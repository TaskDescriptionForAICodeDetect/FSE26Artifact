[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i) \n#define rep(i, n) REP(i, 0, n)\n\n#define X real()\n#define Y imag()\n#define curr(P, i) P[(i)%(P).size()]\n#define next(P, i) curr(P, i+1)\n#define prev(P, i) curr(P, (i)-1+(P.size()))\n\nusing D = double;\nusing P = complex<D>;\nusing G = vector<P>;\nconst D EPS = 1e-8;\nnamespace std {\n    bool operator <(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\nD dot(const P& a, const P& b) {\n    return (conj(a)*b).X;\n}\nD cross(const P& a, const P& b) {\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\nP crossPoint(const L& l, const L& m) {\n    D A = cross(l[1] - l[0], m[1] - m[0]);\n    D B = cross(l[1] - l[0], l[1] - m[0]);\n    if(abs(A) < EPS && abs(B) < EPS) return m[0];\n    if(abs(A) < EPS) assert(false);\n    return m[0] + B / A *(m[1] - m[0]);\n}\nG convexCut(const G& P, const L& l) {\n    G Q;\n    rep(i, P.size()) {\n        auto A = curr(P, i);\n        auto B = next(P, i);\n        if(ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0) Q.push_back(crossPoint(L(A, B), l));\n    }\n    return Q;\n}\n\n\n\nint main() {\n    int n;\n    while(cin >> n) {\n        if(n == 0) break;\n        G ps;\n        rep(i, n) {\n            D x, y;\n            cin >> x >> y;\n            ps.push_back({x, y});\n        }\n        {\n            D l = (D)0.0, r = (D)2e4;\n            auto moveL = [&](D m, const L& l) {\n                auto v = l[1]-l[0];\n                v *= P{0, 1};\n                v /= (D)abs(v);\n                v *= (m);\n                return L{l[0]+v, l[1]+v};\n            };\n            auto check = [&](D m) {\n                auto g = ps;\n                rep(i, n) {\n                    L l = {curr(ps, i), next(ps, i)};\n                    g = convexCut(g, moveL(m, l));\n                    if(g.empty()) return false;\n                }\n                return true;\n            };\n            rep(i, 1024) {\n                D m = (l+r)/2.0;\n                if(check(m)) l = m;\n                else r = m;\n            }\n            printf(\"%.15lf\\n\", l);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<cassert>\n#include<complex>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n//---------------\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//テ「ツ?サテッツスツイテッツスツケテッツセツ津ッツセツ敕」ツ?ォテゥツ卍静」ツつ?\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x;}\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y;}\n\ndouble abs(Point a){return sqrt(norm(a));}\n\nbool pequals(Point a,Point b){ return equals(a.x,b.x) && equals(a.y,b.y); }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nSegment slideSeg(Segment seg,double r)\n{\n  Point p = (seg.p2-seg.p1)*r/abs(seg.p2-seg.p1);\n  p = rotate(p,toRad(90.0));\n  seg = Segment(seg.p1+p,seg.p2+p);\n  if(fabs(seg.p1.x) < EPS)seg.p1.x = 0;\n  if(fabs(seg.p1.y) < EPS)seg.p1.y = 0;\n  if(fabs(seg.p2.x) < EPS)seg.p2.x = 0;\n  if(fabs(seg.p2.y) < EPS)seg.p2.y = 0;\n  return seg;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }\n    return u;\n}\n\n\n//---------------\n\nint n;\n\nbool check(vector<Point> ps,double d)\n{\n  Polygon poly = ps;\n  rep(i,n)\n    {\n      Segment seg = Segment(ps[i],ps[(i+1)%n]);\n      seg = slideSeg(seg,d);\n      poly = cutPolygon(poly,seg);\n    }\n  return poly.empty();\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      vector<Point> ps(n);\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n\n      double L,R,M;\n      L = 0;\n      R = inf;\n      rep(_,100)\n\t{\n\t  M = (L+R)*0.5;\n\t  if(check(ps,M))R = M;\n\t  else           L = M;\n\t}\n\n      cout << setiosflags(ios::fixed) << setprecision(10) << M << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tVP p(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { x,y };\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tvector<L> l(n);\n\t\trep(i, n)l[i] = { p[i],p[(i + 1) % n] };\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tP a = is_ll(l[i], l[j]), b = is_ll(l[j], l[k]), c = is_ll(l[k], l[i]);\n\t\t\tif (ccw(a, b, c) != 0 && ccw(a, b, c) != ccw(l[i].a, l[j].a, l[k].a))continue;\n\t\t\tdouble t1 = atan2((l[i].a - l[i].b).imag(), (l[i].a - l[i].b).real()), t2 = atan2((l[j].a - l[j].b).imag(), (l[j].a - l[j].b).real()), t3 = atan2((l[k].a - l[k].b).imag(), (l[k].a - l[k].b).real());\n\t\t\tt2 = (t1 + t2) / 2;\n\t\t\tt3 = (t1 + t3) / 2;\n\t\t\tL l1 = (isis_ls(L{ a,a + 1e5l*P(cos(t2),sin(t2)) }, L{ b,c })) ? L{ a,a + 1e5l*P(cos(t2),sin(t2)) } : L{ a,a + 1e5l*P(-sin(t2),cos(t2)) };\n\t\t\tL l2 = (isis_ls(L{ c,c + 1e5l*P(cos(t3),sin(t3)) }, L{ a,b })) ? L{ c,c + 1e5l*P(cos(t3),sin(t3)) } : L{ c,c + 1e5l*P(-sin(t3),cos(t3)) };\n\t\t\tcmin(ans, dist_lp(l[i], is_ll(l1, l2)));\n\t\t}\n\t\tcout << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < EPS) return 2;\n  if(abs(b) + EPS < abs(c)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble area(Poly p){\n  int n = p.size();\n  double s = 0;\n  for(int i = 1; i < n-1; ++i){\n    s += cross(p[i]-p[0],p[i+1]-p[0])/2;\n  }\n  return s;\n}\n\n/*\ndouble solve(Poly p){\n  double s = area(p), l = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    l += abs(p[i]-p[(i+1)%n]);\n  }\n  return 2*s/l;\n}\n*/\n\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double ret = INF;\n  for(int i = 0; i < n; ++i){\n    double t = 0;\n    for(int j = 0; j < n; ++j){\n      t = max(t, p_to_s_dist(p[j],L(p[i],p[(i+1)%n])));\n    }\n    ret = min(ret, t);\n  }\n  return ret;\n}\n*/\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//辺上\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//内部\n  return 0;//外部\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角abcをの二等分線\n  //a, b or b, cが一致するとゼロ徐算が発生しREになる\n  P p = b + (a-b)/abs(a-b)*100.0 + (c-b)/abs(c-b)*100.0;\n  return L(b,p);\n}\n\ndouble solve(Poly p){\n  int n = p.size();\n  vector<L> ab;\n  for(int i = 0; i < n; ++i){\n    ab.push_back(angle_bisector(p[i],p[(i+1)%n],p[(i+2)%n]));\n  }\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = i+1; j < n; ++j){\n      if(abs(cross(ab[i].second-ab[i].first,ab[j].second-ab[j].first)) < EPS) continue;\n      P x = intersection(ab[i],ab[j]);\n      if(in_poly(x,p)) cp.push_back(x);\n    }\n  }\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double l = 0.0, r = (1e10);\n  for(int i = 0; i < 100000; ++i){\n    //for(int i = 0; i < 3; ++i){\n    double m1 = (l+r)/3, m2 = (l+r)*2/3;\n    Poly q1, q2;\n    for(int j = 0; j < n; ++j){\n      P d1 = n_vector(p[(j+1)%n]-p[j])*m1, d2 = n_vector(p[(j+2)%n]-p[(j+1)%n])*m1;\n      L e1 = L(p[j]+d1,p[(j+1)%n]+d1), e2 = L(p[(j+1)%n]+d2,p[(j+2)%n]+d2);\n      q1.push_back(intersection(e1,e2));\n\n      P d3 = n_vector(p[(j+1)%n]-p[j])*m2, d4 = n_vector(p[(j+2)%n]-p[(j+1)%n])*m2;\n      L e3 = L(p[j]+d3,p[(j+1)%n]+d3), e4 = L(p[(j+1)%n]+d4,p[(j+2)%n]+d4);\n      q2.push_back(intersection(e3,e4));\n    }\n    double s1 = 0, s2 = 0;\n    for(int j = 0; j < n; ++j){\n      s1 += cross(q1[j],q1[(j+1)%n]);\n      s2 += cross(q2[j],q2[(j+1)%n]);\n    }\n    //printf(\"s1 = %.12f, s2 = %.12f\\n\",s1,s2);\n    if(abs(s1) < abs(s2)) r = m2;\n    else l = m1;\n  }\n  return (l+r)/2;\n}\n*/\n\nint main(){\n  int n;\n  double x, y;\n  while(cin >> n, n){\n    Poly p;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    printf(\"%.6lf\\n\",solve(p));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n\tif(points.size()==1)return false;\n\tvector<P> v;\n\tfor(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n\tint sign=0;\n\tfor(int i=1;i<=(int)v.size();i++){\n\t\tint prv=(i-1+v.size())%v.size();\n\t\tint cur=i%v.size();\n\t\tdouble c=cross(v[prv],v[cur]);\n\t\tif(EQ(c,0))continue;\n\t\telse if(sign==0){\n\t\t\tif(c>0)sign=1;\n\t\t\telse sign=-1;\n\t\t}\n\t\telse{\n\t\t\tif(sign==-1&&c>0)return false;\n\t\t\telse if(sign==1&&c<0)return false;\n\t\t}\n\t}\n\treturn true;\n}\nstruct Rec{\n\tvector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // 線分が平行な場合は重なっていないことにする\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n\t// aの各頂点がbの中に存在しているかチェック\n\tfor(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n\t// 逆\n\tfor(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n\t// 各辺が他方のどれかの辺と接しているか\n\tfor(int i=0;i<4;i++){\n\t\tint curi=i;\n\t\tint prvi=(i-1+4)%4;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint curj=j;\n\t\t\tint prvj=(j-1+4)%4;\n\t\t\tif(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n\t\t}\n\t}\n\treturn false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n\treturn p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n/*\n円周と線分の交差判定\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // 線分が中に含まれるとき、ここのコメントアウトをはずせばtrue(交差)となる\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// 三角形の内部に点があるかどうか\n// 外積の正負がすべて同じなら内部に点あり\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// 矩形の中に点が存在するかどうか\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// 三角形の面積を座標から計算\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// 与えられた円の範囲内に点が存在するかどうか\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn abs(sum/2);\n}\n// 2ベクトル間の角度\n// aからbへ左周りで何度か(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n// 2つのベクトルの重なっている部分の長さを返す\n// もし重なっていなければ0を返す\ndouble multipleLength(P a,P b,P c,P d){\n    Edge e1=make_pair(a,b);\n    Edge e2=make_pair(c,d);\n    // 平行であるかどうか\n    if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n        &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n        return 0;\n    double dist=0;\n    // 両方乗っている\n    if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0))\n        dist=abs(e2.first-e2.second);\n    else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0))\n        dist=abs(e1.first-e1.second);\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n        // どちらが線上にあるか\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.first);\n        else\n            dist=abs(e1.second-e2.first);\n    }\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.second);\n        else\n            dist=abs(e1.second-e2.second);\n    }\n    return dist;\n}\n// 2点を通る半径rの円の中点を求める\npair<P,P> calcCircleCenterPoint(P dot1,P dot2,double r){\n    double v=abs(dot1-dot2);\n    double x = sqrt(r*r - (v/2)*(v/2));\n    // 二組の単位法線ベクトル\n    P hose[2];\n    double x1=-(dot1.imag()-dot2.imag());\n    double y1=(dot1.real() - dot2.real());\n    hose[0]=P(x1,y1);\n    double y2=-y1;\n    double x2=-x1;\n    hose[1]=P(x2,y2);\n    double dd1=abs(hose[0]);\n    double dd2=abs(hose[1]);\n    hose[0]/=dd1;hose[0]*=x;\n    hose[1]/=dd2;hose[1]*=x;\n    P tmp=(dot1+dot2);\n    tmp/=2;\n    hose[0]+=tmp;\n    hose[1]+=tmp;\n    return make_pair(hose[0],hose[1]);\n}\n// 4線分が端点以外でクロスしているかどうかを判定\nbool checkCross(const vector<Edge> &vec){\n    for(int i=0;i<vec.size();i++){\n        for(int j=i+1;j<vec.size();j++){\n            // 線分がクロスしているかどうか\n            if(is_intersected_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second)){\n                // している場合、端点以外でクロスしているなら、false\n                P p=intersection_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second);\n                if(!(EQ(p,vec[i].first)||EQ(p,vec[i].second)))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n// 引き数で与えられた4つの点が矩形を作るどうかを判定\nbool checkRec(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ここですべての線分がクロスするかどうかを計算\n        if(checkCross(ve)){\n            // 線分の長さを確認\n            if(EQ(abs(ve[0].first-ve[0].second),abs(ve[2].first-ve[2].second)))\n                if(EQ(abs(ve[1].first-ve[1].second),abs(ve[3].first-ve[3].second)))\n                    // 直行\n                    if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                        if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                        return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// 引き数で与えられた4つの点が正方形を作るかどうかを判定\nbool checkSqu(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ここですべての線分がクロスするかどうかを計算\n        if(checkCross(ve)){\n            // 線分の長さを確認\n            double d=abs(ve[0].first-ve[0].second);\n            for(int i=1;i<4;i++){\n                double d2=abs(ve[i].first-ve[i].second);\n                if(!EQ(d,d2))return false;\n            }\n            // 直行確認\n            if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                    return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// 二円の共通接線を構成する4直線を求める(二円はお互い接したりどちらかをふくんだりしない)\nvector<pair<P,P> > calcCommonTangentialLine(P p1,double r1,P p2,double r2){\n\tvector<pair<P,P> > res;\n\tif(r1>r2){\n\t\tswap(r1,r2);\n\t\tswap(p1,p2);\n\t}\n\t// 共通外接線\n\t{\n\t\tdouble d=abs(p1-p2);\n\t\tdouble a=abs(r1-r2);\n\t\tdouble b=sqrt(d*d-a*a);\n\t\tdouble sita=acos(b/d);\n\t\tP e=normalVector(roundPoint((roundPoint((p2-p1),sita)),PI/2));\n\t\tres.push_back(make_pair(e*r1+p1,e*r2+p2));\n\t\tP e2=normalVector(roundPoint((roundPoint((p2-p1),-sita)),-PI/2));\n\t\tres.push_back(make_pair(e2*r1+p1,e2*r2+p2));\n\t}\n\t// 共通内接線\n\t{\n\t\tP cp=(r1*p1+r2*p2)/(r1+r2);\n\t\tdouble u=abs(cp-p1);\n\t\tdouble sita=acos(r1/u);\n\t\tP e=normalVector(roundPoint(cp-p1,sita));\n\t\tres.push_back(make_pair(e*r1+p1,-e*r2+p2));\n\t\tP e2=normalVector(roundPoint(cp-p1,-sita));\n\t\tres.push_back(make_pair(e2*r1+p1,-e2*r2+p2));\n\t}\n\treturn res;\n}\n/*\n  与えられた3点a,b,c,をa->b->cと進むとき\n  a->bで時計方向に折れて,b->c\n  a->bで半時計方向に折れて,b->c\n  a->bで逆を向いてaを通り越してb->c\n  a->bでそのままb->c\n  a->bで逆を向いてb->c\n  のどれであるかを判定\n*/\nint ccw(P a,P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0&&!EQ(cross(b,c),0))return 1;// counter clockwise\n  if(cross(b,c)<0&&!EQ(cross(b,c),0))return -1;// clockwise\n  if(dot(b,c)<0&&!EQ(dot(b,c),0))return 2; // c-a-b on line\n  if(!EQ(abs(b),abs(c))&&abs(b)<abs(c))return -2; // a-b-c on line\n  return 0;\n}\n// 凸多角形の切断を行う\n// lineのfirst側から見て左の多角形が返る\n// 多角形は上が+y,右が+xの座標系で座標を時計周りに格納したvectorで表す\n// lineは基本的にmakeDivisorで作成\nvector<P> convex_cut(vector<P> polygon,pair<P,P> line){\n  vector<P> resPolygon;\n  int n=polygon.size();\n  for(int i=0;i<n;i++){\n    P A=polygon[i];\n    P B=polygon[(i+1)%n];\n    if(ccw(line.first,line.second,A)!=-1)\n      resPolygon.push_back(A);\n    if(ccw(line.first,line.second,A)*ccw(line.first,line.second,B)<0)\n      resPolygon.push_back(intersection_l(A,B,line.first,line.second));\n  }\n  return resPolygon;\n}\n// convex_cutの補助関数\n// a側の凸多角形を残すような切断ラインを作成\npair<P,P> makeDivisor(P a, P b){\n  P mid=(a+b);mid/=2;\n  P base=unitNormalVector(b-a);\n  base*=-1000000;\n  P p1=base;p1+=mid;\n  base*=-1;\n  P p2=base;p2+=mid;\n  return make_pair(p1,p2);\n}\n\nint n;\nP ps[101];\nint main(){\n\n  while(cin>>n&&n){\n    vector<P> pol;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      ps[i]=P(x,y);\n      pol.push_back(ps[i]);\n    }\n    reverse(pol.begin(),pol.end());\n    reverse(ps,ps+n);\n    vector<P> initPol=pol;\n    double ub=1000000000;\n    double lb=0;\n    const int lim=200;\n    for(int p=0;p<lim;p++){\n      double mid=(ub+lb)/2;\n      //cout<<mid<<endl;\n      // convexcutを線分ごとに繰り返して,点が残るかチェック\n      for(int i=0;i<n;i++){\n\tP tmp=(ps[(i+1)%n]-ps[i]);tmp/=abs(tmp);\n\ttmp=-P(-tmp.imag(),tmp.real());tmp*=mid;\n\tP p1=tmp;p1+=ps[i];\n\tP p2=tmp;p2+=ps[(i+1)%n];\n\t//cout<<p1<<\" \"<<p2<<endl;\n\tP tmp2=(p2-p1);tmp2/=abs(tmp2);tmp2*=100000;\n\tp2+=tmp2;\n\ttmp2*=-1;\n\tp1+=tmp2;\n\tpol=convex_cut(pol,make_pair(p2,p1));\n\t// cout<<i<<\" \"<<pol.size()<<endl;\n\t// cout<<p1<<\" \"<<p2<<endl;\n      }\n      if(pol.size()>0)lb=mid;\n      else ub=mid;\n      pol=initPol;\n    }\n    printf(\"%.10f\\n\",ub);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\ntypedef complex<double> cmp;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n//const int dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\nconst int dir[]={1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ndouble Cross(const cmp &a,const cmp &b){\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble DistanceLP(const cmp &a,const cmp &b,const cmp &c){\n\treturn abs(Cross(b-a,c-a))/abs(b-a);\n}\n\ndouble GetMinDistanceLP(const vector<cmp> &p,const cmp &a){\n\tdouble res=INF;\n\tREP(i,1,p.size()) res=min(res,DistanceLP(p[i],p[i-1],a));\n\tres=min(res,DistanceLP(p[0],p[p.size()-1],a));\n\treturn res;\n}\n\ncmp CenterOfGravity(const vector<cmp> &p){\n\tdouble resx=0,resy=0;\n\tREP(i,0,p.size()){\n\t\tresx+=p[i].real();\n\t\tresy+=p[i].imag();\n\t}\n\treturn cmp(resx/p.size(),resy/p.size());\n}\n\ninline double GetStep(const double max_cnt,const double cnt,const double score){\n\tconst double rate=((max_cnt-cnt)/max_cnt)*((max_cnt-cnt)/max_cnt);\n\treturn cnt/max_cnt*((1e-7)-score*rate)+score*rate;\n}\n\ndouble Solve(const vector<cmp> &p){\n\tcmp a=CenterOfGravity(p);\n\tdouble best_score=GetMinDistanceLP(p,a);\n\tconst int max_cnt=100000;\n\trandom_device seed_gen;\n\tmt19937 engine(seed_gen());\n\tREP(cnt,0,max_cnt){\n\t\tconst double step=GetStep(max_cnt,cnt,best_score);\n\t\tconst int signx=dir[engine()%3];\n\t\tconst int signy=dir[engine()%3];\n\t\tcmp next_a(a.real()+signx*step,a.imag()+signy*step);\n\t\tdouble next_score=GetMinDistanceLP(p,next_a);\n\t\tif(next_score>=best_score){\n\t\t\tbest_score=next_score;\n\t\t\ta=next_a;\n\t\t}\n\t}\n\treturn best_score;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile(true){\n\t\tcin >> N;\n\t\tif(!N) break;\n\t\tvector<cmp> p(N);\n\t\tREP(i,0,N){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tprintf(\"%.5f\\n\",Solve(p));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometry {ABC=-2, CW, ACB, CCW, CAB, ON_LINE, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometry ccw(Point a, Point b, Point c) {\n  a -= b;\n  c -= b;\n  if (cross(a, c) > EPS) return CCW; // ccw\n  if (cross(a, c) < -EPS) return CW; // cw\n  if (dot(a, c) < -EPS) return ABC; // a - b - c\n\n  double al = abs(a);\n  double cl = abs(c);\n  if (EQ(al, cl)) return ERROR; // a and c are duplicate\n  if (EQ(min(al, cl), 0)) return ERROR;\n  if (al < cl) return CAB; // c - a - b\n  else return ACB; // a - c - b\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  // hard coding: CW := -1, CCW := 1 -> only CW*CW and CCW*CCW are equal to 1\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  swap(s, t);\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  if (!IsParallel(s, t)) return true;\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  swap(s, t);\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  Point a = s[0];\n  Point b = s[1];\n  return abs(a-p)+abs(b-p)-abs(a-b) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  swap(s, t);\n  double b = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (EQ(d, c.r)) {\n    ret.emplace_back(proj(l, c.c));\n  } else if (d < c.r) {\n    double ratio = sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  Point a = s[0];\n  Point b = s[1];\n  if (a > b) swap(a, b);\n  for (Point p : res) {\n    if (\n      LE(a, p) \n      && \n      LE(p, b)) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (!GE(ad, min(bd, c.r))) cros.emplace_back(s[0]);\n    else if (!GE(bd, min(ad, c.r))) cros.emplace_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.emplace_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\nGeometry PositioningPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (LE(u.Y, 0) && !GE(0, v.Y) && cr >= EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  if (ps.size() <= 2) return ps;\n\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\nbool IsConvex(Poly ps) {\n  //return GrahamScan(ps).size() == ps.size();\n  return GrahamScan(ps) == ps;\n}\n\nPoly CapConvexes(Poly pp, Poly qq) {\n#if DEBUG\n  assert (IsConvex(pp));\n  assert (IsConvex(qq));\n#endif\n\n  Poly ret;\n  int a = 0;\n  int b = 0;\n  int aa = 0;\n  int bb = 0;\n  int n = pp.size();\n  int m = qq.size();\n  enum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n  auto forward_a = [&](bool put) {\n    if (put && in == PIN) ret.emplace_back(pp[a]);\n    a = (a+1)%n;\n    aa++;\n  };\n\n  auto forward_b = [&](bool put) {\n    if (put && in == QIN) ret.emplace_back(qq[b]);\n    b = (b+1)%m;\n    bb++;\n  };\n\n  auto intersect_1pt = [](Point &a, Point &b, Point &c, Point &d, Point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n  };\n\n  do {\n    int apre = (a+n-1)%n;\n    int bpre = (b+m-1)%m;\n    double C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n    double A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n    double B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n    Point r;\n    if (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n      if (in == UNKNOWN) aa = bb = 0;\n      ret.emplace_back(r);\n      if (B > 0) in = PIN;\n      else if (A > 0) in = QIN;\n    }\n\n    if (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n      if (in == PIN) forward_b(false);\n      else forward_a(false);\n    } else if (C >= 0) {\n      if (A > 0) forward_a(true);\n      else forward_b(true);\n    } else {\n      if (B > 0) forward_b(true);\n      else forward_a(true);\n    }\n  } while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n  if (in == UNKNOWN) {\n    if (PositioningPoint(qq, pp[0]) != OUTSIDE) return pp;\n    if (PositioningPoint(pp, qq[0]) != OUTSIDE) return qq;\n  }\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nvector<Point> TangentPoints(Circle c, Point p) {\n  vector<Point> ret;\n  double d = abs(c.c-p);\n  if (EQ(d, c.r)) {\n    ret.emplace_back(p);\n    return ret;\n  }\n\n  if (d < c.r) return ret;\n\n  Vec v = (p-c.c)/d*c.r;\n  double t = acos(c.r/d);\n  ret.emplace_back(c.c + rotate(v, t));\n  ret.emplace_back(c.c + rotate(v, -t));\n  return ret;\n}\n\nvector<Line> CommonTangents(Circle p, Circle q) {\n#if DEBUG\n  assert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n  double pr = p.r;\n  double qr = q.r;\n  Point pc = p.c;\n  Point qc = q.c;\n  double d = abs(pc - qc);\n  double dr = abs(pr - qr);\n  double sr = abs(pr + qr);\n\n  vector<Line> ret;\n  if (EQ(d, sr)) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > sr) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    vector<Point> pts = TangentPoints(p, cp);\n    vector<Point> qts = TangentPoints(q, cp);\n    for (int i=0; i<2; i++) {\n      Line l{pts[0], qts[i]};\n      if (IntersectLP(l, cp)) {\n        ret.emplace_back(l);\n        ret.emplace_back(Line{pts[1], qts[i^1]});\n      }\n    }\n  } \n\n  if (EQ(d, dr)) {\n    Point cp = pc + (pc-qc) / (qr-pr) * pr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > dr) {\n    if (EQ(pr, qr)) {\n      Point v = (qc - pc) / d * pr;\n      v *= Point(0, 1);\n      ret.emplace_back(Line{pc+v, qc+v});\n      ret.emplace_back(Line{pc-v, qc-v});\n    } else {\n      Point cp = pc + (qc-pc) * pr / (pr-qr);\n      vector<Point> pts = TangentPoints(p, cp);\n      vector<Point> qts = TangentPoints(q, cp);\n      for (int i=0; i<2; i++) {\n        Line l{pts[0], qts[i]};\n        if (IntersectLP(l, cp)) {\n          ret.emplace_back(l);\n          ret.emplace_back(Line{pts[1], qts[i^1]});\n          break;\n        }\n      }\n    }\n  } \n\n  return ret;\n}\n\nint N;\nvector<Point> ps;\n\nbool check(double x) {\n  vector<Line> ls;\n  for (int j=0; j<N; j++) {\n    Line s{ps[j], ps[(j+1)%N]};\n      \n    Vec u = (s[1]-s[0]);\n    u = (u/abs(u))*x;\n    s[0] += rotate(u, PI/2);\n    s[1] += rotate(u, PI/2);\n    ls.emplace_back(s);\n  }\n\n  for (Line &l : ls) {\n    for (Line &m : ls) {\n      if (IsParallel(l, m)) continue;\n      if (!IntersectSS(l, m)) continue;\n      Point p = CrossPointLL(l, m);\n      double d = INF;\n      for (int i=0; i<N; i++) {\n        Line s{ps[i], ps[(i+1)%N]};\n        d = min(d, DistSP(s, p));\n      }\n      if (GE(d, x)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n    ps.clear();\n    for (int i=0; i<N; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      ps.emplace_back(Point(x, y));\n    }\n  \n    double low = 0;\n    double high = 100000;\n    for (int i=0; i<50; i++) {\n      double mid = (low+high)/2;\n      if (check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.20f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> res;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) res.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      res.push_back(crossPoint(L(A,B), l));\n  }\n  return res;\n}\n\nbool check(vector<P> G,double d){\n  vector<P> pol=G;\n  int n=G.size();\n  for(int i=0;i<n;i++){\n    P a=G[i],b=G[(i+1)%n],c=(b-a);\n    b=P(abs(c),d)*(c/abs(c))+a;\n    a=b-c;\n    pol=convex_cut(pol,L(a,b));\n    if(pol.size()<3)return 0;\n  }\n  return  1;\n}\n\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> pol(n);\n    for(int i=0,x,y;i<n;i++){\n      cin>>x>>y;\n      pol[i]=P(x,y);\n    }\n    double L=0,M,R=1e4;\n    while(L<R){\n      M=(L+R)/2;\n      if(!check(pol,M)) R=M-EPS;\n      else L=M+EPS;\n    }\n    printf(\"%lf\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  \n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator<(const Point &p) const{\n    return x!=p.x? x< p.x : y < p.y;\n  }\n\n  bool operator==(const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS ;\n  }\n};\n\ntypedef Point Vector;\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\ntypedef vector<Point> Polygon;\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nVector half(Vector a,Vector b){\n  return (a*b.abs()+b*a.abs())*1000;\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\nint contains(Polygon g, Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b) < EPS && dot(a,b) < EPS)) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n  }\n  return (x?2:0);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p;\n    p.clear();\n    double x,y;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf %lf\",&x,&y);\n      p.push_back(Point(x,y));\n    }\n\n    double ans=0,b;\n    \n    Point g;\n    \n    for(int i=0;i<n;i++){\n      for(int k=0;k<n;k++){\n\tif(i==k) continue;\n\tg=getCrossPoint(Segment(p[i],p[i]+half(p[(i+n-1)%n]-p[i],p[(i+1)%n]-p[i])),\n\t\t\tSegment(p[k],p[k]+half(p[(k+n-1)%n]-p[k],p[(k+1)%n]-p[k])));  \n\tif(contains(p,g)==0) continue;\n\tb=getDistanceLP(Segment(p[0],p[1]),g);\n\tfor(int j=1;j<n;j++){\n\t  b=min(b,getDistanceLP(Segment(p[j],p[(j+1)%n]),g));\n\t}\n\tans=max(ans,b);\n      }\n    }\n    \n    //cout << ans << endl;\n  \n    printf(\"%.6lf\\n\",ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n\ntypedef double FP;\n\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.second-a.first);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.first,a.second,b.first,b.second);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.first,a.second,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\n\nvoid check(P a){\n\n  assert(!isnan(a.real()));\n  assert(!isnan(a.imag()));\n}\n\nvoid check(line a){\n  check(a.first);\n  check(a.second);  \n}\n\nbool para(line a, line b){\n  P av = a.first - a.second;\n  P bv = b.first - b.second;\n  return abs(dot(av/abs(av),bv/abs(bv))) > 1 - 1e-9;\n}\n\ndouble tri(P a, P b, P c){\n  a -= c;\n  b -= c;\n  return abs(crs(a,b));\n}\n\nline midline(line a,line b){\n  if(!para(a,b)){\n    P av = a.second - a.first;\n    P bv = b.second - b.first;\n    av /= abs(av);\n    bv /= abs(bv);\n    auto ret = line(crspt(a,b),crspt(a,b)+av+bv);\n    check(ret);\n    return ret;\n  }\n  P st =(a.first+b.first)/2.;\n  auto ret = line(st, st + a.second - a.first);\n  check(ret);\n  return ret;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n && n){\n    int x[n], y[n];\n    for(int i = 0; i < n; ++i)\n      cin >> x[i] >> y[i];\n    double cx = accumulate(x,x+n,0.)/n;\n    double cy = accumulate(y,y+n,0.)/n;\n      \n    double ans = 0;\n    for(int i = 0; i < n; ++i){\n      \n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        double r = 10000000000;\n        for(int k = 0; k < n; ++k){\n          if(i == k || j == k) continue;\n          line il = line(P(x[i],y[i]), P(x[(i+1)%n],y[(i+1)%n]));\n          line jl = line(P(x[(j+1)%n],y[(j+1)%n]), P(x[j],y[j]));\n          line kl = line(P(x[(k+1)%n],y[(k+1)%n]), P(x[k],y[k]));\n          line ij = midline(il, jl);\n          line ik = midline(il, kl);\n          // if(!iscrs(ij, ik)){\n          //   cout << ij << \"  \" << ik << endl;\n          //   continue;\n          // }\n          P ce = crspt(ij,ik);\n          if(!isnormal(ce.real()) || !isnormal(ce.imag())){\n            //cout << ce << endl;\n            continue;\n          }\n          double me = 0;\n          double me2 = 0;\n          for(int ii = 0; ii < n; ++ii){\n            me += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),ce);\n            me2 += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),P(cx,cy));\n          }\n          \n          if(abs(me-me2)/max(me,me2) > EPS){\n            //cout << me << \" \" << me2 << endl;\n            continue;\n          }\n          \n          double tr = 10000000000;\n          for(int ii = 0; ii < n; ++ii){\n            line l(P(x[ii],y[ii]),P(x[(ii+1)%n],y[(ii+1)%n]));\n            tr = min(tr, lpdist(l,ce));\n          }\n          ans = max(tr, ans);\n          //cout << ce << endl;\n          double cr = lpdist(il,ce);\n          r = min(r, cr);\n        }\n        //ans = max(r, ans);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-12;\nconst double inf = 1000000;\n\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea2(const vector<P> &g) {\n  int n = g.size();\n  double s = 0;\n  for(int i = 0; i < n; ++i) {\n    s += cross(g[i], g[(i+1)%n]);\n  }\n  return s;\n}\n\nint main() {\n  int n;\n  vector<P> base;\n  base.push_back(P(-inf,-inf));\n  base.push_back(P(inf,-inf));\n  base.push_back(P(inf,inf));\n  base.push_back(P(-inf,inf));\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l, r;\n    l = 0.0;\n    r = inf;\n    while(!equals(l, r)) {\n      double d = (l+r)/2.0;\n      vector<P> g = base;\n      for(int i = 0; g.size() > 2 && i < n; ++i) {\n\tint s = i;\n\tint t = (i+1)%n;\n\tP v = ps[t] - ps[s];\n\tP u = P(-v.imag(), v.real());\n\tg = convex_cut(g, ps[s]+u*d/abs(u), ps[t]+u*d/abs(u));\n      }\n      if(g.size() == 0) {\n\tr = d;\n      } else {\n\tl = d;\n      }\n    }\n    printf(\"%.6f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n    Point operator-() const { return Point(-x, -y); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nstruct Segment {\n    Point a, b;\n    Segment() {}\n    Segment(const Point& a, const Point& b) : a(a), b(b) {}\n};\nPoint projection(const Segment& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\nbool intersects(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\ndouble dist(const Segment& s, const Point& p) {\n    Point q = projection(Segment(s.a, s.b), p);\n    Segment t(p, q);\n    if (intersects(s, t)) return norm(t.b - t.a);\n    return min(norm(s.a - p), norm(s.b - p));\n}\nPoint crosspoint(const Segment& s, const Segment& t) {\n    assert(intersects(s, t));\n    Point u = s.b - s.a,\n          v = t.b - t.a;\n    return s.a - u * cross(v, t.a - s.a) / cross(u, v);\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point& p, double r) : p(p), r(r) {}\n};\nostream& operator<<(ostream& os, const Circle& c) {\n    return os << \"Circle[\" << c.p << \",\" << c.r << \"]\";\n}\n\ntypedef vector<Point> Polygon;\n\nbool contains(const Polygon& c, const Point& p) {\n    int n = int(c.size());\n    int x = ccw(p, c[0], c[1]);\n    for (int i = 0; i < n; i++) {\n        Point a = c[i];\n        Point b = c[(i + 1) % n];\n        if (x != ccw(p, a, b)) return false;\n    }\n    return true;\n}\n\nbool contains(const Polygon& c, const Circle& cir) {\n    if (!contains(c, cir.p)) { return false; }\n    int n = int(c.size());\n    for (int i = 0; i < n; i++) {\n        Point a = c[i];\n        Point b = c[(i + 1) % n];\n        Segment s(a, b);\n        if (dist(s, cir.p) + EPS < cir.r) return false;\n    }\n    return true;\n}\n\nvoid add_moved_segment(const Segment& s, double r, vector<Segment>& ss) {\n    Point v = s.b - s.a;\n    Point u = rot90(v) / norm(v) * r;\n    ss.push_back(Segment(s.a + u, s.b + u));\n    u = -rot90(v) / norm(v) * r;\n    ss.push_back(Segment(s.a + u, s.b + u));\n}\n\nint N;\nvector<Point> P;\n\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    P.clear(); P.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i];\n    }\n    return true;\n}\n\nconst double INF = 1e5;\n\nbool C(double r) {\n    vector<Segment> ss;\n    for (int i = 0; i < N; i++) {\n        Segment e(P[i], P[(i + 1) % N]);\n        add_moved_segment(e, r, ss);\n    }\n    int M = int(ss.size());\n    vector<Point> ps;\n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            if (!intersects(ss[i], ss[j])) continue;\n            ps.push_back(crosspoint(ss[i], ss[j]));\n        }\n    }\n    for (int i = 0; i < ps.size(); i++) {\n        Point& p = ps[i];\n        if (contains(P, Circle(p, r))) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    double lb = 0, ub = INF;\n    for (int _ = 0; _ < 50; _++) {\n        double mid = (lb + ub) / 2;\n        (C(mid) ? lb : ub) = mid;\n    }\n    printf(\"%.12lf\\n\", lb);\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea(const vector<P> &g) {\n  int n = g.size();\n  double s = 0;\n  for(int i = 0; i < n; ++i) {\n    s += cross(g[i], g[(i+1)%n]);\n  }\n  return s/2.0;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l, r;\n    l = 0.0;\n    r = 100000.0;\n    while(!equals(l, r)) {\n      double d = (l+r)/2.0;\n      vector<P> g = ps;\n      for(int i = 0; i < n; ++i) {\n\tint s = i;\n\tint t = (i+1)%n;\n\tP v = ps[t] - ps[s];\n\tP u = P(-v.imag(), v.real());\n\tu /= abs(u);\n\tg = convex_cut(g, ps[s]+u*d, ps[t]+u*d);\n      }\n      if(equals(getArea(g), 0.0)) {\n\tr = d;\n      } else {\n\tl = d;\n      }\n    }\n    printf(\"%.6f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g = (ps[0] + ps[n/3] + ps[2*n/3]) / 3.0;\n    int a = 0, b = n;\n    while (a+1 < b) {\n        int c = (a + b) / 2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    double mx=inf,Mx=-inf;\n    double my=inf,My=-inf;\n    rep(i,n){\n        mx=min(mx,ps[i].real());\n        my=min(my,ps[i].imag());\n        Mx=max(Mx,ps[i].real());\n        My=max(My,ps[i].imag());\n    }\n    double const r[]={10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7};\n    double static d[128];\n    int near=0;\n    rep(t,90000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n)if(d[i]<d[near]){\n            near=i;\n        }\n        P h=projection(es[near],p);\n        P np=p-(h-p)/d[near]*r[t/10000];\n        if(convex_contains(np)==IN){\n            swap(p,np);\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tPolygon npoly(origin);\n\t\tconst int atime = 1000;\n\t\tfor (int repeat = 0; repeat <=atime; ++repeat) {\n\t\t\tconst Polygon prepoly(npoly);\n\t\t\tPoint center;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tcenter += npoly[i];\n\t\t\t}\n\t\t\tcenter /= npoly.size();\n\t\t\tlong double mindis = 20000;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tmindis = min(mindis, dist_sp(Line(npoly[i], npoly[(i + 1) % npoly.size()]), center));\n\t\t\t}\n\n\n\t\t\tfor (int i = 0; i < prepoly.size(); ++i) {\n\t\t\t\tLine preline = Line(prepoly[i], prepoly[(i + 1) % prepoly.size()]);\n\t\t\t\tPoint vec = (preline[1] - preline[0])*complex<long double>(0, 1)/abs(preline[1]-preline[0])*mindis;\n\t\t\t\tLine cutline[2];\n\t\t\t\tcutline[1] = Line(preline[0] + vec, preline[1] + vec);\n\t\t\t\tcutline[0] = Line(preline[0] - vec, preline[1] - vec);\n\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tvector<Polygon>polys(convex_cut(npoly, cutline[i]));\n\t\t\t\t\tif (is_in_polygon(polys[0], center)) {\n\t\t\t\t\t\tnpoly = polys[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnpoly = polys[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Polygon prepoly(npoly);\n\t\tPoint center;\n\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\tcenter += npoly[i];\n\t\t}\n\t\tcenter /= npoly.size();\n\t\tlong double mindis = 20000;\n\t\tfor (int i = 0; i < origin.size(); ++i) {\n\t\t\tmindis = min(mindis, dist_sp(Line(origin[i], origin[(i + 1) % origin.size()]), center));\n\t\t}\n\t\tcout << fixed<<setprecision(22)<<mindis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\n#include <complex>\nusing namespace std;\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\n\n\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n\tld A = cross(l[1] - l[0], m[1] - m[0]);\n\tld B = cross(l[1] - l[0], l[1] - m[0]);\n\tif(abs(A) < eps && abs(B) < eps) return m[0]; // same line\n\tif(abs(A) < eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n#define curr(pol, i) pol[i]\n#define next(pol, i) pol[(i+1)%pol.size()]\nG convex_cut(const G& pol, const L& l) {\n\tG res;\n\tfor(int i = 0; i < pol.size(); ++i) {\n\t\tP A = curr(pol, i), B = next(pol, i);\n\t\tif(ccw(l[0], l[1], A) != -1) res.push_back(A);\n\t\tif(ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n\t\t\tres.push_back(crosspointLL(L(A, B), l));\n\t}\n\treturn res;\n}\n\nint n;\nG ps;\nvector<L> ls;\nbool check(double x) {\n\tG res = ps;\n\tfor(int i = 0; i < n; i++) {\n\t\tP a = ls[i][1] - ls[i][0];\n\t\tP d = a * polar(x / abs(a), pi / 2);\n\t\tL lx = L(ls[i][0] + d, ls[i][1] + d);\n\t\tres = convex_cut(res, lx);\n\t\tif(res.size() < 3) return false;\n\t}\n\treturn true;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tps.clear();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.push_back(P(x, y));\n\t\t}\n\t\tls.clear();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tls.push_back(L(ps[i], ps[(i + 1) % n]));\n\t\t}\n\n\t\tdouble ok = 0, ng = 1e9;\n\t\tfor(int loop = 0; loop < 200; loop++) {\n\t\t\tdouble x = (ok + ng) / 2;\n\t\t\tif(check(x)) ok = x;\n\t\t\telse ng = x;\n\t\t}\n\n\t\tcout << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n};\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ntypedef vector<point> polygon;\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\nbool intersect(const segment &s, const point &p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint crosspoint(const segment &s, const segment &t) {\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\treturn t.a + (t.b - t.a) * (cross(s.b - s.a, s.b - t.a) / tmp);\n}\n\ndouble dist(const segment &s, const point &p) {\n\tif(dot(s.b - s.a, p - s.a) < 0) return abs(p - s.a);\n\tif(dot(s.a - s.b, p - s.b) < 0) return abs(p - s.b);\n\treturn abs(cross(s.b - s.a, p - s.a)) / abs(s.b - s.a);\n}\n\nbool contain(const polygon &P, const point &p) {\n\tbool res = false;\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tpoint v1 = prev - p, v2 = curr - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n\t\tif(abs(cross(v1, v2)) < EPS  && dot(v1, v2) < EPS) return true;\n\t\tprev = curr;\n\t}\n\treturn res;\n}\n\ndouble dist(const polygon &P, const point &p) {\n\tdouble res = INT_MAX;\n\tpoint prev = P.back();\n\n\tfor(const auto &curr : P) {\n\t\tchmin(res, dist(segment(curr, prev), p));\n\t\tprev = curr;\n\t}\n\n\treturn res;\n}\n\ndouble ternary_search(double L, double R, const function<double(double)> &f) {\n\tfor(int i = 0; i < 60; ++i) {\n\t\tdouble x1 = (L + L + R) / 3.0, x2 = (L + R + R) / 3.0;\n\t\tif(f(x1) < f(x2)) {\n\t\t\tL = x1;\n\t\t}\n\t\telse {\n\t\t\tR = x2;\n\t\t}\n\t}\n\treturn f(L);\n}\n\ndouble search_y(double x, const polygon &P) {\n\tconst segment L(point(x, 0), point(x, 10000));\n\tvector<double> range;\n\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tconst segment s(prev, curr);\n\t\tif(intersect(L, s)) range.emplace_back(crosspoint(L, s).y);\n\t\tprev = curr;\n\t}\n\n\tsort(range.begin(), range.end());\n\trange.erase(unique(range.begin(), range.end()), range.end());\n\n\tif(range.size() == 0) return -1;\n\treturn ternary_search(range.front(), range.back(), [&](double y){ return dist(P, point(x, y)); });\n}\n\ndouble search_x(const polygon &P) {\n\tdouble L = INT_MAX, R = 0;\n\tfor(const auto &e : P) {\n\t\tchmin(L, e.x);\n\t\tchmax(R, e.x);\n\t}\n\treturn ternary_search(L, R, [&](double x){ return search_y(x, P); });\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(6);\n\n\tfor(int n; cin >> n && n;) {\n\t\tpolygon P(n);\n\t\tfor(auto &e : P) cin >> e.x >> e.y;\n\t\tcout << search_x(P) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; \n  if(cross(b,c) < -EPS) return -1; \n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨???????????¢\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n \n// ?????´???????????????\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\n\n/*\n  ???????§???¢?????´?????§??????????????´?????¨????????????\n  ???????§???¢??????????¨???????????????????\n  vector<P>??????????§???¢\n*/\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<(int)G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\n//??´??????????????????????????????????±???????\nvector<P> getUnitNormalV(P A,P B){\n  vector<P> v;\n  v.push_back( ((B-A)*P(0,1))/abs(B-A) );\n  v.push_back( ((B-A)*P(0,-1))/abs(B-A) );\n  return v;\n}\n\n//??????s????????¢d?????????????§????\nvector<L> getTranslation(L s,double d){\n  vector<P> p = getUnitNormalV(s.first,s.second);\n  vector<L> ret;\n  for(int i=0;i<2;i++){\n    ret.push_back( L( s.first + p[i]*d , s.second + p[i]*d ) );\n  }\n  return ret;\n}\n\nint N;\nvector<P> v;\n\nconst double WPS = 35.0;\nconst double BPS = 10.0;\n\nint main(){\n  while( (~scanf(\"%d\",&N)) && N ){\n    v.clear();\n    for(int i=0;i<N;i++) {\n      int x,y;\n      scanf(\"%d%d\",&x,&y); v.push_back( P(x,y) );\n    }\n    v.push_back(P(v[0]));\n    double st = 0.0, ed = 1e5;\n    while( (ed-st) > EPS ){\n      double d = (st+ed)/2.0;\n      vector<P> Q = v;\n      Q.pop_back();\n      for(int i=0;i<N;i++){\n\tL s = L(v[i],v[i+1]);\n\tvector<L> tr = getTranslation(s,d);\n\tif( ccw(s.first,s.second,tr[0].first) == 1 )\n\t  Q = convex_cut(Q,tr[0]);\n\t else \n\t  Q = convex_cut(Q,tr[1]);\t\n      }\n      if( Q.empty() )\n\ted = d;\n      else\n\tst = d;\n    }\n\n    printf(\"%.8lf\\n\",ed);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = 1-ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    int n = v.size();\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nVP convex_intersect(VP a, VP b){\n\tVP plist;\n\tint n=a.size(), m=b.size();\n\tfor(int r=0; r<2; r++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(in_poly(a[i], b) >= 0){\n\t\t\t\tplist.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tswap(n, m);\n\t\tswap(a, b);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tL la(a[i], a[(i+1)%n]), lb(b[j], b[(j+1)%m]);\n\t\t\tif(!isParallel(la, lb) && intersectSS(la, lb)){\n\t\t\t\tplist.push_back(crosspointLL(la, lb));\n\t\t\t}\n\t\t}\n\t}\n\treturn convex(plist);\n}\n\nVP convex_cut(const VP& p, const L& l){\n\tVP ret;\n\tint n = p.size();\n\tfor(int i=0; i<n; i++){\n\t\tP curr = p[i];\n\t\tP next = p[(i+1)%n];\n\t\tif(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n\t\tif(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n\t\t\tret.push_back(crosspointLL(L(curr, next), l));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcout << fixed;\n\tcout << setprecision(10);\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tVP v(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv[i] = P(x, y);\n\t\t}\n\t\tif(ccw(v[0], v[1], v[2]) != 1){\n\t\t\treverse(v.begin(), v.end());\n\t\t}\n\t\t\n\t\tdouble l=0, u=20000;\n\t\tfor(int r=0; r<50; r++){\n\t\t\tdouble m = (l+u)/2;\n\t\t\tVP poly = v;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tP normal = (v[(i+1)%n]-v[i])*P(0,1);\n\t\t\t\tnormal *= m/abs(normal);\n\t\t\t\tL edge = L(v[i]+normal, v[(i+1)%n]+normal);\n\t\t\t\tpoly = convex_intersect(poly, convex_cut(poly, edge));\n\t\t\t}\n\t\t\tif((int)poly.size() > 0){\n\t\t\t\tl = m;\n\t\t\t}else{\n\t\t\t\tu = m;\n\t\t\t}\n\t\t}\n\t\tcout << (l+u)/2 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\ndouble solve(){\n    int v[]{rand()%(n-2),rand()%(n-2),rand()%(n-2)};\n    sort(v,v+3);\n    v[1]++;v[2]+=2;\n    P p=innerCenter(ps[v[0]],ps[v[1]],ps[v[2]]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    static double d[128];\n    int near=0;\n    double r[]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10};\n    rep(t,100000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n){\n            if(d[i]<d[near]){\n                near=i;\n            }\n        }\n        P h=projection(es[near],p);\n        p -= (h-p)/d[near]*r[t/10000];\n    }\n\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <array>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public array<point, 2> {\n\tsegment(const point &a, const point &b) {\n\t\tat(0) = a;\n\t\tat(1) = b;\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) + EPS <= 0 && EPS < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) <= EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tif(ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]) == -1)return false;\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\nbool isOK(point p,\n\t\t\t\t\tvector<point> &v,\n\t\t\t\t\tdouble mid) {\n\tll n = v.size();\n\tif(contains(v, p) == 0)return false;\n\tREP(i, n){\n\t\tauto seg = segment(v[i], v[(i+1)%n]);\n\t\tif(distanceLP(seg, p) < mid - EPS)return false;\n\t}\n\treturn true;\n}\n\nbool check(double mid, vector<point> &v){\n\tll n = v.size();\n\tvector<segment> segs;\n\tREP(i, n){\n\t\tauto a = v[i];\n\t\tauto b = v[(i+1)%n];\n\t\tauto vec = b - a;\n\t\tvec /= abs(vec);\n\t\tvec *= mid;\n\t\tvec = rotate(vec, PI/2);\n\t\tsegs.EB(a + vec, b + vec);\n\t}\n\n\tREP(i, n){\n\t\tREP(j, i){\n\t\t\tauto p = crosspointSS(segs[i], segs[j]);\n\t\t\tif(isOK(p, v, mid)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid solve(ll n) {\n\tvector<point> v;\n\tREP(i, n){\n\t\tll x, y;cin >> x >> y;\n\t\tv.EB(x, y);\n\t}\n\n\tdouble l = 0;\n\tdouble r = convex_diameter(v);\n\tREP(_, 100){\n\t\tif(abs(l - r) < EPS)break;\n\t\tdouble mid = (l + r) / 2;\n\t\tif(check(mid, v))l = mid;\n\t\telse r = mid;\n\t}\n\n\tcout << Decimal << l << endl;\n\treturn;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tll n;cin >> n;\n\t\tif(n == 0)break;\n\t\tsolve(n);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n#define lson  (i<<1)\n#define rson  ((i<<1)|1)\ntypedef long long ll;\nusing namespace std;\nconst int  maxn = 1510;\nconst double PI = 3.1415926;\nconst double eps = 1e-8;\n\nint sgn(double x)\n{\n    if(fabs(x) < eps) return 0;\n    if(x < 0)\n        return -1;\n    else\n        return 1;\n}\n\nstruct Point\n{\n    double x,y;\n    Point() {}\n    Point(double _x,double _y)\n    {\n        x = _x,y = _y;\n    }\n    Point operator -(const Point &b)const\n    {\n        return Point(x-b.x,y-b.y);\n    }\n    double operator ^(const Point &b)const\n    {\n        return x*b.y-y*b.x;\n    }\n    double operator *(const Point &b)const\n    {\n        return x*b.x + y*b.y;\n    }\n};\n\nstruct Line\n{\n    Point s,t;\n    double k;\n    Line() {}\n    Line(Point _s,Point _t)\n    {\n        s = _s;\n        t = _t;\n        k = atan2(t.y-s.y,t.x-s.x);\n    }\n    Point operator &(const Line &b) const\n    {\n        Point res = s;\n        double ta = ((s-b.s)^(b.s-b.t))/((s-t)^(b.s-b.t));\n        res.x += (t.x-s.x)*ta;\n        res.y += (t.y-s.y)*ta;\n        return res;\n    }\n};\n\nbool HPIcmp(Line a,Line b)\n{\n    if(fabs(a.k-b.k) > eps) return a.k<b.k;\n    return ((a.s-b.s)^(b.t-b.s)) < 0;\n}\nLine li[maxn];\n\ndouble CalArea(Point p[],int n)\n{\n    double ans = 0;\n    for(int i = 0; i < n; i++)\n    {\n        ans += (p[i]^p[(i+1)%n])/2;\n    }\n    return ans;\n}\n\nvoid HPI(Line line[],int n,Point res[],int &resn)\n{\n    int tot =n;\n    sort(line,line+n,HPIcmp);\n    tot = 1;\n    for(int i = 1; i < n; i++)\n    {\n        if(fabs(line[i].k - line[i-1].k) > eps)\n            line[tot++] = line[i];\n    }\n    int head = 0,tail = 1;\n    li[0] = line[0];\n    li[1] = line[1];\n    resn = 0;\n    for(int i = 2; i < tot; i++)\n    {\n        if(fabs((li[tail].t-li[tail].s)^(li[tail-1].t-li[tail-1].s)) < eps||\n                fabs((li[head].t-li[head].s)^(li[head+1].t-li[head+1].s)) < eps)\n            return;\n        while(head < tail && (((li[tail] & li[tail-1]) - line[i].s) ^ (line[i].t-line[i].s)) > eps)\n            tail--;\n        while(head < tail && (((li[head] & li[head+1]) - line[i].s) ^ (line[i].t-line[i].s)) > eps)\n            head++;\n        li[++tail] = line[i];\n    }\n    while(head < tail && (((li[tail] & li[tail-1]) - li[head].s) ^ (li[head].t-li[head].s)) > eps)\n        tail--;\n    while(head < tail && (((li[head] & li[head-1]) - li[tail].s) ^ (li[tail].t-li[tail].t)) > eps)\n        head++;\n    if(tail <= head+1)\n        return;\n    for(int i = head; i < tail; i++)\n        res[resn++] = li[i]&li[i+1];\n    if(head < tail-1)\n        res[resn++] = li[head]&li[tail];\n}\nPoint p0;\nPoint lis[maxn];\nLine line[maxn];\ndouble dist(Point a,Point b)\n{\n    return sqrt((a-b)*(a-b));\n}\n\nbool cmp(Point a,Point b)\n{\n    double t = (a-p0)^(b-p0);\n    if(sgn(t) > 0)return true;\n    else if(sgn(t) == 0 && sgn(dist(a,lis[0])-dist(b,lis[0])) <= 0)\n        return true;\n    else\n        return false;\n}\n\nPoint ta,tb;\nPoint fans[maxn];\nvoid fin(Point a,Point b,double mid)\n{\n    double len = dist(a,b);\n    double dx = (a.y-b.y)*mid/len;\n    double dy = (b.x-a.x)*mid/len;\n    ta.x = a.x+dx,ta.y = a.y+dy;\n    tb.x = b.x+dx,tb.y = b.y+dy;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int n,T;\n    while(scanf(\"%d\",&n)!= EOF && n)\n    {\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%lf%lf\",&lis[i].x,&lis[i].y);\n        }\n        int ans;\n        double l=0,r=100000;\n        double tans = 0.0;\n        while(r - l > eps)\n        {\n            double mid = (l+r) /2;\n            for(int i = 0; i < n; i++)\n            {\n                fin(lis[i],lis[(i+1)%n],mid);\n                line[i] = Line(ta,tb);\n            }\n            HPI(line,n,fans,ans);\n            if(ans)\n                l = mid+eps,tans = mid;\n            else\n                r = mid-eps;\n        }\n        printf(\"%.6f\\n\",tans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef complex<double> point,vec;\ntypedef pair<point,point> seg,line;\nconst double eps = 1e-9;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\ndouble dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\ndouble dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\ndouble dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        line a( vp[i], vp[(i+1)%vp.size()] );\n        line b( vp[j], vp[(j-1+vp.size())%vp.size()] );\n        bool prl = prll(a,b);\n        if( prl ) continue;\n        vec uva = uvec(a.second- a.first);\n        vec uvb = uvec(b.second- b.first);\n        vec v = uvec( (uva + uvb) );\n        point cr = intersectionLL(a,b);\n        \n        double r = 1e20;\n        double l = 0;\n        int cnt = 0;\n        double radi;\n        while(cnt++<200){\n          double m = (r+l)/2.;\n          point c = m * v + cr;\n          bool ng = false;\n          \n          radi = dist_l(a,c);\n          if( !insimple(c,vp) ){\n            r = m;\n            continue;\n          }\n          \n          for(int k = 0; k < n; ++k){\n            seg s(vp[k],vp[(k+1)%vp.size()]);\n            if( radi > dist_seg(s,c)+eps ){\n              ng = true;\n              break;\n            }\n          }\n          \n          if( ng ){\n            r = m;\n          }else{\n            l = m;\n          }\n        }\n        res = max( res, radi );\n      }\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tdo {\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tfor (int i = 1; i <= 2; ++i) {\n\t\t\t\tPoint laglanju(is_ll(edges[0], edges[i]));\n\t\t\t\tPoint avec = laglanju == edges[0][0] ? edges[0][0] - laglanju : edges[0][1] - laglanju;\n\t\t\t\tPoint bvec = laglanju == edges[i][0] ? edges[i][0] - laglanju : edges[i][1] - laglanju;\n\n\t\t\t\tPoint nvec((abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n\t\t\t\tnlines.emplace_back(laglanju, laglanju + nvec);\n\t\t\t}\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nFOR(it,t) os << *it << endl; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n, m;\nmain(){\n\twhile(cin >> n, n){\n\t\tG g(n);\n\t\tREP(i, n) cin >> g[i];\n\t\tR l=0, r=100000;\n\t\tREP(itr, 80){\n\t\t\tR m = (l+r)*.5;\n\t\t\tif([&](){\n\t\t\t\tG gg = g;\n\t\t\t\tREP(i, n){\n\t\t\t\t\tS s=g.edge(i);\n\t\t\t\t\tP d = unit(s.dir())*P(0, 1)*m;\n\t\t\t\t\ts[0] += d; s[1] += d;\n\t\t\t\t\tgg = gg.cut(s);\n\t\t\t\t}\n\t\t\t\treturn gg.size();\n\t\t\t}()) l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tprintf(\"%.9f\\n\", r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-8;\nconst ld PI=acos(ld(-1));\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nld crs(cm a,cm b,cm c){return crs(b-a,c-a);}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\nauto cmcmp=[](cm a,cm b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nbool cmeq(cm a,cm b){\n\treturn sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;\n};\n//(-pi,0](0,pi]\nint argtype(cm a){\n\tif(sgn(a.y)==0)return a.x<0?1:0;\n\treturn a.y<0?0:1;\n}\nint argcmp(cm a,cm b){\n\tint at=argtype(a),bt=argtype(b);\n\tif(at!=bt)return sgn(at-bt);\n\treturn -ccw(a,b);\n};\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n//AOJ2233\n//a->b->c と進むときに曲がる角度\n//a-b-cが一直線上にあれば0が帰る\nld turn(cm a,cm b,cm c){\n\treturn arg((c-b)/(b-a));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\nint bet(ln a,cm b){return bet(a.a,a.b,b);}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner),3-overelap\nint iss(ln a,ln b){\n\tint c1=ccw(a.a,a.b,b.a),c2=ccw(a.a,a.b,b.b);\n\tint d1=ccw(b.a,b.b,a.a),d2=ccw(b.a,b.b,a.b);\n\tif(c1||c2||d1||d2)return 1-max(c1*c2,d1*d2);\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 3;\n}\n//AOJ1033\ncm cll(ln a,ln b){\n\treturn eval(a,crs(b.a,b.b,a.a)/crs(dir(a),dir(b)));\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n//AOJ2160\n//反時計回り方向に伸びる垂直二等分線\nln vbis(cm a,cm b){\n\tcm c=(a+b)*ld(0.5),d=b-a;\n\treturn ln(c,cm(c.x-d.y,c.y+d.x));\n}\n\n//convex cut\nvc<cm> ccut(vc<cm> a,ln b){\n\tint n=a.size();\n\tvc<cm> c;\n\trep(i,n){\n\t\tint j=(i+1)%n;\n\t\tint d=ccw(b,a[i]),e=ccw(b,a[j]);\n\t\tif(d>=0)c.pb(a[i]);\n\t\tif(d*e<0)c.pb(cll(b,ln(a[i],a[j])));\n\t}\n\treturn c;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\twhile(1){\n\t\tint n;cin>>n;\n\t\tif(n==0)break;\n\t\tvc<cm> a;\n\t\trep(i,n){\n\t\t\tld s,t;\n\t\t\tcin>>s>>t;\n\t\t\ta.eb(s,t);\n\t\t}\n\t\t\n\t\tld lw=0,up=100000;\n\t\trep(_,80){\n\t\t\tld mid=(lw+up)/2;\n\t\t\tvc<cm> b=a;\n\t\t\trep(i,n){\n\t\t\t\tcm c=a[i],d=a[(i+1)%n];\n\t\t\t\tcm e=d-c;\n\t\t\t\te=cm(-e.y,e.x);\n\t\t\t\te*=mid/abs(e);\n\t\t\t\tb=ccut(b,ln(c+e,d+e));\n\t\t\t}\n\t\t\tif(b.size())\n\t\t\t\tlw=mid;\n\t\t\telse\n\t\t\t\tup=mid;\n\t\t}\n\t\tcout<<lw<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble norm(Vector v) { return v.x*v.x + v.y*v.y; }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isOrthogonal(Vector a, Vector b) {\n  return eq(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\ndouble getDistance(Point a, Point b) { return abs(a - b); }\ndouble getAngle(Point a, Point b, Point c) {\n  Vector v = b - a, w = c - b;\n  double alpha = atan2(v.y, v.x), beta = atan2(w.y, w.x);\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha) * 180 / M_PI;\n  return min(theta, 360 - theta);\n}\nVector getAngleBisectorVector(Point a, Point b, Point c) {\n  Vector v = a - b, w = c - b;\n  v = v / abs(v), w = w / abs(w);\n  Vector u = v + w;\n  return u / abs(u);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return eq(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\nPoint reflect(Segment s, Point p) {\n  return p + (project(s, p) - p) * 2.0;\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\ndouble getDistanceSP(Segment s, Point p) {\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\ndouble getDistance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2) {\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\nLine getPerpendicularBisector(Point p1, Point p2) {\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\nvector<Vector> getNormalLineVector(Line l) {\n  vector<Vector> vs;\n  Vector v = l.p2 - l.p1, p = v / abs(v);\n  vs.emplace_back(-p.y, p.x);\n  vs.emplace_back(p.y, p.x);\n  return vs;\n}\nvector<Line> getTranslation(Line l, double d) {\n  vector<Vector> nlv = getNormalLineVector(l);\n  vector<Line> nl;\n  nl.emplace_back(l.p1 + nlv[0]*d, l.p2 + nlv[0]*d);\n  nl.emplace_back(l.p1 + nlv[1]*d, l.p2 + nlv[1]*d);\n  return nl;\n}\n\ntypedef vector<Point> Polygon;\n\ndouble getArea(Polygon p) {\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\n#define IN_POLYGON  2\n#define ON_POLYGON  1\n#define OUT_POLYGON 0\nint contains(Polygon g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n\nPolygon convexHull(Polygon ps) {\n  int N = ps.size(), j = 0;\n  Polygon pg(N*2);\n\n  sort(ps.begin(), ps.end(), [](Point p1, Point p2) -> bool {\n      return p1.y != p2.y ? lt(p1.y, p2.y) : lt(p1.x, p2.x); });\n  for(int i = 0; i < N; i++, j++) {\n    while(j >= 2 && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  int k = j+1;\n  for(int i = N-2; i >= 0; i--, j++) {\n    while(j >= k && ccw(pg[j-2], pg[j-1], ps[i]) == -1) j--;\n    pg[j] = ps[i];\n  }\n  pg.resize(j-1);\n  return pg;\n}\n\nPolygon convexCut(Polygon s, Line l) {\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nbool check(Polygon s, double dist) {\n  Polygon t = s;\n  rep(i, s.size()) {\n    Line bl = Line(s[i], s[(i+1)%s.size()]);\n    vector<Line> ls = getTranslation(bl, dist);\n    Line sl;\n    if(ccw(bl.p1, bl.p2, ls[0].p1) == COUNTER_CLOCKWISE) sl = ls[0];\n    else sl = ls[1];\n    Polygon u = convexCut(t, sl);\n    if(u != t) t = u;\n  }\n  return !t.empty();\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  while(cin >> n, n) {\n    Polygon s(n);\n    rep(i, n) cin >> s[i].x >> s[i].y;\n    double lb = 0, ub = 10000000000;\n    rep(i, 100) {\n      double mb = (lb + ub) / 2;\n      if(check(s, mb)) lb = mb;\n      else ub = mb;\n      //cout<<lb<<\" \"<<ub<<endl;\n    }\n    cout << ub << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tvector<vector<Line>>bis(n, vector<Line>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (isis_ll(lines[i], lines[j])) {\n\t\t\t\t\t\tbis[i][j] = bisection(lines[i], lines[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tint a = perm[0], b = perm[1], c = perm[2];\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t\tswap(a, c);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tnlines.emplace_back(bis[a][b]);\n\t\t\tnlines.emplace_back(bis[a][c]);\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass Vector2 {\npublic:\n  double x, y;\n\n  Vector2(): x(0), y(0) {}\n  Vector2(double x, double y): x(x), y(y) {}\n\n  Vector2 operator+(Vector2 p) { return Vector2(x + p.x, y + p.y); }\n  Vector2 operator-(Vector2 p) { return Vector2(x - p.x, y - p.y); }\n  Vector2 operator*(double t) { return Vector2(x * t, y * t); }\n  Vector2 operator/(double t) { return Vector2(x / t, y / t); }\n  double dot(Vector2 p) { return x * p.x + y * p.y; }\n  double det(Vector2 p) { return x * p.y - y * p.x; }\n  double norm2() { return x * x + y * y; }\n  double norm() { return sqrt(norm2()); }\n  Vector2 normalize() { return Vector2(x / norm(), y / norm()); }\n};\nusing Point2 = Vector2;\n\nclass LineSegment2 {\npublic:\n  Point2 p1, p2;\n\n  LineSegment2() {}\n  LineSegment2(Point2 p1, Point2 p2): p1(p1), p2(p2) {}\n};\n\nusing Polygon2 = vector<Vector2>;\n\nPoint2 lines_intersect_point(Point2 a, Point2 b, Point2 c, Point2 d) {\n  Vector2 u = b - a;\n  Vector2 v = d - c;\n  double p1 = u.y, q1 = -u.x, r1 = -u.det(a);\n  double p2 = v.y, q2 = -v.x, r2 = -v.det(c);\n  double det = p1 * q2 - p2 * q1;\n  double x = (r1 * q2 - r2 * q1) / det;\n  double y = (r2 * p1 - r1 * p2) / det;\n  return Point2(x, y);\n}\n\nLineSegment2 slide(LineSegment2 l, double d) {\n  Vector2 v = (l.p2 - l.p1).normalize();\n  Vector2 n = Vector2(-v.y, v.x);\n  Vector2 m = (l.p1 + l.p2) / 2;\n  Vector2 p1 = m + n * d;\n  Vector2 p2 = p1 + v;\n  return LineSegment2(p1, p2);\n}\n\nPolygon2 cut(Polygon2 &P, LineSegment2 l) {\n  Polygon2 poly;\n  REP(i, 0, P.size()) {\n    Point2 p1 = P[i], p2 = P[(i + 1) % P.size()];\n    if ((l.p2 - l.p1).det(p1 - l.p1) >= 0) {\n      poly.push_back(p1);\n    }\n    if ((l.p2 - l.p1).det(p1 - l.p1) * (l.p2 - l.p1).det(p2 - l.p1) < 0) {\n      poly.push_back(lines_intersect_point(l.p1, l.p2, p1, p2));\n    }\n  }\n  return poly;\n}\n\nbool ok(Polygon2 &P, double d) {\n  Polygon2 poly(P);\n  REP(i, 0, P.size()) {\n    Vector2 p1 = P[i], p2 = P[(i + 1) % P.size()];\n    LineSegment2 l = slide(LineSegment2(p1, p2), d);\n    poly = cut(poly, l);\n  }\n  return poly.size() > 0;\n}\n\ndouble solve(Polygon2 P) {\n  double l = 0, h = 1e10;\n  REP(i, 0, 100) {\n    double m = (l + h) / 2;\n    if (ok(P, m)) l = m;\n    else h = m;\n  }\n  return l;\n}\n\nint main(void) {\n  for (ll N; cin >> N, N;) {\n    Polygon2 P(N);\n    REP(i, 0, N) cin >> P[i].x >> P[i].y;\n    printf(\"%.15lf\\n\", solve(P));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst D INF = 1e40;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nint sig(D r) {return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0;}\nbool eq(D a, D b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(a - b) < EPS;}\n\n// 内積\nD dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.second - a.first;}\n\n// 線分abに対する点xの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  D cr = det(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\n// 角度\nD ang(P p) {D theta = arg(p); return sig(theta - PI) < 0 ? theta : -PI;}\n// 有向角度\nD ang(P base, P a, P b) {return ang((b - base) / (a - base));}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.first + proj(vec(l), p - l.first);}\nP refl(L l, P p) {return perp(l, p) * (D)2 - p;}\n\n// 交差判定\nbool iLL(L a, L b) {return !eq(det(vec(a), vec(b)), 0);}\nbool eqL(L a, L b) {return !iLL(a, b) && eq(det(vec(a), b.first - a.first), 0);}\nbool iLS(L a, L b) {return sig(det(vec(a), b.first - a.first)) * sig(det(vec(a), b.second - a.first)) <= 0;}\nbool iLSs(L a, L b) {return sig(det(vec(a), b.first - a.first)) * sig(det(vec(a), b.second - a.first)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  return ((cwa | cwb) & ON) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nbool iSSs(L a, L b) {return ((ccw(a, b.first) | ccw(a, b.second)) & (ccw(b, a.first) | ccw(b, a.second))) == (LEFT | RIGHT);}\n\n// 交点\nP pLL(L a, L b) {return a.first + vec(a) * (det(vec(b), b.first - a.first) / det(vec(b), vec(a)));}\n\n// 距離\nD dLP(L l, P x) {return abs(det(vec(l), x - l.first)) / abs(vec(l));}\nD dSP(L s, P x) {\n  if (sig(dot(vec(s), x - s.first)) <= 0) return abs(x - s.first);\n  if (sig(dot(-vec(s), x - s.second)) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\nD dLL(L a, L b) {return iLL(a, b) ? 0 : dLP(a, b.first);}\nD dLS(L a, L b) {return iLS(a, b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n// 比較関数\nnamespace std {\n  bool operator<(P a, P b) {return eq(a.X, b.X) ? a.Y < b.Y : a.X < b.X;}\n}\nL sortBase;\nbool lessArg(P a, P b) {\n  D ang1 = ang(sortBase.first, sortBase.second, a);\n  D ang2 = ang(sortBase.first, sortBase.second, b);\n  return eq(ang1, ang2) ? norm(a) > norm(b) : ang1 < ang2;\n}\n\n// 円\nstruct C{\n  P c; D r;\n  C() {}\n  C(P c, D r) : c(c), r(r) {}\n};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  D d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && eq(c1.r, c2.r)) return SAME;\n  if (sig(d - (c1.r - c2.r)) < 0) return OVER;\n  if (sig(d - (c2.r - c1.r)) < 0) return CONTAIN;\n  if (eq(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (eq(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (eq(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d - (c1.r + c2.r)) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 点が円に含まれるか\nbool iCP(C c, P p) {return sig(abs(p - c.c) - c.r) <= 0;}\n// 交差判定\nbool iCL(C c, L l) {return sig(c.r - dLP(l, c.c)) >= 0;}\n// 円と交差せず完全に含まれても良い場合は&&以降を削除\nbool iCS(C c, L s) {return iCL(c, s) && sig(c.r - max(abs(s.first - c.c), abs(s.second - c.c))) <= 0;}\nbool iCC(C a, C b) {return sig(abs(a.c - b.c) - abs(a.r - b.r) >= 0) && sig(abs(a.c - b.c) - a.r - b.r) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  D x = (norm(a.c - b.c) + a.r * a.r - b.r * b.r) / (2 * abs(a.c - b.c));\n  P e = (b.c - a.c) / abs(b.c - a.c);\n  P y = e * P(0, sqrt(max(a.r * a.r - x * x, (D)0)));\n  return make_pair(a.c + e * x - y, a.c + e * x + y);\n}\npair<P, P> pCL(C c, L l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sqrt(max(c.r * c.r - norm(x - c.c), (D)0));\n  return make_pair(x - y, x + y);\n}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(det(a, c)) - sig(det(b, c)) - sig(det(a, b));}\n\n// 多角形の面積\nD aPol(Pol vp) {\n  D ret = 0;\n  rep (i, vp.size()) ret += det(vp[i], vp[(i + 1) % vp.size()]);\n  return abs(ret / 2);\n}\n\n// 三角形の面積\nD aTri(D a, D b, D c){\n  D s = (a + b + c) / 2;\n  return sqrt(max(s * (s - a) * (s - b) * (s - c), (D)0));\n}\n\n// 多角形の内外判定 内部:1、周上:0、外部:-1\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(det(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(det(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\n\n// 凸包\nPol convexHull(Pol p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end());\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(det(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(det(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\n// 凸包カット\nPol convexCut(Pol p, L l) {\n  vector<P> q;\n  rep (i, p.size()) {\n    if (ccw(l, p[i]) & (LEFT | BACK | ON | FRONT)) q.push_back(p[i]);\n    if (iLSs(l, L(p[i], p[(i + 1) % p.size()]))) q.push_back(pLL(l, L(p[i], p[(i + 1) % p.size()])));\n  }\n  return q;\n}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  rep (i, s.size()) if (s[i].second < s[i].first) swap(s[i].first, s[i].second);\n  sort(s.begin(), s.end());\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j]) && !iLL(s[i], s[j])) {\n    s[j].second = max(s[i].second, s[j].second);\n    s.erase(s.begin() + i--);\n    break;\n  }\n  return s;\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\npair<vector<P>, vector<vector<int> > > sArr(vector<L> s) {\n  s = merge(s);\n  vector<P> vp;\n  rep (i, s.size()) {\n    vp.push_back(s[i].first);\n    vp.push_back(s[i].second);\n  }\n  rep (i, s.size()) rep (j, i) if (iSS(s[i], s[j])) vp.push_back(pLL(s[i], s[j]));\n  sort(vp.begin(), vp.end());\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<D, int> > v;\n    rep (j, vp.size()) if (ccw(s[i], vp[j]) == ON) v.push_back(make_pair(norm(vp[j] - s[i].first), j));\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return make_pair(vp, g);\n}\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    Pol pol(n);\n    rep (i, n) cin >> pol[i].X >> pol[i].Y;\n    D a = 0, b = 1e5;\n    while (sig(a - b) < 0) {\n      D m = (a + b) / 2;\n      Pol cnv;\n      cnv.push_back(P(-1e5, -1e5));\n      cnv.push_back(P(1e5, -1e5));\n      cnv.push_back(P(1e5, 1e5));\n      cnv.push_back(P(-1e5, 1e5));\n      rep (i, n) {\n\tL l(pol[i], pol[(i + 1) % n]);\n\tP d = vec(l) * polar(m / abs(vec(l)), PI / 2);\n\tl.first += d;\n\tl.second += d;\n\tcnv = convexCut(cnv, l);\n      }\n      if (cnv.size() == 0u) b = m;\n      else a = m;\n    }\n    printf(\"%.12Lf\\n\", a);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nconst double EPS = 1e-8;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\n\ntypedef vector<P> G;\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\ndouble area(const G& g) {\n  double A = 0;\n  for (int i = 0; i < g.size(); ++i) {\n    A += cross(g[i], next(g, i));\n  }\n  return A/2;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  REP(i, g.size()) {\n    P A = curr(g, i), B = next(g, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n// Cð½·àÌªlb¤É èACð½·ÅålðßéÆ«BCð½·àÌª³¢Æ«ÌÉÓB\ntemplate<class T> T upper_search(T lb, T ub, bool (*C)(T)) {\n  REP(i,100) { // ±±ÍKÉ\n    T mid = (lb+ub)/2;\n    if (C(mid)) lb = mid;       // Å¬lðßéÈçlbÆubðüêÖ¦é\n    else ub = mid;\n  }\n  return lb;\n}\nconst double PI = acos(-1);\nP rotate(P p, double ang) {\n  return p*P(cos(ang), sin(ang));\n}\nG g;\nbool C(double x) {\n  G hoge(g);\n  REP(i, g.size()) {\n    L l(g[i], next(g, i));\n    P p = rotate(l[1]-l[0], PI/2);\n    p *= x/abs(p);\n    l = L(l[0]+p, l[1]+p);\n    hoge = convex_cut(hoge, l);\n    if (hoge.size() == 0) return 0;\n  }\n  // printf(\"%.6f\", x);\n  // cout  << \" \" << area(hoge) << endl;\n  return 1;\n}\nint main() {\n    int n;\n  while(cin>>n,n) {\n    g.clear();\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      g.push_back(P(a,b));\n    }\n    double ans = upper_search<double>(0, INF, C);\n    printf(\"%.6f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nconst double inf = 1000000;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea2(const vector<P> &g) {\n  int n = g.size();\n  double s = 0;\n  for(int i = 0; i < n; ++i) {\n    s += cross(g[i], g[(i+1)%n]);\n  }\n  return s;\n}\n\nint main() {\n  int n;\n  vector<P> base;\n  base.push_back(P(-inf,-inf));\n  base.push_back(P(inf,-inf));\n  base.push_back(P(inf,inf));\n  base.push_back(P(-inf,inf));\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l, r;\n    l = 0.0;\n    r = inf;\n    while(!equals(l, r)) {\n      double d = (l+r)/2.0;\n      vector<P> g = base;\n      for(int i = 0; g.size() > 2 && i < n; ++i) {\n\tint s = i;\n\tint t = (i+1)%n;\n\tP v = ps[t] - ps[s];\n\tP u = P(-v.imag(), v.real());\n\tu /= abs(u);\n\tg = convex_cut(g, ps[s]+u*d, ps[t]+u*d);\n      }\n      if(g.size() <= 2 || equals(getArea2(g), 0.0)) {\n\tr = d;\n      } else {\n\tl = d;\n      }\n    }\n    printf(\"%.6f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\n#include<algorithm>\nusing namespace std;\n\ntypedef long double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> seg,line;\nconst elem eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(elem a, elem b){return abs(b-a) < eps;}\nvec uvec(const vec &v){return v / abs(v);}\nvec nml(vec a){return a*vec(0,1);}\nvec unml(vec a){return uvec(nml(a));}\n\nelem dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nelem cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nelem dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nelem dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\nbool intersectedLL(const line &a, const line &b){\n  return !eq( cross(a.second-a.first,b.second-b.first), 0.0 );\n}\n\npoint intersectionSS(const seg &a, const seg &b)\n{\n  elem d1 = dist_l(b,a.first);\n  elem d2 = dist_l(b,a.second);\n  return a.first + ( d1 / (d1 + d2 ) ) * (a.second-a.first);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nbool intersectionLL(const line &a, const line &b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nbool intersectionLS(const line &l, const seg &s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.first,s.second,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\n\nbool cmpXy(const point &a, const point &b){\n  if( eq(a.real(),b.real() ) ) return a.imag()<b.imag();\n  if( a.real()<b.real() ) return true;\n  return false;\n}\n\nvoid andrewConvexHull(const vector<point> &Q, vector<point> &CH)\n{\n  vector<point> T = Q;\nif(Q.size()<3){CH=Q;return ;}\n  int n = T.size(), k = 0;\n  sort( T.begin(), T.end(), cmpXy );\n  CH.resize(2*n);\n  for(int i = 0; i < n; CH[k++] = T[i++]){\n    while( k >= 2 && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  for(int i = n-2, t = k+1; i >= 0; CH[k++] = T[i--] ){\n    while( k >= t && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  CH.resize(k-1);\n}\n\nbool regularConvex(vector<point> &vp){\n  vector<point> ret;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    for(int j = i+1; j < (int)vp.size(); ++j){\n      if( eq(abs(vp[i]-vp[j]),0) ){\n        vp.erase( vp.begin() + j );\n      }\n    }\n  }\n  andrewConvexHull( vp, ret );\n  vp = ret;\n}\n\n\nbool convexCut(const vector<point> &vp,\n               line l,\n               vector<point> &left)\n{\n  vector<point> tmp;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    if( ccw(l.first, l.second, vp[i] ) == LEFT ){\n      tmp.push_back(vp[i]);\n    }\n  }\n  for(int i = 0; i < (int)vp.size(); ++i){\n    point is;\n    seg s(vp[i],vp[(i+1)%vp.size()]);\n    if(intersectionLS( l, s, is )){\n      tmp.push_back(is);\n    }\n  }\n  regularConvex(tmp);\n  left = tmp;\n  return true;\n}\n\nelem area(const vector<point> &vp){\n  elem ret= 0;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    ret += cross(vp[i],vp[(i+1)%vp.size()]);\n  }\n  return abs(ret/2);\n}\n \nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    point c;\n    for(int i = 0; i < n; ++i){\n      elem x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n\n    elem r = 1e9;\n    elem l = 0;\n    int cnt = 0;\n    vector<point> L;\n    elem m;\n    while(cnt++<100){\n      m = (l+r)/2.;\n      \n      L = vp;\n      for(int i = 0; i < n; ++i){\n        line a( vp[i], vp[(i+1)%n] );\n        point b = m * unml(a.second-a.first);\n        \n        line la(b+a.first,b+a.second);\n        //cout << a.first << ' ' << a.second << ' ' << la.first << ' ' << la.second << endl;\n        vector<point> newL;\n        convexCut( L, la, newL );\n        L = newL;\n      }\n\n      /*\n      cout << m << ' ' << \" Size : \" << L.size() << endl;\n      for(int i = 0; i < (int)L.size(); ++i){\n        cout << L[i] << ' ';\n      }\n      cout << endl;\n      */\n\n      if( L.size()==0 ){\n        r = m;\n      }else{\n        l = m;\n      }\n    }\n    \n    cout << fixed << setprecision(12) << m << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-11;\nconst double inf = 1000000;\n\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea2(const vector<P> &g) {\n  int n = g.size();\n  double s = 0;\n  for(int i = 0; i < n; ++i) {\n    s += cross(g[i], g[(i+1)%n]);\n  }\n  return s;\n}\n\nint main() {\n  int n;\n  vector<P> base;\n  base.push_back(P(-inf,-inf));\n  base.push_back(P(inf,-inf));\n  base.push_back(P(inf,inf));\n  base.push_back(P(-inf,inf));\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l, r;\n    l = 0.0;\n    r = inf;\n    while(!equals(l, r)) {\n      double d = (l+r)/2.0;\n      vector<P> g = base;\n      for(int i = 0; g.size() > 2 && i < n; ++i) {\n\tint s = i;\n\tint t = (i+1)%n;\n\tP v = ps[t] - ps[s];\n\tP u = P(-v.imag(), v.real());\n\tg = convex_cut(g, ps[s]+u*d/abs(u), ps[t]+u*d/abs(u));\n      }\n      if(g.size() <= 2 || equals(getArea2(g), 0.0)) {\n\tr = d;\n      } else {\n\tl = d;\n      }\n    }\n    printf(\"%.6f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nLA3890 Most Distant Point from the Sea\n题意：大海中央有一个凸n边形的小岛，求岛上离海最远的点，输出其距离\n思路：\n\t二分答案，对于小岛的每条边，作一条相应的直线，若最后形成的半平面非空，\n\t那么可以满足。 \n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-6;\nconst double PI=acos(-1);\n\nstruct Point\t\t//定义点or向量 \n{\n\tdouble x,y;\n\tPoint ( double x=0,double y=0 ) : x(x),y(y) {}\n};\ntypedef Point Vector;\t\t//区分点和向量，因为结构体一样 \n\nVector operator + ( Vector A,Vector B )\n{\n\treturn Vector( A.x+B.x,A.y+B.y );\n} \n\nVector operator - ( Point A,Point B )\n{\n\treturn Vector( A.x-B.x,A.y-B.y );\n}\n\nVector operator * ( Vector A,double b )\n{\n\treturn Vector( A.x*b,A.y*b );\n}\n\nVector operator / ( Vector A,double b )\n{\n\treturn Vector( A.x/b,A.y/b );\n}\n\nbool operator < ( const Point &a,const Point &b )\n{\n\treturn a.x<b.x || ( a.x==b.x && a.y<b.y );\n}\n\nint dcmp( double x )\n{\n\tif ( fabs( x )<eps ) return 0;\n\telse return x<0 ? -1 : 1;\n}\n\nbool operator == ( const Point &a,const Point &b )\n{\n\treturn dcmp( a.x-b.x )==0 && dcmp( a.y-b.y )==0;\n}\n\ndouble Dot( Vector A,Vector B )\t\t//求点积 \n{\n\treturn A.x*B.x+A.y*B.y;\n}\n\ndouble Length( Vector A )\t\t//求向量的模 \n{\n\treturn sqrt( Dot( A,A ) );\n}\n\ndouble Cross( Vector A,Vector B )\t\t//根据向量求叉积 \n{\n\treturn A.x*B.y-A.y*B.x;\n}\n\nVector Normal( Vector A )\t\t//左转九十度长度归一，注意不能是零向量\n{\n\tdouble l=Length( A );\n\treturn Vector( -A.y/l,A.x/l );\n}\n\nstruct Line2\t\t//有向直线\n{\n\tPoint P; Vector v; double ang;\n\tLine2() {}\n\tLine2( Point P,Vector v ) :P(P),v(v) {ang=atan2( v.y,v.x );}\n\tbool operator <( const Line2 &L ) const\n\t{\n\t\treturn ang<L.ang;\n\t}\n};\n\nbool Onleft( Line2 L,Point p )\t\t//点p在有向直线左边 \n{\n\treturn Cross( L.v,p-L.P ) >0;\n}\n\nPoint GetLineIntersection( Line2 a,Line2 b )\t\t//两直线交点 \n{\n\tVector u=a.P-b.P;\n\tdouble t=Cross( b.v,u )/Cross( a.v,b.v );\n\treturn a.P+a.v*t;\n}\n\nint HalfPlaneIntersection( Line2 *L,int n,Point *poly )\n{\n\tsort( L,L+n );\n\tint first,last; Point *p=new Point[n]; Line2 *q=new Line2[n];\n\tq[first=last=0]=L[0];\n\tfor ( int i=1; i<n; i++ )\n\t{\n\t\twhile ( first<last && !Onleft( L[i],p[last-1] ) ) last--;\n\t\twhile ( first<last && !Onleft( L[i],p[first] ) ) first++;\n\t\tq[++last]=L[i];\n\t\tif ( fabs( Cross( q[last].v,q[last-1].v ) )<eps )\n\t\t{\n\t\t\tlast--;\n\t\t\tif ( Onleft( q[last],L[i].P ) ) q[last]=L[i];\n\t\t}\n\t\tif ( first<last ) p[last-1]=GetLineIntersection( q[last-1],q[last] );\n\t}\n\twhile (first<last && !Onleft( q[first],p[last-1] ) ) last--;\n\tif ( last-first<=1 ) return 0;\n\tp[last]=GetLineIntersection( q[last],q[first] );\n\tint m=0;\n\tfor ( int i=first; i<=last; i++ )\n\t\tpoly[m++]=p[i];\n\treturn m;\n}\n\nPoint p[210],poly[210];\nVector v[210],v2[210];\nLine2 L[210];\nint n;\n\nint main()\n{\n\twhile ( scanf( \"%d\",&n ) && n )\n\t{\n\t\tint m;\n\t\tfor ( int i=0,x,y; i<n; i++ )\n\t\t{\n\t\t\tscanf( \"%d%d\",&x,&y ); p[i]=Point( x,y );\n\t\t}\n\t\t\n\t\tfor ( int i=0; i<n; i++ )\n\t\t\tv[i]=p[(i+1)%n]-p[i],v2[i]=Normal( v[i] );\n\t\tdouble left=0,right=20010;\n\t\twhile ( dcmp( right-left) )\n\t\t{\n\t\t\tdouble mid=(left+right)/2;\n\t\t\tfor ( int i=0; i<n; i++ )\n\t\t\t\tL[i]=Line2( p[i]+v2[i]*mid,v[i] );\n\t\t\tm=HalfPlaneIntersection( L,n,poly );\n\t\t\tif ( !m ) right=mid;\n\t\t\telse left=mid;\n\t\t}\n\t\t\n\t\tprintf( \"%.6lf\\n\",left );\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x, M_PI/2.) / ln.length();\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n\ntypedef double FP;\n\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.second-a.first);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.first,a.second,b.first,b.second);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.first,a.second,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\n\nvoid check(P a){\n\n  // assert(!isnan(a.real()));\n  // assert(!isnan(a.imag()));\n}\n\nvoid check(line a){\n  check(a.first);\n  check(a.second);  \n}\n\nbool para(line a, line b){\n  P av = a.first - a.second;\n  P bv = b.first - b.second;\n  return abs(dot(av/abs(av),bv/abs(bv))) > 1 - 1e-9;\n}\n\ndouble tri(P a, P b, P c){\n  a -= c;\n  b -= c;\n  return abs(crs(a,b));\n}\n\nline midline(line a,line b){\n  if(!para(a,b)){\n    P av = a.second - a.first;\n    P bv = b.second - b.first;\n    av /= abs(av);\n    bv /= abs(bv);\n    auto ret = line(crspt(a,b),crspt(a,b)+av+bv);\n    check(ret);\n    return ret;\n  }\n  P st =(a.first+b.first)/2.;\n  auto ret = line(st, st + a.second - a.first);\n  check(ret);\n  return ret;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n && n){\n    int x[n], y[n];\n    for(int i = 0; i < n; ++i)\n      cin >> x[i] >> y[i];\n    double cx = accumulate(x,x+n,0.)/n;\n    double cy = accumulate(y,y+n,0.)/n;\n      \n    double ans = 0;\n    for(int i = 0; i < n; ++i){\n      \n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        double r = 10000000000;\n        for(int k = 0; k < n; ++k){\n          if(i == k || j == k) continue;\n          line il = line(P(x[i],y[i]), P(x[(i+1)%n],y[(i+1)%n]));\n          line jl = line(P(x[(j+1)%n],y[(j+1)%n]), P(x[j],y[j]));\n          line kl = line(P(x[(k+1)%n],y[(k+1)%n]), P(x[k],y[k]));\n          line ij = midline(il, jl);\n          line ik = midline(il, kl);\n          // if(!iscrs(ij, ik)){\n          //   cout << ij << \"  \" << ik << endl;\n          //   continue;\n          // }\n          P ce = crspt(ij,ik);\n          if(!isnormal(ce.real()) || !isnormal(ce.imag())){\n            //cout << ce << endl;\n            continue;\n          }\n          double me = 0;\n          double me2 = 0;\n          for(int ii = 0; ii < n; ++ii){\n            me += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),ce);\n            me2 += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),P(cx,cy));\n          }\n          \n          if(abs(me-me2)/max(me,me2) > EPS){\n            //cout << me << \" \" << me2 << endl;\n            continue;\n          }\n          \n          double tr = 10000000000;\n          for(int ii = 0; ii < n; ++ii){\n            line l(P(x[ii],y[ii]),P(x[(ii+1)%n],y[(ii+1)%n]));\n            tr = min(tr, lpdist(l,ce));\n          }\n          ans = max(tr, ans);\n          //cout << ce << endl;\n          double cr = lpdist(il,ce);\n          r = min(r, cr);\n        }\n        //ans = max(r, ans);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point {\n    double x, y;\n\n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x, y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x, y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k, y*k); }\n    Point operator / (const double &k)const{ return Point(x/k, y/k); }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x*b.y - b.x*a.y;\n}\n\ndouble norm(const Point &p){\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2));\n}\n\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return +1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS)   return +2; \n    if (norm(a) < norm(b))  return -2;\n    return +0;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tPoint cp = curr(pg,i), np = next(pg,i);\n\tif (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n\tif (ccw(l.s, l.t, cp)*ccw(l.s, l.t, np) < 0) {\n\t    res.push_back(crosspointLL(Line(cp, np), l));\n\t}\n    }\n    return res;\n}\n\nvector<Vector> normal_line_vector(const Line &l)\n{\n    vector<Vector> vs;\n    Vector v = l.t - l.s, p = v / abs(v);\n    vs.push_back(Point(-p.y, p.x));\n    vs.push_back(Point(p.y, p.x));\n    return vs;\n}\n\nvector<Line> translation(const Line &l, double d)\n{\n    vector<Vector> nlv = normal_line_vector(l);\n    vector<Line> nl;\n    nl.push_back(Line(l.s + nlv[0]*d, l.t + nlv[0]*d));\n    nl.push_back(Line(l.s + nlv[1]*d, l.t + nlv[1]*d));\n    return nl;\n}\n\nbool c(double d, const Polygon &pg)\n{\n    Polygon p = pg;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Line l(curr(pg, i), next(pg, i)), ll;\n        vector<Line> nl = translation(l, d);\n        ll = (ccw(l.s, l.t, nl[0].s) == 1 ? nl[0] : nl[1]);\n        p = convex_cut(p, ll);\n    }\n    return (p.size() > 0);\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        Polygon pg(n);\n        for (int i = 0; i < n; i++) {\n            cin >> pg[i].x >> pg[i].y;\n        }\n\n        double l = 0, r = 10000;\n        for (int i = 0; i < 150; i++) {\n            double mid = (l + r) / 2;\n            if (c(mid, pg)) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        printf(\"%.8f\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define EPS 1e-10\n\n#define RIGHT 1\n#define LEFT  -1\n\ntypedef complex<double> P;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1 + a*cross(b,b1-a1)/cross(b,a);\n}\n\n\n\nint ccw(P a,P b){\n  if (cross(a,b)<0 )return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(vector<P> in,int n,P a1,P a2){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if ( ccw(a1-a2,now-a2)==LEFT)ret.push_back(now);\n    if ( ccw(a1-a2,now-a2)*ccw(a1-a2,next-a2)< 0 )\n      ret.push_back( intersection_ll(a1,a2,now,next));\n  }\n  \n  return ret;\n}\n\ndouble calc(double a,double b){return sqrt(a*a+b*b);}\n\n\nint cut(P *in,int n,double r){\n  vector<P> a;\n  rep(i,n)a.push_back(in[i]);\n  \n  rep(i,n && a.size() ){\n    P tmp=in[(i+1)%n]-in[i];\n    complex<double> e(-tmp.imag(),tmp.real());\n    e=e/abs(e)*r;\n    a = Convex_Cut(a,a.size(),in[(i+1)%n]+e,in[i]+e);    \n  }\n\n  return a.size();\n}\n\ndouble solve(P *in,int n){\n  double small=0,large=0,mid=0;\n  rep(i,n){\n    REP(j,i+1,n)large=max(large,calc(in[i].real()-in[j].real(),in[i].imag()-in[j].imag()));\n  }\n  \n\n  while(small<=large){\n    mid = (small+large)/2; \n    \n    if ( cut(in,n,mid) == 0)large=mid-1e-6;\n    else small=mid+1e-6;\n  }\n  return mid;\n}\n\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    P in[n];\n    rep(i,n)cin>>in[i].real() >> in[i].imag();\n    printf(\"%.6lf\\n\",solve(in,n));\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point {\n    double x, y;\n\n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x, y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x, y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k, y*k); }\n    Point operator / (const double &k)const{ return Point(x/k, y/k); }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x*b.y - b.x*a.y;\n}\n\ndouble norm(const Point &p){\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2));\n}\n\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return +1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS)   return +2; \n    if (norm(a) < norm(b))  return -2;\n    return +0;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tPoint cp = curr(pg,i), np = next(pg,i);\n\tif (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n\tif (ccw(l.s, l.t, cp)*ccw(l.s, l.t, np) < 0) {\n\t    res.push_back(crosspointLL(Line(cp, np), l));\n\t}\n    }\n    return res;\n}\n\nvector<Vector> normal_line_vector(const Line &l)\n{\n    vector<Vector> vs;\n    Vector v = l.t - l.s, p = v / abs(v);\n    vs.push_back(Point(-p.y, p.x));\n    vs.push_back(Point(p.y, p.x));\n    return vs;\n}\n\nvector<Line> translation(const Line &l, double d)\n{\n    vector<Vector> nlv = normal_line_vector(l);\n    vector<Line> nl;\n    nl.push_back(Line(l.s + nlv[0]*d, l.t + nlv[0]*d));\n    nl.push_back(Line(l.s + nlv[1]*d, l.t + nlv[1]*d));\n    return nl;\n}\n\nbool c(double d, const Polygon &pg)\n{\n    Polygon p = pg;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Line l(curr(pg, i), next(pg, i)), ll;\n        vector<Line> nl = translation(l, d);\n        ll = (ccw(l.s, l.t, nl[0].s) == 1 ? nl[0] : nl[1]);\n        p = convex_cut(p, ll);\n    }\n    return (p.size() > 0);\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        Polygon pg(n);\n        for (int i = 0; i < n; i++) {\n            cin >> pg[i].x >> pg[i].y;\n        }\n\n        double l = 0, r = 10000;\n        for (int i = 0; i < 150; i++) {\n            double mid = (l + r) / 2;\n            if (c(mid, pg)) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        printf(\"%.8f\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L : public vector<P>{\n  L(const P &a, const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\n#define EPS (1e-8)\n\nint n;\ndouble lx, hx, ly, hy;\nvector<P> t;\n\ndouble dot(const P& a, const P& b){\n  return real(conj(a) * b);\n}\n\ndouble cross(const P &a, const P &b){\n  return imag(conj(a) * b);\n}\n\nenum { OUT, ON, IN };\nint contains(const vector<P> &pol, const P &p) {\n  P g = (pol[0] + pol[n/3] + pol[2*n/3]) / 3.0;\n  int a = 0, b = n;\n  while (a+1 < b) {\n    int c = (a + b) / 2;\n    if (cross(pol[a]-g, pol[c]-g) > 0) {\n      if (cross(pol[a]-g, p-g) > 0 && cross(pol[c]-g, p-g) < 0) b = c;\n      else                                                      a = c;\n    } else {\n      if (cross(pol[a]-g, p-g) < 0 && cross(pol[c]-g, p-g) > 0) a = c;\n      else                                                      b = c;\n    }\n  }\n  b %= n;\n  if (cross(pol[a] - p, pol[b] - p) < 0) return 0;\n  if (cross(pol[a] - p, pol[b] - p) > 0) return 2;\n  return 1;\n}\n\nP projection(const L &l, const P &p) {\n  double tmp = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + tmp*(l[0]-l[1]);\n}\n\nbool intersectSP(const L &s, const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLS(const L &l, const L &s) {\n  return\n    cross(l[1]-l[0], s[0]-l[0])*\n    cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n\nP crosspoint(const L &l, const L &m){\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return -1;\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble calcDist2(P p){\n  double res = 999999999;\n  for(int i = 0; i < n; i++){\n    P from = t[i];\n    P to = t[(i + 1) % n];\n    res = min(res, distanceSP(L(from, to), p));\n  }\n  return res;\n}\n\nvoid setY(double sx){\n  ly = 10001;\n  hy = -1;\n\n  for(int i = 0; i < n; i++){\n    P from = t[i];\n    P to = t[(i + 1) % n];\n    if(!intersectLS(L(P(sx, 0), P(sx, 1)), L(from, to))) continue;\n    P cp = crosspoint(L(P(sx, 0), P(sx, 1)), L(from, to));\n    ly = min(ly, cp.imag());\n    hy = max(hy, cp.imag());\n  }\n}\n\ndouble calcDist(double sx){\n  setY(sx);\n\n  for(int i = 0; i < 100; i++){\n    double ny1 = (ly * 2 + hy) / 3.0;\n    double ny2 = (ly + hy * 2) / 3.0;\n\n    if(!contains(t, P(sx, ny1))){\n      ly = ny1;\n      continue;\n    }\n    if(!contains(t, P(sx, ny2))){\n      hy = ny2;\n      continue;\n    }\n\n    double dist1 = calcDist2(P(sx, ny1));\n    double dist2 = calcDist2(P(sx, ny2));\n\n    if(dist1 < dist2){\n      ly = ny1;\n    }\n    else{\n      hy = ny2;\n    }\n  }\n\n  return calcDist2(P(sx, ly));\n}\n\nvoid solve(){\n  for(int i = 0; i < 100; i++){\n    double nx1 = (lx * 2 + hx) / 3.0;\n    double nx2 = (lx + hx * 2) / 3.0;\n    double dist1 = calcDist(nx1);\n    double dist2 = calcDist(nx2);\n\n    if(dist1 < dist2){\n      lx = nx1;\n    }\n    else{\n      hx = nx2;\n    }\n  }\n\n  cout << setprecision(10) << fixed << calcDist(lx) << endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    lx = 20000;\n    hx = -1;\n    t.clear();\n\n    for(int i = 0; i < n; i++){\n      P tmp;\n      cin >> tmp.real() >> tmp.imag();\n      t.push_back(tmp);\n      lx = min(lx, t[i].real());\n      hx = max(hx, t[i].real());\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tdo {\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tfor (int i = 1; i <= 2; ++i) {\n\t\t\t\tPoint laglanju(is_ll(edges[0], edges[i]));\n\t\t\t\tLine a(laglanju, edges[0][0]);\n\t\t\t\tif (abs(a[1] - a[0]) == 0)a = Line(laglanju, edges[0][1]);\n\t\t\t\tLine b(laglanju, edges[i][0]);\n\t\t\t\tif (abs(b[1] - b[0]) == 0)b = Line(laglanju, edges[i][1]);\n\t\t\t\tconst Point avec(a[1]-a[0]);\n\t\t\t\tconst Point bvec(b[1] - b[0]);\n\t\t\t\tPoint nvec((abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n\t\t\t\tnlines.emplace_back(laglanju, laglanju + nvec);\n\t\t\t}\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<cassert>\n#include<complex>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define all(n) (n).begin(),(n).end()\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n//---------------\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x;}\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y;}\n\ndouble abs(Point a){return sqrt(norm(a));}\n\nbool pequals(Point a,Point b){ return equals(a.x,b.x) && equals(a.y,b.y); }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nSegment slideSeg(Segment seg,double r)\n{\n  Point p = (seg.p2-seg.p1)*r/abs(seg.p2-seg.p1);\n  p = rotate(p,toRad(90.0));\n  seg = Segment(seg.p1+p,seg.p2+p);\n  if(fabs(seg.p1.x) < EPS)seg.p1.x = 0;\n  if(fabs(seg.p1.y) < EPS)seg.p1.y = 0;\n  if(fabs(seg.p2.x) < EPS)seg.p2.x = 0;\n  if(fabs(seg.p2.y) < EPS)seg.p2.y = 0;\n  return seg;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }\n    return u;\n}\n\n\n//---------------\n\nint n;\n\nbool check(vector<Point> ps,double d)\n{\n  Polygon poly = ps;\n  rep(i,n)\n    {\n      Segment seg = Segment(ps[i],ps[(i+1)%n]);\n      seg = slideSeg(seg,d);\n      poly = cutPolygon(poly,seg);\n    }\n  return poly.empty();\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      vector<Point> ps(n);\n      rep(i,n)cin >> ps[i].x >> ps[i].y;\n\n      double L,R,M;\n      L = 0;\n      R = inf;\n      rep(_,100)\n\t{\n\t  M = (L+R)*0.5;\n\t  if(check(ps,M))R = M;\n\t  else           L = M;\n\t}\n\n      cout << setiosflags(ios::fixed) << setprecision(10) << M << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <set>\n#include <complex>\nusing namespace std;\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\n\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\n\n\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nP crosspointLL(const L &l, const L &m) {\n\tld A = cross(l[1] - l[0], m[1] - m[0]);\n\tld B = cross(l[1] - l[0], l[1] - m[0]);\n\tif(abs(A) < eps && abs(B) < eps) return m[0]; // same line\n\tif(abs(A) < eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n#define curr(pol, i) pol[i]\n#define next(pol, i) pol[(i+1)%pol.size()]\nG convex_cut(const G& pol, const L& l) {\n\tG res;\n\tfor(int i = 0; i < pol.size(); ++i) {\n\t\tP A = curr(pol, i), B = next(pol, i);\n\t\tif(ccw(l[0], l[1], A) != -1) res.push_back(A);\n\t\tif(ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n\t\t\tres.push_back(crosspointLL(L(A, B), l));\n\t}\n\treturn res;\n}\n\nint n;\nG ps;\nvector<L> ls;\nbool check(double x) {\n\tG res = ps;\n\tfor(int i = 0; i < n; i++) {\n\t\tP a = ls[i][1] - ls[i][0];\n\t\tP d = a * polar(x / abs(a), pi / 2);\n\t\tL lx = L(ls[i][0] + d, ls[i][1] + d);\n\t\tres = convex_cut(res, lx);\n\t\tif(res.size() < 3) return false;\n\t}\n\treturn true;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tps.clear();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.push_back(P(x, y));\n\t\t}\n\t\tls.clear();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tls.push_back(L(ps[i], ps[(i + 1) % n]));\n\t\t}\n\n\t\tdouble ok = 0, ng = 1e9;\n\t\tfor(int loop = 0; loop < 200; loop++) {\n\t\t\tdouble x = (ok + ng) / 2;\n\t\t\tif(check(x)) ok = x;\n\t\t\telse ng = x;\n\t\t}\n\n\t\tcout << fixed << setprecision(15) << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\tint n=0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%.8f\\n\",left);\n\t\tn++;\n\t}\n\tif(n>29)return 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Line{\n\tLine(){\n\t\tp[0].x = p[0].y = p[1].x = p[1].y = 0;\n\t}\n\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nint N;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\nstatic const double PI = acos(-1);\n\nPoint rotate(Point point,double theta){\n    return Point(point.x*cos(theta)-point.y*sin(theta),point.x*sin(theta)+point.y*cos(theta));\n}\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPolygon ConvexCut(Polygon g,Line line){\n\n\tPolygon ret;\n\tPoint a = line.p[0];\n\tPoint b = line.p[1];\n\n\tint N = g.size();\n\n\tfor(int i = 0; i < g.size(); i++){\n\t\tPoint A = g[i], B = g[(i+1)%N];\n\t\tif(ccw(a,b,A) != -1)ret.push_back(A);\n\t\tif(ccw(a,b,A)*ccw(a,b,B) == -1)ret.push_back(calc_Cross_Point(a,b,A,B));\n\t}\n\n\treturn ret;\n}\n\nPolygon G;\n\n\n\nvoid func(){\n\n\tG.clear();\n\n\tPoint point;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%lf %lf\",&point.x,&point.y);\n\t\tG.push_back(point);\n\t}\n\n\tdouble left = 0,right = 999999999.0,m = (left+right)/2;\n\tdouble ans = 0;\n\tLine line;\n\n\tfor(int i = 0; i < 100; i++){\n\t\tPolygon CALC = G;\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tPoint vec = G[(k+1)%N]-G[k];\n\t\t\tvec = vec/abs(vec);\n\t\t\tvec = rotate(vec,PI/2);\n\t\t\tline.p[0] = G[k]+vec*m;\n\t\t\tline.p[1] = G[(k+1)%N]+vec*m;\n\t\t\tCALC = ConvexCut(CALC,line);\n\t\t}\n\t\tif(CALC.empty()){\n\t\t\tright = m-EPS;\n\t\t}else{\n\t\t\tans = m;\n\t\t\tleft = m+EPS;\n\t\t}\n\t\tm = (left+right)/2;\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) const { return Point(k * x, k * y); }\n    Point operator/(double k) const { return Point(x / k, y / k); }\n    Point operator-() const { return Point(-x, -y); }\n};\ndouble dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\ndouble norm(const Point& a) { return sqrt(dot(a, a)); }\nPoint rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \nostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\nistream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nint ccw(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n    if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nstruct Segment {\n    Point a, b;\n    Segment() {}\n    Segment(const Point& a, const Point& b) : a(a), b(b) {}\n};\nPoint projection(const Segment& l, const Point& p) {\n    Point u = (p - l.a), v = (l.b - l.a);\n    return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n}\nbool intersects(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\ndouble dist(const Segment& s, const Point& p) {\n    Point q = projection(Segment(s.a, s.b), p);\n    Segment t(p, q);\n    if (intersects(s, t)) return norm(t.b - t.a);\n    return min(norm(s.a - p), norm(s.b - p));\n}\nPoint crosspoint(const Segment& s, const Segment& t) {\n    assert(intersects(s, t));\n    Point u = s.b - s.a,\n          v = t.b - t.a;\n    return s.a - u * cross(v, t.a - s.a) / cross(u, v);\n}\n\nstruct Circle {\n    Point p;\n    double r;\n    Circle() {}\n    Circle(const Point& p, double r) : p(p), r(r) {}\n};\nostream& operator<<(ostream& os, const Circle& c) {\n    return os << \"Circle[\" << c.p << \",\" << c.r << \"]\";\n}\n\ntypedef vector<Point> Polygon;\n\nbool contains(const Polygon& c, const Point& p) {\n    int n = int(c.size());\n    int x = ccw(p, c[0], c[1]);\n    for (int i = 0; i < n; i++) {\n        Point a = c[i];\n        Point b = c[(i + 1) % n];\n        if (x != ccw(p, a, b)) return false;\n    }\n    return true;\n}\n\nbool contains(const Polygon& c, const Circle& cir) {\n    if (!contains(c, cir.p)) { return false; }\n    int n = int(c.size());\n    for (int i = 0; i < n; i++) {\n        Point a = c[i];\n        Point b = c[(i + 1) % n];\n        Segment s(a, b);\n        if (dist(s, cir.p) + EPS < cir.r) return false;\n    }\n    return true;\n}\n\nvoid add_moved_segment(const Segment& s, double r, vector<Segment>& ss) {\n    Point v = s.b - s.a;\n    Point u = rot90(v) / norm(v) * r;\n    ss.push_back(Segment(s.a + u, s.b + u));\n    u = -rot90(v) / norm(v) * r;\n    ss.push_back(Segment(s.a + u, s.b + u));\n}\n\nint N;\nvector<Point> P;\n\nbool input() {\n    cin >> N;\n    if (N == 0) return false;\n    P.clear(); P.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i];\n    }\n    return true;\n}\n\nconst double INF = 1e5;\n\nbool C(double r) {\n    vector<Segment> ss;\n    for (int i = 0; i < N; i++) {\n        Segment e(P[i], P[(i + 1) % N]);\n        add_moved_segment(e, r, ss);\n    }\n    int M = int(ss.size());\n    vector<Point> ps;\n    for (int i = 0; i < M; i++) {\n        for (int j = i + 1; j < M; j++) {\n            if (!intersects(ss[i], ss[j])) continue;\n            ps.push_back(crosspoint(ss[i], ss[j]));\n        }\n    }\n    for (int i = 0; i < ps.size(); i++) {\n        Point& p = ps[i];\n        if (contains(P, Circle(p, r))) return true;\n    }\n    return false;\n}\n\nvoid solve() {\n    double lb = 0, ub = INF;\n    for (int _ = 0; _ < 50; _++) {\n        double mid = (lb + ub) / 2;\n        (C(mid) ? lb : ub) = mid;\n    }\n    printf(\"%.12lf\\n\", lb);\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n// 2D GEOMETORY //\n\n// 平面上の点。もしくは平面上のベクトル。\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x * _.x + y * _.y; } // 内積\n\tdouble cross(const P2 &_) const { return x * _.y - y * _.x; } // 外積\n\tdouble sqlength() const { return x * x + y * y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\n\n/// 直線\nstruct Line\n{\n\tP2 p, d; // 始点・方向\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d; // 始点・方向大きさ\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\ntypedef vector<P2> Polygon;\n\npair<Polygon, Polygon> cutConvexPolygon(const Polygon &polygon, const Line &cut)\n{\n\tint N = polygon.size();\n\tPolygon left, right;\n\tREP(i, N)\n\t{\n\t\tP2 p0 = polygon[i];\n\t\tP2 p1 = polygon[(i + 1) % N];\n\t\tint d1 = sign_of(cut.d.cross(p1 - cut.p)); // -1:cw, 0:on, 1:ccw\n\t\tint d0 = sign_of(cut.d.cross(p0 - cut.p)); // -1:cw, 0:on, 1:ccw\n\n\t\tif (d0 == 0) // p0 on cut line\n\t\t{\n\t\t\tleft.push_back(p0);\n\t\t\tright.push_back(p0);\n\t\t}\n\t\telse  // p0 and p1 are the same side.\n\t\t{\n\t\t\tif (d0 < 0)\n\t\t\t{\n\t\t\t\tleft.push_back(p0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tright.push_back(p0);\n\t\t\t}\n\n\t\t\tif (d0 * d1 < 0)\n\t\t\t{\n\t\t\t\tP2 splitPoint = crossPoint(Line::From2Point(p0, p1), cut);\n\t\t\t\tleft.push_back(splitPoint);\n\t\t\t\tright.push_back(splitPoint);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (left.size() < 3) { left.clear(); }\n\tif (right.size() < 3) { right.clear(); }\n\treturn { left, right };\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\n\t\tauto polygon = read<P2>(N);\n\n\t\t// 削れる陸の距離をにぶたんで探す。\n\t\tdouble l = 0.0, r = 5000.0, m;\n\n\t\twhile (abs(l - r) >= 0.0000001)\n\t\t{\n\t\t\tm = (r - l) / 2 + l; // 陸を削る\n\n\t\t\tPolygon poly = polygon;\n\t\t\tREP(i,N)\n\t\t\t{\n\t\t\t\tLineSeg cutLine = LineSeg::From2Point(polygon[i], polygon[(i + 1) % N]);\n\t\t\t\tcutLine.p = cutLine.p + -cutLine.d.orthogonal().direction() * m; // 辺に垂直な方向に m だけ動かした直線。\n\t\t\t\tpoly = cutConvexPolygon(poly, cutLine).second;\n\t\t\t}\n\t\t\tDEBUG(m);\n\t\t\tbool ok = poly.size() > 0; // 陸地がちょっとでも残ってればOK\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tWRITE(m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double PI  = acos(-1.0);\nconst double mEPS = 1e-10;\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n  Point operator + (const Point& p) const{ return Point(x + p.x, y + p.y); }\n  Point& operator += (const Point& p){ x += p.x; y += p.y; return *this;}\n  Point operator - (const Point& p) const{ return Point(x - p.x, y - p.y); }\n  Point& operator -= (const Point& p){ x -= p.x; y -= p.y; return *this;}\n  Point operator * (double a) const{ return Point(a*x, a*y); }\n  Point& operator *= (double a){ x *= a; y *= a; return *this;}\n  Point operator / (double a) const{ return Point(x / a, y / a); }\n  Point& operator /= (double a){ x /= a; y /= a; return *this;}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n  friend ostream& operator <<(ostream& os, const Point& p);\n};\nostream& operator <<(ostream& os, const Point& p){\n  return os << \"(\" << p.x << \",\"<<p.y << \")\";\n}\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n  Segment(){}\n  Segment(const Point& p1_, const Point& p2_)\n\t: p1(p1_), p2(p2_)\n  {}\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\nPoint project(Line s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\nPoint rotate(Point p,double angle){\n  return Point(p.x*cos(angle) - p.y*sin(angle),\n\t\t\t   p.x*sin(angle) + p.y*cos(angle));\n}\n\nSegment get(const Segment& s, double d){\n  Vector v = (s.p2 - s.p1);\n  v = v * d / v.abs();\n  v = rotate(v, PI / 2.);\n  \n  Segment res = s;\n  res.p1 += v; res.p2 += v;\n  return res;\n}\n\nPolygon convex_cut(const Polygon& pol, const Line& l) {\n  Polygon Q;\n  for (unsigned int i = 0; i < pol.size(); ++i) {\n    Point A = pol[i], B = pol[(i+1)%pol.size()];\n    if (ccw(l.p1, l.p2, A) != -1) Q.push_back(A);\n    if (ccw(l.p1, l.p2, A)*ccw(l.p1, l.p2, B) < 0){\n\t  Line tmp; tmp.p1 = A, tmp.p2 = B;\n      Q.push_back(getCrossPoint(tmp, l));\n\t}\n  }\n  return Q;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tvector<Point> ps(N);\n\tREP(i,N) cin >> ps[i].x >> ps[i].y;\n\tdouble lb = 0., ub = 10000;\n\tvector<Segment> ovs(N);\n\tREP(i,N) ovs[i] = Segment(ps[i], ps[(i+1)%N]);\n\n\tREP(loop,100){\n\t  double r = (lb + ub) / 2.;\n\t  Polygon poly = ps;\n\t  REP(i,N) poly = convex_cut(poly, get(ovs[i], r));\n\t  bool ok = !poly.empty();\n\n\t  if(ok) lb = r;\n\t  else ub = r;\n\t}\n\tcout << fixed << setprecision(9) << lb << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\ntypedef complex<double> cmp;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n//const int dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\nconst int dir[]={1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ndouble Cross(const cmp &a,const cmp &b){\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble DistanceLP(const cmp &a,const cmp &b,const cmp &c){\n\treturn abs(Cross(b-a,c-a))/abs(b-a);\n}\n\ndouble GetMinDistanceLP(const vec<cmp> &p,const cmp &a){\n\tdouble res=INF;\n\tREP(i,1,p.size()) res=min(res,DistanceLP(p[i],p[i-1],a));\n\tres=min(res,DistanceLP(p[0],p[p.size()-1],a));\n\treturn res;\n}\n\ncmp CenterOfGravity(const vec<cmp> &p){\n\tdouble resx=0,resy=0;\n\tREP(i,0,p.size()){\n\t\tresx+=p[i].real();\n\t\tresy+=p[i].imag();\n\t}\n\treturn cmp(resx/p.size(),resy/p.size());\n}\n\ninline double GetStep(const double max_cnt,const double cnt,const double score){\n\tconst double rate=((max_cnt-cnt)/max_cnt)*((max_cnt-cnt)/max_cnt);\n\treturn cnt/max_cnt*((1e-7)-score*rate)+score*rate;\n}\n\ndouble Solve(const vec<cmp> &p){\n\tcmp a=CenterOfGravity(p);\n\tdouble best_score=GetMinDistanceLP(p,a);\n\tconst int max_cnt=100000;\n\trandom_device seed_gen;\n\tmt19937 engine(seed_gen());\n\tREP(cnt,0,max_cnt){\n\t\tconst double step=GetStep(max_cnt,cnt,best_score);\n\t\tconst int signx=dir[engine()%3];\n\t\tconst int signy=dir[engine()%3];\n\t\tcmp na(a.real()+signx*step,a.imag()+signy*step);\n\t\tdouble next_score=GetMinDistanceLP(p,na);\n\t\tif(next_score>=best_score){\n\t\t\tbest_score=next_score;\n\t\t\ta=na;\n\t\t}\n\t}\n\treturn best_score;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile(true){\n\t\tcin >> N;\n\t\tif(!N) break;\n\t\tvec<cmp> p(N);\n\t\tREP(i,0,N){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tprintf(\"%.5f\\n\",Solve(p));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LE(n,m) ((n) < (m) + EPS * (abs(n) + abs(m)))\n#define GE(n,m) ((n) + EPS * (abs(n) + abs(m)) > (m))\n#define LT(n,m) ((n) + EPS * (abs(n) + abs(m)) < (m))\n#define GT(n,m) ((n) > (m) + EPS * (abs(n) + abs(m)))\n#define EQ(n,m) (abs((n)-(m)) < EPS * (abs(n) + abs(m)))\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\ntypedef pair<P, P> L;\n\nvector<P> poly;\n\nint N;\n\ndouble dot(P a, P b) {\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\ndouble distLP(P a1, P a2, P p) {\n    return abs(cross(a2-a1,p-a1))/abs(a2-a1);\n}\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n    ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\t// same line\n    return a1 + d1 / d2 * (a2-a1);\n}\n\nbool ok(double l){\n    vector<L> lines(N);\n    for(int i=0; i<N; i++){\n        auto p1 = poly[i], p2 = poly[(i+1)%N];\n        auto v = (p2 - p1)/abs(p2 - p1) * P(0, 1) * l;\n        auto np1 = p1 + v, np2 = p2 + v;\n        lines[i] = L(np1, np2);\n    }\n    for(int i=0; i<N; i++){\n        for(int j=i+1; j<N; j++){\n            auto& a1 = lines[i].first, a2 = lines[i].second;\n            auto& b1 = lines[j].first, b2 = lines[j].second;\n            if(!isecSS(a1, a2, b1, b2)) continue;\n            \n            auto p = crosspointLL(a1, a2, b1, b2);\n            bool flag = true;\n            for(int k=0; k<N; k++){\n                auto& p1 = poly[k], p2 = poly[(k+1)%N];\n                flag &= GE(distLP(p1, p2, p), l);\n            }\n            if(flag)\n                return true;\n        }\n    }\n    return false;\n}\n\nvoid solve(){\n    double lb = 0, ub = 10000;\n    for(int i=0; i<100; i++){\n        double m = (lb + ub)/2;\n        if(ok(m))\n            lb = m;\n        else\n            ub = m;\n    }\n    cout << lb << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(16);\n    cout.setf(ios::fixed);\n\n    while(cin >> N, N){\n        poly.resize(N);\n        for(int i=0; i<N; i++){\n            int x, y; cin >> x >> y;\n            poly[i] = P(x, y);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  /*\n    Polygon A;\n    A.push_back(P(inf,inf)); A.push_back(P(-inf,inf));\n    A.push_back(P(-inf,-inf)); A.push_back(P(inf,-inf));\n  */\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\ndouble solve(){\n    int v[]{rand()%(n-2),rand()%(n-2),rand()%(n-2)};\n    sort(v,v+3);\n    v[1]++;v[2]+=2;\n    P p=innerCenter(ps[v[0]],ps[v[1]],ps[v[2]]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    static double d[128];\n    int near=0;\n    double r[]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10};\n    rep(t,200000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n){\n            if(d[i]<d[near]){\n                near=i;\n            }\n        }\n        P h=projection(es[near],p);\n        p -= (h-p)/d[near]*r[t/20000];\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-12;\nconst double inf = 1000000;\n\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea2(const vector<P> &g) {\n  int n = g.size();\n  double s = 0;\n  for(int i = 0; i < n; ++i) {\n    s += cross(g[i], g[(i+1)%n]);\n  }\n  return s;\n}\n\nint main() {\n  int n;\n  vector<P> base;\n  base.push_back(P(-inf,-inf));\n  base.push_back(P(inf,-inf));\n  base.push_back(P(inf,inf));\n  base.push_back(P(-inf,inf));\n  while(cin >> n && n) {\n    vector<P> ps(n);\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l, r;\n    l = 0.0;\n    r = inf;\n    while(!equals(l, r)) {\n      double d = (l+r)/2.0;\n      vector<P> g = base;\n      for(int i = 0; g.size() > 2 && i < n; ++i) {\n\tint s = i;\n\tint t = (i+1)%n;\n\tP v = ps[t] - ps[s];\n\tP u = P(-v.imag(), v.real());\n\tg = convex_cut(g, ps[s]+u*d/abs(u), ps[t]+u*d/abs(u));\n      }\n      if(g.size() <= 2 || equals(getArea2(g), 0.0)) {\n\tr = d;\n      } else {\n\tl = d;\n      }\n    }\n    printf(\"%.6f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstatic const double INF = 1e+5;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\nPoint crosspointSS(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) { return m[0]; }\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPolygon convex_cut(const Polygon &P, const Line &l) {\n  Polygon Q;\n  REP(i, P.size()) {\n    Point A = CURR(P, i), B = NEXT(P, i);\n    if (ccw(l[0], l[1], A) != -1) { Q.push_back(A); }\n    if (ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0) {\n      Q.push_back(crosspointSS(Line(A, B), l));\n    }\n  }\n  return Q;\n}\n\nLine move(Line l, double dist) {\n  Point vect2 = l[1] - l[0];\n  Point vect = vect2 * Point(0, 1);\n  vect *= dist / abs(vect);\n  l[0] += vect;\n  l[1] += vect;\n  l[1] += vect2 * INF;\n  l[0] -= vect2 * INF;\n  return l;\n}\n\nPolygon iniP;\nbool cut(Polygon poly, double l) {\n  REP(i, iniP.size()) {\n    poly = convex_cut(poly, move(Line(CURR(iniP, i), NEXT(iniP, i)), l));\n    if (poly.size() == 0) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    iniP.clear();\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      iniP.push_back(Point(x, y));\n    }\n    double left = 0;\n    double right = 1e+5;\n    REP(i, 100) {\n      double mid = (left + right) / 2.0;\n      if (cut(iniP, mid)) {\n        left = mid;\n      } else {\n        right = mid;\n      }\n    }\n    printf(\"%.5f\\n\", left);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <complex>\n#include <random>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\ntypedef complex<double> cmp;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n//const int dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\nconst int dir[]={1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ndouble Cross(const cmp &a,const cmp &b){\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble DistanceLP(const cmp &a,const cmp &b,const cmp &c){\n\treturn abs(Cross(b-a,c-a))/abs(b-a);\n}\n\ndouble GetMinDistanceLP(const vector<cmp> &p,const cmp &a){\n\tdouble res=INF;\n\tREP(i,1,p.size()) res=min(res,DistanceLP(p[i],p[i-1],a));\n\tres=min(res,DistanceLP(p[0],p[p.size()-1],a));\n\treturn res;\n}\n\ncmp CenterOfGravity(const vector<cmp> &p){\n\tdouble resx=0,resy=0;\n\tREP(i,0,p.size()){\n\t\tresx+=p[i].real();\n\t\tresy+=p[i].imag();\n\t}\n\treturn cmp(resx/p.size(),resy/p.size());\n}\n\ninline double GetStep(const double max_cnt,const double cnt,const double score){\n\tconst double rate=((max_cnt-cnt)/max_cnt)*((max_cnt-cnt)/max_cnt);\n\treturn cnt/max_cnt*((1e-7)-score*rate)+score*rate;\n}\n\ndouble Solve(const vector<cmp> &p){\n\tcmp a=CenterOfGravity(p);\n\tdouble best_score=GetMinDistanceLP(p,a);\n\tconst int max_cnt=100000;\n\trandom_device seed_gen;\n\tmt19937 engine(seed_gen());\n\tREP(cnt,0,max_cnt){\n\t\tconst double step=GetStep(max_cnt,cnt,best_score);\n\t\tconst int signx=dir[engine()%3];\n\t\tconst int signy=dir[engine()%3];\n\t\tcmp next_a(a.real()+signx*step,a.imag()+signy*step);\n\t\tdouble next_score=GetMinDistanceLP(p,next_a);\n\t\tif(next_score>=best_score){\n\t\t\tbest_score=next_score;\n\t\t\ta=next_a;\n\t\t}\n\t}\n\treturn best_score;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N;\n\twhile(true){\n\t\tcin >> N;\n\t\tif(!N) break;\n\t\tvector<cmp> p(N);\n\t\tREP(i,0,N){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i].real(x);\n\t\t\tp[i].imag(y);\n\t\t}\n\t\tprintf(\"%.6f\\n\",Solve(p));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nint n;\nvoid solve() {\n\tvector<Point> v(n);\n\trep(i, n) {\n\t\tld x, y; cin >> x >> y;\n\t\tv[i] = { x,y };\n\t}\n\tv.push_back(v[0]);\n\tvector<Line> l(n);\n\tvector<LDP> d(n);\n\trep(i, n) {\n\t\tl[i] = { v[i],v[i + 1] };\n\t\tld dx = real(v[i + 1]) - real(v[i]);\n\t\tld dy = imag(v[i + 1]) - imag(v[i]);\n\t\tld r = pow(dx, 2) + pow(dy, 2); r = sqrt(r);\n\t\td[i] = { dx / r,dy / r };\n\t}\n\tld ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tRep(k, i+ 1, n) {\n\t\t\t\tif (i == j || j == k)continue;\n\t\t\t\tif (!isis_ll(l[i], l[j]) || !isis_ll(l[j], l[k]))continue;\n\t\t\t\tPoint a = is_ll(l[i], l[j]), b = is_ll(l[j], l[k]);\n\t\t\t\tld vx = (d[j].first - d[i].first) / 2.0;\n\t\t\t\tld vy = (d[j].second - d[i].second) / 2.0;\n\t\t\t\tPoint sa = { real(a) + vx,imag(a) + vy };\n\t\t\t\tvx = (d[k].first - d[j].first) / 2.0;\n\t\t\t\tvy = (d[k].second - d[j].second) / 2.0;\n\t\t\t\tPoint sb = { real(b) + vx,imag(b) + vy };\n\t\t\t\tLine la = { a,sa }, lb = { b,sb };\n\t\t\t\tPoint m = is_ll(la, lb);\n\t\t\t\tld mi = INF;\n\t\t\t\tint cnt = 0;\n\t\t\t\trep(x, n) {\n\t\t\t\t\tcnt += ccw(v[x], v[x + 1], m);\n\t\t\t\t\tmi = min(mi, dist_lp(l[x], m));\n\t\t\t\t}\n\t\t\t\t//cout << mi << endl;\n\t\t\t\t//ans = max(ans, mi);\n\t\t\t\tcnt = abs(cnt);\n\t\t\t\tif (cnt == n) {\n\t\t\t\t\tans = max(ans, mi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(9);\n\twhile (cin >>n,n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n        trace(line1);\n        trace(line2);\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{ \n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0\n            && abs(a - b) > 1e-8) // 平行で交点できない\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[(i + 1) % g.size()] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[(i + 1) % g.size()] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e5;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n\n        printf(\"%.6f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-11;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      vec v = uvec( (uva + uvb) );\n      point cr = intersectionLL(a,b);\n      \n      long double r = 1e30;\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<1000){\n        long double m = (r+l)/2.;\n        point c = m * v + cr;\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          l = m;\n        }\n      }\n      res = max( res, radi );\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tdo {\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tfor (int i = 1; i <= 2; ++i) {\n\t\t\t\tnlines.emplace_back(bisection(edges[0], edges[i]));\n\t\t\t}\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;\t\t// clockwise\n\tif(dot(b, c) < -EPS)     return +2;\t\t// c--a--b on line\n\tif(norm(b) + EPS < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n// !CAUTION! number は有理数以上\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n    P A = curr(po, i), B = next(po, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tG g(n);\n\t\trep(i, n) cin >> g[i].real() >> g[i].imag();\n\t\tdouble lo = 0, hi = 20000, mid;\n\t\trep(it, 100){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tG g2 = g;\n\t\t\trep(i, n){\n\t\t\t\tP d = g[(i + 1) % n] - g[i];\n\t\t\t\td *= P(0, 1);\n\t\t\t\td *= mid / abs(d);\n\t\t\t\tg2 = convex_cut(g2, L(g[i] + d, g[(i + 1) % n] + d));\n\t\t\t}\n\t\t\tif(g2.empty()) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\", hi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\npoint inscribedCircleCenter( point a, point b, point c )\n{\n  long double A = abs( c - b ), B = abs( c - a ), C = abs( b - a );\n  long double S = A + B + C;\n  return (A / S) * a + (B / S) * b + (C / S) * c;\n}\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    point c;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%n] );\n      line b( vp[i], vp[(i-1+n)%n] );\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      vec v = uvec( (uva + uvb) );\n\n      assert(!prll(a,b));\n      assert(abs(uva)>0&&abs(uvb)>0);\n\n      long double r = 0;\n      for(int j = 0; j < n; ++j){\n        r = max(r,10*abs(vp[i]-vp[j]));\n      }\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<300){\n        long double m = (r+l)/2.;\n        c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        //cout << m << ' ' << vp[i] << ' ' << c << ' ' << radi << endl;\n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%n]);\n          //cout << dist_seg(s,c) << ' ';\n          if( k == i ) continue;\n          if( k == (i-1+n)%n ) continue;\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        //cout << endl;\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    //cout << c << ' ' << inscribedCircleCenter(vp[0],vp[1],vp[2]) << endl;\n    cout << fixed << setprecision(8) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nvector<P> convexCut(const vector<P> &vp, P p, P q){\n\tvector<P> res;\n\tint n = vp.size();\n\tfor(int i=0;i<n;i++){\n\t\tP A(vp[i]), B(vp[(i+1)%n]);\n\t\tdouble p1 = cross(q-p,A-p);\n\t\tdouble p2 = cross(q-p,B-p);\n\t\tif(p1 > -EPS) res.push_back(A);\n\t\tif(p1*p2 < -EPS)\n\t\t\tres.push_back(A+cross(q-p,q-A)/cross(q-p,B-A)*(B-A));\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<P> vp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tvp.push_back(P(x,y));\n\t\t}\n\t\tdouble L = 0.0, R = 1e6;\n\t\tfor(int cnt=0;cnt<200;cnt++){\n\t\t\tdouble mid = 0.5*(L+R);\n\t\t\tvector<P> cur = vp;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tP dir = P(0,1)*(vp[(i+1)%n]-vp[i]);\n\t\t\t\tdir = dir/abs(dir)*mid;\n\t\t\t\tcur = convexCut(cur, vp[i]+dir, vp[(i+1)%n]+dir); \n\t\t\t}\n\t\t\tcur.empty() ? R = mid : L = mid;\n\t\t}\n\t\tprintf(\"%.8lf\\n\", 0.5*(L+R));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef complex<double> point,vec;\ntypedef pair<point,point> seg,line;\nconst double eps = 1e-9;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\ndouble dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\ndouble dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\ndouble dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first );\n      vec uvb = uvec( b.second- b.first );\n      vec v = uvec( (uva + uvb) );\n      point cr = intersectionLL(a,b);\n      \n      double r = 1e40;\n      double l = 0;\n      int cnt = 0;\n      double radi;\n      while(cnt++<250){\n        double m = (r+l)/2.;\n        point c = m * v + cr;\n        radi = dist_l(a,c);\n        bool ng = false;\n\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        //cout << a.first << ' ' << m << ' ' << c  << endl;\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c)+eps ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          l = m;\n        }\n      }\n      res = max( res, radi );\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    R u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.y-l.x) / abs(l) * P(0, -1); //l?????´???????????????????????????\n    v *= u;\n    if (ccw(l.x, l.y, c.p) < 0) v *= -1;\n    //v?????????????????????l?????¨??????????????????????????????\n    if (si == 0) {\n        r.x = r.y = c.p + v;\n        return 1;\n    }\n    r.x = c.p+v+polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    r.y = c.p+v-polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    return 2;\n}\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\n\ntypedef vector<P> Pol;\n\nP cu(Pol p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nPol l2rect(const L &l, R r) {\n    P v = vec(l)*P(0, 1) / abs(vec(l)) * r;\n    Pol p;\n    p.push_back(l.x + v);\n    p.push_back(l.x - v);\n    p.push_back(l.y - v);\n    p.push_back(l.y + v);\n    return p;\n}\n\n\nint n;\nPol po;\n\nbool solve(R md) {\n    int n = po.size();\n    vector<C> cv;\n    vector<L> lv;\n    vector<Pol> pov;\n    for (int i = 0; i < n; i++) {\n        cv.push_back(C(po[i], md));\n    }\n    for (int i = 0; i < n; i++) {\n        pov.push_back(l2rect(L(po[i], po[(i+1)%n]), md));\n    }\n    for (Pol pp : pov) {\n        for (int i = 0; i < 4; i++) {\n            lv.push_back(L(cu(pp, i), cu(pp, i+1)));\n        }\n    }\n    vector<P> pv;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            L l;\n            if (crossCC(cv[i], cv[j], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (int i = 0; i < n*4; i++) {\n        for (int j = i+1; j < n*4; j++) {\n            P pp;\n            if (crossSS(lv[i], lv[j], pp)) {\n                pv.push_back(pp);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n*4; j++) {\n            L l;\n            if (crossLC(lv[j], cv[i], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (P p: pv) {\n        if (contains(po, p) == 0) continue;\n        bool f = true;\n        for (Pol &po: pov) {\n            if (contains(po, p) == 2) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        for (C &c: cv) {\n            if (sgn(abs(c.p - p), c.r) == 1) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        po.clear();\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            cin >> x >> y;\n            po.push_back(P(x, y));\n        }\n        R l = 0, r = 1e6;\n        for (int i = 0; i < 50; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        polygon p(n);\n        for(int i=0; i<n; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        ld lb = 0, ub = 1e9;\n        while(abs(ub - lb) > eps) {\n            auto p2 = p;\n            ld m = (ub + lb) / 2;\n            for(int i=0; i<n; ++i) {\n                point a = p[i], b = p[(i+1)%n];\n                point v = (b - a) * point(0, 1);\n                v = v / abs(v) * m;\n                a += v;\n                b += v;\n                p2 = convex_cut(p2, line(a, b));\n            }\n            if(p2.size() == 0) {\n                ub = m;\n            } else {\n                lb = m;\n            }\n        }\n        cout << fixed << setprecision(10) << lb << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tPolygon npoly(origin);\n\t\tconst int atime = 1000;\n\t\tfor (int repeat = 0; repeat <= atime; ++repeat) {\n\t\t\tconst Polygon prepoly(npoly);\n\t\t\tPoint center;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tcenter += npoly[i];\n\t\t\t}\n\t\t\tcenter /= npoly.size();\n\t\t\tlong double mindis = 20000;\n\t\t\tint minid;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tlong double adis = dist_sp(Line(npoly[i], npoly[(i + 1) % npoly.size()]), center);\n\t\t\t\tif (mindis > adis){\n\t\t\t\t\tmindis = adis;\n\t\t\t\t\tminid = i;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor (int i = 0; i < prepoly.size(); ++i) {\n\t\t\t\t\n\t\t\t\tLine preline = Line(prepoly[i], prepoly[(i + 1) % prepoly.size()]);\n\t\t\t\tPoint vec = (preline[1] - preline[0])*complex<long double>(0, 1)/abs(preline[1]-preline[0])*mindis;\n\t\t\t\tif (i == minid) {\n\t\t\t\t\tvec *= 0.99999999999;\n\t\t\t\t}\n\t\t\t\tLine cutline[2];\n\t\t\t\tcutline[1] = Line(preline[0] + vec, preline[1] + vec);\n\t\t\t\tcutline[0] = Line(preline[0] - vec, preline[1] - vec);\n\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tvector<Polygon>polys(convex_cut(npoly, cutline[i]));\n\t\t\t\t\tif (is_in_polygon(polys[0], center)) {\n\t\t\t\t\t\tnpoly = polys[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnpoly = polys[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Polygon prepoly(npoly);\n\t\tPoint center;\n\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\tcenter += npoly[i];\n\t\t}\n\t\tcenter /= npoly.size();\n\t\tlong double mindis = 20000;\n\t\tfor (int i = 0; i < origin.size(); ++i) {\n\t\t\tmindis = min(mindis, dist_sp(Line(origin[i], origin[(i + 1) % origin.size()]), center));\n\t\t}\n\t\tcout << fixed<<setprecision(22)<<mindis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(area(U)>0)return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        D l=0,r=1e6;\n        rep(c,400){\n            D mid=(l+r)/2;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.9f\\n\",(l+r)/2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    R u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.y-l.x) / abs(l) * P(0, -1); //l?????´???????????????????????????\n    v *= u;\n    if (ccw(l.x, l.y, c.p) < 0) v *= -1;\n    //v?????????????????????l?????¨??????????????????????????????\n    if (si == 0) {\n        r.x = r.y = c.p + v;\n        return 1;\n    }\n    r.x = c.p+v+polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    r.y = c.p+v-polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    return 2;\n}\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\n\ntypedef vector<P> Pol;\n\nP cu(Pol p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nPol l2rect(const L &l, R r) {\n    P v = vec(l)*P(0, 1) / abs(vec(l)) * r;\n    Pol p;\n    p.push_back(l.x + v);\n    p.push_back(l.x - v);\n    p.push_back(l.y - v);\n    p.push_back(l.y + v);\n    return p;\n}\n\n\nint n;\nPol po;\n\nbool solve(R md) {\n    int n = po.size();\n    vector<C> cv;\n    vector<L> lv;\n    vector<Pol> pov;\n    for (int i = 0; i < n; i++) {\n        cv.push_back(C(po[i], md));\n    }\n    for (int i = 0; i < n; i++) {\n        pov.push_back(l2rect(L(po[i], po[(i+1)%n]), md));\n    }\n    for (Pol pp : pov) {\n        for (int i = 0; i < 4; i++) {\n            lv.push_back(L(cu(pp, i), cu(pp, i+1)));\n        }\n    }\n    vector<P> pv;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            L l;\n            if (crossCC(cv[i], cv[j], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (int i = 0; i < n*4; i++) {\n        for (int j = i+1; j < n*4; j++) {\n            P pp;\n            if (crossSS(lv[i], lv[j], pp)) {\n                pv.push_back(pp);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n*4; j++) {\n            L l;\n            if (crossLC(lv[j], cv[i], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (P p: pv) {\n        if (contains(po, p) == 0) continue;\n        bool f = true;\n        for (Pol &po: pov) {\n            if (contains(po, p) == 2) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        for (C &c: cv) {\n            if (sgn(abs(c.p - p), c.r) == 1) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        po.clear();\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            cin >> x >> y;\n            po.push_back(P(x, y));\n        }\n        R l = 0, r = 1e6;\n        for (int i = 0; i < 100; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20Lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[102];\nP point[102];\nint main(){\n\tint a;\n\tint n=0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%.8f\\n\",left);\n\t\tn++;\n\t}\n\tif(n>29)return 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 105\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,x,y;\nP p[N];\n\nL line(P a,P b,double d){\n  b-=a;\n  P B=P(abs(b),d);\n  B=B*b/abs(b)+a;\n  b+=a;\n  P A=P(B.real()-(b.real()-a.real()),B.imag()-(b.imag()-a.imag()));\n  return L(A,B);\n}\n\nbool check(double d){\n  vector<P> land;\n  for(int i=0;i<n;i++)\n    land.push_back(p[i]);\n  for(int i=0;i<n;i++)\n    land=convex_cut(land,line(p[i],p[(i+1)%n],d));\n  if(!land.size())return false;\n  return true;\n}\n\ndouble bynary_search(){\n  double L=0,R=10005;\n  while(L+EPS<R){\n    double M=(L+R)/2.0;\n    if(check(M))L=M;\n    else R=M;\n  }\n  return L;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      p[i]=P(x,y);\n    }\n    printf(\"%.6f\\n\",bynary_search());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nusing Poly=vector<P>;\nconst ld EPS=1e-9;\nstruct Line{\n    P x,y;\n};\nld cross(P x,P y){\n    return real(x)*imag(y)-real(y)*imag(x);\n}\nP is_ll(Line s,Line t){\n    return s.x+(s.y-s.x)*cross(t.x-s.x,t.y-s.x)/(cross(t.x-s.x,s.y-s.x)+cross(s.y-s.x,t.y-s.x));\n}\nenum{CCW,CW,ABC,ACB,BAC};\nint ccw(P a,P b,P c){\n    if(cross(a-b,c-b)>EPS) return CW;\n    else return CCW;\n}\nvector<Line> shrink(Poly poly,ld len){\n    int n=poly.size();\n    vector<Line> res(n);\n    for(int i=0;i<n;i++){\n        Line org={poly[i],poly[(i+1)%n]};\n        P vec=(org.y-org.x)*P(0,1);\n        vec*=len/abs(vec);\n        res[i]={org.x+vec,org.y+vec};\n    }\n    return res;\n}\n\nconst int LOOP=50;\nld solve(int n){\n    Poly poly(n);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        poly[i]={x,y};\n    }\n    ld lb=0;\n    ld ub=1e5;\n    for(int _t=0;_t<LOOP;_t++){\n        ld mid=(lb+ub)/2;\n        vector<Line> sl=shrink(poly,mid);\n        vector<P> pv;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                Line s=sl[i];\n                Line t=sl[j];\n                if(abs(cross(s.x-s.y,t.x-t.y))>EPS){\n                    pv.push_back(is_ll(s,t));\n                }\n            }\n        }\n        bool isok=true;\n        for(auto p:pv){\n            isok=true;\n            for(int i=0;i<n;i++){\n                int flag=ccw(sl[i].x,sl[i].y,p);\n                if(flag==CW){\n                    isok=false; break;\n                }\n            }    \n            if(isok){\n                break;\n            }\n        }\n        if(isok) lb=mid;\n        else ub=mid;\n    }\n    return lb;\n} \nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<setprecision(10)<<fixed;\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n\ntypedef double FP;\n\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.second-a.first);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.first,a.second,b.first,b.second);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.first,a.second,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\n\nvoid check(P a){\n\n  // assert(!isnan(a.real()));\n  // assert(!isnan(a.imag()));\n}\n\nvoid check(line a){\n  check(a.first);\n  check(a.second);  \n}\n\nbool para(line a, line b){\n  P av = a.first - a.second;\n  P bv = b.first - b.second;\n  return abs(dot(av/abs(av),bv/abs(bv))) > 1 - 1e-9;\n}\n\ndouble tri(P a, P b, P c){\n  a -= c;\n  b -= c;\n  return abs(crs(a,b));\n}\n\nline midline(line a,line b){\n  if(!para(a,b)){\n    P av = a.second - a.first;\n    P bv = b.second - b.first;\n    av /= abs(av);\n    bv /= abs(bv);\n    auto ret = line(crspt(a,b),crspt(a,b)+av+bv);\n    check(ret);\n    return ret;\n  }\n  P st =(a.first+b.first)/2.;\n  auto ret = line(st, st + a.second - a.first);\n  check(ret);\n  return ret;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n && n){\n    int x[n], y[n];\n    for(int i = 0; i < n; ++i)\n      cin >> x[i] >> y[i];\n    double cx = accumulate(x,x+n,0.)/n;\n    double cy = accumulate(y,y+n,0.)/n;\n      \n    double ans = 0;\n    for(int i = 0; i < n; ++i){\n      \n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        double r = 10000000000;\n        for(int k = 0; k < n; ++k){\n          if(i == k || j == k) continue;\n          line il = line(P(x[i],y[i]), P(x[(i+1)%n],y[(i+1)%n]));\n          line jl = line(P(x[(j+1)%n],y[(j+1)%n]), P(x[j],y[j]));\n          line kl = line(P(x[(k+1)%n],y[(k+1)%n]), P(x[k],y[k]));\n          line ij = midline(il, jl);\n          line ik = midline(il, kl);\n          // if(!iscrs(ij, ik)){\n          //   cout << ij << \"  \" << ik << endl;\n          //   continue;\n          // }\n          P ce = crspt(ij,ik);\n          if(!isnormal(ce.real()) || !isnormal(ce.imag())){\n            //cout << ce << endl;\n            continue;\n          }\n          double me = 0;\n          double me2 = 0;\n          for(int ii = 0; ii < n; ++ii){\n            me += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),ce);\n            me2 += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),P(cx,cy));\n          }\n          \n          if(abs(me-me2)/max(me,me2) > EPS){\n            //cout << me << \" \" << me2 << endl;\n            continue;\n          }\n          \n          double tr = 10000000000;\n          for(int ii = 0; ii < n; ++ii){\n            line l(P(x[ii],y[ii]),P(x[(ii+1)%n],y[(ii+1)%n]));\n            tr = min(tr, lpdist(l,ce));\n          }\n          ans = max(tr, ans);\n          //cout << ce << endl;\n          double cr = lpdist(il,ce);\n          r = min(r, cr);\n        }\n        //ans = max(r, ans);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    const std::vector<int> farthest_point_pair() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {return line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nconst std::vector<int> Polygon::farthest_point_pair() const {  // Rotating calipers\n    auto v = vertex();\n    int p, q, start_p, start_q, max_p, max_q;\n    p = start_p = max_p = std::min_element(v.begin(), v.end()) - v.begin();\n    q = start_q = max_q = std::max_element(v.begin(), v.end()) - v.begin();\n    double max_d = (vertex(p) - vertex(q)).norm();\n    do {\n        if((vertex((p + 1) % size()) - vertex(p)).cross(vertex((q + 1) % size()) - vertex(q)) >= 0) q = (q + 1) % size();\n        else p = (p + 1) % size();\n        if((vertex(p) - vertex(q)).norm() > max_d) {\n            max_d = (vertex(p) - vertex(q)).norm();\n            max_p = p;\n            max_q = q;\n        }\n    } while(start_p != q || start_q != p);\n    return {max_p, max_q};\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// 山登り法\n\n#include<iomanip>\nusing namespace std;\n\nPoint farthest_point(const Point& start, const Polygon& polygon) {\n    static const double INF = 1e9;\n    double distance = -INF;\n    Point result = start;\n    for(const auto& e: polygon.edge()) {\n        double d = start.distance(e);\n        if(distance >= d) continue;\n        distance = d;\n        Point p = start.projection(e.line());\n        if(p.intersect(e)) {\n            result = p;\n        } else {\n            result = e.source().distance(result) > e.target().distance(result) ? e.source() : e.target();\n        }\n    }\n    return result;\n}\nPoint nearest_point(const Point& start, const Polygon& polygon) {\n    static const double INF = 1e9;\n    double distance = INF;\n    Point result = start;\n    for(const auto& e: polygon.edge()) {\n        double d = start.distance(e);\n        if(distance <= d) continue;\n        distance = d;\n        Point p = start.projection(e.line());\n        if(p.intersect(e)) {\n            result = p;\n        } else {\n            result = e.source().distance(result) < e.target().distance(result) ? e.source() : e.target();\n        }\n    }\n    return result;\n}\n\nint main() {\n    cout<<setprecision(6)<<fixed;\n    int n;\n    while(cin >> n, n) {\n        Point me(0);\n        Polygon island;\n        for(int i = 0; i < n; ++i) {\n            double x, y;\n            cin >> x >> y;\n            island.add(Point(x, y));\n            me += Point(x, y);\n        }\n        me /= island.size();\n        static const double LIMIT = 1e-6;\n        static const double PI = 3.14152965358979;\n        double scale = 0.99;\n        double speed = 5000;\n        int cnt = 0;\n        double t =0;\n        while((speed *= scale) > LIMIT) {\n            double d = nearest_point(me, island).distance(me);\n            double s = farthest_point(me, island).distance(me);\n            for(double a = 0.0; a < 2.0 * PI; a += PI / 16.0) {\n                Point nex = me + Point(cos(a), sin(a)) * d * speed;\n                if(!island.include(nex)) continue;\n                double t = nearest_point(nex, island).distance(nex);\n                if(d >= t) continue;\n                d = t;\n                me = nex;\n            }\n\n        }\n        Point p = nearest_point(me, island);\n        cout<<me.distance(p)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    R u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.y-l.x) / abs(l) * P(0, -1); //l?????´???????????????????????????\n    v *= u;\n    if (ccw(l.x, l.y, c.p) < 0) v *= -1;\n    //v?????????????????????l?????¨??????????????????????????????\n    if (si == 0) {\n        r.x = r.y = c.p + v;\n        return 1;\n    }\n    r.x = c.p+v+polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    r.y = c.p+v-polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    return 2;\n}\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nPol l2rect(const L &l, R r) {\n    P v = vec(l)*P(0, 1) / abs(vec(l)) * r;\n    Pol p;\n    p.push_back(l.x + v);\n    p.push_back(l.x - v);\n    p.push_back(l.y - v);\n    p.push_back(l.y + v);\n    return p;\n}\n\n\nint n;\nPol po;\n\nbool solve(R md) {\n    int n = po.size();\n    vector<C> cv;\n    vector<L> lv;\n    vector<Pol> pov;\n    for (int i = 0; i < n; i++) {\n        cv.push_back(C(po[i], md));\n    }\n    for (int i = 0; i < n; i++) {\n        pov.push_back(l2rect(L(po[i], po[(i+1)%n]), md));\n    }\n    for (Pol &pp : pov) {\n        for (int i = 0; i < 4; i++) {\n            lv.push_back(L(cu(pp, i), cu(pp, i+1)));\n        }\n    }\n    vector<P> pv;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            L l;\n            if (crossCC(cv[i], cv[j], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (int i = 0; i < n*4; i++) {\n        for (int j = i+1; j < n*4; j++) {\n            P pp;\n            if (crossSS(lv[i], lv[j], pp)) {\n                pv.push_back(pp);\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n*4; j++) {\n            L l;\n            if (crossLC(lv[j], cv[i], l)) {\n                pv.push_back(l.x);\n                pv.push_back(l.y);\n            }\n        }\n    }\n    for (P &p: pv) {\n        if (contains(po, p) == 0) continue;\n        bool f = true;\n        for (Pol &po: pov) {\n            if (contains(po, p) == 2) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        for (C &c: cv) {\n            if (sgn(abs(c.p - p), c.r) == 1) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        cin >> n;\n        if (!n) break;\n        po.clear();\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            cin >> x >> y;\n            po.push_back(P(x, y));\n        }\n        R l = 0, r = 1e5 * 2;\n        for (int i = 0; i < 40; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-6; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 直線と点\nbool isecLP(Point a1, Point a2, Point b) {\n  return abs(ccw(a1, a2, b)) != 1;\n  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(Point a1, Point a2, Point b1, Point b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\ndouble distSP(Point a1, Point a2, Point p) {\n  Point r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  //= !ccw(a1, a2, r)\n  return min(abs(a1-p), abs(a2-p));\n}\n\n// 2直線の交点\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n  double d1 = cross(b2-b1, b1-a1);\n  double d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  assert(!EQ(d2, 0)); // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(Point p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        VP p(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y;\n            p[i] = Point(x,y);\n        }\n\n        auto D = [&](Point z){\n            double ret = INF;\n            rep(i,n){\n                ret = min(ret, distSP(p[i],p[(i+1)%n],z));\n            }\n            // printf(\" (%f,%f) -> %f\\n\",z.X,z.Y,ret);\n            return ret;\n        };\n\n        auto check = [&](double d){\n            vector<Line> l;\n            rep(i,n){\n                Point p1 = p[i], p2 = p[(i+1)%n];\n                double vx = p1.X-p2.X, vy = p1.Y-p2.Y;\n                double sz = sqrt(vx*vx + vy*vy);\n\n                for(int j=-1; j<=1; j+=2){\n                    Point q1(p1.X+vy*d/sz*j, p1.Y-vx*d/sz*j);\n                    Point q2(p2.X+vy*d/sz*j, p2.Y-vx*d/sz*j);\n                    l.pb({q1,q2});\n                }\n            }\n\n            int L = l.size();\n            rep(i,L)rep(j,i){\n                if(!isecLL(l[i].fi, l[i].se, l[j].fi, l[j].se)) continue;\n\n                Point c = crosspointLL(l[i].fi, l[i].se, l[j].fi, l[j].se);\n                if(inConvex(c, p) != 1) continue;\n\n                if(GE(D(c),d)) return true;\n            }\n            return false;\n        };\n\n        double l=0,r=10000;\n        rep(loop,50){\n            double m = (l+r)/2;\n            if(check(m)) l=m;\n            else r=m;\n        }\n        printf(\"%.10f\\n\", l);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-7;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    R u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.y-l.x) / abs(l) * P(0, -1); //l?????´???????????????????????????\n    v *= u;\n    if (ccw(l.x, l.y, c.p) < 0) v *= -1;\n    //v?????????????????????l?????¨??????????????????????????????\n    if (si == 0) {\n        r.x = r.y = c.p + v;\n        return 1;\n    }\n    r.x = c.p+v+polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    r.y = c.p+v-polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    return 2;\n}\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nPol l2rect(const L &l, R r) {\n    P v = vec(l)*P(0, 1) / abs(vec(l)) * r;\n    Pol p;\n    p.push_back(l.x + v);\n    p.push_back(l.x - v);\n    p.push_back(l.y - v);\n    p.push_back(l.y + v);\n    return p;\n}\n\n\nPol po;\n\nbool solve(R md) {\n    int n = po.size();\n    vector<L> lv;\n    vector<Pol> pov;\n    vector<C> cv;\n    for (int i = 0; i < n; i++) {\n        cv.push_back(C(po[i], md));\n        pov.push_back(l2rect(L(po[i], po[(i+1)%n]), md));\n    }\n    for (Pol &pp : pov) {\n        for (int i = 0; i < 4; i++) {\n            lv.push_back(L(cu(pp, i), cu(pp, i+1)));\n        }\n    }\n    vector<P> pv;\n    for (int i = 0; i < n*4; i++) {\n        for (int j = i+1; j < n*4; j++) {\n            P pp;\n            if (crossSS(lv[i], lv[j], pp)) {\n                pv.push_back(pp);\n            }\n        }\n    }\n    for (P &p: pv) {\n        if (contains(po, p) == 0) continue;\n        bool f = true;\n        for (Pol &po: pov) {\n            if (contains(po, p) == 2) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        for (C &c: cv) {\n            if (sgn(abs(c.p - p), c.r) == 1) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        //printf(\"%.lf\", md);\n        //cout << p << endl;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        po.clear();\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            cin >> x >> y;\n            po.push_back(P(x, y));\n        }\n        R l = 0, r = 1e5;\n        for (int i = 0; i < 50; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-11;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      assert(abs(uva)>0&&abs(uvb)>0);\n      vec v = uvec( (uva + uvb) );\n      \n      long double r = 1e9;\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<1000){\n        long double m = (r+l)/2.;\n        point c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          l = m;\n        }\n      }\n      res = max( res, radi );\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bi_deg(Point a, Point b, Point c) {\n\tPoint d = (b - c) / (a - c);\n\tld deg = atan2l(d.imag(), d.real()) / 2.0;\n\treturn Line(c, c + (Point(cosl(deg), sinl(deg)) * (a - c)));\n}\n\nPoint H(Line a, Line b, Line c) {\n\tif (!isis_ll(a, b)) {\n\t\tPoint x = is_ll(b, c), y = is_ll(c, a);\n\t\treturn is_ll(bi_deg(b.a, a.b, x), bi_deg(c.a, a.b, y));\n\t}\n\telse if (!isis_ll(b, c)) {\n\t\tPoint x = is_ll(c, a), y = is_ll(a, b);\n\t\treturn is_ll(bi_deg(c.a, a.b, x), bi_deg(a.a, b.b, y));\n\t}\n\telse {\n\t\tPoint x = is_ll(a, b), y = is_ll(b, c);\n\t\treturn is_ll(bi_deg(a.a, b.b, x), bi_deg(b.a, c.b, y));\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Point> p(n);\n\t\tfor (int i = 0, x, y; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tvector<Line> l(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = bi_deg(p[i], p[(i + 2) % n], p[(i + 1) % n]);\n\t\t}\n\t\tvector<Line> e(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = Line(p[i], i + 1 < n ? p[i + 1] : p[0]);\n\t\t}\n\t\tvector<Point> all;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (isis_ll(e[i], e[j]) || isis_ll(e[j], e[k]) || isis_ll(e[k], e[i])) {\n\t\t\t\t\t\tif (isis_ll(e[i], e[k]) && ccw(e[j].a, is_ll(e[i], e[k]), e[j].b) == 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isis_ll(e[j], e[i]) && ccw(e[k].a, is_ll(e[j], e[i]), e[k].b) == 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isis_ll(e[k], e[j]) && ccw(e[i].a, is_ll(e[k], e[j]), e[i].b) == 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tall.push_back(H(e[i], e[j], e[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tld res = 0;\n\t\tfor (auto is : all) {\n\t\t\tld deg = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (norm(p[k] - is) < eps) {\n\t\t\t\t\tdeg = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tPoint tmp = ((k + 1 >= n ? p[k + 1 - n] : p[k + 1]) - is) / (p[k] - is);\n\t\t\t\tdeg += atan2l(tmp.imag(), tmp.real());\n\t\t\t}\n\t\t\tif (eq(deg, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tld mi = 1e10;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tmi = min(mi, dist_lp(e[k], is));\n\t\t\t}\n\t\t\tres = max(res, mi);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-9;\ninline D dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\treturn -1;\n}\ninline P perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline bool iSP(L s,P p){\n\tP a=s.fs,b=s.sc,c=p;\n\treturn abs(abs(a-c)+abs(c-b)-abs(a-b))<eps;\n}\ninline D dSP(L s,P p){\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline P intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint N;\nPol pol;\nP p[100];\nbool contain(Pol pol,P p){\n\tbool in=false;\n\trep(i,N){\n\t\tP a=pol[i]-p,b=pol[(i+1)%N]-p;\n\t\tif(ccw(a,b,P(0,0))==0) return false;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(imag(a)<=eps && eps<imag(b) && ccw(P(0,0),a,b)==1) in=!in;\n\t}\n\treturn in;\n}\nbool check(D m){\n\trep(i,N) rep(k,i){\n//\t\tshow(i);\n\t\tP a=p[i],b=p[(i+1)%N],c=p[k],d=p[(k+1)%N];\n\t\tP x=(b-a)*P(0,1),y=(d-c)*P(0,1);\n\t\tx=x/abs(x)*m,y=y/abs(y)*m;\n\t\tL l1=L(a+x,b+x),l2=L(c+y,d+y);\n\t\tP q=intLL(l1,l2);\n\t\tif(!contain(pol,q)) continue;\n\t\tint cnt=0;\n\t\trep(j,N){\n//\t\t\tshow(j);\n\t\t\tL l=L(p[j],p[(j+1)%N]);\n//\t\t\tshow(dSP(l,q));\n//\t\t\tshow(m);\n\t\t\tif(dSP(l,q)+eps<m) cnt++;\n\t\t}\n//\t\tshow(cnt);\n\t\tif(cnt==0) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tpol.clear();\n\t\trep(i,N){\n\t\t\tint xx,yy;\n\t\t\tcin>>xx>>yy;\n\t\t\tp[i]=P(xx,yy);\n\t\t\tpol.pb(p[i]);\n\t\t}\n\t\tD ub=10000,lb=0;\n\t\trep(tt,40){\n\t\t\tD m=(ub+lb)/2;\n\t\t\tif(check(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n//\t\tcheck(2.0);\n/*\t\tif(abs(ub-1.1965)<1e-2){\n\t\t\tcout<<N<<endl;\n\t\t\trep(i,N){\n\t\t\t\tcout<<p[i].real()<<\" \"<<p[i].imag()<<endl;\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%.12f\\n\",ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n \n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n  \nusing namespace std;\n  \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n  \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n};\n  \n#define Line pair<point,point>\n \ndouble dot(point a, point b){return (a.x * b.x + a.y * b.y);}\ndouble cross(point a, point b){return (a.x * b.y - a.y * b.x);}\ndouble norm(point a){return sqrt(a.x*a.x+a.y*a.y);}\n  \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n \npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n \npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n  \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n \n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n  \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n  \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n    return make_pair(a_,b_);\n}\n \nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n \nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n   \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n \ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=50;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n \nint main(void){\n \n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n\tPoint a = P[i], b = P[(i+1)%P.size()];\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t    u.push_back(getCrossPointLines(Segment(a, b), l));\n\t}\n    }\n    return u;\n}\n\ndouble getArea(Polygon p){\n    double sum = 0.0;\n    for(int i = 0; i < p.size(); i++){\n\tsum += cross(p[i], p[(i+1)%p.size()]);\n    }\n    return abs(sum/2);\n}\n\nSegment shift(Segment s, double d ){\n    Vector v = polar(d, arg(s.p2 - s.p1)+acos(-1)/2 );\n    Segment m = Segment(s.p1 + v, s.p2 + v );\n    return m;\n}\n\n#define MAX 100\nPolygon P;\nint n;\n\ndouble getCutArea(double d){\n    Polygon target = P;\n\n    for ( int i = 0; i < n; i++ ){\n\tSegment s = Segment(P[i], P[(i+1)%n]);\n\ts = shift(s, d);\n\ttarget = cutPolygon(target, s);\n    }\n\n    return getArea(target);\n\n}\n\nvoid compute(){\n    double l = 0, r = 1000000;\n    double a, d;\n    while(1){\n\td = (r+l)/2;\n\ta = getCutArea(d);\n\tif ( a == 0 ){\n\t    r = d;\n\t} else {\n\t    if ( a < 0.0000000001 ) break;\n\t    l = d;\n\t}\n    }\n    printf(\"%.12lf\\n\", d);\n}\n\n\nint main(){\n    double x, y;\n    while ( cin >> n && n ){\n\tP.clear();\n\tfor ( int i = 0; i < n; i++ ){\n\t    cin >> x >> y; P.push_back(Point(x, y));\n \t}\n\tcompute();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  /*\n    Polygon A;\n    A.push_back(P(inf,inf)); A.push_back(P(-inf,inf));\n    A.push_back(P(-inf,-inf)); A.push_back(P(inf,-inf));\n  */\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n// 2D GEOMETORY //\n\n// 平面上の点。もしくは平面上のベクトル。\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x * _.x + y * _.y; } // 内積\n\tdouble cross(const P2 &_) const { return x * _.y - y * _.x; } // 外積\n\tdouble sqlength() const { return x * x + y * y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\n\n/// 直線\nstruct Line\n{\n\tP2 p, d; // 始点・方向\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d; // 始点・方向大きさ\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\ntypedef vector<P2> Polygon;\n\npair<Polygon, Polygon> cutConvexPolygon(const Polygon &polygon, const Line &cut)\n{\n\tint N = polygon.size();\n\tPolygon left, right;\n\tREP(i, N)\n\t{\n\t\tP2 p0 = polygon[i];\n\t\tP2 p1 = polygon[(i + 1) % N];\n\t\tint d1 = sign_of(cut.d.cross(p1 - cut.p)); // -1:cw, 0:on, 1:ccw\n\t\tint d0 = sign_of(cut.d.cross(p0 - cut.p)); // -1:cw, 0:on, 1:ccw\n\n\t\tif (d0 == 0) // p0 on cut line\n\t\t{\n\t\t\tleft.push_back(p0);\n\t\t\tright.push_back(p0);\n\t\t}\n\t\telse  // p0 and p1 are the same side.\n\t\t{\n\t\t\tif (d0 < 0)\n\t\t\t{\n\t\t\t\tleft.push_back(p0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tright.push_back(p0);\n\t\t\t}\n\n\t\t\tif (d0 * d1 < 0)\n\t\t\t{\n\t\t\t\tP2 splitPoint = crossPoint(Line::From2Point(p0, p1), cut);\n\t\t\t\tleft.push_back(splitPoint);\n\t\t\t\tright.push_back(splitPoint);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (left.size() < 3) { left.clear(); }\n\tif (right.size() < 3) { right.clear(); }\n\treturn { left, right };\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto polygon = read<P2>(N);\n\n\t\t// 削れる陸の距離をにぶたんで探す。\n\t\tdouble l = 0.0, r = 10000.0, m;\n\n\t\twhile (abs(l - r) >= 0.0000001)\n\t\t{\n\t\t\tm = (r - l) / 2 + l; // 陸を削る\n\n\t\t\tPolygon poly = polygon;\n\t\t\tREP(i,N)\n\t\t\t{\n\t\t\t\tLineSeg cutLine = LineSeg::From2Point(polygon[i], polygon[(i + 1) % N]);\n\t\t\t\tcutLine.p = cutLine.p + -cutLine.d.orthogonal().direction() * m; // 辺に垂直な方向に m だけ動かした直線。\n\t\t\t\tpoly = cutConvexPolygon(poly, cutLine).second;\n\t\t\t}\n\n\t\t\t//DEBUG(m);\n\t\t\tbool ok = poly.size() > 0; // 陸地がちょっとでも残ってればOK\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tWRITE(m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint sign(double x){\n    if(x > EPS) return 1;\n    if(x < -EPS) return -1;\n    return 0;\n}\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ninline Point curr(const Polygon& P, int k){ return P[k]; }\ninline Point next(const Polygon& P, int k){ return P[(k + 1) % P.size()]; }\nPolygon convex_cut(const Polygon& P, Line l){\n    Polygon Q;\n    for(int i = 0; i < P.size(); i++){\n        Point A = curr(P, i), B = next(P, i);\n        if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n        if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(l, Line(A, B)));\n    }\n    return Q;\n}\n\nPoint rotate(Point a, double b){\n    return a * polar(1.0, b);\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        Polygon P;\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            P.push_back(Point(x, y));\n        }\n        double lb = 0, ub = 100000;\n        REP(iter, 100){\n            double len = (lb + ub) / 2;\n            Polygon Q = P;\n            REP(i, N){\n                Line l(curr(P, i), next(P, i));\n                Line l2(l[0] + polar(len, arg(l.vector()) + M_PI/2), l[1] + polar(len, arg(l.vector()) + M_PI/2));\n                Q = convex_cut(Q, l2);\n            }\n            if(Q.empty()){\n                ub = len;\n            }else{\n                lb = len;\n            }\n        }\n        printf(\"%.12f\\n\", lb);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn abs(a.x-b.x)>=EPS || abs(a.y-b.y)>=EPS;\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\nPoint operator/(Point p,double c){\n\treturn Point(p.x/c,p.y/c);\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\nPoint InterLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS)\n\t\treturn a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\nPoint InterLS(Line l,Segment s){\n\treturn InterLL(s,l);\n}\n\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nvector<Point> ConvexCut(const vector<Point>& ps,Line l){\n\tint n=ps.size();\n\tvector<Point> res;\n\trep(i,n){\n\t\tint c1=CCW(l.pos,l.pos+l.dir,ps[i]);\n\t\tint c2=CCW(l.pos,l.pos+l.dir,ps[(i+1)%n]);\n\t\tif(c1!=-1)\n\t\t\tres.push_back(ps[i]);\n\t\tif(c1*c2==-1)\n\t\t\tres.push_back(InterLS(l,Segment(ps[i],ps[(i+1)%n]-ps[i])));\n\t}\n\treturn res;\n}\n\nvector<Point> calc(const vector<Point>& ps,double x)\n{\n\tvector<Point> res=ps;\n\trep(i,ps.size()){\n\t\tPoint dir=ps[(i+1)%ps.size()]-ps[i];\n\t\tPoint pos=ps[i]+x*Rot(dir/Abs(dir),PI/2);\n\t\tres=ConvexCut(res,Line(pos,dir));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Point> ps(n);\n\t\trep(i,n) cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\tdouble lo=0,hi=1e6;\n\t\trep(_,50){\n\t\t\tdouble mi=(lo+hi)/2;\n\t\t\tif(calc(ps,mi).size()==0)\n\t\t\t\thi=mi;\n\t\t\telse\n\t\t\t\tlo=mi;\n\t\t}\n\t\tprintf(\"%f\\n\",lo);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ???§ ????????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ???§ ?????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b???§??????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c???§??????´??????\n    return 0;  // a -- c -- b???§??????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  {\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  {\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  {\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nusing namespace Geometory;\n\nPolygon data;\n\nbool isable(double v)\n{\n  Polygon ret = data;\n  for(int i = 0; i < data.size(); i++) {\n    Point point = next(data, i) - curr(data, i);\n    point = (point * v / point.abs()).rotate90();\n    ret = Convex_Cut(ret, Line(curr(data, i) + point, next(data, i) + point));\n  }\n  return (!ret.empty());\n}\n\nint main()\n{\n  int N;\n  cout << fixed << setprecision(10);\n  while(cin >> N, N) {\n    data.resize(N);\n    for(int i = 0; i < N; i++) cin >> data[i];\n    double low = 0, high = 1e4;\n    for(int i = 0; i < 40; i++) {\n      double mid = (low + high) * 0.5;\n      if(isable(mid)) low = mid;\n      else high = mid;\n    }\n    cout << low << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n \n// ?°???± verify AOJ CGL_1_A\n// P proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\n// P proj(L l,P p){l.t-=l.s,p-=l.s;return l.s+l.t*real(p/l.t);}\n// // ????°? verify AOJ CGL_1_B\n// P refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n    VP res;\n    int n=pol.size();\n    rep(i,n){\n        P a = pol[i],b=pol[(i+1)%n];\n        if(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n        if((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n    }\n    return res;\n}\n\nVP org;\nint n;\n\nbool check(R d){\n    VP rest = org;\n    rep(i, n){\n        int j = (i + 1) % n;\n        L l = {org[i], org[j]};\n        P u = (l.t - l.s) / abs(l.t - l.s); u = {-imag(u), real(u)};\n        l.s += u * d;\n        l.t += u * d;\n        rest = convex_cut(rest, l);\n    }\n\n    return ((int)rest.size() != 0);\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        org = VP(n);\n        for(auto& e : org) cin >> e;\n        \n        R lb = 0.0, ub = 1e6;\n        while((ub - lb) > EPS){\n            R mid = (lb + ub) / 2.0;\n            \n            if(check(mid)){\n                lb = mid;\n            }\n            else {\n                ub = mid;\n            }\n        }\n        cout.precision(20);\n        cout << fixed << lb << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return m[0]; // same line\n    if (abs(A) < eps) throw;\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\ndouble solve(){\n    int v[]{rand()%(n-2),rand()%(n-2),rand()%(n-2)};\n    sort(v,v+3);\n    v[1]++;v[2]+=2;\n    P p=innerCenter(ps[v[0]],ps[v[1]],ps[v[2]]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    static double d[128];\n    int near=0;\n    double r[]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6};\n    rep(t,700000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n){\n            if(d[i]<d[near]){\n                near=i;\n            }\n        }\n        P h=projection(es[near],p);\n        p -= (h-p)/d[near]*r[t/100000];\n    }\n\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\npoint inscribedCircleCenter( point a, point b, point c )\n{\n  long double A = abs( c - b ), B = abs( c - a ), C = abs( b - a );\n  long double S = A + B + C;\n  return (A / S) * a + (B / S) * b + (C / S) * c;\n}\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    point c;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      vec uva = (a.second- a.first);\n      vec uvb = (b.second- b.first);\n      vec v = uvec( (uva + uvb) );\n\n      assert(!prll(a,b));\n      assert(abs(uva)>0&&abs(uvb)>0);\n\n      long double r = 0;\n      for(int j = 0; j < n; ++j){\n        r = max(r,2*abs(vp[i]-vp[j]));\n      }\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<800){\n        long double m = (r+l)/2.;\n        c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    //cout << c << ' ' << inscribedCircleCenter(vp[0],vp[1],vp[2]) << endl;\n    cout << fixed << setprecision(8) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\nconst double PI=acos(-1);\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\npoint<double> &operator/=(point<double> &a,double c){ a.x/=c; a.y/=c; return a; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\npoint<double> rot(const point<double> &a,double theta){\n\treturn (point<double>){a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a,b;\n\toperator line<double>()const{ return (line<double>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n):vector< point<T> >(n){}\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\npolygon<double> convex_cut(const polygon<T> &G,const line<T> &L){\n\tint n=G.size();\n\tpolygon<double> H;\n\trep(i,n){\n\t\tint d1=ccw(L.a,L.b,G[i]);\n\t\tint d2=ccw(L.a,L.b,G[(i+1)%n]);\n\t\tif(d1!=CW) H.push_back(G[i]);\n\t\tif(d1==CCW && d2==CW || d1==CW && d2==CCW){\n\t\t\tH.push_back(get_intersect(L,(line<T>){G[i],G[(i+1)%n]}));\n\t\t}\n\t}\n\treturn H;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tpolygon<double> G(n);\n\t\trep(i,n) scanf(\"%lf%lf\",&G[i].x,&G[i].y);\n\n\t\tdouble lo=0,hi=1e5;\n\t\trep(_,50){\n\t\t\tdouble mi=(lo+hi)/2;\n\t\t\tpolygon<double> F=G;\n\t\t\trep(i,n){\n\t\t\t\tpoint<double> vec=G[(i+1)%n]-G[i];\n\t\t\t\tvec/=abs(vec);\n\t\t\t\tvec=rot(vec,PI/2);\n\t\t\t\tF=convex_cut(F,(line<double>){G[i]+mi*vec,G[(i+1)%n]+mi*vec});\n\t\t\t}\n\t\t\tif(F.empty()) hi=mi; else lo=mi;\n\t\t}\n\n\t\tprintf(\"%.9f\\n\",(lo+hi)/2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\ninline P unit(P p){return p/abs(p);}\ninline pair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\n//for line(segment)\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\n//vertexes are in the counter-clockwise order.\ninline Poly convex_cut(Poly p,L l){\n  Poly res;\n  rep(i,p.sz){\n    int nxt = (i+1)%p.sz;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nbool check(D dis, const Poly &p){\n  Poly U(4);\n  U[0] = P(-1e6, -1e6);\n  U[1] = P(+1e6, -1e6);\n  U[2] = P(+1e6, +1e6);\n  U[3] = P(-1e6, +1e6);\n\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    L l = L(p[i],p[(i+1)%n]);\n    P vec = norm(l.sc-l.fs).fs, move = dis*unit(vec);\n    l.fs += move; l.sc += move;\n    U = convex_cut(U,l);\n  }\n  return !U.empty();\n}\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    Poly p(n);\n    for(int i=0;i<n;i++){\n      D x,y;\n      cin >> x >> y;\n      p[i] = P(x,y);\n    }\n\n    D l = 0, r = 1e6;\n    for(int i=0;i<50;i++){\n      D mid = (l+r)/2;\n      if(check(mid,p))l = mid;\n      else r = mid;\n    }\n    cout << fixed << setprecision(10) << l << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 4);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  double t = dot(p - l.first, direction(l)) / norm(direction(l));\n  return l.first + t*(direction(l));\n}\n\ndouble distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\ndouble distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N;\n\n  while (cin >>N && N){\n    poly_t poly(N);\n\n    REP(i, N){\n      cin >> poly[i];\n    }\n\n    double ub = 1e9;\n    double lb = 0;\n\n    REP(i, 300){\n      double mb = (ub + lb) / 2;\n      \n      poly_t tmp_poly = poly;\n      REP(j, poly.size()){\n        line_t line = line_t(poly[j], poly[next_index(poly, j)]);\n        xy_t   vec  = direction(line) / abs(direction(line)) * polar(1., M_PI / 2);\n        line_t cut_line = line_t(line.first + vec * mb, line.second + vec * mb);\n        tmp_poly = convex_cut(tmp_poly, cut_line);\n      }\n\n      if (area(tmp_poly) > EPS){\n        lb = mb;\n      } else {\n        ub = mb;\n      }\n    }\n    printf(\"%.20lf\\n\", lb);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\n\ndouble cross(P va, P vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble distanceLP(P a, P b, P c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nP crosspoint(P pa1, P pa2, P pb1, P pb2){\n\tP da12 = pa2 - pa1;\n\tP db21 = pb1 - pb2;\n\tP dab1 = pb1 - pa1;\n\tdouble d = cross(da12, db21);\n\tif(abs(d) > EPS){\n\t\tdouble t = cross(dab1, db21) / d;\n\t\treturn pa1 + t * da12;\n\t}\n\treturn P(DBL_MAX, DBL_MAX);\n}\n\nint main(){\n\tint n;\n\tP pts[110];\n\tdouble x, y;\n\twhile(scanf(\"%d\", &n), n){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tpts[i] = P(x, y);\n\t\t}\n\t\tpts[n] = pts[0];\n\t\t\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j < n; ++j)\n\t\tfor(int k = j + 1; k < n; ++k){\n\t\t\tint e0 = i, e1 = j, e2 = k;\n\n\t\t\tif(abs(cross(pts[i + 1] - pts[i], pts[j + 1] - pts[j])) < EPS){\n\t\t\t\te0 = j;\n\t\t\t\te1 = k;\n\t\t\t\te2 = i;\n\t\t\t}\n\t\t\telse if(abs(cross(pts[j + 1] - pts[j], pts[k + 1] - pts[k])) < EPS){\n\t\t\t\te0 = k;\n\t\t\t\te1 = i;\n\t\t\t\te2 = j;\n\t\t\t}\n\n\t\t\tP tmp[4];\n\t\t\ttmp[0] = pts[e0];\n\t\t\ttmp[1] = crosspoint(pts[e0], pts[e0 + 1], pts[e1], pts[e1 + 1]);\n\t\t\ttmp[2] = crosspoint(pts[e1], pts[e1 + 1], pts[e2], pts[e2 + 1]);\n\t\t\ttmp[3] = pts[e2 + 1];\n\t\t\tdouble a1 = 0.5 * (arg(tmp[2] - tmp[1]) + arg(tmp[0] - tmp[1]));\n\t\t\tdouble a2 = 0.5 * (arg(tmp[3] - tmp[2]) + arg(tmp[1] - tmp[2]));\n\t\t\tP c = crosspoint(tmp[1], tmp[1] + polar(1.0, a1), tmp[2], tmp[2] + polar(1.0, a2));\n\t\t\tif(real(c) == DBL_MAX){ continue; }\n\t\t\tdouble d = distanceLP(tmp[1], tmp[2], c);\n\t\t\tif(d <= ans){ continue; }\n\t\t\tbool ok = true;\n\t\t\tfor(int h = 0; h < n; ++h){\n\t\t\t\tif(distanceLP(pts[h], pts[h + 1], c) < d - EPS){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){ ans = d; }\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\tint n=0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%.8f\\n\",left);\n\t\tn++;\n\t}\n\tif(n>29)return 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tPolygon npoly(origin);\n\t\tconst int atime = 1900;\n\t\tfor (int repeat = 0; repeat <=atime; ++repeat) {\n\t\t\tconst Polygon prepoly(npoly);\n\t\t\tPoint center;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tcenter += npoly[i];\n\t\t\t}\n\t\t\tcenter /= npoly.size();\n\t\t\tlong double mindis = 20000;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tmindis = min(mindis, dist_sp(Line(npoly[i], npoly[(i + 1) % npoly.size()]), center));\n\t\t\t}\n\n\n\t\t\tfor (int i = 0; i < prepoly.size(); ++i) {\n\t\t\t\tLine preline = Line(prepoly[i], prepoly[(i + 1) % prepoly.size()]);\n\t\t\t\tPoint vec = (preline[1] - preline[0])*complex<long double>(0, 1)/abs(preline[1]-preline[0])*mindis;\n\t\t\t\tLine cutline[2];\n\t\t\t\tcutline[1] = Line(preline[0] + vec, preline[1] + vec);\n\t\t\t\tcutline[0] = Line(preline[0] - vec, preline[1] - vec);\n\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tvector<Polygon>polys(convex_cut(npoly, cutline[i]));\n\t\t\t\t\tif (is_in_polygon(polys[0], center)) {\n\t\t\t\t\t\tnpoly = polys[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnpoly = polys[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Polygon prepoly(npoly);\n\t\tPoint center;\n\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\tcenter += npoly[i];\n\t\t}\n\t\tcenter /= npoly.size();\n\t\tlong double mindis = 20000;\n\t\tfor (int i = 0; i < origin.size(); ++i) {\n\t\t\tmindis = min(mindis, dist_sp(Line(origin[i], origin[(i + 1) % origin.size()]), center));\n\t\t}\n\t\tcout << fixed<<setprecision(22)<<mindis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\ninline P unit(P p){return p/abs(p);}\ninline P norm(P p){return p*P(0,1);}\n\n//for line(segment)\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\n//vertexes are in the counter-clockwise order.\ninline Poly convex_cut(Poly p,L l){\n  Poly res;\n  rep(i,p.sz){\n    int nxt = (i+1)%p.sz;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\ninline bool check(D dis, const Poly &p){\n  Poly U(4);\n  U[0] = P(-1e6, -1e6);\n  U[1] = P(+1e6, -1e6);\n  U[2] = P(+1e6, +1e6);\n  U[3] = P(-1e6, +1e6);\n\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    L l = L(p[i],p[(i+1)%n]);\n    P move = dis*unit(norm(l.sc-l.fs));\n    l.fs += move; l.sc += move;\n    U = convex_cut(U,l);\n  }\n  return !U.empty();\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    Poly p(n);\n    for(int i=0;i<n;i++){\n      D x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      p[i] = P(x,y);\n    }\n\n    D l = 0, r = 1e6;\n    for(int i=0;i<50;i++){\n      D mid = (l+r)/2;\n      if(check(mid,p))l = mid;\n      else r = mid;\n    }\n    printf(\"%.9lf\\n\",l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    // L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n            h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nbool check(double d, G g, vector<L> l) {\n    int n = g.size();\n    rep(i, n) {\n        l[i].trans(d);\n        g = convex_cut(g, l[i]);\n    }\n    return (int)g.size() >= 3;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    int n;\n    while (cin >> n, n) {\n        G g;\n        rep(i, n) g.emplace_back(readP());\n        vector<L> l;\n        rep(i, n) {\n            l.emplace_back(here(g, i), next(g, i));\n        }\n\n        double lb = 0, ub = 1e10;\n        rep(_, 100) {\n            double mid = (lb + ub) / 2;\n            (check(mid, g, l) ? lb : ub) = mid;\n        }\n\n        cout << fixed << setprecision(10) << lb << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \n#define EPS (1e-10)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n \nclass Point {\n  public:\n \n  double x,y;\n   \n  Point (double x = 0, double y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point( x+p.x , y+p.y );\n  }\n  Point operator - (Point p) {\n    return Point( x-p.x , y-p.y );\n  }\n  Point operator * (double a) {\n    return Point( a*x , a*y );\n  }\n  \n  double abs() {\n    return sqrt(norm());\n  }\n  double norm() {\n    return x*x+y*y;\n  }\n  \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == (const Point &p) const {\n    return equal( x,p.x )&& equal( y,p.y );\n  }\n};\n \ntypedef Point Vector;\n  \ndouble dot(Vector a,Vector b) {\n  return a.x*b.x + a.y*b.y;\n}\n  \ndouble cross(Vector a,Vector b) {\n  return a.x*b.y - b.x*a.y;\n}\n \nVector rotation(Vector vec,double si,double co){\n  Vector res;\n  res.x = vec.x*co - vec.y*si;\n  res.y = vec.x*si + vec.y*co;\n  return res;\n}\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n  \nint ccw( Point p0 , Point p1 , Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\ntypedef Segment Line;\n \nPoint getCrossPointLL(Line l1,Line l2){\n  Point p1=l1.p1,p2=l1.p2;\n  Point q1=l2.p1,q2=l2.p2;\n  Point res;\n  res= p1+(p2-p1)*( cross(q2-q1,q1-p1)/cross(q2-q1,p2-p1) );\n  return res;\n}\n \nvector<Point> cutC(vector<Point> t,Line li){\n  int n=t.size();\n  vector<Point> u;\n  int A[200];\n  \n  for(int i=0;i<n;i++)A[i]=ccw(li.p1,li.p2,t[i]);\n  \n  for(int i=0;i<n;i++){\n    if(A[i]!=CLOCKWISE)u.push_back(t[i]);\n    int j=(i+1)%n;\n    if(A[i]==COUNTER_CLOCKWISE\n       &&A[j]==CLOCKWISE)\n      u.push_back( getCrossPointLL(Line(t[i],t[j]),li));\n    else if(A[j]==COUNTER_CLOCKWISE\n            &&A[i]==CLOCKWISE)\n      u.push_back( getCrossPointLL(Line(t[i],t[j]),li));\n  }\n   \n  return u;\n}\n \n \nint n,m;\ndouble d,V;\nvector<Point> G,G2;\nvector< Segment > g;\n\nbool check(double M){\n  G2 = G;\n  for(int i=0;i<n;i++){\n    Segment s=g[i];\n    Vector v = rotation(s.p2-s.p1,1.0,0.0);\n    double k=v.abs();\n    v = v*(1.0/k);\n    v = v*M;\n    s.p1 = s.p1 + v;\n    s.p2 = s.p2 + v;\n    G2 = cutC(G2,s);\n    if(G2.size()<3)return false;\n  }\n  return true;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    G.resize(n);\n    for(int i=0;i<n;i++)cin>>G[i].x>>G[i].y;\n    g.resize(n);\n    for(int i=0;i<n;i++)g[i]=(Segment){ G[i] , G[(i+1)%n] };\n    \n    double L=0.0,R=1e5,M;\n    for(int i=0;i<100;i++){\n      M=(L+R)/2.0;\n      if(check(M))L=M;\n      else R=M;\n    }\n    printf(\"%.8f\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ???§ ????????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ???§ ?????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b???§??????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c???§??????´??????\n    return 0;  // a -- c -- b???§??????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  {\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  {\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  {\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nusing namespace Geometory;\n\nPolygon data;\n\nbool isable(double v)\n{\n  Polygon ret = data;\n  for(int i = 0; i < data.size(); i++) {\n    Point point = next(data, i) - curr(data, i);\n    point = (point * v / point.abs()).rotate(PI / 2);\n    ret = Convex_Cut(ret, Line(curr(data, i) + point, next(data, i) + point));\n  }\n  return (!ret.empty());\n}\n\nint main()\n{\n  int N;\n  cout << fixed << setprecision(10);\n  while(cin >> N, N) {\n    data.resize(N);\n    for(int i = 0; i < N; i++) cin >> data[i];\n    double low = 0, high = 1e5;\n    for(int i = 0; i < 133; i++) {\n      double mid = (low + high) * 0.5;\n      if(isable(mid)) low = mid;\n      else high = mid;\n    }\n    cout << low << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n};\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ntypedef vector<point> polygon;\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\nbool intersect(const segment &s, const point &p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint crosspoint(const segment &s, const segment &t) {\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\treturn t.a + (t.b - t.a) * (cross(s.b - s.a, s.b - t.a) / tmp);\n}\n\ndouble dist(const segment &s, const point &p) {\n\tif(dot(s.b - s.a, p - s.a) < 0) return abs(p - s.a);\n\tif(dot(s.a - s.b, p - s.b) < 0) return abs(p - s.b);\n\treturn abs(cross(s.b - s.a, p - s.a)) / abs(s.b - s.a);\n}\n\nbool contain(const polygon &P, const point &p) {\n\tbool res = false;\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tpoint v1 = prev - p, v2 = curr - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n\t\tif(abs(cross(v1, v2)) < EPS  && dot(v1, v2) < EPS) return true;\n\t\tprev = curr;\n\t}\n\treturn res;\n}\n\ndouble dist(const polygon &P, const point &p) {\n\tdouble res = INT_MAX;\n\tpoint prev = P.back();\n\n\tfor(const auto &curr : P) {\n\t\tchmin(res, dist(segment(curr, prev), p));\n\t\tprev = curr;\n\t}\n\n\treturn res;\n}\n\ndouble ternary_search(double L, double R, const function<double(double)> &f) {\n\tfor(int i = 0; i < 80; ++i) {\n\t\tdouble x1 = (L + L + R) / 3.0, x2 = (L + R + R) / 3.0;\n\t\tif(f(x1) < f(x2)) {\n\t\t\tL = x1;\n\t\t}\n\t\telse {\n\t\t\tR = x2;\n\t\t}\n\t}\n\treturn f(L);\n}\n\ndouble search_y(double x, const polygon &P) {\n\tconst segment L(point(x, 0), point(x, 10000));\n\tvector<double> range;\n\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tconst segment s(prev, curr);\n\t\tif(intersect(L, s)) range.emplace_back(crosspoint(L, s).y);\n\t\tprev = curr;\n\t}\n\n\tsort(range.begin(), range.end());\n\trange.erase(unique(range.begin(), range.end()), range.end());\n\n\tif(range.size() == 0) return -1;\n\treturn ternary_search(range.front(), range.back(), [&](double y){ return dist(P, point(x, y)); });\n}\n\ndouble search_x(const polygon &P) {\n\treturn ternary_search(0, 10000, [&](double x){ return search_y(x, P); });\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(6);\n\n\tfor(int n; cin >> n && n;) {\n\t\tpolygon P(n);\n\t\tfor(auto &e : P) cin >> e.x >> e.y;\n\t\tcout << search_x(P) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ninline double cross(const P& a, const P& b){return imag(conj(a)*b);}\ninline double dot(const P& a, const P& b){return real(conj(a)*b);}\nstruct L : public vector<P> {\n    L(const P &a, const P &b){push_back(a); push_back(b);}\n    L(){}\n};\nP projection(const L &l, const P &p){double t = dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);return l[0]+t*(l[0]-l[1]);}\ninline double distanceLP(const L &l, const P &p){return abs(p-projection(l, p));}\nP innerCenter(P a, P b, P c){double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);return (la*a+lb*b+lc*c)/(la+lb+lc);}\n\nint n;\nP ps[128];\nL es[128];\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g=(ps[0]+ps[n/3]+ps[2*n/3])/3.0;\n    int a=0,b=n;\n    while (a+1 < b) {\n        int c=(a+b)/2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    if(n==3)return distanceLP(es[0],p);\n\n    double const r[]={100,10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8};\n    double static d[128];\n    int near=0;\n    rep(t,11){\n        rep(u,3000){\n            rep(i,n)d[i]=distanceLP(es[i],p);\n            near=0;\n            rep(i,n)if(d[i]<d[near])near=i;\n            P h=projection(es[near],p);\n            P np=p-(h-p)/d[near]*r[t];\n            if(convex_contains(np)==IN){\n                swap(p,np);\n            } else {\n                break;\n            }\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n// !CAUTION! number は有理数以上\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n    P A = curr(po, i), B = next(po, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tG g(n);\n\t\trep(i, n) cin >> g[i].real() >> g[i].imag();\n\t\tdouble lo = 0, hi = inf, mid;\n\t\trep(it, 100){\n\t\t\tmid = (lo + hi) / 2;\n\t\t\tG g2 = g;\n\t\t\trep(i, n){\n\t\t\t\tP d = g[(i + 1) % n] - g[i];\n\t\t\t\td *= P(0, 1);\n\t\t\t\td *= mid / abs(d);\n\t\t\t\tg2 = convex_cut(g2, L(g[i] + d, g[(i + 1) % n] + d));\n\t\t\t}\n\t\t\tif(g2.empty()) hi = mid;\n\t\t\telse lo = mid;\n\t\t}\n\t\tprintf(\"%.9f\\n\", hi);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n#define double long double\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n\n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }\n  }\n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n\n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }\n  }\n\n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps(n);\n    for(int i=0;i<n;i++) cin>>ps[i];\n\n    using D = double;\n    auto check=\n      [&](D d)->int{\n        Polygon qs(ps);\n        for(int i=0;i<n;i++){\n          Line l(ps[i],ps[(i+1)%n]);\n          auto v=translate(l.p2-l.p1,PI/2);\n          l.p1=l.p1+v/abs(v)*d;\n          l.p2=l.p2+v/abs(v)*d;\n          qs=convexCut(qs,l);\n        }\n        return area(qs)>0;\n      };\n\n    D L=0,R=1e5;\n    for(int k=0;k<200;k++){\n      D M=(L+R)/2;\n      if(check(M)) L=M;\n      else R=M;\n    }\n    cout<<L<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps && abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nLine Parallelmove(Line L,double dis){\n  Vector v1,v2;\n  v1=(rotationPoint(L.p1,L.p2,90)-L.p1);\n  v2=(rotationPoint(L.p2,L.p1,270)-L.p2);\n  v1=(v1/abs(v1))*dis;\n  v2=(v2/abs(v2))*dis;\n  return Line(L.p1+v1,L.p2+v2);\n}\n\nint n;\nPolygon p;\n\nbool ok(double mid){\n  Polygon cp=p;\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    L=Parallelmove(L,mid);\n    cp=convex_cut(cp,L);\n  }\n  if(cp.size()>=3)return true;\n  return false;\n}\nint main()\n{\n  int x,y;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    p.clear();\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      p.push_back(Point(x,y));\n    }\n\n    double r=1<<30,l=0,mid;\n    for(int i=0;i<100;i++){\n      mid=(r+l)/2;\n      if(ok(mid))l=mid;\n      else r=mid;\n    }\n    printf(\"%.10f\\n\",mid);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{\n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0)\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[i + 1] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[i + 1] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e9;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<stdlib.h>\n\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n  \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n   \n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator<(const Point &p) const{\n    return x!=p.x? x< p.x : y < p.y;\n  }\n \n  bool operator==(const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS ;\n  }\n};\n \ntypedef Point Vector;\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\ntypedef vector<Point> Polygon;\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \nVector half(Vector a,Vector b){\n  return (a*b.abs()+b*a.abs())*1000;\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\nint contains(Polygon g, Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n  }\n  return (x?2:0);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nPolygon convex_cut(Polygon P,Line l) {\n  Polygon Q;\n  for (int i = 0; i < P.size(); ++i) {\n    Point A = curr(P, i), B = next(P, i);\n    if (ccw(l.p1, l.p2, A) != -1) Q.push_back(A);\n    if (ccw(l.p1, l.p2, A)*ccw(l.p1, l.p2, B) < 0)\n      Q.push_back(getCrossPoint(Line(A, B), l));\n  }\n  return Q;\n}\n\nVector housen(Vector v){\n  Vector r;\n  r.x=-v.y;\n  r.y=v.x;\n  return r;\n}\n\nLine slide(Line l, Vector a){\n  return Line(l.p1+a,l.p2+a);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p;\n    p.clear();\n    double x,y;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf %lf\",&x,&y);\n      p.push_back(Point(x,y));\n    }\n \n    double ans=0,l=0,r=10000,mid;\n     \n    Point g1,g2;\n\n    \n    for(int i=0;i<10000;i++){\n      if(equals(l,r)) break;\n      mid=(l+r)/2;\n      Polygon q(p);\n      for(int j=0;j<n;j++){\n\tLine l=Line(p[j],p[(j+1)%n]);\n\tVector a = housen(p[(j+1)%n]-p[j]);\n\ta=(a/a.abs())*mid;\n\tq=convex_cut(q,slide(l,a));\n      }\n      if(q.empty()) r=mid;\n      else l=mid;\n    }\n   \n    printf(\"%.6lf\\n\",l);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nclass circle {\npublic:\n    circle()\n        : p(point(0, 0)), r(0)\n    {}\n    circle(point p_, long double r_)\n        : p(p_), r(r_)\n    {}\n\n    point p;\n    long double r;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\nstd::vector<point> is_cc(circle const& c1, circle const& c2) {\n    std::vector<point> res;\n    long double d = std::abs(c1.p - c2.p);\n    long double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    long double dfr = c1.r * c1.r - rc * rc;\n    if(std::abs(dfr) < eps) {\n        dfr = 0.0;\n    } else if(dfr < 0.0) {\n        return res;\n    }\n\n    long double rs = std::sqrt(dfr);\n    point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * point(rc, rs));\n    if(dfr != 0.0) {\n        res.push_back(c1.p + diff * point(rc, -rs));\n    }\n    return res;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return eq(sum, 0) ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        polygon p(n);\n        for(int i=0; i<n; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            p[i] = point(x, y);\n        }\n        ld lb = 0, ub = 1e9;\n        while(abs(ub - lb) > eps) {\n            auto p2 = p;\n            ld m = (ub + lb) / 2;\n            for(int i=0; i<n; ++i) {\n                point a = p[i], b = p[(i+1)%n];\n                point v = (b - a) * point(0, 1);\n                v = v / abs(v) * m;\n                a += v;\n                b += v;\n                p2 = convex_cut(p2, line(a, b));\n            }\n            if(p2.size() == 0) {\n                ub = m;\n            } else {\n                lb = m;\n            }\n        }\n        cout << fixed << setprecision(10) << lb << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> res;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) res.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      res.push_back(crossPoint(L(A,B), l));\n  }\n  return res;\n}\nh\nbool check(vector<P> G,double d){\n  vector<P> pol=G;\n  int n=G.size();\n  for(int i=0;i<n;i++){\n    P a=G[i],b=G[(i+1)%n],c=(b-a);\n    b=P(abs(c),d)*(c/abs(c))+a;\n    a=b-c;\n    pol=convex_cut(pol,L(a,b));\n    if(pol.size()<3)return 0;\n  }\n  return  1;\n}\n\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> pol(n);\n    for(int i=0,x,y;i<n;i++){\n      cin>>x>>y;\n      pol[i]=P(x,y);\n    }\n    double L=0,M,R=1e4;\n    while(L<R){\n      M=(L+R)/2;\n      if(!check(pol,M)) R=M-EPS;\n      else L=M+EPS;\n    }\n    printf(\"%.10f\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g = (ps[0] + ps[n/3] + ps[2*n/3]) / 3.0;\n    int a = 0, b = n;\n    while (a+1 < b) {\n        int c = (a + b) / 2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    // これがないとTLEするかも\n    if(n==3)return distanceLP(es[0],p);\n\n    double const r[]={10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7};\n    double static d[128];\n    int near=0;\n    rep(t,90000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n)if(d[i]<d[near]){\n            near=i;\n        }\n        P h=projection(es[near],p);\n        P np=p-(h-p)/d[near]*r[t/10000];\n        if(convex_contains(np)==IN){\n            swap(p,np);\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{\n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0 &&\n            !is_parallel(Line(a, b), line))\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[(i + 1) % g.size()] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[i + 1] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e9;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\npt crossPoint(pt a,pt b,pt c,pt d){\n\tdouble A = cross(b-a,d-c);\n\tdouble B = cross(b-a,b-c);\n\tif( fabs(A) < EPS && fabs(B) < EPS ) return c;\n\telse if(fabs(A) >= EPS ) return c+B/A*(d-c);\n\telse pt(1e9,1e9);\n}\nvector<pt> convex_cut(vector<pt> G, pair<pt,pt>l){\n  vector<pt> ans;\n  for(int i=0;i<(int)G.size();i++){\n    pt A = G[i];\n    pt B = G[(i+1)%G.size()];\n    if(ccw(l.fi,l.sc,A) != -1) ans.pb(A);\n    if(ccw(l.fi,l.sc,A) * ccw(l.fi,l.sc,B) < 0)\n      ans.pb(crossPoint(A,B,l.fi,l.sc));\n  }\n  return ans;\n}\nint n;\npt p[105];\nint main(){\n\twhile(1){\n\t\tcin >> n; if(!n) return 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble xx,yy; scanf(\"%lf%lf\",&xx,&yy);\n\t\t\tp[i] = pt(xx,yy);\n\t\t}\n\t\tdouble lb = 0.0,ub = 10000.0;\n\t\trep(WWW,100){\n\t\t\tdouble mid = (lb+ub)/2;\n\t\t\tvector<pt>vec; rep(i,n) vec.pb(p[i]);\n\t\t\trep(j,n){\n\t\t\t\tpt A = p[j],B = p[(j+1)%n];\n\t\t\t\tpt C = A-B;\n\t\t\t\tC *= pt(0.0,-1.0); //cout << C << endl;\n\t\t\t\tC *= mid / abs(C);\n\t\t\t\tA += C; B += C;\n\t\t\t//\tcout << A << \" \" << B << endl;\n\t\t\t\tvec = convex_cut(vec,mp(A,B));\n\t\t\t\t//rep(i,vec.size()) cout << vec[i] << endl;\n\t\t\t}\n\t\t\t//cout << vec.size() << endl;\n\t\t\tif(vec.size() <= 2) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tprintf(\"%.12f\\n\",lb);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%.8f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(area(U)>0.0)return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        //for(int i=4990;i<=5010;i++)cout<<i<<' '<<check(v,(double)i-EPS)<<endl;\n        D l=0,r=100000;\n        rep(c,200){\n            D mid=(l+r)/2;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.6f\\n\",(l+r)/2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n// 2D GEOMETORY //\n\n// 平面上の点。もしくは平面上のベクトル。\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x * _.x + y * _.y; } // 内積\n\tdouble cross(const P2 &_) const { return x * _.y - y * _.x; } // 外積\n\tdouble sqlength() const { return x * x + y * y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\n\n/// 直線\nstruct Line\n{\n\tP2 p, d; // 始点・方向\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d; // 始点・方向大きさ\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\ntypedef vector<P2> Polygon;\n\npair<Polygon, Polygon> cutConvexPolygon(const Polygon &polygon, const Line &cut)\n{\n\tint N = polygon.size();\n\tPolygon left, right;\n\tREP(i, N)\n\t{\n\t\tP2 p0 = polygon[i];\n\t\tP2 p1 = polygon[(i + 1) % N];\n\t\tint d1 = sign_of(cut.d.cross(p1 - cut.p)); // -1:cw, 0:on, 1:ccw\n\t\tint d0 = sign_of(cut.d.cross(p0 - cut.p)); // -1:cw, 0:on, 1:ccw\n\n\t\tif (d0 == 0) // p0 on cut line\n\t\t{\n\t\t\tleft.push_back(p0);\n\t\t\tright.push_back(p0);\n\t\t}\n\t\telse  // p0 and p1 are the same side.\n\t\t{\n\t\t\tif (d0 < 0)\n\t\t\t{\n\t\t\t\tleft.push_back(p0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tright.push_back(p0);\n\t\t\t}\n\n\t\t\tif (d0 * d1 < 0)\n\t\t\t{\n\t\t\t\tP2 splitPoint = crossPoint(Line::From2Point(p0, p1), cut);\n\t\t\t\tleft.push_back(splitPoint);\n\t\t\t\tright.push_back(splitPoint);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (left.size() < 3) { left.clear(); }\n\tif (right.size() < 3) { right.clear(); }\n\treturn { left, right };\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto polygon = read<P2>(N);\n\n\t\t// 削れる陸の距離をにぶたんで探す。\n\t\tdouble l = 0.0, r = 10000.0, m;\n\n\t\twhile (abs(l - r) >= 0.0000001)\n\t\t{\n\t\t\tm = (r - l) / 2 + l; // 陸を削る\n\n\t\t\tPolygon poly = polygon;\n\t\t\tREP(i,N)\n\t\t\t{\n\t\t\t\tLineSeg cutLine = LineSeg::From2Point(polygon[i], polygon[(i + 1) % N]);\n\t\t\t\tcutLine.p = cutLine.p + -cutLine.d.orthogonal().direction() * m; // 辺に垂直な方向に m だけ動かした直線。\n\t\t\t\tpoly = cutConvexPolygon(poly, cutLine).second;\n\t\t\t}\n\n\t\t\t//DEBUG(m);\n\t\t\tbool ok = poly.size() > 0; // 陸地がちょっとでも残ってればOK\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\tWRITE(m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef long double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> seg,line;\nconst elem eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(elem a, elem b){return abs(b-a) < eps;}\nvec uvec(const vec &v){return v / abs(v);}\nvec nml(vec a){return a*vec(0,1);}\nvec unml(vec a){return uvec(nml(a));}\n\nelem dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nelem cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nelem dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nelem dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\nbool intersectedLL(const line &a, const line &b){\n  return !eq( cross(a.second-a.first,b.second-b.first), 0.0 );\n}\n\npoint intersectionSS(const seg &a, const seg &b)\n{\n  elem d1 = dist_l(b,a.first);\n  elem d2 = dist_l(b,a.second);\n  return a.first + ( d1 / (d1 + d2 ) ) * (a.second-a.first);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nbool intersectionLL(const line &a, const line &b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nbool intersectionLS(const line &l, const seg &s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.first,s.second,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\n\nbool cmpXy(const point &a, const point &b){\n  if( eq(a.real(),b.real() ) ) return a.imag()<b.imag();\n  if( a.real()<b.real() ) return true;\n  return false;\n}\n\nvoid andrewConvexHull(const vector<point> &Q, vector<point> &CH)\n{\n  vector<point> T = Q;\nif(Q.size()<3){CH=Q;return ;}\n  int n = T.size(), k = 0;\n  sort( T.begin(), T.end(), cmpXy );\n  CH.resize(2*n);\n  for(int i = 0; i < n; CH[k++] = T[i++]){\n    while( k >= 2 && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  for(int i = n-2, t = k+1; i >= 0; CH[k++] = T[i--] ){\n    while( k >= t && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  CH.resize(k-1);\n}\n\nbool regularConvex(vector<point> &vp){\n  vector<point> ret;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    for(int j = i+1; j < (int)vp.size(); ++j){\n      if( eq(abs(vp[i]-vp[j]),0) ){\n        vp.erase( vp.begin() + j );\n      }\n    }\n  }\n  andrewConvexHull( vp, ret );\n  vp = ret;\n}\n\n\nbool convexCut(const vector<point> &vp,\n               line l,\n               vector<point> &left)\n{\n  vector<point> tmp;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    if( ccw(l.first, l.second, vp[i] ) == LEFT ){\n      tmp.push_back(vp[i]);\n    }\n  }\n  for(int i = 0; i < (int)vp.size(); ++i){\n    point is;\n    seg s(vp[i],vp[(i+1)%vp.size()]);\n    if(intersectionLS( l, s, is )){\n      tmp.push_back(is);\n    }\n  }\n  regularConvex(tmp);\n  left = tmp;\n  return true;\n}\n\nelem area(const vector<point> &vp){\n  elem ret= 0;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    ret += cross(vp[i],vp[(i+1)%vp.size()]);\n  }\n  return abs(ret/2);\n}\n \nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    elem res = 1e20;\n    point c;\n    for(int i = 0; i < n; ++i){\n      elem x, y;\n      cin >> x >> y;\n      x*=10;\n      y*=10;\n      vp.push_back( point(x,y) );\n    }\n\n    elem r = 1e7;\n    elem l = 0;\n    int cnt = 0;\n    vector<point> L;\n    while(cnt++<200){\n      elem m = (l+r)/2.;\n      \n      L = vp;\n      for(int i = 0; i < n; ++i){\n        line a( vp[i], vp[(i+1)%n] );\n        point b = m * unml(a.second-a.first);\n        \n        line la(b+a.first,b+a.second);\n        //cout << a.first << ' ' << a.second << ' ' << la.first << ' ' << la.second << endl;\n        vector<point> newL;\n        convexCut( L, la, newL );\n        L = newL;\n      }\n\n      /*\n      cout << m << ' ' << \" Size : \" << L.size() << endl;\n      for(int i = 0; i < (int)L.size(); ++i){\n        cout << L[i] << ' ';\n      }\n      cout << endl;\n      */\n\n      if( L.size()<3 ){\n        r = m;\n      }else{\n        l = m;\n      }\n    }\n    \n    for(int i = 0; i < n; ++i){\n      res = min(res, dist_seg(seg(vp[i],vp[(i+1)%n]),L[0]));\n    }\n    cout << fixed << setprecision(6) << res/10 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{\n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0)\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[i + 1] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[i + 1] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e9;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  /*\n    Polygon A;\n    A.push_back(P(inf,inf)); A.push_back(P(-inf,inf));\n    A.push_back(P(-inf,-inf)); A.push_back(P(inf,-inf));\n  */\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-7;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨???????????¢\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\n/* \n   ???????§???¢???????????????????????????????§???¢????????¨????¢????????????¨???????????????????????? \n   ????????? 0:?????¨ 1:?¢???? 2:?????¨ \n   ???????¨?????????§????????¨??????????????? \n   O(log n) \n*/\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n} \n \n\nint N;\nvector<P> v;\n\nconst double WPS = 35.0;\nconst double BPS = 10.0;\n\nint main(){\n  while( (~scanf(\"%d\",&N)) && N ){\n    v.clear();\n    double sx=1e19,sy=1e19,ex=-1e19,ey=-1e19;\n    for(int i=0;i<N;i++) {\n      int x,y;\n      scanf(\"%d%d\",&x,&y); v.push_back( P(x,y) );\n      sx = min( (double)x, sx ), sy = min ( (double)y , sy );\n      ex = max( (double)x, ex ), ey = max ( (double)y , ey );\n    }\n\n    double wx = (ex-sx)/WPS;\n    double wy = (ey-sy)/WPS;\n    double res;\n    for(;wx>EPS&&wy>EPS;){\n      res = 0.0;\n      P ns = P((ex+sx)/2.0,(ey+sy)/2.0);\n      for(double x=sx;x<ex;x+=wx){\n\tfor(double y=sy;y<ey;y+=wy){\n\t  P c = P(x + wx/2.0,y + wy/2.0);\n\t  double ret = 1e19;\n\t  if( convex_contains( v, c ) == 0 ) continue;\n\t  for(int k=0;k<N;k++){\n\t    L s = L( v[k] , v[(k+1)%N] );\n\t    ret = min( ret , getDistanceSP(s,c) );\n\t  }\n\t  //\t  cout << c <<  \" \" << \" ret : =  \" << ret << endl;\n\t  if( ret > res ){\n\t    res = ret;\n\t    ns = c; \n\t  }\n\t}\n      }\n      //  cout << ns << \" res = \" << res << endl;\n      //printf(\"(%lf,%lf) - (%lf,%lf) : (%lf,%lf)\\n\",sx,sy,ex,ey,wx,wy);\n      //   Sleep(1000);\n      sx = ns.real()-wx*BPS; sy = ns.imag()-wy*BPS;\n      ex = ns.real()+wx*BPS; ey = ns.imag()+wy*BPS;\n      wx = (ex-sx)/WPS; wy = (ey-sy)/WPS;\n  \n    }\n\n    printf(\"%.8lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Segment { Point p1, p2; };\nPoint Minus(Point a, Point b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Segment& a, const Point& b) {\n\treturn dot(Minus(a.p2, a.p1), Minus(b, a.p1)) < 0.0 ? abs(Minus(b, a.p1)) : (dot(Minus(a.p1, a.p2), Minus(b, a.p2)) < 0.0 ? abs(Minus(b, a.p2)) : abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nvector<Point>x; int n;\nlong double solve(long double S) {\n\tlong double L1 = -100000.0l, R1 = 100000.0l, d1, d2, maxn2 = -1000000000.0l;\n\tfor (int i = 0; i < 200; i++) {\n\t\td1 = (L1 + L1 + R1) / 3;\n\t\td2 = (L1 + R1 + R1) / 3;\n\t\tlong double cnt1 = 1000000000.0l, cnt2 = 1000000000.0l;\n\t\tPoint P1 = Point{ S,d1 }, P2 = Point{ S,d2 };\n\t\tif (contain(x, P1) >= 1) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSegment L1 = Segment{ x[j],x[(j + 1) % n] };\n\t\t\t\tlong double W3 = dst(L1, P1);\n\t\t\t\tcnt1 = min(cnt1, W3);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcnt1 = -1000000000.0l;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSegment L1 = Segment{ x[j],x[(j + 1) % n] };\n\t\t\t\tlong double W3 = dst(L1, P1);\n\t\t\t\tcnt1 = max(cnt1, -1.0l*W3);\n\t\t\t}\n\t\t}\n\t\tif (contain(x, P2) >= 1) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSegment L1 = Segment{ x[j],x[(j + 1) % n] };\n\t\t\t\tlong double W4 = dst(L1, P2);\n\t\t\t\tcnt2 = min(cnt2, W4);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcnt2 = -1000000000.0l;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSegment L1 = Segment{ x[j],x[(j + 1) % n] };\n\t\t\t\tlong double W4 = dst(L1, P2);\n\t\t\t\tcnt2 = max(cnt2, -1.0l*W4);\n\t\t\t}\n\t\t}\n\t\tif (cnt1 < cnt2)L1 = d1;\n\t\tif (cnt1 > cnt2)R1 = d2;\n\t\tmaxn2 = max(maxn2, max(cnt1, cnt2));\n\t}\n\treturn maxn2;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; x.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) { Point AA; cin >> AA.px >> AA.py; x.push_back(AA); }\n\t\tlong double L = -100000.0l, R = 100000.0l, c1, c2, maxn = 0.0l;\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tc1 = (L + L + R) / 3;\n\t\t\tc2 = (L + R + R) / 3;\n\t\t\tlong double W1 = solve(c1), W2 = solve(c2);\n\t\t\tif (W1 < W2)L = c1;\n\t\t\tif (W1 > W2)R = c2;\n\t\t\tmaxn = max(maxn, max(W1, W2));\n\t\t}\n\t\tprintf(\"%.16Lf\\n\", maxn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<utility>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> Line;\n\ndouble eps=1e-9;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP cp(Line a,Line b){\n  P bv=b.second-b.first;\n  P av=a.second-a.first;\n  return a.first+av*cross(bv,b.first-a.first)/cross(bv,av);\n}\n\ndouble ail(Line l,P p){\n  return arg(((abs(l.first-p)>abs(l.second-p))?l.first:l.second)-p);\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int y[100],x[100];\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i];\n    }\n    vector<Line> edges;\n    for(int i=0;i<n;i++){\n      edges.emplace_back(P(x[i],y[i]),P(x[(i+1)%n],y[(i+1)%n]));\n    }\n    double md=-1;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tfor(int k=j+1;k<n;k++){\n\t  Line e[3]={edges[i],edges[j],edges[k]};\n\t  vector<Line> v;\n\t  for(int l=0;v.size()<2;l++){\n\t    Line a=e[l],b=e[(l+1)%3];\n\t    if(fabs(cross(a.second-a.first,b.second-b.first))<eps)continue;\n\t    P p=cp(a,b);\n\t    v.emplace_back(p,p+polar(1.,(ail(a,p)+ail(b,p))/2));\n\t  }\n\t  P candp=cp(v[0],v[1]);\n\t  double cmd=1e9;\n\t  bool f=false;\n\t  for(auto elm:edges){\n\t    P vec=elm.second-elm.first;\n\t    cmd=min(cmd,fabs(cross(vec,candp-elm.first))/abs(vec));\n\t    f|=cross(candp-elm.first,elm.second-elm.first)>0;\n\t  }\n\t  if(!f){\n\t    md=max(md,cmd);\n\t  }\n\t}\n      }\n    }\n    cout<<fixed<<md<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nstruct L {\n    P a, b, v, h;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a), h(v / abs(v) * P(0, 1)) {}\n    // L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void trans(double d) {\n        a += d * h;\n        b += d * h;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n            h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nbool check(double d, G g, vector<L> l) {\n    int n = g.size();\n    rep(i, n) {\n        l[i].trans(d);\n        g = convex_cut(g, l[i]);\n        // rep(i, g.size()) {\n        //     cerr << g[i].real() << \" \" << g[i].imag() << endl;\n        // }\n        // cerr << endl;\n    }\n    return (int)g.size() >= 3;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int testcase = 0;\n    int n;\n    while (cin >> n, n) {\n        // cerr << \"--- testcase \" << ++testcase << \" ---\" << endl;\n        G g;\n        rep(i, n) g.emplace_back(readP());\n        vector<L> l;\n        rep(i, n) {\n            l.emplace_back(here(g, i), next(g, i));\n        }\n\n        // if (testcase != 2) continue;\n\n        // check(500, g, l);\n\n        double lb = 0, ub = 1e10;\n        rep(_, 200) {\n            double mid = (lb + ub) / 2;\n            (check(mid, g, l) ? lb : ub) = mid;\n        }\n\n        cout << fixed << setprecision(10) << lb << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<windows.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; \n  if(cross(b,c) < -EPS) return -1; \n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨???????????¢\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n \n// ?????´???????????????\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\n\n/*\n  ???????§???¢?????´?????§??????????????´?????¨????????????\n  ???????§???¢??????????¨???????????????????\n  vector<P>??????????§???¢\n*/\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<(int)G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\n//??´??????????????????????????????????±???????\nvector<P> getUnitNormalV(P A,P B){\n  vector<P> v;\n  v.push_back( ((B-A)*P(0,1))/abs(B-A) );\n  v.push_back( ((B-A)*P(0,-1))/abs(B-A) );\n  return v;\n}\n\n//??????s????????¢d?????????????§????\nvector<L> getTranslation(L s,double d){\n  vector<P> p = getUnitNormalV(s.first,s.second);\n  vector<L> ret;\n  for(int i=0;i<2;i++){\n    ret.push_back( L( s.first + p[i]*d , s.second + p[i]*d ) );\n  }\n  return ret;\n}\n\nint N;\nvector<P> v;\n\nconst double WPS = 35.0;\nconst double BPS = 10.0;\n\nint main(){\n  while( (~scanf(\"%d\",&N)) && N ){\n    v.clear();\n    for(int i=0;i<N;i++) {\n      int x,y;\n      scanf(\"%d%d\",&x,&y); v.push_back( P(x,y) );\n    }\n    v.push_back(P(v[0]));\n    double st = 0.0, ed = 1e5;\n    while( (ed-st) > EPS ){\n      double d = (st+ed)/2.0;\n      vector<P> Q = v;\n      Q.pop_back();\n      for(int i=0;i<N;i++){\n\tL s = L(v[i],v[i+1]);\n\tvector<L> tr = getTranslation(s,d);\n\tif( ccw(s.first,s.second,tr[0].first) == 1 )\n\t  Q = convex_cut(Q,tr[0]);\n\t else \n\t  Q = convex_cut(Q,tr[1]);\t\n      }\n      if( Q.empty() )\n\ted = d;\n      else\n\tst = d;\n    }\n\n    printf(\"%.8lf\\n\",ed);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\t// if (is_parallel(line1, line2))\n\t// {\n\t// \tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t// \texit(1);\n\t// }\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{\n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0)\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[(i + 1) % g.size()] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[i + 1] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e9;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble area(Poly p){\n  int n = p.size();\n  double s = 0;\n  for(int i = 1; i < n-1; ++i){\n    s += cross(p[i]-p[0],p[i+1]-p[0])/2;\n  }\n  return s;\n}\n\n/*\ndouble solve(Poly p){\n  double s = area(p), l = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    l += abs(p[i]-p[(i+1)%n]);\n  }\n  return 2*s/l;\n}\n*/\n\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double ret = INF;\n  for(int i = 0; i < n; ++i){\n    double t = 0;\n    for(int j = 0; j < n; ++j){\n      t = max(t, p_to_s_dist(p[j],L(p[i],p[(i+1)%n])));\n    }\n    ret = min(ret, t);\n  }\n  return ret;\n}\n*/\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nL angle_bisector(P a, P b, P c){\n  //?§?abc??????????????????\n  //a, b or b, c????????´????????¨????????????????????????RE?????????\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\ndouble solve(Poly p){\n  int n = p.size();\n  vector<L> ab;\n  for(int i = 0; i < n; ++i){\n    ab.push_back(angle_bisector(p[i],p[(i+1)%n],p[(i+2)%n]));\n  }\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = i+1; j < n; ++j){\n      if(abs(cross(ab[i].second-ab[i].first,ab[j].second-ab[j].first)) < EPS) continue;\n      P x = intersection(ab[i],ab[j]);\n      if(in_poly(x,p)) cp.push_back(x);\n    }\n  }\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n\nint main(){\n  int n;\n  double x, y;\n  while(cin >> n, n){\n    Poly p;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    printf(\"%.6lf\\n\",solve(p));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ninline double cross(const P& a, const P& b){return imag(conj(a)*b);}\ninline double dot(const P& a, const P& b){return real(conj(a)*b);}\nstruct L : public vector<P> {\n    L(const P &a, const P &b){push_back(a); push_back(b);}\n    L(){}\n};\nP projection(const L &l, const P &p){double t = dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);return l[0]+t*(l[0]-l[1]);}\ninline double distanceLP(const L &l, const P &p){return abs(p-projection(l, p));}\nP innerCenter(P a, P b, P c){double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);return (la*a+lb*b+lc*c)/(la+lb+lc);}\n\nint n;\nP ps[128];\nL es[128];\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g=(ps[0]+ps[n/3]+ps[2*n/3])/3.0;\n    int a=0,b=n;\n    while (a+1 < b) {\n        int c=(a+b)/2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    if(n==3)return distanceLP(es[0],p);\n\n    double const r[]={100,10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8};\n    double static d[128];\n    int near=0;\n    rep(t,11){\n        rep(u,3000){\n            rep(i,n)d[i]=distanceLP(es[i],p);\n            near=0;\n            rep(i,n)if(d[i]<d[near])near=i;\n            P h=projection(es[near],p);\n            P np=p-(h-p)/d[near]*r[t];\n            if(convex_contains(np)==IN){\n                swap(p,np);\n            } else {\n                break;\n            }\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n \n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n};\n \n#define Line pair<point,point>\n \ndouble dot(point a, point b){return (a.x*b.x+a.y*b.y);}\ndouble cross(point a, point b){return (a.x*b.y-a.y*b.x);}\ndouble norm(point a){return sqrt(a.x*a.x+a.y*a.y);}\n \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n \npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1+(a2-a1)*(cross(b2-b1,b1-a1)/cross(b2-b1,a2-a1));\n}\n \npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n \n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n \n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n    return make_pair(a_,b_);\n}\n \nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n \n/*\nテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ青?ィツセツコテ」ツつ壇テ」ツ??」ツ?妥・ツ??・ツ?エテ」ツ?ォテ」ツ?堙」ツつ嘉」ツ?療」ツ?淌ァツ崢エテァツキツ堙」ツ?ァテ」ツ??・ツ、ツ堙ィツァツ津・ツスツ「テ」ツつ津・ツ按?ヲツ鳴ュテ」ツ??\nテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?古ヲツョツ凝」ツ?」テ」ツ?ヲテ」ツ??」ツつ古」ツ?ーtrue\nテ」ツ?敕」ツつ古、ツサツ・テ・ツ、ツ姪」ツ?ェテ」ツつ映alseテ」ツつ津ィツソツ氾」ツ?凖」ツ??\n*/\nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n \n/*\nテ、ツコツ古・ツ按?ヲツ篠「テァツエツ「テ」ツ?ァテ」ツ??・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテ・ツ青?ィツセツコテ」ツつ津」ツ?ゥテ」ツつ古」ツ??」ツ?妥・ツ??・ツ?エテ」ツ?ォテ」ツ?堙」ツつ嘉」ツ?崚」ツ?ー\nテ」ツ?。テ」ツつ?」ツ??」ツ?ゥテ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?古ヲツカツ暗」ツ?暗」ツつ凝」ツ?ョテ」ツ?凝」ツつ津ヲツアツづ」ツつ?」ツつ凝」ツ??\n*/\ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=86;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n \nint main(void){\n \n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n \n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\t//addhtml(\"ctx.fill();\");\n\t}\n};\n\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nint main(void){\n\tfor(;;){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tpolygon pol;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tpol.ps.push_back(pos(x,y));\n\t\t}\n\t\tvector<line> es;\n\t\trep(i,n)es.push_back(pol.gete(i));\n\t\t\n\t\tdouble l=0,r=1e6;\n\t\trep(qqq,100){\n\t\t\tdouble d=(l+r)/2;\n\t\t\tpolygon tp(pol);\n\t\t\t\n\t\t\trep(i,n){\n\t\t\t\tline ne=es[i];\n\t\t\t\tpos bs=ne.bisection().vec;\n\t\t\t\tbs = bs.scalar(d/bs.norm);\n\t\t\t\tne = line(ne.q+bs,ne.p+bs);\n\t\t\t\ttp = tp.cut(ne);\n\t\t\t}\n\t\t\t\n\t\t\tif(tp.ps.size()<=0)r=d;\n\t\t\telse l=d;\n\t\t}\n\t\tprintf(\"%f\\n\",l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\ndouble solve(){\n    P p=innerCenter(ps[0],ps[1],ps[2]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    static double d[128];\n    int near=0;\n    double r[]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8,1e-9,1e-10};\n    rep(t,200000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n){\n            if(d[i]<d[near]){\n                near=i;\n            }\n        }\n        P h=projection(es[near],p);\n        p -= (h-p)/d[near]*r[t/20000];\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-7;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\nint crossSS(const L &l, const L &m, P &r) {\n    int u = crossLL(l, m, r);\n    if (u == 0) return 0;\n    if (u == -1) {\n        int x = ccw(l.x, l.y, m.x);\n        int y = ccw(l.x, l.y, m.y);\n        if (x == 0) {\n            r = m.x;\n            return -1;\n        }\n        if (y == 0) {\n            r = m.y;\n            return -1;\n        }\n        if (x == y) return 0;\n        r = l.x;\n        return -1;\n    }\n    if (ccw(l.x, l.y, r) == 0 && ccw(m.x, m.y, r) == 0) return 1;\n    return 0;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\n//need Intersect/distLP\nint crossLC(const L &l, const C &c, L &r) {\n    R u = distLP(l, c.p);\n    int si = sgn(u - c.r);\n    if (si == 1) return 0;\n    P v = (l.y-l.x) / abs(l) * P(0, -1); //l?????´???????????????????????????\n    v *= u;\n    if (ccw(l.x, l.y, c.p) < 0) v *= -1;\n    //v?????????????????????l?????¨??????????????????????????????\n    if (si == 0) {\n        r.x = r.y = c.p + v;\n        return 1;\n    }\n    r.x = c.p+v+polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    r.y = c.p+v-polar<R>(sqrt(c.r*c.r - u*u), arg(vec(l)));\n    return 2;\n}\n\n\n//return number of cross point\nint crossCC(const C &c, const C &d, L &l) {\n    if (near(c.p, d.p) && !sgn(c.r, d.r)) {\n        l.x = l.y = c.p+P(c.r, 0);\n        return -1;\n    }\n    R di = abs(c.p - d.p);\n    if (sgn(c.r+d.r, di) == 1) return 0;\n    if (sgn(di, abs(c.r-d.r)) == 1) return 0;\n    R bth = arg(d.p - c.p);\n    R th = sacos((c.r*c.r + di*di - d.r*d.r) / (2*c.r*di));\n    l.x = c.p+polar<R>(c.r, bth+th);\n    l.y = c.p+polar<R>(c.r, bth-th);\n    if (sgn(th) == 0) return 1;\n    return 2;\n}\n\n\ntypedef vector<P> Pol;\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const Pol &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nPol l2rect(const L &l, R r) {\n    P v = vec(l)*P(0, 1) / abs(vec(l)) * r;\n    Pol p;\n    p.push_back(l.x + v);\n    p.push_back(l.x - v);\n    p.push_back(l.y - v);\n    p.push_back(l.y + v);\n    return p;\n}\n\n\nPol po;\n\nbool solve(R md) {\n    int n = po.size();\n    vector<L> lv;\n    vector<Pol> pov;\n    vector<C> cv;\n    for (int i = 0; i < n; i++) {\n        cv.push_back(C(po[i], md));\n        pov.push_back(l2rect(L(po[i], po[(i+1)%n]), md));\n    }\n    for (Pol &pp : pov) {\n        lv.push_back(L(cu(pp, 3), cu(pp, 0)));\n        for (int i = 0; i < 4; i++) {\n        }\n    }\n    vector<P> pv;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            P pp;\n            if (crossSS(lv[i], lv[j], pp)) {\n                pv.push_back(pp);\n            }\n        }\n    }\n    for (P &p: pv) {\n        if (contains(po, p) == 0) continue;\n        bool f = true;\n        for (Pol &po: pov) {\n            if (contains(po, p) == 2) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        for (C &c: cv) {\n            if (sgn(abs(c.p - p), c.r) == 1) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        //printf(\"%.lf\", md);\n        //cout << p << endl;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        po.clear();\n        for (int i = 0; i < n; i++) {\n            R x, y;\n            cin >> x >> y;\n            po.push_back(P(x, y));\n        }\n        R l = 0, r = 1e5;\n        for (int i = 0; i < 50; i++) {\n            R md = (l+r)/2;\n            if (solve(md)) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        printf(\"%.20lf\\n\", l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-10;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(U.size())return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        D l=0,r=100000;\n        rep(c,200){\n            D mid=(l+r)/2;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.6f\\n\",l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Real = long double;\nconst Real EPS = 1e-8, PI = acos(-1);\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n      if (a.real() == b.real()) return a.imag() < b.imag();\n      return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n      return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\nReal radian_to_degree(Real r) {\n  return r * 180.0 / PI;\n}\nReal degree_to_radian(Real d) {\n  return d * PI / 180.0;\n}\nPoint rotate(const Point &p, Real theta) {\n  return p * polar((Real)1.0, theta);\n}\nReal cross(const Point& a, const Point& b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\nReal dot(const Point& a, const Point& b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nPoint projection(const Line& l, const Point& p) {\n  Real A = dot(l.b - l.a, p - l.a),\n          B = dot(l.a - l.b, p - l.b);\n  return (A * l.b + B * l.a) / (A + B);\n}\nbool parallel(const Line& l1, const Line& l2) {\n  return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nbool orthogonal(const Line& l1, const Line& l2) {\n  return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(b, c) < -EPS) return CLOCKWISE;\n  if (dot(b, c) < 0) return ONLINE_BACK;\n  if (norm(b) < norm(c)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersected(const Line& l, const Point& p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersected(const Segment& s, const Point& p) {\n  return ccw(s.a, s.b, p) == 0;\n}\nbool intersected(const Line& l, const Segment& s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\nbool intersected(const Segment& s1, const Segment& s2) {\n  return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n         ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\nReal distance(const Line& l, const Point& p) {\n  return abs(p - projection(l, p));\n}\nReal distance(const Segment& s, const Point& p) {\n  Point r = projection(s, p);\n  if (intersected(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Line &l, const Segment &s) {\n  if (intersected(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\nReal distance(const Segment& s1, const Segment& s2) {\n  if (intersected(s1, s2)) return 0.0;\n  return min({ distance(s1, s2.a), distance(s1, s2.b),\n               distance(s2, s1.a), distance(s2, s1.b) });\n}\nPoint crosspoint(const Line& l1, const Line& l2) {\n  Real A = cross(l2.a - l1.a, l2.b - l1.a),\n          B = cross(l2.b - l1.b, l2.a - l1.b);\n  return (A * l1.b + B * l1.a) / (A + B);\n}\nusing Polygon = vector<Point>;\nReal area(const Polygon& U) {\n  Real area = 0;\n  for (int i = 0; i < U.size(); ++i) {\n    area += cross(U[i], U[(i + 1) % U.size()]);\n  }\n  return area / 2.0;\n}\nbool is_convex(const Polygon &U) {\n  int n = U.size();\n  for (int i = 0; i < n; ++i) {\n    if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;\n  }\n  return true;\n}\nconst int OUT = 0,\n        ON = 1,\n        IN = 2;\nint contains(const Polygon &U, const Point &p) {\n  int in = 0;\n  for (int i = 0; i < U.size(); ++i) {\n    Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;\n    if (cross(a, b) == 0 and dot(a, b) <= 0) return ON;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 and 0 < b.imag() and cross(a, b) < 0) in ^= 1;\n  }\n  return in ? IN : OUT;\n}\nvector<Point> convex_hull(vector<Point>& p, bool includeOnLine = false) {\n  int n = p.size(), k = 0;\n  if (n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector<Point> ch(n * 2);\n  const Real BOUND = includeOnLine ? -EPS : EPS;\n  for (int i = 0; i < n; ch[k++] = p[i++]) {\n    while (k >= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n  }\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = p[i--]) {\n    while (k >= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nReal convex_diameter(const Polygon &U) {\n  int n = U.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (U[i].imag() > U[is].imag()) is = i;\n    if (U[i].imag() < U[js].imag()) js = i;\n  }\n  Real maxnorm = norm(U[is] - U[js]);\n  int i = is, j = js;\n  do {\n    if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) >= 0) {\n      j = (j+1) % n;\n    } else {\n      i = (i+1) % n;\n    }\n    if (norm(U[i] - U[j]) > maxnorm) {\n      maxnorm = norm(U[i] - U[j]);\n    }\n  } while (i != is or j != js);\n  return sqrt(maxnorm);\n}\nPolygon convex_cut(const Polygon& U, const Line& l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); ++i) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) == -1) {\n      ret.push_back(crosspoint(Line{ now, nxt }, l));\n    }\n  }\n  return ret;\n}\nPolygon voronoi_cell(const Point& c, const vector<Point>& ps, Polygon outer) {\n  for (const Point& p : ps) {\n    Point m = (p + c) / complex<ld>(2.0, 0);\n    outer = convex_cut(outer,\n                       Line{ m, m + rotate(p - c, M_PI / 2) });\n  }\n  return outer;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n  int n; cin >> n;\n  if(n == 0) break;\n  Polygon poly;\n  for(int i=0;i<n;++i) {\n    int x, y; cin >> x >> y;\n    poly.emplace_back(Point(x, y));\n  }\n  vector<Line> lines;\n  for(int i=0;i<n;++i) {\n    lines.emplace_back(Line(poly[i], poly[(i+1)%n]));\n  }\n  vector<Point> norm;\n  for(int i=0;i<n;++i) {\n    Point tmp = (lines[i].b - lines[i].a);\n    norm.emplace_back(Point(-tmp.imag() / abs(tmp), tmp.real() / abs(tmp)));\n  }\n  Real l = 0, r = 100000000;\n  while(r - l > eps) {\n    Real mid = (l + r) / 2.0;\n    vector<Line> newlines;\n    for(int i=0;i<n;++i) {\n      newlines.emplace_back(Line(lines[i].a + norm[i] * mid, lines[i].b + norm[i] * mid));\n    }\n    Polygon tmp = poly;\n    for(int i=0;i<n;++i) {\n      tmp = convex_cut(tmp, newlines[i]);\n    }\n    if((int)(tmp.size()) > 0) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  cout << l << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\nusing namespace std;\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\n\nusing R=long double; // __float128\nconst R EPS = 1E-14; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\n\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(det(l.s,l.t,a)>=0) reg(res,a);\n\t\tif(det(l.s,l.t,a)*det(l.s,l.t,b)<0) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\nbool check(VP pol,R len){\n\tint n=pol.size();\n\tVL lines(n);\n\n\trep(i,n){\n\t\tP e=(pol[(i+1)%n]-pol[i])/abs(pol[(i+1)%n]-pol[i])*P(0,1);\n\t\tlines[i]=L({pol[i]+e*len,pol[(i+1)%n]+e*len});\n\t}\n\n\tVP cur=pol;\n\trep(i,n) cur=convex_cut(cur,lines[i]);\n\treturn sgn(area(cur));\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol(n);\n\t\trep(i,n) cin >> pol[i];\n\n\t\tR lb=0.0,ub=20000.0;\n\n\t\trep(loop,200){\n\t\t\tconst R mid=(lb+ub)/2.0;\n\t\t\tif(check(pol,mid))\n\t\t\t\tlb=mid;\n\t\t\telse\n\t\t\t\tub=mid;\n\t\t}\n\n\t\tcout.precision(20);\n\t\tcout << fixed << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define all(a) (a).begin(),(a).end()\n\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\ninline P unit(P p){return p/abs(p);}\ninline pair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\n//for line(segment)\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\n//vertexes are in the counter-clockwise order.\ninline Poly convex_cut(Poly p,L l){\n  Poly res;\n  rep(i,p.sz){\n    int nxt = (i+1)%p.sz;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nbool check(D dis, const Poly &p){\n  Poly U(4);\n  U[0] = P(-1e6, -1e6);\n  U[1] = P(+1e6, -1e6);\n  U[2] = P(+1e6, +1e6);\n  U[3] = P(-1e6, +1e6);\n\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    L l = L(p[i],p[(i+1)%n]);\n    P vec = norm(l.sc-l.fs).fs, move = dis*unit(vec);\n    l.fs += move; l.sc += move;\n    U = convex_cut(U,l);\n  }\n  return !U.empty();\n}\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    Poly p(n);\n    for(int i=0;i<n;i++){\n      D x,y;\n      cin >> x >> y;\n      p[i] = P(x,y);\n    }\n\n    D l = 0, r = 1e6;\n    for(int i=0;i<100;i++){\n      D mid = (l+r)/2;\n      if(check(mid,p))l = mid;\n      else r = mid;\n    }\n    cout << fixed << setprecision(10) << l << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bi_deg(Point a, Point b, Point c) {\n\tPoint d = (b - c) / (a - c);\n\tld deg = atan2l(d.imag(), d.real()) / 2.0;\n\treturn Line(c, c + (Point(cosl(deg), sinl(deg)) * (a - c)));\n}\n\nPoint H(Line a, Line b, Line c) {\n\tif (!isis_ll(a, b)) {\n\t\tPoint x = is_ll(b, c), y = is_ll(c, a);\n\t\treturn is_ll(bi_deg(b.a, a.b, x), bi_deg(c.a, a.b, y));\n\t}\n\telse if (!isis_ll(b, c)) {\n\t\tPoint x = is_ll(c, a), y = is_ll(a, b);\n\t\treturn is_ll(bi_deg(c.a, a.b, x), bi_deg(a.a, b.b, y));\n\t}\n\telse {\n\t\tPoint x = is_ll(a, b), y = is_ll(b, c);\n\t\treturn is_ll(bi_deg(a.a, b.b, x), bi_deg(b.a, c.b, y));\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Point> p(n);\n\t\tfor (int i = 0, x, y; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tvector<Line> l(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = bi_deg(p[i], p[(i + 2) % n], p[(i + 1) % n]);\n\t\t}\n\t\tvector<Line> e(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = Line(p[i], i + 1 < n ? p[i + 1] : p[0]);\n\t\t}\n\t\tvector<Point> all;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (isis_ll(e[i], e[j]) || isis_ll(e[j], e[k]) || isis_ll(e[k], e[i])) {\n\t\t\t\t\t\tall.push_back(H(e[i], e[j], e[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tld res = 0;\n\t\tfor (auto is : all) {\n\t\t\tld deg = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tPoint tmp = (p[(k + 1) % n] - is) / (p[k] - is);\n\t\t\t\tdeg += atan2l(tmp.imag(), tmp.real());\n\t\t\t}\n\t\t\tif (eq(deg, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tld mi = 1e10;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tmi = min(mi, dist_sp(e[k], is));\n\t\t\t}\n\t\t\tres = max(res, mi);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\n#include<algorithm>\nusing namespace std;\n\ntypedef long double elem;\ntypedef complex<elem> point,vec;\ntypedef pair<point,point> seg,line;\nconst elem eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(elem a, elem b){return abs(b-a) < eps;}\nvec uvec(const vec &v){return v / abs(v);}\nvec nml(vec a){return a*vec(0,1);}\nvec unml(vec a){return uvec(nml(a));}\n\nelem dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nelem cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nelem dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nelem dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\nbool intersectedLL(const line &a, const line &b){\n  return !eq( cross(a.second-a.first,b.second-b.first), 0.0 );\n}\n\npoint intersectionSS(const seg &a, const seg &b)\n{\n  elem d1 = dist_l(b,a.first);\n  elem d2 = dist_l(b,a.second);\n  return a.first + ( d1 / (d1 + d2 ) ) * (a.second-a.first);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nbool intersectionLL(const line &a, const line &b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\n\nbool intersectionLS(const line &l, const seg &s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.first,s.second,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\n\nbool cmpXy(const point &a, const point &b){\n  if( eq(a.real(),b.real() ) ) return a.imag()<b.imag();\n  if( a.real()<b.real() ) return true;\n  return false;\n}\n\nvoid andrewConvexHull(const vector<point> &Q, vector<point> &CH)\n{\n  vector<point> T = Q;\nif(Q.size()<3){CH=Q;return ;}\n  int n = T.size(), k = 0;\n  sort( T.begin(), T.end(), cmpXy );\n  CH.resize(2*n);\n  for(int i = 0; i < n; CH[k++] = T[i++]){\n    while( k >= 2 && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  for(int i = n-2, t = k+1; i >= 0; CH[k++] = T[i--] ){\n    while( k >= t && ccw( CH[k-2], CH[k-1], T[i] ) & ( RIGHT | BACK ) ) --k;\n  }\n  CH.resize(k-1);\n}\n\nbool regularConvex(vector<point> &vp){\n  vector<point> ret;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    for(int j = i+1; j < (int)vp.size(); ++j){\n      if( eq(abs(vp[i]-vp[j]),0) ){\n        vp.erase( vp.begin() + j );\n      }\n    }\n  }\n  andrewConvexHull( vp, ret );\n  vp = ret;\n}\n\n\nbool convexCut(const vector<point> &vp,\n               line l,\n               vector<point> &left)\n{\n  vector<point> tmp;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    if( ccw(l.first, l.second, vp[i] ) == LEFT ){\n      tmp.push_back(vp[i]);\n    }\n  }\n  for(int i = 0; i < (int)vp.size(); ++i){\n    point is;\n    seg s(vp[i],vp[(i+1)%vp.size()]);\n    if(intersectionLS( l, s, is )){\n      tmp.push_back(is);\n    }\n  }\n  regularConvex(tmp);\n  left = tmp;\n  return true;\n}\n\nelem area(const vector<point> &vp){\n  elem ret= 0;\n  for(int i = 0; i < (int)vp.size(); ++i){\n    ret += cross(vp[i],vp[(i+1)%vp.size()]);\n  }\n  return abs(ret/2);\n}\n \nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    elem res = 1e20;\n    point c;\n    for(int i = 0; i < n; ++i){\n      elem x, y;\n      cin >> x >> y;\n      x*=10;\n      y*=10;\n      vp.push_back( point(x,y) );\n    }\n\n    elem r = 1e7;\n    elem l = 0;\n    int cnt = 0;\n    vector<point> L;\n    while(cnt++<200){\n      elem m = (l+r)/2.;\n      \n      L = vp;\n      for(int i = 0; i < n; ++i){\n        line a( vp[i], vp[(i+1)%n] );\n        point b = m * unml(a.second-a.first);\n        \n        line la(b+a.first,b+a.second);\n        //cout << a.first << ' ' << a.second << ' ' << la.first << ' ' << la.second << endl;\n        vector<point> newL;\n        convexCut( L, la, newL );\n        L = newL;\n      }\n\n      /*\n      cout << m << ' ' << \" Size : \" << L.size() << endl;\n      for(int i = 0; i < (int)L.size(); ++i){\n        cout << L[i] << ' ';\n      }\n      cout << endl;\n      */\n\n      if( L.size()<3 ){\n        r = m;\n      }else{\n        l = m;\n      }\n    }\n    \n    for(int i = 0; i < n; ++i){\n      res = min(res, dist_seg(seg(vp[i],vp[(i+1)%n]),L[0]));\n    }\n    cout << fixed << setprecision(6) << res/10 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    G g;\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      g.push_back(P(a,b));\n    }\n    vector<L> ls;\n    REP(i, n) {\n      P p1, p2 ;\n      if (i==n-1) p1 = g[0];\n      else p1 = g[i+1];\n      if (i==0) p2 = g[n-1];\n      else p2 = g[i-1];\n      p1 -= g[i];\n      p2 -= g[i];\n      p1 *= 1/abs(p1);\n      p2 *= 1/abs(p2);\n      //cout << l1[0] << \" l1 = \"  << l1[1] << \" \" << \"l2 = \" << l2[1]<< endl;\n      L l(g[i], g[i] + p1+p2);\n      ls.push_back(l);\n    }\n    // REP(i, ls.size()) {\n    //   cout << ls[i][0] << \" \" << ls[i][1] << endl;\n    // }\n    double ans = 0;\n    REP(i, n) {\n      REP(j, i) {\n        if (!intersectLL(ls[i],ls[j])) continue;\n        P p = crosspoint(ls[i], ls[j]);\n        double mi = INF;\n        bool ok = 1;\n        REP(k, n) {\n          L l;\n          if (k == n-1) l = L(g[k], g[0]);\n          else l = L(g[k], g[k+1]);\n          if (ccw(l[0], l[1], p) != 1) {\n            ok = 0;\n            break;\n          }\n          mi = min(mi, distanceSP(l, p));\n        }\n        if (ok)\n          ans = max(ans, mi);\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n \n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n  \nusing namespace std;\n  \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n  \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n  \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n  \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n  \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n};\n  \n#define Line pair<point,point>\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n  \ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n  \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n \npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n \npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n  \n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n  \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n \n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n  \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n  \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n  \n    return make_pair(a_,b_);\n}\n \nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n \nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n   \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n \ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=50;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n \nint main(void){\n \n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\ntypedef complex<double> P;\n\ndouble cross(P va, P vb){\n\treturn real(va) * imag(vb) - imag(va) * real(vb);\n}\n\ndouble distanceLP(P a, P b, P c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nP crosspoint(P pa1, P pa2, P pb1, P pb2){\n\tP da12 = pa2 - pa1;\n\tP db21 = pb1 - pb2;\n\tP dab1 = pb1 - pa1;\n\tdouble d = cross(da12, db21);\n\tif(abs(d) > EPS){\n\t\tdouble t = cross(dab1, db21) / d;\n\t\treturn pa1 + t * da12;\n\t}\n\treturn P(DBL_MAX, DBL_MAX);\n}\n\nint main(){\n\tint n;\n\tP pts[110];\n\tdouble x, y;\n\twhile(scanf(\"%d\", &n), n){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%lf%lf\", &x, &y);\n\t\t\tpts[i] = P(x, y);\n\t\t}\n\t\tpts[n] = pts[0];\n\t\t\n\t\tdouble ans = 0.0;\n\t\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = i + 1; j < n; ++j)\n\t\tfor(int k = j + 1; k < n; ++k){\n\t\t\tint e0 = i, e1 = j, e2 = k;\n\n\t\t\tif(abs(cross(pts[i + 1] - pts[i], pts[j + 1] - pts[j])) < EPS){\n\t\t\t\te0 = j;\n\t\t\t\te1 = k;\n\t\t\t\te2 = i;\n\t\t\t}\n\t\t\telse if(abs(cross(pts[j + 1] - pts[j], pts[k + 1] - pts[k])) < EPS){\n\t\t\t\te0 = k;\n\t\t\t\te1 = i;\n\t\t\t\te2 = j;\n\t\t\t}\n\n\t\t\tP tmp[4];\n\t\t\ttmp[0] = pts[e0];\n\t\t\ttmp[1] = crosspoint(pts[e0], pts[e0 + 1], pts[e1], pts[e1 + 1]);\n\t\t\ttmp[2] = crosspoint(pts[e1], pts[e1 + 1], pts[e2], pts[e2 + 1]);\n\t\t\ttmp[3] = pts[e2 + 1];\n\t\t\tdouble a1 = 0.5 * (arg(tmp[2] - tmp[1]) + arg(tmp[0] - tmp[1]));\n\t\t\tdouble a2 = 0.5 * (arg(tmp[3] - tmp[2]) + arg(tmp[1] - tmp[2]));\n\t\t\tP c = crosspoint(tmp[1], tmp[1] + polar(1.0, a1), tmp[2], tmp[2] + polar(1.0, a2));\n\t\t\tif(real(c) == DBL_MAX){ continue; }\n\t\t\tdouble d = distanceLP(pts[j], pts[j + 1], c);\n\t\t\tif(d <= ans){ continue; }\n\t\t\tbool ok = true;\n\t\t\tfor(int h = 0; h < n && ok; ++h){\n\t\t\t\tif(distanceLP(pts[h], pts[h + 1], c) < d - EPS){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t\tif(cross(pts[h + 1] - pts[h], c - pts[h]) < -EPS){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tans = d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<stdlib.h>\n\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n  \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n   \n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator<(const Point &p) const{\n    return x!=p.x? x< p.x : y < p.y;\n  }\n \n  bool operator==(const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS ;\n  }\n};\n \ntypedef Point Vector;\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\ntypedef vector<Point> Polygon;\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \nVector half(Vector a,Vector b){\n  return (a*b.abs()+b*a.abs())*1000;\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\nint contains(Polygon g, Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n  }\n  return (x?2:0);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nPolygon convex_cut(Polygon P,Line l) {\n  Polygon Q;\n  for (int i = 0; i < P.size(); ++i) {\n    Point A = curr(P, i), B = next(P, i);\n    if (ccw(l.p1, l.p2, A) != -1) Q.push_back(A);\n    if (ccw(l.p1, l.p2, A)*ccw(l.p1, l.p2, B) < 0)\n      Q.push_back(getCrossPoint(Line(A, B), l));\n  }\n  return Q;\n}\n\nVector housen(Vector v){\n  Vector r;\n  r.x=-v.y;\n  r.y=v.x;\n  return r;\n}\n\nLine slide(Line l, Vector a){\n  return Line(l.p1+a,l.p2+a);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p;\n    p.clear();\n    double x,y;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf %lf\",&x,&y);\n      p.push_back(Point(x,y));\n    }\n \n    double ans=0,l=0,r=10000,mid;\n     \n    Point g1,g2;\n\n    \n    for(int i=0;i<10000;i++){\n      if(equals(l,r)) break;\n      mid=(l+r)/2;\n      Polygon q(p);\n      for(int j=0;j<n;j++){\n\tLine l=Line(p[j],p[(j+1)%n]);\n\tVector a = housen(p[(j+1)%n]-p[j]);\n\ta=(a/a.abs())*mid;\n\tq=convex_cut(q,slide(l,a));\n      }\n      if(q.empty()) r=mid;\n      else l=mid;\n    }\n   \n    printf(\"%.6lf\\n\",l);\n  }\n   \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tvector<vector<Line>>bis(n, vector<Line>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (isis_ll(lines[i], lines[j])) {\n\t\t\t\t\t\tbis[i][j] = bisection(lines[i], lines[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tint a = perm[0], b = perm[1], c = perm[2];\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t\tswap(a, c);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tnlines.emplace_back(bis[a][b]);\n\t\t\tnlines.emplace_back(bis[a][c]);\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (convex_contains(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t\tif (mindis < maxdis)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-5;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(area(U)>0.0)return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        //for(int i=4990;i<=5010;i++)cout<<i<<' '<<check(v,(double)i-EPS)<<endl;\n        D l=0,r=100000;\n        rep(c,200){\n            D mid=(l+r)/2;\n            mid+=EPS;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.6f\\n\",(l+r)/2);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n \n};\n \n#define Line pair<point,point>\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n \n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n\n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n \n    return make_pair(a_,b_);\n}\n\nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n\nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n  \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n\ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=86;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-14; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(det(l.s,l.t,a)>=0) reg(res,a);\n\t\tif(det(l.s,l.t,a)*det(l.s,l.t,b)<0) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\nbool check(VP pol,R len){\n\tint n=pol.size();\n\tVL lines(n);\n\n\trep(i,n){\n\t\tP e=(pol[(i+1)%n]-pol[i])/abs(pol[(i+1)%n]-pol[i])*P(0,1);\n\t\tlines[i]=L({pol[i]+e*len,pol[(i+1)%n]+e*len});\n\t}\n\n\tVP cur=pol;\n\trep(i,n) cur=convex_cut(cur,lines[i]);\n\treturn sgn(area(cur));\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol(n);\n\t\trep(i,n) cin >> pol[i];\n\n\t\tR lb=0.0,ub=20000.0;\n\n\t\trep(loop,200){\n\t\t\tconst R mid=(lb+ub)/2.0;\n\t\t\tif(check(pol,mid))\n\t\t\t\tlb=mid;\n\t\t\telse\n\t\t\t\tub=mid;\n\t\t}\n\n\t\tcout.precision(20);\n\t\tcout << fixed << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <array>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\nstruct point {\n\tdouble x, y;\n\tpoint(double x_, double y_):x(x_), y(y_){};\n\tpoint(const point &p):x(p.x), y(p.y){}\n\tpoint():x(0), y(0){}\n\tpoint& operator+=(point a){x += a.x;y += a.y;return *this;}\n\tpoint& operator-=(point a){x -= a.x;y -= a.y;return *this;}\n\tpoint& operator*=(point a){\n\t\tdouble xx = x * a.x - y * a.y;\n\t\tdouble yy = x * a.y + y * a.x;\n\t\tx = xx;y = yy;return *this;\n\t}\n\tpoint& operator*=(double a){x *= a;y *= a;return *this;}\n\tpoint& operator/=(double a){x /= a;y /= a;return *this;}\n\tpoint operator+(point a) const{return point(x, y)+=a;}\n\tpoint operator-(point a) const{return point(x, y)-=a;}\n\tpoint operator*(point a) const{return point(x, y)*=a;}\n\tpoint operator*(double a) const{return point(x, y)*=a;}\n\tpoint operator/(double a) const{return point(x, y)/=a;}\n\tbool operator<(point a) const{return (x == a.x ? x < a.x : y < a.y);}\n\tbool operator==(point a) const{return (abs(x - a.x) < EPS && abs(y - a.y) < EPS);}\n\tbool operator!=(point a) const{return !(*this == a);}\n\tdouble real() {return x;}\n\tdouble imag() {return y;}\n};\n\ntemplate <class T>\npoint operator*(const T a, const point p){return point(p.x * a, p.y * a);}\n\npoint conj(point p) {return point(p.x, -p.y);}\ndouble arg(point p) {return arg(complex<double>(p.x, p.y));}\ndouble abs(point p) {return abs(complex<double>(p.x, p.y));}\ndouble norm(point p) {return norm(complex<double>(p.x, p.y));}\ndouble real(point p) {return p.x;}\ndouble imag(point p) {return p.y;}\n\nnamespace std {\n\tistream& operator>>(std::istream& is, point& p){\n\t\tis >> p.x >> p.y;\n    return is;\n}\n\tostream& operator<<(ostream& os, const point& p){\n\t\tos << p.x << \" \" << p.y;\n\t\treturn os;\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public array<point, 2> {\n\tsegment(const point &a, const point &b) {\n\t\tat(0) = a;\n\t\tat(1) = b;\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn (conj(a)*b).y;\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn (conj(a)*b).x;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.x * cos(rad) - p.y * sin(rad);\n\tdouble y = p.y * cos(rad) + p.x * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (d.y < c.y) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (c.y <= m.y && m.y < d.y)  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tif(ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]) == -1)return false;\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (pt[i].y > pt[is].y) is = i;\n    if (pt[i].y < pt[js].y) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\npoint max_circle_size_in_polygon_check(double mid, vector<point> &v){\n\tll n = v.size();\n\tvector<point> now(v);\n\tREP(i, n){\n\t\tauto a = v[i];\n\t\tauto b = v[(i+1)%n];\n\t\tauto vec = b - a;\n\t\tvec /= abs(vec);\n\t\tvec *= mid;\n\t\tvec = vec * point(0, 1);\n\t\tsegment seg = segment(a + vec, b + vec);\n\t\tnow = convex_cut(now, seg);\n\t}\n\treturn (now.empty() ? point(INF, INF): now[0]);\n}\n\n// 凸多角形に入る最大の円\ncircle max_circle_size_in_polygon(vector<point> &v){\n\tdouble l = 0;\n\tdouble r = convex_diameter(v);\n\tpoint ret;\n\tREP(_, 1000){\n\t\tif(abs(l - r) < EPS)break;\n\t\tdouble mid = (l + r) / 2;\n\t\tret = max_circle_size_in_polygon_check(mid, v);\n\t\tif(ret != point(INF, INF))l = mid;\n\t\telse r = mid;\n\t}\n\treturn circle(ret, l);\n}\n\n//　三角形の外接円\ncircle circumscribed_circle(vector<point> p) {\n\tsegment seg_a = segment((p[1] + p[0]) * 0.5,\n\t(p[1] + p[0]) * 0.5 + (p[1] - p[0]) * point(0, 1));\n\tsegment seg_b = segment((p[2] + p[1]) * 0.5,\n\t(p[2] + p[1]) * 0.5 + (p[2] - p[1]) * point(0, 1));\n\tcircle ret;\n\tret.p = crosspointSS(seg_a, seg_b);\n\tret.r = distancePP(p[0], ret.p);\n\treturn ret;\n}\n\n// ################################### 3D ####################################\n\nstruct point3d {\n\tdouble x, y, z;\n\tpoint3d(double x_, double y_, double z_):x(x_), y(y_), z(z_){}\n\n\tpoint3d& operator+=(point3d a){x += a.x;y += a.y;z += a.z;return *this;}\n\tpoint3d& operator-=(point3d a){x -= a.x;y -= a.y;z -= a.z;return *this;}\n\tpoint3d& operator*=(double a){x *= a;y *= a;z *= a;return *this;}\n\tpoint3d& operator/=(double a){x /= a;y /= a;z /= a;return *this;}\n\tpoint3d operator+(point3d a) const{return point3d(x, y, z)+=a;}\n\tpoint3d operator-(point3d a) const{return point3d(x, y, z)-=a;}\n\tpoint3d operator*(double a) const{return point3d(x, y, z)*=a;}\n\tpoint3d operator/(double a) const{return point3d(x, y, z)/=a;}\n\tbool operator<(point3d a) const{\n\t\treturn (x == a.x ? x < a.x : (y == a.y ? y < a.y : z < a.z));}\n\tbool operator==(point3d a) const{\n\t\treturn (abs(x - a.x) < EPS && abs(y - a.y) < EPS && abs(z - a.z) < EPS);\n\t}\n\tbool operator!=(point3d a) const{return !(*this == a);}\n\n};\n\ndouble abs(point3d p) {\n\treturn sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n}\n\ndouble dot(point3d a, point3d b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\npoint3d cross(point3d a, point3d b){\n\treturn point3d(a.y * b.z - a.z * b.y,\n\t\t\t\t\t\t\t\t a.z * b.x - a.x * b.z,\n\t\t\t\t\t\t\t   a.x * b.y - a.y * b.x);\n}\n\nstruct plane {\n\tdouble a, b, c, d;\n\tplane(double a_, double b_, double c_, double d_):a(a_), b(b_), c(c_), d(d_){}\n\tplane(point3d p1, point3d p2, point3d p3){\n\t\tpoint3d A = p2 - p1;\n\t\tpoint3d B = p3 - p1;\n\t\tpoint3d p = cross(A, B);\n\t\ta = p.x;b = p.y;c = p.z;\n\t\td = -(a * p1.x + b * p1.y + c * p1.z);\n\t}\n};\n\ndouble distance(point3d p, plane pl){\n\tdouble a = abs(p.x * pl.a + p.y * pl.b + p.z * pl.c + pl.d);\n\tdouble b = sqrt(pl.a * pl.a + pl.b * pl.b + pl.c * pl.c);\n\treturn a / b;\n}\n\ndouble distance(plane p, point3d pl){\n\treturn distance(pl, p);\n}\n\npoint3d projection(point3d p, plane pl){\n\tdouble d = distance(p, pl);\n\tpoint3d a = point3d(pl.a, pl.b, pl.c);a /= abs(a);\n\tpoint3d ret = p + a * d;\n\tif(distance(ret, pl) < EPS)return ret;\n\treturn p - a * d;\n}\n\nnamespace std {\n\tostream& operator<<(ostream& os, const point3d& p){\n\t\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\t\treturn os;\n\t}\n\n\tostream& operator<<(ostream& os, const plane& p){\n\t\tos << p.a << \"x + \" << p.b << \"y + \" << p.c << \"z + \" << p.d;\n\t\treturn os;\n\t}\n}\n\n// ################################### 3D ####################################\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n;\n\twhile(cin >> n, n){\n\t\tvector<point> v;\n\t\tREP(i, n){\n\t\t\tll x, y;cin >> x >> y;\n\t\t\tv.EB(x, y);\n\t\t}\n\t\tcout <<  Decimal << max_circle_size_in_polygon(v).r << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint sign(double x){\n    if(x > EPS) return 1;\n    if(x < -EPS) return -1;\n    return 0;\n}\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nstruct Line : public vector<Point> {\n    Line(const Point& a, const Point& b) {\n        push_back(a); push_back(b);\n    }\n    Point vector() const {\n        return back() - front();\n    }\n};\ndouble dot(Point a, Point b){\n    return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n    return imag(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS)   return +1; // 反時計回り\n    if (cross(b, c) < -EPS)   return -1; // 時計回り\n    if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n    if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n    return 0;                         // 点が線分ab上にある\n}\nPoint crosspointLL(Line l, Line m){\n    double A = cross(l.vector(), m.vector());\n    double B = cross(l.vector(), l[1] - m[0]);\n    if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n    if(sign(A) == 0) assert(false); // 直線が交わらない\n    return m[0] + m.vector() * B / A;\n}\n\ninline Point curr(const Polygon& P, int k){ return P[k]; }\ninline Point next(const Polygon& P, int k){ return P[(k + 1) % P.size()]; }\nPolygon convex_cut(const Polygon& P, Line l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\n\nPoint rotate(Point a, double b){\n    return a * polar(1.0, b);\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        Polygon P;\n        REP(i, N){\n            double x, y;\n            cin >> x >> y;\n            P.push_back(Point(x, y));\n        }\n        double lb = 0, ub = 100000;\n        REP(iter, 100){\n            double len = (lb + ub) / 2;\n            Polygon Q = P;\n            REP(i, N){\n                Line l(curr(P, i), next(P, i));\n                Line l2(l[0] + polar(len, arg(l.vector()) + M_PI/2), l[1] + polar(len, arg(l.vector()) + M_PI/2));\n                Q = convex_cut(Q, l2);\n            }\n            if(Q.empty()){\n                ub = len;\n            }else{\n                lb = len;\n            }\n        }\n        printf(\"%.12f\\n\", lb);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\nstruct line : public vector<point> {\n\tline(point a, point b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n\tbool operator<(const point& a, const point& b) {\n\t\treturn a.real()!=b.real() ? a.real()<b.real() : a.imag()<b.imag();\n\t}\n}\n\nconst double eps = 1e-10;\nbool   equal(const double a, const double b) { return abs(a-b)<eps; }\nbool   equal(const point& a, const point& b) { return abs(a-b)<eps; }\ndouble dot  (const point& a, const point& b) { return (a*conj(b)).real(); }\ndouble cross(const point& a, const point& b) { return (conj(a)*b).imag(); }\npoint  vec  (const line&  l)                 { return l[1]-l[0]; }\npoint  unit (const point& v)                 { return v/abs(v);  }\npoint  ortho(const point& v)                 { return v*point(0,1); }\n\nint ccw(const point& a, const point& b, const point& c) {\n\tpoint u=b-a, v=c-a;\n\tif(cross(u,v) > 0 ) return +1; // ccw\n\tif(cross(u,v) < 0 ) return -1; // cw\n\tif(  dot(u,v) < 0 ) return +2; // cab\n\tif(norm(u)<norm(v)) return -2; // abc\n\treturn 0;                      // acb\n}\n\nint ccw(const line& s, const point& p) {\n\treturn ccw(s[0], s[1], p);\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(vec(l), vec(m));\n\tdouble B = cross(vec(l), l[1]-m[0]);\n\tif(abs(A)<eps) {\t\t\t// parallel\n\t\tassert(abs(B)<eps);\n\t\treturn m[0];\t\t\t// sameline\n\t}\n\treturn m[0] + B/A*vec(m);\n}\n\npolygon convex_cut(const polygon& g, const line& l, int f=0) {\n\tpolygon h;\n\tline m(l[f%2], l[(f+1)%2]);\n\n\tfor(int i=0; i<g.size(); i++) {\n\t\tconst point& a = g[i];\n\t\tconst point& b = g[(i+1)%g.size()];\n\t\tif(ccw(m,a) != -1) h.push_back(a);\n\t\tif(ccw(m,a)*ccw(m,b) < 0) {\n\t\t\tpoint p = crosspoint(line(a,b), m);\n\t\t\tif((!equal(a,p)) && (!equal(b,p))) {\n\t\t\t\th.push_back(p);\n\t\t\t}\n\t\t}\n\t}\n\treturn h;\n}\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N) {\n\t\tpolygon g;\n\t\twhile(N--) {\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tg.push_back(point(x,y));\n\t\t}\n\n\t\tdouble low=0,high=5000;\n\t\twhile(high-low > 1e-6)\n\t\t{\n\t\t\tpolygon h;\n\t\t\th.push_back(point(    0,    0));\n\t\t\th.push_back(point(10000,    0));\n\t\t\th.push_back(point(10000,10000));\n\t\t\th.push_back(point(    0,10000));\n\n\t\t\tdouble d = (low+high)/2.0;\n\n\t\t\tfor(int i=0; i<g.size(); i++) {\n\t\t\t\tpoint& a = g[i];\n\t\t\t\tpoint& b = g[(i+1)%g.size()];\n\t\t\t\tpoint  v = unit(ortho(b-a));\n\n\t\t\t\th = convex_cut(h, line(a+d*v, b+d*v));\n\t\t\t}\n\n\t\t\tif(h.size()) low  = d;\n\t\t\telse         high = d;\n\t\t}\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(6);\n\t\tcout << (low+high)/2.0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define REP(i, n) for (int i(0); i < (int) (n); i++)\n\nconst int N = 100 + 10;\nconst long double EPS = 1e-8;\n\nint sign(long double x)\n{\n\treturn x < -EPS ? -1 : x > EPS;\n}\n\nstruct Point\n{\n\tlong double x, y;\n\tPoint() {}\n\tPoint(long double x, long double y) : x(x), y(y) {}\n\tPoint operator + (const Point &that) const {\n\t\treturn Point(x + that.x, y + that.y);\n\t}\n\tPoint operator - (const Point &that) const {\n\t\treturn Point(x - that.x, y - that.y);\n\t}\n\tPoint operator * (const long double &that) const {\n\t\treturn Point(x * that, y * that);\n\t}\n\tPoint operator / (const long double &that) const {\n\t\treturn Point(x / that, y / that);\n\t}\n\tPoint rot90() const {\n\t\treturn Point(-y, x);\n\t}\n\tPoint unit() const {\n\t\treturn *this / hypot(x, y);\n\t}\n\tvoid read() {\n\t\tdouble dx, dy;\n\t\tscanf(\"%lf%lf\", &dx, &dy);\n\t\tx = dx; y = dy;\n\t} \n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nint n;\nPoint a[N];\n\nPoint isSS(Point p1, Point p2, Point q1, Point q2)\n{\n\tlong double a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nvector<Point> convexCut(vector<Point> ps, Point q1, Point q2)\n{\n\tvector<Point> qs;\n\tint n = ps.size();\n\tfor(int i = 0; i < n; ++ i) {\n\t\tPoint p1 = ps[i], p2 = ps[(i + 1) % n];\n\t\tint d1 = crossOp(q1, q2, p1), d2 = crossOp(q1, q2, p2);\n\t\tif (d1 >= 0)\n\t\t\tqs.push_back(p1);\n\t\tif(d1 * d2 < 0)\n\t\t\tqs.push_back(isSS(p1, p2, q1, q2));\n\t}\n\treturn qs;\n}\n\nvoid solve() {\n\tfor(int i = 0; i < n; ++ i) {\n\t\ta[i].read();\n\t}\n\n\tlong double l = 0, r = 5001, mid;\n\tfor(int i = 0; i < 50; ++ i) {\n\t\tmid = (l + r) * 0.5;\n\t\tvector<Point> vec;\n\t\tvec.push_back(Point(0, 0));\n\t\tvec.push_back(Point(0, 10000));\n\t\tvec.push_back(Point(10000, 10000));\n\t\tvec.push_back(Point(10000, 0));\n\t\tfor(int j = 0; j < n; ++ j) {\n\t\t\tPoint u = a[j], v = a[(j + 1) % n];\n\t\t\tPoint d = (v - u).rot90().unit() * mid;\n\t\t\tu = u + d;\n\t\t\tv = v + d;\n\t\t\tvec = convexCut(vec, u, v);\n\t\t\tif (vec.size() <= 2) break;\n\t\t}\n\t\tif (vec.size() <= 2) {\n\t\t\tr = mid;\n\t\t} else {\n\t\t\tl = mid;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", (double)l);\n}\n\nint main() {\n\tfor( ; cin >> n && n; ) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& l, Line const& m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) { return m[0]; } // same line\n  if(abs(A) < EPS) { return P(inf, inf); }\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0) {\n      P r = crosspoint(ab, l);\n      if(r == P(inf, inf)) { continue; }\n      left_part.push_back(r);\n    }\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  /*\n    Polygon A;\n    A.push_back(P(inf,inf)); A.push_back(P(-inf,inf));\n    A.push_back(P(-inf,-inf)); A.push_back(P(inf,-inf));\n  */\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<stdlib.h>\n\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n  \n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n   \n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n \n  bool operator<(const Point &p) const{\n    return x!=p.x? x< p.x : y < p.y;\n  }\n \n  bool operator==(const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS ;\n  }\n};\n \ntypedef Point Vector;\ndouble norm(Vector a){return a.x*a.x+a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\ntypedef vector<Point> Polygon;\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n \nVector half(Vector a,Vector b){\n  return (a*b.abs()+b*a.abs())*1000;\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\nint contains(Polygon g, Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n  }\n  return (x?2:0);\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nPolygon convex_cut(Polygon P,Line l) {\n  Polygon Q;\n  for (int i = 0; i < P.size(); ++i) {\n    Point A = curr(P, i), B = next(P, i);\n    if (ccw(l.p1, l.p2, A) != -1) Q.push_back(A);\n    if (ccw(l.p1, l.p2, A)*ccw(l.p1, l.p2, B) < 0)\n      Q.push_back(getCrossPoint(Line(A, B), l));\n  }\n  return Q;\n}\n\nVector housen(Vector v){\n  Vector r;\n  r.x=-v.y;\n  r.y=v.x;\n  return r;\n}\n\nLine slide(Line l, Vector a){\n  return Line(l.p1+a,l.p2+a);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p;\n    p.clear();\n    double x,y;\n    for(int i=0;i<n;i++){\n      scanf(\"%lf %lf\",&x,&y);\n      p.push_back(Point(x,y));\n    }\n \n    double ans=0,l=0,r=10000,mid;\n     \n    Point g1,g2;\n\n    \n    for(int i=0;i<10000;i++){\n      if(equals(l,r)) break;\n      mid=(l+r)/2;\n      Polygon q(p);\n      for(int j=0;j<n;j++){\n\tLine l=Line(p[j],p[(j+1)%n]);\n\tVector a = housen(p[(j+1)%n]-p[j]);\n\ta=(a/a.abs())*mid;\n\tq=convex_cut(q,slide(l,a));\n      }\n      if(q.empty()) r=mid;\n      else l=mid;\n    }\n   \n    printf(\"%.6lf\\n\",l);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\nlong double distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\nlong double distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\nlong double distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\nlong double distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\npoint intersection_l(const point& a1,const point& a2,const point& b1,const point& b2) {\n  const point& a=a2-a1,b=b2-b1;\n  return a1+a*cross(b, b1-a1)/cross(b, a);\n}\npoint intersection_l(const line& l,const line& m){\n    return intersection_l(l.first,l.second,m.first,m.second);\n}\n// ????§???¢????¬?????????¢???\nlong double area(const vector<point>& pol){\n    long double s=0;\n    rep(i,0,pol.size()) s+=cross(pol[i],pol[(i+1)%pol.size()]);\n    return s/2;\n}\n\n//??´??????????????????????????????????±???????\nline get_unit_normalV(const point &a,const point &b){\n    line l;\n    l.first=((b-a)*point(0,1))/abs(b-a);\n    l.second=((b-a)*point(0,-1))/abs(b-a);\n    return l;\n}\n\n//??????s????????¢d?????????????§????\npair<line,line> get_translation(const line &s,long double d){\n    line v = get_unit_normalV(s.first,s.second);\n    pair<line,line> res;\n    res.first=line(s.first+v.first*d,s.second+v.first*d);\n    res.second=line(s.first+v.second*d,s.second+v.second*d);\n    return res;\n}\n\nvector<point> convex_cut(const vector<point>& ps, const line& l) {\n    vector<point> res;\n    for (int i = 0; i < ps.size(); ++i) {\n        point a = ps[i], b = ps[(i+1)%ps.size()];\n        if (ccw(l.first, l.second, a) != -1) res.push_back(a);\n        if (ccw(l.first, l.second, a)*ccw(l.first, l.second, b) < 0) res.push_back(intersection_l(line(a, b), l));\n    }\n    return res;\n}\n\nvoid solve(int n){\n    vector<point> ps;\n    rep(i,0,n){\n        long double x,y;\n        cin >> x >> y;\n        ps.push_back(point(x,y));\n    }\n    ps.push_back(ps[0]);\n    vector<line> ls;\n    rep(i,0,n) ls.push_back(line(ps[i],ps[i+1]));\n\n    auto ok=[&](long double k){\n        vector<point> pol;\n        rep(i,0,n) pol.push_back(ps[i]);\n        rep(i,0,n){\n            auto tl=get_translation(ls[i],k);\n            if(ccw(ps[i],ps[i+1],tl.first.first)==1) pol=convex_cut(pol,tl.first);\n            else pol=convex_cut(pol,tl.second);\n        }\n        return pol.size()>0;\n    };\n\n    long double lb=0,ub=inf;\n    rep(i,0,64){\n        long double m=(lb+ub)/2;\n        if(ok(m)) lb=m;\n        else ub=m;\n    }\n    cout << lb << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tvector<vector<Line>>bis(n, vector<Line>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (isis_ll(lines[i], lines[j])) {\n\t\t\t\t\t\tbis[i][j] = bisection(lines[i], lines[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tint a = perm[0], b = perm[1], c = perm[2];\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t\tswap(a, c);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tnlines.emplace_back(bis[a][b]);\n\t\t\tnlines.emplace_back(bis[a][c]);\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t\tif (mindis < maxdis)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout <<fixed<< setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n};\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ntypedef vector<point> polygon;\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\nbool intersect(const segment &s, const point &p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint crosspoint(const segment &s, const segment &t) {\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\treturn t.a + (t.b - t.a) * (cross(s.b - s.a, s.b - t.a) / tmp);\n}\n\ndouble dist(const segment &s, const point &p) {\n\tif(dot(s.b - s.a, p - s.a) < 0) return abs(p - s.a);\n\tif(dot(s.a - s.b, p - s.b) < 0) return abs(p - s.b);\n\treturn abs(cross(s.b - s.a, p - s.a)) / abs(s.b - s.a);\n}\n\nbool contain(const polygon &P, const point &p) {\n\tbool res = false;\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tpoint v1 = prev - p, v2 = curr - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n\t\tif(abs(cross(v1, v2)) < EPS  && dot(v1, v2) < EPS) return true;\n\t\tprev = curr;\n\t}\n\treturn res;\n}\n\ndouble dist(const polygon &P, const point &p) {\n\tdouble res = INT_MAX;\n\tpoint prev = P.back();\n\n\tfor(const auto &curr : P) {\n\t\tchmin(res, dist(segment(curr, prev), p));\n\t\tprev = curr;\n\t}\n\n\treturn res;\n}\n\ndouble ternary_search(double L, double R, const function<double(double)> &f) {\n\tfor(int i = 0; i < 80; ++i) {\n\t\tdouble x1 = (L + L + R) / 3.0, x2 = (L + R + R) / 3.0;\n\t\tif(f(x1) < f(x2)) {\n\t\t\tL = x1;\n\t\t}\n\t\telse {\n\t\t\tR = x2;\n\t\t}\n\t}\n\treturn f(L);\n}\n\ndouble search_y(double x, const polygon &P) {\n\tconst segment L(point(x, 0), point(x, 10000));\n\tvector<double> range;\n\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tconst segment s(prev, curr);\n\t\tif(intersect(L, s)) range.emplace_back(crosspoint(L, s).y);\n\t\tprev = curr;\n\t}\n\n\tsort(range.begin(), range.end());\n\trange.erase(unique(range.begin(), range.end()), range.end());\n\n\tif(range.size() == 0) return -1;\n\treturn ternary_search(range.front(), range.back(), [&](double y){ return dist(P, point(x, y)); });\n}\n\ndouble search_x(const polygon &P) {\n\treturn ternary_search(0, 10000, [&](double x){ return search_y(x, P); });\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(6);\n\n\tfor(int n; cin >> n && n;) {\n\t\tpolygon P(n);\n\t\tfor(auto &e : P) cin >> e.x >> e.y;\n\t\tcout << search_x(P) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定(平行でない)\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    Polygon P(N);\n    REP(i, N) cin>>P[i];\n    double lb = 0, ub = 1e6;\n    REP(iter, 50){\n      double mid = (lb + ub) / 2;\n      Polygon Q = P;\n      //cout<<\"mid is \"<<mid<<endl;\n      REP(i, N){\n        Line l(curr(P, i), next(P, i));\n        //cout<<\"l is \"<<l[0]<<\" \"<<l[1]<<endl;\n        Point u = l.vector().rotate90() / l.vector().abs();\n        Line m(l[0] + u * mid, l[1] + u * mid);\n        //cout<<\"m is \"<<m[0]<<\" \"<<m[1]<<endl;\n        Q = convex_cut(Q, m);\n        if(Q.empty()) break;\n        //cout<<\"Q is \"; REP(i, Q.size()) cout<<Q[i]<<\" \"; cout<<endl;\n      }\n      if(Q.empty()){\n        ub = mid;\n      }else{\n        lb = mid;\n      }\n    }\n    printf(\"%.6lf\\n\", ub);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < EPS) return 2;\n  if(abs(b) + EPS < abs(c)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble area(Poly p){\n  int n = p.size();\n  double s = 0;\n  for(int i = 1; i < n-1; ++i){\n    s += cross(p[i]-p[0],p[i+1]-p[0])/2;\n  }\n  return s;\n}\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//辺上\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//内部\n  return 0;//外部\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角 abc の二等分線\n  //a, b or b, c が一致するとゼロ徐算が発生し RE になる\n  P p = b + (a-b)/abs(a-b)*100.0 + (c-b)/abs(c-b)*100.0;\n  return L(b,p);\n}\n\ndouble solve(Poly p){\n  int n = p.size();\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < i; ++j){\n      for(int k = 0; k < j; ++k){\n        L a(p[i],p[(i+1)%n]), b(p[j],p[(j+1)%n]), c(p[k],p[(k+1)%n]), l1, l2;\n        P a_ = a.second - a.first, b_ = b.second - b.first, c_ = c.second - c.first;\n        if(abs(cross(a_, b_)) < EPS) l1 = L((a.first + b.first)/2.0, (a.first + b.first)/2.0 + a_);\n        else{\n          P t = intersection(a,b);\n          l1 = angle_bisector(t + a_, t, t - b_);\n        }\n        if(abs(cross(b_, c_)) < EPS) l2 = L((b.first + c.first)/2.0, (b.first + c.first)/2.0 + b_);\n        else{\n          P t = intersection(b,c);\n          l2 = angle_bisector(t + b_, t, t - c_);\n        }\n        if(abs(cross(l1.second - l1.first, l2.second - l2.first)) > EPS){\n          P x = intersection(l1, l2);\n          if(in_poly(x, p)){\n            cp.push_back(x);\n          }\n        }\n      }\n    }\n  }\n\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n\nint main(){\n  int n;\n  double x, y;\n  while(cin >> n, n){\n    Poly p;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    printf(\"%.6lf\\n\",solve(p));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g = (ps[0] + ps[n/3] + ps[2*n/3]) / 3.0;\n    int a = 0, b = n;\n    while (a+1 < b) {\n        int c = (a + b) / 2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    double mx=inf,Mx=-inf;\n    double my=inf,My=-inf;\n    rep(i,n){\n        mx=min(mx,ps[i].real());\n        my=min(my,ps[i].imag());\n        Mx=max(Mx,ps[i].real());\n        My=max(My,ps[i].imag());\n    }\n    double const r[]={10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7};\n    double static d[128];\n    int near=0;\n    rep(t,90000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n)if(d[i]<d[near]){\n            near=i;\n        }\n        P h=projection(es[near],p);\n        P np=p-(h-p)/d[near]*r[t/10000];\n        if(convex_contains(np)==IN){\n            swap(p,np);\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define X real()\n#define Y imag()\n\ntypedef double D;\ntypedef complex<D> P;\n\nconst D eps=1e-9;\nconst D EPS=1e-7;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\n\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\n\nbool intersectSP(L s,P p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\n\nD distanceSP(L s,P p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\n\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint N;\nP ps[101];\n\nconst double GR=(sqrt(5.0)-1.0)/2.0;\n\ndouble f(double x,double y){\n  // actual content of func\n  P p=P(x,y);\n  double res=inf;\n  rep(i,N)minch(res,distanceSP(L(ps[i],ps[(i+1)%N]),p));\n  return res;\n}\n\ndouble yargmax(double crtx){\n  double lb=inf,ub=-inf;\n  rep(i,N){\n    D mnx=min(ps[i].X,ps[(i+1)%N].X);\n    D mxx=max(ps[i].X,ps[(i+1)%N].X);\n    if(mnx-eps<crtx&&crtx<mxx+eps){\n      if(abs(ps[i].X-ps[(i+1)%N].X)<eps){\n        minch(lb,min(ps[i].Y,ps[(i+1)%N].Y));\n        maxch(ub,max(ps[i].Y,ps[(i+1)%N].Y));\n      }else{\n        P cp=crosspoint(L(ps[i],ps[(i+1)%N]),L(P(crtx,-1000000),P(crtx,+1000000)));\n        minch(lb,cp.Y);\n        maxch(ub,cp.Y);\n      }\n    }\n  }\n  double x=ub-GR*(ub-lb),y=lb+GR*(ub-lb);\n  double vx=f(crtx,x),vy=f(crtx,y);\n  while(ub-lb>EPS){\n    if(vx<vy){\n      lb=x; x=y; vx=vy; y=lb+GR*(ub-lb); vy=f(crtx,y);\n    }else{\n      ub=y; y=x; vy=vx; x=ub-GR*(ub-lb); vx=f(crtx,x);\n    }\n  }\n  return (x+y)/2.0;\n}\n\nD xmax(D mnx,D mxx){\n  D lb=mnx,ub=mxx;\n  D x=ub-GR*(ub-lb),y=lb+GR*(ub-lb);\n  double vx=f(x,yargmax(x)),vy=f(y,yargmax(y));\n  while(ub-lb>EPS){\n    if(vx<vy){\n      lb=x; x=y; vx=vy; y=lb+GR*(ub-lb); vy=f(y,yargmax(y));\n    }else{\n      ub=y; y=x; vy=vx; x=ub-GR*(ub-lb); vx=f(x,yargmax(x));\n    }\n  }\n  return f((x+y)/2.0,yargmax((x+y)/2.0));\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    rep(i,N){\n      D x,y;\n      cin>>x>>y;\n      ps[i]=P(x,y);\n    }\n    D mnx=inf,mxx=-inf;\n    rep(i,N){\n      minch(mnx,ps[i].X); maxch(mxx,ps[i].X);\n    }\n    printf(\"%.10f\\n\", xmax(mnx,mxx));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n// gは凸多角形\n// lineより左側の凸多角形を返す\n// AOJ1213(正方形に2回カットなので緩い)\nConvex convex_cut(const Convex& g, const Line& line)\n{\n    Convex left;\n    rep(i, g.size())\n    {\n        const Point& a = g[i], b = g[(i + 1) % g.size()];\n        if (ccw(line.first, line.second, a) != clockwise)\n            left.push_back(a);\n        if (ccw(line.first, line.second, a) * ccw(line.first, line.second, b) < 0)\n            left.push_back(ip_LL(Line(a, b), line));\n    }\n    return left;\n}\nConvex convex_cut(const Convex& g, const Point& a, const Point& b)\n{\n    return convex_cut(g, Line(a, b));\n}\n\n/////////////////// \n\n\nbool ok(const Convex& g, double d)\n{\n    Convex rem = g;\n    rep(i, g.size())\n    {\n        Point v = (g[(i + 1) % g.size()] - g[i]) * Point(0, 1);\n        v *= d / abs(v);\n        rem = convex_cut(rem, g[i] + v, g[i + 1] + v);\n    }\n    return !rem.empty();\n}\nint main()\n{\n    int n;\n    while (cin >> n, n)\n    {\n        Convex g(n);\n        rep(i, n)\n            cin >> g[i];\n\n        double low = 0, high = 1e9;\n        rep(i, 100)\n        {\n            double mid = (low + high) / 2;\n            (ok(g, mid) ? low : high) = mid;\n        }\n        printf(\"%.8f\\n\", low);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      assert(abs(uva)>0&&abs(uvb)>0);\n      vec v = uvec( (uva + uvb) );\n      \n      long double r = 1e7;\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<300){\n        long double m = (r+l)/2.;\n        point c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    cout << fixed << setprecision(8) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef complex<double> point,vec;\ntypedef pair<point,point> seg,line;\nconst double eps = 1e-9;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\ndouble dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\ndouble dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\ndouble dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        line a( vp[i], vp[(i+1)%vp.size()] );\n        line b( vp[j], vp[(j-1+vp.size())%vp.size()] );\n        bool prl = prll(a,b);\n        if( prl ) continue;\n        vec uva = uvec(a.second- a.first);\n        vec uvb = uvec(b.second- b.first);\n        vec v = uvec( (uva + uvb) );\n        point cr = intersectionLL(a,b);\n        \n        double r = 1e20;\n        double l = 0;\n        int cnt = 0;\n        double radi;\n        while(cnt++<150){\n          double m = (r+l)/2.;\n          point c = m * v + cr;\n          bool ng = false;\n          \n          radi = dist_l(a,c);\n          if( !insimple(c,vp) ){\n            r = m;\n            continue;\n          }\n          \n          for(int k = 0; k < n; ++k){\n            seg s(vp[k],vp[(k+1)%vp.size()]);\n            if( radi > dist_seg(s,c)+eps ){\n              ng = true;\n              break;\n            }\n          }\n          \n          if( ng ){\n            r = m;\n          }else{\n            l = m;\n          }\n        }\n        res = max( res, radi );\n      }\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\n \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)?????????´???????????????(c-a)?????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)?????????´???????????????(c-a)?????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n \nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> res;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) res.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      res.push_back(crossPoint(L(A,B), l));\n  }\n  return res;\n}\n \nbool check(vector<P> G,double d){\n  vector<P> pol=G;\n  int n=G.size();\n  for(int i=0;i<n;i++){\n    P c=(G[(i+1)%n]-G[i]);\n    P a=P(abs(c),d)*(c/abs(c))+G[i];\n    pol=convex_cut(pol,L(a,a+c));\n    if(pol.size()<3)return 0;\n  }\n  return  1;\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> pol(n);\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,pol[i]=P(x,y);\n     \n    double L=0,M,R=1e4;\n    while(L<R){\n      M=(L+R)/2;\n      if(!check(pol,M)) R=M-EPS;\n      else L=M+EPS;\n    }\n    printf(\"%lf\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ???§ ????????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ???§ ?????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b???§??????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c???§??????´??????\n    return 0;  // a -- c -- b???§??????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  {\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  {\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  {\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nusing namespace Geometory;\n\nPolygon data;\n\nbool isable(double v)\n{\n  Polygon ret = data;\n  for(int i = 0; i < data.size(); i++) {\n    Point point = next(data, i) - curr(data, i);\n    point = (point * v / point.abs()).rotate(PI / 2);\n    ret = Convex_Cut(ret, Line(curr(data, i) + point, next(data, i) + point));\n  }\n  return (!ret.empty());\n}\n\nint main()\n{\n  int N;\n  cout << fixed << setprecision(10);\n  while(cin >> N, N) {\n    data.resize(N);\n    for(int i = 0; i < N; i++) cin >> data[i];\n    double low = 0, high = 1e4;\n    for(int i = 0; i < 40; i++) {\n      double mid = (low + high) * 0.5;\n      if(isable(mid)) low = mid;\n      else high = mid;\n    }\n    cout << low << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n\ntypedef double FP;\n\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.second-a.first);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.first,a.second,b.first,b.second);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.first,a.second,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\n\nvoid check(P a){\n\n  // assert(!isnan(a.real()));\n  // assert(!isnan(a.imag()));\n}\n\nvoid check(line a){\n  check(a.first);\n  check(a.second);  \n}\n\nbool para(line a, line b){\n  P av = a.first - a.second;\n  P bv = b.first - b.second;\n  return abs(dot(av/abs(av),bv/abs(bv))) > 1 - 1e-9;\n}\n\ndouble tri(P a, P b, P c){\n  a -= c;\n  b -= c;\n  return abs(crs(a,b));\n}\n\nline midline(line a,line b){\n  if(!para(a,b)){\n    P av = a.second - a.first;\n    P bv = b.second - b.first;\n    av /= abs(av);\n    bv /= abs(bv);\n    auto ret = line(crspt(a,b),crspt(a,b)+av+bv);\n    check(ret);\n    return ret;\n  }\n  P st =(a.first+b.first)/2.;\n  auto ret = line(st, st + a.second - a.first);\n  check(ret);\n  return ret;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n && n){\n    int x[n], y[n];\n    for(int i = 0; i < n; ++i)\n      cin >> x[i] >> y[i];\n    double cx = accumulate(x,x+n,0.)/n;\n    double cy = accumulate(y,y+n,0.)/n;\n      \n    double ans = 0;\n    for(int i = 0; i < n; ++i){\n      \n      for(int j = 0; j < i; ++j){\n        if(i == j) continue;\n        double r = 10000000000;\n        for(int k = 0; k < n; ++k){\n          if(i == k || j == k) continue;\n          line il = line(P(x[i],y[i]), P(x[(i+1)%n],y[(i+1)%n]));\n          line jl = line(P(x[(j+1)%n],y[(j+1)%n]), P(x[j],y[j]));\n          line kl = line(P(x[(k+1)%n],y[(k+1)%n]), P(x[k],y[k]));\n          line ij = midline(il, jl);\n          line ik = midline(il, kl);\n          // if(!iscrs(ij, ik)){\n          //   cout << ij << \"  \" << ik << endl;\n          //   continue;\n          // }\n          P ce = crspt(ij,ik);\n          if(!isnormal(ce.real()) || !isnormal(ce.imag())){\n            //cout << ce << endl;\n            continue;\n          }\n          double me = 0;\n          double me2 = 0;\n          for(int ii = 0; ii < n; ++ii){\n            me += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),ce);\n            me2 += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),P(cx,cy));\n          }\n          \n          if(abs(me-me2)/max(me,me2) > EPS){\n            //cout << me << \" \" << me2 << endl;\n            continue;\n          }\n          \n          double tr = 10000000000;\n          for(int ii = 0; ii < n; ++ii){\n            line l(P(x[ii],y[ii]),P(x[(ii+1)%n],y[(ii+1)%n]));\n            tr = min(tr, lpdist(l,ce));\n          }\n          ans = max(tr, ans);\n          //cout << ce << endl;\n          double cr = lpdist(il,ce);\n          r = min(r, cr);\n        }\n        //ans = max(r, ans);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> res;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) res.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      res.push_back(crossPoint(L(A,B), l));\n  }\n  return res;\n}\n\nbool check(vector<P> G,double d){\n  vector<P> pol=G;\n  int n=G.size();\n  for(int i=0;i<n;i++){\n    P c=(G[(i+1)%n]-G[i]);\n    P a=P(abs(c),d)*(c/abs(c))+G[i];\n    pol=convex_cut(pol,L(a,a+c));\n    if(pol.size()<3)return 0;\n  }\n  return  1;\n}\n\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> pol(n);\n    for(int i=0,x,y;i<n;i++){\n      cin>>x>>y;\n      pol[i]=P(x,y);\n    }\n\n    double L=0,M,R=1e4;\n    while(L<R){\n      M=(L+R)/2;\n      if(!check(pol,M)) R=M-EPS;\n      else L=M+EPS;\n    }\n    printf(\"%lf\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nusing Real = double;\nconst Real EPS = 1e-8, PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n      CLOCKWISE = -1,\n      ONLINE_BACK = 2,\n      ONLINE_FRONT = -2,\n      ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n        ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n            distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\n\nusing Polygon = vector<Point>;\n\nReal area(const Polygon& U) {\n    Real area = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        area += cross(U[i], U[(i + 1) % U.size()]);\n    }\n    return area / 2.0;\n}\n\nbool is_convex(const Polygon &U) {\n    int n = U.size();\n    for (int i = 0; i < n; ++i) {\n        if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;\n    }\n    return true;\n}\n\nconst int OUT = 0,\n      ON = 1,\n      IN = 2;\nint contains(const Polygon &U, const Point &p) {\n    int in = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;\n        if (cross(a, b) == 0 and dot(a, b) <= 0) return ON;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 and 0 < b.imag() and cross(a, b) < 0) in ^= 1;\n    }\n    return in ? IN : OUT;\n}\n\nvector<Point> convex_hull(vector<Point>& p, bool includeOnLine = false) {\n    int n = p.size(), k = 0;\n    if (n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n    const Real BOUND = includeOnLine ? -EPS : EPS;\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n        while (k >= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = p[i--]) {\n        while (k >= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n\nReal convex_diameter(const Polygon &U) {\n    int n = U.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (U[i].imag() > U[is].imag()) is = i;\n        if (U[i].imag() < U[js].imag()) js = i;\n    }\n    Real maxnorm = norm(U[is] - U[js]);\n\n    int i = is, j = js;\n    do {\n        if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) >= 0) {\n            j = (j+1) % n;\n        } else {\n            i = (i+1) % n;\n        }\n        if (norm(U[i] - U[j]) > maxnorm) {\n            maxnorm = norm(U[i] - U[j]);\n        }\n    } while (i != is or j != js);\n    return sqrt(maxnorm);\n}\n\nPolygon convex_cut(const Polygon& U, const Line& l) {\n    Polygon ret;\n    for (int i = 0; i < U.size(); ++i) {\n        Point now = U[i], nxt = U[(i + 1) % U.size()];\n        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) == -1) {\n            ret.push_back(crosspoint(Line{ now, nxt }, l));\n        }\n    }\n    return ret;\n}\n\nPolygon voronoi_cell(const Point& c, const vector<Point>& ps, Polygon outer) {\n    for (const Point& p : ps) {\n        Point m = (p + c) / 2.0;\n        outer = convex_cut(outer,\n                Line{ m, m + rotate(p - c, M_PI / 2) });\n    }\n    return outer;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<Point> p(n);\n        double lb = 10000, ub = 0;\n        for (int i = 0; i < n; ++i) {\n            double x, y; cin >> x >> y;\n            p[i] = { x, y };\n            chmin(lb, y);\n            chmax(ub, y);\n        }\n        lb += EPS; ub -= EPS;\n\n        auto f = [&](double y) {\n            auto fx = [&](double x) {\n                double dist = numeric_limits<double>::max();\n                bool out = false;\n                for (int i = 0; i < n; ++i) {\n                    if (ccw(p[i], p[(i+1)%n], Point{ x, y }) == -1) {\n                        out = true;\n                    }\n                    chmin(dist, distance(\n                                Line{ p[i], p[(i+1)%n] }, Point{ x, y }));\n                }\n                return dist * (out ? -1 : 1);\n            };\n\n            double lb = 10000, ub = 0;\n            for (int i = 0; i < n; ++i) {\n                Line l = { Point{0, y}, Point{1, y} };\n                Segment s = { p[i], p[(i+1)%n] };\n                if (!parallel(l, s) and intersected(l, s)) {\n                    double crossx = crosspoint(l, s).real();\n                    chmin(lb, crossx);\n                    chmax(ub, crossx);\n                }\n            }\n            lb += EPS; ub -= EPS;\n\n            while (abs(lb - ub) > EPS) {\n                assert(lb < ub);\n                double m1 = (2 * lb + ub) / 3,\n                       m2 = (lb + 2 * ub) / 3;\n\n                if (fx(m1) < fx(m2)) lb = m1;\n                else ub = m2;\n            }\n            return fx(lb);\n        };\n\n        while (abs(lb - ub) > EPS) {\n            assert(lb < ub);\n            double m1 = (2 * lb + ub) / 3,\n                   m2 = (lb + 2 * ub) / 3;\n\n            if (f(m1) < f(m2)) lb = m1;\n            else ub = m2;\n        }\n\n        cout << f(lb) << endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    G g;\n    REP(i, n) {\n      int a, b;\n      cin >> a >> b;\n      g.push_back(P(a,b));\n    }\n    vector<L> ls;\n    REP(i, n) {\n      P p1, p2 ;\n      if (i==n-1) p1 = g[0];\n      else p1 = g[i+1];\n      if (i==0) p2 = g[n-1];\n      else p2 = g[i-1];\n      p1 -= g[i];\n      p2 -= g[i];\n      p1 *= 1/abs(p1);\n      p2 *= 1/abs(p2);\n      //cout << l1[0] << \" l1 = \"  << l1[1] << \" \" << \"l2 = \" << l2[1]<< endl;\n      L l(g[i], g[i] + p1+p2);\n      ls.push_back(l);\n    }\n    // REP(i, ls.size()) {\n    //   cout << ls[i][0] << \" \" << ls[i][1] << endl;\n    // }\n    double ans = 0;\n    REP(i, n) {\n      REP(j, i) {\n        P p = crosspoint(ls[i], ls[j]);\n        double mi = INF;\n        bool ok = 1;\n        REP(k, n) {\n          L l;\n          if (k == n-1) l = L(g[k], g[0]);\n          else l = L(g[k], g[k+1]);\n          if (ccw(l[0], l[1], p) != 1) {\n            ok = 0;\n            break;\n          }\n          mi = min(mi, distanceSP(l, p));\n        }\n        if (ok)\n          ans = max(ans, mi);\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tdo {\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tfor (int i = 1; i <= 2; ++i) {\n\t\t\t\tPoint laglanju(is_ll(edges[0], edges[i]));\n\t\t\t\tLine a(laglanju, edges[0][0]);\n\t\t\t\tif (abs(a[1] - a[0]) == 0)a = Line(laglanju, edges[0][1]);\n\t\t\t\tLine b(laglanju, edges[i][0]);\n\t\t\t\tif (abs(b[1] - b[0]) == 0)b = Line(laglanju, edges[i][1]);\n\t\t\t\tconst Point avec(a[1]-a[0]);\n\t\t\t\tconst Point bvec(b[1] - b[0]);\n\t\t\t\tPoint nvec((abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n\t\t\t\tif (!is_in_polygon(origin, laglanju + nvec*0.00000001l)) {\n\t\t\t\t\tnvec = -nvec;\n\t\t\t\t}\n\t\t\t\tnlines.emplace_back(laglanju, laglanju + nvec);\n\t\t\t}\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (is_in_polygon(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-10;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(U.size())return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        D l=0,r=100000;\n        rep(c,200){\n            D mid=(l+r)/2;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.6f\\n\",l);\n   \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\n\ntypedef double FP;\n\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.second-a.first);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.first,a.second,b.first,b.second);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.first,a.second,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\n\nvoid check(P a){\n\n  assert(!isnan(a.real()));\n  assert(!isnan(a.imag()));\n}\n\nvoid check(line a){\n  check(a.first);\n  check(a.second);  \n}\n\nbool para(line a, line b){\n  P av = a.first - a.second;\n  P bv = b.first - b.second;\n  return abs(dot(av/abs(av),bv/abs(bv))) > 1 - 1e-9;\n}\n\ndouble tri(P a, P b, P c){\n  a -= c;\n  b -= c;\n  return abs(crs(a,b));\n}\n\nline midline(line a,line b){\n  if(!para(a,b)){\n    P av = a.second - a.first;\n    P bv = b.second - b.first;\n    av /= abs(av);\n    bv /= abs(bv);\n    auto ret = line(crspt(a,b),crspt(a,b)+av+bv);\n    check(ret);\n    return ret;\n  }\n  P st =(a.first+b.first)/2.;\n  auto ret = line(st, st + a.second - a.first);\n  check(ret);\n  return ret;\n}\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n && n){\n    int x[n], y[n];\n    for(int i = 0; i < n; ++i)\n      cin >> x[i] >> y[i];\n    double cx = accumulate(x,x+n,0.)/n;\n    double cy = accumulate(y,y+n,0.)/n;\n      \n    double ans = 0;\n    for(int i = 0; i < n; ++i){\n      \n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        double r = 10000000000;\n        for(int k = 0; k < n; ++k){\n          if(i == k || j == k) continue;\n          line il = line(P(x[i],y[i]), P(x[(i+1)%n],y[(i+1)%n]));\n          line jl = line(P(x[(j+1)%n],y[(j+1)%n]), P(x[j],y[j]));\n          line kl = line(P(x[(k+1)%n],y[(k+1)%n]), P(x[k],y[k]));\n          line ij = midline(il, jl);\n          line ik = midline(il, kl);\n          // if(!iscrs(ij, ik)){\n          //   cout << ij << \"  \" << ik << endl;\n          //   continue;\n          // }\n          P ce = crspt(ij,ik);\n          if(!isnormal(ce.real()) || !isnormal(ce.imag())){\n            //cout << ce << endl;\n            continue;\n          }\n          double me = 0;\n          double me2 = 0;\n          for(int ii = 0; ii < n; ++ii){\n            me += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),ce);\n            me2 += tri(P(x[ii],y[ii]), P(x[(ii+1)%n],y[(ii+1)%n]),P(cx,cy));\n          }\n          \n          if(abs(me-me2)/max(me,me2) > EPS){\n            //cout << me << \" \" << me2 << endl;\n            continue;\n          }\n          \n          double tr = 10000000000;\n          for(int ii = 0; ii < n; ++ii){\n            line l(P(x[ii],y[ii]),P(x[(ii+1)%n],y[(ii+1)%n]));\n            tr = min(tr, lpdist(l,ce));\n          }\n          ans = max(tr, ans);\n          //cout << ce << endl;\n          double cr = lpdist(il,ce);\n          r = min(r, cr);\n        }\n        //ans = max(r, ans);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%f\\n\",left);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble const EPS = 1e-7;\ndouble const inf = 1e10;\n\nstruct Line : public vector<P>\n{\n  Line() {}\n  Line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n  P vectorize() { return (*this)[1]-(*this)[0]; }\n  double length() { return abs((*this)[1]-(*this)[0]); }\n};\n\ninline double dot(P const& a, P const& b) { return real(conj(a)*b); }\ninline double cross(P const& a, P const& b) { return imag(conj(a)*b); }\n\nenum { counter_clockwise = +1, clockwise = -1, cab_online = +2, abc_online = -2, on_segment = 0 };\nint ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return counter_clockwise;\n  if(cross(b, c) < 0) return clockwise;\n  if(dot(b, c) < 0) return cab_online;\n  if(norm(b) < norm(c)) return abc_online;\n  return on_segment;\n}\n\ntypedef Line Segment;\n\n\nP crosspoint(Line const& a, Line const& b) {\n  double k = cross(a[1]-a[0], b[1]-b[0]);\n  double t = cross(a[1]-a[0], a[1]-b[0]);\n  if(abs(k) < EPS && abs(t) < EPS) return b[0]; // same line\n  if(abs(k) < EPS) { assert(false); } // parallel\n  return b[0] + t / k * (b[1]-b[0]);\n}\n\n// Notice: Return left part of the polygon.\nPolygon convex_cut(Polygon const& G, Line const& l) {\n  Polygon left_part;\n  rep(i, G.size()) {\n    P const& a = G[i], b = G[(i+1)%G.size()];\n    Line const& ab = Line(a, b);\n    if(ccw(l[0], l[1], a) != clockwise) { left_part.push_back(a); }\n    if(ccw(l[0], l[1], a) * ccw(l[0], l[1], b) < 0)\n      left_part.push_back(crosspoint(ab, l));\n  }\n  return left_part;\n}\n\n// Notice: The border of the polygon in counterclockwise order.\nbool able_polygon(Polygon const& G, double x) {\n  int N = G.size();\n  /*\n    Polygon A;\n    A.push_back(P(inf,inf)); A.push_back(P(-inf,inf));\n    A.push_back(P(-inf,-inf)); A.push_back(P(inf,-inf));\n  */\n  Polygon A = {{-inf, -inf}, {inf, -inf}, {inf, inf}, {-inf, inf}};\n  rep(i, N) {\n    Line ln(G[i], G[(i+1)%N]);\n    P shift = ln.vectorize()*polar(x/ln.length(), M_PI/2.);\n    A = convex_cut(A, Line(G[i] + shift, G[(i+1)%G.size()] + shift));\n  }\n  return !A.empty();\n}\n\ndouble solve(Polygon const& G) {\n  double L = 0., R = inf;\n  rep(loop, 1000) {\n    double M = (L+R) / 2.;\n    if(able_polygon(G, M)) { L = M; }\n    else { R = M; }\n  }\n  return L;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    Polygon G(N);\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      G[i] = P(x, y);\n    }\n    printf(\"%.8f\\n\", solve(G));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\nclass Line\n{\n  public:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle\n{\n  public:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// s : line segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t)\n{\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc(Circle c, Line l)\n{\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l)\n{\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    REP(j, n)\n    res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    REP(i, n)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N)\n    {\n        Polygon land;\n        for (int i = 0; i < N; i++)\n        {\n            ld x, y;\n            cin >> x >> y;\n            land.push_back(Point(x, y));\n        }\n        ld low = 0, high = 100000;\n        for (int k = 0; k < 100; k++)\n        {\n            ld mid = (low + high) / 2;\n            Polygon p = land;\n            for (int i = 0; i < N; i++)\n            {\n                Point a = land[i], b = land[(i + 1) % N];\n                Point st = a + (mid / abs(b - a)) * ((b - a) * Point(0, 1)), gt = st + (b - a);\n                p = convex_cut(p, Line(st, gt));\n            }\n            if (p.size() == 0)\n            {\n                high = mid;\n            }\n            else\n            {\n                low = mid;\n            }\n        }\n        cout << fixed << setprecision(10) << low << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\ntypedef long double ld;\ntypedef double Double;\ntypedef complex<ld> Point;\nconst ld eps = 1e-15, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() { ld x, y; cin >> x >> y; return Point(x, y); } // 点の入力\nbool eq(ld a, ld b) { return (abs(a - b) < eps); } // 誤差つき等号判定\nld dot(Point a, Point b) { return real(conj(a) * b); } // 内積\nld cross(Point a, Point b) { return imag(conj(a) * b); } // 外積\n\n// 直線の定義\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// 円の定義\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n    if (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n    if (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n    if (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n    return 0;                          // a,c,bの順に直線に並ぶ\n}\n\n/* 交差判定 */\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// 点の直線上判定\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\n// 点の線分上判定\nbool isis_sp(Line s, Point p) { return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps); }\n\n/* 距離 */\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n/* 円 */\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\n/* 多角形 */\ntypedef vector<Point> Polygon;\n// 面積\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = (int)p.size();\n    for (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n// 凸性判定\nbool isConvex(const Polygon &poly){\n    int n = (int)poly.size();\n    if(n < 3) return false;\n    int s = -3;\n    for(int i = 0; i < n;i++){\n        int r = ccw(poly[(i+n-1)%n],poly[i%n],poly[(i+1)%n]);\n        if(r == 1 && s == -3) s = r;\n        if(s*r == -1) return false;\n    }\n    return true;\n}\n// 点の内外判定\n//  0 => out : 1 => on : 2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = (int)poly.size();\n    for (int i = 0;i < n;i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包 : 凸多角形のある一辺上にある点を含まない\nPolygon convex_hull(vector<Point> ps) {\n    int n = (int)ps.size();\n    if(n < 3) return ps;\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n// 凸包 : 凸多角形のある一辺上にある点も含む\nPolygon convex_hull2(vector<Point> ps) {\n    int n = (int)ps.size();\n    if (n < 3) return ps;\n    sort(ps.begin(), ps.end());\n    Polygon u = { ps[0], ps[1] }, l = { ps[n - 1],ps[n - 2] };\n    for (int i = 2; i < n; i++) {\n        for (int j = (int)u.size(); j >= 2 && ccw(u[j - 2], u[j - 1], ps[i]) >= 0;j--)u.pop_back();\n        u.push_back(ps[i]);\n    }\n    for (int i = n - 3;i >= 0;i--) {\n        for (int j = (int)l.size(); j >= 2 && ccw(l[j - 2], l[j - 1], ps[i]) >= 0;j--)l.pop_back();\n        l.push_back(ps[i]);\n    }\n    reverse(l.begin(), l.end());\n    for (int i = (int)u.size() - 2; i >= 1; i--)l.push_back(u[i]);\n    return l;\n}\n\n// 凸多角形の直径\npair<pll,ld> convex_diameter(const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return make_pair(pll(0,1),abs(poly[0]-poly[1]));\n    int ii = 0, jj = 0;\n    for(int i = 1;i < n;i++){\n        if(poly[i].imag() > poly[ii].imag())ii = i;\n        if(poly[i].imag() < poly[jj].imag())jj = i;\n    }\n    pll resp = make_pair(-1,-1);\n    ld resd = 0;\n    \n    int i, maxi,j,maxj;\n    i = maxi = ii; j = maxj = jj;\n    while(i != maxj || j != maxi){\n        ld cur = abs(poly[i] - poly[j]);\n        if(resd + eps < cur){ resd = cur; resp = pll(i,j); }\n        int di = (i+1)%n, dj = (j+1)%n;\n        if(cross(poly[di]-poly[i],poly[dj]-poly[j]) < 0) i = di;\n        else j = dj;\n    }\n    return make_pair(resp,resd);\n}\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = (int)ps.size();\n    Polygon Q;\n    for (int i = 0;i < n;i++) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// 円と多角形の共通部分\ndouble area_of_polygon_and_circle(const Polygon& poly, const Circle c) {\n    int n = (int)poly.size();\n    ld r = 0;\n    for (int i = n - 1, j = 0; j < n; i=j++) {\n        Point v = abs(poly[j] - poly[i]) / (poly[j] - poly[i]);\n        if (poly[j] == poly[i])continue;\n        assert(poly[j] != poly[i]);\n        Point a = (poly[i] - c.p)*v, b = (poly[j] - c.p)*v;\n        ld d = norm(c.r) - norm(a.imag());\n        if (abs(a.imag()) < eps) continue;\n        if (d < 0)d = 0;\n        d = sqrt(d);\n        double l, m;\n        r += norm(c.r)*((l = atan2(b.imag(), min(b.real(), -d)) - atan2(a.imag(), min(a.real(), -d)))\n                        + (m = atan2(b.imag(), max(b.real(), d)) - atan2(a.imag(), max(a.real(), d))))\n        + a.imag()*(min(d, max(a.real(), -d)) - max(-d, min(b.real(), d)));\n        assert(-pi < l && -pi < m && l < pi && m < pi);\n    }\n    return r / 2;\n}\n\n// 凸多角形と凸多角形のAND O(nm)ぐらい そのうち線形時間のやつも書く\nPolygon convex_polygon_and_convex_polygon(const Polygon& in1,const Polygon& in2){\n    Polygon ret;\n    if(in1.size()==0 || in2.size()==0) return ret;\n    Polygon ps1 = in1,ps2 = in2;\n    // ポリゴンを凸＋並びを揃える(反時計回り)　// この２点が保証されているのであればコメントアウト可\n    ps1 = convex_hull(in1);ps2 = convex_hull(in2);\n    int n = (int)ps1.size(),m = (int)ps2.size();\n    // p2に含まれるp1の点、p1に含まれるp2の点をそれぞれ探索する\n    vector<int> inpoint_of_ps1(n),inpoint_of_ps2(m);\n    for(int i = 0; i < n;i++) if(is_in_polygon(ps2, ps1[i])){ ret.push_back(ps1[i]); inpoint_of_ps1[i] = 1; }\n    for(int i = 0; i < m;i++) if(is_in_polygon(ps1, ps2[i])){ ret.push_back(ps2[i]); inpoint_of_ps2[i] = 1; }\n    \n    if(n>=2 && m >= 2){\n        // p1とp2が交わる点を探索する\n        for(int i = 0; i < n;i++){\n            Line l1(ps1[i],ps1[(i+1)%n]);\n            for(int j = 0; j < m;j++){\n                Line l2(ps2[j],ps2[(j+1)%m]);\n                if(dist_ss(l1,l2) < eps) ret.push_back(is_ll(l1,l2));\n            }\n        }\n    }\n    // ポリゴンを凸＋並びを揃える(反時計回り)\n    ret = convex_hull(ret);\n    \n    return ret;\n}\n\n#define FOR(i,s,t) for(int i = s ; i < t ; i++)\n#define SZ(a) ((int)a.size())\nusing LL = long long;\n\n// pから多角形の最短距離を求める\n// 採用されるのは最遠のもの\n// ただし多角形から外れていてもその値を返す\n\nlong double f(Point& p, Polygon & ps) {\n    if (is_in_polygon(ps,p) !=0) {\n        long double ret = LINF;\n        // min\n        FOR(i, 0, SZ(ps)) {\n            Line line(ps[i], ps[(i + 1) % SZ(ps)]);\n            ret = min(ret, dist_sp(line,p));\n        }\n        \n        return ret;\n    }\n    else {\n        long double ret = -LINF;\n        // max(- to 0)\n        FOR(i, 0, SZ(ps)) {\n            Line line(ps[i], ps[(i + 1) % SZ(ps)]);\n            ret = max(ret, -dist_sp(line,p));\n        }\n        \n        return ret;\n    }\n}\n\nint Iter = 70;\n// Xを決めたときのYを三分探索する\nlong double solve(long double X, Polygon & ps) {\n    long double ret = -LINF;\n    long double yL = 0, yR = 15000;\n    //while (eps6 < yR - yL) {\n    FOR(syiri, 0, Iter) {\n        long double y1 = (2.0 * yL + yR) / 3.0;\n        long double y2 = (yL + 2.0 * yR) / 3.0;\n        Point p1 = Point(X, y1);\n        Point p2 = Point(X, y2);\n        \n        long double WL = f(p1, ps);\n        long double WR = f(p2, ps);\n        \n        if (WL < WR) {\n            yL = y1;\n        }\n        else if(WL> WR){\n            yR = y2;\n        }\n        ret = max(ret, max(WL, WR));\n    }\n    \n    return ret;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    \n    \n    int N;\n    while (cin >> N, N) {\n        vector<Point>ps;\n        FOR(i, 0, N) {\n            Double x, y;\n            cin >> x >> y;\n            ps.push_back(Point(x, y));\n        }\n        long double L = 0; long double R = 15000;\n        long double ans = 0.0;\n        FOR(i, 0, Iter) {\n            long double LS = (2.0 * L + R) / 3.0;\n            long double RS = (L + 2.0 * R) / 3.0;\n            long double DL = solve(LS, ps);\n            long double DR = solve(RS, ps);\n            if (DL < DR) {\n                L = LS;\n            }\n            else if (DL > DR) {\n                R = RS;\n            }\n            \n            ans = max(ans, max(DL, DR));\n        }\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tvector<vector<Line>>bis(n, vector<Line>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (isis_ll(lines[i], lines[j])) {\n\t\t\t\t\t\tbis[i][j] = bisection(lines[i], lines[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tint a = perm[0], b = perm[1], c = perm[2];\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t\tswap(a, c);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tnlines.emplace_back(bis[a][b]);\n\t\t\tnlines.emplace_back(bis[a][c]);\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (convex_contains(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t\tif (mindis < maxdis)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout <<fixed<< setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bi_deg(Point a, Point b, Point c) {\n\tPoint d = (b - c) / (a - c);\n\tld deg = atan2l(d.imag(), d.real()) / 2.0;\n\treturn Line(c, c + (Point(cosl(deg), sinl(deg)) * (a - c)));\n}\n\nPoint H(Line a, Line b, Line c) {\n\tif (!isis_ll(a, b)) {\n\t\tPoint x = is_ll(b, c), y = is_ll(c, a);\n\t\treturn is_ll(bi_deg(b.a, c.b, x), bi_deg(c.a, a.b, y));\n\t}\n\telse if (!isis_ll(b, c)) {\n\t\tPoint x = is_ll(c, a), y = is_ll(a, b);\n\t\treturn is_ll(bi_deg(c.a, a.b, x), bi_deg(a.a, b.b, y));\n\t}\n\telse {\n\t\tPoint x = is_ll(a, b), y = is_ll(b, c);\n\t\treturn is_ll(bi_deg(a.a, b.b, x), bi_deg(b.a, c.b, y));\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Point> p(n);\n\t\tfor (int i = 0, x, y; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tvector<Line> l(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = bi_deg(p[i], p[(i + 2) % n], p[(i + 1) % n]);\n\t\t}\n\t\tvector<Line> e(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = Line(p[i], i + 1 < n ? p[i + 1] : p[0]);\n\t\t}\n\t\tvector<Point> all;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (isis_ll(e[i], e[j]) || isis_ll(e[j], e[k]) || isis_ll(e[k], e[i])) {\n\t\t\t\t\t\tall.push_back(H(e[i], e[j], e[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tld res = 0;\n\t\tfor (auto is : all) {\n\t\t\tbool flag = false;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (ccw(p[k], k + 1 < n ? p[k + 1] : p[k + 1 - n] , is) != 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tld mi = 1e10;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tmi = min(mi, dist_lp(e[k], is));\n\t\t\t}\n\t\t\tres = max(res, mi);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n// 2D GEOMETORY //\n\n// 平面上の点。もしくは平面上のベクトル。\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x * _.x + y * _.y; } // 内積\n\tdouble cross(const P2 &_) const { return x * _.y - y * _.x; } // 外積\n\tdouble sqlength() const { return x * x + y * y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\n\n/// 直線\nstruct Line\n{\n\tP2 p, d; // 始点・方向\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d; // 始点・方向大きさ\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\ntypedef vector<P2> Polygon;\n\npair<Polygon, Polygon> cutConvexPolygon(const Polygon &polygon, const Line &cut)\n{\n\tint N = polygon.size();\n\tPolygon left, right;\n\tREP(i, N)\n\t{\n\t\tP2 p0 = polygon[i];\n\t\tP2 p1 = polygon[(i + 1) % N];\n\t\tint d1 = sign_of(cut.d.cross(p1 - cut.p)); // -1:cw, 0:on, 1:ccw\n\t\tint d0 = sign_of(cut.d.cross(p0 - cut.p)); // -1:cw, 0:on, 1:ccw\n\n\t\tif (d0 == 0) // p0 on cut line\n\t\t{\n\t\t\tleft.push_back(p0);\n\t\t\tright.push_back(p0);\n\t\t}\n\t\telse  // p0 and p1 are the same side.\n\t\t{\n\t\t\tif (d0 < 0)\n\t\t\t{\n\t\t\t\tleft.push_back(p0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tright.push_back(p0);\n\t\t\t}\n\n\t\t\tif (d0 * d1 < 0)\n\t\t\t{\n\t\t\t\tP2 splitPoint = crossPoint(Line::From2Point(p0, p1), cut);\n\t\t\t\tleft.push_back(splitPoint);\n\t\t\t\tright.push_back(splitPoint);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (left.size() < 3) { left.clear(); }\n\tif (right.size() < 3) { right.clear(); }\n\treturn { left, right };\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile (true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tauto polygon = read<P2>(N);\n\n\t\t// 削れる陸の距離をにぶたんで探す。\n\t\tdouble l = 0.0, r = 10000.0, m;\n\n\t\twhile (abs(l - r) >= 0.0000001)\n\t\t{\n\t\t\tm = (r - l) / 2 + l; // 陸を削る\n\n\t\t\tPolygon poly = polygon;\n\t\t\tREP(i,N)\n\t\t\t{\n\t\t\t\tLineSeg cutLine = LineSeg::From2Point(polygon[i], polygon[(i + 1) % N]);\n\t\t\t\tcutLine.p = cutLine.p + -cutLine.d.orthogonal().direction() * m; // 辺に垂直な方向に m だけ動かした直線。\n\t\t\t\tpoly = cutConvexPolygon(poly, cutLine).second;\n\t\t\t}\n\n\t\t\t//DEBUG(m);\n\t\t\tbool ok = poly.size() > 0; // 陸地がちょっとでも残ってればOK\n\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\n\t\t//WRITE(m);\n\t\tprintf(\"%16.16f\\n\", m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if (cross(a, b) > eps) return 1;\n  if (cross(a, b) < -eps) return -1;\n  if (dot(a, b) < -eps) return 2;\n  if (norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for (int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i + 1) % ps.size()];\n    if (ccw(p1, p2, a) != dir) v.push_back(a);\n    if (ccw(p1, p2, a) * ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint n;\nvector<P> ps;\n\nbool ok(double d) {\n  vector<P> g = ps;\n  for (int i = 0; i < n; ++i) {\n    P a = ps[i];\n    P b = ps[(i + 1) % ps.size()];\n    P base = b - a;\n    P nv = base * P(0, 1);\n    nv = nv * d / abs(nv);\n    g = convex_cut(g, a + nv, b + nv);\n  }\n  return g.size() >= 1;\n}\n\nint main() {\n  for (; cin >> n && n; ) {\n    ps = vector<P>(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    double l = 0, r = 10000000;\n    for (int step = 0; step < 100; ++step) {\n      double d = (l + r) / 2.0;\n      if (ok(d)) {\n        l = d;\n      } else {\n        r = d;\n      }\n    }\n    printf(\"%.10f\\n\", l);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define GE(x, y) ((x)>(y)||EQ(x, y))\n#define LE(x, y) ((x)<(y)||EQ(x, y))\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometry {ABC=-2, CW, ACB, CCW, CAB, ON_LINE, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (!EQ(a.X, b.X)) return a.X < b.X;\n    if (!EQ(a.Y, b.Y)) return a.Y < b.Y;\n    return false;\n  }\n\n  bool operator>(Point a, Point b) {\n    return b<a;\n  }\n\n  bool operator<=(Point a, Point b) {\n    return !(a>b);\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometry ccw(Point a, Point b, Point c) {\n  a -= b;\n  c -= b;\n  if (cross(a, c) > EPS) return CCW; // ccw\n  if (cross(a, c) < -EPS) return CW; // cw\n  if (dot(a, c) < -EPS) return ABC; // a - b - c\n\n  double al = abs(a);\n  double cl = abs(c);\n  if (EQ(al, cl)) return ERROR; // a and c are duplicate\n  if (EQ(min(al, cl), 0)) return ERROR;\n  if (al < cl) return CAB; // c - a - b\n  else return ACB; // a - c - b\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  // hard coding: CW := -1, CCW := 1 -> only CW*CW and CCW*CCW are equal to 1\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  swap(s, t);\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) == 1) return false;\n  if (!IsParallel(s, t)) return true;\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  swap(s, t);\n  if (max(s[0], s[1]) < min(t[0], t[1])) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  Point a = s[0];\n  Point b = s[1];\n  return abs(a-p)+abs(b-p)-abs(a-b) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  swap(s, t);\n  double b = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (EQ(d, c.r)) {\n    ret.emplace_back(proj(l, c.c));\n  } else if (d < c.r) {\n    double ratio = sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.emplace_back(proj(l, c.c) + ratio*sgn);\n    ret.emplace_back(proj(l, c.c) - ratio*sgn);\n  }\n\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  Point a = s[0];\n  Point b = s[1];\n  if (a > b) swap(a, b);\n  for (Point p : res) {\n    if (\n      LE(a, p) \n      && \n      LE(p, b)) ret.emplace_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.emplace_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.emplace_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Get the intersection of a circle and a segment, which is obviously a segment\nLine CapCS(Circle c, Line s) {\n  Point inf(INF, INF);\n  vector<Point> cros = CrossPointCS(c, s);\n  if (cros.empty()) return Line{inf, inf};\n\n  if (cros.size() == 1) {\n    double ad = abs(s[0]-c.c);\n    double bd = abs(s[1]-c.c);\n    if (!GE(ad, min(bd, c.r))) cros.emplace_back(s[0]);\n    else if (!GE(bd, min(ad, c.r))) cros.emplace_back(s[1]);\n    else {\n      Point p = cros[0];\n      cros.emplace_back(p); // avoid an undefined behavior\n    }\n  }\n\n  if (cros[1] < cros[0]) {\n    swap(cros[0], cros[1]);\n  }\n\n  return Line{cros[0], cros[1]};\n}\n\nGeometry PositioningPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n\n    if (u.Y > v.Y) swap(u, v);\n\n    double cr = cross(u, v);\n    if (LE(u.Y, 0) && !GE(0, v.Y) && cr >= EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  if (ps.size() <= 2) return ps;\n\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\nbool IsConvex(Poly ps) {\n  //return GrahamScan(ps).size() == ps.size();\n  return GrahamScan(ps) == ps;\n}\n\nPoly CapConvexes(Poly pp, Poly qq) {\n#if DEBUG\n  assert (IsConvex(pp));\n  assert (IsConvex(qq));\n#endif\n\n  Poly ret;\n  int a = 0;\n  int b = 0;\n  int aa = 0;\n  int bb = 0;\n  int n = pp.size();\n  int m = qq.size();\n  enum {PIN, QIN, UNKNOWN} in = UNKNOWN;\n\n  auto forward_a = [&](bool put) {\n    if (put && in == PIN) ret.emplace_back(pp[a]);\n    a = (a+1)%n;\n    aa++;\n  };\n\n  auto forward_b = [&](bool put) {\n    if (put && in == QIN) ret.emplace_back(qq[b]);\n    b = (b+1)%m;\n    bb++;\n  };\n\n  auto intersect_1pt = [](Point &a, Point &b, Point &c, Point &d, Point &r) {\n    double D =  cross(b - a, d - c);\n    if (EQ(D, 0)) return false;\n    double t =  cross(c - a, d - c) / D;\n    double s = -cross(a - c, b - a) / D;\n    r = a + t * (b - a);\n    return GE(t, 0) && LE(t, 1) && GE(s, 0) && LE(s, 1);\n  };\n\n  do {\n    int apre = (a+n-1)%n;\n    int bpre = (b+m-1)%m;\n    double C = cross(pp[a]-pp[apre], qq[b]-qq[bpre]);\n    double A = cross(pp[apre]-qq[b], pp[a]-qq[b]);\n    double B = cross(qq[bpre]-pp[a], qq[b]-pp[a]);\n    Point r;\n    if (intersect_1pt(pp[apre], pp[a], qq[bpre], qq[b], r)) {\n      if (in == UNKNOWN) aa = bb = 0;\n      ret.emplace_back(r);\n      if (B > 0) in = PIN;\n      else if (A > 0) in = QIN;\n    }\n\n    if (EQ(A, 0) && EQ(B, 0) && EQ(C, 0)) {\n      if (in == PIN) forward_b(false);\n      else forward_a(false);\n    } else if (C >= 0) {\n      if (A > 0) forward_a(true);\n      else forward_b(true);\n    } else {\n      if (B > 0) forward_b(true);\n      else forward_a(true);\n    }\n  } while ((aa < n || bb < m) && aa < 2*n && bb < 2*m);\n\n  if (in == UNKNOWN) {\n    if (PositioningPoint(qq, pp[0]) != OUTSIDE) return pp;\n    if (PositioningPoint(pp, qq[0]) != OUTSIDE) return qq;\n  }\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nCircle Circum(Point a, Point b, Point c) {\n  Circle ret{{INF, INF}, 0.0};\n  Line l{a, b};\n  Line m{b, c};\n  Line lp = PerpendBisect(l);\n  Line mp = PerpendBisect(m);\n  if (IsParallel(lp, mp)) return ret;\n\n  ret.c = CrossPointLL(lp, mp);\n  ret.r = abs(a-ret.c);\n  return ret;\n}\n\nvector<Point> TangentPoints(Circle c, Point p) {\n  vector<Point> ret;\n  double d = abs(c.c-p);\n  if (EQ(d, c.r)) {\n    ret.emplace_back(p);\n    return ret;\n  }\n\n  if (d < c.r) return ret;\n\n  Vec v = (p-c.c)/d*c.r;\n  double t = acos(c.r/d);\n  ret.emplace_back(c.c + rotate(v, t));\n  ret.emplace_back(c.c + rotate(v, -t));\n  return ret;\n}\n\nvector<Line> CommonTangents(Circle p, Circle q) {\n#if DEBUG\n  assert(!EQ(p.c, q.c) || !EQ(p.r, q.r));\n#endif\n\n  double pr = p.r;\n  double qr = q.r;\n  Point pc = p.c;\n  Point qc = q.c;\n  double d = abs(pc - qc);\n  double dr = abs(pr - qr);\n  double sr = abs(pr + qr);\n\n  vector<Line> ret;\n  if (EQ(d, sr)) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > sr) {\n    Point cp = (pc * qr + qc * pr) / sr;\n    vector<Point> pts = TangentPoints(p, cp);\n    vector<Point> qts = TangentPoints(q, cp);\n    for (int i=0; i<2; i++) {\n      Line l{pts[0], qts[i]};\n      if (IntersectLP(l, cp)) {\n        ret.emplace_back(l);\n        ret.emplace_back(Line{pts[1], qts[i^1]});\n      }\n    }\n  } \n\n  if (EQ(d, dr)) {\n    Point cp = pc + (pc-qc) / (qr-pr) * pr;\n    Vec v = cp - pc;\n    ret.emplace_back(Line{cp, cp + v*Vec(0, 1)});\n  } else if (d > dr) {\n    if (EQ(pr, qr)) {\n      Point v = (qc - pc) / d * pr;\n      v *= Point(0, 1);\n      ret.emplace_back(Line{pc+v, qc+v});\n      ret.emplace_back(Line{pc-v, qc-v});\n    } else {\n      Point cp = pc + (qc-pc) * pr / (pr-qr);\n      vector<Point> pts = TangentPoints(p, cp);\n      vector<Point> qts = TangentPoints(q, cp);\n      for (int i=0; i<2; i++) {\n        Line l{pts[0], qts[i]};\n        if (IntersectLP(l, cp)) {\n          ret.emplace_back(l);\n          ret.emplace_back(Line{pts[1], qts[i^1]});\n          break;\n        }\n      }\n    }\n  } \n\n  return ret;\n}\n\nint N;\nPoint ps[114];\nPoint qs[114];\n\nbool check(double x) {\n  Line s{ps[0], ps[1]};\n  Line t{ps[1], ps[2]};\n    \n  Vec u = (s[1]-s[0]);\n  u = (u/abs(u))*x;\n  s[0] += rotate(u, PI/2);\n  s[1] += rotate(u, PI/2);\n  Vec v = (t[1]-t[0]);\n  v = (v/abs(v))*x;\n  t[0] += rotate(v, PI/2);\n  t[1] += rotate(v, PI/2);\n  if (!IntersectSS(s, t)) return false;\n  Point p = CrossPointLL(s, t);\n  for (int i=0; i<N; i++) {\n    Line l{ps[i], ps[(i+1)%N]};\n    if (!LE(x, DistSP(l, p))) return false;\n  }\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) return 0;\n    for (int i=0; i<N; i++) {\n      int x, y;\n      scanf(\"%d%d\", &x, &y);\n      ps[i] = Point(x, y);\n    }\n  \n    double low = 0;\n    double high = 100000;\n    for (int i=0; i<50; i++) {\n      double mid = (low+high)/2;\n      if (check(mid)) low = mid;\n      else high = mid;\n    }\n    printf(\"%.20f\\n\", low);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\ndouble solve(){\n    int v[]{rand()%(n-2),rand()%(n-2),rand()%(n-2)};\n    sort(v,v+3);\n    v[1]++;v[2]+=2;\n    P p=innerCenter(ps[v[0]],ps[v[1]],ps[v[2]]);\n    if(n==3){\n        return distanceLP(es[0],p);\n    }\n    static double d[128];\n    int near=0;\n    double r[]={1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7};\n    rep(t,80000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n){\n            if(d[i]<d[near]){\n                near=i;\n            }\n        }\n        P h=projection(es[near],p);\n        p -= (h-p)/d[near]*r[t/10000];\n    }\n\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[n]=ps[0];\n        rep(i,n){\n            es[i]={ps[i],ps[i+1]};\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-9;\ninline D dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\treturn -1;\n}\ninline P perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline bool iSP(L s,P p){\n\tP a=s.fs,b=s.sc,c=p;\n\treturn abs(abs(a-c)+abs(c-b)-abs(a-b))<eps;\n}\ninline D dSP(L s,P p){\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline P intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint N;\nPol pol;\nP p[100];\nbool contain(Pol pol,P p){\n\tbool in=false;\n\trep(i,N){\n\t\tP a=pol[i]-p,b=pol[(i+1)%N]-p;\n\t\tif(ccw(a,b,P(0,0))==0) return false;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(imag(a)<=eps && eps<imag(b) && ccw(P(0,0),a,b)==1) in=!in;\n\t}\n\treturn in;\n}\nbool check(D m){\n\trep(i,N){\n\t\tP a=p[i],b=p[(i+1)%N],c=p[(i+2)%N];\n\t\tP x=(b-a)*P(0,1),y=(c-b)*P(0,1);\n\t\tx=x/abs(x)*m,y=y/abs(y)*m;\n\t\tL l1=L(a+x,b+x),l2=L(b+y,c+y);\n\t\tP q=intLL(l1,l2);\n\t\tif(!contain(pol,q)) continue;\n\t\tint cnt=0;\n\t\trep(j,N){\n\t\t\tL l=L(p[j],p[(j+1)%N]);\n\t\t\tif(dSP(l,q)+eps<m) cnt++;\n\t\t}\n\t\tif(cnt==0) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tpol.clear();\n\t\trep(i,N){\n\t\t\tint xx,yy;\n\t\t\tcin>>xx>>yy;\n\t\t\tp[i]=P(xx,yy);\n\t\t\tpol.pb(p[i]);\n\t\t}\n\t\tD ub=10000,lb=0;\n\t\trep(tt,40){\n\t\t\tD m=(ub+lb)/2;\n\t\t\tif(check(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tprintf(\"%.12f\\n\",ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nFOR(it,t) os << *it << endl; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, const int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tconst P m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n, m;\nmain(){\n\twhile(cin >> n, n){\n\t\tG g(n);\n\t\tREP(i, n) cin >> g[i];\n\t\tR l=0, r=100000;\n\t\tREP(itr, 40){\n\t\t\tR m = (l+r)*.5;\n\t\t\tif([&](){\n\t\t\t\tG gg = g;\n\t\t\t\tREP(i, n){\n\t\t\t\t\tS s=g.edge(i);\n\t\t\t\t\tP d = unit(s.dir())*P(0, 1)*m;\n\t\t\t\t\ts[0] += d; s[1] += d;\n\t\t\t\t\tgg = gg.cut(s);\n\t\t\t\t\tif(gg.empty()) return 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}()) l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tprintf(\"%.9f\\n\", r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c??????????¨???¨???\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b????????§??´???\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c???????????´???\n\treturn 0;\t\t\t\t\t\t\t// a,c,b???????????´???\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bi_deg(Point a, Point b, Point c) {\n\tPoint d = (b - c) / (a - c);\n\tld deg = atan2l(d.imag(), d.real()) / 2.0;\n\treturn Line(c, c + (Point(cosl(deg), sinl(deg)) * (a - c)));\n}\n\nPoint H(Line a, Line b, Line c) {\n\tif (!isis_ll(a, b)) {\n\t\tPoint x = is_ll(b, c), y = is_ll(c, a);\n\t\treturn is_ll(bi_deg(b.a, a.b, x), bi_deg(c.a, a.b, y));\n\t}\n\telse if (!isis_ll(b, c)) {\n\t\tPoint x = is_ll(c, a), y = is_ll(a, b);\n\t\treturn is_ll(bi_deg(c.a, a.b, x), bi_deg(a.a, b.b, y));\n\t}\n\telse {\n\t\tPoint x = is_ll(a, b), y = is_ll(b, c);\n\t\treturn is_ll(bi_deg(a.a, b.b, x), bi_deg(b.a, c.b, y));\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcout << fixed << setprecision(7);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Point> p(n);\n\t\tfor (int i = 0, x, y; i < n; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = Point(x, y);\n\t\t}\n\t\tvector<Line> l(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl[i] = bi_deg(p[i], p[(i + 2) % n], p[(i + 1) % n]);\n\t\t}\n\t\tvector<Line> e(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = Line(p[i], i + 1 < n ? p[i + 1] : p[0]);\n\t\t}\n\t\tvector<Point> all;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tif (isis_ll(e[i], e[j]) || isis_ll(e[j], e[k]) || isis_ll(e[k], e[i])) {\n\t\t\t\t\t\tall.push_back(H(e[i], e[j], e[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tld res = 0;\n\t\tfor (auto is : all) {\n\t\t\tld deg = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tPoint tmp = ((k + 1 >= n ? p[k + 1 - n] : p[k + 1]) - is) / (p[k] - is);\n\t\t\t\tdeg += atan2l(tmp.imag(), tmp.real());\n\t\t\t}\n\t\t\tif (eq(deg, 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tld mi = 1e10;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tmi = min(mi, dist_lp(e[k], is));\n\t\t\t}\n\t\t\tres = max(res, mi);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\ntypedef vector<VP> Vcon;\nconst D EPS = 1e-10;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n \n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {return (conj(a)*b).X; }\n \n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {  return (conj(a)*b).Y;}\n \n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isparallel(L a,L b){\n  return cross(a.first-a.second,b.first-b.second) == 0.0 ;\n}\n \n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n \n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n \n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  //return !ccw(a1, a2, b);\n   return abs(a1 - b) + abs(a2 - b) - abs(a2 - a1) < EPS;  //Perfective\n}\n \n \n/* 距離　各直線・線分は縮退してはならない */\n \n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* 円 */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\nP mae_syori(P p1, P p2, P Q){\n  double xa,ya,xb,yb,t1,t2;\n  P R;\n  xa=Q.X-p1.X,ya=Q.Y-p1.Y;\n  xb=p2.X-p1.X,yb=p2.Y-p1.Y;\n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n  R=P(2*(p1.X+xb*t1/t2)-Q.X,2*(p1.Y+yb*t1/t2)-Q.Y);\n  return R;\n}\n// 直線abから左側にh離れた直線\nL parallel_line(P a,P b,double h){\n    double t = atan((a.Y-b.Y)/(a.X-b.X));\n    P a_=P(a.X + h*cos(t+M_PI/2), a.Y + h*sin(t+M_PI/2));\n    P b_=P(b.X + h*cos(t+M_PI/2), b.Y + h*sin(t+M_PI/2));\n    if(ccw(a,b,a_)==-1)a_=mae_syori(a,b,a_),b_=mae_syori(a,b,b_);  // -1ならabを左側にhだけ移動\n    return make_pair(a_,b_);\n}\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n \n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n \n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n \n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n \n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\nint n;\n\nbool check(VP &v,D d){\n    VP U=v;\n    rep(i,n){\n        L l=parallel_line(v[i],v[(i+1)%n],d);\n        U=convexCut(U,l.first,l.second);\n    }\n    if(U.size())return 1;\n    return 0;\n}\n\nint main(){\n    while(cin>>n,n){\n        VP v;\n        rep(i,n){\n            D x,y;\n            cin>>x>>y;\n            v.push_back(P(x,y));\n        }\n        D l=0,r=100000;\n        rep(c,200){\n            D mid=(l+r)/2;\n            if(!check(v,mid))r=mid;\n            else l=mid;\n        }\n        printf(\"%.6f\\n\",l);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tVP p(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { x,y };\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tvector<L> l(n);\n\t\trep(i, n)l[i] = { p[i],p[(i + 1) % n] };\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tP a = is_ll(l[i], l[j]), b = is_ll(l[j], l[k]), c = is_ll(l[k], l[i]);\n\t\t\tif (ccw(a, b, c) != ccw(l[i].a, l[j].a, l[k].a))continue;\n\t\t\tdouble t1 = atan2((l[i].a - l[i].b).imag(), (l[i].a - l[i].b).real()), t2 = atan2((l[j].a - l[j].b).imag(), (l[j].a - l[j].b).real()), t3 = atan2((l[k].a - l[k].b).imag(), (l[k].a - l[k].b).real());\n\t\t\tt2 = (t1 + t2) / 2;\n\t\t\tt3 = (t1 + t3) / 2;\n\t\t\tL l1 = (isis_ls(L{ a,a + 1e5l*P(cos(t2),sin(t2)) }, L{ b,c })) ? L{ a,a + 1e5l*P(cos(t2),sin(t2)) } : L{ a,a + 1e5l*P(-sin(t2),cos(t2)) };\n\t\t\tL l2 = (isis_ls(L{ c,c + 1e5l*P(cos(t3),sin(t3)) }, L{ a,b })) ? L{ c,c + 1e5l*P(cos(t3),sin(t3)) } : L{ c,c + 1e5l*P(-sin(t3),cos(t3)) };\n\t\t\tcmin(ans, dist_lp(l[i], is_ll(l1, l2)));\n\t\t}\n\t\tcout << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<stdlib.h>\nusing namespace std;\ndouble x[200];\ndouble y[200];\ndouble EPS=1e-9;\nstruct L{ // ax+by+c=0\n\tdouble a,b,c;\n\tL(){}\n\tL(double A,double B,double C){\n\t\ta=A;\n\t\tb=B;\n\t\tc=C;\n\t}\n};\ndouble Abs(double a){return max(a,-a);}\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double X,double Y){\n\t\tx=X;\n\t\ty=Y;\n\t}\n};\nP inter(L s,L t){\n\tdouble det=s.a*t.b-s.b*t.a;\n\tif(Abs(det)<EPS){\n\t\treturn P(1000000009,1000000009);\n\t}\n\treturn P((-t.b*s.c+s.b*t.c)/det,(-t.c*s.a+s.c*t.a)/det);\n}\ndouble dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble norm(P a){\n\treturn a.x*a.x+a.y*a.y;\n}\nint ccw(P a,P b,P c){\n\tb.x-=a.x;\n\tb.y-=a.y;\n\tc.x-=a.x;\n\tc.y-=a.y;\n\tif(cross(b,c)>0)return 1;\n\tif(cross(b,c)<0)return -1;\n\tif(dot(b,c)<0)return 2;\n\tif(norm(b)<norm(c))return -2;\n\treturn 0;\n}\ndouble dist(L s,P t){ // 点と直線の距離\n\treturn Abs(s.a*t.x+s.b*t.y+s.c)/sqrt(s.a*s.a+s.b*s.b);\n}\nL convLine(P s,P t){ // (x1,y1),(x2,y2)を通る直線の型変換\n\tdouble theta=atan2(t.y-s.y,t.x-s.x);\n\tdouble A=sin(theta);\n\tdouble B=-cos(theta);\n\tdouble C=-(s.x*A+s.y*B);\n\treturn L(A,B,C);\n}\nL lines[200];\nL poly[100];\nP point[100];\nint main(){\n\tint a;\n\tint n=0;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",x+i,y+i);\n\t\t}\n\t\tx[a]=x[0];\n\t\ty[a]=y[0];\n\t\tfor(int i=0;i<=a;i++)point[i]=P(x[i],y[i]);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tpoly[i]=convLine(point[i],point[i+1]);\n\t\t//\tprintf(\"%f %f %f\\n\",poly[i].a,poly[i].b,poly[i].c);\n\t\t}\n\t\tdouble left=0;\n\t\tdouble right=10000;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tdouble M=(left+right)/2;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tlines[j*2]=L(poly[j].a,poly[j].b,poly[j].c-M);\n\t\t\t\tlines[j*2+1]=L(poly[j].a,poly[j].b,poly[j].c+M);\n\t\t\t}\n\t\t\tvector<P> points;\n\t\t\tfor(int j=0;j<2*a;j++){\n\t\t\t\tfor(int k=j+1;k<2*a;k++){\n\t\t\t\t\tP val=inter(lines[j],lines[k]);\n\t\t\t\t\tif(Abs(val.x-1000000009)>EPS){\n\t\t\t\t\t\tpoints.push_back(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<points.size();j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(dist(poly[k],points[j])+EPS<M){\n\t\t\t\t\t\tOK=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(ccw(point[k],points[j],point[k+1])!=-1)OK=false;\n\t\t\t\t}\n\t\t\t\tif(OK){\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tleft=M;\n\t\t\t}else right=M;\n\t\t}\n\t\tprintf(\"%.8f\\n\",left);\n\t\tn++;\n\t}\n\tif(n!=29)return 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <vector>\n#define EPS 1e-10\n#define INF 1e5\nusing namespace std;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n};\n\nstruct Segment{\n\tP p1,p2;\n\tSegment(){}\n\tSegment(P pp1,P pp2){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\ntypedef P Vector;\ntypedef Segment Line;\ntypedef vector<P> Polygon;\n\ndouble norm(P p){\n\treturn add(p.x*p.x,p.y*p.y);\n}\n\ndouble abs(P p){\n\treturn sqrt(norm(p));\n}\n\ndouble dot(P a,P b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(P a,P b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<EPS)return -1;\n\tif(dot(a,b)<-EPS)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\ndouble getDistanceLP(Line l,P p){\n\treturn abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,P p){\n\tif(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n\tif(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\treturn getDistanceLP(s,p);\n}\n\nint contains(Polygon& g,P p){\n\tint N=g.size();\n\tbool x=false;\n\tfor(int i=0;i<N;i++){\n\t\tP a=g[i]-p,b=g[(i+1)%N]-p;\n\t\tif(abs(cross(a,b))<EPS && dot(a,b)<EPS)return 1;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<EPS && EPS<b.y && cross(a,b)>EPS)x=!x;\n\t}\n\treturn (x?2:0);\n}\n\ndouble getDistancePP(Polygon& g,P p){\n\tdouble res=INF;\n\tint n=g.size();\n\tfor(int i=0;i<n;i++){\n\t\tP p1=g[i],p2=g[(i+1)%n];\n\t\tres=min(res,getDistanceSP(Segment(p1,p2),p));\n\t}\n\tif(contains(g,p)!=2)res=-res;\n\treturn res;\n}\n\ndouble Cx(Polygon& g, double x){\n\tdouble l=-1.0,r=10001;\n\tfor(int i=0;i<100;i++){\n\t\tdouble ml=(l*2.0+r)/3.0;\n\t\tdouble mr=(l+r*2.0)/3.0;\n\t\tif(getDistancePP(g,P(x,ml))<getDistancePP(g,P(x,mr)))l=ml;\n\t\telse r=mr;\n\t}\n\treturn getDistancePP(g,P(x,l));\n}\n\nint main(void){\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tPolygon g;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tP p;\n\t\t\tscanf(\"%lf%lf\",&p.x,&p.y);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tdouble l=-1.0,r=10001;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tdouble ml=(l*2.0+r)/3.0;\n\t\t\tdouble mr=(l+r*2.0)/3.0;\n\t\t\tif(Cx(g,ml)<Cx(g,mr))l=ml;\n\t\t\telse r=mr;\n\t\t}\n\t\tprintf(\"%.10f\\n\",Cx(g,l));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  if(cross(b-a,c-a) > EPS) return 1;\n  if(cross(b-a,c-a) < -EPS) return -1;\n  if(dot(b-a,c-a) < EPS) return 2;\n  if(abs(b-a) + EPS < abs(c-a)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble area(Poly p){\n  int n = p.size();\n  double s = 0;\n  for(int i = 1; i < n-1; ++i){\n    s += cross(p[i]-p[0],p[i+1]-p[0])/2;\n  }\n  return s;\n}\n\n/*\ndouble solve(Poly p){\n  double s = area(p), l = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    l += abs(p[i]-p[(i+1)%n]);\n  }\n  return 2*s/l;\n}\n*/\n\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double ret = INF;\n  for(int i = 0; i < n; ++i){\n    double t = 0;\n    for(int j = 0; j < n; ++j){\n      t = max(t, p_to_s_dist(p[j],L(p[i],p[(i+1)%n])));\n    }\n    ret = min(ret, t);\n  }\n  return ret;\n}\n*/\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nL angle_bisector(P a, P b, P c){\n  //?§?abc??????????????????\n  //a, b or b, c????????´????????¨????????????????????????RE?????????\n  P p = b + (a-b)/abs(a-b) + (c-b)/abs(c-b);\n  return L(b,p);\n}\n\ndouble solve(Poly p){\n  int n = p.size();\n  vector<L> ab;\n  for(int i = 0; i < n; ++i){\n    ab.push_back(angle_bisector(p[i],p[(i+1)%n],p[(i+2)%n]));\n  }\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = i+1; j < n; ++j){\n      if(norm(cross(ab[i].second-ab[i].first,ab[j].second-ab[j].first)) < EPS) continue;\n      P x = intersection(ab[i],ab[j]);\n      if(in_poly(x,p)) cp.push_back(x);\n    }\n  }\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n\nint main(){\n  int n;\n  double x, y;\n  while(cin >> n, n){\n    Poly p;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    printf(\"%.6lf\\n\",solve(p));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\ntypedef complex<long double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, long double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst long double EPS = 1e-12;\n\ninline bool equal(long double a, long double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  long double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline long double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline long double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\n\nbool intersectSP(const line_t &s, const xy_t &p) {\n  return abs(s.first - p) + abs(s.second - p) - abs(direction(s)) < EPS;\n}\n\nbool intersectSS(const line_t &s, const line_t &t) {\n  return ccw(s, t.first) * ccw(s, t.second) <= 0 &&\n         ccw(t, s.first) * ccw(t, s.second) <= 0;\n}\n\nxy_t projection(const line_t &l, const xy_t &p) {\n  long double t = dot(p - l.first, direction(l)) / norm(direction(l));\n  return l.first + t*(direction(l));\n}\n\nlong double distanceSP(const line_t &s, const xy_t &p) {\n  const xy_t r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.first - p), abs(s.second - p));\n}\n\nlong double distanceSS(const line_t &s, const line_t &t) {\n  if (intersectSS(s, t)) return 0;\n  \n  return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.first), distanceSP(t, s.second)));\n}\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  long double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\nlong double signed_area(const poly_t &poly){\n  long double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\nlong double area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N;\n\n  while (cin >>N && N){\n    poly_t poly(N);\n\n    REP(i, N){\n      cin >> poly[i];\n    }\n\n    long double ub = 1e9;\n    long double lb = 0;\n\n    REP(i, 500){\n      long double mb = (ub + lb) / 2;\n      \n      poly_t tmp_poly = poly;\n      REP(j, poly.size()){\n        line_t line = line_t(poly[j], poly[next_index(poly, j)]);\n        xy_t   vec  = direction(line) / abs(direction(line)) *\n          polar((long double)1., (long double)M_PI / 2);\n        line_t cut_line = line_t(line.first + vec * mb, line.second + vec * mb);\n        tmp_poly = convex_cut(tmp_poly, cut_line);\n      }\n\n      if (area(tmp_poly) > EPS){\n        lb = mb;\n      } else {\n        ub = mb;\n      }\n    }\n    printf(\"%.20lf\\n\", (double)lb);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <complex>\n#include <iostream>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < EPS) return 2;\n  if(abs(b) + EPS < abs(c)) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\ndouble area(Poly p){\n  int n = p.size();\n  double s = 0;\n  for(int i = 1; i < n-1; ++i){\n    s += cross(p[i]-p[0],p[i+1]-p[0])/2;\n  }\n  return s;\n}\n\n/*\ndouble solve(Poly p){\n  double s = area(p), l = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    l += abs(p[i]-p[(i+1)%n]);\n  }\n  return 2*s/l;\n}\n*/\n\n\ndouble p_to_s_dist(P a, L s){\n  if(dot(s.second-s.first,a-s.first) >= 0 && dot(s.first-s.second,a-s.second) >= 0){\n    return abs(cross(s.first-s.second,a-s.second))/abs(s.first-s.second);\n  }\n  return min(abs(a-s.first), abs(a-s.second));\n}\n\ndouble s_to_s_dist(L a, L b){\n  if(is_cross(a,b)) return 0;\n  return min(min(p_to_s_dist(a.first,b),p_to_s_dist(a.second,b)),\n\t     min(p_to_s_dist(b.first,a),p_to_s_dist(b.second,a)));\n}\n\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double ret = INF;\n  for(int i = 0; i < n; ++i){\n    double t = 0;\n    for(int j = 0; j < n; ++j){\n      t = max(t, p_to_s_dist(p[j],L(p[i],p[(i+1)%n])));\n    }\n    ret = min(ret, t);\n  }\n  return ret;\n}\n*/\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  p.push_back(p[0]);\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[i+1]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//辺上\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//内部\n  return 0;//外部\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nL angle_bisector(P a, P b, P c){\n  //角 abc の二等分線\n  //a, b or b, c が一致するとゼロ徐算が発生し RE になる\n  P p = b + (a-b)/abs(a-b)*100.0 + (c-b)/abs(c-b)*100.0;\n  return L(b,p);\n}\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  vector<L> ab;\n  for(int i = 0; i < n; ++i){\n    ab.push_back(angle_bisector(p[i],p[(i+1)%n],p[(i+2)%n]));\n  }\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = i+1; j < n; ++j){\n      if(abs(cross(ab[i].second-ab[i].first,ab[j].second-ab[j].first)) < EPS) continue;\n      P x = intersection(ab[i],ab[j]);\n      if(in_poly(x,p)) cp.push_back(x);\n    }\n  }\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n*/\n\ndouble solve(Poly p){\n  int n = p.size();\n  vector<P> cp;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < i; ++j){\n      for(int k = 0; k < j; ++k){\n        L a(p[i],p[(i+1)%n]), b(p[j],p[(j+1)%n]), c(p[k],p[(k+1)%n]), l1, l2;\n        //cout << i << \" \" << j << \" \" << k << \" : \" ;\n        P a_ = a.second - a.first, b_ = b.second - b.first, c_ = c.second - c.first;\n        if(abs(cross(a_, b_)) < EPS) l1 = L((a.first + b.first)/2.0, (a.first + b.first)/2.0 + a_);\n        else{\n          P t = intersection(a,b);\n          l1 = angle_bisector(t + a_, t, t - b_);\n        }\n        if(abs(cross(b_, c_)) < EPS) l2 = L((b.first + c.first)/2.0, (b.first + c.first)/2.0 + b_);\n        else{\n          P t = intersection(b,c);\n          l2 = angle_bisector(t + b_, t, t - c_);\n        }\n        //cout << l1.first << \" \" << l1.second << \", \" << l2.first << \" \" << l2.second << endl;\n        if(abs(cross(l1.second - l1.first, l2.second - l2.first)) > EPS){\n          P x = intersection(l1, l2);\n          //cout << x << endl;\n          if(in_poly(x, p)){\n            cp.push_back(x);\n          }\n        }\n      }\n    }\n  }\n\n  double ret = 0;\n  for(int i = 0; i < cp.size(); ++i){\n    double t = INF;\n    P x = cp[i];\n    for(int j = 0; j < n; ++j)\n      t = min(t,p_to_s_dist(x,L(p[j],p[(j+1)%n])));\n    ret = max(ret, t);\n  }\n  return ret;\n}\n\nP n_vector(P a){\n  //aベクトルに垂直な単位ベクトル\n  double l = abs(a);\n  return P(-a.Y,a.X)/l;\n}\n\n/*\ndouble solve(Poly p){\n  int n = p.size();\n  double l = 0.0, r = (1e10);\n  for(int i = 0; i < 100000; ++i){\n    //for(int i = 0; i < 3; ++i){\n    double m1 = (l+r)/3, m2 = (l+r)*2/3;\n    Poly q1, q2;\n    for(int j = 0; j < n; ++j){\n      P d1 = n_vector(p[(j+1)%n]-p[j])*m1, d2 = n_vector(p[(j+2)%n]-p[(j+1)%n])*m1;\n      L e1 = L(p[j]+d1,p[(j+1)%n]+d1), e2 = L(p[(j+1)%n]+d2,p[(j+2)%n]+d2);\n      q1.push_back(intersection(e1,e2));\n\n      P d3 = n_vector(p[(j+1)%n]-p[j])*m2, d4 = n_vector(p[(j+2)%n]-p[(j+1)%n])*m2;\n      L e3 = L(p[j]+d3,p[(j+1)%n]+d3), e4 = L(p[(j+1)%n]+d4,p[(j+2)%n]+d4);\n      q2.push_back(intersection(e3,e4));\n    }\n    double s1 = 0, s2 = 0;\n    for(int j = 0; j < n; ++j){\n      s1 += cross(q1[j],q1[(j+1)%n]);\n      s2 += cross(q2[j],q2[(j+1)%n]);\n    }\n    //printf(\"s1 = %.12f, s2 = %.12f\\n\",s1,s2);\n    if(abs(s1) < abs(s2)) r = m2;\n    else l = m1;\n  }\n  return (l+r)/2;\n}\n*/\n\nint main(){\n  int n;\n  double x, y;\n  while(cin >> n, n){\n    Poly p;\n    for(int i = 0; i < n; ++i){\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    printf(\"%.6lf\\n\",solve(p));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      vec v = uvec( (uva + uvb) );\n\n      assert(!prll(a,b));\n      assert(abs(uva)>0&&abs(uvb)>0);\n\n      long double r = 0;\n      for(int j = 0; j < n; ++j){\n        r = max(r,abs(vp[i]-vp[j]));\n      }\n      r = 2*r;\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<300){\n        long double m = (r+l)/2.;\n        point c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    cout << fixed << setprecision(8) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n\nPolygon ConvexCut(const Polygon& g, const Line l)\n{\n\tPolygon res;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l.a, l.b, a) != -1) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0) res.push_back(is_ll(Line(a, b), l));\n\t}\n\treturn res;\n}\n\nvector<Line> move(Line l, ld d)\n{\n\tPoint v = l.b - l.a;\n\tld len = abs(v);\n\tvector<Point> normal = { Point(-v.imag(), v.real()) / len, Point(v.imag(), -v.real()) / len };\n\tvector<Line> res = { Line(l.a + d*normal[0], l.b + d*normal[0]), Line(l.a + d*normal[1], l.b + d*normal[1]) };\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tPolygon g;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tg.emplace_back(x, y);\n\t\t}\n\n\t\tld lb = 0, ub = 10000;\n\t\tREP(i, 1000)\n\t\t{\n\t\t\tld mid = (lb + ub) / 2.0;\n\t\t\tPolygon tmp = g;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tLine l = Line(g[i], g[(i + 1) % n]);\n\t\t\t\tvector<Line> s = move(l, mid);\n\t\t\t\tif (ccw(l.a, l.b, s[0].a) == 1)\n\t\t\t\t{\n\t\t\t\t\ttmp = ConvexCut(tmp, s[0]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp = ConvexCut(tmp, s[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp.empty()) ub = mid;\n\t\t\telse lb = mid;\n\t\t}\n\t\tcout << D10 << lb << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定(平行でない)\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    Polygon P(N);\n    REP(i, N) cin>>P[i];\n    double lb = 0, ub = 1e6;\n    REP(iter, 1000){\n      double mid = (lb + ub) / 2;\n      Polygon Q = P;\n      //cout<<\"mid is \"<<mid<<endl;\n      REP(i, N){\n        Line l(curr(P, i), next(P, i));\n        //cout<<\"l is \"<<l[0]<<\" \"<<l[1]<<endl;\n        Point u = l.vector().rotate90() / l.vector().abs();\n        Line m(l[0] + u * mid, l[1] + u * mid);\n        //cout<<\"m is \"<<m[0]<<\" \"<<m[1]<<endl;\n        Q = convex_cut(Q, m);\n        //cout<<\"Q is \"; REP(i, Q.size()) cout<<Q[i]<<\" \"; cout<<endl;\n      }\n      if(Q.empty()){\n        ub = mid;\n      }else{\n        lb = mid;\n      }\n    }\n    printf(\"%.6lf\\n\", ub);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator/(double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n};\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ntypedef vector<point> polygon;\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\nbool intersect(const segment &s, const point &p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint crosspoint(const segment &s, const segment &t) {\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\treturn t.a + (t.b - t.a) * (cross(s.b - s.a, s.b - t.a) / tmp);\n}\n\ndouble dist(const segment &s, const point &p) {\n\tif(dot(s.b - s.a, p - s.a) < 0) return abs(p - s.a);\n\tif(dot(s.a - s.b, p - s.b) < 0) return abs(p - s.b);\n\treturn abs(cross(s.b - s.a, p - s.a)) / abs(s.b - s.a);\n}\n\nbool contain(const polygon &P, const point &p) {\n\tbool res = false;\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tpoint v1 = prev - p, v2 = curr - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\t\tif(v1.y < EPS && EPS < v2.y && cross(v1, v2) > EPS) res = !res;\n\t\tif(abs(cross(v1, v2)) < EPS  && dot(v1, v2) < EPS) return true;\n\t\tprev = curr;\n\t}\n\treturn res;\n}\n\ndouble dist(const polygon &P, const point &p) {\n\tdouble res = INT_MAX;\n\tpoint prev = P.back();\n\n\tfor(const auto &curr : P) {\n\t\tchmin(res, dist(segment(curr, prev), p));\n\t\tprev = curr;\n\t}\n\n\treturn res;\n}\n\ndouble ternary_search(double L, double R, const function<double(double)> &f) {\n\tfor(int i = 0; i < 80; ++i) {\n\t\tdouble x1 = (L + L + R) / 3.0, x2 = (L + R + R) / 3.0;\n\t\tif(f(x1) < f(x2)) {\n\t\t\tL = x1;\n\t\t}\n\t\telse {\n\t\t\tR = x2;\n\t\t}\n\t}\n\treturn f(L);\n}\n\ndouble search_y(double x, const polygon &P) {\n\tconst segment L(point(x, 0), point(x, 10000));\n\tvector<double> range;\n\n\tpoint prev = P.back();\n\tfor(const auto &curr : P) {\n\t\tconst segment s(prev, curr);\n\t\tif(intersect(L, s)) range.emplace_back(crosspoint(L, s).y);\n\t\tprev = curr;\n\t}\n\n\tsort(range.begin(), range.end());\n\trange.erase(unique(range.begin(), range.end()), range.end());\n\n\tif(range.size() == 0) return -1;\n\treturn ternary_search(range.front(), range.back(), [&](double y){ return dist(P, point(x, y)); });\n}\n\ndouble search_x(const polygon &P) {\n\tdouble L = INT_MAX, R = 0;\n\tfor(const auto &e : P) {\n\t\tchmin(L, e.x);\n\t\tchmax(R, e.x);\n\t}\n\treturn ternary_search(L, R, [&](double x){ return search_y(x, P); });\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(6);\n\n\tfor(int n; cin >> n && n;) {\n\t\tpolygon P(n);\n\t\tfor(auto &e : P) cin >> e.x >> e.y;\n\t\tcout << search_x(P) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\npoint inscribedCircleCenter( point a, point b, point c )\n{\n  long double A = abs( c - b ), B = abs( c - a ), C = abs( b - a );\n  long double S = A + B + C;\n  return (A / S) * a + (B / S) * b + (C / S) * c;\n}\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    point c;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      vec v = uvec( (uva + uvb) );\n\n      assert(!prll(a,b));\n      assert(abs(uva)>0&&abs(uvb)>0);\n\n      long double r = 0;\n      for(int j = 0; j < n; ++j){\n        r = max(r,10*abs(vp[i]-vp[j]));\n      }\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<100){\n        long double m = (r+l)/2.;\n        c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        //cout << m << ' ' << vp[i] << ' ' << c << ' ' << radi << endl;\n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          //cout << dist_seg(s,c) << ' ';\n          if( k == i ) continue;\n          if( k == signed((i-1+vp.size())%vp.size()) ) continue;\n          if( radi > dist_seg(s,c) ){\n            ng = true;\n            break;\n          }\n        }\n        //cout << endl;\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    //cout << c << ' ' << inscribedCircleCenter(vp[0],vp[1],vp[2]) << endl;\n    cout << fixed << setprecision(8) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> res;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) res.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      res.push_back(crossPoint(L(A,B), l));\n  }\n  return res;\n}\n\nbool check(vector<P> G,double d){\n  vector<P> pol=G;\n  int n=G.size();\n  for(int i=0;i<n;i++){\n    P c=(G[(i+1)%n]-G[i]);\n    P a=P(abs(c),d)*(c/abs(c))+G[i];\n    pol=convex_cut(pol,L(a,a+c));\n    if(pol.size()<3)return 0;\n  }\n  return  1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> pol(n);\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,pol[i]=P(x,y);\n    \n    double L=0,M,R=1e4;\n    while(L<R){\n      M=(L+R)/2;\n      if(!check(pol,M)) R=M-EPS;\n      else L=M+EPS;\n    }\n    printf(\"%lf\\n\",L);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\n#include<cassert>\nusing namespace std;\n\ntypedef complex<long double> point,vec;\ntypedef pair<point,point> seg,line;\nconst long double eps = 1e-8;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(long double a, long double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\nlong double dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nlong double cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\nlong double dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\nlong double dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    long double res = 0;\n    for(int i = 0; i < n; ++i){\n      long double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first);\n      vec uvb = uvec(b.second- b.first);\n      assert(abs(uva)>0&&abs(uvb)>0);\n      vec v = uvec( (uva + uvb) );\n      \n      long double r = 1e9;\n      long double l = 0;\n      int cnt = 0;\n      long double radi;\n      while(cnt++<1000){\n        long double m = (r+l)/2.;\n        point c = m * v + vp[i];\n        bool ng = false;\n        \n        radi = dist_l(a,c);\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c)+eps ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          res = max( res, radi );\n          l = m;\n        }\n      }\n\n    }\n    cout << fixed << setprecision(6) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定(平行でない)\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    Polygon P(N);\n    REP(i, N) cin>>P[i];\n    double lb = 0, ub = 1e6;\n    REP(iter, 100){\n      double mid = (lb + ub) / 2;\n      Polygon Q = P;\n      //cout<<\"mid is \"<<mid<<endl;\n      REP(i, N){\n        Line l(curr(P, i), next(P, i));\n        //cout<<\"l is \"<<l[0]<<\" \"<<l[1]<<endl;\n        Point u = l.vector().rotate90() / l.vector().abs();\n        Line m(l[0] + u * mid, l[1] + u * mid);\n        //cout<<\"m is \"<<m[0]<<\" \"<<m[1]<<endl;\n        Q = convex_cut(Q, m);\n        //cout<<\"Q is \"; REP(i, Q.size()) cout<<Q[i]<<\" \"; cout<<endl;\n      }\n      if(Q.empty()){\n        ub = mid;\n      }else{\n        lb = mid;\n      }\n    }\n    printf(\"%.6lf\\n\", ub);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ninline double cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ninline double dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\ninline double distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint n;\nP ps[128];\nL es[128];\n\nP innerCenter(P a, P b, P c){\n    double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);\n    return (la*a+lb*b+lc*c)/(la+lb+lc);\n}\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g = (ps[0] + ps[n/3] + ps[2*n/3]) / 3.0;\n    int a = 0, b = n;\n    while (a+1 < b) {\n        int c = (a + b) / 2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    // これがないとTLEするかも\n    if(n==3)return distanceLP(es[0],p);\n\n    double const r[]={10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7};\n    double static d[128];\n    int near=0;\n    rep(t,90000){\n        rep(i,n){\n            d[i]=distanceLP(es[i],p);\n        }\n        near=0;\n        rep(i,n)if(d[i]<d[near]){\n            near=i;\n        }\n        P h=projection(es[near],p);\n        P np=p-(h-p)/d[near]*r[t/10000];\n        if(convex_contains(np)==IN){\n            swap(p,np);\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<windows.h>\nusing namespace std;\n\n\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-7;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n/*\n  ?????????????????????\n  a.real() * b.real() + a.imag() * b.imag()\n*/\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\n\n/*\n  ?????????????????????\n  a.real() * b.imag() - a.imag() * b.real()\n*/\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\n\n// ???????????? a,b ???????????¢???\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\n// ????????¨???????????¢\ndouble getDistanceSP(L s, P p){\n  if(dot(s.second - s.first, p - s.first) < -EPS) return abs(p - s.first);\n  if(dot(s.first - s.second, p - s.second) < -EPS) return abs(p - s.second);\n  return abs(cross(s.second - s.first, p - s.first) / abs(s.second - s.first));  //??´?????¨???????????¢\n}\n\n/* \n   ???????§???¢???????????????????????????????§???¢????????¨????¢????????????¨???????????????????????? \n   ????????? 0:?????¨ 1:?¢???? 2:?????¨ \n   ???????¨?????????§????????¨??????????????? \n   O(log n) \n*/\nint convex_contains(vector<P> v, P p){ \n  int n = v.size(); \n  P g = (v[0] + v[n/3] + v[2*n/3]) / 3.0; \n  int a = 0, b = n; \n  while(a + 1 < b){ \n    int c = (a + b) / 2; \n    if(cross(v[a] - g, v[c] - g) > 0){ \n      if(cross(v[a]-g, p-g) > 0 && cross(v[c]-g, p-g) < 0) b = c; \n      else a = c; \n    } else { \n      if(cross(v[a]-g, p-g) < 0 && cross(v[c]-g, p-g) > 0) a = c; \n      else b = c; \n    } \n  } \n  b %= n; \n  if(cross(v[a] - p, v[b] - p) < 0) return 0; \n  if(cross(v[a] - p, v[b] - p) > 0) return 2; \n  return 1; \n} \n \n\nint N;\nvector<P> v;\n\nconst double WPS = 35.0;\nconst double BPS = 10.0;\n\nint main(){\n  while( (~scanf(\"%d\",&N)) && N ){\n    v.clear();\n    double sx=1e19,sy=1e19,ex=-1e19,ey=-1e19;\n    for(int i=0;i<N;i++) {\n      int x,y;\n      scanf(\"%d%d\",&x,&y); v.push_back( P(x,y) );\n      sx = min( (double)x, sx ), sy = min ( (double)y , sy );\n      ex = max( (double)x, ex ), ey = max ( (double)y , ey );\n    }\n\n    double wx = (ex-sx)/WPS;\n    double wy = (ey-sy)/WPS;\n    double res;\n    for(;wx>EPS&&wy>EPS;){\n      res = 0.0;\n      P ns = P((ex+sx)/2.0,(ey+sy)/2.0);\n      for(double x=sx;x<ex;x+=wx){\n\tfor(double y=sy;y<ey;y+=wy){\n\t  P c = P(x + wx/2.0,y + wy/2.0);\n\t  double ret = 1e19;\n\t  if( convex_contains( v, c ) == 0 ) continue;\n\t  for(int k=0;k<N;k++){\n\t    L s = L( v[k] , v[(k+1)%N] );\n\t    ret = min( ret , getDistanceSP(s,c) );\n\t  }\n\t  //\t  cout << c <<  \" \" << \" ret : =  \" << ret << endl;\n\t  if( ret > res ){\n\t    res = ret;\n\t    ns = c; \n\t  }\n\t}\n      }\n      //  cout << ns << \" res = \" << res << endl;\n      //printf(\"(%lf,%lf) - (%lf,%lf) : (%lf,%lf)\\n\",sx,sy,ex,ey,wx,wy);\n      //   Sleep(1000);\n      sx = ns.real()-wx*BPS; sy = ns.imag()-wy*BPS;\n      ex = ns.real()+wx*BPS; ey = ns.imag()+wy*BPS;\n      wx = (ex-sx)/WPS; wy = (ey-sy)/WPS;\n  \n    }\n\n    printf(\"%.8lf\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n \nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n \n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n \n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \n \ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n \nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps && abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n \nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n \ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n \nPoint rotationPoint(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n \nLine Parallelmove(Line L,double dis){\n  Vector v1,v2;\n  v1=(rotationPoint(L.p1,L.p2,90)-L.p1);\n  v2=(rotationPoint(L.p2,L.p1,270)-L.p2);\n  v1=(v1/abs(v1))*dis;\n  v2=(v2/abs(v2))*dis;\n  return Line(L.p1+v1,L.p2+v2);\n}\n \nint n;\nPolygon p;\n \nbool ok(double mid){\n  Polygon cp=p;\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    L=Parallelmove(L,mid);\n    cp=convex_cut(cp,L);\n  }\n  if(cp.size()>=3)return true;\n  return false;\n}\nint main()\n{\n  int x,y;\n \n  while(1){\n    cin>>n;\n    if(n==0)break;\n    p.clear();\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      p.push_back(Point(x,y));\n    }\n \n    double r=1<<30,l=0,mid;\n    for(int i=0;i<100;i++){\n      mid=(r+l)/2;\n      if(ok(mid))l=mid;\n      else r=mid;\n    }\n    printf(\"%.10f\\n\",mid);\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#define REP rep\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t/*\n\ttemplate<class QF = function<T(T, T)>>\n\tauto query(int a, int b, int k, int l, int r,QF qf) {\n\tif (r <= a || b <= l)return e;\n\tif (a <= l && r <= b)return obj[k];\n\telse return qf(query(a, b, k * 2 + 1, l, (l + r) / 2, qf), query(a, b, k * 2 + 2, (l + r) / 2, r, qf));\n\t}*/\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}/*\n\t template<class QF = function<T(T, T)>>\n\t auto query(int a, int b,QF &&qf) {//[a,b)\n\t return query(a, b, 0, 0, offset + 1,qf);\n\t }*/\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\n\tint n;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T = int>\nclass rangeadd {\n\tBIT<T> b0, b1;\npublic:\n\trangeadd(int n) :b0(n), b1(n) {};\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x*(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\tif (i < 0)return 0;\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n\tT sum(int l, int r) {\n\t\treturn sum(r - 1) - sum(l - 1);\n\t}\n};\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\npublic:\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//end of lib\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tVP p(n);\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tp[i] = { x,y };\n\t\t}\n\t\tdouble ans = 1e9;\n\t\tvector<L> l(n);\n\t\trep(i, n)l[i] = { p[i],p[(i + 1) % n] };\n\t\trep(i, n)rep(j, i)rep(k, j) {\n\t\t\tP a = is_ll(l[i], l[j]), b = is_ll(l[j], l[k]), c = is_ll(l[k], l[i]);\n\t\t\tif (ccw(a, b, c) != 0 && ccw(a, b, c) != ccw(l[i].a, l[j].a, l[k].a))continue;\n\t\t\tdouble t1 = atan2((l[i].a - l[i].b).imag(), (l[i].a - l[i].b).real()), t2 = atan2((l[j].a - l[j].b).imag(), (l[j].a - l[j].b).real()), t3 = atan2((l[k].a - l[k].b).imag(), (l[k].a - l[k].b).real());\n\t\t\tt2 = (t1 + t2) / 2;\n\t\t\tt3 = (t1 + t3) / 2;\n\t\t\tL l1 = (isis_ls(L{ a,a + 1e5l*P(cos(t2),sin(t2)) }, L{ b,c })) ? L{ a,a + 1e5l*P(cos(t2),sin(t2)) } : L{ a,a + 1e5l*P(-sin(t2),cos(t2)) };\n\t\t\tL l2 = (isis_ls(L{ c,c + 1e5l*P(cos(t3),sin(t3)) }, L{ a,b })) ? L{ c,c + 1e5l*P(cos(t3),sin(t3)) } : L{ c,c + 1e5l*P(-sin(t3),cos(t3)) };\n\t\t\tcmin(ans, dist_lp(l[i], is_ll(l1, l2)));\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\n// 直線lと直線mが交点を持つか\nbool isis_ll(L l, L m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > eps ||\n    abs(cross(l.b - l.a, m.a - l.a)) < eps;\n}\n\n// 点pから直線lに下ろした垂線の足\nP proj(L l, P p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\n// 直線lと点pの距離\nld dist_lp(L l, P p) {\n  return abs(p - proj(l, p));\n}\n\n// 直線sと直線lの交点\nVP is_ll(L s, L t){\n  VP v;\n  P sv = s.b - s.a, tv = t.b - t.a;\n  if (abs(cross(sv,tv)) > 0)\n    v.push_back(s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv));\n  return v;\n}\n\n// 点pが線分s上に存在するか\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\n// 頂点から内心を求める\nP ic(P a, P b, P c) {\n  ld la = abs(b-c);\n  ld lb = abs(c-a);\n  ld lc = abs(a-b);\n  return 1/(la+lb+lc)*(la*a+lb*b+lc*c);\n}\n\n// 3辺から内心を求める\nP ic_l(L a,L b,L c) {\n  if(!isis_ll(a,b)) {\n    ld r = dist_lp(a,b.a) / 2.0;\n    L m((a.a + b.a)/P(2,0),(a.a + b.b)/P(2,0));\n    P ar = c.a - c.b;\n    ar /= abs(ar);\n    P p1 = ar * P(0,r);\n    P p2 = ar * P(0,-r);\n    L c1(c.a+p1, c.b+p1);\n    L c2(c.a+p2, c.b+p2);\n    VP cx1 = is_ll(m,c1);\n    VP cx2 = is_ll(m,c2);\n    P h=proj(c,cx1[0]);\n    if(isis_sp(c1,h)) return cx1[0];\n    return cx2[0];\n  } else if (!isis_ll(b,c)) {\n    return ic_l(b,c,a);\n  } else if (!isis_ll(c,a)) {\n    return ic_l(c,a,b);\n  }\n  P pa = is_ll(b,c)[0];\n  P pb = is_ll(c,a)[0];\n  P pc = is_ll(a,b)[0];\n  return ic(pa,pb,pc);\n}\n\nint main() {\n  while(1){\n    int n;\n    cin >> n;\n    if(!n) break;\n    VP vp;\n    REP(i,n) {\n      ld x,y;\n      cin >> x >> y;\n      vp.emplace_back(x,y);\n    }\n    ld rmax = 0.0;\n    REP(i,n)REP(j,n)REP(k,n){\n      if(i==j)break;\n      if(i==k||j==k)continue;\n      L l1(vp[i],vp[(i+1)%vp.size()]);\n      L l2(vp[j],vp[(j+1)%vp.size()]);\n      L l3(vp[k],vp[(k+1)%vp.size()]);\n      P ip = ic_l(l1,l2,l3);\n      if(!(isis_sp(l1,proj(l1,ip)) && isis_sp(l2,proj(l2,ip)) && isis_sp(l3,proj(l3,ip))))continue;\n      if(dist_lp(l1, ip) < rmax) continue;\n      bool valid = true;\n      REP(l,n){\n        L l4(vp[l], vp[(l+1)%vp.size()]);\n        if(dist_lp(l4, ip) < dist_lp(l1, ip)) {\n          valid = false;\n          break;\n        }\n      }\n      if(valid) rmax = dist_lp(l1,ip);\n    }\n    cout << fixed << setprecision(6) << rmax << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ndouble const eps=1e-8;\ndouble const inf = 1e10;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ninline double cross(const P& a, const P& b){return imag(conj(a)*b);}\ninline double dot(const P& a, const P& b){return real(conj(a)*b);}\nstruct L : public vector<P> {\n    L(const P &a, const P &b){push_back(a); push_back(b);}\n    L(){}\n};\nP projection(const L &l, const P &p){double t = dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);return l[0]+t*(l[0]-l[1]);}\ninline double distanceLP(const L &l, const P &p){return abs(p-projection(l, p));}\nP innerCenter(P a, P b, P c){double la=abs(b-c), lb=abs(c-a), lc=abs(a-b);return (la*a+lb*b+lc*c)/(la+lb+lc);}\n\nint n;\nP ps[128];\nL es[128];\n\nenum { OUT, ON, IN };\nint convex_contains(const P &p) {\n    P g=(ps[0]+ps[n/3]+ps[2*n/3])/3.0;\n    int a=0,b=n;\n    while (a+1 < b) {\n        int c=(a+b)/2;\n        if (cross(ps[a]-g, ps[c]-g) > 0) {\n            if (cross(ps[a]-g, p-g) > 0 && cross(ps[c]-g, p-g) < 0) b = c;\n            else                                                    a = c;\n        } else {\n            if (cross(ps[a]-g, p-g) < 0 && cross(ps[c]-g, p-g) > 0) a = c;\n            else                                                    b = c;\n        }\n    }\n    b %= n;\n    if (cross(ps[a] - p, ps[b] - p) < 0) return 0;\n    if (cross(ps[a] - p, ps[b] - p) > 0) return 2;\n    return 1;\n}\n\ndouble solve(){\n    rotate(ps,ps+rand()%n,ps+n);\n    ps[n]=ps[0];\n    rep(i,n){\n        es[i]={ps[i],ps[i+1]};\n    }\n    P p=innerCenter(ps[0],ps[n/3],ps[n/3*2]);\n\n    if(n==3)return distanceLP(es[0],p);\n\n    double const r[]={100,10,1,1e-1,1e-2,1e-3,1e-4,1e-5,1e-6,1e-7,1e-8};\n    double static d[128];\n    int near=0;\n    rep(t,11){\n        rep(u,3000){\n            rep(i,n)d[i]=distanceLP(es[i],p);\n            near=0;\n            rep(i,n)if(d[i]<d[near])near=i;\n            P h=projection(es[near],p);\n            P np=p-(h-p)/d[near]*r[t];\n            if(convex_contains(np)==IN){\n                swap(p,np);\n            } else {\n                break;\n            }\n        }\n    }\n    return d[near];\n}\n\nint main(){\n    srand(time(0));\n    while(cin>>n && n){\n        rep(i,n){\n            double x,y;\n            scanf(\"%lf%lf\",&x,&y);\n            ps[i]=P(x,y);\n        }\n        printf(\"%lf\\n\",solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef complex<double> point,vec;\ntypedef pair<point,point> seg,line;\nconst double eps = 1e-9;\nenum CCW{BACK=0x01,FRONT=0x02,RIGHT=0x04,LEFT=0x08,OVER=0x10};\n\nbool eq(double a, double b){\n  return abs(b-a) < eps;\n}\n\nvec uvec(const vec &v){\n  return v / abs(v);\n}\ndouble dot(const point &a, const point &b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\ndouble cross(const point &a, const point &b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline int ccw(const point &a, point b, point x){\n  b-=a;\n  x-=a;\n  if(eq(cross(b,x),0) && dot(b,x)<0 ) return BACK;\n  if(eq(cross(b,x),0) &&abs(b)<abs(x))return FRONT;\n  if(eq(cross(b,x),0))return OVER;\n  if(cross(b,x)>0)return LEFT;\n  return RIGHT;\n}\n\nbool prll(const line &a,const line &b){\n  return eq(cross( a.second-a.first,b.second-b.first),0);\n}\n\npoint intersectionLL(const line &a, const line &b){\n  vec va = a.second - a.first;\n  vec vb = b.second - b.first;\n  return a.first + va * ( cross(vb,b.first-a.first) / cross( vb,va ) );\n}\n\ndouble dist_l(const line &l, const point &x){\n  return abs(cross(l.second-l.first,x-l.first))/abs(l.second-l.first);\n}\n\ndouble dist_seg(const seg &s, const point &x){\n  if( dot(s.second-s.first,x-s.first) < 0 ) return abs(x-s.first);\n  if( dot(s.first-s.second,x-s.second) < 0 ) return abs(x-s.second);\n  return dist_l(s,x);\n}\n\nbool insimple(const point &x, const vector<point> &p){\n  int cnt = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    point a=p[i]-x,b=p[(i+1)%n]-x;\n    if(b.imag()>a.imag())swap(a,b);\n    int cw=ccw(a,b,point(0,0));\n    if(cw==LEFT&&0<=a.imag() &&b.imag()<0)++cnt;\n    if(cw==OVER)return true;\n  }\n  if(cnt&1)return true;\n  return false;\n}\n\nint main()\n{\n  int n;\n  while(cin>>n && n){\n    vector<point> vp;\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      double x, y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    for(int i = 0; i < n; ++i){\n      line a( vp[i], vp[(i+1)%vp.size()] );\n      line b( vp[i], vp[(i-1+vp.size())%vp.size()] );\n      bool prl = prll(a,b);\n      if( prl ) continue;\n      vec uva = uvec(a.second- a.first );\n      vec uvb = uvec( b.second- b.first );\n      vec v = uvec( (uva + uvb) );\n      point cr = intersectionLL(a,b);\n      \n      double r = 1e10;\n      double l = 0;\n      int cnt = 0;\n      double radi;\n      while(cnt++<100){\n        double m = (r+l)/2.;\n        point c = m * v + cr;\n        radi = dist_l(a,c);\n        bool ng = false;\n\n        if( !insimple(c,vp) ){\n          r = m;\n          continue;\n        }\n        //cout << a.first << ' ' << m << ' ' << c  << endl;\n        \n        for(int k = 0; k < n; ++k){\n          seg s(vp[k],vp[(k+1)%vp.size()]);\n          if( radi > dist_seg(s,c)+eps ){\n            ng = true;\n            break;\n          }\n        }\n        \n        if( ng ){\n          r = m;\n        }else{\n          l = m;\n        }\n      }\n      res = max( res, radi );\n    }\n    cout << fixed << setprecision(12) << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-9;\ninline D dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\treturn -1;\n}\ninline P perp(L l,P p){\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline bool iSP(L s,P p){\n\tP a=s.fs,b=s.sc,c=p;\n\treturn abs(abs(a-c)+abs(c-b)-abs(a-b))<eps;\n}\ninline D dSP(L s,P p){\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline bool iLSex(L l, L s){\t\t//intersect(excluding endpoint)\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<-eps;\n}\ninline P intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\ninline Pol convexcut(Pol p,L l){\t//left\n\tPol ret;\n\trep(i,p.size()){\n\t\tif(ccw(l.fs,l.sc,p[i])!=-1) ret.pb(p[i]);\n\t\tL s=L(p[i],p[(i+1)%p.size()]);\n\t\tif(iLSex(l,s)) ret.pb(intLL(l,s));\n\t}\n\treturn ret;\n}\nint N;\nPol pol,polc;\nP p[100];\nbool check(D m){\n\trep(i,N){\n\t\tP a=p[i],b=p[(i+1)%N];\n\t\tP x=(b-a)*P(0,1);\n\t\tx=x/abs(x)*m;\n\t\tL l=L(a+x,b+x);\n\t\tpol=convexcut(pol,l);\n\t}\n\treturn pol.size()==0;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tpol.clear();\n\t\trep(i,N){\n\t\t\tint xx,yy;\n\t\t\tcin>>xx>>yy;\n\t\t\tp[i]=P(xx,yy);\n\t\t\tpol.pb(p[i]);\n\t\t}\n\t\tpolc=pol;\n\t\tD ub=10000,lb=0;\n\t\trep(tt,40){\n\t\t\tpol=polc;\n\t\t\tD m=(ub+lb)/2;\n\t\t\tif(check(m)) ub=m;\n\t\t\telse lb=m;\n\t\t}\n\t\tprintf(\"%.12f\\n\",ub);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n#define double long double\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n}\n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n\n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n\n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }\n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n\n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }\n  }\n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n\n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }\n  }\n\n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Polygon ps(n);\n    for(int i=0;i<n;i++) cin>>ps[i];\n\n    using D = double;\n    auto check=\n      [&](D d)->int{\n        Polygon qs(ps);\n        for(int i=0;i<n;i++){\n          Line l(ps[i],ps[(i+1)%n]);\n          auto v=translate(l.p2-l.p1,PI/2);\n          l.p1=l.p1+v/abs(v)*d;\n          l.p2=l.p2+v/abs(v)*d;\n          qs=convexCut(qs,l);\n        }\n        return area(qs)>0;\n      };\n\n    D L=0,R=1e9;\n    for(int k=0;k<200;k++){\n      D M=(L+R)/2;\n      if(check(M)) L=M;\n      else R=M;\n    }\n    cout<<L<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const  {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju,laglanju+(abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\nREP(j, tup[i].size()) {\n\tld angle; int pos = j, from = i, to; bool flag;\n\ttie(angle, to, flag) = tup[i][j];\n\tif (flag) continue;\n\tvector<int> ps;\n\twhile (!flag) {\n\t\tps.push_back(from);\n\t\tget<2>(tup[from][pos]) = true;\n\t\tseg2p[from][to].push_back(polygon.size());\n\t\tseg2p[to][from].push_back(polygon.size());\n\t\tangle += pi + eps;\n\t\tif (angle > pi) angle -= 2 * pi;\n\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\tpos = it - tup[from].begin();\n\t}\n\tpolygon.push_back(ps);\n}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tvector<Line>lines;\n\t\tvector<int>perm;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlines.emplace_back(origin[i],origin[(i + 1) % n]);\n\t\t\tperm.push_back(i);\n\t\t}\n\t\tlong double maxdis = 0;\n\t\tvector<vector<Line>>bis(n, vector<Line>(n));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\telse {\n\t\t\t\t\tif (isis_ll(lines[i], lines[j])) {\n\t\t\t\t\t\tbis[i][j] = bisection(lines[i], lines[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tint a = perm[0], b = perm[1], c = perm[2];\n\t\t\tvector<Line>edges;\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tedges.emplace_back(lines[perm[i]]);\n\t\t\t}\n\t\t\tif (!isis_ll(edges[0], edges[2])) {\n\t\t\t\tswap(edges[0], edges[1]);\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\telse if (!isis_ll(edges[0], edges[1]) ){\n\t\t\t\tswap(edges[0], edges[2]);\n\t\t\t\tswap(a, c);\n\t\t\t}\n\t\t\tvector<Line>nlines;\n\t\t\tnlines.emplace_back(bis[a][b]);\n\t\t\tnlines.emplace_back(bis[a][c]);\n\t\t\tPoint ncenter(is_ll(nlines[0], nlines[1]));\n\t\t\tif (convex_contains(origin, ncenter)) {\n\t\t\t\tlong double mindis = 22222;\n\t\t\t\tfor (int i = 0; i < lines.size(); ++i) {\n\t\t\t\t\tlong double adis = dist_sp(lines[i], ncenter);\n\t\t\t\t\tif (mindis > adis) {\n\t\t\t\t\t\tmindis = adis;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxdis = max(maxdis, mindis);\n\t\t\t}\n\t\t\t\n\t\t} while (next_combination(perm.begin(), perm.begin() + 3, perm.end()));\n\n\t\tcout << setprecision(22)<<maxdis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n\nstruct Point {\n    double x, y;\n\n    Point(){}\n    Point(double x, double y) : x(x), y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x, y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x, y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k, y*k); }\n    Point operator / (const double &k)const{ return Point(x/k, y/k); }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x*b.y - b.x*a.y;\n}\n\ndouble norm(const Point &p){\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2));\n}\n\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS)  return +1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS)   return +2; \n    if (norm(a) < norm(b))  return -2;\n    return +0;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\ndouble area(const Polygon &pg)\n{\n    double res = 0;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tres += cross(pg[i], next(pg, i));\n    }\n    return abs(res)/2.0;\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n\tPoint cp = curr(pg,i), np = next(pg,i);\n\tif (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n\tif (ccw(l.s, l.t, cp)*ccw(l.s, l.t, np) < 0) {\n\t    res.push_back(crosspointLL(Line(cp, np), l));\n\t}\n    }\n    return res;\n}\n\nvector<Vector> normal_line_vector(const Line &l)\n{\n    vector<Vector> vs;\n    Vector v = l.t - l.s, p = v / abs(v);\n    vs.push_back(Point(-p.y, p.x));\n    vs.push_back(Point(p.y, p.x));\n    return vs;\n}\n\nvector<Line> translation(const Line &l, double d)\n{\n    vector<Vector> nlv = normal_line_vector(l);\n    vector<Line> nl;\n    nl.push_back(Line(l.s + nlv[0]*d, l.t + nlv[0]*d));\n    nl.push_back(Line(l.s + nlv[1]*d, l.t + nlv[1]*d));\n    return nl;\n}\n\nbool c(double d, const Polygon &pg)\n{\n    Polygon p = pg;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Line l(curr(pg, i), next(pg, i)), ll;\n        vector<Line> nl = translation(l, d);\n        ll = (ccw(l.s, l.t, nl[0].s) == 1 ? nl[0] : nl[1]);\n        p = convex_cut(p, ll);\n    }\n    return (area(p) > 0);\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        Polygon pg(n);\n        for (int i = 0; i < n; i++) {\n            cin >> pg[i].x >> pg[i].y;\n        }\n\n        double l = 0, r = 10000;\n        for (int i = 0; i < 200; i++) {\n            double mid = (l + r) / 2;\n            if (c(mid, pg)) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n        printf(\"%.8f\\n\", r);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tdouble l=0,r=10010;\n\t\twhile(r-l>EPS){\n\t\t\tdouble h=(l+r)/2;\n\t\t\tG t=g;\n\t\t\tbool H=true;\n\t\t\trep(i,n){\n\t\t\t\tL w(g[i],g[(i+1)%n]);\n\n\t\t\t\tdouble mi=inf,ma=-inf;\n\t\t\t\trep(j,t.size()){\n\t\t\t\t\tdouble dis=distanceLP(w,t[j]);\n\t\t\t\t\tcmin(mi,dis);\n\t\t\t\t\tcmax(ma,dis);\n\t\t\t\t}\n\t\t\t\tif(ma<h){\n\t\t\t\t\tH=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h<mi)continue;\n\n\t\t\t\tP p=w[1]-w[0];\n\t\t\t\tp*=P(0,1);\n\t\t\t\tp/=abs(p);\n\t\t\t\tp*=h;\n\t\t\t\tw[0]+=p;w[1]+=p;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt=convex_cut(t,w);\n\t\t\t// cout<<endl;\n\t\t\t// cout<<l<<\" \"<<h<<\" \"<<r<<\" \"<<H<<endl;\n\t\t\t// rep(j,t.size())cout<<t[j].real()<<\" \"<<t[j].imag()<<endl;\n\t\t\t}\n\t\t\tif(H)l=h;\n\t\t\telse r=h;\n\t\t}\n\t\tcout<<shosu(9)<<l<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ???§ ????????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ???§ ?????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b???§??????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c???§??????´??????\n    return 0;  // a -- c -- b???§??????´??????\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nusing namespace Geometory;\n\nPolygon data;\n\nbool isable(double v)\n{\n  Polygon ret = data;\n  for(int i = 0; i < data.size(); i++) {\n    Point point = next(data, i) - curr(data, i);\n    point = (point * v / point.abs()).rotate90();\n    ret = Convex_Cut(ret, Line(curr(data, i) + point, next(data, i) + point));\n  }\n  return (!ret.empty());\n}\n\nint main()\n{\n  int N;\n  cout << fixed << setprecision(10);\n  while(cin >> N, N) {\n    data.resize(N);\n    for(int i = 0; i < N; i++) cin >> data[i];\n    double low = 0, high = 1e4;\n    for(int i = 0; i < 40; i++) {\n      double mid = (low + high) * 0.5;\n      if(isable(mid)) low = mid;\n      else high = mid;\n    }\n    cout << low << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nlong double getdis(vector<Line>&l, vector<Line>&r) {\n\tlong double amin = 9999999999;\n\tfor (int i = 0; i < 5; ++i) {\n\t\tfor (int j = 0; j < 5; ++j) {\n\t\t\tamin = min(dist_ss(l[i], r[j]), amin);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main() {\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tPolygon origin;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\torigin.emplace_back(x, y);\n\t\t}\n\t\tPolygon npoly(origin);\n\t\tconst int atime = 2000;\n\t\tfor (int repeat = 0; repeat <=atime; ++repeat) {\n\t\t\tconst Polygon prepoly(npoly);\n\t\t\tPoint center;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tcenter += npoly[i];\n\t\t\t}\n\t\t\tcenter /= npoly.size();\n\t\t\tlong double mindis = 20000;\n\t\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\t\tmindis = min(mindis, dist_sp(Line(npoly[i], npoly[(i + 1) % npoly.size()]), center));\n\t\t\t}\n\n\n\t\t\tfor (int i = 0; i < prepoly.size(); ++i) {\n\t\t\t\tLine preline = Line(prepoly[i], prepoly[(i + 1) % prepoly.size()]);\n\t\t\t\tPoint vec = (preline[1] - preline[0])*complex<long double>(0, 1)/abs(preline[1]-preline[0])*mindis;\n\t\t\t\tLine cutline[2];\n\t\t\t\tcutline[1] = Line(preline[0] + vec, preline[1] + vec);\n\t\t\t\tcutline[0] = Line(preline[0] - vec, preline[1] - vec);\n\n\t\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\t\tvector<Polygon>polys(convex_cut(npoly, cutline[i]));\n\t\t\t\t\tif (is_in_polygon(polys[0], center)) {\n\t\t\t\t\t\tnpoly = polys[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnpoly = polys[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst Polygon prepoly(npoly);\n\t\tPoint center;\n\t\tfor (int i = 0; i < npoly.size(); ++i) {\n\t\t\tcenter += npoly[i];\n\t\t}\n\t\tcenter /= npoly.size();\n\t\tlong double mindis = 20000;\n\t\tfor (int i = 0; i < origin.size(); ++i) {\n\t\t\tmindis = min(mindis, dist_sp(Line(origin[i], origin[(i + 1) % origin.size()]), center));\n\t\t}\n\t\tcout << fixed<<setprecision(22)<<mindis << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1283 Most Distant Point from the Sea\n// 2018.3.3 bal4u\n \n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define LIM 40\n#define EPS 1e-8\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG;\n\nPP p[101], po[2][500];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vadd(PP p1, PP p2) { PP r; r.x = p1.x + p2.x, r.y = p1.y + p2.y; return r; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\nPP vsmul(PP p, double k) { PP r; r.x = p.x * k, r.y = p.y * k; return r; }\nPP vsdiv(PP p, double k) { PP r; r.x = p.x / k, r.y = p.y / k; return r; }\nPP vmul(PP p1, PP p2) { PP r;\n\tr.x = p1.x * p2.x - p1.y * p2.y, r.y = p1.x * p2.y + p1.y * p2.x; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\nint ccw(PP p0, PP p1, PP p2) { PP a, b;\tdouble t;\n\ta = vsub(p1, p0), b = vsub(p2, p0), t = cross(a, b);\n\tif (t >  EPS) return 1;\tif (t < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\n\n// 線分と点の距離\ndouble getDistanceSP(SEG s, PP p) {\n\tif (dot(vsub(s.e, s.s), vsub(p, s.s)) < -EPS) return vabs(vsub(p, s.s));\n\tif (dot(vsub(s.s, s.e), vsub(p, s.e)) < -EPS) return vabs(vsub(p, s.e));\n\treturn fabs(cross(vsub(s.e, s.s), vsub(p, s.s))) / vabs(vsub(s.e, s.s));\n}\n\n// ２線分間の交点\nPP crossPointS2P(SEG a, PP bs, PP be) { double a1, a2; PP r;\n\ta1 = cross(vsub(be, bs), vsub(a.s, bs));\n\ta2 = cross(vsub(be, bs), vsub(a.e, bs));\n\tr.x = (a.s.x*a2 - a.e.x*a1) / (a2-a1);\n\tr.y = (a.s.y*a2 - a.e.y*a1) / (a2-a1);\n\treturn r;\n}\nPP crossPointSS(SEG a, SEG b) {\treturn crossPointS2P(a, b.s, b.e); }\n\n// 凸包を直線で切断して左側をpo[]に残す\nint convex_cut(SEG u, int n, PP *p, PP *po)\t\t// p --> po\n{\n\tint i, d1, d2, top = 0;\n    for (i = 0; i < n; i++) {\n        d1 = dcmp(cross(vsub(u.e, u.s), vsub(p[i],   u.s)));\n        d2 = dcmp(cross(vsub(u.e, u.s), vsub(p[i+1], u.s)));\n        if (d1 >= 0) po[top++] = p[i];\n        if (d1*d2 < 0) po[top++] = crossPointS2P(u, p[i], p[i+1]);\n    }\n\tpo[top] = po[0];\n    return top;\n}\n\n//直線の単位法線ベクトル\nvoid unitnormalv(SEG *ans, SEG a) {\n\tPP t; double k = vabs(vsub(a.e, a.s));\n\tt.x = 0, t.y =  1; ans->s = vsdiv(vmul(vsub(a.e, a.s), t), k);\n\tt.x = 0, t.y = -1; ans->e = vsdiv(vmul(vsub(a.e, a.s), t), k);\n}\n\n//線分を距離dだけ平行移動\nvoid parallelShift(SEG *ans, SEG a, double d) {\n\tSEG r; unitnormalv(&r, a);\n\tans[0].s = vadd(a.s, vsmul(r.s, d));\n\tans[0].e = vadd(a.e, vsmul(r.s, d));\n\tans[1].s = vadd(a.s, vsmul(r.e, d));\n\tans[1].e = vadd(a.e, vsmul(r.e, d));\n}\n\nint main()\n{\n\tint n, i, j, k, k1, k2;\n\tdouble lo, hi, mi;\n\tSEG a, sft[2];\n\n\twhile(n = in()) {\n\t\tfor (i = 0; i < n; i++) p[i].x = in(), p[i].y = in();\n\t\tp[n] = p[0];\n\n\t\tlo = 0, hi = 10000;\n\t\tfor (i = 0; i < LIM; i++) {\n\t\t\tmi = 0.5*(lo + hi);\n\t\t\tmemcpy(po[0], p, sizeof(PP)*(n+1));\n\t\t\tk = n, k1 = 0, k2 = 1;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\ta.s = p[j], a.e = p[j+1];\n\t\t\t\tparallelShift(sft, a, mi);\n\t\t\t\tif (ccw(p[j], p[j+1], sft[0].s) == 1)\n\t\t\t\t\t k = convex_cut(sft[0], k, po[k1], po[k2]);\n\t\t\t\telse k = convex_cut(sft[1], k, po[k1], po[k2]);\n\t\t\t\tif (!k) break;\n\t\t\t\tk1 = k2, k2 = !k2;\n\t\t\t}\n\t\t\tif (!k) hi = mi; else lo = mi;\n\t\t}\n\t\tprintf(\"%.6lf\\n\", hi);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-09){\n\t\t\tfor(int i = 0; i < 10000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\t//startP = new Point2D.Double(nextx , nexty);\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.5;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-06;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\tdouble premindis = -1;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 5000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t\tif(premindis - EPS < mindis && mindis < premindis + EPS){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpremindis = mindis;\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.15;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 10000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\t//startP = new Point2D.Double(nextx , nexty);\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.5;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew Q2007I();\n\t}\n\t\n\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2());\n\t}\n\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\tPoint2D a=diff(a2,a1),\n\t\t\t\tb=diff(b2,b1);\n\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t}\n\tPoint2D diff(Point2D p1,Point2D p2){\n\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t}\n\tdouble cross(Point2D p1,Point2D p2){\n\t\treturn p1.getX()*p2.getY() - p2.getX()*p1.getY();\n\t}\n\tPoint2D mul(double n,Point2D p1){\n\t\treturn new Point2D.Double(p1.getX()*n, p1.getY()*n);\n\t}\n\tPoint2D sum(Point2D p1,Point2D p2){\n\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t}\n\t\n\tclass Q2007I{\n\t\tint N;\n\t\tQ2007I(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] x=new int[N],\n\t\t\t\t\ty=new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble ret = f1(x,y);\n\t\t\tSystem.out.println(ret);\n\t\t\t\n\t\t}\n\t\tfinal double EPS = 1.0e-7;\n\t\tdouble f1(int[] x,int[] y){\n\t\t\tdouble l=0, r=30000;\n\t\t\twhile(abs(r-l) > EPS){\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tArrayList<Point2D> tmp = new ArrayList<Point2D>(N);\n\t\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\t\ttmp.add(new Point2D.Double(x[i], y[i]));\n\t\t\t\t}\n\t\t\t\tboolean flg = f2(tmp, mid);\t// true = 沈む false = 残る\n\t\t\t\tif(flg)\tr=mid;\n\t\t\t\telse\tl=mid;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\tboolean f2(ArrayList<Point2D> ps, double d){\n\t\t\t\n\t\t\tLine2D.Double[] cuts = new Line2D.Double[ps.size()];\n\t\t\tfor(int i=0; i<ps.size(); ++i){\n\t\t\t\tPoint2D p1 = ps.get(i),\n\t\t\t\t\t\tp2 = ps.get((i+1)%ps.size());\n\t\t\t\tdouble x = -(p2.getY()-p1.getY()),\n\t\t\t\t\t\ty = (p2.getX()-p1.getX());\n\t\t\t\tdouble d2 = p1.distance(p2);\n\t\t\t\tx = x*d/d2;\ty=y*d/d2;\n\t\t\t\tPoint2D v1 = new Point2D.Double(x,y);\n\t\t\t\tcuts[i] = new Line2D.Double(sum(p1, v1), sum(p2, v1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line2D.Double cut: cuts){\n\t\t\t\tps = polygonCut(ps, cut);\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"D:\"+d+\" ps:\"+ps.size());\n\t\t\t\n\t\t\treturn ps.isEmpty();\n\t\t\t\n\t\t}\n\t\t\n\t\tprivate ArrayList<Point2D> polygonCut(ArrayList<Point2D> plist, Line2D cut) {\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i =0; i<n; i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from) <= 0){\n\t\t\t\t\tans.add(from);\n\t\t\t\t}\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1 * temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2());\n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\tdouble premindis = -1;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 7000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\t//startP = new Point2D.Double(nextx , nexty);\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t\tif(premindis - EPS < mindis && mindis < premindis + EPS){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpremindis = mindis;\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.25;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 20000.0;\n\t\t\t\twhile(Math.abs(left-right)>0.00000001){\n\t\t\t\t\tdouble next = (left+right)/2;\n//\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%1.6f\\n\",left);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tLine2D c = getcutV(a, b, distance);\n\t\t\t\tplist = convexCut(plist, c);\n//\t\t\t\tSystem.out.println(plist);\n\t\t\t\tif(plist.size()==0)return false;\n\t\t\t\tplist = convexHull(plist);\n\t\t\t}\n\t\t\treturn plist.size()==0? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.println(mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\tdouble move = 0.5;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 100;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP = new Point2D.Double(nextx , nexty);\n\t\t\t}\n\t\t\tmove = move / 2.0;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-06;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\tdouble premindis = -1;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 10000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t\tif(premindis - EPS < mindis && mindis < premindis + EPS){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpremindis = mindis;\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.2;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew Q2007I();\n\t}\n\t\n\tclass Q2007I{\n\t\tint N;\n\t\tQ2007I(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] x=new int[N],\n\t\t\t\t\ty=new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble ret = f1(x,y);\n\t\t\tSystem.out.println(ret);\n\t\t\t\n\t\t}\n\t\tfinal double EPS = 1.0e-7;\n\t\tdouble f1(int[] x,int[] y){\n\t\t\tdouble l=0, r=30000;\n\t\t\twhile(abs(r-l) > EPS){\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tArrayList<Point2D> tmp = new ArrayList<Point2D>(N);\n\t\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\t\ttmp.add(new Point2D.Double(x[i], y[i]));\n\t\t\t\t}\n\t\t\t\tboolean flg = f2(tmp, mid);\t// true = 沈む false = 残る\n\t\t\t\tif(flg)\tr=mid;\n\t\t\t\telse\tl=mid;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\tboolean f2(ArrayList<Point2D> ps, double d){\n\t\t\t\n\t\t\tLine2D[] cuts = new Line2D[ps.size()];\n\t\t\tfor(int i=0; i<ps.size(); ++i){\n\t\t\t\tPoint2D p1 = ps.get(i),\n\t\t\t\t\t\tp2 = ps.get((i+1)%ps.size());\n\t\t\t\tdouble x = -(p2.getY()-p1.getY()),\n\t\t\t\t\t\ty = (p2.getX()-p1.getX());\n\t\t\t\tdouble d2 = p1.distance(p2);\n\t\t\t\tx = x*d/d2;\ty=y*d/d2;\n\t\t\t\tPoint2D v1 = new Point2D.Double(x,y);\n\t\t\t\tcuts[i] = new Line2D.Double(sum(p1, v1), sum(p2, v1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line2D cut: cuts){\n\t\t\t\tps = polygonCut(ps, cut);\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"D:\"+d+\" ps:\"+ps.size());\n\t\t\t\n\t\t\treturn ps.isEmpty();\n\t\t\t\n\t\t}\n\t\t\n\t\tprivate ArrayList<Point2D> polygonCut(ArrayList<Point2D> plist, Line2D cut) {\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i =0; i<n; i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from) <= 0){\n\t\t\t\t\tans.add(from);\n\t\t\t\t}\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1 * temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2());\n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-06;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\tdouble premindis = -1;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 1500;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t\tif(premindis - EPS < mindis && mindis < premindis + EPS){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpremindis = mindis;\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.05;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew Q2007I();\n\t}\n\t\n\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2());\n\t}\n\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\tPoint2D a=diff(a2,a1),\n\t\t\t\tb=diff(b2,b1);\n\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t}\n\tPoint2D diff(Point2D p1,Point2D p2){\n\t\treturn new Point2D.Double(p1.getX()-p2.getX(), p1.getY()-p2.getY());\n\t}\n\tdouble cross(Point2D p1,Point2D p2){\n\t\treturn p1.getX()*p2.getY() - p2.getX()*p1.getY();\n\t}\n\tPoint2D mul(double n,Point2D p1){\n\t\treturn new Point2D.Double(p1.getX()*n, p1.getY()*n);\n\t}\n\tPoint2D sum(Point2D p1,Point2D p2){\n\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t}\n\tprivate ArrayList<Point2D> polygonCut(ArrayList<Point2D> plist, Line2D cut) {\n\t\tint n = plist.size();\n\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\tfor(int i =0; i<n; i++){\n\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\tif(cut.relativeCCW(from) <= 0){\n\t\t\t\tans.add(from);\n\t\t\t}\n\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\tif(temp1 * temp2 < 0){\n\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\tans.add(IntersectP);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tclass Q2007I{\n\t\tint N;\n\t\tQ2007I(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] x=new int[N],\n\t\t\t\t\ty=new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble ret = f1(x,y);\n\t\t\tSystem.out.printf(\"%.7f\\n\" ,ret);\n\t\t\t\n\t\t}\n\t\tfinal double EPS = 1.0e-7;\n\t\tdouble f1(int[] x,int[] y){\n\t\t\tdouble l=0, r=30000;\n\t\t\twhile(abs(r-l) > EPS){\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tArrayList<Point2D> tmp = new ArrayList<Point2D>(N);\n\t\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\t\ttmp.add(new Point2D.Double(x[i], y[i]));\n\t\t\t\t}\n\t\t\t\tboolean flg = f2(tmp, mid);\t// true = 沈む false = 残る\n\t\t\t\tif(flg)\tr=mid;\n\t\t\t\telse\tl=mid;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\tboolean f2(ArrayList<Point2D> ps, double d){\n\t\t\t\n\t\t\tLine2D.Double[] cuts = new Line2D.Double[ps.size()];\n\t\t\tfor(int i=0; i<ps.size(); ++i){\n\t\t\t\tPoint2D p1 = ps.get(i),\n\t\t\t\t\t\tp2 = ps.get((i+1)%ps.size());\n\t\t\t\tdouble x = -(p2.getY()-p1.getY()),\n\t\t\t\t\t\ty = (p2.getX()-p1.getX());\n\t\t\t\tdouble d2 = p1.distance(p2);\n\t\t\t\tx = x*d/d2;\ty=y*d/d2;\n\t\t\t\tPoint2D v1 = new Point2D.Double(x,y);\n\t\t\t\tcuts[i] = new Line2D.Double(sum(p1, v1), sum(p2, v1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line2D.Double cut: cuts){\n\t\t\t\tps = polygonCut(ps, cut);\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"D:\"+d+\" ps:\"+ps.size());\n\t\t\t\n\t\t\treturn ps.isEmpty();\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n//\t\t\t\tSystem.out.println(plist);\n//\t\t\t\tSystem.out.println(isOK(494.02336412, plist));\n\t\t\t\tdouble result = 0.0;\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 10000.0;\n\t\t\t\twhile(Math.abs(left-right)>0.00001){\n\t\t\t\t\tdouble next = (left+right)/2;\n//\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(left);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tLine2D c = getcutV(a, b, distance);\n\t\t\t\tplist = convexCut(plist, c);\n//\t\t\t\tSystem.out.println(plist);\n\t\t\t\tif(plist.size()==0)return false;\n\t\t\t\tplist = convexHull(plist);\n\t\t\t}\n\t\t\treturn plist.size()==0? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 20000.0;\n\t\t\t\twhile(Math.abs(left-right)>0.00000001){\n\t\t\t\t\tdouble next = (left+right)/2.0;\n//\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%1.6f\\n\",right);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tLine2D c = getcutV(a, b, distance);\n\t\t\t\tplist = convexCut(plist, c);\n//\t\t\t\tSystem.out.println(plist);\n\t\t\t\tif(plist.size()<1)return false;\n\t\t\t\tplist = convexHull(plist);\n\t\t\t}\n\t\t\treturn plist.size()<1? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n//\t\t\t\tSystem.out.println(plist);\n//\t\t\t\tSystem.out.println(isOK(494.02336412, plist));\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 20000.0;\n\t\t\t\twhile(Math.abs(left-right)>0.00000001){\n\t\t\t\t\tdouble next = (left+right)/2;\n//\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(left);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tLine2D c = getcutV(a, b, distance);\n\t\t\t\tplist = convexCut(plist, c);\n//\t\t\t\tSystem.out.println(plist);\n\t\t\t\tif(plist.size()==0)return false;\n\t\t\t\tplist = convexHull(plist);\n\t\t\t}\n\t\t\treturn plist.size()==0? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n\t\t\t\tSystem.out.println(plist);\n//\t\t\t\tSystem.out.println(isOK(494.02336412, plist));\n\t\t\t\tdouble result = 0.0;\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 10000.0;\n\t\t\t\twhile(Math.abs(left-right)>0.00001){\n\t\t\t\t\tdouble next = (left+right)/2;\n\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(left);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tLine2D c = getcutV(a, b, distance);\n\t\t\t\tplist = convexCut(plist, c);\n//\t\t\t\tSystem.out.println(plist);\n\t\t\t\tif(plist.size()==0)return false;\n\t\t\t\tplist = convexHull(plist);\n\t\t\t}\n\t\t\treturn plist.size()==0? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\t//1824 start\n\t//1900 end\n\t//0008 start\n\t//0406 cording end\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t//Point2D [] plist = new Point2D[n];\n\t\t\tArrayList<Point2D> plist = new ArrayList<Point2D>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tplist.add(new Point2D.Double(sc.nextDouble(), sc.nextDouble()));\n\t\t\t}\n\t\t\t\n\t\t\tdouble low = 0.0, high = 10000 * 2;\n\t\t\twhile(high - low > 1.0e-08){\n\t\t\t\tdouble mid = (high + low) / 2;\n\t\t\t\t//Point2D [] work = plist.clone();\n\t\t\t\tArrayList<Point2D> work = new ArrayList<Point2D>();\n\t\t\t\twork.addAll(plist);\n\t\t\t\t\n\t\t\t\t//create cut line\n\t\t\t\tLine2D [] cutLine = new Line2D[n];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tPoint2D p1 = work.get(i), p2 = work.get((i+1) % n);\n\t\t\t\t\tcutLine[i] = getcutV(p1,p2, mid);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//polygon cutする\n\t\t\t\tfor(Line2D cut: cutLine){\n\t\t\t\t\twork = polygonCut(work, cut);\n\t\t\t\t}\n\t\t\t\tif(work.size() < 1){\n\t\t\t\t\t//over \n\t\t\t\t\thigh = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlow = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\",high);\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tprivate ArrayList<Point2D> polygonCut(ArrayList<Point2D> plist, Line2D cut) {\n\t\tint n = plist.size();\n\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\tfor(int i =0; i<n; i++){\n\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\tif(cut.relativeCCW(from) < 0){\n\t\t\t\tans.add(from);\n\t\t\t}\n\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\tif(temp1 * temp2 < 0){\n\t\t\t\tPoint2D IntersectP = intersectPt(cut, new Line2D.Double(from,to));\n\t\t\t\tans.add(IntersectP);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate Point2D intersectPt(Line2D l, Line2D m) {\n\t\tPoint2D lVec = getV(l.getP2(), l.getP1());\n\t\tPoint2D mVec = getV(m.getP2(), m.getP1());\n\t\tPoint2D m1l1Vec = getV(m.getP1(), l.getP1());\n\t\tdouble a = getCross(m1l1Vec, lVec);\n\t\tdouble b = getCross(lVec, mVec);\n\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\treturn l.getP1();\n\t\t}\n\t\tdouble t = a / b;\n\t\tdouble resx = m.getX1() + t * mVec.getX();\n\t\tdouble resy = m.getY1() + t * mVec.getY();\n\t\treturn new Point2D.Double(resx, resy);\n\t}\n\n\tprivate double getCross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\tPoint2D p2p1 = getV(p2, p1);\n\t\tdouble p1p2Dis = p1.distance(p2);\n\t\tPoint2D p2p1NV = normalVector(p2p1);\n\t\tPoint2D cutV = mul(p2p1NV, mid / p1p2Dis);\n\t\tPoint2D cutp1 = add(p1, cutV);\n\t\tPoint2D cutp2 = add(p2, cutV);\n\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\treturn res;\n\t}\n\n\tprivate Point2D add(Point2D p1, Point2D p2) {\n\t\tdouble x = p2.getX() + p1.getX();\n\t\tdouble y = p2.getY() + p1.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tprivate Point2D normalVector(Point2D p) {\n\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t}\n\t\n\tprivate Point2D mul(Point2D p,double value) {\n\t\treturn new Point2D.Double(p.getX() * value, p.getY() * value);\n\t}\n\n\tprivate Point2D getV(Point2D p2, Point2D p1) {\n\t\tdouble x = p2.getX() - p1.getX();\n\t\tdouble y = p2.getY() - p1.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\tdouble move = 0.5;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 20000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP = new Point2D.Double(nextx , nexty);\n\t\t\t}\n\t\t\tmove = move / 2.0;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ1283().doIt();\n\t}\n\t\n\tclass AOJ1283{\n\t\tint n;\n\t\tArrayList<Point2D> plist;\n\t\tvoid doIt(){\n\t\t\twhile(true){\n\t\t\t\tn = in.nextInt();\n\t\t\t\tif(n==0)return;\n\t\t\t\tplist = new ArrayList<Point2D>();\n\t\t\t\tfor(int i=0;i<n;i++)plist.add(new Point2D.Double(in.nextDouble(),in.nextDouble()));\n\t\t\t\tdouble left = 0.0;\n\t\t\t\tdouble right = 20000.0;\n\t\t\t\twhile(Math.abs(left-right)>1.0e-08){\n\t\t\t\t\tdouble next = (left+right)/2.0;\n//\t\t\t\t\tSystem.out.println(next);\n\t\t\t\t\tif(isOK(next, plist)){\n\t\t\t\t\t\tleft = next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%1.6f\\n\",right);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean isOK(double distance, ArrayList<Point2D> plist){\n\t\t\tArrayList<Line2D> list = new ArrayList<Line2D>();\n\t\t\tArrayList<Point2D> result = new ArrayList<Point2D>();\n\t\t\tresult.addAll(plist);\n\t\t\tfor(int i=0;i<plist.size();i++){\n\t\t\t\tPoint2D a = plist.get(i);\n\t\t\t\tPoint2D b = plist.get((i+1)%plist.size());\n\t\t\t\tlist.add(getcutV(a, b, distance));\n\t\t\t}\n\t\t\tfor(Line2D l: list)result = convexCut(result, l);\n\t\t\treturn result.size()<1? false:true;\n\t\t}\n\t\t\n\t\tComparator< Point2D > com = new Comparator< Point2D >() {\n\t\t\tpublic int compare(Point2D p1,Point2D p2) {\n\t\t\t\tif(p1.getX() < p2.getX()) return -1;\n\t\t\t\telse if(p1.getX() > p2.getX()) return 1; \n\t\t\t\telse if(p1.getY() < p2.getY()) return -1;\n\t\t\t\telse if(p1.getY() > p2.getY()) return 1; \n\t\t\t\telse return 0;\n\t\t\t}\n\t\t};\n\t\t\n\t\tArrayList<Point2D> convexHull(ArrayList<Point2D>ps) {\n\t\t\tPoint2D[] plist = new Point2D[ps.size()];\n\t\t\tfor(int i=0;i<ps.size();i++)plist[i] = ps.get(i);\n\t\t\tint n = plist.length; Arrays.sort(plist, com);\n\t\t\tint k = 0;\n\t\t\tPoint2D [] qs = new Point2D[n * 2]; \n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\twhile(k > 1 && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k; i >= 0; i--){\n\t\t\t\twhile(k > t && new Line2D.Double(qs[k-2] , qs[k-1]).relativeCCW(plist[i]) > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\tqs[k++] = plist[i]; \n\t\t\t}\n\t\t\tPoint2D [] res = Arrays.copyOf(qs, k-1);\n\t\t\tArrayList<Point2D> list = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<res.length;i++)list.add(res[i]);\n\t\t\treturn list;\n\t\t}\n\t\t\n\t\tprivate Line2D getcutV(Point2D p1, Point2D p2, double mid) {\n\t\t\tPoint2D p2p1 = sub(p2, p1);\n\t\t\tdouble p1p2Dis = p1.distance(p2);\n\t\t\tPoint2D p2p1NV = normalVector1(p2p1);\n\t\t\tPoint2D cutV = mul(mid / p1p2Dis, p2p1NV);\n\t\t\tPoint2D cutp1 = add(p1, cutV);\n\t\t\tPoint2D cutp2 = add(p2, cutV);\n\t\t\tLine2D res = new Line2D.Double(cutp1, cutp2);\n\t\t\treturn res;\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tPoint2D add(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(), p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D normalVector1(Point2D p){\n\t\t\treturn new Point2D.Double(-p.getY(), p.getX());\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2()); \n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t\tPoint2D sum(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()+p2.getX(),p1.getY()+p2.getY());\n\t\t}\n\t\tPoint2D diff(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tPoint2D mul(double n,Point2D p1){\n\t\t\treturn new Point2D.Double(p1.getX()*n,p1.getY()*n);\n\t\t}\n\t\tArrayList<Point2D> convexCut(ArrayList<Point2D> plist,Line2D cut){\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from)<=0)ans.add(from);\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1*temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\tclass Pair{\n\t\tint x,y;\n\t\tpublic Pair(int x,int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.println(mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\tdouble move = 0.5;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 100000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\tstartP = new Point2D.Double(nextx , nexty);\n\t\t\t}\n\t\t\tmove = move / 2.0;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew Q2007I();\n\t}\n\t\n\tclass Q2007I{\n\t\tint N;\n\t\tQ2007I(){\n\t\t\twhile(true){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\tvoid solve(){\n\t\t\tint[] x=new int[N],\n\t\t\t\t\ty=new int[N];\n\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\tx[i]=sc.nextInt();\n\t\t\t\ty[i]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tdouble ret = f1(x,y);\n\t\t\tSystem.out.println(ret);\n\t\t\t\n\t\t}\n\t\tfinal double EPS = 1.0e-7;\n\t\tdouble f1(int[] x,int[] y){\n\t\t\tdouble l=0, r=30000;\n\t\t\twhile(abs(r-l) > EPS){\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\tArrayList<Point2D> tmp = new ArrayList<Point2D>(N);\n\t\t\t\tfor(int i=0; i<N; ++i){\n\t\t\t\t\ttmp.add(new Point2D.Double(x[i], y[i]));\n\t\t\t\t}\n\t\t\t\tboolean flg = f2(tmp, mid);\t// true = 沈む false = 残る\n\t\t\t\tif(flg)\tr=mid;\n\t\t\t\telse\tl=mid;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\t\n\t\tboolean f2(ArrayList<Point2D> ps, double d){\n\t\t\t\n\t\t\tLine2D[] cuts = new Line2D[ps.size()];\n\t\t\tfor(int i=0; i<ps.size(); ++i){\n\t\t\t\tPoint2D p1 = ps.get(i),\n\t\t\t\t\t\tp2 = ps.get((i+1)%ps.size());\n\t\t\t\tdouble x = -(p2.getY()-p1.getY()),\n\t\t\t\t\t\ty = (p2.getX()-p1.getX());\n\t\t\t\tdouble d2 = p1.distance(p2);\n\t\t\t\tx = x*d/d2;\ty=y*d/d2;\n\t\t\t\tPoint2D v1 = new Point2D.Double(x,y);\n\t\t\t\tcuts[i] = new Line2D.Double(sum(p1, v1), sum(p2, v1));\n\t\t\t}\n\t\t\t\n\t\t\tfor(Line2D cut: cuts){\n\t\t\t\tps = polygonCut(ps, cut);\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"D:\"+d+\" ps:\"+ps.size());\n\t\t\t\n\t\t\treturn ps.isEmpty();\n\t\t\t\n\t\t}\n\t\t\n\t\tprivate ArrayList<Point2D> polygonCut(ArrayList<Point2D> plist, Line2D cut) {\n\t\t\tint n = plist.size();\n\t\t\tArrayList<Point2D> ans = new ArrayList<Point2D>();\n\t\t\tfor(int i =0; i<n; i++){\n\t\t\t\tPoint2D from = plist.get(i), to = plist.get((i+1)%n);\n\t\t\t\tif(cut.relativeCCW(from) <= 0){\n\t\t\t\t\tans.add(from);\n\t\t\t\t}\n\t\t\t\tint temp1 = cut.relativeCCW(from);\n\t\t\t\tint temp2 = cut.relativeCCW(to);\n\t\t\t\tif(temp1 * temp2 < 0){\n\t\t\t\t\tPoint2D IntersectP = intersectionPoint(cut, new Line2D.Double(from,to));\n\t\t\t\t\tans.add(IntersectP);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tPoint2D intersectionPoint(Line2D l1,Line2D l2){\n\t\t\treturn intersectionPoint(l1.getP1(), l1.getP2(), l2.getP1(), l2.getP2());\n\t\t}\n\t\tPoint2D intersectionPoint(Point2D a1,Point2D a2,Point2D b1,Point2D b2){\n\t\t\tPoint2D a=diff(a2,a1),\n\t\t\t\t\tb=diff(b2,b1);\n\t\t\treturn sum(a1, mul(cross(b, diff(b1,a1))/cross(b,a), a));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tdouble EPS = 1.0e-08;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint2D [] inputlist = new Point2D[n];\n\t\t\tdouble startx = 0.0, starty = 0.0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tinputlist[i] = new Point2D.Double(x, y);\n\t\t\t\tstartx += x;\n\t\t\t\tstarty += y;\n\t\t\t}\n\t\t\tstartx = startx / n;\n\t\t\tstarty = starty / n;\n\t\t\t\n\t\t\tLine2D [] lineList = new Line2D[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tlineList[i] = new Line2D.Double(inputlist[i], inputlist[(i+1) % n]);\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D startP = new Point2D.Double(startx, starty);\n\t\t\tdouble mindis = calcDis(startP, lineList);\n\t\t\tSystem.out.printf(\"%.6f\\n\",mindis);\n\t\t}\n\t}\n\t\n\tprivate double calcDis(Point2D startP, Line2D [] lineList){\n\t\t//double move = 0.5;\n\t\tdouble move = 0.95;\n\t\tdouble mindis = -1.0;\n\t\tint len = lineList.length;\n\t\twhile(move > 1.0e-10){\n\t\t\tfor(int i = 0; i < 5000;i++){\n\t\t\t\tmindis = -1;\n\t\t\t\tint minind = 0;\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tdouble nowdis = lineList[j].ptLineDist(startP);\n\t\t\t\t\tif(mindis < 0)mindis = nowdis;\n\t\t\t\t\tif(nowdis < mindis){\n\t\t\t\t\t\tmindis = nowdis;\n\t\t\t\t\t\tminind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lineind = minind;\n\t\t\t\tPoint2D forwardP = calcNearPoint(lineList[lineind], startP, mindis);\n\t\t\t\tPoint2D forwardVec = getV(forwardP, startP);\n\t\t\t\tdouble nextx = startP.getX() - forwardVec.getX() * move;\n\t\t\t\tdouble nexty = startP.getY() - forwardVec.getY() * move;\n\t\t\t\t//startP = new Point2D.Double(nextx , nexty);\n\t\t\t\tstartP.setLocation(nextx, nexty);\n\t\t\t}\n\t\t\t//move = move / 2;\n\t\t\tmove = move / 1.25;\n\t\t}\n\t\treturn mindis;\n\t}\n\n\tprivate Point2D calcNearPoint(Line2D line, Point2D p, double dis) {\n\t\tdouble disC = p.distance(line.getP1());\n\t\tdouble disB = Math.sqrt(disC * disC - dis * dis);\n\t\tdouble disD = line.getP1().distance(line.getP2());\n\t\tdouble rate = disB / disD;\n\t\tPoint2D p2p1Vec = getV(line.getP2(), line.getP1());\n\t\tdouble x = p2p1Vec.getX() * rate + line.getP1().getX();\n\t\tdouble y = p2p1Vec.getY() * rate + line.getP1().getY();\n\t\tPoint2D res = new Point2D.Double(x, y);\n\t\treturn res;\n\t}\n\n\tprivate Point2D getV(Point2D p1, Point2D p2) {\n\t\tdouble x = p1.getX() - p2.getX();\n\t\tdouble y = p1.getY() - p2.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = Float::INFINITY\nDELTA = 1e-11\n\nMIN_X = MIN_Y = 0.0\nMAX_X = MAX_Y = 10000.0\nMAX_D = 10000.0\n\n### classes\n\nclass Pt\n  attr_accessor :x, :y\n\n  def initialize() end\n  def initialize(x, y) @x = x; @y = y end\n\n  def ==(pt) @x == pt.x && @y == pt.y end\n  def +(pt) Pt.new(@x + pt.x, @y + pt.y) end\n  def -(pt) Pt.new(@x - pt.x, @y - pt.y) end\n  def -@() Pt.new(-@x, -@y) end\n  def *(t) Pt.new(@x * t, @y * t) end\n  def /(t) Pt.new(@x / t, @y / t) end\n  def dot(v) @x * v.x + @y * v.y end\n  def cross(v) @x * v.y - @y * v.x end\n  def d2() @x * @x + @y * @y end\n  def d() Math.sqrt(d2()) end\n  def to_s() \"(#{@x},#{@y})\" end\nend\n\n### global variables\n\n### subroutines\n\ndef cross_lines(ap, av, bp, bv)\n  cr01 = av.cross(bv)\n  return nil if cr01 == 0.0\n\n  ab = bp - ap\n  cr0 = ab.cross(av)\n  cr1 = ab.cross(bv)\n\n  t0 = cr1 / cr01\n  t1 = cr0 / cr01\n\n  cl = av * t0 + ap\n  #p [ap.to_s, av.to_s, bp.to_s, bv.to_s, cl.to_s]\n  cl\nend\n\ndef convex_cut(cpol, pt, v)\n  n = cpol.length\n  cpol0 = []\n\n  for i in (0...n)\n    cpt0 = cpol[i]\n    cr0 = v.cross(cpt0 - pt)\n    if cr0 >= 0.0\n      cpol0 << cpt0\n    end\n    \n    cpt1 = cpol[(i + 1) % n]\n    cr1 = v.cross(cpt1 - pt)\n    if cr0 * cr1 < 0.0\n      pt = cross_lines(pt, v, cpt0, cpt1 - cpt0)\n      cpol0 << pt\n    end\n  end\n\n  #p cpol0.map{|pt| pt.to_s}; exit\n  cpol0\nend\n\n### main\n\n$max_conv = [\n  Pt.new(MIN_X - 1, MIN_Y - 1), Pt.new(MAX_X + 1, MIN_Y - 1),\n  Pt.new(MAX_X + 1, MAX_Y + 1), Pt.new(MIN_X - 1, MAX_Y + 1)\n]\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  $pts = $n.times.map{Pt.new(*gets.split.map(&:to_f))}\n  $pts << $pts.first\n  #p $pts.map{|pt| pt.to_s}\n\n  $vecs = (0...$n).map{|i| $pts[i + 1] - $pts[i]}\n  $nrvecs = $vecs.map{|v| d = v.d(); Pt.new(-v.y / d, v.x / d)}\n  #p $vecs.map{|v| v.to_s}\n  #p $nrvecs.map{|v| v.to_s}\n\n  ld = 0.0\n  ud = MAX_D \n\n  while (ud - ld > DELTA)\n    md = (ld + ud) / 2\n\n    cpol = $max_conv\n    for i in (0...$n)\n      cpol = convex_cut(cpol, $pts[i] + $nrvecs[i] * md, $vecs[i])\n    end\n\n    if ! cpol.empty?\n      ld = md\n    else\n      ud = md\n    end\n  end\n\n  d = (ld + ud) / 2\n  puts \"%.6f\" % d\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef cross2(p, q):\n    return p[0]*q[1] - p[1]*q[0]\ndef cross3(o, p, q):\n    return (p[0] - o[0])*(q[1] - o[1]) - (p[1] - o[1])*(q[0] - o[0])\ndef dot2(p, q):\n    return p[0]*q[0] + p[1]*q[1]\ndef dist2(p):\n    return p[0]**2 + p[1]**2\ndef segment_line_dist(x, p0, p1):\n    z0 = (p1[0] - p0[0], p1[1] - p0[1])\n    z1 = (x[0] - p0[0], x[1] - p0[1])\n    if 0 <= dot2(z0, z1) <= dist2(z0):\n        return abs(cross2(z0, z1)) / dist2(z0)**.5\n    z2 = (x[0] - p1[0], x[1] - p1[1])\n    return min(dist2(z1), dist2(z2))**.5\n\ndef polygon_cont(x, PS):\n    V = [cross3(PS[i-1], PS[i], x) for i in range(len(PS))]\n    return all(e >= 0 for e in V) or all(e <= 0 for e in V)\ndef polygon_dist(x, PS):\n    return min(segment_line_dist(x, PS[i-1], PS[i]) for i in range(len(PS)))\n\ndef check(x, PS):\n    if not polygon_cont(x, PS):\n        return -polygon_dist(x, PS)\n    return polygon_dist(x, PS)\ndef check_x(x, PS):\n    ly = min(y for x, y in PS); ry = max(y for x, y in PS)\n    EPS = 1e-6\n    while ly + EPS < ry:\n        y0 = (ly*2 + ry) / 3; y1 = (ly + ry*2) / 3\n        if check((x, y0), PS) < check((x, y1), PS):\n            ly = y0\n        else:\n            ry = y1\n    return ly\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    PS = [list(map(int, readline().split())) for i in range(N)]\n    EPS = 1e-6\n    lx = min(x for x, y in PS); rx = max(x for x, y in PS)\n    while lx + EPS < rx:\n        x0 = (lx*2 + rx) / 3; x1 = (lx + rx*2) / 3\n        y0 = check_x(x0, PS); y1 = check_x(x1, PS)\n        if check((x0, y0), PS) < check((x1, y1), PS):\n            lx = x0\n        else:\n            rx = x1\n    x0 = lx\n    y0 = check_x(x0, PS)\n    write(\"%.16f\\n\" % check((x0, y0), PS))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter, Binary};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nconst EPSILON: f64 = 0.000000001;\n#[derive(Copy, Clone)]\nstruct Point {\n    x: f64, y: f64\n}\nimpl Point {\n    fn distance(&self, other: &Self) -> f64 {\n        ((self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)).sqrt()\n    }\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Self) -> Self::Output {\n        Vector{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\n#[derive(Copy, Clone)]\nstruct Line {\n    a: f64, b: f64, c: f64\n}\nimpl Line {\n    fn by_two_point(a: &Point, b: &Point) -> Line {\n        Line{a: a.y - b.y, b: b.x - a.x, c: a.x * b.y - a.y * b.x}\n    }\n    fn is_parallel(&self, other: &Self) -> bool {\n        (self.a * other.b - self.b * other.a).abs() < EPSILON\n    }\n    fn cross_point(&self, other: &Self) -> Option<Point> {\n        let d = self.a * other.b - self.b * other.a;\n        if d.abs() < EPSILON {\n            None\n        }else {\n            Some(Point { x: (self.b * other.c - self.c * other.b) / d, y: (self.c * other.a - self.a * other.c) / d })\n        }\n    }\n    fn cathetus(&self, point: &Point) -> Line {\n        Line{a: self.b, b: -self.a, c: self.a * point.y - self.b * point.x}\n    }\n}\n#[derive(Copy, Clone)]\nstruct Triangle {\n    a: Point, b: Point, c: Point\n}\nimpl Triangle {\n    fn area(&self) -> f64 {\n        let a = self.a.distance(&self.b);\n        let b = self.b.distance(&self.c);\n        let c = self.c.distance(&self.a);\n        let s = (a + b + c) / 2_f64;\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    }\n    fn inner_circle_radius(&self) -> f64 {\n        self.area() * 2_f64 / (self.a.distance(&self.b) + self.b.distance(&self.c) + self.c.distance(&self.a))\n    }\n    fn by_three_edges(a: &Edge, b: &Edge, c: &Edge) -> Option<Triangle> {\n        if Triangle::can_make_triangle(a, b, c) {\n            let la = Line::by_two_point(&a.from, &a.to);\n            let lb = Line::by_two_point(&b.from, &b.to);\n            let lc = Line::by_two_point(&c.from, &c.to);\n            Some(Triangle{a: la.cross_point(&lb).unwrap(), b: lb.cross_point(&lc).unwrap(), c: lc.cross_point(&la).unwrap()})\n        }else {\n            None\n        }\n    }\n    fn can_make_triangle(a: &Edge, b: &Edge, c: &Edge) -> bool {\n        let va = a.to - a.from;\n        let vb = b.to - b.from;\n        let vc = c.to - c.from;\n        va.cross(&vb) > 0_f64 && vb.cross(&vc) > 0_f64 && vc.cross(&va) > 0_f64\n    }\n}\n#[derive(Copy, Clone)]\nstruct Edge {\n    from: Point, to: Point\n}\nimpl Edge {\n    fn is_parallel(&self, other: &Self) -> bool {\n        let Vector{x: ax, y: ay} = self.to - self.from;\n        let Vector{x: bx, y: by} = other.to - other.from;\n        (ax * by - ay * bx).abs() < EPSILON\n    }\n    fn distance_if_parallel(&self, other: &Self) -> Option<f64> {\n        if self.is_parallel(other) {\n            let sl = Line::by_two_point(&self.from, &self.to);\n            let ol = Line::by_two_point(&other.from, &other.to);\n            Some(Line::cathetus(&sl, &self.from).cross_point(&ol).unwrap().distance(&self.from))\n        }else {\n            None\n        }\n    }\n}\n#[derive(Copy, Clone)]\nstruct Vector {\n    x: f64, y: f64\n}\nimpl Vector {\n    fn cross(&self, other: &Self) -> f64 {\n        self.x * other.y - self.y * other.x\n    }\n}\nfn main() {\n    loop {\n        let_all!(n: usize);\n        if n == 0 {\n            return\n        }\n        let mut points = Vec::with_capacity(n);\n        for _ in 0 .. n {\n            let_all!(x: f64, y: f64);\n            points.push(Point{x: x, y: y});\n        }\n        let mut edges = Vec::with_capacity(n);\n        edges.push(Edge{from: points[n - 1], to: points[0]});\n        for i in 1 .. n {\n            edges.push(Edge{from: points[i - 1], to: points[i]});\n        }\n        let mut min_r = std::f64::MAX;\n        for i in 0 .. n {\n            for j in 0 .. i {\n                if let Some(d) = edges[i].distance_if_parallel(&edges[j]) {\n                    if min_r > d / 2_f64 {\n                        min_r = d/ 2_f64;\n                    }\n                }else {\n                    for k in 0..j {\n                        if let Some(t) = Triangle::by_three_edges(&edges[k], &edges[j], &edges[i]) {\n                            let r = t.inner_circle_radius();\n                            if min_r > r {\n                                min_r = r;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        println!(\"{:.*}\", 10, min_r);\n    }\n}\n"
  }
]