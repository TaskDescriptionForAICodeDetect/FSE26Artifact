[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    long long p, q, r;\n} Result;\n\nResult solve(char* s) {\n    int n = strlen(s);\n    long long p = 0, q = 0, r = 0;\n    \n    // Compute probabilities\n    for (int mask = 0; mask < (1 << n); mask++) {\n        int valid = 1;\n        for (int i = 0; i < n; i++) {\n            if ((mask & (1 << i)) && s[i] == '-') valid = 0;\n            if (!(mask & (1 << i)) && s[i] == 'X') valid = 0;\n            \n            if (i > 0 && (mask & (1 << (i-1))) && (mask & (1 << i))) valid = 0;\n            if (i < n-1 && (mask & (1 << (i+1))) && (mask & (1 << i))) valid = 0;\n        }\n        \n        if (valid) {\n            int ones = __builtin_popcount(mask);\n            if (ones == 0) p++;\n            else if (ones == 1) q++;\n            else r++;\n        }\n    }\n    \n    long long total = 1 << n;\n    p = p * 1000000000 / total % MOD;\n    q = q * 1000000000 / total % MOD;\n    r = r * 1000000000 / total % MOD;\n    \n    Result result = {p, q, r};\n    return result;\n}\n\nint main() {\n    char s[20];\n    scanf(\"%s\", s);\n    \n    Result result = solve(s);\n    printf(\"%lld %lld %lld\\n\", result.p, result.q, result.r);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 1000\n\ntypedef long long ll;\n\nll mod_pow(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nll inv(ll a, ll mod) {\n    return mod_pow(a, mod - 2, mod);\n}\n\nvoid solve() {\n    int N;\n    char s[MAXN + 1];\n    scanf(\"%d %s\", &N, s);\n    \n    int len = strlen(s);\n    ll p = 0, q = 0, r = 0;\n    \n    if (len == 1) {\n        if (s[0] == '-') {\n            p = inv(2, MOD);\n            q = inv(2, MOD);\n        } else {\n            p = inv(2, MOD);\n            q = (-inv(2, MOD) + MOD) % MOD;\n        }\n    } else {\n        int all_x = 1;\n        for (int i = 0; i < len; ++i) {\n            if (s[i] != 'X') {\n                all_x = 0;\n                break;\n            }\n        }\n        if (all_x) {\n            p = 0;\n            q = 0;\n            r = 1;\n        } else {\n            int valid = 1;\n            for (int i = 0; i < len - 1; ++i) {\n                if (s[i] == 'X' && s[i + 1] == 'X') {\n                    valid = 0;\n                    break;\n                }\n            }\n            if (!valid) {\n                p = 0;\n                q = 0;\n                r = 0;\n            } else {\n                int k = 0;\n                for (int i = 0; i < len; ++i) {\n                    if (s[i] == 'X') {\n                        k++;\n                    }\n                }\n                ll e_k = mod_pow(2, k, MOD);\n                ll denom = mod_pow(2, len + 1, MOD);\n                ll inv_denom = inv(denom, MOD);\n                p = (e_k * inv_denom) % MOD;\n                q = 0;\n                r = 0;\n                \n                int has_isolated = 0;\n                for (int i = 0; i < len; ++i) {\n                    if (s[i] == 'X') {\n                        int left_ok = (i == 0) || (s[i - 1] == '-');\n                        int right_ok = (i == len - 1) || (s[i + 1] == '-');\n                        if (left_ok && right_ok) {\n                            has_isolated = 1;\n                            break;\n                        }\n                    }\n                }\n                if (has_isolated) {\n                    ll term = inv(mod_pow(2, len + 2, MOD), MOD);\n                    q = (term * k) % MOD;\n                    q = (q * 2) % MOD;\n                    q = (q - term * len % MOD + MOD) % MOD;\n                    p = (p - q + MOD) % MOD;\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld %lld %lld\\n\", p, q, r);\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1e9 + 7;\n\nll modpow(ll a, ll b, ll mod) {\n    ll res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inv(ll a, ll mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvoid solve() {\n    string s;\n    cin >> s;\n    int N = s.size();\n    \n    vector<int> pat(N + 2, 0);\n    for (int i = 0; i < N; ++i) {\n        if (s[i] == 'X') pat[i + 1] = 1;\n    }\n    \n    ll p = 0, q = 0, r = 0;\n    \n    for (int k = 0; k <= 2; ++k) {\n        vector<vector<ll>> dp(N + 2, vector<ll>(3, 0));\n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= N + 1; ++i) {\n            for (int j = 0; j <= 2; ++j) {\n                if (i >= 1) {\n                    if (pat[i - 1] == 1) continue;\n                    int nj = min(j + 1, 2);\n                    if (i >= 2 && pat[i - 2] == 1) nj = 2;\n                    if (i <= N && pat[i] == 1) nj = 2;\n                    dp[i][nj] = (dp[i][nj] + dp[i - 1][j]) % MOD;\n                }\n            }\n        }\n        \n        ll denom = inv(2 * k + 2, MOD);\n        ll term = dp[N + 1][k] * denom % MOD;\n        \n        if (k == 0) p = term;\n        else if (k == 1) q = term;\n        else r = term;\n    }\n    \n    ll e_inv = inv(modpow(2, MOD - 2, MOD), MOD);\n    ll e_inv_sq = e_inv * e_inv % MOD;\n    \n    ll ans_p = p;\n    ll ans_q = q * e_inv % MOD;\n    ll ans_r = r * e_inv_sq % MOD;\n    \n    ll ans = (ans_p + ans_q + ans_r) % MOD;\n    cout << ans_p << \" \" << ans_q << \" \" << ans_r << endl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:56:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static final long MOD = 1000000007;\n    \n    static long modInverse(long a, long m) {\n        return BigInteger.valueOf(a).modInverse(BigInteger.valueOf(m)).longValue();\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int N = s.length();\n        \n        long[] pow2 = new long[N + 2];\n        pow2[0] = 1;\n        for (int i = 1; i <= N + 1; i++) {\n            pow2[i] = (pow2[i - 1] * 2) % MOD;\n        }\n        \n        long inv_e = modInverse(3, MOD);\n        long inv_e2 = (inv_e * inv_e) % MOD;\n        \n        long p = 0, q = 0, r = 0;\n        \n        for (int k = 0; k <= N; k++) {\n            long coeff = 0;\n            if (k == 0) {\n                boolean valid = true;\n                for (int i = 0; i < N; i++) {\n                    if (s.charAt(i) != '-') {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    coeff = 1;\n                }\n            } else if (k == 1) {\n                boolean valid = true;\n                for (int i = 0; i < N; i++) {\n                    if (s.charAt(i) == 'X') {\n                        if (i > 0 && s.charAt(i - 1) == 'X') {\n                            valid = false;\n                            break;\n                        }\n                        if (i < N - 1 && s.charAt(i + 1) == 'X') {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                if (valid) {\n                    int cnt = 0;\n                    for (int i = 0; i < N; i++) {\n                        if (s.charAt(i) == 'X') {\n                            cnt++;\n                        }\n                    }\n                    coeff = pow2[cnt];\n                }\n            } else if (k == 2) {\n                boolean valid = true;\n                for (int i = 0; i < N; i++) {\n                    if (s.charAt(i) == 'X') {\n                        if (i > 0 && s.charAt(i - 1) == 'X') {\n                            valid = false;\n                            break;\n                        }\n                        if (i < N - 1 && s.charAt(i + 1) == 'X') {\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                if (valid) {\n                    int cnt = 0;\n                    for (int i = 0; i < N; i++) {\n                        if (s.charAt(i) == 'X') {\n                            cnt++;\n                        }\n                    }\n                    coeff = (pow2[cnt] * cnt) % MOD;\n                }\n            }\n            \n            if (k == 0) {\n                p = (p + coeff) % MOD;\n            } else if (k == 1) {\n                q = (q + coeff) % MOD;\n            } else if (k == 2) {\n                r = (r + coeff) % MOD;\n            }\n        }\n        \n        long inv_N_plus_1 = modInverse(N + 1, MOD);\n        p = (p * inv_N_plus_1) % MOD;\n        q = (q * inv_N_plus_1) % MOD;\n        r = (r * inv_N_plus_1) % MOD;\n        \n        System.out.println(p + \" \" + q + \" \" + r);\n    }\n}",
    "timestamp": "2025-08-05 22:57:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class BenchProblem {\n    static final int MOD = 1_000_000_007;\n    static final int[] dx = {-1, 1};\n\n    public static int[] solve(int M, int N, String s) {\n        double p = 0, q = 0, r = 0;\n        int[] result = new int[3];\n\n        // Compute limit probabilities \n        Map<String, Double> memo = new HashMap<>();\n        p = computeLimitProbability(N, s, memo);\n        \n        // Compute modulo results\n        result[0] = (int) ((p + MOD) % MOD);\n        result[1] = (int) ((q + MOD) % MOD);\n        result[2] = (int) ((r + MOD) % MOD);\n\n        return result;\n    }\n\n    private static double computeLimitProbability(int N, String s, Map<String, Double> memo) {\n        if (memo.containsKey(s)) return memo.get(s);\n\n        double prob = 0;\n        for (int i = 0; i < (1 << N); i++) {\n            String config = convertToBinaryString(i, N);\n            if (isConfigValid(config, s)) {\n                prob += Math.pow(1.0 / countComfortableSections(config), 1);\n            }\n        }\n\n        memo.put(s, prob);\n        return prob;\n    }\n\n    private static String convertToBinaryString(int num, int length) {\n        String binary = Integer.toBinaryString(num);\n        return String.format(\"%\" + length + \"s\", binary).replace(' ', '0');\n    }\n\n    private static boolean isConfigValid(String config, String target) {\n        for (int i = 0; i < config.length(); i++) {\n            if (target.charAt(i) != '-' && config.charAt(i) != '1') return false;\n            if (target.charAt(i) == 'X' && config.charAt(i) != '1') return false;\n        }\n        return true;\n    }\n\n    private static int countComfortableSections(String config) {\n        int count = 0;\n        for (int i = 0; i < config.length(); i++) {\n            if (config.charAt(i) == '0') {\n                boolean isComfortable = true;\n                for (int d : dx) {\n                    int ni = i + d;\n                    if (ni >= 0 && ni < config.length() && config.charAt(ni) == '1') {\n                        isComfortable = false;\n                        break;\n                    }\n                }\n                if (isComfortable) count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M = scanner.nextInt();\n        int N = scanner.nextInt();\n        String s = scanner.next();\n\n        int[] result = solve(M, N, s);\n        for (int val : result) {\n            System.out.println(val);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:57:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nstruct Fraction {\n    ll p, q;\n    Fraction(ll p = 0, ll q = 1) : p(p), q(q) {\n        if (q < 0) { p = -p; q = -q; }\n        ll g = __gcd(abs(p), abs(q));\n        p /= g;\n        q /= g;\n    }\n    Fraction operator+(const Fraction& other) const {\n        return Fraction(p * other.q + other.p * q, q * other.q);\n    }\n};\n\nint main() {\n    int N;\n    string s;\n    cin >> N >> s;\n\n    vector<int> dp(1 << N);\n    dp[0] = 1;\n\n    for (int mask = 1; mask < (1 << N); mask++) {\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                int prev_mask = mask ^ (1 << i);\n                if (s[i] == 'X') {\n                    if (prev_mask == 0 || (prev_mask & ((1 << i) | (1 << ((i + 1) % N)))) == 0) {\n                        dp[mask] += dp[prev_mask];\n                    }\n                } else {\n                    dp[mask] += dp[prev_mask];\n                }\n            }\n        }\n    }\n\n    Fraction ans(0, 1);\n    for (int mask = 0; mask < (1 << N); mask++) {\n        ans = ans + Fraction(dp[mask], 1 << N);\n    }\n\n    cout << ans.p % MOD << \" \" << ans.q % MOD << \" 0\" << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:57:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def modinv(a, m):\n    m0, x0, x1 = m, 0, 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        m, a = a % m, m\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += m0\n    return x1\n\ndef solve(s):\n    MOD = 10**9 + 7\n    N = len(s)\n    \n    factorial_cache = [1] * (N + 1)\n    inv_factorial_cache = [1] * (N + 1)\n    \n    for i in range(2, N + 1):\n        factorial_cache[i] = factorial_cache[i - 1] * i % MOD\n    \n    inv_factorial_cache[N] = modinv(factorial_cache[N], MOD)\n    for i in range(N - 1, 0, -1):\n        inv_factorial_cache[i] = inv_factorial_cache[i + 1] * (i + 1) % MOD\n    \n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        return factorial_cache[n] * inv_factorial_cache[k] % MOD * inv_factorial_cache[n - k] % MOD\n    \n    count_X = s.count('X')\n    count_dash = s.count('-')\n    \n    p = pow(2, -count_X, MOD) * comb(N - count_X, count_dash) % MOD\n    q = pow(2, -count_X + 1, MOD) * (comb(N - count_X - 1, count_dash - 1) * (N - count_X) + comb(N - count_X - 2, count_dash - 2)) % MOD\n    r = pow(2, -count_X + 2, MOD) * ((comb(N - count_X - 2, count_dash - 3) * (N - count_X) * (N - count_X - 1) // 2) + (comb(N - count_X - 3, count_dash - 4) * (N - count_X) * 3) + comb(N - count_X - 4, count_dash - 5)) % MOD\n    \n    return (p, q, r)\n\ns = input().strip()\nresult = solve(s)\nprint(result[0] % (10**9 + 7), result[1] % (10**9 + 7), result[2] % (10**9 + 7))",
    "timestamp": "2025-08-13 13:00:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.math.BigInteger;\n\npublic class BenchPhotoProbability {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        String s = \"X-X-X\"; // Sample input string\n        int N = s.length();\n        Rational[] result = solve(s, N);\n        for (Rational r : result) {\n            System.out.println(r.mod(MOD));\n        }\n    }\n\n    private static Rational[] solve(String s, int N) {\n        Rational p = new Rational(1, 1);\n        Rational q = new Rational(0, 1);\n        Rational r = new Rational(0, 1);\n\n        int xCount = countX(s);\n        int xDashCount = countXDash(s);\n\n        if (xDashCount != 0) {\n            p = new Rational(0, 1);\n            for (int i = 1; i <= xDashCount; i++) {\n                p = p.add(new Rational(factorial(i - 1).multiply(BigInteger.valueOf(N - i + 1)), factorial(N).multiply(BigInteger.valueOf(2).pow(i))));\n            }\n        }\n\n        if (xCount != 0 || xDashCount != 0) {\n            q = new Rational(p.numerator, p.denominator.multiply(BigInteger.valueOf(N)));\n        }\n        r = new Rational(q.numerator, q.denominator.multiply(BigInteger.valueOf(N)));\n\n        return new Rational[]{p, q, r};\n    }\n\n    private static int countX(String s) {\n        return (int) s.chars().filter(c -> c == 'X').count();\n    }\n\n    private static int countXDash(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) == 'X' && s.charAt(i + 1) == '-') count++;\n        }\n        return count;\n    }\n\n    private static BigInteger factorial(int n) {\n        BigInteger fact = BigInteger.ONE;\n        for (int i = 2; i <= n; i++) {\n            fact = fact.multiply(BigInteger.valueOf(i));\n        }\n        return fact;\n    }\n\n    static class Rational {\n        BigInteger numerator;\n        BigInteger denominator;\n\n        Rational(int numerator, int denominator) {\n            this.numerator = BigInteger.valueOf(numerator);\n            this.denominator = BigInteger.valueOf(denominator);\n            reduce();\n        }\n\n        Rational(BigInteger numerator, BigInteger denominator) {\n            this.numerator = numerator;\n            this.denominator = denominator;\n            reduce();\n        }\n\n        void reduce() {\n            BigInteger gcd = numerator.gcd(denominator);\n            numerator = numerator.divide(gcd);\n            denominator = denominator.divide(gcd);\n        }\n\n        Rational add(Rational other) {\n            BigInteger newNumerator = numerator.multiply(other.denominator).add(other.numerator.multiply(denominator));\n            BigInteger newDenominator = denominator.multiply(other.denominator);\n            return new Rational(newNumerator, newDenominator);\n        }\n\n        int mod(int m) {\n            BigInteger modValue = numerator.multiply(denominator.modInverse(BigInteger.valueOf(m)));\n            return modValue.mod(BigInteger.valueOf(m)).intValue();\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:00:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\n// Function to compute modular inverse a^(-1) mod m using Fermat's Little Theorem\nint mod_inv(int a, int m) {\n    int res = 1;\n    int k = m - 2;\n    while (k) {\n        if (k & 1) res = (long long)res * a % m;\n        a = (long long)a * a % m;\n        k >>= 1;\n    }\n    return res;\n}\n\n// Function to compute the required probabilities\nvoid compute_probabilities(const char *s, int *p, int *q, int *r) {\n    int n = 0;\n    while (s[n]) n++;\n    \n    // Initialize probabilities\n    *p = *q = *r = 0;\n    \n    // Compute p\n    int all_unoccupied = 1;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'X') {\n            all_unoccupied = 0;\n            break;\n        }\n    }\n    if (all_unoccupied) *p = 1;\n    \n    // Compute q\n    int single_occupied = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'X') {\n            if ((i == 0 || s[i - 1] == '-') && (i == n - 1 || s[i + 1] == '-')) {\n                single_occupied = 1;\n            } else {\n                single_occupied = 0;\n                break;\n            }\n        }\n    }\n    if (single_occupied) *q = 1;\n    \n    // Compute r\n    int double_occupied = 0;\n    if (n > 1) {\n        for (int i = 0; i <= n - 2; ++i) {\n            if (s[i] == 'X' && s[i + 1] == 'X') {\n                if ((i == 0 || s[i - 1] == '-') && (i + 1 == n - 1 || s[i + 2] == '-')) {\n                    double_occupied++;\n                }\n            }\n        }\n    }\n    *r = double_occupied;\n    \n    // Adjust q and r probabilities to be rational numbers based on number of comfortable states\n    *q = *q * mod_inv(2, MOD) % MOD;\n    *r = *r * mod_inv(2, MOD) % MOD;\n}\n\nint main() {\n    char s[1001];\n    scanf(\"%s\", s);\n    \n    int p, q, r;\n    compute_probabilities(s, &p, &q, &r);\n    \n    printf(\"%d %d %d\\n\", p, q, r);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:00:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nconst int MOD = 1000000007;\n\n// Helper function to compute the modular inverse of 'a' modulo 'mod'\nlong long mod_inv(long long a, long long mod) {\n    long long m0 = mod, t, q;\n    long long x0 = 0, x1 = 1;\n    if (mod == 1) return 0;\n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\n// Helper function to compute factorial up to n mod MOD\nvoid compute_factorials(int n, std::vector<long long>& fact, std::vector<long long>& inv_fact) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[n] = mod_inv(fact[n], MOD);\n    for (int i = n - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\n// Function to compute binomial coefficients C(n, k) % MOD\nlong long binomial(int n, int k, const std::vector<long long>& fact, const std::vector<long long>& inv_fact) {\n    if (k < 0 || k > n) return 0;\n    return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    std::string s;\n    std::cin >> s;\n    int n = s.length();\n\n    std::vector<long long> fact(n + 2);\n    std::vector<long long> inv_fact(n + 2);\n    compute_factorials(n + 1, fact, inv_fact);\n\n    // Count the number of 'X's and '-'\n    int x_count = 0;\n    for (char c : s) {\n        if (c == 'X') x_count++;\n    }\n    int dash_count = n - x_count;\n\n    // Calculate probabilities p, q, r\n    long long p = 0, q = 0, r = 0;\n\n    for (int k = 0; k <= dash_count; k++) {\n        long long ways = binomial(dash_count, k, fact, inv_fact);\n        long long multi_factorial = fact[n - k - x_count] * inv_fact[n - k] % MOD;\n        if (k >= 0) p = (p + ways * multi_factorial) % MOD;\n        if (k >= 1) q = (q + ways * multi_factorial) % MOD;\n        if (k >= 2) r = (r + ways * multi_factorial) % MOD;\n    }\n\n    // Factor each by respective powers of e, where e is represented by exp(1)\n    p = p * mod_inv(exp(0), MOD) % MOD;\n    q = q * mod_inv(exp(1), MOD) % MOD;\n    r = r * mod_inv(exp(2), MOD) % MOD;\n\n    std::cout << p << \" \" << q << \" \" << r << \"\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-13 13:01:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from math import factorial\nfrom typing import List, Tuple\n\ndef solve(M: int, N: int, s: str) -> Tuple[int, int, int]:\n    MOD = 10**9 + 7\n    \n    def choose(n: int, k: int) -> int:\n        return factorial(n) // (factorial(k) * factorial(n - k))\n    \n    def count_occupied_sequences(s: str) -> int:\n        n = len(s)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, n + 1):\n            for j in range(i + 1):\n                if s[i-1] == '-':\n                    if j > 0:\n                        dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return sum(dp[n][j] for j in range(n + 1))\n    \n    occupied_sequences = count_occupied_sequences(s)\n    total_sequences = 2**N\n    \n    p = occupied_sequences / total_sequences\n    q = 0\n    r = 0\n    \n    return (\n        int(p * (10**9 + 7)) % MOD, \n        int(q * (10**9 + 7)) % MOD, \n        int(r * (10**9 + 7)) % MOD\n    )",
    "timestamp": "2025-08-13 13:01:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    N = len(s)\n    \n    # Precompute the transitions for the automaton\n    # Each state is a tuple (prev_char, current_char)\n    # We need to model the last two characters to check for '---' patterns\n    \n    # The automaton states are:\n    # 0: prev is not '-', current is not '-'\n    # 1: prev is not '-', current is '-'\n    # 2: prev is '-', current is not '-'\n    # 3: prev is '-', current is '-'\n    # 4: prev is '-', current is '-', and the one before prev is not '-'\n    # But we can simplify to track the last two characters\n    \n    # The states are tuples (a, b) where a and b are the last two characters (0: not '-', 1: '-')\n    # So total 4 states: (0,0), (0,1), (1,0), (1,1)\n    \n    # We need to find the stationary distribution of this Markov chain\n    \n    # The transitions are:\n    # From (a, b), the next character is c:\n    # c can be 'X' (0) or '-' (1) based on the rules\n    \n    # The rules for adding a new character:\n    # If the last two are (0,0) or (0,1) or (1,0), then the next can be 0 or 1, but 1 is only possible if it doesn't create a '---' pattern\n    # Specifically:\n    # For state (a, b):\n    # If (a, b) is (0,0): next can be 0 or 1 (if 1, new state (0,1))\n    # If (a, b) is (0,1): next can be 0 (new state (1,0)) or 1 if the one before a is not 1 (but we don't know, so 1 is not allowed)\n    #   So next is 0 (new state (1,0))\n    # If (a, b) is (1,0): next can be 0 (new state (0,0)) or 1 (new state (0,1))\n    # If (a, b) is (1,1): next must be 0 (new state (1,0)), because adding 1 would create '---' which is not comfortable\n    \n    # So the transition probabilities:\n    # State (0,0):\n    #   next 0: probability 1/2, new state (0,0)\n    #   next 1: probability 1/2, new state (0,1)\n    # State (0,1):\n    #   next 0: probability 1, new state (1,0)\n    # State (1,0):\n    #   next 0: probability 1/2, new state (0,0)\n    #   next 1: probability 1/2, new state (0,1)\n    # State (1,1):\n    #   next 0: probability 1, new state (1,0)\n    \n    # Now, compute the stationary distribution of this Markov chain\n    \n    # The transition matrix is:\n    # (0,0) -> (0,0): 1/2, (0,1): 1/2\n    # (0,1) -> (1,0): 1\n    # (1,0) -> (0,0): 1/2, (0,1): 1/2\n    # (1,1) -> (1,0): 1\n    \n    # Let the stationary probabilities be p00, p01, p10, p11\n    # Then:\n    # p00 = 0.5*p00 + 0.5*p10\n    # p01 = 0.5*p00 + 0.5*p10\n    # p10 = p01 + p11\n    # p11 = 0 (since from (1,1) you always go to (1,0), and no transitions lead to (1,1))\n    \n    # So p11 = 0\n    # Then p10 = p01\n    # And p00 = 0.5*p00 + 0.5*p10 => 0.5*p00 = 0.5*p10 => p00 = p10\n    # Also p01 = 0.5*p00 + 0.5*p10 = p10 (since p00 = p10)\n    # And p00 + p01 + p10 + p11 = 1 => p00 + p01 + p10 = 1 => 3*p10 = 1 => p10 = 1/3\n    # So p00 = 1/3, p01 = 1/3, p10 = 1/3, p11 = 0\n    \n    # Now, the probability of a given pattern is the sum over all possible starting states of the stationary probability of the starting state times the product of the transition probabilities for the pattern\n    \n    # We need to compute the probability that a randomly selected N-length substring matches s\n    \n    # The pattern s must not contain '---' (since that's impossible in the stationary distribution)\n    # Also, the pattern must be consistent with the transition rules\n    \n    # For the pattern to be possible, it must not have three consecutive '-'\n    if '---' in s:\n        print(0, 0, 0)\n        return\n    \n    # Now, for each possible starting state (a, b), compute the probability of generating s[0], s[1], ..., s[N-1]\n    # Then multiply by the stationary probability of (a, b), and sum over all possible starting states\n    \n    # The initial state is (a, b), and we generate the first two characters as a, b\n    # Then for each subsequent character, we follow the transition rules\n    \n    # But since the bench is very long, the starting state is already in the stationary distribution\n    \n    # So we can model the probability as follows:\n    # For each possible window of N consecutive characters, the probability is the stationary probability of the first two characters times the product of the transition probabilities for the next N-2 characters\n    \n    # But since the bench is circular (or very long), the probability is the same for any window\n    \n    # So we can compute the probability of the pattern s by considering the stationary probabilities and transitions\n    \n    # The pattern s must start with two characters that are consistent with the stationary distribution\n    \n    # The stationary distribution is p00 = 1/3, p01 = 1/3, p10 = 1/3\n    \n    # Now, for the pattern s, we need to find all possible pairs of initial states (a, b) that can generate s\n    \n    # The initial two characters of s must match (a, b)\n    # So for the first two characters of s, we can determine possible (a, b)\n    \n    if N == 1:\n        # The single character must be 'X' or '-'\n        # The probability of 'X' is p00 + p10 (since the last character is not '-')\n        # The probability of '-' is p01 (since the last character is '-', and the one before is not '-')\n        # But in stationary distribution, p00 + p10 = 2/3, p01 = 1/3\n        if s == 'X':\n            print((2 * pow(3, MOD-2, MOD)) % MOD, 0, 0)\n        elif s == '-':\n            print((pow(3, MOD-2, MOD)) % MOD, 0, 0)\n        else:\n            print(0, 0, 0)\n        return\n    \n    # For N >= 2, we need to check the first two characters\n    first_two = s[:2]\n    possible_states = []\n    for a in 0, 1:\n        for b in 0, 1:\n            # Check if (a, b) matches the first two characters\n            match = True\n            if len(first_two) < 2:\n                match = False\n            else:\n                for i in range(2):\n                    c = first_two[i]\n                    if (i == 0 and a == 0 and c != 'X') or (i == 0 and a == 1 and c != '-'):\n                        match = False\n                    if (i == 1 and b == 0 and c != 'X') or (i == 1 and b == 1 and c != '-'):\n                        match = False\n            if match:\n                possible_states.append((a, b))\n    \n    if not possible_states:\n        print(0, 0, 0)\n        return\n    \n    # Now, for each possible starting state, compute the probability of generating the rest of the string\n    total_p = 0\n    total_q = 0\n    total_r = 0\n    \n    # The stationary probabilities are:\n    # p00 = 1/3, p01 = 1/3, p10 = 1/3\n    stat_prob = {\n        (0, 0): pow(3, MOD-2, MOD),\n        (0, 1): pow(3, MOD-2, MOD),\n        (1, 0): pow(3, MOD-2, MOD),\n        (1, 1): 0\n    }\n    \n    for a, b in possible_states:\n        current_p = stat_prob[(a, b)]\n        valid = True\n        for i in range(2, N):\n            prev_prev = s[i-2]\n            prev = s[i-1]\n            current = s[i]\n            # The transition must be valid\n            # The possible transitions are:\n            # If prev_prev is 'X' and prev is 'X', current can be 'X' or '-'\n            # If prev_prev is 'X' and prev is '-', current must be 'X'\n            # If prev_prev is '-' and prev is 'X', current can be 'X' or '-'\n            # If prev_prev is '-' and prev is '-', current must be 'X'\n            if prev_prev == 'X' and prev == 'X':\n                if current == 'X':\n                    current_p = current_p * pow(2, MOD-2, MOD) % MOD\n                elif current == '-':\n                    current_p = current_p * pow(2, MOD-2, MOD) % MOD\n                else:\n                    valid = False\n                    break\n            elif prev_prev == 'X' and prev == '-':\n                if current == 'X':\n                    pass  # probability 1, no change\n                else:\n                    valid = False\n                    break\n            elif prev_prev == '-' and prev == 'X':\n                if current == 'X':\n                    current_p = current_p * pow(2, MOD-2, MOD) % MOD\n                elif current == '-':\n                    current_p = current_p * pow(2, MOD-2, MOD) % MOD\n                else:\n                    valid = False\n                    break\n            elif prev_prev == '-' and prev == '-':\n                if current == 'X':\n                    pass  # probability 1, no change\n                else:\n                    valid = False\n                    break\n        if valid:\n            total_p = (total_p + current_p) % MOD\n    \n    # The result is total_p, since the e terms are 0 in this case\n    print(total_p, 0, 0)\n\nsolve()",
    "timestamp": "2025-08-13 13:02:12"
  }
]