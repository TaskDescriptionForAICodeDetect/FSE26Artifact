[
  {
    "language": "Fortran",
    "code": "module mod_modint\n  implicit none\n  integer(8) :: modulus = 10_8**9+7\n  !integer(8) :: modulus = 998244353_8\n  type modint\n    private\n    integer(8) :: num\n  contains\n    procedure :: get => getnum\n  end type\n\n  interface assignment(=)\n    module procedure :: setm, seti64, seti32\n  end interface assignment(=)\n\n  interface operator(+)\n    module procedure :: posm, addmm, addmi64, addmi32, addi64m, addi32m\n  end interface operator(+)\n\n  interface operator(-)\n    module procedure :: negm, submm, submi64, submi32, subi64m, subi32m\n  end interface operator(-)\n\n  interface operator(*)\n    module procedure :: mulmm, mulmi64, mulmi32, muli64m, muli32m\n  end interface operator(*)\n\n  interface operator(/)\n    module procedure :: divmm, divmi64, divmi32, divi64m, divi32m\n  end interface operator(/)\n\n  interface operator(**)\n    module procedure :: powmi64, powmi32\n  end interface operator(**)\n\n  interface inv\n    module procedure :: invm\n  end interface inv\n\ncontains\n\n  integer(8) function getnum(this)\n    class(modint), intent(in) :: this\n    getnum = this%num\n  end\n\n  pure elemental type(modint) function newm()\n    newm%num = 0_8\n  end\n\n  pure elemental subroutine setm(x,y)\n    type(modint), intent(inout) :: x\n    type(modint), intent(in) :: y\n    x%num = y%num\n  end\n\n  pure elemental function posm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = x%num\n  end\n\n  pure elemental function negm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    n%num = modulus-x%num\n  end\n\n  pure elemental function addmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num+y%num\n    if (n%num >= modulus) n%num = n%num-modulus\n  end\n\n  pure elemental function submm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = x%num-y%num\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  pure elemental function mulmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n%num = mod(x%num*y%num,modulus)\n  end\n\n  impure elemental function invm(x) result(n)\n    type(modint), intent(in) :: x\n    type(modint) :: n\n    integer(8) :: a, b, c, q, r, v\n    a = x%num\n    if (a == 0_8) then\n      write(*,'(a)') \"Error: Division by zero (x == 0). (modint, invm)\"\n      stop\n    end if\n    b = modulus\n    c = 0_8\n    v = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      r = mod(a,b)\n      a = b\n      b = r\n      r = c\n      c = v-c*q\n      v = r\n    end do\n    n%num = mod(v,modulus)\n    if (n%num < 0_8) n%num = n%num+modulus\n  end\n\n  impure elemental function divmm(x,y) result(n)\n    type(modint), intent(in) :: x, y\n    type(modint) :: n\n    n = mulmm(x,invm(y))\n  end\n\n  impure elemental type(modint) function newi(i)\n    class(*), intent(in) :: i\n    select type(i)\n    type is (integer(8))\n      newi%num = i\n    type is (integer)\n      newi%num = int(i,8)\n    type is (integer(2))\n      newi%num = int(i,8)\n    type is (integer(1))\n      newi%num = int(i,8)\n    class default\n      write(*,'(a)') \"Error: Invalid value (i is not integer). (modint, newi)\"\n      stop\n    end select\n    newi%num = mod(newi%num,modulus)\n    if (newi%num < 0_8) newi%num = newi%num+modulus\n  end\n\n  function num(x)\n    integer::x\n    type(modint)::num\n    num%num=x\n  end function\n\n  impure elemental subroutine seti64(x,i)\n    type(modint), intent(inout) :: x\n    integer(8), intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental subroutine seti32(x,i)\n    type(modint), intent(inout) :: x\n    integer, intent(in) :: i\n    call setm(x,newi(i))\n  end\n\n  impure elemental function addmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = addmm(x,newi(i))\n  end\n\n  impure elemental function addi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function addi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = addmm(newi(i),y)\n  end\n\n  impure elemental function submi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function submi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = submm(x,newi(i))\n  end\n\n  impure elemental function subi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function subi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = submm(newi(i),y)\n  end\n\n  impure elemental function mulmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function mulmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = mulmm(x,newi(i))\n  end\n\n  impure elemental function muli64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function muli32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = mulmm(newi(i),y)\n  end\n\n  impure elemental function divmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n\n    n = divmm(x,newi(i))\n  end\n\n  impure elemental function divi64m(i,y) result(n)\n    integer(8), intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function divi32m(i,y) result(n)\n    integer, intent(in) :: i\n    type(modint), intent(in) :: y\n    type(modint) :: n\n    n = divmm(newi(i),y)\n  end\n\n  impure elemental function powmi64(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer(8), intent(in) :: i\n    type(modint) :: n, p\n    integer(8) :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0_8) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0_8)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\n  impure elemental function powmi32(x,i) result(n)\n    type(modint), intent(in) :: x\n    integer, intent(in) :: i\n    type(modint) :: n, p\n    integer :: m\n    n = newi(1_8)\n    p = x\n    m = i\n    if (i < 0) then\n      p = invm(x)\n      m = abs(i)\n    end if\n    do while (m > 0)\n      if (btest(m,0)) n = mulmm(p,n)\n      p = mulmm(p,p)\n      m = rshift(m,1)\n    end do\n  end\n\nend module mod_modint\nprogram am\nuse mod_modint\nimplicit none\ninteger::N\ncharacter(1000)::S\n\ntype(modint)::ifact(0:2001),H(0:1000),den(0:2000)\n\ninteger::numX\ninteger::breaks(1000),brsize=0\ntype(modint)::valC,ans\ninteger::i,j\n    read*,N\n    read*,S\n\n    ifact(0)=1\n    do i=1,2001\n        ifact(i)=ifact(i-1)*i\n    end do\n    ifact(2001)=invm(ifact(2001))\n    do i=2001,1,-1\n        ifact(i-1)=ifact(i)*i\n    end do\n\n    do i = 0,N\n        den(i) = ifact(2*i) - merge(getnum(ifact(2*i-1)),0_8,i>0)\n        H(i) = ifact(2*i) - ifact(2*i+1)\n    end do\n    do  i = 0,N\n        do j = 1,N-i\n            H(i+j) = H(i+j)-H(i) * den(j)\n        end do\n    end do\n\n    do i = 1,N-1\n        if (S(i:i+1) == \"XX\")then\n            print\"(A)\",\"0 0 0\"\n            stop\n        endif\n        if (S(i:i+1) == '--' ) then\n            brsize=brsize+1\n            breaks(brsize)=i\n        endif\n    end do\n\n    if (brsize==0)then\n        numX=0\n        do i = 1,N\n            if(S(i:i)==\"X\")numX =numX+1\n        end do\n        valC = 1\n        ans = invm(num(2))\n        do i = 1,numX\n            ans =ans- valC\n            valC =valC- H(i-1)\n        end do\n        print\"(I0,A,I0,A,I0)\", getnum(invm(num(2))),' ',0,' ',getnum(ans) \n        stop\n    endif\n\n    ans = 1\n    do i = 1,brsize-1\n        ans =ans* H((breaks(i+1) - breaks(i))/2)\n    end do\n    valC = 1\n    do i = 1,(breaks(1))/2\n        valC =valC- H(i-1)\n    end do\n    ans =ans*valC\n    valC = num(1)\n    do  i = 1,(N-breaks(brsize))/2\n        valC = ValC-H(i-1)\n    end do\n    ans =ans* valC\n    print\"(I0,A,i0,A,i0)\",0,' ',0,' ',getnum(ans)\nend program am"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=1e9+7;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this *= x.inv();}\n    bool operator==(const Mint& x) const{return val == x.val;}\n    bool operator!=(const Mint& x) const{return val != x.val;}\n    bool operator<(const Mint& x) const{return val < x.val;}\n    bool operator<=(const Mint& x) const{return val <= x.val;}\n    bool operator>(const Mint& x) const{return val > x.val;}\n    bool operator>=(const Mint& x) const{return val >= x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\ntypedef tuple<vector<Mint>,vector<Mint>,Mint> func;\ntypedef tuple<Mint,Mint,Mint> T;\nfunc to_f(T t){return func{{get<0>(t)},{get<1>(t)},get<2>(t)};}\nvoid v_add(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]+=b[i];\n}\nvoid v_dec(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]-=b[i];\n}\nvoid t_add(T &a,T b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(T &a,T b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nvoid f_add(func &a,func b){v_add(get<0>(a),get<0>(b)),v_add(get<1>(a),get<1>(b)),get<2>(a)+=get<2>(b);}\nfunc f_dec(func a,func b){v_dec(get<0>(a),get<0>(b)),v_dec(get<1>(a),get<1>(b)),get<2>(a)-=get<2>(b); return a;}\nfunc integral(func f){\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    p.resize(p.size()+1); q.resize(q.size()+1);\n    rrep(i,p.size()-1,0)p[i]=p[i-1]/Mint(i); p[0]=0;\n    rrep(i,q.size()-1,0)q[i]=q[i-1]/Mint(i); q[0]=0;\n    get<2>(f)*=-1; return func{p,q,get<2>(f)};\n}\nfunc int_x(func f){f=integral(f); return func(f_dec(f,func{{get<2>(f)},{0},0}));}\nT int_1(func f){\n    f=integral(f); T res;\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i];\n    rep(i,0,q.size())get<1>(res)+=q[i];\n    get<0>(res)-=get<2>(f); get<1>(res)+=get<2>(f); return res;\n}\nMint pre[1010][2];\nvoid calc(){\n    pre[0][0]=pre[0][1]=1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*Mint(i+1);\n        pre[i+1][1]=pre[i][1]*Mint(i+1)+1;\n        pre[i][1]*=-1;\n    }\n}\nT int_e(func f){\n    T res; vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\n\nfunc dp[1010][2][3];\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    string s; cin>>s; calc();\n    if(s[0]=='X')dp[0][0][0]=func{{0},{0},1};\n    else dp[0][0][1]=func{{0},{0},1},dp[0][1][2]=func{{1},{0},-1};\n    rep(i,1,n){\n        if(s[i]=='X'){\n            f_add(dp[i][0][0],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][0],int_x(dp[i-1][1][2]));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][1])),int_x(dp[i-1][0][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][1])),int_x(dp[i-1][1][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n        else{\n            f_add(dp[i][0][1],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][1],int_x(dp[i-1][1][2]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][0]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][2]));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][0])),int_x(dp[i-1][0][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][0])),int_x(dp[i-1][1][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n    } T ans;\n    rep(i,0,2){\n        t_add(ans,int_e(dp[n-1][i][0]));\n        t_add(ans,int_1(dp[n-1][i][1]));\n        t_dec(ans,int_e(dp[n-1][i][1]));\n        t_add(ans,int_1(dp[n-1][i][2]));\n    }\n    printf(\"%d %d %d\\n\",get<0>(ans).mtoi(),get<1>(ans).mtoi(),get<2>(ans).mtoi());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0,i##_len=(n);i<i##_len;++i)\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define All(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod=1e9+7;\nclass mint {\n private:\n  ll _num,_mod;\n  mint set(ll num){ \n      _num = num ;\n      if(_num>=0) _num%=_mod;\n      else _num+=(1-(_num+1)/_mod)*_mod; \n      return *this;\n  }\n  ll _mpow(ll x, ll n){ //x^n(mod) ←普通にpow(x,n)では溢れてしまうため，随時mod計算 2分累乗法だから早い\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % _mod;\n        x = x*x % _mod;\n        n = n >> 1;\n    }\n    return ans;\n  }\n  ll imod(ll n){return _mpow(n , _mod-2);}\n public:\n  mint(){ _num = 0;_mod=mod; }\n  mint(ll num){ _mod = mod; _num = (num+(1LL<<25)*mod) % mod; }\n  mint(ll num,ll M){ _mod=M;_num=(num+(1LL<<25)*mod)%_mod; }\n  mint(const mint &cp){_num=cp._num;_mod=cp._mod;}\n  mint operator= (const ll x){ return set(x); }\n  mint operator+ (const ll x){ return mint(_num + (x % _mod) , _mod); }\n  mint operator- (const ll x){ return mint(_num - (x % _mod), _mod); }\n  mint operator* (const ll x){ return mint(_num * (x % _mod) , _mod); }\n  mint operator/ (ll x){ return mint(_num * imod(x) , _mod);}\n  mint operator+=(const ll x){ return set(_num + (x % _mod)); }\n  mint operator-=(const ll x){ return set(_num - (x % _mod)); }\n  mint operator*=(const ll x){ return set(_num * (x % _mod)); }\n  mint operator/=(ll x){ return set(_num * imod(x));}\n  mint operator+ (const mint &x){ return mint(_num + x._num , _mod); }\n  mint operator- (const mint &x){ return mint(_num - x._num , _mod);}\n  mint operator* (const mint &x){ return mint(_num * x._num , _mod); }\n  mint operator/ (mint x){ return mint(_num * imod(x._num) , _mod);}\n  mint operator+=(const mint &x){ return set(_num + x._num); }\n  mint operator-=(const mint &x){ return set(_num - x._num); }\n  mint operator*=(const mint &x){ return set(_num * x._num); }\n  mint operator/=(mint x){ return set(_num * imod(x._num));}\n\n  bool operator<(const mint &x)const{return _num<x._num;}\n  bool operator==(const mint &x)const{return _num==x._num;}\n  bool operator>(const mint &x)const{return _num>x._num;}\n\n  friend mint operator+(ll x,const mint &m){return mint(m._num + (x % m._mod) , m._mod);}\n  friend mint operator-(ll x,const mint &m){return mint( (x % m._mod) - m._num , m._mod);}\n  friend mint operator*(ll x,const mint &m){return mint(m._num * (x % m._mod) , m._mod);}\n  friend mint operator/(ll x,mint m){return mint(m.imod(m._num) * x , m._mod);}\n\n  explicit operator ll() { return _num; }\n  explicit operator int() { return (int)_num; }\n\n  friend ostream& operator<<(ostream &os, const mint &x){ os << x._num; return os; }\n  friend istream& operator>>(istream &is, mint &x){ll val; is>>val; x.set(val); return is;}\n};\n\ntypedef tuple<vector<mint>,vector<mint>,mint> T;\nT sekibun(T &v,int state){\n    vector<mint> p,q;\n    mint c;\n    tie(p,q,c)=v;\n    if(state==0){\n        p.push_back(0);\n        q.push_back(0);\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=p[i-1]/mint(i);\n        }\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=q[i-1]/mint(i);\n        }\n        p[0]=0;\n        q[0]=c;\n        c=mod-c;\n    }\n    else if(state==1){\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=mod-p[i-1]/mint(i);\n            r+=p[i-1]/mint(i);\n        }\n        p[0]=r;\n        r=0;\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=mod-q[i-1]/mint(i);\n            r+=q[i-1]/mint(i);\n        }\n        q[0]=r-c;\n    }\n    else{\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        REP(i,p.size()){\n            r+=p[i]/mint(i+1);\n            p[i]=0;\n        }\n        p[0]=r;\n        r=q[0];\n        rep(i,1,q.size()){\n            r+=q[i]/mint(i+1);\n            q[i]=0;\n        }\n        q[0]=r-c;\n    }\n    return tie(p,q,c);\n}\nT operator+(T a,T b){\n    vector<mint> p(max(get<0>(a).size(),get<0>(b).size()))\n                ,q(max(get<1>(a).size(),get<1>(b).size()));\n    mint c=0;\n    REP(i,get<0>(a).size()) p[i]+=get<0>(a)[i];\n    REP(i,get<0>(b).size()) p[i]+=get<0>(b)[i];\n    REP(i,get<1>(a).size()) q[i]+=get<1>(a)[i];\n    REP(i,get<1>(b).size()) q[i]+=get<1>(b)[i];\n    c=get<2>(a)+get<2>(b);\n    return tie(p,q,c);\n}\n\nmint pre[1010][2];\nvoid calc(){\n    pre[0][0]=pre[0][1]=1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*mint(i+1);\n        pre[i+1][1]=pre[i][1]*mint(i+1)+1;\n        pre[i][1]*=-1;\n    }\n}\ntypedef tuple<mint,mint,mint> F;\n\nF int_e(T f){\n    F res; vector<mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\nvoid t_add(F &a,F b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(F &a,F b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nint main(){\n    int N;cin>>N;\n    string S;cin>>S;calc();\n    typedef vector<T> vt;\n    typedef vector<vt> vvt;\n    vector<vvt> dp(N+1,vvt(2,vt(3)));\n    if(S[0]=='X') dp[0][0][0]=T({0},{0},1);\n    else dp[0][0][1]=T({0},{0},1),dp[0][1][2]=T({1},{0},-1);\n    rep(i,1,N){\n        if(S[i]=='X'){\n            dp[i][0][0]=sekibun(dp[i-1][1][0],0)+sekibun(dp[i-1][0][1],1)\n                        +sekibun(dp[i-1][1][2],1)+sekibun(dp[i-1][1][2],0);\n        }\n        else{\n            dp[i][0][1]=sekibun(dp[i-1][1][0],0)+sekibun(dp[i-1][1][2],0);\n            REP(j,2) for(int k=0;k<=2;k+=2) dp[i][0][1]=dp[i][0][1]+sekibun(dp[i-1][j][k],1);\n            dp[i][1][2]=sekibun(dp[i-1][0][0],0)+sekibun(dp[i-1][0][2],0);\n        }\n    }\n    F ans;\n    REP(i,2){\n        t_add(ans,int_e(dp[N-1][i][0]));\n        T S=sekibun(dp[N-1][i][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n        t_dec(ans,int_e(dp[N-1][i][1]));\n        S=sekibun(dp[N-1][i][2],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n    }\n    mint p,q,r;\n    tie(p,q,r)=ans;\n    cout<<p<<\" \"<<q<<\" \"<<r<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "a"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=1e9+7;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this *= x.inv();}\n    bool operator==(const Mint& x) const{return val == x.val;}\n    bool operator!=(const Mint& x) const{return val != x.val;}\n    bool operator<(const Mint& x) const{return val < x.val;}\n    bool operator<=(const Mint& x) const{return val <= x.val;}\n    bool operator>(const Mint& x) const{return val > x.val;}\n    bool operator>=(const Mint& x) const{return val >= x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\ntypedef tuple<vector<Mint>,vector<Mint>,Mint> func;\ntypedef tuple<Mint,Mint,Mint> T;\nfunc to_f(T t){return func{{get<0>(t)},{get<1>(t)},get<2>(t)};}\nvoid v_add(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]+=b[i];\n}\nvoid v_dec(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]-=b[i];\n}\nvoid t_add(T &a,T b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(T &a,T b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nvoid f_add(func &a,func b){v_add(get<0>(a),get<0>(b)),v_add(get<1>(a),get<1>(b)),get<2>(a)+=get<2>(b);}\nfunc f_dec(func a,func b){v_dec(get<0>(a),get<0>(b)),v_dec(get<1>(a),get<1>(b)),get<2>(a)-=get<2>(b); return a;}\nvoid integral(func &f){\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    if(p.back()!=Mint(0))p.resize(p.size()+1); \n    if(q.back()!=Mint(0))q.resize(q.size()+1);\n    rrep(i,p.size()-1,0)p[i]=p[i-1]/Mint(i); p[0]=0;\n    rrep(i,q.size()-1,0)q[i]=q[i-1]/Mint(i); q[0]=0;\n    get<0>(f)=p; get<1>(f)=q; get<2>(f)*=-1;\n}\nfunc int_x(func f){integral(f); return func(f_dec(f,func{{get<2>(f)},{0},0}));}\nT int_1(func f){\n    integral(f); T res;\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i];\n    rep(i,0,q.size())get<1>(res)+=q[i];\n    get<0>(res)-=get<2>(f); get<1>(res)+=get<2>(f); return res;\n}\nMint pre[1010][2];\nvoid calc(){\n    pre[0][0]=1; pre[0][1]=-1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*Mint(i+1);\n        pre[i+1][1]=pre[i][1]*Mint(i+1)-1;\n    }\n}\nT int_e(func f){\n    T res; vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\n\nfunc dp[1010][2][3];\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    string s; cin>>s; calc(); Fill(dp,func{{0},{0},0});\n    if(s[0]=='X')dp[0][0][0]=func{{0},{0},1};\n    else dp[0][0][1]=func{{0},{0},1},dp[0][1][2]=func{{1},{0},-1};\n    rep(i,1,n){\n        if(s[i]=='X'){\n            f_add(dp[i][0][0],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][0],int_x(dp[i-1][1][2]));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][1])),int_x(dp[i-1][0][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][1])),int_x(dp[i-1][1][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n        else{\n            f_add(dp[i][0][1],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][1],int_x(dp[i-1][1][2]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][0]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][2]));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][0])),int_x(dp[i-1][0][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][0])),int_x(dp[i-1][1][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n    } T ans;\n    rep(i,0,2){\n        t_add(ans,int_e(dp[n-1][i][0]));\n        t_add(ans,int_1(dp[n-1][i][1]));\n        t_dec(ans,int_e(dp[n-1][i][1]));\n        t_add(ans,int_1(dp[n-1][i][2]));\n    }\n    printf(\"%d %d %d\\n\",get<0>(ans).mtoi(),get<1>(ans).mtoi(),get<2>(ans).mtoi());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M = 1e9 + 7;\n\nint add(int a, int b) {\n  int c = a + b;\n  if (c < 0) c += M;\n  if (c >= M) c -= M;\n  return c;\n}\n\nint mul(int a, int b) {\n  return (a * (ll) b) % M;\n}\n\nint pw(int a, int n) {\n  int res = 1;\n  while (n) {\n    if (n % 2 == 0) {\n      a = mul(a, a);\n      n /= 2;\n    } else {\n      res = mul(res, a);\n      n--;\n    }\n  }\n  return res;\n}\n\nint inv(int x) {\n  return pw(x, M - 2);\n}\n\ntypedef vector <int> poly;\n\nstruct ans {\n  poly p, q;\n  int c;\n  ans() {\n    p.clear(), q.clear();\n    c = 0;\n  }\n  ans(poly p, poly q, int c): p(p), q(q), c(c) {\n  }\n};\n\npoly integrate(poly p) {\n  poly q(p.size() + 1);\n  for (int i = 0; i < (int) p.size(); i++) {\n    q[i + 1] = add(q[i + 1], mul(p[i], inv(i + 1)));\n  }\n  return q;\n}\n\npoly operator + (poly a, poly b) {\n  poly c(max(a.size(), b.size()));\n  for (int i = 0; i < (int) a.size(); i++) {\n    c[i] = add(c[i], a[i]);\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    c[i] = add(c[i], b[i]);\n  }\n  return c;\n}\n\nans operator + (ans a, ans b) {\n  return {a.p + b.p, a.q + b.q, add(a.c, b.c)};\n}\n\nans set_one(ans t) {\n  int a = 0;\n  for (int x : t.p) {\n    a = add(a, x);\n  }\n  int b = 0;\n  for (int x : t.q) {\n    b = add(b, x);\n  }\n  b = add(b, t.c);\n  ans ret = {{a}, {b}, 0};\n  return ret;\n}\n\nconst int N = 1003;\n\nans dp[N][2][2][2];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int t = 0; t < 2; t++) {\n        for (int x = 0; x < 2; x++) {\n          dp[i][j][t][x] = ans();\n        }\n      }\n    }\n  }\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  for (int t = 0; t < 2; t++) {\n    ans x;\n    if (t == 0) {\n      x = {{}, {}, 1};\n      if (s[0] == 'X') {\n        dp[0][0][1][0] = x;\n      } else {\n        dp[0][0][0][1] = x;\n      }\n    } else {\n      x = {{1}, {}, -1};\n      if (s[0] == '-') {\n        dp[0][1][1][1] = x;\n      }\n    }\n  }\n  //integrate (P(x)+Q(x)/e+c*e^(-x))*(1 - e^(-x))\n  vector <int> fact(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = mul(fact[i - 1], i);\n  }\n  vector <int> rfact(n + 1);\n  for (int i = 0; i <= n; i++) {\n    rfact[i] = inv(fact[i]);\n  }\n  vector <int> i0(n + 1);\n  vector <int> i1(n + 1);\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j <= i; j++) {\n      if (j == 0) {\n        i0[i] = add(i0[i], 1);\n      }\n      i1[i] = add(i1[i], -mul(fact[i], rfact[j]));\n    }\n  }\n  int i2 = inv(2);\n  int p = 0, q = 0, r = 0;\n  for (int i = 0; i < n; i++) {\n    for (int chet = 0; chet < 2; chet++) {\n      for (int suf_chet = 0; suf_chet < 2; suf_chet++) {\n        for (int suf_nechet = 0; suf_nechet < 2; suf_nechet++) {\n          if (i == n - 1) {\n            auto ret = dp[i][chet][suf_chet][suf_nechet];\n            if (suf_chet) {\n              for (int i = 0; i < (int) ret.p.size(); i++) {\n                p = add(p, mul(ret.p[i], i0[i]));\n                q = add(q, mul(ret.p[i], i1[i]));\n              }\n              for (int i = 0; i < (int) ret.q.size(); i++) {\n                q = add(q, mul(ret.q[i], i0[i]));\n                r = add(r, mul(ret.q[i], i1[i]));\n              }\n              p = add(p, mul(i2, ret.c));\n              r = add(r, -mul(i2, ret.c));\n            }\n            if (suf_nechet) {\n              auto okret = ret;\n              okret.p = integrate(okret.p);\n              okret.q = integrate(okret.q);\n              okret.c = mul(okret.c, M - 1);\n              auto ok = set_one(okret);\n              p = add(p, ok.p[0]);\n              q = add(q, ok.q[0]);\n              q = add(q, okret.c);\n              p = add(p, -okret.c);\n              for (int i = 0; i < (int) ret.p.size(); i++) {\n                p = add(p, -mul(ret.p[i], i0[i]));\n                q = add(q, -mul(ret.p[i], i1[i]));\n              }\n              for (int i = 0; i < (int) ret.q.size(); i++) {\n                q = add(q, -mul(ret.q[i], i0[i]));\n                r = add(r, -mul(ret.q[i], i1[i]));\n              }\n              p = add(p, -mul(i2, ret.c));\n              r = add(r, mul(i2, ret.c));\n            }\n          } else {\n            for (int sm = 0; sm < 2; sm++) {\n              auto ret = dp[i][chet][suf_chet][suf_nechet];\n              ans y = ret;\n              if (!sm) {\n                y.p = integrate(dp[i][chet][suf_chet][suf_nechet].p);\n                y.q = integrate(dp[i][chet][suf_chet][suf_nechet].q);\n                y.c = mul(y.c, M - 1);  \n                y.p[0] = add(y.p[0], -y.c);\n                if (s[i + 1] == 'X' && (chet ^ 1)) continue;\n                if (!suf_chet) continue;\n                int now_nechet = 1;\n                int now_chet = 1;\n                if (s[i + 1] == 'X') {\n                  now_nechet = 0;\n                }\n                if (s[i + 1] == '-' && !(chet ^ 1)) {\n                  now_chet = 0;\n                }\n                if (now_chet || now_nechet) {\n                  dp[i + 1][chet ^ 1][now_chet][now_nechet] = dp[i + 1][chet ^ 1][now_chet][now_nechet] + y;\n                }\n              } else {\n                y.p = integrate(dp[i][chet][suf_chet][suf_nechet].p);\n                y.q = integrate(dp[i][chet][suf_chet][suf_nechet].q);\n                y.c = mul(y.c, M - 1);  \n                auto go = set_one(y);\n                for (int &x : y.p) x = mul(x, M - 1);\n                for (int &x : y.q) x = mul(x, M - 1);\n                y.c = mul(y.c, M - 1);\n                y = y + go;\n                int now_nechet = suf_chet;\n                int now_chet = suf_nechet;\n                if (s[i + 1] == 'X') {\n                  now_nechet = 0;\n                }\n                if (s[i + 1] == '-') {\n                  now_chet = 0;\n                }\n                if (now_chet || now_nechet) {\n                  dp[i + 1][0][now_chet][now_nechet] = dp[i + 1][0][now_chet][now_nechet] + y; \n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  q = 0;\n  cout << p << ' ' << q << ' ' << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0,i##_len=(n);i<i##_len;++i)\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define All(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod=1e9+7;\nclass mint {\n private:\n  ll _num,_mod=mod;\n  mint set(ll num){ \n      _num = num ;\n      if(_num<0){\n          if(_num>=-mod)_num=mod+_num;\n          else _num=mod-(-_num)%mod;\n      }\n      else if(_num>=mod) _num%=mod;\n      return *this;\n  }\n  \n public:\n  mint(){ _num = 0; }\n  mint(ll num){\n      _num = num;\n      if(_num<0){\n          if(_num>=-mod)_num=mod+_num;\n          else _num=mod-(-_num)%mod;\n      }\n      else if(_num>=mod) _num%=mod;\n  }\n  mint(ll num,ll M){\n      _mod=M;\n      _num=num;\n      if(_num<0){\n          if(_num>=-mod)_num=mod+_num;\n          else _num=mod-(-_num)%mod;\n      }\n      else if(_num>=mod) _num%=mod;\n  }\n  mint(const mint &cp){_num=cp._num;_mod=cp._mod;}\n  ll imod(){\n    ll n=_mod-2;\n    ll ans = 1,x=_num;\n    while(n != 0){\n        if(n&1) ans = ans*x%mod;\n        x = x*x %mod;\n        n = n >> 1;\n    }\n    return ans;\n  }\n  mint operator+ (const mint &x){ return mint(_num + x._num , _mod); }\n  mint operator- (const mint &x){ return mint(_num - x._num , _mod);}\n  mint operator* (const mint &x){ return mint(_num * x._num , _mod); }\n  mint operator/ (mint x){ return mint(_num * x.imod() , _mod);}\n  \n  mint operator+=(const mint &x){ return set(_num + x._num); }\n  mint operator-=(const mint &x){ return set(_num - x._num); }\n  mint operator*=(const mint &x){ return set(_num * x._num); }\n  mint operator/=(mint x){ return set(_num * x.imod());}\n\n  mint operator= (const ll x){ return set(x); }\n  mint operator+ (const ll x){return *this + mint(x,_mod); }\n  mint operator- (const ll x){ return *this - mint(x,_mod); }\n  mint operator* (const ll x){ return *this * mint(x,_mod); }\n  mint operator/ (const ll x){ return *this/mint(x);}\n\n  mint operator+=(const ll x){ *this = *this + x;return *this; }\n  mint operator-=(const ll x){ *this = *this - x;return *this; }\n  mint operator*=(const ll x){ *this = *this * x;return *this;}\n  mint operator/=(const ll x){ *this = *this / x;return *this;}\n\n  bool operator==(const mint &x)const{return _num==x._num;}\n  bool operator!=(const mint &x)const{return _num!=x._num;}\n\n  friend mint operator+(ll x,const mint &m){return mint(m._num + x , m._mod);}\n  friend mint operator-(ll x,const mint &m){return mint( x - m._num , m._mod);}\n  friend mint operator*(ll x,const mint &m){return mint(m._num * (x % m._mod) , m._mod);}\n  friend mint operator/(ll x,mint m){return mint(m.imod() * (x % m._mod) , m._mod);}\n\n  explicit operator ll() { return _num; }\n  explicit operator int() { return (int)_num; }\n  \n  friend ostream& operator<<(ostream &os, const mint &x){ os << x._num; return os; }\n  friend istream& operator>>(istream &is, mint &x){ll val; is>>val; x.set(val); return is;}\n};\ntypedef tuple<vector<mint>,vector<mint>,mint> T;\nT sekibun(T &v,int state){\n    vector<mint> p,q;\n    mint c;\n    tie(p,q,c)=v;\n    if(state==0){\n        p.push_back(0);\n        q.push_back(0);\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=p[i-1]/mint(i);\n        }\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=q[i-1]/mint(i);\n        }\n        p[0]=c;\n        q[0]=0;\n        c=mod-c;\n    }\n    else if(state==1){\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=mod-p[i-1]/mint(i);\n            r+=p[i-1]/mint(i);\n        }\n        p[0]=r;\n        r=0;\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=mod-q[i-1]/mint(i);\n            r+=q[i-1]/mint(i);\n        }\n        q[0]=r-c;\n    }\n    else{\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        REP(i,p.size()){\n            r+=p[i]/mint(i+1);\n            p[i]=0;\n        }\n        p[0]=r+c;\n        r=0;\n        REP(i,q.size()){\n            r+=q[i]/mint(i+1);\n            q[i]=0;\n        }\n        q[0]=r-c;\n        c=0;\n    }\n    return tie(p,q,c);\n}\nT operator+(T a,T b){\n    vector<mint> p(max(get<0>(a).size(),get<0>(b).size()))\n                ,q(max(get<1>(a).size(),get<1>(b).size()));\n    mint c=0;\n    REP(i,get<0>(a).size()) p[i]+=get<0>(a)[i];\n    REP(i,get<0>(b).size()) p[i]+=get<0>(b)[i];\n    REP(i,get<1>(a).size()) q[i]+=get<1>(a)[i];\n    REP(i,get<1>(b).size()) q[i]+=get<1>(b)[i];\n    c=get<2>(a)+get<2>(b);\n    return tie(p,q,c);\n}\n\nmint pre[1010][2];\nvoid calc(){\n    pre[0][0]=1;\n    pre[0][1]=-1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*mint(i+1);\n        pre[i+1][1]=pre[i][1]*mint(i+1)-1;\n    }\n}\ntypedef tuple<mint,mint,mint> F;\n\nF int_e(T f){\n    F res; vector<mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\nvoid t_add(F &a,F b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(F &a,F b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nint main(){\n    int N;cin>>N;\n    string S;cin>>S;calc();\n    typedef vector<T> vt;\n    typedef vector<vt> vvt;\n    typedef vector<vvt> vvvt;\n    vector<vvvt> dp(N+1,vvvt(2,vvt(2,vt(2))));\n    dp[0][0][1][1]=T({0},{0},1);\n    dp[0][1][1][1]=T({1},{0},-1);\n    rep(i,1,N+1){\n        if(S[i-1]=='X'){\n            dp[i][0][1][0]=sekibun(dp[i-1][0][0][1],1)+sekibun(dp[i-1][1][0][1],1)\n                          +sekibun(dp[i-1][0][1][1],1)+sekibun(dp[i-1][1][1][1],1)\n                          +sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n        }\n        else{\n            dp[i][0][0][1]=sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n            REP(j,2) REP(k,2) dp[i][0][0][1]=dp[i][0][0][1]+sekibun(dp[i-1][j][1][k],1);\n            dp[i][1][1][1]=sekibun(dp[i-1][0][1][0],0)+sekibun(dp[i-1][0][1][1],0);\n        }\n    }\n    F ans;\n    REP(i,2){\n        t_add(ans,int_e(dp[N][i][1][0]));\n        T S=sekibun(dp[N][i][0][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n        t_dec(ans,int_e(dp[N][i][0][1]));\n        S=sekibun(dp[N][i][1][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n    }\n    mint p,q,r;\n    tie(p,q,r)=ans;\n    cout<<p<<\" \"<<q<<\" \"<<r<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 1011;\nll inv[maxn];\ntypedef pair<int,int> num;\ntypedef vector<pair<int,int> > poly;\nnum add(const num &x, const num &y)\n{\n\treturn MP((x.FF+y.FF)%mod, (x.SS+y.SS)%mod);\n}\nnum sub(const num &x, const num &y)\n{\n\treturn MP((x.FF-y.FF)%mod, (x.SS-y.SS)%mod);\n}\npoly add(const poly &x, const poly &y)\n{\n\tpoly ret;\n\tret.resize(max(x.size(), y.size()));\n\tfor (int i=0; i<x.size(); i++) ret[i] = x[i];\n\tfor (int i=0; i<y.size(); i++) ret[i] = add(ret[i], y[i]);\n\treturn ret;\n}\npoly sub(const poly &x, const poly &y)\n{\n\tpoly ret;\n\tret.resize(max(x.size(), y.size()));\n\tfor (int i=0; i<x.size(); i++) ret[i] = x[i];\n\tfor (int i=0; i<y.size(); i++) ret[i] = sub(ret[i], y[i]);\n\treturn ret;\n}\nstruct func\n{\n\t//f(x) = a e^(-x)+ P(x)\n\tint a;\n\tpoly v;\n\tfunc operator + (const func &t) const\n\t{\n\t\tfunc ret;\n\t\tret.a = (a+t.a)%mod;\n\t\tret.v = add(v, t.v);\n\t\treturn ret;\n\t}\n\tfunc itg () const\n\t{\n\t\tfunc ret;\n\t\tret.a = -a;\n\t\tret.v.resize(v.size()+1);\n\t\tfor (int i=0; i<v.size(); i++)\n\t\t{\n\t\t\tret.v[i+1] = MP(1ll*v[i].FF*inv[i+1]%mod, 1ll*v[i].SS*inv[i+1]%mod);\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpair<int,int> get0() const\n\t{\n\t\tpair<int,int> ret = MP(a, 0);\n\t\tif (v.size()>0) ret = add(ret, v[0]);\n\t\treturn ret;\n\t}\n\tpair<int,int> get1() const\n\t{\n\t\tpair<int,int> ret = MP(0, a);\n\t\tfor (auto x : v) ret = add(ret, x);\n\t\treturn ret;\n\t}\n\tfunc trans0() const\n\t{\n\t\tfunc ret = itg();\n\t\tret.v = sub(ret.v, poly{ret.get0()});\n\t\treturn ret;\n\t}\n\tfunc trans1() const\n\t\n\t{\n\t\tfunc ret = itg();\n\t\tret.v = sub(poly{ret.get1()}, ret.v);\n\t\tret.a = -ret.a;\n\t\treturn ret;\n\t}\n\tvoid debug()\n\t{\n\t\tcerr<<\"func:\"<<endl;\n\t\tcerr<<a<<\" e^(-x) + \";\n\t\tfor (auto t : v) cerr<<t.FF<<\",\"<<t.SS<<\" \"; cerr<<endl;\n\t}\n};\n/*\n前i位已经填完 第i个随机数是x 0/1表示第i位之前的极长下降序列奇偶性 0/1表示第i位之后的极长下降序列的奇偶性 \nf[i][0/1][0/1](x) = a*e^(-x)+P(x)\n*/\nfunc dp[maxn][2][2];\nint n;\nchar s[maxn];\nvoid upd(func &x, func v)\n{\n\tx = x+v;\n}\nvoid calc_itg(int C, int coef0, int coef1, ll &a, ll &b, ll &c)\n{\n\tb = (b-coef0)%mod;\n\tc = (c-coef1)%mod;\n\tif (C==0)\n\t{\n\t\ta = (a+coef0)%mod;\n\t\tb = (b+coef1)%mod;\n\t}\n\telse calc_itg(C-1, 1ll*C*coef0%mod, 1ll*C*coef1%mod, a, b, c);\n}\nint main()\n{\n\tfor (int i=1; i<maxn; i++) inv[i] = qpow(i, mod-2);\n\tcin>>n;\n\tscanf(\"%s\", s+1);\n\tif (s[1]=='X')\n\t{\n\t\tdp[1][0][0].a = 1;\n\t}\n\telse\n\t{\n\t\tdp[1][0][1].a = 1;\n\t\tdp[1][1][0].a = dp[1][1][1].a = mod-1;\n\t\tdp[1][1][0].v = dp[1][1][1].v = {MP(1, 0)};\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tfor (int t0=0; t0<2; t0++)\n\t\t{\n\t\t\tfor (int t1=0; t1<2; t1++)\n\t\t\t{\n\t\t\t\tif ((s[i]=='X')^(t0==0&&t1==0)) continue;\n\t\t\t\t// <\n\t\t\t\tif (t1==0)\n\t\t\t\t{\n\t\t\t\t\tupd(dp[i+1][t0^1][0], dp[i][t0][t1].trans0());\n\t\t\t\t\tupd(dp[i+1][t0^1][1], dp[i][t0][t1].trans0());\n\t\t\t\t}\n\t\t\t\t// >\n\t\t\t\tupd(dp[i+1][0][t1^1], dp[i][t0][t1].trans1());\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tll ansa=0, ansb=0, ansc=0;\n\tfor (int t0=0; t0<2; t0++)\n\t{\n\t\tfor (int t1=0; t1<2; t1++)\n\t\t{\n\t\t\tif ((s[n]=='X')^(t0==0&&t1==0)) continue;\n//\t\t\tcerr<<\"t0=\"<<t0<<\" t1=\"<<t1<<endl;\n\t\t\tfunc &cur = dp[n][t0][t1];\n//\t\t\tcur.debug();\n\t\t\tll a=0, b=0, c=0;\n\t\t\tc = -1ll*cur.a*inv[2]%mod;\n\t\t\ta = (a+1ll*cur.a*inv[2])%mod;\n\t\t\tfor (int i=0; i<cur.v.size(); i++) calc_itg(i, cur.v[i].FF, cur.v[i].SS, a, b, c);\n\t\t\tif (t1==1)\n\t\t\t{\n\t\t\t\ta = -a;\n\t\t\t\tb = -b;\n\t\t\t\tc = -c;\n\t\t\t\tpair<int,int> p = sub(cur.itg().get1(), cur.itg().get0());\n\t\t\t\ta = (a+p.FF)%mod;\n\t\t\t\tb = (b+p.SS)%mod;\n\t\t\t}\n//\t\t\tcerr<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t\t\tansa = (ansa+a)%mod;\n\t\t\tansb = (ansb+b)%mod;\n\t\t\tansc = (ansc+c)%mod;\n\t\t}\n\t}\n\tcout<<(ansa+mod)%mod<<\" \"<<(ansb+mod)%mod<<\" \"<<(ansc+mod)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9)+7>;\n\nconst int MAXN = 1.1e3;\nint N;\nnum ifact[MAXN*2+1];\nnum H[MAXN];\nnum den[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\n\tifact[0] = 1;\n\tfor (int i = 1; i <= 2*N+1; i++) ifact[i] = ifact[i-1] * num(i);\n\tifact[2*N+1] = inv(ifact[2*N+1]);\n\tfor (int i = 2*N+1; i >= 1; i--) ifact[i-1] = ifact[i] * num(i);\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tden[i] = ifact[2*i] - (i > 0 ? ifact[2*i-1] : 0);\n\t\tH[i] = ifact[2*i] - ifact[2*i+1];\n\t}\n\tassert(den[0] == num(1));\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 1; i+j <= N; j++) {\n\t\t\tH[i+j] -= H[i] * den[j];\n\t\t}\n\t}\n\n\tstring S; cin >> S;\n\tvector<int> breaks;\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tif (S[i] == 'X' && S[i+1] == 'X') {\n\t\t\tcout << 0 << ' ' << 0 << ' ' << 0 << '\\n';\n\t\t\texit(0);\n\t\t}\n\t\tif (S[i] == '-' && S[i+1] == '-') breaks.push_back(i);\n\t}\n\n\tif (breaks.empty()) {\n\t\tint numX = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnumX += S[i] == 'X';\n\t\t}\n\t\tnum valC = num(1);\n\t\tnum ans = inv(num(2));\n\t\tfor (int i = 0; i < numX; i++) {\n\t\t\tans -= valC;\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tcout << inv(num(2)) << ' ' << 0 << ' ' << ans << '\\n';\n\t\texit(0);\n\t}\n\n\tnum ans = 1;\n\tfor (int z = 0; z+1 < int(breaks.size()); z++) {\n\t\tans *= H[(breaks[z+1] - breaks[z]) / 2];\n\t}\n\t{\n\t\tnum valC = num(1);\n\t\tfor (int i = 0; i < (breaks.front()+1)/2; i++) {\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tans *= valC;\n\t}\n\t{\n\t\tnum valC = num(1);\n\t\tfor (int i = 0; i < (N-1-breaks.back())/2; i++) {\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tans *= valC;\n\t}\n\tcout << 0 << ' ' << 0 << ' ' << ans << '\\n';\n\n\treturn 0;\n}\n\n// Note that the constraint is satisfied iff all dashes are next to an earlier X\n// This means that -- can't interact with each other, so we just want to solve\n// (...-)-X-X-X-X-(-...)\n//\n// Let f be the g.f. of P(...X-X-X... is good) * y^{2 * #X's}\n// Then, caseworking on min gives\n// y f'(y) - (f(y) - 1) = y^2 f(y)\n// f(y) = cosh(y) / (cosh(y) - y * sinh(y))\n//\n// Let g be the g.f. of P(...X-X-X-... is good) * y^{2 * #X's}\n// y g'(y) = y^2 f(y) g(y)\n// g(y) = 1 / (cosh(y) - y * sinh(y))\n//\n// Let h be the g.f. of P(...-X-X-X-... is good) * y^{2 * #X's} (>= 1 X's)\n// h(y) = (cosh(y) - sinh(y)/y) / (cosh(y) - y * sinh(y))\n//\n// So we just need terms of h(y)\n//\n// Also, for a given location, P(...-|- stuff on the left ends in -) = 1 - 1/1 + 1/2! - 1/3! ... = 1/e\n// (We're caseworking on length of increasing sequence to the -)\n//\n// Then, let c be the g.f. of e * P(...X-X-X-|-) * y^{2 * #X's} is\n// c(y) = 1 / (1-y^2) - y^2 / (1-y^2) * h(y)\n// = cosh(h) / (cosh(y) - y * sinh(y)) = f(y)\n//\n// Let d be the g.f. of e^2 * P(...X-X-X...) * y^{2 * #X's}\n// We do inclusion-exclusion:\n// y^2 d(y) - d(y) + (e^2 - 1) / 2 y^2 = (c(y) - 1) * y^2\n// d(y) = (e^2+1)/2 / (1-y^2) - c(y) * y^2 / (1-y^2)\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0,i##_len=(n);i<i##_len;++i)\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define All(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod=1e9+7;\nclass mint {\n private:\n  ll _num,_mod;\n  mint set(ll num){ \n      _num = num ;\n      if(_num>=0) _num%=_mod;\n      else _num+=(1-(_num+1)/_mod)*_mod; \n      return *this;\n  }\n  ll _mpow(ll x, ll n){ //x^n(mod) ←普通にpow(x,n)では溢れてしまうため，随時mod計算 2分累乗法だから早い\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % _mod;\n        x = x*x % _mod;\n        n = n >> 1;\n    }\n    return ans;\n  }\n  ll imod(ll n){return _mpow(n , _mod-2);}\n public:\n  mint(){ _num = 0;_mod=mod; }\n  mint(ll num){ _mod = mod; _num = (num+(1LL<<25)*mod) % mod; }\n  mint(ll num,ll M){ _mod=M;_num=(num+(1LL<<25)*mod)%_mod; }\n  mint(const mint &cp){_num=cp._num;_mod=cp._mod;}\n  mint operator= (const ll x){ return set(x); }\n  mint operator+ (const ll x){ return mint(_num + (x % _mod) , _mod); }\n  mint operator- (const ll x){ return mint(_num - (x % _mod), _mod); }\n  mint operator* (const ll x){ return mint(_num * (x % _mod) , _mod); }\n  mint operator/ (ll x){ return mint(_num * imod(x) , _mod);}\n  mint operator+=(const ll x){ return set(_num + (x % _mod)); }\n  mint operator-=(const ll x){ return set(_num - (x % _mod)); }\n  mint operator*=(const ll x){ return set(_num * (x % _mod)); }\n  mint operator/=(ll x){ return set(_num * imod(x));}\n  mint operator+ (const mint &x){ return mint(_num + x._num , _mod); }\n  mint operator- (const mint &x){ return mint(_num - x._num , _mod);}\n  mint operator* (const mint &x){ return mint(_num * x._num , _mod); }\n  mint operator/ (mint x){ return mint(_num * imod(x._num) , _mod);}\n  mint operator+=(const mint &x){ return set(_num + x._num); }\n  mint operator-=(const mint &x){ return set(_num - x._num); }\n  mint operator*=(const mint &x){ return set(_num * x._num); }\n  mint operator/=(mint x){ return set(_num * imod(x._num));}\n\n  bool operator<(const mint &x)const{return _num<x._num;}\n  bool operator==(const mint &x)const{return _num==x._num;}\n  bool operator>(const mint &x)const{return _num>x._num;}\n\n  friend mint operator+(ll x,const mint &m){return mint(m._num + (x % m._mod) , m._mod);}\n  friend mint operator-(ll x,const mint &m){return mint( (x % m._mod) - m._num , m._mod);}\n  friend mint operator*(ll x,const mint &m){return mint(m._num * (x % m._mod) , m._mod);}\n  friend mint operator/(ll x,mint m){return mint(m.imod(m._num) * x , m._mod);}\n\n  explicit operator ll() { return _num; }\n  explicit operator int() { return (int)_num; }\n\n  friend ostream& operator<<(ostream &os, const mint &x){ os << x._num; return os; }\n  friend istream& operator>>(istream &is, mint &x){ll val; is>>val; x.set(val); return is;}\n};\n\ntypedef tuple<vector<mint>,vector<mint>,mint> T;\nT sekibun(T &v,int state){\n    vector<mint> p,q;\n    mint c;\n    tie(p,q,c)=v;\n    if(state==0){\n        p.push_back(0);\n        q.push_back(0);\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=p[i-1]/mint(i);\n        }\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=q[i-1]/mint(i);\n        }\n        p[0]=c;\n        q[0]=0;\n        c=mod-c;\n    }\n    else if(state==1){\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=mod-p[i-1]/mint(i);\n            r+=p[i-1]/mint(i);\n        }\n        p[0]=r;\n        r=0;\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=mod-q[i-1]/mint(i);\n            r+=q[i-1]/mint(i);\n        }\n        q[0]=r-c;\n    }\n    else{\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        REP(i,p.size()){\n            r+=p[i]/mint(i+1);\n            p[i]=0;\n        }\n        p[0]=r+c;\n        r=0;\n        REP(i,q.size()){\n            r+=q[i]/mint(i+1);\n            q[i]=0;\n        }\n        q[0]=r-c;\n        c=0;\n    }\n    return tie(p,q,c);\n}\nT operator+(T a,T b){\n    vector<mint> p(max(get<0>(a).size(),get<0>(b).size()))\n                ,q(max(get<1>(a).size(),get<1>(b).size()));\n    mint c=0;\n    REP(i,get<0>(a).size()) p[i]+=get<0>(a)[i];\n    REP(i,get<0>(b).size()) p[i]+=get<0>(b)[i];\n    REP(i,get<1>(a).size()) q[i]+=get<1>(a)[i];\n    REP(i,get<1>(b).size()) q[i]+=get<1>(b)[i];\n    c=get<2>(a)+get<2>(b);\n    return tie(p,q,c);\n}\n\nmint pre[1010][2];\nvoid calc(){\n    pre[0][0]=1;\n    pre[0][1]=-1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*mint(i+1);\n        pre[i+1][1]=pre[i][1]*mint(i+1)-1;\n    }\n}\ntypedef tuple<mint,mint,mint> F;\n\nF int_e(T f){\n    F res; vector<mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\nvoid t_add(F &a,F b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(F &a,F b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nint main(){\n    int N;cin>>N;\n    string S;cin>>S;calc();\n    typedef vector<T> vt;\n    typedef vector<vt> vvt;\n    typedef vector<vvt> vvvt;\n    vector<vvvt> dp(N+1,vvvt(2,vvt(2,vt(2))));\n    dp[0][0][1][1]=T({0},{0},1);\n    dp[0][1][1][1]=T({1},{0},-1);\n    rep(i,1,N+1){\n        if(S[i-1]=='X'){\n            dp[i][0][1][0]=sekibun(dp[i-1][0][0][1],1)+sekibun(dp[i-1][1][0][1],1)\n                          +sekibun(dp[i-1][0][1][1],1)+sekibun(dp[i-1][1][1][1],1)\n                          +sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n        }\n        else{\n            dp[i][0][0][1]=sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n            REP(j,2) REP(k,2) dp[i][0][0][1]=dp[i][0][0][1]+sekibun(dp[i-1][j][1][k],1);\n            dp[i][1][1][1]=sekibun(dp[i-1][0][1][0],0)+sekibun(dp[i-1][0][1][1],0);\n        }\n    }\n    F ans;\n    REP(i,2){\n        t_add(ans,int_e(dp[N][i][1][0]));\n        T S=sekibun(dp[N][i][0][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n        t_dec(ans,int_e(dp[N][i][0][1]));\n        S=sekibun(dp[N][i][1][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n    }\n    mint p,q,r;\n    tie(p,q,r)=ans;\n    cout<<p<<\" \"<<q<<\" \"<<r<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx2\")\n#pragma GCC optimization(\"O3\")\n#pragma GCC optimization(\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define int long long\n#define ll long long\n#define mod (int)1000000007\n#define P pair<int,int>\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define all(V) V.begin(),V.end()\n#ifdef int\nconstexpr int INF = LLONG_MAX / 10;\n#else\nconstexpr int INF = INT_MAX / 10;\n#endif\nconstexpr double eps = 1e-9;\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nusing namespace std;\ninline int gcd(int a, int b) {\n\twhile (b) {\n\t\tint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline int lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tmodInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tmodInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tif (value < 0) {\n\t\t\tvalue = -value;\n\t\t\tvalue %= modulo;\n\t\t\tvalue = -value;\n\t\t\tvalue += modulo;\n\t\t}\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline modInt operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tinline modInt inv() {\n\t\treturn modpow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x, modulo)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x, modulo)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x, modulo)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x, modulo)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nmodInt modpow(modInt a, int b) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return modpow(a, b - 1) * a;\n\tmodInt memo = modpow(a, b / 2);\n\treturn memo * memo;\n}\nclass Polynomial {\npublic:\n\tvector<modInt> vec;\n\tPolynomial() {}\n\tPolynomial(vector<modInt> vec) :vec(vec) {}\n\tmodInt get(modInt x) {\n\t\tmodInt res = 0;\n\t\trep(i, vec.size()) {\n\t\t\tres += modpow(x, i) * vec[i];\n\t\t}\n\t\treturn res;\n\t}\n\tPolynomial integrate() {\n\t\tvector<modInt> res = vec;\n\t\tres.emplace_back();\n\t\tfor (int i = (int)res.size() - 2; i >= 0; i--)res[i + 1] = res[i] / (i + 1);\n\t\tres[0] = 0;\n\t\treturn Polynomial(res);\n\t}\n};\nclass func {\npublic:\n\tPolynomial first, second;\n\tmodInt third;\n\tfunc() {}\n\tfunc(Polynomial first, Polynomial second, modInt third) :first(first), second(second), third(third) {}\n\tvoid set(Polynomial first, Polynomial second, modInt third) {\n\t\tthis->first = first;\n\t\tthis->second = second;\n\t\tthis->third = third;\n\t}\n\tfunc* operator+=(const func& f) {\n\t\tfirst.vec.resize(max(first.vec.size(), f.first.vec.size()));\n\t\tsecond.vec.resize(max(second.vec.size(), f.second.vec.size()));\n\t\trep(i, f.first.vec.size())first.vec[i] += f.first.vec[i];\n\t\trep(i, f.second.vec.size())second.vec[i] += f.second.vec[i];\n\t\tthird += f.third;\n\t\treturn this;\n\t}\n};\nfunc dintegrate(func f, bool flag) {\n\tPolynomial p = f.first.integrate(), q = f.second.integrate();\n\tif (!flag) {\n\t\tp.vec[0] = f.third;\n\t\treturn func(p, q, -f.third);\n\t}\n\telse {\n\t\tp.vec[0] -= p.get(1);\n\t\trep(i, p.vec.size())p.vec[i] = -p.vec[i];\n\t\tq.vec[0] -= q.get(1);\n\t\tq.vec[0] += f.third;\n\t\trep(i, q.vec.size())q.vec[i] = -q.vec[i];\n\t\treturn func(p, q, f.third);\n\t}\n}\nint n;\nstring s;\nfunc dp[1010][2][2][2];\nmodInt fact[1010], inv[1010];\nsigned main() {\n\tcin >> n >> s;\n\tif (s[0] == 'X')dp[0][0][1][0].set(vector<modInt>(), vector<modInt>(), 1);\n\telse {\n\t\tdp[0][0][0][1].set(vector<modInt>(), vector<modInt>(), 1);\n\t\tdp[0][1][1][1].set(vector<modInt>(1, 1), vector<modInt>(), modInt(-1));\n\t}\n\tREP(i, n - 1) {\n\t\tif (s[i] == 'X') {\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][1][1][0], 0);\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][1][1][1], 0);\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][0][0][1], 1);\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][0][1][1], 1);\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][1][0][1], 1);\n\t\t\tdp[i][0][1][0] += dintegrate(dp[i - 1][1][1][1], 1);\n\t\t}\n\t\telse {\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][1][1][0], 0);\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][1][1][1], 0);\n\t\t\tdp[i][1][1][1] += dintegrate(dp[i - 1][0][1][0], 0);\n\t\t\tdp[i][1][1][1] += dintegrate(dp[i - 1][0][1][1], 0);\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][0][1][0], 1);\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][0][1][1], 1);\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][1][1][0], 1);\n\t\t\tdp[i][0][0][1] += dintegrate(dp[i - 1][1][1][1], 1);\n\t\t}\n\t}\n\tfact[0] = 1;\n\tREP(i, n)fact[i] = fact[i - 1] * i;\n\tinv[n] = modInt(1) / fact[n];\n\tfor (int i = n - 1; i >= 0; i--)inv[i] = inv[i + 1] * (i + 1);\n\tmodInt a, b, c;\n\tPolynomial p;\n\n\tp = dp[n - 1][0][1][1].first.integrate();\n\ta += p.get(1) - p.get(0);\n\tp = dp[n - 1][0][1][1].second.integrate();\n\tb += p.get(1) - p.get(0);\n\ta += dp[n - 1][0][1][1].third;\n\tb -= dp[n - 1][0][1][1].third;\n\tp = dp[n - 1][1][1][1].first.integrate();\n\ta += p.get(1) - p.get(0);\n\tp = dp[n - 1][1][1][1].second.integrate();\n\tb += p.get(1) - p.get(0);\n\ta += dp[n - 1][1][1][1].third;\n\tb -= dp[n - 1][1][1][1].third;\n\n\trep(i, dp[n - 1][0][1][0].first.vec.size()) {\n\t\ta += dp[n - 1][0][1][0].first.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tb -= dp[n - 1][0][1][0].first.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\trep(i, dp[n - 1][0][1][0].second.vec.size()) {\n\t\tb += dp[n - 1][0][1][0].second.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tc -= dp[n - 1][0][1][0].second.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\ta += dp[n - 1][0][1][0].third / 2;\n\tc -= dp[n - 1][0][1][0].third / 2;\n\n\trep(i, dp[n - 1][1][1][0].first.vec.size()) {\n\t\ta += dp[n - 1][1][1][0].first.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tb -= dp[n - 1][1][1][0].first.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\trep(i, dp[n - 1][1][1][0].second.vec.size()) {\n\t\tb += dp[n - 1][1][1][0].second.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tc -= dp[n - 1][1][1][0].second.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\ta += dp[n - 1][1][1][0].third / 2;\n\tc -= dp[n - 1][1][1][0].third / 2;\n\n\tp = dp[n - 1][0][0][1].first.integrate();\n\ta += p.get(1) - p.get(0);\n\tp = dp[n - 1][0][0][1].second.integrate();\n\tb += p.get(1) - p.get(0);\n\ta += dp[n - 1][0][0][1].third;\n\tb -= dp[n - 1][0][0][1].third;\n\n\tp = dp[n - 1][1][0][1].first.integrate();\n\ta += p.get(1) - p.get(0);\n\tp = dp[n - 1][1][0][1].second.integrate();\n\tb += p.get(1) - p.get(0);\n\ta += dp[n - 1][1][0][1].third;\n\tb -= dp[n - 1][1][0][1].third;\n\n\trep(i, dp[n - 1][0][0][1].first.vec.size()) {\n\t\ta -= dp[n - 1][0][0][1].first.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tb += dp[n - 1][0][0][1].first.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\trep(i, dp[n - 1][0][0][1].second.vec.size()) {\n\t\tb -= dp[n - 1][0][0][1].second.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tc += dp[n - 1][0][0][1].second.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\ta -= dp[n - 1][0][0][1].third / 2;\n\tc += dp[n - 1][0][0][1].third / 2;\n\n\trep(i, dp[n - 1][1][0][1].first.vec.size()) {\n\t\ta -= dp[n - 1][1][0][1].first.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tb += dp[n - 1][1][0][1].first.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\trep(i, dp[n - 1][1][0][1].second.vec.size()) {\n\t\tb -= dp[n - 1][1][0][1].second.vec[i] * fact[i];\n\t\trep(j, i + 1) {\n\t\t\tc += dp[n - 1][1][0][1].second.vec[i] * fact[i] * inv[j];\n\t\t}\n\t}\n\ta -= dp[n - 1][1][0][1].third / 2;\n\tc += dp[n - 1][1][0][1].third / 2;\n\n\tcout << a << \" \" << b << \" \" << c << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long N;\n    cin >> N;\n    if(N == 1){\n        char c;\n        cin >> c;\n        cout << \"500000004 0 \" << (c == 'X' ? 500000003 : 500000004) << endl;\n        return 0;\n    }\n    string s;\n    cin >> s;\n    if(s.find(\"---\") != string::npos || s.find(\"XX\") != string::npos){\n        puts(\"0 0 0\");\n        return 0;\n    }\n    vector<long> tapi;\n    if(s[0] == s[1] && s[0] == '-')tapi.push_back(1);\n    long now = s[0] == 'X' ? 1 : s[1] == 'X' ? 2 : 3, cnt(-1);\n    bool f(0);\n    for(; now < s.size(); ++now){\n        if(s[now] == '-')++cnt;\n        else{\n            if(cnt == 1)f = true;\n            tapi.push_back(cnt);\n            cnt = -1;\n        }\n    }\n    cout << (!f ? 500000004 : 0) << \" 0\";\n    if(cnt == 1)tapi.push_back(1);\n\n    puts(\"\\nsorry...\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\nvector<int> fact, inv, inv_fact, inv_fact_sum;\n\nstruct poly {\n  vector<int> p, q;\n  int c;\n\n  poly(vector<int> p = vector<int>(), vector<int> q = vector<int>(), int c = 0): p(p), q(q), c(c) {\n  }\n};\n\nstruct info {\n  int p, q, r;\n\n  info(int p = 0, int q = 0, int r = 0): p(p), q(q), r(r) {\n  }\n};\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (int) ((long long) x * y % md);\n}\n\nvector<int>& operator += (vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); ++i) {\n    add(a[i], b[i]);\n  }\n  return a;\n}\n\npoly& operator += (poly &a, const poly &b) {\n  a.p += b.p;\n  a.q += b.q;\n  add(a.c, b.c);\n  return a;\n}\n\ninfo& operator += (info &a, const info &b) {\n  add(a.p, b.p);\n  add(a.q, b.q);\n  add(a.r, b.r);\n  return a;\n}\n\ninfo& operator -= (info &a, const info &b) {\n  sub(a.p, b.p);\n  sub(a.q, b.q);\n  sub(a.r, b.r);\n  return a;\n}\n\npoly integral_0_x(const poly &a) {\n  vector<int> pp, qq;\n  int cc;\n  pp.push_back(a.c);\n  for (int i = 0; i < (int) a.p.size(); ++i) {\n    pp.push_back(mul(a.p[i], inv[i + 1]));\n  }\n  qq.push_back(0);\n  for (int i = 0; i < (int) a.q.size(); ++i) {\n    qq.push_back(mul(a.q[i], inv[i + 1]));\n  }\n  cc = (md - a.c) % md;\n  return poly(pp, qq, cc);\n}\n\npoly integral_x_1(const poly &a) {\n  vector<int> pp, qq;\n  int cc;\n  pp.push_back(0);\n  for (int i = 0; i < (int) a.p.size(); ++i) {\n    int coef = mul(a.p[i], inv[i + 1]);\n    add(pp[0], coef);\n    pp.push_back((md - coef) % md);\n  }\n  qq.push_back((md - a.c) % md);\n  for (int i = 0; i < (int) a.q.size(); ++i) {\n    int coef = mul(a.q[i], inv[i + 1]);\n    add(qq[0], coef);\n    qq.push_back((md - coef) % md);\n  }\n  cc = a.c;\n  return poly(pp, qq, cc);\n}\n\ninfo integral_0_1(const poly &a) {\n  int p, q, r;\n  p = a.c;\n  for (int i = 0; i < (int) a.p.size(); ++i) {\n    add(p, mul(a.p[i], inv[i + 1]));\n  }\n  q = (md - a.c) % md;\n  for (int i = 0; i < (int) a.q.size(); ++i) {\n    add(q, mul(a.q[i], inv[i + 1]));\n  }\n  r = 0;\n  return info(p, q, r);\n}\n\ninfo integral_0_1_e(const poly &a) {\n  int p, q, r;\n  p = 0;\n  for (int i = 0; i < (int) a.p.size(); ++i) {\n    add(p, mul(a.p[i], fact[i]));\n  }\n  add(p, mul(a.c, (md + 1) >> 1));\n  q = 0;\n  for (int i = 0; i < (int) a.p.size(); ++i) {\n    sub(q, mul(a.p[i], mul(fact[i], inv_fact_sum[i])));\n  }\n  for (int i = 0; i < (int) a.q.size(); ++i) {\n    add(q, mul(a.q[i], fact[i]));\n  }\n  r = 0;\n  for (int i = 0; i < (int) a.q.size(); ++i) {\n    sub(r, mul(a.q[i], mul(fact[i], inv_fact_sum[i])));\n  }\n  sub(r, mul(a.c, (md + 1) >> 1));\n  return info(p, q, r);\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  string s;\n  cin >> n >> s;\n  vector<vector<vector<vector<poly>>>> dp(n, vector<vector<vector<poly>>>(2, vector<vector<poly>>(2, vector<poly>(2))));\n  fact.resize(n + 1);\n  inv.resize(n + 1);\n  inv_fact.resize(n + 1);\n  inv_fact_sum.resize(n + 1);\n  fact[0] = fact[1] = inv[0] = inv[1] = inv_fact[0] = inv_fact[1] = inv_fact_sum[0] = 1;\n  inv_fact_sum[1] = 2;\n  for (int i = 2; i <= n; ++i) {\n    fact[i] = mul(fact[i - 1], i);\n    inv[i] = mul(md - md / i, inv[md % i]);\n    inv_fact[i] = mul(inv_fact[i - 1], inv[i]);\n    inv_fact_sum[i] = inv_fact_sum[i - 1];\n    add(inv_fact_sum[i], inv_fact[i]);\n  }\n  if (s[0] == 'X') {\n    dp[0][0][1][0] = poly(vector<int>(), vector<int>(), 1);\n  } else {\n    dp[0][0][0][1] = poly(vector<int>(), vector<int>(), 1);\n    dp[0][1][1][1] = poly(vector<int>(1, 1), vector<int>(), md - 1);\n  }\n  for (int i = 1; i < n; ++i) {\n    if (s[i] == 'X') {\n      for (int j = 0; j < 2; ++j) {\n        dp[i][0][1][0] += integral_0_x(dp[i - 1][1][1][j]);\n      }\n      for (int j = 0; j < 2; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp[i][0][1][0] += integral_x_1(dp[i - 1][j][k][1]);\n        }\n      }\n    } else {\n      for (int j = 0; j < 2; ++j) {\n        dp[i][0][0][1] += integral_0_x(dp[i - 1][1][1][j]);\n        dp[i][1][1][1] += integral_0_x(dp[i - 1][0][1][j]);\n      }\n      for (int j = 0; j < 2; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp[i][0][0][1] += integral_x_1(dp[i - 1][j][1][k]);\n        }\n      }\n    }\n  }\n  info ans;\n  for (int i = 0; i < 2; ++i) {\n    ans += integral_0_1(dp[n - 1][i][0][1]);\n    ans += integral_0_1(dp[n - 1][i][1][1]);\n    ans += integral_0_1_e(dp[n - 1][i][1][0]);\n    ans -= integral_0_1_e(dp[n - 1][i][0][1]);\n  }\n  cout << ans.p << \" \" << ans.q << \" \" << ans.r << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=1e9+7;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this *= x.inv();}\n    bool operator==(const Mint& x) const{return val == x.val;}\n    bool operator!=(const Mint& x) const{return val != x.val;}\n    bool operator<(const Mint& x) const{return val < x.val;}\n    bool operator<=(const Mint& x) const{return val <= x.val;}\n    bool operator>(const Mint& x) const{return val > x.val;}\n    bool operator>=(const Mint& x) const{return val >= x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\ntypedef tuple<vector<Mint>,vector<Mint>,Mint> func;\ntypedef tuple<Mint,Mint,Mint> T;\nfunc to_f(T t){return func{{get<0>(t)},{get<1>(t)},get<2>(t)};}\nvoid v_add(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]+=b[i];\n}\nvoid v_dec(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]-=b[i];\n}\nvoid t_add(T &a,T b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(T &a,T b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nvoid f_add(func &a,func b){v_add(get<0>(a),get<0>(b)),v_add(get<1>(a),get<1>(b)),get<2>(a)+=get<2>(b);}\nfunc f_dec(func a,func b){v_dec(get<0>(a),get<0>(b)),v_dec(get<1>(a),get<1>(b)),get<2>(a)-=get<2>(b); return a;}\nfunc integral(func f){\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    p.resize(p.size()+1); q.resize(q.size()+1);\n    rrep(i,p.size()-1,0)p[i]=p[i-1]/Mint(i); p[0]=0;\n    rrep(i,q.size()-1,0)q[i]=q[i-1]/Mint(i); q[0]=0;\n    get<2>(f)*=-1; return func{p,q,get<2>(f)};\n}\nfunc int_x(func f){f=integral(f); return f_dec(f,{{get<2>(f)},{0},0});}\nT int_1(func f){\n    f=integral(f); T res;\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i];\n    rep(i,0,q.size())get<1>(res)+=q[i];\n    get<0>(res)-=get<2>(f); get<1>(res)+=get<2>(f); return res;\n}\nMint pre[1010][2];\nvoid calc(){\n    pre[0][0]=pre[0][1]=1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*Mint(i+1);\n        pre[i+1][1]=pre[i][1]*Mint(i+1)+1;\n        pre[i][1]*=-1;\n    }\n}\nT int_e(func f){\n    T res; vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\n\nfunc dp[1010][2][3];\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    string s; cin>>s; calc();\n    if(s[0]=='X')dp[0][0][0]={{0},{0},1};\n    else dp[0][0][1]={{0},{0},1},dp[0][1][2]={{1},{0},-1};\n    rep(i,1,n){\n        if(s[i]=='X'){\n            f_add(dp[i][0][0],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][0],int_x(dp[i-1][1][2]));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][1])),int_x(dp[i-1][0][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][1])),int_x(dp[i-1][1][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n        else{\n            f_add(dp[i][0][1],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][1],int_x(dp[i-1][1][2]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][0]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][2]));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][0])),int_x(dp[i-1][0][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][0])),int_x(dp[i-1][1][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n    } T ans;\n    rep(i,0,2){\n        t_add(ans,int_e(dp[n-1][i][0]));\n        t_add(ans,int_1(dp[n-1][i][1]));\n        t_dec(ans,int_e(dp[n-1][i][1]));\n        t_add(ans,int_1(dp[n-1][i][2]));\n    }\n    printf(\"%d %d %d\\n\",get<0>(ans).mtoi(),get<1>(ans).mtoi(),get<2>(ans).mtoi());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9)+7>;\n\nconst int MAXN = 1.1e3;\nint N;\nnum ifact[MAXN*2+1];\nnum H[MAXN];\nnum den[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\n\tifact[0] = 1;\n\tfor (int i = 1; i <= 2*N+1; i++) ifact[i] = ifact[i-1] * num(i);\n\tifact[2*N+1] = inv(ifact[2*N+1]);\n\tfor (int i = 2*N+1; i >= 1; i--) ifact[i-1] = ifact[i] * num(i);\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tden[i] = ifact[2*i] - (i > 0 ? ifact[2*i-1] : 0);\n\t\tH[i] = ifact[2*i] - ifact[2*i+1];\n\t}\n\tassert(den[0] == num(1));\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 1; i+j <= N; j++) {\n\t\t\tH[i+j] -= H[i] * den[j];\n\t\t}\n\t}\n\n\tstring S; cin >> S;\n\tvector<int> breaks;\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tif (S[i] == '-' && S[i+1] == '-') breaks.push_back(i);\n\t}\n\n\tif (breaks.empty()) {\n\t\tint numX = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnumX += S[i] == 'X';\n\t\t}\n\t\tnum valC = num(1);\n\t\tnum ans = inv(num(2));\n\t\tfor (int i = 0; i < numX; i++) {\n\t\t\tans -= valC;\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tcout << inv(num(2)) << ' ' << 0 << ' ' << ans << '\\n';\n\t\texit(0);\n\t}\n\n\tnum ans = 1;\n\tfor (int z = 0; z+1 < int(breaks.size()); z++) {\n\t\tans *= H[(breaks[z+1] - breaks[z]) / 2];\n\t}\n\t{\n\t\tnum valC = num(1);\n\t\tfor (int i = 0; i < (breaks.front()+1)/2; i++) {\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tans *= valC;\n\t}\n\t{\n\t\tnum valC = num(1);\n\t\tfor (int i = 0; i < (N-1-breaks.back())/2; i++) {\n\t\t\tvalC -= H[i];\n\t\t}\n\t\tans *= valC;\n\t}\n\tcout << 0 << ' ' << 0 << ' ' << ans << '\\n';\n\n\treturn 0;\n}\n\n// Note that the constraint is satisfied iff all dashes are next to an earlier X\n// This means that -- can't interact with each other, so we just want to solve\n// (...-)-X-X-X-X-(-...)\n//\n// Let f be the g.f. of P(...X-X-X... is good) * y^{2 * #X's}\n// Then, caseworking on min gives\n// y f'(y) - (f(y) - 1) = y^2 f(y)\n// f(y) = cosh(y) / (cosh(y) - y * sinh(y))\n//\n// Let g be the g.f. of P(...X-X-X-... is good) * y^{2 * #X's}\n// y g'(y) = y^2 f(y) g(y)\n// g(y) = 1 / (cosh(y) - y * sinh(y))\n//\n// Let h be the g.f. of P(...-X-X-X-... is good) * y^{2 * #X's} (>= 1 X's)\n// h(y) = (cosh(y) - sinh(y)/y) / (cosh(y) - y * sinh(y))\n//\n// So we just need terms of h(y)\n//\n// Also, for a given location, P(...-|- stuff on the left ends in -) = 1 - 1/1 + 1/2! - 1/3! ... = 1/e\n// (We're caseworking on length of increasing sequence to the -)\n//\n// Then, let c be the g.f. of e * P(...X-X-X-|-) * y^{2 * #X's} is\n// c(y) = 1 / (1-y^2) - y^2 / (1-y^2) * h(y)\n// = cosh(h) / (cosh(y) - y * sinh(y)) = f(y)\n//\n// Let d be the g.f. of e^2 * P(...X-X-X...) * y^{2 * #X's}\n// We do inclusion-exclusion:\n// y^2 d(y) - d(y) + (e^2 - 1) / 2 y^2 = (c(y) - 1) * y^2\n// d(y) = (e^2+1)/2 / (1-y^2) - c(y) * y^2 / (1-y^2)\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define pb push_back\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n#define iFr(i,n) for(int i=n;i>0;i--)\n\nconst ll MOD=1e9+7;\n\nll ad(ll x,ll y=0){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y=1){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll inv(ll x){\n  return pwr(x,MOD-2);\n}\n\nll fc[1010]={1};\nll fct(ll x){\n  if(fc[x]==0) fc[x]=mlt(x,fct(x-1));\n  return fc[x];\n}\n\nll ifc[1010]={1};\nll ifct(ll x){\n  if(ifc[x]==0) ifc[x]=inv(fct(x));\n  return ifc[x];\n}\n\nll Bn[1010]={0};\nll bn(ll x){\n  if(x>0&&Bn[x]==0) Bn[x]=ad(1,mlt(x,bn(x-1)));\n  return Bn[x];\n}\n\nint main(){\n  ll n,num=1,dp[1010][2][1010]={},dpc[1010]={},kari;\n  bool f[1010];\n  string s;\n  cin>>n>>s;\n  int q=0,r=n;\n  n=-1;\n  if(s[q]=='-') q++;\n  if(s[q]=='-'){q++;n++;num++;}\n  if(s[q]=='-'){cout<<\"0 0 0\"<<endl;return 0;}\n  for(int i=q;i<r;i++){\n    if(s[i]=='X'){\n      if(num==0){cout<<\"0 0 0\"<<endl;return 0;}\n      if(n>=0) f[n]=num-1;\n      n++;num=0;\n    }\n    else{\n      if(num>1){cout<<\"0 0 0\"<<endl;return 0;}\n      num++;\n    }\n  }\n  if(num==2) f[n++]=1;\n  dpc[0]=1;\n  fr(i,n){\n    if(f[i]){\n      fr(j,2){\n        fr(k,2*n+2){\n          kari=inv(k*k+3*k+2);\n          dp[i+1][j][0]=ad(dp[i+1][j][0],mlt(dp[i][j][k],kari));\n          dp[i+1][j][1]=ad(dp[i+1][j][1],mlt(dp[i][j][k],MOD-kari));\n        }\n      }\n      dp[i+1][1][0]=ad(dp[i+1][1][0],dpc[i]);\n      dp[i+1][1][1]=ad(dp[i+1][1][1],MOD-dpc[i]);\n    }\n    else{\n      fr(j,2){\n        fr(k,2*n+2){\n          kari=inv(k+1);\n          dp[i+1][j][0]=ad(dp[i+1][j][0],mlt(dp[i][j][k],kari));\n          dp[i+1][j][1]=ad(dp[i+1][j][1],mlt(dp[i][j][k],MOD-kari));\n          dp[i+1][j][k+2]=ad(dp[i+1][j][k+2],mlt(dp[i][j][k],inv(k*k+3*k+2)));\n        }\n      }\n      dp[i+1][1][1]=ad(dp[i+1][1][1],dpc[i]);\n      dp[i+1][1][0]=ad(dp[i+1][1][0],MOD-dpc[i]);\n      dpc[i+1]=ad(dpc[i+1],dpc[i]);\n    }\n  }\n  ll ans[3]={};\n  fr(j,2){\n    fr(k,2*n+2){\n      ans[j]=ad(ans[j],mlt(dp[n][j][k],fct(k)));\n      ans[j+1]=ad(ans[j+1],mlt(dp[n][j][k],MOD-ad(fct(k),bn(k))));\n    }\n  }\n  kari=(MOD+1)/2;\n  ans[0]=ad(ans[0],mlt(dpc[n],kari));\n  ans[2]=ad(ans[2],mlt(dpc[n],MOD-kari));\n  cout<<ans[0]<<\" \"<<ans[1]<<\" \"<<ans[2]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define moduro (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= moduro) >= 0 ? a : a + moduro;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a* power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, moduro - 2);\n}\n\nstruct Func{\n\tvector<int> a;\n\tvector<int> b;\n\tint c;\n\n\tFunc(int L) : a(L + 1, 0), b(L + 1, 0), c(0){}\n};\n\nint L;\n\nFunc integral(Func f, char x){\n\tint i;\n\tFunc ans(L);\n\tif(x == '<'){\n\t\tfor(i = 0; i < L; i++){\n\t\t\tans.a[i + 1] = MOD(f.a[i] * inverse(i + 1));\n\t\t\tans.b[i + 1] = MOD(f.b[i] * inverse(i + 1));\n\t\t}\n\t\tans.c = MOD(-f.c);\n\t\tans.a[0] = MOD(f.c);\n\t}\n\telse{\n\t\tans.b[0] = MOD(-f.c);\n\t\tfor(i = 0; i < L; i++){\n\t\t\tans.a[i + 1] = MOD(-f.a[i] * inverse(i + 1));\n\t\t\tans.b[i + 1] = MOD(-f.b[i] * inverse(i + 1));\n\t\t\tans.a[0] = MOD(ans.a[0] + f.a[i] * inverse(i + 1));\n\t\t\tans.b[0] = MOD(ans.b[0] + f.b[i] * inverse(i + 1));\n\t\t}\n\t\tans.c = MOD(f.c);\n\t}\n\treturn ans;\n}\n\nFunc Func_plus(Func f1, Func f2){\n\tFunc ans(L);\n\tfor(int i = 0; i <= L; i++){\n\t\tans.a[i] = MOD(f1.a[i] + f2.a[i]);\n\t\tans.b[i] = MOD(f1.b[i] + f2.b[i]);\n\t}\n\tans.c = MOD(f1.c + f2.c);\n\treturn ans;\n}\n\ntuple<int, int, int> solve(vector<int> &interval){\n\tint i, j;\n\tL = interval.size();\n\tfor(i = 0; i < interval.size(); i++){\n\t\tif(!(interval[i] == 1 || interval[i] == 2)){\n\t\t\treturn make_tuple(0, 0, 0);\n\t\t}\n\t\tL += interval[i];\n\t}\n\tFunc f(L);\n\tf.c = 1;\n\tfor(i = 0; i < interval.size(); i++){\n\t\tif(interval[i] == 1){\n\t\t\tFunc f1 = integral(f, '<');\n\t\t\tFunc f2 = integral(f, '>');\n\t\t\tFunc f11 = integral(f1, '<');\n\t\t\tFunc f12 = integral(f1, '>');\n\t\t\tFunc f22 = integral(f2, '>');\n\t\t\tf = Func_plus(Func_plus(f11, f12), f22);\n\t\t}\n\t\telse{\n\t\t\tFunc f1 = integral(f, '<');\n\t\t\tFunc f11 = integral(f1, '<');\n\t\t\tFunc f12 = integral(f1, '>');\n\t\t\tFunc f112 = integral(f11, '>');\n\t\t\tFunc f122 = integral(f12, '>');\n\t\t\tf = Func_plus(f112, f122);\n\t\t}\n\t}\n\tint p = 0, q = 0, r = 0;\n\t//ここから部分積分\n\tp = MOD(f.c * inverse(2));\n\tr = MOD(-f.c * inverse(2));\n\tvector<vector<int>> as(L + 2, vector<int>(L + 1, 0));\n\tfor(i = 0; i <= L; i++){\n\t\tas[0][i] = f.a[i];\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tp = MOD(p + as[i][0]);\n\t\tfor(j = 0; j <= L; j++){\n\t\t\tq = MOD(q - as[i][j]);\n\t\t}\n\t\tfor(j = 1; j <= L; j++){\n\t\t\tas[i + 1][j - 1] = MOD(j * as[i][j]);\n\t\t}\n\t}\n\tvector<vector<int>> bs(L + 2, vector<int>(L + 1, 0));\n\tfor(i = 0; i <= L; i++){\n\t\tbs[0][i] = f.b[i];\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tq = MOD(q + bs[i][0]);\n\t\tfor(j = 0; j <= L; j++){\n\t\t\tr = MOD(r - bs[i][j]);\n\t\t}\n\t\tfor(j = 1; j <= L; j++){\n\t\t\tbs[i + 1][j - 1] = MOD(j * bs[i][j]);\n\t\t}\n\t}\n\treturn make_tuple(p, q, r);\n}\n\nstring edge_begin[3] = {\"X\", \"X-\", \"X--\"};\nstring edge_end[3] = {\"X\", \"-X\", \"--X\"};\n\nsigned main(){\n\tint N, i, j, k;\n\tint p = 0, q = 0, r = 0;\n\tscanf(\"%lld\", &N);\n\tstring s;\n\tcin >> s;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n\t\t\tstring s_sub = edge_begin[i] + s + edge_end[j];\n\t\t\tint rast = 0;\n\t\t\tvector<int> interval(0);\n\t\t\tfor(k = 1; k < s_sub.size(); k++){\n\t\t\t\tif(s_sub[k] == 'X'){\n\t\t\t\t\tinterval.push_back(k - rast - 1);\n\t\t\t\t\trast = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttuple<int, int, int> res = solve(interval);\n\t\t\tp = MOD(p + get<0>(res));\n\t\t\tq = MOD(q + get<1>(res));\n\t\t\tr = MOD(r + get<2>(res));\n\t\t}\n\t}\n\tprintf(\"%lld %lld %lld\\n\", p, q, r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 27.01.2020 04:52:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  for (int i = 0; i < n - 1; i++) {\n    if (s[i] == 'X' && s[i + 1] == 'X') {\n      cout << \"0 0 0\" << '\\n';\n      return 0;\n    }\n  }\n  if (s[0] == 'X') {\n    s = \"-\" + s;\n  }\n  if (s.back() == 'X') {\n    s = s + \"-\";\n  }\n  vector<int> a;\n  int start = 0;\n  for (int i = 0; i < (int) s.size(); i++) {\n    if (i == (int) s.size() - 1 || (s[i] == '-' && s[i + 1] == '-')) {\n      a.push_back((i - start + 1) / 2);\n      start = i + 1;\n    }\n  }\n  int sz = (int) a.size();\n  for (int i = 1; i < sz - 1; i++) {\n    if (a[i] == 0) {\n      cout << \"0 0 0\" << '\\n';\n      return 0;\n    }\n  }\n  const int M = n + 3;\n  vector<Mint> f(M);\n  f[0] = 1;\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      f[i] += f[j] * f[i - 1 - j] / Mint(2 * i - 1);\n    }\n  }\n  vector<Mint> g(M);\n  g[0] = 1;\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      g[i] += g[j] * f[i - 1 - j] / Mint(2 * i);\n    }\n  }\n  vector<Mint> h(M);\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      h[i] += g[j] * g[i - 1 - j] / Mint(2 * i + 1);\n    }\n  }\n  vector<Mint> c(M);\n  for (int i = 0; i < M; i++) {\n    c[i] = 1;\n    for (int j = 1; j < i; j++) {\n      c[i] -= h[j];\n    }\n  }\n  if (sz == 1) {\n    int len = (int) s.size() - 1;\n    Mint ans = 0;\n    if (len == 0) {\n      ans = Mint(1) / 2;\n    }\n    for (int i = 0; i < len - 1; i++) {\n      ans -= c[(i + 1) >> 1] / 2;\n    }\n    cout << Mint(1) / 2 << \" 0 \" << ans << '\\n';\n    return 0;\n  }\n  Mint ans = c[a[0]] * c[a[sz - 1]];\n  for (int i = 1; i < sz - 1; i++) {\n    ans *= h[a[i]];\n  }\n  cout << \"0 0 \" << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define pb push_back\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n#define iFr(i,n) for(int i=n;i>0;i--)\n\nconst ll MOD=1e9+7;\n\nll ad(ll x,ll y=0){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y=1){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll inv(ll x){\n  return pwr(x,MOD-2);\n}\n\nll fc[1010]={1};\nll fct(ll x){\n  if(fc[x]==0) fc[x]=mlt(x,fct(x-1));\n  return fc[x];\n}\n\nll ifc[1010]={1};\nll ifct(ll x){\n  if(ifc[x]==0) ifc[x]=inv(fct(x));\n  return ifc[x];\n}\n\nll Bn[1010]={0};\nll bn(ll x){\n  if(x>0&&Bn[x]==0) Bn[x]=ad(1,mlt(x,bn(x-1)));\n  return Bn[x];\n}\n\nint main(){\n  ll n,num=1,dp[1010][2][1010]={},dpc[1010]={},kari;\n  bool f[1010];\n  string s;\n  cin>>n>>s;\n  if(n==1&&s==\"-\"){\n    cout<<(MOD+1)/2<<\" \"<<0<<\" \"<<(MOD+1)/2<<endl;\n    return 0;\n  }\n  int q=0,r=n;\n  n=-1;\n  if(s[q]=='-') q++;\n  if(s[q]=='-'){q++;n++;num++;}\n  if(s[q]=='-'){cout<<\"0 0 0\"<<endl;return 0;}\n  for(int i=q;i<r;i++){\n    if(s[i]=='X'){\n      if(num==0){cout<<\"0 0 0\"<<endl;return 0;}\n      if(n>=0) f[n]=num-1;\n      n++;num=0;\n    }\n    else{\n      if(num>1){cout<<\"0 0 0\"<<endl;return 0;}\n      num++;\n    }\n  }\n  if(num==2) f[n++]=1;\n  dpc[0]=1;\n  fr(i,n){\n    if(f[i]){\n      fr(j,2){\n        fr(k,2*n+2){\n          kari=inv(k*k+3*k+2);\n          dp[i+1][j][0]=ad(dp[i+1][j][0],mlt(dp[i][j][k],kari));\n          dp[i+1][j][1]=ad(dp[i+1][j][1],mlt(dp[i][j][k],MOD-kari));\n        }\n      }\n      dp[i+1][1][0]=ad(dp[i+1][1][0],dpc[i]);\n      dp[i+1][1][1]=ad(dp[i+1][1][1],MOD-dpc[i]);\n    }\n    else{\n      fr(j,2){\n        fr(k,2*n+2){\n          kari=inv(k+1);\n          dp[i+1][j][0]=ad(dp[i+1][j][0],mlt(dp[i][j][k],kari));\n          dp[i+1][j][1]=ad(dp[i+1][j][1],mlt(dp[i][j][k],MOD-kari));\n          dp[i+1][j][k+2]=ad(dp[i+1][j][k+2],mlt(dp[i][j][k],inv(k*k+3*k+2)));\n        }\n      }\n      dp[i+1][1][1]=ad(dp[i+1][1][1],dpc[i]);\n      dp[i+1][1][0]=ad(dp[i+1][1][0],MOD-dpc[i]);\n      dpc[i+1]=ad(dpc[i+1],dpc[i]);\n    }\n  }\n  ll ans[3]={};\n  fr(j,2){\n    fr(k,2*n+2){\n      ans[j]=ad(ans[j],mlt(dp[n][j][k],fct(k)));\n      ans[j+1]=ad(ans[j+1],mlt(dp[n][j][k],MOD-ad(fct(k),bn(k))));\n    }\n  }\n  kari=(MOD+1)/2;\n  ans[0]=ad(ans[0],mlt(dpc[n],kari));\n  ans[2]=ad(ans[2],mlt(dpc[n],MOD-kari));\n  cout<<ans[0]<<\" \"<<ans[1]<<\" \"<<ans[2]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define moduro (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= moduro) >= 0 ? a : a + moduro;\n}\n\nint power(int a, int N){\n\tif(N == 0){\n\t\treturn 1;\n\t}\n\telse if(N % 2 == 0){\n\t\treturn power(MOD(a * a), N / 2);\n\t}\n\telse{\n\t\treturn MOD(a* power(a, N - 1));\n\t}\n}\n\nint inverse(int a){\n\treturn power(a, moduro - 2);\n}\n\nstruct Func{\n\tvector<int> a;\n\tvector<int> b;\n\tint c;\n\n\tFunc(int L) : a(L + 1, 0), b(L + 1, 0), c(0){\n//\t\ta.assign(L + 1, 0);\n//\t\tb.assign(L + 1, 0);\n//\t\tc = 0;\n\t}\n};\n\nint L;\n\nvoid output_Func(Func f){\n\tint i;\n\tfor(i = 0; i <= L; i++){\n\t\tprintf(\"%lld \", f.a[i]);\n\t}\n\tprintf(\"\\n\");\n\tfor(i = 0; i <= L; i++){\n\t\tprintf(\"%lld \", f.b[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"%lld\\n\", f.c);\n\tprintf(\"\\n\");\n}\n\nFunc integral(Func f, char x){\n\tint i;\n\tFunc ans(L);\n\tif(x == '<'){\n\t\tfor(i = 0; i < L; i++){\n\t\t\tans.a[i + 1] = MOD(f.a[i] * inverse(i + 1));\n\t\t\tans.b[i + 1] = MOD(f.b[i] * inverse(i + 1));\n\t\t}\n\t\tans.c = MOD(-f.c);\n\t\tans.a[0] = MOD(f.c);\n\t}\n\telse{\n\t\tans.b[0] = MOD(-f.c);\n\t\tfor(i = 0; i < L; i++){\n\t\t\tans.a[i + 1] = MOD(-f.a[i] * inverse(i + 1));\n\t\t\tans.b[i + 1] = MOD(-f.b[i] * inverse(i + 1));\n\t\t\tans.a[0] = MOD(ans.a[0] + f.a[i] * inverse(i + 1));\n\t\t\tans.b[0] = MOD(ans.b[0] + f.b[i] * inverse(i + 1));\n\t\t}\n\t\tans.c = MOD(f.c);\n\t}\n\treturn ans;\n}\n\nFunc Func_plus(Func f1, Func f2){\n\tFunc ans(L);\n\tfor(int i = 0; i <= L; i++){\n\t\tans.a[i] = MOD(f1.a[i] + f2.a[i]);\n\t\tans.b[i] = MOD(f1.b[i] + f2.b[i]);\n\t}\n\tans.c = MOD(f1.c + f2.c);\n\treturn ans;\n}\n\ntuple<int, int, int> solve(vector<int> &interval){\n\tint i, j;\n\tL = interval.size();\n\tfor(i = 0; i < interval.size(); i++){\n\t\tif(!(interval[i] == 1 || interval[i] == 2)){\n\t\t\treturn make_tuple(0, 0, 0);\n\t\t}\n\t\tL += interval[i];\n\t}\n\tFunc f(L);\n\tf.c = 1;\n\tfor(i = 0; i < interval.size(); i++){\n/*\t\tprintf(\"old_f:\\n\");\n\t\toutput_Func(f);\n*/\t\tif(interval[i] == 1){\n\t\t\tFunc f1 = integral(f, '<');\n\t\t\tFunc f2 = integral(f, '>');\n\t\t\tFunc f11 = integral(f1, '<');\n\t\t\tFunc f12 = integral(f1, '>');\n\t\t\tFunc f22 = integral(f2, '>');\n\t\t\tf = Func_plus(Func_plus(f11, f12), f22);\n/*\t\t\tprintf(\"f1:\\n\");\n\t\t\toutput_Func(f1);\n\t\t\tprintf(\"f2:\\n\");\n\t\t\toutput_Func(f2);\n\t\t\tprintf(\"f11:\\n\");\n\t\t\toutput_Func(f11);\n\t\t\tprintf(\"f12:\\n\");\n\t\t\toutput_Func(f12);\n\t\t\tprintf(\"f22:\\n\");\n\t\t\toutput_Func(f22);\n*/\t\t}\n\t\telse if(interval[i] == 2){\n\t\t\tFunc f1 = integral(f, '<');\n\t\t\tFunc f11 = integral(f1, '<');\n\t\t\tFunc f12 = integral(f1, '>');\n\t\t\tFunc f112 = integral(f11, '>');\n\t\t\tFunc f122 = integral(f12, '>');\n\t\t\tf = Func_plus(f112, f122);\n\t\t}\n\t\telse{\n\t\t\treturn make_tuple(0, 0, 0);\n\t\t}\n/*\t\tprintf(\"f:\\n\");\n\t\toutput_Func(f);\n*/\t}\n\tint p = 0, q = 0, r = 0;\n\tp = MOD(f.c * inverse(2));\n\tr = MOD(-f.c * inverse(2));\n\tvector<vector<int>> as(L + 2, vector<int>(L + 1, 0));\n\tfor(i = 0; i <= L; i++){\n\t\tas[0][i] = f.a[i];\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tp = MOD(p + as[i][0]);\n\t\tfor(j = 0; j <= L; j++){\n\t\t\tq = MOD(q - as[i][j]);\n\t\t}\n\t\tfor(j = 1; j <= L; j++){\n\t\t\tas[i + 1][j - 1] = MOD(j * as[i][j]);\n\t\t}\n\t}\n\tvector<vector<int>> bs(L + 2, vector<int>(L + 1, 0));\n\tfor(i = 0; i <= L; i++){\n\t\tbs[0][i] = f.b[i];\n\t}\n\tfor(i = 0; i <= L; i++){\n\t\tq = MOD(q + bs[i][0]);\n\t\tfor(j = 0; j <= L; j++){\n\t\t\tr = MOD(r - bs[i][j]);\n\t\t}\n\t\tfor(j = 1; j <= L; j++){\n\t\t\tbs[i + 1][j - 1] = MOD(j * bs[i][j]);\n\t\t}\n\t}\n//\tprintf(\"(p, q, r) = (%lld, %lld, %lld)\\n\", p, q, r);\n\treturn make_tuple(p, q, r);\n}\n\nstring edge_begin[3] = {\"X\", \"X-\", \"X--\"};\nstring edge_end[3] = {\"X\", \"-X\", \"--X\"};\n\nsigned main(){\n\tint N, i, j, k;\n\tint p = 0, q = 0, r = 0;\n/*\tvector<int> interval_test(2, 1);\n\ttuple<int, int, int> res = solve(interval_test);\n\treturn 0;\n*/\n\tscanf(\"%lld\", &N);\n\tstring s;\n\tcin >> s;\n\tfor(i = 0; i < 3; i++){\n\t\tfor(j = 0; j < 3; j++){\n//\t\t\tprintf(\"(i, j) = (%lld, %lld)\\n\", i, j);\n\t\t\tstring s_sub = edge_begin[i] + s + edge_end[j];\n//\t\t\tcout << s_sub << endl;\n\t\t\tint rast = 0;\n\t\t\tvector<int> interval(0);\n\t\t\tfor(k = 1; k < s_sub.size(); k++){\n\t\t\t\tif(s_sub[k] == 'X'){\n\t\t\t\t\tinterval.push_back(k - rast - 1);\n\t\t\t\t\trast = k;\n\t\t\t\t}\n\t\t\t}\n/*\t\t\tprintf(\"interval:\");\n\t\t\tfor(k = 0; k < interval.size(); k++){\n\t\t\t\tprintf(\"%lld \", interval[k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\t\t\ttuple<int, int, int> res = solve(interval);\n//\t\t\tprintf(\"res = (%lld, %lld, %lld)\\n\", get<0>(res), get<1>(res), get<2> (res));\n\t\t\tp = MOD(p + get<0>(res));\n\t\t\tq = MOD(q + get<1>(res));\n\t\t\tr = MOD(r + get<2>(res));\n/*\t\t\tif(i == 1 && j == 1){\n\t\t\t\treturn 0;\n\t\t\t}\n*/\t\t}\n\t}\n\tprintf(\"%lld %lld %lld\\n\", p, q, r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll; typedef pair<ll, ll> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A,size_t N,typename T>void Fill(A(&array)[N],const T &val){fill((T*)array, (T*)(array+N), val);}\nconst int inf = 0x3fffffff; const ll INF = 0x3fffffffffffffff;\n//template end\n\nll mod=1e9+7;\nstruct Mint {\n    ll val;\n    Mint inv() const{\n        ll tmp,a=val,b=mod,x=1,y=0;\n        while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n        return Mint(x);\n    }\npublic:\n    Mint():val(0){}\n    Mint(ll x):val(x>=0?x%mod:x%mod+mod){}\n    int mtoi(){return this->val; }\n    Mint pow(ll t){Mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n    Mint& operator+=(const Mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n    Mint& operator-=(const Mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n    Mint& operator*=(const Mint& x){val=(ll)val*x.val%mod; return *this;}\n    Mint& operator/=(const Mint& x){return *this *= x.inv();}\n    bool operator==(const Mint& x) const{return val == x.val;}\n    bool operator!=(const Mint& x) const{return val != x.val;}\n    bool operator<(const Mint& x) const{return val < x.val;}\n    bool operator<=(const Mint& x) const{return val <= x.val;}\n    bool operator>(const Mint& x) const{return val > x.val;}\n    bool operator>=(const Mint& x) const{return val >= x.val;}\n    Mint operator+(const Mint& x) const{return Mint(*this)+=x;}\n    Mint operator-(const Mint& x) const{return Mint(*this)-=x;}\n    Mint operator*(const Mint& x) const{return Mint(*this)*=x;}\n    Mint operator/(const Mint& x) const{return Mint(*this)/=x;}\n};\nstruct factorial {\n    vector<Mint> Fact, Finv;\npublic:\n    factorial(int maxx){\n        Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*Mint(i+1);\n        Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*Mint(i);\n    }\n    Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n    Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n    Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\n\ntypedef tuple<vector<Mint>,vector<Mint>,Mint> func;\ntypedef tuple<Mint,Mint,Mint> T;\nfunc to_f(T t){return {{get<0>(t)},{get<1>(t)},get<2>(t)};}\nvoid v_add(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]+=b[i];\n}\nvoid v_dec(vector<Mint> &a,vector<Mint> b){\n    a.resize(max(a.size(),b.size()));\n    rep(i,0,b.size())a[i]-=b[i];\n}\nvoid t_add(T &a,T b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(T &a,T b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nvoid f_add(func &a,func b){v_add(get<0>(a),get<0>(b)),v_add(get<1>(a),get<1>(b)),get<2>(a)+=get<2>(b);}\nfunc f_dec(func a,func b){v_dec(get<0>(a),get<0>(b)),v_dec(get<1>(a),get<1>(b)),get<2>(a)-=get<2>(b); return a;}\nfunc integral(func f){\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    p.resize(p.size()+1); q.resize(q.size()+1);\n    rrep(i,p.size()-1,0)p[i]=p[i-1]/Mint(i); p[0]=0;\n    rrep(i,q.size()-1,0)q[i]=q[i-1]/Mint(i); q[0]=0;\n    get<2>(f)*=-1; return {p,q,get<2>(f)};\n}\nfunc int_x(func f){f=integral(f); return f_dec(f,{{get<2>(f)},{0},0});}\nT int_1(func f){\n    f=integral(f); T res;\n    vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i];\n    rep(i,0,q.size())get<1>(res)+=q[i];\n    get<0>(res)-=get<2>(f); get<1>(res)+=get<2>(f); return res;\n}\nMint pre[1010][2];\nvoid calc(){\n    pre[0][0]=pre[0][1]=1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*Mint(i+1);\n        pre[i+1][1]=pre[i][1]*Mint(i+1)+1;\n        pre[i][1]*=-1;\n    }\n}\nT int_e(func f){\n    T res; vector<Mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\n\nfunc dp[1010][2][3];\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    string s; cin>>s; calc();\n    if(s[0]=='X')dp[0][0][0]={{0},{0},1};\n    else dp[0][0][1]={{0},{0},1},dp[0][1][2]={{1},{0},-1};\n    rep(i,1,n){\n        if(s[i]=='X'){\n            f_add(dp[i][0][0],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][0],int_x(dp[i-1][1][2]));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][1])),int_x(dp[i-1][0][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][1])),int_x(dp[i-1][1][1])));\n            f_add(dp[i][0][0],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n        else{\n            f_add(dp[i][0][1],int_x(dp[i-1][1][0]));\n            f_add(dp[i][0][1],int_x(dp[i-1][1][2]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][0]));\n            f_add(dp[i][1][2],int_x(dp[i-1][0][2]));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][0])),int_x(dp[i-1][0][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][0][2])),int_x(dp[i-1][0][2])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][0])),int_x(dp[i-1][1][0])));\n            f_add(dp[i][0][1],f_dec(to_f(int_1(dp[i-1][1][2])),int_x(dp[i-1][1][2])));\n        }\n    } T ans;\n    rep(i,0,2){\n        t_add(ans,int_e(dp[n-1][i][0]));\n        t_add(ans,int_1(dp[n-1][i][1]));\n        t_dec(ans,int_e(dp[n-1][i][1]));\n        t_add(ans,int_1(dp[n-1][i][2]));\n    }\n    printf(\"%d %d %d\\n\",get<0>(ans).mtoi(),get<1>(ans).mtoi(),get<2>(ans).mtoi());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<tourist>\nint main(){\n  int ans = tourist();\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define pb push_back\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n#define iFr(i,n) for(int i=n;i>0;i--)\n\nstruct modint{\n    using i64=int_fast64_t;\n    i64 a;\n    static constexpr i64 MOD=1e9+7;\n    modint(){a=0;}\n    modint(i64 a_){\n        a=a_%MOD;\n        if(a<0) a+=MOD;\n    }\n    modint inv()const{\n        i64 n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y;\n        y.a=n;\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y;\n        y.a=a+x.a;\n        if(y.a>=MOD) y.a-=MOD;\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y;\n        y.a=a-x.a;\n        if(y.a<0) y.a+=MOD;\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y;\n        y.a=(a*x.a)%MOD;\n        return y;\n    }\n    modint operator/(const modint& x){\n        modint y;\n        y.a=(a*x.inv().a)%MOD;\n        return y;\n    }\n    modint& operator+=(const modint& x){\n        a+=x.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        a-=x.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        (a*=x.a)%=MOD;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        (a*=x.inv().a)%=MOD;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    int_fast64_t a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(int_fast64_t a,int_fast64_t b){\n    modint _;\n    int_fast64_t n=1,A=a;\n    while(b){\n        if(b&1) (n*=A)%=modint::MOD;\n        (A*=A)%=modint::MOD;\n        b>>=1;\n    }\n    _.a=n;\n    return _;\n}\n\ntemplate <int n> struct COMB{\n    int_fast64_t fc[n],ifc[n],Bn[n];\n    constexpr COMB():fc(),ifc(),Bn(){\n        fc[0]=1;\n        for(int i=1;i<n;++i){\n            fc[i]=fc[i-1]*i%modint::MOD;\n            Bn[i]=(Bn[i-1]*i+1)%modint::MOD;\n        }\n        int_fast64_t N=1,A=fc[n-1],b=modint::MOD-2;\n        while(b){\n            if(b&1) (N*=A)%=modint::MOD;\n            (A*=A)%=modint::MOD;\n            b>>=1;\n        }\n        ifc[n-1]=N;\n        for(int i=n-1;i>=1;--i) ifc[i-1]=ifc[i]*i%modint::MOD;\n    };\n    modint operator()(int N,int R)const{\n        if(N<0||R<0||N<R) return 0;\n        return fc[N]*ifc[R]%modint::MOD*ifc[N-R];\n    }\n    modint operator[](int N)const{\n        modint _;\n        _.a=fc[N];\n        return _;\n    }\n    modint operator()(int N)const{\n        modint _;\n        _.a=ifc[N];\n        return _;\n    }\n};\nconstexpr COMB<1010> comb;\n\nmodint dp[1010][2][1010]={},dpc[1010]={},kari{};\nint main(){\n    ll n,num=1;\n    bool f[1010];\n    string s;\n    cin>>n>>s;\n    if(n==1&&s==\"-\"){\n        cout<<(modint::MOD+1)/2<<\" \"<<0<<\" \"<<(modint::MOD+1)/2<<endl;\n        return 0;\n    }\n    int q=0,r=n;\n    n=-1;\n    if(s[q]=='-') q++;\n    if(s[q]=='-'){q++;n++;num++;}\n    if(s[q]=='-'){cout<<\"0 0 0\"<<endl;return 0;}\n    for(int i=q;i<r;i++){\n        if(s[i]=='X'){\n            if(num==0){cout<<\"0 0 0\"<<endl;return 0;}\n            if(n>=0) f[n]=num-1;\n            n++;num=0;\n        }\n        else{\n            if(num>1){cout<<\"0 0 0\"<<endl;return 0;}\n            num++;\n        }\n    }\n    if(num==2) f[n++]=1;\n    dpc[0]=1;\n    fr(i,n){\n        if(f[i]){\n            fr(j,2){\n                fr(k,2*n+2){\n                    kari=modint(k*k+3*k+2).inv();\n                    dp[i+1][j][0]+=dp[i][j][k]*kari;\n                    dp[i+1][j][1]+=dp[i][j][k]*(modint(0)-kari);\n                }\n            }\n            dp[i+1][1][0]+=dpc[i];\n            dp[i+1][1][1]-=dpc[i];\n        }\n        else{\n            fr(j,2){\n                fr(k,2*n+2){\n                    kari=modint(k+1).inv();\n                    dp[i+1][j][0]+=dp[i][j][k]*kari;\n                    dp[i+1][j][1]-=dp[i][j][k]*kari;\n                    dp[i+1][j][k+2]+=dp[i][j][k]/(k*k+3*k+2);\n                }\n            }\n            dp[i+1][1][1]+=dpc[i];\n            dp[i+1][1][0]-=dpc[i];\n            dpc[i+1]+=dpc[i];\n        }\n    }\n    modint ans[3]={};\n    fr(j,2){\n        fr(k,2*n+2){\n            ans[j]+=dp[n][j][k]*comb[k];\n            ans[j+1]-=dp[n][j][k]*(comb[k]+comb.Bn[k]);\n        }\n    }\n    kari=modint(2).inv();\n    ans[0]+=dpc[n]*kari;\n    ans[2]-=dpc[n]*kari;\n    cout<<ans[0]<<\" \"<<ans[1]<<\" \"<<ans[2]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,m) for(long long i=0; i<m; i++)\n#define per(i,m) for(long long i=m-1; i>=0; i--)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define ROF(i,n,m) for(long long i=m-1; i>=n; i--)\n#define SORT(v,n) do{sort(v,v+n);reverse(v,v+n);}while(0)\n#define all(x) (x).begin(),(x).end()\n#define MP make_pair\n#define MT make_tuple\n#define EPS (1e-7)\n#define INF (1e18)\n#define PI (acos(-1))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> LP;\n\n \nll POW(ll x,ll n){\n  x%=MOD;\n  if(n==0)return 1;\n  if(n%2==0)return POW(x*x,n/2)%MOD;\n  return x%MOD*POW(x,n-1)%MOD;\n}\n \nll POW2(ll x,ll n){\n  if(n==0)return 1;\n  if(n%2==0)return POW2(x*x,n/2);\n  return x*POW2(x,n-1);\n}\n \nll POW3(ll x,ll n,ll m){\n  x%=m;\n  if(n==0)return 1;\n  if(n%2==0)return POW3(x*x,n/2,m)%m;\n  return x*POW3(x,n-1,m)%m;\n}\n \nll gcd(ll u, ll v) {\n  ll r;\n  while (0 != v) {\n    r = u % v; u = v; v = r;\n  }\n  return u;\n}\n \nll lcm(ll u, ll v) {\n  return u/gcd(u,v)*v;\n}\n \nll KAI(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI(m-1)%MOD;\n}\n \nll KAI2(ll m)\n{\n  if(m<0) return 0;\n  if(m==0) return 1;\n  return m*KAI2(m-1);\n}\n \nll extGCD(ll a, ll b, ll &x, ll &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    ll d = extGCD(b, a%b, y, x);\n    y -= a / b * x;\n    return d;\n}\n \ninline ll mod(ll a, ll m) {\n    return (a % m + m) % m;\n}\n \nll modinv(ll a) {\n    ll x, y;\n    extGCD(a, MOD, x, y);\n    return mod(x, MOD);\n}\n \nll COM(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI(m)%MOD*modinv(KAI(n)%MOD*KAI(m-n)%MOD)%MOD;\n}\n \nll COM2(ll m,ll n)\n{\n  if(m<n) return 0;\n  if(n<0) return 0;\n  if(n==0) return 1;\n  if(m==n) return 1;\n  return KAI2(m)/KAI2(n)/KAI2(m-n);\n}\n \nll DEC(ll x,ll m,ll n)\n{\n  return x%POW2(m,n+1)/POW2(m,n);\n}\n \nll keta(ll x,ll n)\n{\n  if(x==0)return 0;\n  return keta(x/n,n)+1;\n}\n \nll DIV(ll x,ll n)\n{\n  if(x==0)return 0;\n  return x/n+DIV(x/n,n);\n}\n \nll ORD(ll x,ll n)\n{\n  if(x==0)return INF;\n  if(x%n!=0)return 0;\n  return 1+ORD(x/n,n);\n}\n\nll SUP(ll x,ll n)\n{\n  if(x==0)return 0;\n  if(x%n!=0)return x;\n  return SUP(x/n,n);\n}\n \nll SGS(ll x,ll y, ll m)\n{\n  if(y==0)return 0;\n  if(y%2==0){\n    return (1+POW3(x,y/2,m))*SGS(x,y/2,m)%m;\n  }\n  return (1+x*SGS(x,y-1,m))%m;\n}\n \nll SSGS(ll x,ll y,ll m)\n{\n  if(y==0)return 0;\n  if(y==1)return 1;\n  if(y%2==0){\n    return (SSGS(x,y/2,m)*(POW3(x,y/2,m)+1)%m+SGS(x,y/2,m)*y/2%m)%m;\n  }\n  return (SSGS(x,y-1,m)*x%m+y)%m;\n}\n \nvoid shuffle(ll array[], ll size) {\n    for(ll i = 0; i < size; i++) {\n        ll j = rand()%size;\n        ll t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n}\n\nll SQRT(ll n){\n  ll ok,ng,mid;\n  ng=n+1;\n  if(303700500<ng)ng=303700500;\n  ok=0;\n  while(abs(ok-ng)>1){\n    mid=(ok+ng)/2;\n    if(mid*mid<=n){\n      ok=mid;\n    }\n    else{\n      ng=mid;\n    }\n  }\n  return ok;\n}\n \nstruct UnionFind\n{\n  vector<int> par;\n  vector<int> sizes;\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    rep(i,n) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (sizes[x] < sizes[y]) swap(x, y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nmap< int64_t, int > prime_factor(int64_t n) {\n  map< int64_t, int > ret;\n  for(int64_t i = 2; i * i <= n; i++) {\n    while(n % i == 0) {\n      ret[i]++;\n      n /= i;\n    }\n  }\n  if(n != 1) ret[n] = 1;\n  return ret;\n}\n\nstruct edge{ll to, cost;};\nstruct graph{\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> d;\n\n  graph(ll n){\n    init(n);\n  }\n\n  void init(ll n){\n    V = n;\n    G.resize(V);\n    d.resize(V);\n    rep(i,V){\n      d[i] = INF;\n    }\n  }\n\n  void add_edge(ll s, ll t, ll cost){\n    edge e;\n    e.to = t, e.cost = cost;\n    G[s].push_back(e);\n  }\n\n  void dijkstra(ll s){\n    rep(i,V){\n      d[i] = INF;\n    }\n    d[s] = 0;\n    priority_queue<LP,vector<LP>, greater<LP> > que;\n    que.push(LP(0,s));\n    while(!que.empty()){\n      LP p = que.top(); que.pop();\n      ll v = p.second;\n      if(d[v]<p.first) continue;\n      for(auto e : G[v]){\n        if(d[e.to]>d[v]+e.cost){\n          d[e.to] = d[v]+e.cost;\n          que.push(LP(d[e.to],e.to));\n        }\n      }\n    }\n  }\n};\n\nll d[310][310];\n\nvoid warshall_floyd(ll n){\n  rep(i,n)rep(j,n)rep(k,n)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nstruct bit{\n  ll m;\n  vector<ll> b;\n  bit(ll i){\n    m=i;\n    b.resize(m+1);\n  }\n  ll num(ll i){\n    return b[i];\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){\n      s+=b[i];\n      i-=i&-i;\n    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n    return s;\n  }\n  void add(ll i, ll x){\n    while(i<=m){\n      b[i]+=x;\n      i+=i&-i;\n    }\n  }\n};\n\n\n\nint main()\n{\n  ll n,a[1100][3][3][1100]={},b[1100][3][3][1100]={},c[1100][3][3]={},p[1100],q[1100],x=0,y=0,z=0;\n  string s;\n  cin >> n >> s;\n  if(s[0]=='X')c[0][0][0]=1;\n  else{\n    a[0][1][1][0]=1;\n    a[0][1][0][0]=1;\n    c[0][0][1]=1;\n    c[0][1][1]=MOD-1;\n    c[0][1][0]=MOD-1;\n  }\n  rep(i,n-1){\n    if(s[i+1]=='X'){      \n      c[i+1][0][0]+=c[i][1][0]*(MOD-1);\n      c[i+1][0][0]%=MOD;\n      a[i+1][0][0][0]+=c[i][1][0];\n      a[i+1][0][0][0]%=MOD;\n      \n      b[i+1][0][0][0]-=c[i][0][1];\n      b[i+1][0][0][0]%=MOD;\n      c[i+1][0][0]+=c[i][0][1];\n      c[i+1][0][0]%=MOD;\n      \n      b[i+1][0][0][0]-=c[i][1][1];\n      b[i+1][0][0][0]%=MOD;\n      c[i+1][0][0]+=c[i][1][1];\n      c[i+1][0][0]%=MOD;\n\n      rep(j,1050){\n        a[i+1][0][0][j+1]+=a[i][1][0][j]*modinv(j+1);\n        a[i+1][0][0][j+1]%=MOD;\n        b[i+1][0][0][j+1]+=b[i][1][0][j]*modinv(j+1);\n        b[i+1][0][0][j+1]%=MOD;        \n        \n        a[i+1][0][0][0]+=a[i][0][1][j]*modinv(j+1);\n        a[i+1][0][0][0]%=MOD;\n        a[i+1][0][0][j+1]-=a[i][0][1][j]*modinv(j+1);\n        a[i+1][0][0][j+1]%=MOD;\n        b[i+1][0][0][0]+=b[i][0][1][j]*modinv(j+1);\n        b[i+1][0][0][0]%=MOD;\n        b[i+1][0][0][j+1]-=b[i][0][1][j]*modinv(j+1);\n        b[i+1][0][0][j+1]%=MOD;\n        \n        a[i+1][0][0][0]+=a[i][1][1][j]*modinv(j+1);\n        a[i+1][0][0][0]%=MOD;\n        a[i+1][0][0][j+1]-=a[i][1][1][j]*modinv(j+1);\n        a[i+1][0][0][j+1]%=MOD;\n        b[i+1][0][0][0]+=b[i][1][1][j]*modinv(j+1);\n        b[i+1][0][0][0]%=MOD;\n        b[i+1][0][0][j+1]-=b[i][1][1][j]*modinv(j+1);\n        b[i+1][0][0][j+1]%=MOD;\n      }\n    }\n    else{\n      c[i+1][1][1]+=c[i][0][0]*(MOD-1);\n      c[i+1][1][1]%=MOD;\n      a[i+1][1][1][0]+=c[i][0][0];\n      a[i+1][1][1][0]%=MOD;\n      \n      c[i+1][1][0]+=c[i][0][0]*(MOD-1);\n      c[i+1][1][0]%=MOD;\n      a[i+1][1][0][0]+=c[i][0][0];\n      a[i+1][1][0][0]%=MOD;\n      \n      b[i+1][0][1][0]-=c[i][0][0];\n      b[i+1][0][1][0]%=MOD;\n      c[i+1][0][1]+=c[i][0][0];\n      c[i+1][0][1]%MOD;\n      \n      b[i+1][0][1][0]-=c[i][1][0];\n      b[i+1][0][1][0]%=MOD;\n      a[i+1][0][1][0]+=c[i][1][0];\n      a[i+1][0][1][0]%=MOD;\n      \n      rep(j,1050){\n        a[i+1][1][1][j+1]+=a[i][0][0][j]*modinv(j+1);\n        a[i+1][1][1][j+1]%=MOD;\n        b[i+1][1][1][j+1]+=b[i][0][0][j]*modinv(j+1);\n        b[i+1][1][1][j+1]%=MOD;\n        \n        a[i+1][1][0][j+1]+=a[i][0][0][j]*modinv(j+1);\n        a[i+1][1][0][j+1]%=MOD;\n        b[i+1][1][0][j+1]+=b[i][0][0][j]*modinv(j+1);\n        b[i+1][1][0][j+1]%=MOD;  \n      \n        a[i+1][0][1][0]+=a[i][0][0][j]*modinv(j+1);\n        a[i+1][0][1][0]%=MOD;\n        a[i+1][0][1][j+1]-=a[i][0][0][j]*modinv(j+1);\n        a[i+1][0][1][j+1]%=MOD;\n        b[i+1][0][1][0]+=b[i][0][0][j]*modinv(j+1);\n        b[i+1][0][1][0]%=MOD;\n        b[i+1][0][1][j+1]-=b[i][0][0][j]*modinv(j+1);\n        b[i+1][0][1][j+1]%=MOD;\n        \n        a[i+1][0][1][0]+=a[i][1][0][j]*modinv(j+1);\n        a[i+1][0][1][0]%=MOD;\n        b[i+1][0][1][0]+=b[i][1][0][j]*modinv(j+1);\n        b[i+1][0][1][0]%=MOD;\n      }\n    }\n  }\n  p[0]=1;\n  q[0]=1;\n  rep(i,1050)p[i+1]=(p[i]*(i+1))%MOD;\n  rep(i,1050)q[i+1]=(q[i]*(i+1)+1)%MOD;\n  rep(i,2){\n    rep(j,2){\n      if(j==0){\n        x=(x+c[n-1][i][j]*modinv(2))%MOD;\n        z=(z-c[n-1][i][j]*modinv(2))%MOD;\n      }\n      else{\n        x=(x+c[n-1][i][j]*modinv(2))%MOD;\n        y=(y-c[n-1][i][j])%MOD;\n        z=(z+c[n-1][i][j]*modinv(2))%MOD;\n      }\n    }\n  }\n  rep(i,1050){\n    rep(j,2){\n      rep(k,2){\n        if(k==1){\n          x=(x+a[n-1][j][k][i]*(1-p[i]))%MOD;\n          y=(y+a[n-1][j][k][i]*q[i])%MOD;\n          y=(y+b[n-1][j][k][i]*(1-p[i]))%MOD;\n          z=(z+b[n-1][j][k][i]*q[i])%MOD;\n        }\n        else{\n          x=(x+a[n-1][j][k][i]*p[i])%MOD;\n          y=(y-a[n-1][j][k][i]*q[i])%MOD;\n          y=(y+b[n-1][j][k][i]*p[i])%MOD;\n          z=(z-b[n-1][j][k][i]*q[i])%MOD;\n        }\n      }\n    }\n  }\n  x=mod(x,MOD);\n  y=mod(y,MOD);\n  z=mod(z,MOD);\n  printf(\"%lld %lld %lld\",x,y,z);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr modulo_int power (unsigned long long pow) const {\n    modulo_int result(1), mult(*this);\n    while (pow > 0) {\n      if (pow & 1) result *= mult;\n      mult *= mult;\n      pow >>= 1;\n    }\n    return result;\n  }\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n};\n\ntemplate <class T>\nclass polynomial {\npublic:\n  using value_type = T;\n\n// private:\n  std::vector<value_type> data;\n\npublic:\n  polynomial(): data(1, 0) { }\n  polynomial(int size_): data(size_, 0) { }\n\n  void operator += (const polynomial &rhs) {\n    if (degree() < rhs.degree()) {\n      data.resize(rhs.degree());\n    }\n    for (int i: range(0, std::min(degree(), rhs.degree()))) {\n      data[i] += rhs[i];\n    }\n  }\n  void operator -= (const polynomial &rhs) {\n    if (degree() < rhs.degree()) {\n      data.resize(rhs.degree());\n    }\n    for (int i: range(0, std::min(degree(), rhs.degree()))) {\n      data[i] -= rhs[i];\n    }\n  }\n\n  polynomial integrate() const {\n    polynomial res(degree() + 1);\n    for (int i: range(0, degree())) {\n      res[i + 1] = data[i] / (i + 1);\n    }\n    return res;\n  }\n  std::pair<value_type, value_type> calculate() const {\n    value_type r1, r2;\n    value_type t1(1), t2(-1);\n    for (int i: range(0, degree())) {\n      r1 += data[i] * t1;\n      r2 += data[i] * t2;\n      t1 *= (i + 1);\n      t2 *= (i + 1);\n      t2 -= 1;\n    }\n    return { r1, r2 };\n  }\n\n  value_type &operator [] (int i) const {\n    return (value_type&) this -> data[i];\n  }\n  value_type operator () (const value_type &val) const {\n    value_type res, cur(1);\n    for (auto coeff: data) {\n      res += cur * coeff;\n      cur *= val;\n    }\n    return res;\n  }\n  int degree() const {\n    return data.size();\n  }\n\n};\n\nusing modint = modulo_int<std::integral_constant<int, 1000000007>>;\nusing poly = polynomial<modint>;\n\nstruct state {\n  poly first, second;\n  modint third;\n  state(): first(poly()), second(poly()), third(modint()) { }\n  state(const poly &first_, const poly &second_, const modint &third_): \n    first(first_), second(second_), third(third_)\n  { }\n  state integrate(bool val) const {\n    auto P = first.integrate();\n    auto Q = second.integrate();\n    if (val) {\n      P[0] -= P(1);\n      Q[0] -= Q(1);\n      Q[0] += third;\n    }\n    else {\n      P[0] -= P(0);\n      Q[0] -= Q(0);\n      P[0] += third;\n    }\n    return state(P, Q, -third);\n  }\n  void set(const modint &a, const modint &b, const modint &c) {\n    first[0] = a;\n    second[0] = b;\n    third = c;\n  }\n  void operator += (const state &rhs) {\n    first += rhs.first;\n    second += rhs.second;\n    third += rhs.third;\n  }\n  void operator -= (const state &rhs) {\n    first -= rhs.first;\n    second -= rhs.second;\n    third -= rhs.third;\n  }\n};\n\ntemplate <class T, int N, int I = 0>\nauto gen_vec(const int (&list)[N], typename std::enable_if<(I == N), const T&>::type value = T()) {\n  return value;\n}\n\ntemplate <class T, int N, int I = 0>\nauto gen_vec(const int (&list)[N], typename std::enable_if<(I != N), const T&>::type value = T()) {\n  return std::vector<decltype(gen_vec<T, N, I + 1>(list, value))>(list[I], gen_vec<T, N, I + 1>(list, value));\n}\n\nint main() {\n  int N;\n  std::string S;\n  std::cin >> N >> S;\n  if (S.front() == 'X') {\n    S = \"-\" + S;\n    ++N;\n  }\n  auto dp = gen_vec<state>({ N, 2, 2 });\n  dp[0][0][1].set(0, 0, 1);\n  dp[0][1][0].set(1, 0, -1);\n  dp[0][1][1].set(1, 0, -1);\n  for (int i: range(1, N)) {\n    if (S[i] == 'X') {\n      dp[i][0][0] += dp[i - 1][1][0].integrate(0);\n      dp[i][0][0] -= dp[i - 1][0][1].integrate(1);\n      dp[i][0][0] -= dp[i - 1][1][1].integrate(1);\n    }\n    else {\n      dp[i][0][1] += dp[i - 1][1][0].integrate(0);\n      dp[i][1][0] += dp[i - 1][0][0].integrate(0);\n      dp[i][1][1] += dp[i - 1][0][0].integrate(0);\n      dp[i][0][1] -= dp[i - 1][0][0].integrate(1);\n      dp[i][0][1] -= dp[i - 1][1][0].integrate(1);\n    }\n  }\n  modint A, B, C;\n  for (int i: range(0, 2)) {\n    auto p = dp[N - 1][i][0].first;\n    auto q = dp[N - 1][i][0].second;\n    auto r = dp[N - 1][i][0].third;\n    auto t1 = p.calculate();\n    auto t2 = q.calculate();\n    A += t1.first;\n    B += t1.second;\n    B += t2.first;\n    C += t2.second;\n    A += r / 2;\n    C -= r / 2;\n  }\n  for (int i: range(0, 2)) {\n    auto p = dp[N - 1][i][1].first;\n    auto q = dp[N - 1][i][1].second;\n    auto r = dp[N - 1][i][1].third;\n    auto t1 = p.calculate();\n    auto t2 = q.calculate();\n    A -= t1.first;\n    B -= t1.second;\n    B -= t2.first;\n    C -= t2.second;\n    A -= r / 2;\n    C += r / 2;\n    A += p.integrate()(1);\n    B += q.integrate()(1);\n    A += r;\n    B -= r;\n  }\n  std::cout << A << ' ' << B << ' ' << C << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long N;\n    cin >> N;\n    if(N == 1){\n        char c;\n        cin >> c;\n        cout << \"500000004 0 \" << (c == 'X' ? 500000003 : 500000004) << endl;\n        return 0;\n    }\n    string s;\n    cin >> s;\n    if(s.find(\"---\") != string::npos || s.find(\"XX\") != string::npos){\n        puts(\"0 0 0\");\n        return 0;\n    }\n    assert(-1);\n    vector<long> tapi;\n    if(s[0] == s[1] && s[0] == '-')tapi.push_back(1);\n    long now = s[0] == 'X' ? 1 : s[1] == 'X' ? 2 : 3, cnt(-1);\n    bool f(0);\n    for(; now < s.size(); ++now){\n        if(s[now] == '-')++cnt;\n        else{\n            if(cnt == 1)f = true;\n            tapi.push_back(cnt);\n            cnt = -1;\n        }\n    }\n    cout << (!f ? 500000004 : 0) << \" 0\";\n    if(cnt == 1)tapi.push_back(1);\n\n    puts(\"\\nsorry...\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong inv(int a, int m) {\n\tlong i = 1, j = 0;\n\tfor (int b = m; a > 1; swap(i, j), swap(a, b)) {\n\t\tj = (j + b / a * (m - i)) % m;\n\t\tb %= a;\n\t}\n\treturn i;\n}\nint m = 1e9 + 7, f[1111] = { 1 };\nlong P[2][1111], c[2], q[3], r = 1;\nint main() {\n\tint n, d = 1;\n\tstring s;\n\tcin >> n >> s;\n\tif (s[0] != 'X')\n\t\tP[0][0] = c[0] = 1, r = m - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tf[i] = f[i - 1] * inv(i, m) % m;\n\t\tP[0][d] = r;\n\t\tP[1][d++] = 0;\n\t\tr = (m - r) % m;\n\t\tif (s[i] != 'X') {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tc[j] = (P[j][d - 1] + r * j) % m;\n\t\t\t\tfor (int k = 1; k < d; k++)\n\t\t\t\t\t(c[j] += P[j][d - 1 - k] * f[k]) %= m;\n\t\t\t}\n\t\t\tif (s[i - 1] != 'X')\n\t\t\t\td = 1, P[0][0] = P[1][0] = r = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t(P[j][d - 1] += c[j]) %= m;\n\t\t\t(P[j][d - 2] += m - c[j]) %= m;\n\t\t}\n\t\tif (s[i - 1] == 'X') {\n\t\t\tcout << \"0 0 0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tq[0] = r * inv(2, m) % m;\n\tq[2] = (m - q[0]) % m;\n\tfor (int i = 0; i < d; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t(q[j] += P[j][d - 1 - i]) %= m;\n\t\t\t(q[j + 1] += P[j][d - 1 - i] * (m - f[i])) %= m;\n\t\t}\n\t\t(f[i + 1] += f[i]) %= m;\n\t}\n\tif (s[n - 1] != 'X')\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\t(q[j + 1] += c[j]) %= m;\n\tcout << q[0] << ' ' << q[1] << ' ' << q[2] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 27.01.2020 04:52:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  for (int i = 0; i < n - 1; i++) {\n    if (s[i] == 'X' && s[i + 1] == 'X') {\n      cout << \"0 0 0\" << '\\n';\n      return 0;\n    }\n  }\n  if (s[0] == 'X') {\n    s = \"-\" + s;\n  }\n  if (s.back() == 'X') {\n    s = s + \"-\";\n  }\n  vector<int> a;\n  int start = 0;\n  for (int i = 0; i < (int) s.size(); i++) {\n    if (i == (int) s.size() - 1 || (s[i] == '-' && s[i + 1] == '-')) {\n      a.push_back((i - start + 1) / 2);\n      start = i + 1;\n    }\n  }\n  int sz = (int) a.size();\n  for (int i = 1; i < sz - 1; i++) {\n    if (a[i] == 0) {\n      cout << \"0 0 0\" << '\\n';\n      return 0;\n    }\n  }\n  const int M = n + 3;\n  vector<Mint> f(M);\n  f[0] = 1;\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      f[i] += f[j] * f[i - 1 - j] / Mint(2 * i - 1);\n    }\n  }\n  vector<Mint> g(M);\n  g[0] = 1;\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      g[i] += g[j] * f[i - 1 - j] / Mint(2 * i);\n    }\n  }\n  vector<Mint> h(M);\n  for (int i = 1; i < M; i++) {\n    for (int j = 0; j < i; j++) {\n      h[i] += g[j] * g[i - 1 - j] / Mint(2 * i + 1);\n    }\n  }\n  vector<Mint> c(M);\n  for (int i = 0; i < M; i++) {\n    c[i] = 1;\n    for (int j = 1; j < i; j++) {\n      c[i] -= h[j];\n    }\n  }\n  if (sz == 1) {\n    int len = (int) s.size() - 1;\n    Mint ans = 0;\n    for (int i = 0; i < len - 1; i++) {\n      ans -= c[(i + 1) >> 1] / 2;\n    }\n    cout << Mint(1) / 2 << \" 0 \" << ans << '\\n';\n    return 0;\n  }\n  Mint ans = c[a[0]] * c[a[sz - 1]];\n  for (int i = 1; i < sz - 1; i++) {\n    ans *= h[a[i]];\n  }\n  cout << \"0 0 \" << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.01.2020 22:39:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] = -c[i];\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  vector<T> c(a.size() + b.size() - 1, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    for (int j = 0; j < (int) b.size(); j++) {\n      c[i + j] += a[i] * b[j];\n    }\n  }\n  return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<T> x = b * b * a_cut;\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T>{1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n  vector<T> c = a;\n  for (int i = 0; i < (int) c.size(); i++) {\n    c[i] *= i;   \t\n  }\n  if (!c.empty()) {\n    c.erase(c.begin());\n  }\n  return c;\n}\n \ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n  vector<T> c = a;\n  c.insert(c.begin(), 0);\n  for (int i = 1; i < (int) c.size(); i++) {\n    c[i] /= i;\n  }\n  while (!c.empty() && c.back() == 0) {\n    c.pop_back();\n  }\n  return c;\n}\n\ntemplate <typename T>\nT evaluate(const vector<T>& a, const T& x) {\n  T res = 0;\n  for (int i = (int) a.size() - 1; i >= 0; i--) {\n    res = res * x + a[i];\n  }\n  return res;\n}\n\nstruct State {\n  vector<Mint> p;\n  vector<Mint> q;\n  Mint c;\n};\n     \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<vector<State>> dp(2, vector<State>(3));\n  dp[0][2].c = 1;\n  dp[1][2].p = {1};\n  dp[1][2].c = -1;\n  for (int i = 0; i < n; i++) {\n    vector<vector<State>> new_dp(2, vector<State>(3));\n    for (int parity = 0; parity < 2; parity++) {\n      for (int want = 0; want < 3; want++) {\n        State& ft = dp[parity][want];\n        for (int rot = 0; rot < 2; rot++) {\n          if (rot == 0) { // a[i - 1] < a[i]\n            if (want == 1) {\n              continue;\n            }\n            int new_parity = parity ^ 1;\n            int new_want = 2;\n            if (s[i] == 'X') {\n              if (new_parity == 1) {\n                continue;\n              }\n              new_want = 0;\n            } else {\n              if (new_parity == 0) {\n                new_want = 1;\n              }\n            }\n            State& to = new_dp[new_parity][new_want];\n            to.p += primitive(ft.p) + vector<Mint> {ft.c};\n            to.q += primitive(ft.q);\n            to.c += -ft.c;\n          } else { // a[i - 1] > a[i]\n            int new_parity = 0;\n            int new_want = (s[i] == 'X' ? 0 : 1);\n            if (want == new_want) {\n              continue;\n            }\n            State& to = new_dp[new_parity][new_want];\n            to.p += -primitive(ft.p) + vector<Mint> {evaluate(primitive(ft.p), Mint(1))};\n            to.q += -primitive(ft.q) + vector<Mint> {evaluate(primitive(ft.q), Mint(1)) - ft.c};\n            to.c += ft.c;\n          }\n        }\n      }\n    }\n    swap(dp, new_dp);\n  }\n  vector<Mint> ans(3);\n  for (int parity = 0; parity < 2; parity++) {\n    for (int want = 0; want < 3; want++) {\n      State& ft = dp[parity][want];\n      debug(parity, want, ft.p, ft.q, ft.c);\n      vector<Mint> cur(3);\n      cur[0] += ft.c / 2;\n      cur[2] -= ft.c / 2;\n      for (int shift = 0; shift < 2; shift++) {\n        vector<Mint>& r = (shift == 0 ? ft.p : ft.q);\n        Mint c0 = 1;\n        Mint c1 = 1;\n        for (int i = 0; i < (int) r.size(); i++) {\n          cur[shift + 0] += c0 * r[i];\n          cur[shift + 1] -= c1 * r[i];\n          c0 = c0 * (i + 1);\n          c1 = c1 * (i + 1) + 1;\n        }\n      }\n      debug(cur);\n      for (int i = 0; i < 3; i++) {\n        ans[i] += cur[i] * (want == 0 ? 1 : (want == 1 ? -1 : 0));\n      }\n      debug(ans);\n      if (want >= 1) {\n        vector<Mint> P = primitive(ft.p);\n        ans[0] += evaluate(P, Mint(1)) - evaluate(P, Mint(0));\n        vector<Mint> Q = primitive(ft.q);\n        ans[1] += evaluate(Q, Mint(1)) - evaluate(Q, Mint(0));\n        ans[0] += ft.c;\n        ans[1] -= ft.c;\n      }\n      debug(ans);\n    }\n  }\n  cout << ans[0] << \" \" << ans[1] << \" \" << ans[2] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define pb push_back\n#define fr(i,n) for(int i=0;i<n;i++)\n#define Fr(i,n) for(int i=0;i++<n;)\n#define ifr(i,n) for(int i=n-1;i>=0;i--)\n#define iFr(i,n) for(int i=n;i>0;i--)\n\nstruct modint{\n    using i64=int_fast64_t;\n    i64 a;\n    static constexpr i64 MOD=1e9+7;\n    constexpr modint():a(){}\n    constexpr modint(i64 a_):a(a_%MOD){\n        if(a<0) a+=MOD;\n    }\n    constexpr modint inv()const noexcept{\n        i64 n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y;\n        y.a=n;\n        return y;\n    }\n    constexpr bool operator==(const modint& x)const noexcept{\n        return a==x.a;\n    }\n    constexpr bool operator!=(const modint& x)const noexcept{\n        return a!=x.a;\n    }\n    constexpr modint operator+(const modint& x)const noexcept{\n        modint y;\n        y.a=a+x.a;\n        if(y.a>=MOD) y.a-=MOD;\n        return y;\n    }\n    constexpr modint operator-(const modint& x)const noexcept{\n        modint y;\n        y.a=a-x.a;\n        if(y.a<0) y.a+=MOD;\n        return y;\n    }\n    constexpr modint operator*(const modint& x)const noexcept{\n        modint y;\n        y.a=(a*x.a)%MOD;\n        return y;\n    }\n    constexpr modint operator/(const modint& x)const noexcept{\n        modint y;\n        y.a=(a*x.inv().a)%MOD;\n        return y;\n    }\n    constexpr modint& operator+=(const modint& x)noexcept{\n        a+=x.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    constexpr modint& operator-=(const modint& x)noexcept{\n        a-=x.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint& x)noexcept{\n        (a*=x.a)%=MOD;\n        return *this;\n    }\n    constexpr modint& operator/=(const modint& x)noexcept{\n        (a*=x.inv().a)%=MOD;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x)noexcept{\n    static int_fast64_t a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x)noexcept{\n    out<<x.a;\n    return out;\n}\nconstexpr modint pwr(int_fast64_t a,int_fast64_t b)noexcept{\n    modint _;\n    int_fast64_t n=1,A=a;\n    while(b){\n        if(b&1) (n*=A)%=modint::MOD;\n        (A*=A)%=modint::MOD;\n        b>>=1;\n    }\n    _.a=n;\n    return _;\n}\n\ntemplate <int n> struct COMB{\n    int_fast64_t fc[n],ifc[n],Bn[n];\n    constexpr COMB():fc(),ifc(),Bn(){\n        fc[0]=1;\n        for(int i=1;i<n;++i){\n            fc[i]=fc[i-1]*i%modint::MOD;\n            Bn[i]=(Bn[i-1]*i+1)%modint::MOD;\n        }\n        int_fast64_t N=1,A=fc[n-1],b=modint::MOD-2;\n        while(b){\n            if(b&1) (N*=A)%=modint::MOD;\n            (A*=A)%=modint::MOD;\n            b>>=1;\n        }\n        ifc[n-1]=N;\n        for(int i=n-1;i>=1;--i) ifc[i-1]=ifc[i]*i%modint::MOD;\n    };\n    modint operator()(int N,int R)const{\n        if(N<0||R<0||N<R) return 0;\n        return fc[N]*ifc[R]%modint::MOD*ifc[N-R];\n    }\n    modint operator[](int N)const{\n        modint _;\n        _.a=fc[N];\n        return _;\n    }\n    modint operator()(int N)const{\n        modint _;\n        _.a=ifc[N];\n        return _;\n    }\n};\nconstexpr COMB<1010> comb;\n\nmodint dp[1010][2][1010]={},dpc[1010]={},kari{};\nint main(){\n    ll n,num=1;\n    bool f[1010];\n    string s;\n    cin>>n>>s;\n    if(n==1&&s==\"-\"){\n        cout<<(modint::MOD+1)/2<<\" \"<<0<<\" \"<<(modint::MOD+1)/2<<endl;\n        return 0;\n    }\n    int q=0,r=n;\n    n=-1;\n    if(s[q]=='-') q++;\n    if(s[q]=='-'){q++;n++;num++;}\n    if(s[q]=='-'){cout<<\"0 0 0\"<<endl;return 0;}\n    for(int i=q;i<r;i++){\n        if(s[i]=='X'){\n            if(num==0){cout<<\"0 0 0\"<<endl;return 0;}\n            if(n>=0) f[n]=num-1;\n            n++;num=0;\n        }\n        else{\n            if(num>1){cout<<\"0 0 0\"<<endl;return 0;}\n            num++;\n        }\n    }\n    if(num==2) f[n++]=1;\n    dpc[0]=1;\n    fr(i,n){\n        if(f[i]){\n            fr(j,2){\n                fr(k,2*n+2){\n                    kari=modint(k*k+3*k+2).inv();\n                    dp[i+1][j][0]+=dp[i][j][k]*kari;\n                    dp[i+1][j][1]+=dp[i][j][k]*(modint(0)-kari);\n                }\n            }\n            dp[i+1][1][0]+=dpc[i];\n            dp[i+1][1][1]-=dpc[i];\n        }\n        else{\n            fr(j,2){\n                fr(k,2*n+2){\n                    kari=modint(k+1).inv();\n                    dp[i+1][j][0]+=dp[i][j][k]*kari;\n                    dp[i+1][j][1]-=dp[i][j][k]*kari;\n                    dp[i+1][j][k+2]+=dp[i][j][k]/(k*k+3*k+2);\n                }\n            }\n            dp[i+1][1][1]+=dpc[i];\n            dp[i+1][1][0]-=dpc[i];\n            dpc[i+1]+=dpc[i];\n        }\n    }\n    modint ans[3]={};\n    fr(j,2){\n        fr(k,2*n+2){\n            ans[j]+=dp[n][j][k]*comb[k];\n            ans[j+1]-=dp[n][j][k]*(comb[k]+comb.Bn[k]);\n        }\n    }\n    kari=modint(2).inv();\n    ans[0]+=dpc[n]*kari;\n    ans[2]-=dpc[n]*kari;\n    cout<<ans[0]<<\" \"<<ans[1]<<\" \"<<ans[2]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0,i##_len=(n);i<i##_len;++i)\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define All(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\nconstexpr ll mod=1e9+7;\nclass mint {\n private:\n  ll _num,_mod;\n  mint set(ll num){ \n      _num = num ;\n      if(_num>=0) _num%=_mod;\n      else _num+=(1-(_num+1)/_mod)*_mod; \n      return *this;\n  }\n  ll _mpow(ll x, ll n){ //x^n(mod) ←普通にpow(x,n)では溢れてしまうため，随時mod計算 2分累乗法だから早い\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % _mod;\n        x = x*x % _mod;\n        n = n >> 1;\n    }\n    return ans;\n  }\n  ll imod(ll n){return _mpow(n , _mod-2);}\n public:\n  mint(){ _num = 0;_mod=mod; }\n  mint(ll num){ _mod = mod; _num = (num+(1LL<<25)*mod) % mod; }\n  mint(ll num,ll M){ _mod=M;_num=(num+(1LL<<25)*mod)%_mod; }\n  mint(const mint &cp){_num=cp._num;_mod=cp._mod;}\n  mint operator= (const ll x){ return set(x); }\n  mint operator+ (const ll x){ return mint(_num + (x % _mod) , _mod); }\n  mint operator- (const ll x){ return mint(_num - (x % _mod), _mod); }\n  mint operator* (const ll x){ return mint(_num * (x % _mod) , _mod); }\n  mint operator/ (ll x){ return mint(_num * imod(x) , _mod);}\n  mint operator+=(const ll x){ return set(_num + (x % _mod)); }\n  mint operator-=(const ll x){ return set(_num - (x % _mod)); }\n  mint operator*=(const ll x){ return set(_num * (x % _mod)); }\n  mint operator/=(ll x){ return set(_num * imod(x));}\n  mint operator+ (const mint &x){ return mint(_num + x._num , _mod); }\n  mint operator- (const mint &x){ return mint(_num - x._num , _mod);}\n  mint operator* (const mint &x){ return mint(_num * x._num , _mod); }\n  mint operator/ (mint x){ return mint(_num * imod(x._num) , _mod);}\n  mint operator+=(const mint &x){ return set(_num + x._num); }\n  mint operator-=(const mint &x){ return set(_num - x._num); }\n  mint operator*=(const mint &x){ return set(_num * x._num); }\n  mint operator/=(mint x){ return set(_num * imod(x._num));}\n\n  bool operator<(const mint &x)const{return _num<x._num;}\n  bool operator==(const mint &x)const{return _num==x._num;}\n  bool operator>(const mint &x)const{return _num>x._num;}\n\n  friend mint operator+(ll x,const mint &m){return mint(m._num + (x % m._mod) , m._mod);}\n  friend mint operator-(ll x,const mint &m){return mint( (x % m._mod) - m._num , m._mod);}\n  friend mint operator*(ll x,const mint &m){return mint(m._num * (x % m._mod) , m._mod);}\n  friend mint operator/(ll x,mint m){return mint(m.imod(m._num) * x , m._mod);}\n\n  explicit operator ll() { return _num; }\n  explicit operator int() { return (int)_num; }\n\n  friend ostream& operator<<(ostream &os, const mint &x){ os << x._num; return os; }\n  friend istream& operator>>(istream &is, mint &x){ll val; is>>val; x.set(val); return is;}\n};\n\ntypedef tuple<vector<mint>,vector<mint>,mint> T;\nT sekibun(T &v,int state){\n    vector<mint> p,q;\n    mint c;\n    tie(p,q,c)=v;\n    if(state==0){\n        p.push_back(0);\n        q.push_back(0);\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=p[i-1]/mint(i);\n        }\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=q[i-1]/mint(i);\n        }\n        p[0]=c;\n        q[0]=0;\n        c=mod-c;\n    }\n    else if(state==1){\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        for(int i=p.size()-1;i>0;--i){\n            p[i]=mod-p[i-1]/mint(i);\n            r+=p[i-1]/mint(i);\n        }\n        p[0]=r;\n        r=0;\n        for(int i=q.size()-1;i>0;--i){\n            q[i]=mod-q[i-1]/mint(i);\n            r+=q[i-1]/mint(i);\n        }\n        q[0]=r-c;\n    }\n    else{\n        p.push_back(0);\n        q.push_back(0);\n        mint r=0;\n        REP(i,p.size()){\n            r+=p[i]/mint(i+1);\n            p[i]=0;\n        }\n        p[0]=r+c;\n        r=0;\n        REP(i,q.size()){\n            r+=q[i]/mint(i+1);\n            q[i]=0;\n        }\n        q[0]=r-c;\n        c=0;\n    }\n    return tie(p,q,c);\n}\nT operator+(T a,T b){\n    vector<mint> p(max(get<0>(a).size(),get<0>(b).size()))\n                ,q(max(get<1>(a).size(),get<1>(b).size()));\n    mint c=0;\n    REP(i,get<0>(a).size()) p[i]+=get<0>(a)[i];\n    REP(i,get<0>(b).size()) p[i]+=get<0>(b)[i];\n    REP(i,get<1>(a).size()) q[i]+=get<1>(a)[i];\n    REP(i,get<1>(b).size()) q[i]+=get<1>(b)[i];\n    c=get<2>(a)+get<2>(b);\n    return tie(p,q,c);\n}\n\nmint pre[1010][2];\nvoid calc(){\n    pre[0][0]=pre[0][1]=1;\n    rep(i,0,1005){\n        pre[i+1][0]=pre[i][0]*mint(i+1);\n        pre[i+1][1]=pre[i][1]*mint(i+1)+1;\n        pre[i][1]*=-1;\n    }\n}\ntypedef tuple<mint,mint,mint> F;\n\nF int_e(T f){\n    F res; vector<mint> p=get<0>(f),q=get<1>(f);\n    rep(i,0,p.size())get<0>(res)+=p[i]*pre[i][0],get<1>(res)+=p[i]*pre[i][1];\n    rep(i,0,q.size())get<1>(res)+=q[i]*pre[i][0],get<2>(res)+=q[i]*pre[i][1];\n    get<0>(res)+=get<2>(f)/2; get<2>(res)-=get<2>(f)/2; return res;\n}\nvoid t_add(F &a,F b){get<0>(a)+=get<0>(b),get<1>(a)+=get<1>(b),get<2>(a)+=get<2>(b);}\nvoid t_dec(F &a,F b){get<0>(a)-=get<0>(b),get<1>(a)-=get<1>(b),get<2>(a)-=get<2>(b);}\nint main(){\n    int N;cin>>N;\n    string S;cin>>S;calc();\n    typedef vector<T> vt;\n    typedef vector<vt> vvt;\n    typedef vector<vvt> vvvt;\n    vector<vvvt> dp(N+1,vvvt(2,vvt(2,vt(2))));\n    dp[0][0][1][1]=T({0},{0},1);\n    dp[0][1][1][1]=T({1},{0},-1);\n    rep(i,1,N+1){\n        if(S[i-1]=='X'){\n            dp[i][0][1][0]=sekibun(dp[i-1][0][0][1],1)+sekibun(dp[i-1][1][0][1],1)\n                          +sekibun(dp[i-1][0][1][1],1)+sekibun(dp[i-1][1][1][1],1)\n                          +sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n        }\n        else{\n            dp[i][0][0][1]=sekibun(dp[i-1][1][1][0],0)+sekibun(dp[i-1][1][1][1],0);\n            REP(j,2) REP(k,2) dp[i][0][0][1]=dp[i][0][0][1]+sekibun(dp[i-1][j][1][k],1);\n            dp[i][1][1][1]=sekibun(dp[i-1][0][1][0],0)+sekibun(dp[i-1][0][1][1],0);\n        }\n    }\n    F ans;\n    REP(i,2){\n        t_add(ans,int_e(dp[N][i][1][0]));\n        T S=sekibun(dp[N][i][0][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n        t_dec(ans,int_e(dp[N][i][0][1]));\n        S=sekibun(dp[N][i][1][1],2);\n        t_add(ans,F(get<0>(S)[0],get<1>(S)[0],get<2>(S)));\n    }\n    mint p,q,r;\n    tie(p,q,r)=ans;\n    cout<<p<<\" \"<<q<<\" \"<<r<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int P = 1e9 + 7;\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)\n    a += P;\n}\n\nint mul(int a,int b){\n  return a * b % P;\n}\nstruct war{\n  int a,b,c;\n  void operator +=(war x){\n    add(a, x.a);\n    add(b, x.b);\n    add(c, x.c);\n  }\n  void operator -=(war x){\n    sub(a, x.a);\n    sub(b, x.b);\n    sub(c, x.c);\n  }\n  \n  void operator *=(war x){\n    c = mul(c, x.a);\n    add(c,mul(a, x.c));\n    add(c,mul(b, x.b));\n    \n    \n    b = mul(b, x.a);\n    add(b,mul(a, x.b));\n    \n    a = mul(a, x.a);\n  }\n};\n\nconst int MAX = 1001;\nint dp[MAX][3];\n\nwar licz1(int x){\n  war res = {0,1,0};\n  R(i,x - 1){\n    res -= {0,dp[i + 1][2],0};\n  }\n  debug(x, res.b * 3 % P);\n  return res;\n}\n\nwar licz2(int x){\n  debug(x);\n  if(x == 1){\n    return {(P + 1) / 2, 0, (P - 1) / 2};\n  }\n  war res = {1,0,0};\n  res -= licz2(x-1);\n  R(i,2 * x - 2){\n    war pom = licz1((i + 1) / 2);\n    pom *= {0,1,0};\n    res -= pom;\n  }\n  return res;\n}\n\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  \n  dp[0][1] = dp[0][0] = 1;\n  dp[0][2] = 0;\n  R(i,MAX)if(i)R(j,3){\n    R(k,i){\n      add(dp[i][j], mul(pot(2 * i - 1 + j, P - 2), mul(dp[k][j / 2], dp[i - k - 1][(j + 1) / 2])));\n    }\n  }\n  debug(dp[0][2]);\n  debug(dp[1][2] * 3 % P);\n  debug(dp[2][2] * 5 % P);\n  debug(dp[3][2] * 7 % P);\n  \n  int n;\n  string z;\n  cin >> n >> z;\n  R(i,n-1)if(z[i] == 'X' && z[i+1] == 'X'){\n    cout << \"0 0 0\\n\";\n    return 0;\n  }\n  int ile = 0;\n  war res = {1,0,0};\n  vector<int> x;\n  R(i,n){\n    if(z[i] == '-'){\n      if(i && z[i-1] == '-'){\n        x.PB(ile);\n        ile = 0;\n      }\n    }else{\n      ile ++;\n    }\n  }\n  debug(ile, x);\n  if(x.empty()){\n    res = licz2(ile);\n  }else{\n    res *= licz1(ile);\n    res *= licz1(x[0]);\n    R(i,SZ(x))if(i){\n      res *= {dp[x[i]][2],0,0};\n    }\n  }\n  cout << res.a << \" \" << res.b << \" \" << res.c << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nReference:\n競プロ初心者日記 #25「World Tour Finals2019 Eの解説を解説する」\nhttps://www.nicovideo.jp/watch/sm35888883\n\nｺﾄﾉﾊｼﾏｲｶｼｺｲﾔｯﾀｰ\n*/\n\n//#define _GLIBCXX_DEBUG\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//------------------------------- Libraries --------------------------------//\n\ntemplate <int p>\nstruct Modint\n{\n    int value;\n\n    Modint() : value(0) {}\n    Modint(long x) : value(x >= 0 ? x % p : (p + x % p) % p) {}\n\n    inline Modint &operator+=(const Modint &b)\n    {\n        if ((this->value += b.value) >= p)\n            this->value -= p;\n        return (*this);\n    }\n    inline Modint &operator-=(const Modint &b)\n    {\n        if ((this->value += p - b.value) >= p)\n            this->value -= p;\n        return (*this);\n    }\n    inline Modint &operator*=(const Modint &b)\n    {\n        this->value = (int)((1LL * this->value * b.value) % p);\n        return (*this);\n    }\n    inline Modint &operator/=(const Modint &b)\n    {\n        (*this) *= b.inverse();\n        return (*this);\n    }\n\n    Modint operator+(const Modint &b) const { return Modint(*this) += b; }\n    Modint operator-(const Modint &b) const { return Modint(*this) -= b; }\n    Modint operator*(const Modint &b) const { return Modint(*this) *= b; }\n    Modint operator/(const Modint &b) const { return Modint(*this) /= b; }\n\n    inline Modint &operator++(int) { return (*this) += 1; }\n    inline Modint &operator--(int) { return (*this) -= 1; }\n\n    inline bool operator==(const Modint &b) const\n    {\n        return this->value == b.value;\n    }\n    inline bool operator!=(const Modint &b) const\n    {\n        return this->value != b.value;\n    }\n    inline bool operator<(const Modint &b) const\n    {\n        return this->value < b.value;\n    }\n    inline bool operator<=(const Modint &b) const\n    {\n        return this->value <= b.value;\n    }\n    inline bool operator>(const Modint &b) const\n    {\n        return this->value > b.value;\n    }\n    inline bool operator>=(const Modint &b) const\n    {\n        return this->value >= b.value;\n    }\n\n    // requires that \"this->value and p are co-prime\"\n    // a_i * v + a_(i+1) * p = r_i\n    // r_i = r_(i+1) * q_(i+1) * r_(i+2)\n    // q == 1 (i > 1)\n    // reference: https://atcoder.jp/contests/agc026/submissions/2845729\n    // (line:93)\n    inline Modint inverse() const\n    {\n        assert(this->value != 0);\n        int r0 = p, r1 = this->value, a0 = 0, a1 = 1;\n        while (r1)\n        {\n            int q = r0 / r1;\n            r0 -= q * r1;\n            swap(r0, r1);\n            a0 -= q * a1;\n            swap(a0, a1);\n        }\n        return Modint(a0);\n    }\n\n    friend istream &operator>>(istream &is, Modint<p> &a)\n    {\n        long t;\n        is >> t;\n        a = Modint<p>(t);\n        return is;\n    }\n    friend ostream &operator<<(ostream &os, const Modint<p> &a)\n    {\n        return os << a.value;\n    }\n};\n\n/*\nverified @ https://atcoder.jp/contests/abc034/submissions/4316971\n*/\n\nconst int MOD = 1e9 + 7;\n\nusing Int = Modint<MOD>;\n\n//------------------------------- Type Names -------------------------------//\n\nusing i64 = int_fast64_t;\n\nusing seika = string;\n//akari : 1D, yukari : 2D, maki : 3D vector\ntemplate <class kizuna>\nusing akari = vector<kizuna>;\ntemplate <class yuzuki>\nusing yukari = akari<akari<yuzuki>>;\ntemplate <class tsurumaki>\nusing maki = akari<yukari<tsurumaki>>;\n//akane : ascending order, aoi : decending order\ntemplate <class kotonoha>\nusing akane = priority_queue<kotonoha, akari<kotonoha>, greater<kotonoha>>;\ntemplate <class kotonoha>\nusing aoi = priority_queue<kotonoha>;\n\n//------------------------------- Dubug Functions ---------------------------//\ninline void print()\n{\n    cout << endl;\n}\ntemplate <typename First, typename... Rest>\nvoid print(const First &first, const Rest &... rest)\n{\n    cout << first << ' ';\n    print(rest...);\n}\n//------------------------------- Solver ------------------------------------//\n\nvoid integrate(akari<Int> &P, akari<Int> &Q, Int &C, const akari<Int> &P1, const akari<Int> &Q1, const Int &C1, int m, bool up)\n{\n    if (up)\n    {\n        for (int i = 0; i <= m; i++)\n        {\n            P[0] += P1[i] / Int(i + 1);\n            P[i + 1] += P1[i] / Int(-(i + 1));\n        }\n        for (int i = 0; i <= m; i++)\n        {\n            Q[0] += Q1[i] / Int(i + 1);\n            Q[i + 1] += Q1[i] / Int(-(i + 1));\n        }\n        Q[0] -= C1;\n        C += C1;\n    }\n    else\n    {\n        for (int i = 0; i <= m; i++)\n        {\n            P[i + 1] += P1[i] / Int(i + 1);\n        }\n        for (int i = 0; i <= m; i++)\n        {\n            Q[i + 1] += Q1[i] / Int(i + 1);\n        }\n        P[0] += C1;\n        C -= C1;\n    }\n}\n\nvoid solve()\n{\n    int n;\n    seika s;\n    cin >> n >> s;\n\n    maki<akari<Int>> Ps(2, yukari<akari<Int>>(2, akari<akari<Int>>(2, akari<Int>(1)))), Qs(Ps);\n    maki<Int> C(2, yukari<Int>(2, akari<Int>(2)));\n\n    Ps[1][1][1][0] = 1;\n    C[0][1][1] = 1;\n    C[1][1][1] = -1;\n    for (int i = 0; i < n; i++)\n    {\n        maki<akari<Int>> nxPs(2, yukari<akari<Int>>(2, akari<akari<Int>>(2, akari<Int>(i + 2)))), nxQs(nxPs);\n        maki<Int> nxC(2, yukari<Int>(2, akari<Int>(2)));\n        if (s[i] == 'X')\n        {\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[0][0][1], Qs[0][0][1], C[0][0][1], i, true);\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[0][1][1], Qs[0][1][1], C[0][1][1], i, true);\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[1][0][1], Qs[1][0][1], C[1][0][1], i, true);\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[1][1][1], Qs[1][1][1], C[1][1][1], i, true);\n\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[1][1][0], Qs[1][1][0], C[1][1][0], i, false);\n            integrate(nxPs[0][1][0], nxQs[0][1][0], nxC[0][1][0], Ps[1][1][1], Qs[1][1][1], C[1][1][1], i, false);\n        }\n        else\n        {\n            integrate(nxPs[1][1][1], nxQs[1][1][1], nxC[1][1][1], Ps[0][1][0], Qs[0][1][0], C[0][1][0], i, false);\n            integrate(nxPs[1][1][1], nxQs[1][1][1], nxC[1][1][1], Ps[0][1][1], Qs[0][1][1], C[0][1][1], i, false);\n\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[0][1][0], Qs[0][1][0], C[0][1][0], i, true);\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[0][1][1], Qs[0][1][1], C[0][1][1], i, true);\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[1][1][0], Qs[1][1][0], C[1][1][0], i, true);\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[1][1][1], Qs[1][1][1], C[1][1][1], i, true);\n\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[1][1][0], Qs[1][1][0], C[1][1][0], i, false);\n            integrate(nxPs[0][0][1], nxQs[0][0][1], nxC[0][0][1], Ps[1][1][1], Qs[1][1][1], C[1][1][1], i, false);\n        }\n        swap(Ps, nxPs);\n        swap(Qs, nxQs);\n        swap(C, nxC);\n    }\n\n    akari<Int> ans(3);\n    //I_k = a_k + b_k / e\n    Int a = 1, b = Int(-1);\n    for (int i = 0; i <= n; i++)\n    {\n        //[1][1]\n        ans[0] += Ps[0][1][1][i] / Int(i + 1);\n        ans[0] += Ps[1][1][1][i] / Int(i + 1);\n        ans[1] += Qs[0][1][1][i] / Int(i + 1);\n        ans[1] += Qs[1][1][1][i] / Int(i + 1);\n        if (!i)\n        {\n            ans[0] += C[0][1][1] + C[1][1][1];\n            ans[1] -= C[0][1][1] + C[1][1][1];\n        }\n\n        //[0][1]\n        ans[0] += Ps[0][0][1][i] / Int(i + 1);\n        ans[0] += Ps[1][0][1][i] / Int(i + 1);\n        ans[1] += Qs[0][0][1][i] / Int(i + 1);\n        ans[1] += Qs[1][0][1][i] / Int(i + 1);\n        if (!i)\n        {\n            ans[0] += C[0][0][1] + C[1][0][1];\n            ans[1] -= C[0][0][1] + C[1][0][1];\n        }\n\n        ans[0] -= Ps[0][0][1][i] * a;\n        ans[0] -= Ps[1][0][1][i] * a;\n        ans[1] -= Qs[0][0][1][i] * a;\n        ans[1] -= Qs[1][0][1][i] * a;\n\n        ans[1] -= Ps[0][0][1][i] * b;\n        ans[1] -= Ps[1][0][1][i] * b;\n        ans[2] -= Qs[0][0][1][i] * b;\n        ans[2] -= Qs[1][0][1][i] * b;\n        if (!i)\n        {\n            ans[0] -= (C[0][0][1] + C[1][0][1]) / 2;\n            ans[2] += (C[0][0][1] + C[1][0][1]) / 2;\n        }\n\n        //[1][0]\n        ans[0] += Ps[0][1][0][i] * a;\n        ans[0] += Ps[1][1][0][i] * a;\n        ans[1] += Qs[0][1][0][i] * a;\n        ans[1] += Qs[1][1][0][i] * a;\n\n        ans[1] += Ps[0][1][0][i] * b;\n        ans[1] += Ps[1][1][0][i] * b;\n        ans[2] += Qs[0][1][0][i] * b;\n        ans[2] += Qs[1][1][0][i] * b;\n        if (!i)\n        {\n            ans[0] += (C[0][1][0] + C[1][1][0]) / 2;\n            ans[2] -= (C[0][1][0] + C[1][1][0]) / 2;\n        }\n\n        a *= i + 1;\n        b = Int(i + 1) * b - 1;\n    }\n    print(ans[0], ans[1], ans[2]);\n}\n\nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll Ten(int n){\n\treturn n==0?1:Ten(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\nusing mint=ModInt<1000000007>;\n//using mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nvoid Answer(mint p,mint q,mint r){\n\tprint(p,2);\n\tprint(q,2);\n\tprint(r);\n\texit(0);\n}\n\nvoid AnswerImpossible(string s){\n\tint n=s.size();\n\tREP(i,n){\n\t\tif(i+3<=n&&s.substr(i,3)==\"---\")\n\t\t\tAnswer(0,0,0);\n\t\tif(i+2<=n&&s.substr(i,2)==\"XX\")\n\t\t\tAnswer(0,0,0);\n\t}\n}\n\nvoid AnswerLength1(string s){\n\tif(s==\"X\"){\n\t\tAnswer(mint(1)/2,0,mint(-1)/2);\n\t}\n\tif(s==\"-\"){\n\t\tAnswer(mint(1)/2,0,mint(1)/2);\n\t}\n}\n\nvector<mint> Magic(int n){\n\tvector<mint> dp(n);\n\tdp[0]=1;\n\tFOR(i,1,n){\n\t\tREP(j,i)\n\t\t\tdp[i]+=dp[j]*(2*(i-j)-1)*factInv[2*(i-j)];\n\t}\n\treturn dp;\n}\n\n//-X-X-\nvector<mint> CalcA(int n){\n\tvector<mint> arr=Magic(n);\n\tmint ans=0;\n\tREP(i,n){\n\t\tint s=(n-1-i)*2;\n\t\tmint p=arr[i]*factInv[s+2];\n\t\tmint q=-arr[i]*factInv[s+3];\n\t\tans+=p;\n\t\tans+=q;\n\t}\n\treturn {ans};\n}\n\npair<mint,mint> EvalSub(vector<mint> p){\n\tint n=p.size();\n\tpair<mint,mint> res(0,0);\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(i==0)\n\t\t\tres.first+=p[i];\n\t\tres.second-=p[i];\n\t\tif(i)\n\t\t\tp[i-1]+=i*p[i];\n\t}\n\treturn res;\n}\n\n//-X-X\nvector<mint> CalcB(int n){\n\tvector<mint> arr=Magic(n);\n\tvector<mint> f(n*2);\n\tREP(i,n){\n\t\tint s=(n-1-i)*2;\n\t\tf[s]=arr[i]*factInv[s];\n\t\tf[s+1]=-arr[i]*factInv[s+1];\n\t}\n\tauto w=EvalSub(f);\n\treturn {w.first,w.second};\n}\n\n//X-X\nvector<mint> CalcC(int n){\n\tassert(n>=2);\n\tvector<mint> arr=Magic(n-1);\n\tREP(i,n-2)\n\t\tarr[i+1]+=arr[i];\n\tmint p=mint(1)/2,q=0,r=mint(-1)/2;\n\tvector<mint> f(2*(n-1));\n\tREP(i,n-1){\n\t\tf[i*2]=arr[n-2-i]*factInv[i*2];\n\t\tf[i*2+1]=-arr[n-2-i]*factInv[i*2+1];\n\t}\n\tcerr<<f<<endl;\n\tauto w=EvalSub(f);\n\tq-=w.first;\n\tr-=w.second;\n\treturn {p,q,r};\n}\n\nvector<mint> mult(vector<mint> x,vector<mint> y){\n\tint n=x.size(),m=y.size();\n\tvector<mint> z(n+m-1);\n\tREP(i,n)REP(j,m)\n\t\tz[i+j]+=x[i]*y[j];\n\tz.resize(3);\n\treturn z;\n}\n\nsigned main(){\n\tint n=read();\n\tstring s=readString();\n\tAnswerImpossible(s);\n\tAnswerLength1(s);\n\tif(s[0]=='-'){\n\t\tif(s[1]=='-'){\n\t\t\ts.insert(s.begin(),'X');\n\t\t}else{\n\t\t\ts.erase(s.begin());\n\t\t}\n\t}\n\tAnswerLength1(s);\n\tn=s.size();\n\tif(s[n-1]=='-'){\n\t\tif(s[n-2]=='-'){\n\t\t\ts.PB('X');\n\t\t}else{\n\t\t\ts.pop_back();\n\t\t}\n\t}\n\tAnswerLength1(s);\n\tn=s.size();\n\t\n\tvector<mint> ans{1,0,0};\n\t\n\tint last=0;\n\tREP(i,n-1){\n\t\tif(s[i]=='-'&&s[i+1]=='-'){\n\t\t\tif(last==0){\n\t\t\t\tans=mult(ans,CalcB((i+1)/2));\n\t\t\t}else{\n\t\t\t\tans=mult(ans,CalcA((i-last)/2));\n\t\t\t}\n\t\t\tlast=i+1;\n\t\t}\n\t}\n\tif(last==0)\n\t\tans=mult(ans,CalcC((n+1)/2));\n\telse\n\t\tans=mult(ans,CalcB((n-last)/2));\n\tAnswer(ans[0],ans[1],ans[2]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 2/24/2019, 9:39:27 AM\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <functional>\n#include <random> // auto rd = bind(uniform_int_distribution<int>(0, 9), mt19937(10101010));\n#include <chrono> // std::chrono::system_clock::time_point start_time, end_time;\n// start = std::chrono::system_clock::now();\n// double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end_time-start_time).count();\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\nconst ll MOD = 1000000007;\n\nconst int MAX_SIZE = 1000010;\n\nlong long inv[MAX_SIZE];\nlong long fact[MAX_SIZE];\nlong long factinv[MAX_SIZE];\nll factinvsum[MAX_SIZE];\n\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = ((MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n  }\n  fact[0] = factinv[0] = factinvsum[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = (i * fact[i - 1]) % MOD;\n    factinv[i] = (inv[i] * factinv[i - 1]) % MOD;\n    factinvsum[i] = (factinv[i] + factinvsum[i - 1]) % MOD;\n  }\n}\n\ntypedef vector<ll> Poly;\n\nostream &operator<<(ostream &o_str, const Poly &p)\n{\n  o_str << \"{ \";\n  for (auto i = 0; i < (int)p.size(); i++)\n  {\n    o_str << p[i];\n    if (i < (int)p.size() - 1)\n    {\n      o_str << \", \";\n    }\n  }\n  return o_str << \" }\";\n}\n\nvoid reduce(Poly &v)\n{\n  while (!v.empty() && v.back() % MOD == 0)\n  {\n    v.pop_back();\n  }\n}\n\nbool is_zero(Poly p)\n{\n  reduce(p);\n  return p.empty();\n}\n\nPoly operator+(Poly p, Poly q)\n{\n  reduce(p);\n  reduce(q);\n  if (p.size() < q.size())\n  {\n    return q + p;\n  }\n  else\n  {\n    for (auto i = 0; i < (int)q.size(); i++)\n    {\n      p[i] += q[i];\n      p[i] %= MOD;\n    }\n  }\n  reduce(p);\n  return p;\n}\n\nPoly operator-(Poly p)\n{\n  reduce(p);\n  for (auto i = 0; i < (int)p.size(); i++)\n  {\n    p[i] %= MOD;\n    p[i] = MOD - p[i];\n    p[i] %= MOD;\n  }\n  reduce(p);\n  return p;\n}\n\nPoly operator-(Poly p, Poly q)\n{\n  return p + (-q);\n}\n\ntypedef tuple<Poly, Poly, ll> Func;\n\nostream &operator<<(ostream &o_str, const Func &f)\n{\n  o_str << \"a = \" << get<0>(f) << endl;\n  o_str << \"b = \" << get<1>(f) << endl;\n  o_str << \"c = \" << get<2>(f);\n  return o_str;\n}\n\nvoid reduce(Func &f)\n{\n  reduce(get<0>(f));\n  reduce(get<1>(f));\n}\n\nFunc operator+(Func f, Func g)\n{\n  reduce(f);\n  reduce(g);\n  Func ans = Func(get<0>(f) + get<0>(g), get<1>(f) + get<1>(g), get<2>(f) + get<2>(g));\n  reduce(ans);\n  get<2>(ans) %= MOD;\n  return ans;\n}\n\nFunc operator-(Func f)\n{\n  reduce(f);\n  Func ans = Func(-get<0>(f), -get<1>(f), (MOD - get<2>(f)) % MOD);\n  reduce(f);\n  return f;\n}\n\nFunc operator-(Func p, Func q)\n{\n  return p + (-q);\n}\n\nFunc int_0(Func f)\n{\n  Poly a = get<0>(f);\n  Poly b = get<1>(f);\n  ll c = get<2>(f);\n  Poly a_prime, b_prime;\n  ll c_prime;\n  int K = a.size();\n  a_prime.push_back(c);\n  for (auto i = 1; i <= K; i++)\n  {\n    a_prime.push_back((a[i - 1] * inv[i]) % MOD);\n  }\n  reduce(a_prime);\n  int L = b.size();\n  b_prime.push_back(0);\n  for (auto i = 1; i <= L; i++)\n  {\n    b_prime.push_back((b[i - 1] * inv[i]) % MOD);\n  }\n  reduce(b_prime);\n  c_prime = (MOD - c) % MOD;\n  return Func(a_prime, b_prime, c_prime);\n}\n\nFunc int_1(Func f)\n{\n  Poly a = get<0>(f);\n  Poly b = get<1>(f);\n  ll c = get<2>(f);\n  Poly a_prime, b_prime;\n  ll c_prime;\n  int K = a.size();\n  ll t = 0;\n  for (auto i = 0; i < K; i++)\n  {\n    t += (a[i] * inv[i + 1]) % MOD;\n    t %= MOD;\n  }\n  a_prime.push_back(t);\n  for (auto i = 1; i <= K; i++)\n  {\n    a_prime.push_back((MOD - ((a[i - 1] * inv[i]) % MOD)) % MOD);\n  }\n  reduce(a_prime);\n  int L = b.size();\n  t = (MOD - c) % MOD;\n  for (auto i = 0; i < L; i++)\n  {\n    t += (b[i] * inv[i + 1]) % MOD;\n    t %= MOD;\n  }\n  b_prime.push_back(t);\n  for (auto i = 1; i <= L; i++)\n  {\n    b_prime.push_back((MOD - ((b[i - 1] * inv[i]) % MOD)) % MOD);\n  }\n  reduce(b_prime);\n  c_prime = c;\n  return Func(a_prime, b_prime, c_prime);\n}\n\ntypedef tuple<ll, ll, ll> Flush;\n\nostream &operator<<(ostream &o_str, const Flush &x)\n{\n  return o_str << get<0>(x) << \" \" << get<1>(x) << \" \" << get<2>(x);\n}\n\nFlush operator+(Flush x, Flush y)\n{\n  get<0>(x) += get<0>(y);\n  get<0>(x) %= MOD;\n  get<1>(x) += get<1>(y);\n  get<1>(x) %= MOD;\n  get<2>(x) += get<2>(y);\n  get<2>(x) %= MOD;\n  return x;\n}\n\nFlush operator-(Flush x)\n{\n  get<0>(x) = (MOD - get<0>(x)) % MOD;\n  get<1>(x) = (MOD - get<1>(x)) % MOD;\n  get<2>(x) = (MOD - get<2>(x)) % MOD;\n  return x;\n}\n\nFlush operator-(Flush x, Flush y)\n{\n  return x + (-y);\n}\n\nFlush operator*(ll k, Flush x)\n{\n  get<0>(x) *= k;\n  get<0>(x) %= MOD;\n  get<1>(x) *= k;\n  get<1>(x) %= MOD;\n  get<2>(x) *= k;\n  get<2>(x) %= MOD;\n  return x;\n}\n\nFlush operator*(Flush x, ll k)\n{\n  return k * x;\n}\n\nFlush int_01(ll i)\n{\n  ll x = fact[i];\n  ll y = (MOD - (fact[i] * factinvsum[i]) % MOD) % MOD;\n  return Flush(x, y, 0);\n}\n\nFlush int_01_e(ll i)\n{\n  ll x = fact[i];\n  ll y = (MOD - (fact[i] * factinvsum[i]) % MOD) % MOD;\n  return Flush(0, x, y);\n}\n\nFlush int_e_2()\n{\n  return Flush(inv[2], 0, (MOD - inv[2]) % MOD);\n}\n\nFlush integral(Func f)\n{\n  Poly a = get<0>(f);\n  Poly b = get<1>(f);\n  ll c = get<2>(f);\n  ll x = c;\n  int K = a.size();\n  for (auto i = 0; i < K; i++)\n  {\n    x += (a[i] * inv[i + 1]) % MOD;\n    x %= MOD;\n  }\n  ll y = (MOD - c) % MOD;\n  int L = b.size();\n  for (auto i = 0; i < L; i++)\n  {\n    y += (b[i] * inv[i + 1]) % MOD;\n    y %= MOD;\n  }\n  return Flush(x, y, 0);\n}\n\nFlush integral_e(Func f)\n{\n  Flush ans = Flush(0, 0, 0);\n  Poly a = get<0>(f);\n  Poly b = get<1>(f);\n  ll c = get<2>(f);\n  int K = a.size();\n  for (auto i = 0; i < K; i++)\n  {\n    ans = ans + int_01(i) * a[i];\n  }\n  int L = b.size();\n  for (auto i = 0; i < L; i++)\n  {\n    ans = ans + int_01_e(i) * b[i];\n  }\n  ans = ans + int_e_2() * c;\n  return ans;\n}\n\nint N;\nstring S;\nFunc DP[1010][2][2][2];\n\nint main()\n{\n  init();\n  vector<ll> temp_v;\n  Func zero = Func(temp_v, temp_v, 0);\n  fill(&DP[0][0][0][0], &DP[0][0][0][0] + 1010 * 2 * 2 * 2, zero);\n  cin >> N >> S;\n  if (S[0] == 'X')\n  {\n    DP[0][0][1][0] = Func(temp_v, temp_v, 1);\n  }\n  else\n  {\n    DP[0][0][0][1] = Func(temp_v, temp_v, 1);\n    vector<ll> temp_w;\n    temp_w.push_back(1);\n    DP[0][1][1][1] = Func(temp_w, temp_v, MOD - 1);\n  }\n  for (auto i = 1; i < N; i++)\n  {\n    if (S[i] == 'X')\n    {\n      for (auto k = 0; k < 2; k++)\n      {\n        DP[i][0][1][0] = DP[i][0][1][0] + int_0(DP[i - 1][1][1][k]);\n      }\n      for (auto k = 0; k < 2; k++)\n      {\n        for (auto l = 0; l < 2; l++)\n        {\n          DP[i][0][1][0] = DP[i][0][1][0] + int_1(DP[i - 1][k][l][1]);\n        }\n      }\n    }\n    else\n    {\n      for (auto k = 0; k < 2; k++)\n      {\n        DP[i][0][0][1] = DP[i][0][0][1] + int_0(DP[i - 1][1][1][k]);\n      }\n      for (auto k = 0; k < 2; k++)\n      {\n        DP[i][1][1][1] = DP[i][1][1][1] + int_0(DP[i - 1][0][1][k]);\n      }\n      for (auto k = 0; k < 2; k++)\n      {\n        for (auto l = 0; l < 2; l++)\n        {\n          DP[i][0][0][1] = DP[i][0][0][1] + int_1(DP[i - 1][k][1][l]);\n        }\n      }\n    }\n    /*\n#if DEBUG == 1\n    if (N < 10)\n    {\n      for (auto k = 0; k < 2; k++)\n      {\n        for (auto l = 0; l < 2; l++)\n        {\n          for (auto m = 0; m < 2; m++)\n          {\n            cerr << \"DP[\" << i << \"][\" << k << \"][\" << l << \"][\" << m << \"]:\" << endl;\n            cerr << DP[i][k][l][m] << endl;\n          }\n        }\n      }\n    }\n#endif\n    */\n  }\n  Flush ans = Flush(0, 0, 0);\n#if DEBUG == 1\n  for (auto k = 0; k < 2; k++)\n  {\n    for (auto l = 0; l < 2; l++)\n    {\n      for (auto m = 0; m < 2; m++)\n      {\n        cerr << \"DP[\" << N - 1 << \"][\" << k << \"][\" << l << \"][\" << m << \"]:\" << endl;\n        cerr << DP[N - 1][k][l][m] << endl;\n      }\n    }\n  }\n#endif\n  for (auto k = 0; k < 2; k++)\n  {\n    ans = ans + integral(DP[N - 1][k][0][1]);\n    ans = ans + integral(DP[N - 1][k][1][1]);\n  }\n  for (auto k = 0; k < 2; k++)\n  {\n    ans = ans + integral_e(DP[N - 1][k][1][0]);\n    ans = ans - integral_e(DP[N - 1][k][0][1]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "e"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int P = 1e9 + 7;\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)\n    a += P;\n}\n\nint mul(int a,int b){\n  return a * b % P;\n}\nstruct war{\n  int a,b,c;\n  void operator +=(war x){\n    add(a, x.a);\n    add(b, x.b);\n    add(c, x.c);\n  }\n  void operator -=(war x){\n    sub(a, x.a);\n    sub(b, x.b);\n    sub(c, x.c);\n  }\n  \n  void operator *=(war x){\n    c = mul(c, x.a);\n    add(c,mul(a, x.c));\n    add(c,mul(b, x.b));\n    \n    \n    b = mul(b, x.a);\n    add(b,mul(a, x.b));\n    \n    a = mul(a, x.a);\n  }\n};\n\nconst int MAX = 1001;\nint dp[MAX][3];\n\nwar licz1(int x){\n  war res = {0,1,0};\n  R(i,x - 1){\n    res -= {0,dp[i + 1][2],0};\n  }\n  debug(x, res.b * 3 % P);\n  return res;\n}\n\nwar licz2(int x){\n  debug(x);\n  if(x == 1){\n    return {(P + 1) / 2, 0, (P - 1) / 2};\n  }\n  war res = {1,0,0};\n  res -= licz2(x-1);\n  R(i,2 * x - 2){\n    war pom = licz1((i + 1) / 2);\n    pom *= {0,1,0};\n    res -= pom;\n  }\n  return res;\n}\n\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  \n  dp[0][1] = dp[0][0] = 1;\n  dp[0][2] = 0;\n  R(i,MAX)if(i)R(j,3){\n    R(k,i){\n      add(dp[i][j], mul(pot(2 * i - 1 + j, P - 2), mul(dp[k][j / 2], dp[i - k - 1][(j + 1) / 2])));\n    }\n  }\n  debug(dp[0][2]);\n  debug(dp[1][2] * 3 % P);\n  debug(dp[2][2] * 5 % P);\n  debug(dp[3][2] * 7 % P);\n  \n  int n;\n  string z;\n  cin >> n >> z;\n  if(n == 1 && z[0] == '-'){\n    cout << (P + 1) / 2 << \" 0 \" << (P + 1) / 2 << \"\\n\";\n    return 0;\n  }\n  R(i,n-1)if(z[i] == 'X' && z[i+1] == 'X'){\n    cout << \"0 0 0\\n\";\n    return 0;\n  }\n  int ile = 0;\n  war res = {1,0,0};\n  vector<int> x;\n  R(i,n){\n    if(z[i] == '-'){\n      if(i && z[i-1] == '-'){\n        x.PB(ile);\n        ile = 0;\n      }\n    }else{\n      ile ++;\n    }\n  }\n  debug(ile, x);\n  if(x.empty()){\n    res = licz2(ile);\n  }else{\n    res *= licz1(ile);\n    res *= licz1(x[0]);\n    R(i,SZ(x))if(i){\n      res *= {dp[x[i]][2],0,0};\n    }\n  }\n  cout << res.a << \" \" << res.b << \" \" << res.c << \"\\n\";\n}\n"
  },
  {
    "language": "C",
    "code": "//AWTF2019-E\n//Thanks to:\n//http://kazune-lab.net/contest/2019/02/24/wtf19-open/#e---e\n\n#include<stdio.h>\n#define mod 1000000007\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b%2){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b/=2;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long inv[1024];\n\nvoid invcalc(){\n  long long i;\n  for(i=0;i<1024;i++){\n    inv[i]=modular_inverse(i);\n  }\n}\n\nvoid indefinite_integral(long long f[1024]){\n  long long i;\n  for(i=1022;i>=0;i--){\n    f[i+1]=inv[i+1]*f[i];\n    f[i+1]%=mod;\n  }\n  f[0]=0;\n}\n\nlong long fcalc(long long f[1024],long long x){\n  long long i,r=0;\n  if(x==0){\n    return f[0];\n  }\n  if(x==1){\n    for(i=0;i<1024;i++){\n      r+=f[i];\n      r%=mod;\n    }\n    return r;\n  }\n}\n\ntypedef struct{\n  long long p[1024];\n  long long q[1024];\n  long long c;\n}func;\n\nvoid integral_ztx(func *a,func *b){\n  long long w,i;\n\n  //func_add\n  for(i=0;i<1024;i++){\n    (((func*)a)->p[i])+=(((func*)b)->p[i]);\n    (((func*)a)->p[i])%=mod;\n    (((func*)a)->q[i])+=(((func*)b)->q[i]);\n    (((func*)a)->q[i])%=mod;\n  }\n  (((func*)a)->c)+=(((func*)b)->c);\n  (((func*)a)->c)%=mod;\n\n  w=fcalc(((func*)b)->p,0);\n  (((func*)a)->p[0])+=mod;\n  (((func*)a)->p[0])-=w;\n  (((func*)a)->p[0])%=mod;\n\n  w=fcalc(((func*)b)->q,0);\n  (((func*)a)->q[0])+=mod;\n  (((func*)a)->q[0])-=w;\n  (((func*)a)->q[0])%=mod;\n\n  w=((func*)b)->c;\n  (((func*)a)->p[0])+=mod;\n  (((func*)a)->p[0])-=w;\n  (((func*)a)->p[0])%=mod;\n}\n\nvoid integral_xto(func *a,func *b){\n  long long w,i;\n\n  //func_dec\n  for(i=0;i<1024;i++){\n    (((func*)a)->p[i])+=mod;\n    (((func*)a)->p[i])-=(((func*)b)->p[i]);\n    (((func*)a)->p[i])%=mod;\n    (((func*)a)->q[i])+=mod;\n    (((func*)a)->q[i])-=(((func*)b)->q[i]);\n    (((func*)a)->q[i])%=mod;\n  }\n  (((func*)a)->c)+=mod;\n  (((func*)a)->c)-=(((func*)b)->c);\n  (((func*)a)->c)%=mod;\n\n  w=fcalc(((func*)b)->p,1);\n  (((func*)a)->p[0])+=w;\n  (((func*)a)->p[0])%=mod;\n\n  w=fcalc(((func*)b)->q,1);\n  (((func*)a)->q[0])+=w;\n  (((func*)a)->q[0])%=mod;\n\n  w=((func*)b)->c;\n  (((func*)a)->q[0])+=w;\n  (((func*)a)->q[0])%=mod;\n}\n\nvoid funcprint(func a){\n  long long i;\n  printf(\"p: \");\n  for(i=0;i<1024;i++){\n    if(a.p[i]!=0){\n      printf(\"%lld x^%lld \",a.p[i],i);\n    }\n  }\n  printf(\"\\nq:(1/e)* \");\n  for(i=0;i<1024;i++){\n    if(a.q[i]!=0){\n      printf(\"%lld x^%lld \",a.q[i],i);\n    }\n  }\n  printf(\"\\nc:%lld\\n\",a.c);\n}\n\nint main(){\n  invcalc();\n  long long n,i,j,k,l,m,t,w,v;\n  long long a,b,c;\n  char s[1024];\n  func dp[1024][2][2][2];\n\n  scanf(\"%lld%s\",&n,s);\n\n  for(i=0;i<1024;i++){\n    for(j=0;j<2;j++){\n      for(k=0;k<2;k++){\n        for(l=0;l<2;l++){\n          for(m=0;m<1024;m++){\n            dp[i][j][k][l].p[m]=0;\n            dp[i][j][k][l].q[m]=0;\n          }\n          dp[i][j][k][l].c=0;\n        }\n      }\n    }\n  }\n\n  if(s[0]=='X'){\n    dp[0][0][1][0].c=1;\n  }\n  else{\n    dp[0][0][0][1].c=1;\n    dp[0][1][1][1].p[0]=1;\n    dp[0][1][1][1].c=mod-1;\n  }\n\n  for(i=1;i<n;i++){\n    for(j=0;j<2;j++){\n      for(k=0;k<2;k++){\n        for(l=0;l<2;l++){\n          indefinite_integral(dp[i-1][j][k][l].p);\n          indefinite_integral(dp[i-1][j][k][l].q);\n          dp[i-1][j][k][l].c=mod-dp[i-1][j][k][l].c;\n          dp[i-1][j][k][l].c%=mod;\n        }\n      }\n    }\n\n    if(s[i]=='X'){\n      //X_i-1<X_i\n      integral_ztx(&dp[i][0][1][0],&dp[i-1][1][1][0]);\n      integral_ztx(&dp[i][0][1][0],&dp[i-1][1][1][1]);\n      //X_i-1>X_i\n      integral_xto(&dp[i][0][1][0],&dp[i-1][0][0][1]);\n      integral_xto(&dp[i][0][1][0],&dp[i-1][0][1][1]);\n      integral_xto(&dp[i][0][1][0],&dp[i-1][1][0][1]);\n      integral_xto(&dp[i][0][1][0],&dp[i-1][1][1][1]);\n    }\n    else{\n      //X_i-1<X_i\n      integral_ztx(&dp[i][1][1][1],&dp[i-1][0][1][0]);\n      integral_ztx(&dp[i][1][1][1],&dp[i-1][0][1][1]);\n\n      integral_ztx(&dp[i][0][0][1],&dp[i-1][1][1][0]);\n      integral_ztx(&dp[i][0][0][1],&dp[i-1][1][1][1]);\n\n      //X_i-1>X_i\n      integral_xto(&dp[i][0][0][1],&dp[i-1][0][1][0]);\n      integral_xto(&dp[i][0][0][1],&dp[i-1][0][1][1]);\n      integral_xto(&dp[i][0][0][1],&dp[i-1][1][1][0]);\n      integral_xto(&dp[i][0][0][1],&dp[i-1][1][1][1]);\n    }\n    //for(j=0;j<2;j++){\n    //  for(k=0;k<2;k++){\n    //    for(l=0;l<2;l++){\n    //      printf(\"%d[%d,%d,%d]\\n\",i,j,k,l);\n    //      funcprint(dp[i][j][k][l]);\n    //    }\n    //  }\n    //}\n  }\n\n  a=0;b=0;c=0;\n\n  for(i=0;i<2;i++){\n    t=0;m=1;\n    for(j=0;j<1024;j++){\n      t+=modular_inverse(m);\n      t%=mod;\n      v=(m*t)%mod;\n      v=(v*(mod-1))%mod;\n\n      w=(m*dp[n-1][i][1][0].p[j])%mod;\n      a+=w;\n      a%=mod;\n      w=(v*dp[n-1][i][1][0].p[j])%mod;\n      b+=w;\n      b%=mod;\n\n      w=(m*dp[n-1][i][1][0].q[j])%mod;\n      b+=w;\n      b%=mod;\n      w=(v*dp[n-1][i][1][0].q[j])%mod;\n      c+=w;\n      c%=mod;\n\n      m*=(j+1);\n      m%=mod;\n    }\n    w=(inv[2]*dp[n-1][i][1][0].c)%mod;\n    c+=mod;\n    c-=w;\n    c%=mod;\n    a+=w;\n    a%=mod;\n  }\n\n  for(i=0;i<2;i++){\n    t=0;m=1;\n    for(j=0;j<1024;j++){\n      t+=modular_inverse(m);\n      t%=mod;\n      v=(m*t)%mod;\n      v=(v*(mod-1))%mod;\n\n      w=(m*dp[n-1][i][0][1].p[j])%mod;\n      w=(w*(mod-1))%mod;\n      a+=w;\n      a%=mod;\n      w=(v*dp[n-1][i][0][1].p[j])%mod;\n      w=(w*(mod-1))%mod;\n      b+=w;\n      b%=mod;\n\n      w=(m*dp[n-1][i][0][1].q[j])%mod;\n      w=(w*(mod-1))%mod;\n      b+=w;\n      b%=mod;\n      w=(v*dp[n-1][i][0][1].q[j])%mod;\n      w=(w*(mod-1))%mod;\n      c+=w;\n      c%=mod;\n\n      m*=(j+1);\n      m%=mod;\n    }\n    w=(inv[2]*dp[n-1][i][0][1].c)%mod;\n    a+=mod;\n    a-=w;\n    a%=mod;\n    c+=w;\n    c%=mod;\n  }\n\n  for(i=0;i<2;i++){\n    for(j=0;j<2;j++){\n      indefinite_integral(dp[n-1][i][j][1].p);\n      a+=mod;\n      a+=fcalc(dp[n-1][i][j][1].p,1);\n      a-=fcalc(dp[n-1][i][j][1].p,0);\n      a%=mod;\n\n      indefinite_integral(dp[n-1][i][j][1].q);\n      b+=mod;\n      b+=fcalc(dp[n-1][i][j][1].q,1);\n      b-=fcalc(dp[n-1][i][j][1].q,0);\n      b%=mod;\n\n      a+=dp[n-1][i][j][1].c;\n      a%=mod;\n      b+=mod;\n      b-=dp[n-1][i][j][1].c;\n      b%=mod;\n    }\n  }\n\n  printf(\"%lld %lld %lld\\n\",a,b,c);\n  return 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "りんごさんすき"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 10L^^9 + 7;\nenum LIM = 3000;\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\n\n/*\n  Int[0..t] exp(-s) ds = - exp(-t) + 1\n  Int[t..1] exp(-s) ds = - exp(-1) + exp(-t)\n*/\n// Fun(p, q, r) = p + q exp(-1) + r exp(-t)\nstruct Fun {\n  long[] p, q;\n  long r;\n  Fun opBinary(string op)(in Fun f) const if (op == \"+\") {\n    long[] pp = new long[max(p.length, f.p.length)];\n    long[] qq = new long[max(q.length, f.q.length)];\n    long rr;\n    pp[0 .. p.length] += p[];\n    pp[0 .. f.p.length] += f.p[];\n    pp[] %= MO;\n    qq[0 .. q.length] += q[];\n    qq[0 .. f.q.length] += f.q[];\n    qq[] %= MO;\n    rr += r;\n    rr += f.r;\n    rr %= MO;\n    debug {\n      // writefln(\"%s + %s = %s\", this, f, Fun(pp, qq, rr));\n    }\n    return Fun(pp, qq, rr);\n  }\n  ref Fun opOpAssign(string op)(in Fun f) if (op == \"+\") {\n    return this = this + f;\n  }\n  Fun integrate0() const {\n    long[] pp = new long[p.length + 1];\n    long[] qq = new long[q.length + 1];\n    long rr;\n    foreach (d; 0 .. p.length) {\n      pp[d + 1] += inv[d + 1] * p[d];\n      pp[d + 1] %= MO;\n    }\n    foreach (d; 0 .. q.length) {\n      qq[d + 1] += inv[d + 1] * q[d];\n      qq[d + 1] %= MO;\n    }\n    pp[0] += r;\n    pp[0] %= MO;\n    rr = -r;\n    debug {\n      // writefln(\"Int0 %s = %s\", this, Fun(pp, qq, rr));\n    }\n    return Fun(pp, qq, rr);\n  }\n  Fun integrate1() const {\n    long[] pp = new long[p.length + 1];\n    long[] qq = new long[q.length + 1];\n    long rr;\n    foreach (d; 0 .. p.length) {\n      pp[0] += inv[d + 1] * p[d];\n      pp[0] %= MO;\n      pp[d + 1] -= inv[d + 1] * p[d];\n      pp[d + 1] %= MO;\n    }\n    foreach (d; 0 .. q.length) {\n      qq[0] += inv[d + 1] * q[d];\n      qq[0] %= MO;\n      qq[d + 1] -= inv[d + 1] * q[d];\n      qq[d + 1] %= MO;\n    }\n    qq[0] -= r;\n    qq[0] %= MO;\n    rr = r;\n    debug {\n      // writefln(\"Int1 %s = %s\", this, Fun(pp, qq, rr));\n    }\n    return Fun(pp, qq, rr);\n  }\n}\nenum ZERO = Fun([0], [0], 0);\n\nint N;\nstring S;\n\nvoid main() {\n  prepare();\n  auto sumInvFac = new long[LIM];\n  sumInvFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    sumInvFac[i] = (sumInvFac[i - 1] + invFac[i]) % MO;\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      S = readToken();\n      \n      // up-run, down-constraints\n      auto DP = new Fun[][][](N, 2, 4);\n      auto dp = new Fun[][][](N, 2, 4);\n      foreach (i; 0 .. N) {\n        foreach (a; 0 .. 2) {\n          DP[i][a][] = ZERO;\n          dp[i][a][] = ZERO;\n        }\n      }\n      DP[0][0][3] = Fun([0], [0], 1);\n      DP[0][1][3] = Fun([1], [0], -1);\n      foreach (i; 0 .. N) {\n        foreach (a; 0 .. 2) foreach (c; 0 .. 4) {\n          const cc = c & ((S[i] == 'X') ? ((a == 0) ? 1 : 0) : ((a == 0) ? 2 : 3));\n          dp[i][a][cc] += DP[i][a][c];\n        }\n        debug {\n          foreach (a; 0 .. 2) {\n            writefln(\"DP[%s][%s] = %s\", i, a, DP[i][a]);\n          }\n          foreach (a; 0 .. 2) {\n            writefln(\"dp[%s][%s] = %s\", i, a, dp[i][a]);\n          }\n        }\n        if (i < N - 1) {\n          foreach (a; 0 .. 2) foreach (c; 0 .. 4) {\n            // <\n            if (c & 1) {\n              DP[i + 1][a ^ 1][3] += dp[i][a][c].integrate0;\n            }\n            // >\n            {\n              const cc = [0, 2, 1, 3][c];\n              DP[i + 1][0][cc] += dp[i][a][c].integrate1;\n            }\n          }\n        }\n      }\n      \n      auto f = [ZERO, ZERO];\n      foreach (a; 0 .. 2) foreach (c; 0 .. 4) {\n        foreach (r; 0 .. 2) {\n          if ((c >> r) & 1) {\n            f[r] += dp[N - 1][a][c];\n          }\n        }\n      }\n      debug {\n        writeln(\"f = \", f);\n      }\n      /*\n        Int[0..1] x^d dt = 1 / (d + 1)\n        Int[0..1] x^d exp(-t) dt = d! - d! (1/0! + ... + 1/d!) exp(-1)\n        Int[0..1] exp(-t) dt = 1 - exp(-1)\n        Int[0..1] exp(-t) exp(-t) dt = 1/2 - (1/2) exp(-2)\n      */\n      long[3] ans;\n      \n      // Int[0..1] f[0] exp(-t) dt\n      foreach (d; 0 .. f[0].p.length) {\n        ans[0] += fac[d] * f[0].p[d];\n        ans[0] %= MO;\n        ans[1] -= ((fac[d] * sumInvFac[d]) % MO) * f[0].p[d];\n        ans[1] %= MO;\n      }\n      foreach (d; 0 .. f[0].q.length) {\n        ans[1] += fac[d] * f[0].q[d];\n        ans[1] %= MO;\n        ans[2] -= ((fac[d] * sumInvFac[d]) % MO) * f[0].q[d];\n        ans[2] %= MO;\n      }\n      ans[0] += inv[2] * f[0].r;\n      ans[0] %= MO;\n      ans[2] -= inv[2] * f[0].r;\n      ans[2] %= MO;\n      \n      // Int[0..1] f[1] (1 - exp(-t)) dt\n      foreach (d; 0 .. f[1].p.length) {\n        ans[0] += inv[d + 1] * f[1].p[d];\n        ans[0] %= MO;\n        ans[0] -= fac[d] * f[1].p[d];\n        ans[0] %= MO;\n        ans[1] += ((fac[d] * sumInvFac[d]) % MO) * f[1].p[d];\n        ans[1] %= MO;\n      }\n      foreach (d; 0 .. f[1].q.length) {\n        ans[1] += inv[d + 1] * f[1].q[d];\n        ans[1] %= MO;\n        ans[1] -= fac[d] * f[1].q[d];\n        ans[1] %= MO;\n        ans[2] += ((fac[d] * sumInvFac[d]) % MO) * f[1].q[d];\n        ans[2] %= MO;\n      }\n      ans[0] += f[1].r;\n      ans[0] %= MO;\n      ans[1] -= f[1].r;\n      ans[1] %= MO;\n      ans[0] -= inv[2] * f[1].r;\n      ans[0] %= MO;\n      ans[2] += inv[2] * f[1].r;\n      ans[2] %= MO;\n      \n      ans[0] = (ans[0] % MO + MO) % MO;\n      ans[1] = (ans[1] % MO + MO) % MO;\n      ans[2] = (ans[2] % MO + MO) % MO;\n      writeln(ans[0], \" \", ans[1], \" \", ans[2]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "print(\"Hello World\")\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return input().rstrip()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = 1e10\nfc = [1] * 1010\nifc = [1] * 1010\nBn = [0] * 1010\n\ndef ad(x, y=0):\n    return (x + y) % mod\n\ndef mlt(x, y=1):\n    return (x * y) % mod\n    \ndef pwr(x, y):\n    return pow(x, y, mod)\n\ndef inv(x):\n    return pwr(x, mod - 2)\n\ndef bn(x):\n    if x > 0 and Bn[x] == 0: Bn[x] = ad(1, mlt(x, bn(x - 1)))\n    return Bn[x]\n\n#solve\ndef solve():\n    for i in range(1, 1010): fc[i] = fc[i - 1] * i\n    for i in range(1010): ifc[i] = inv(fc[i])\n    num = 1\n    dp = [[[0] * 1010 for _ in range(2)] for k in range(1010)]\n    dpc = [0] * 1010\n    f = [False] * 1010\n    n = II()\n    s = S()\n    if n == 1 and s == \"-\":\n        print(\"{} 0 {}\".format((mod + 1) // 2, (mod + 1) // 2))\n        return\n    q = 0\n    r = n\n    n = -1\n    if s[q] == \"-\":\n        q += 1\n    if s[q] == \"-\":\n        q += 1\n        n += 1\n        num += 1\n    if s[q] == \"-\":\n        print(\"0 0 0\")\n        return\n    for i in range(q, r):\n        if s[i] == \"X\":\n            if num == 0:\n                print(\"0 0 0\")\n                return\n            if n >= 0:\n                f[n] = num - 1\n            n += 1\n            num = 0\n        else:\n            if num > 1:\n                print(\"0 0 0\")\n                return\n            num += 1\n    if num == 2:\n        f[n] = 1\n        n += 1\n    dpc[0] = 1\n    for i in range(n):\n        if f[i]:\n            for j in range(2):\n                for k in range(2 * n + 2):\n                    kari = inv(k * k + 3 * k + 2)\n                    dp[i + 1][j][0] = ad(dp[i + 1][j][0], mlt(dp[i][j][k], kari))\n                    dp[i + 1][j][1] = ad(dp[i + 1][j][1], mlt(dp[i][j][k], mod - kari))\n            dp[i + 1][1][0] = ad(dp[i + 1][1][0], dpc[i])\n            dp[i + 1][1][1] = ad(dp[i + 1][1][1], mod - dpc[i])\n        else:\n            for j in range(2):\n                for k in range(2 * n + 2):\n                    kari = inv(k + 1)\n                    dp[i + 1][j][0] = ad(dp[i + 1][j][0], mlt(dp[i][j][k], kari))\n                    dp[i + 1][j][1] = ad(dp[i + 1][j][1], mlt(dp[i][j][k], mod - kari))\n                    dp[i + 1][j][k + 2] = ad(dp[i + 1][j][k + 2], mlt(dp[i][j][k], inv(k * k + 3 * k + 2)))\n            dp[i + 1][1][1] = ad(dp[i + 1][1][1], dpc[i])\n            dp[i + 1][1][0] = ad(dp[i + 1][1][0], mod - dpc[i])\n            dpc[i + 1] = ad(dpc[i + 1], dpc[i])\n    ans = [0] * 3\n    for j in range(2):\n        for k in range(2 * n + 2):\n            ans[j] = ad(ans[j], mlt(dp[n][j][k], fc[k]))\n            ans[j + 1] = ad(ans[j + 1], mlt(dp[n][j][k], mod - ad(fc[k], bn(k))))\n    kari = (mod + 1) // 2\n    ans[0] = ad(ans[0], mlt(dpc[n], kari))\n    ans[2] = ad(ans[2], mlt(dpc[n], mod - kari))\n    print(\"{} {} {}\".format(ans[0], ans[1], ans[2]))\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "print('いつもありがとうございます！')\nprint('ACしてくれてえらい！すき！')"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 1_000_000_007\n\nlim = 1 << 10\nfact = np.ones(lim, np.int64)\nfor n in range(1, lim):\n    fact[n] = fact[n - 1] * n % MOD\nfact_inv = np.ones(lim, np.int64)\nfact_inv[-1] = pow(int(fact[-1]), MOD - 2, MOD)\nfor n in range(lim - 1, 0, -1):\n    fact_inv[n - 1] = n * fact_inv[n] % MOD\ninv = np.zeros(lim, np.int64)\ninv[1:] = fact[:-1] * fact_inv[1:] % MOD\n\ndef integrate_poly_0x(F):\n    F1 = np.zeros_like(F)\n    F1[1:] = F[:-1] * inv[1:len(F)] % MOD\n    return F1\n\ndef integrate_poly_x1(F):\n    F1 = -integrate_poly_0x(F)\n    F1[0] -= F1.sum() % MOD\n    return F1 % MOD\n\ndef integrate_0x(a, F, G):\n    \"\"\"\\int_0^x (ae^{-x} + F(x) + G(x)/e)\"\"\"\n    F1 = integrate_poly_0x(F)\n    G1 = integrate_poly_0x(G)\n    F1[0] += a\n    return -a, F1, G1\n\ndef integrate_x1(a, F, G):\n    \"\"\"\\int_x^1 (ae^{-x} + F(x) + G(x)/e)\"\"\"\n    F1 = integrate_poly_x1(F)\n    G1 = integrate_poly_x1(G)\n    G1[0] -= a\n    return a, F1, G1\n\ndef integrate_01(a, F, G):\n    a, F, G = integrate_x1(a, F, G)\n    F[1:] = 0\n    G[1:] = 0\n    F[0] += a\n    return 0, F, G\n\ndef one_to_zero(dp0, dp1, dp2):\n    dp0 = integrate_0x(*dp2)\n    dp1 = integrate_x1(*dp2)\n    dp2 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n    return dp0, dp1, dp2\n\ndef zero_to_one(dp0, dp1, dp2):\n    a0, F0, G0 = integrate_01(*dp0)\n    a1, F1, G1 = integrate_x1(*dp1)\n    dp0 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n    dp1 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n    dp2 = [a0 + a1, F0 + F1, G0 + G1]\n    return dp0, dp1, dp2\n\ndef zero_to_zero(dp0, dp1, dp2):\n    a0, F0, G0 = integrate_01(*dp0)\n    dp0 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n    dp1 = [a0, F0, G0]\n    dp2 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n    return dp0, dp1, dp2\n\ndef integrate_poly_01_with_exp(F):\n    # int_0^1 e^{-x}F(x)dx = a + b/e の計算\n    a, b = 0, 0\n    F = F.copy()\n    while len(F) > 0:\n        a += F[0]\n        b -= F.sum() % MOD\n        F = F[1:] * np.arange(1, len(F)) % MOD\n    return a, b\n\ndef integrate_01_with_exp(a, F, G):\n    # int_0^1 e^{-x}(ae^{-x}+F(x)+G(x)/e) = a + b/e +c/e^2の計算\n    ans = np.zeros(3, np.int64)\n    if a & 1:\n        a += MOD\n    ans[0] += a // 2\n    ans[2] -= a // 2\n    a, b = integrate_poly_01_with_exp(F)\n    ans[0] += a\n    ans[1] += b\n    a, b = integrate_poly_01_with_exp(G)\n    ans[1] += a\n    ans[2] += b\n    return ans % MOD\n\ndef get_ans(dp0, dp1, dp2):\n    ans = np.zeros(3, np.int64)\n\n    a, F, G = integrate_01(*dp0)\n    ans[0] += a + F[0]\n    ans[1] += G[0]\n    a, F, G = integrate_01(*dp1)\n    ans[0] += a + F[0]\n    ans[1] += G[0]\n    ans -= integrate_01_with_exp(*dp1)\n    ans += integrate_01_with_exp(*dp2)\n    ans %= MOD\n    return ans\n\nN = int(readline())\nS = [1 if x == 'X' else 0 for x in readline().rstrip().decode()]\nN += 10\n\ndp0 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\ndp1 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\ndp2 = [0, np.zeros(N, np.int64), np.zeros(N, np.int64)]\n\nif S[0] == 1:\n    dp2[0] = 1\nelse:\n    dp0[0] = -1\n    dp0[1][0] = 1\n    dp1[0] = 1\nfor s, t in zip(S, S[1:]):\n    if (s, t) == (1, 1):\n        print(0, 0, 0)\n        exit()\n    elif (s, t) == (1, 0):\n        dp0, dp1, dp2 = one_to_zero(dp0, dp1, dp2)\n    elif (s, t) == (0, 1):\n        dp0, dp1, dp2 = zero_to_one(dp0, dp1, dp2)\n    elif (s, t) == (0, 0):\n        dp0, dp1, dp2 = zero_to_zero(dp0, dp1, dp2)\nprint(*get_ans(dp0, dp1, dp2))"
  },
  {
    "language": "Python",
    "code": "#参考URL\n#https://qiita.com/ageprocpp/items/104c051b2ec2086f5a9b\n\nmod=10**9+7\ndef value(obj):\n    if type(obj)==modint:\n        tmp=obj.number\n    else:\n        tmp=obj\n    return tmp%mod\nclass modint():\n    number=0\n    def __init__(self,num):\n        self.number=num%mod\n    def __add__(self,other):\n        tmp=value(other)\n        return modint(self.number+tmp)\n    def __iadd__(self,other):\n        tmp=value(other)\n        self.number+=tmp\n        self.number%=mod\n        return self\n    def __sub__(self,other):\n        tmp=value(other)\n        return modint(self.number-tmp)\n    def __isub__(self,other):\n        tmp=value(other)\n        self.number-=tmp\n        self.number%=mod\n        return self\n    def __mul__(self,other):\n        tmp=value(other)\n        return modint(self.number*tmp)\n    def __imul__(self,other):\n        tmp=value(other)\n        self.number*=tmp\n        self.number%=mod\n        return self\n    def __truediv__(self,other):\n        tmp=value(other)\n        return self*pow(tmp,mod-2,mod)\n    def __itruediv(self,other):\n        tmp=value(other)\n        self.number=self/tmp\n        self.number%=mod\n        return self\n    def __repr__(self):\n        return str(self.number)\n    def __eq__(self,other):\n        return value(self)==value(other)\n    def __ne__(self,other):\n        return value(self)!=value(other)\n    def __str__(self):\n        return str(self.number)\n    def __int__(self):\n        return self.number\n    def __hash__(self):\n        return self.number\n\nclass polynomial():\n    sequence=[0]\n    def __init__(self,seq):\n        self.sequence=[]\n        for i in seq:\n            self.sequence.append(value(i))\n    def get(self,x):\n        res=modint(0)\n        tmp=modint(1)\n        for a in self.sequence:\n            res+=tmp*a\n            tmp*=x\n            if tmp==0:\n                break\n        return res\n    def __add__(self,other):\n        res=[]\n        for i,a in enumerate(self.sequence):\n            try:\n                res[i]=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]=a\n        for i,a in enumerate(other.sequence):\n            try:\n                res[i]+=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]+=a\n        \n        return polynomial(res)\n    def __iadd__(self,other):\n        return self+other\n    def __sub__(self,other):\n        res=[]\n        for i,a in enumerate(self.sequence):\n            try:\n                res[i]=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]=a\n        for i,a in enumerate(other.sequence):\n            try:\n                res[i]-=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]-=a\n        return polynomial(res)\n    def __isub__(self,other):\n        return self-other\n    def indef_integral(self):\n        res=[modint(0)]\n        for i,a in enumerate(self.sequence):\n            res.append(modint(a)/(i+1))\n        return polynomial(res)\n    def integrate(self,flag):\n        #0: 0->x\n        #1:x->1\n        if flag==0:\n            return self.indef_integral()\n        else:\n            tmp=self.indef_integral()\n            return polynomial([tmp.get(1)])-tmp\n    def __repr__(self):\n        return str(self.sequence)\n    def __str__(self):\n        return str(self.sequence)\n\nclass func():\n    P=polynomial([modint(0)])\n    Q=polynomial([modint(0)])\n    C=modint(0)\n    def __init__(self,poly1,poly2,cnst):\n        self.P=poly1\n        self.Q=poly2\n        self.C=cnst\n    def __add__(self,other):\n        PP=self.P+other.P\n        QQ=self.Q+other.Q\n        CC=self.C+other.C\n        return func(PP,QQ,CC)\n    def __iadd__(self,other):\n        return self+other\n    def __sub__(self,other):\n        PP=self.P-other.P\n        QQ=self.Q-other.Q\n        CC=self.C-other.C\n        return func(PP,QQ,CC)\n    def __isub__(self,other):\n        return self-other\n    def dintegrate(self,flag):\n        if flag==0:\n            PP=self.P.integrate(0)+polynomial([self.C])\n            QQ=self.Q.integrate(0)\n            CC=modint(-1)*self.C\n        else:\n            PP=self.P.integrate(1)\n            QQ=self.Q.integrate(1)+polynomial([modint(-1)*self.C])\n            CC=self.C\n        return func(PP,QQ,CC)\nMAX_N=1009\nN=int(input())\ns=input()\nfact=[modint(0) for i in range(MAX_N+1)]\ninv=[modint(0) for i in range(MAX_N+1)]\nfact[0]=modint(1)\nfor i in range(MAX_N):\n    fact[i+1]=fact[i]*(i+1)\ninv[-1]=modint(1)/fact[-1]\nfor i in range(MAX_N-1,-1,-1):\n    inv[i]=inv[i+1]*(i+1)\ndp=[[[[func(polynomial([modint(0)]),polynomial([modint(0)]),modint(0)) for l in range(2)]for k in range(2)]for j in range(2)] for i in range(MAX_N+1)]\n\nif s[0]==\"X\":\n    dp[0][0][1][0]=func(polynomial([modint(0)]),polynomial([modint(0)]),modint(1))\nelse:\n    dp[0][0][0][1]=func(polynomial([modint(0)]),polynomial([modint(0)]),modint(1))\n    dp[0][1][1][1]=func(polynomial([modint(1)]),polynomial([modint(0)]),modint(-1))\nfor i in range(1,N):\n    if s[i]==\"X\":\n        dp[i][0][1][0]+=dp[i-1][1][1][0].dintegrate(0)\n        dp[i][0][1][0]+=dp[i-1][1][1][1].dintegrate(0)\n        dp[i][0][1][0]+=dp[i-1][0][0][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][0][1][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][1][0][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][1][1][1].dintegrate(1)\n    else:\n        dp[i][0][0][1]+=dp[i-1][1][1][0].dintegrate(0)\n        dp[i][0][0][1]+=dp[i-1][1][1][1].dintegrate(0)\n        dp[i][1][1][1]+=dp[i-1][0][1][0].dintegrate(0)\n        dp[i][1][1][1]+=dp[i-1][0][1][1].dintegrate(0)\n        dp[i][0][0][1]+=dp[i-1][0][1][0].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][0][1][1].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][1][1][0].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][1][1][1].dintegrate(1)\na=modint(0)\nb=modint(0)\nc=modint(0)\n\np = dp[N-1][0][1][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][0][1][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][0][1][1].C\nb-= dp[N-1][0][1][1].C\np = dp[N-1][1][1][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][1][1][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][1][1][1].C\nb-= dp[N-1][1][1][1].C\nfor x in range(2):\n    for i,v in enumerate(dp[N-1][x][1][0].P.sequence):\n        a+=modint(1)*v*fact[i]\n        for j in range(i+1):\n            b-=modint(1)*v*fact[i]*inv[j]\n    for i,v in enumerate(dp[N-1][x][1][0].Q.sequence):\n        b+=modint(1)*v*fact[i]\n        for j in range(i+1):\n            c-=modint(1)*v*fact[i]*inv[j]\n    a+=dp[N-1][x][1][0].C/2\n    c-=dp[N-1][x][1][0].C/2\n\np = dp[N-1][0][0][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][0][0][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][0][0][1].C\nb-= dp[N-1][0][0][1].C\np = dp[N-1][1][0][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][1][0][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][1][0][1].C\nb-= dp[N-1][1][0][1].C\nfor x in range(2):\n    for i,v in enumerate(dp[N-1][x][0][1].P.sequence):\n        a-=modint(1)*v*fact[i]\n        for j in range(i+1):\n            b+=modint(1)*v*fact[i]*inv[j]\n    for i,v in enumerate(dp[N-1][x][0][1].Q.sequence):\n        b-=modint(1)*v*fact[i]\n        for j in range(i+1):\n            c+=modint(1)*v*fact[i]*inv[j]\n    a-=dp[N-1][x][0][1].C/2\n    c+=dp[N-1][x][0][1].C/2\n\nprint(a,b,c)\n\n            \n"
  },
  {
    "language": "Python",
    "code": "print('I am tourist')"
  },
  {
    "language": "Python",
    "code": "from copy import *\nN=int(input())\nS=input()\nDP=[[[[0]*2 for i in range(2)] for j in range(2)] for k in range(N)]\nmod=10**9+7\nfor i in range(N):\n  for j in range(2):\n    for k in range(2):\n      for l in range(2):\n        DP[i][j][k][l]=[[],[],0]\nif S[0]=='X':\n  DP[0][0][1][0]=[[],[],1]\nelse:\n  DP[0][0][0][1]=[[],[],1]\n  DP[0][1][1][1]=[[1],[],mod-1]\ng1=[1,1]\ng2=[1,1]\ninv=[0,1]\nc=[1,2]\nfor i in range(2,N+5):\n  g1.append((g1[-1]*i)%mod)\n  inv.append((-inv[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inv[-1])%mod)\n  c.append((c[-1]+g2[i])%mod)\n\ndef add(x,y):\n  for j in range(2):\n    for i in range(len(y[j])-len(x[j])):\n      x[j].append(0)\n    for i in range(len(y[j])):\n      x[j][i]=(x[j][i]+y[j][i])%mod\n  x[2]=(x[2]+y[2])%mod\n\ndef integrate(p):\n  p[2]=-p[2]%mod\n  for j in range(2):\n    p[j].append(0)\n    for i in range(len(p[j])-2,-1,-1):\n      p[j][i+1]=p[j][i]*inv[i+1]%mod\n      p[j][i]=0\n\ndef fx0(p):\n  integrate(p)\n  p[0][0]=(p[0][0]-p[2])%mod\n\ndef f1x(p):\n  integrate(p)\n  for j in range(2):\n    for i in range(len(p[j])):\n      p[j][i]=-p[j][i]%mod\n  p[2]=-p[2]%mod\n  for i in range(2):\n    p[i][0]=-sum(p[i])%mod\n  p[1][0]=(p[1][0]-p[2])%mod\n\nfor i in range(N-1):\n  if S[i+1]=='X':\n    add(DP[i][1][1][0],DP[i][1][1][1])\n    fx0(DP[i][1][1][0])\n    add(DP[i][1][1][1],DP[i][1][0][1])\n    add(DP[i][1][1][1],DP[i][0][1][1])\n    add(DP[i][1][1][1],DP[i][0][0][1])\n    f1x(DP[i][1][1][1])\n    for j in range(2):\n      add(DP[i+1][0][1][0],DP[i][1][1][j])\n  else:\n    t=[[],[],0]\n    add(DP[i][0][1][0],DP[i][0][1][1])\n    add(DP[i][1][1][0],DP[i][1][1][1])\n    add(DP[i+1][1][1][1],DP[i][0][1][0])\n    fx0(DP[i+1][1][1][1])\n    add(t,DP[i][0][1][0])\n    add(t,DP[i][1][1][0])\n    f1x(t)\n    fx0(DP[i][1][1][0])\n    add(DP[i+1][0][0][1],DP[i][1][1][0])\n    add(DP[i+1][0][0][1],t)\n\ndef f10(p,o,e):\n  r=[0]*3\n  q=deepcopy(p)\n  integrate(q)\n  r[0]=(sum(q[0])-q[2])*o%mod\n  r[1]=(sum(q[1])+q[2])*o%mod\n  for j in range(2):\n    for i in range(len(p[j])):\n      r[j]=(r[j]+p[j][i]*g1[i]*e)%mod\n      r[j+1]=(r[j+1]-p[j][i]*g1[i]*c[i]*e)%mod\n  r[0]=(r[0]+p[2]*inv[2]*e)%mod\n  r[2]=(r[2]-p[2]*inv[2]*e)%mod\n  return r\n\nadd(DP[-1][0][1][1],DP[-1][1][1][1])\nadd(DP[-1][0][1][0],DP[-1][1][1][0])\nadd(DP[-1][0][0][1],DP[-1][1][0][1])\nX=[f10(DP[-1][0][1][1],1,0),f10(DP[-1][0][1][0],0,1),f10(DP[-1][0][0][1],1,mod-1)]\nA=[sum(map(lambda x:x[i],X))%mod for i in range(3)]\nprint(*A)"
  },
  {
    "language": "Python",
    "code": "print(\"This contest is recommended for reds and very ambitious oranges.\")"
  },
  {
    "language": "Python",
    "code": "🤔"
  },
  {
    "language": "Python",
    "code": "from copy import *\nN=int(input())\nS=input()\nDP=[[[[0]*2 for i in range(2)] for j in range(2)] for k in range(N)]\nmod=10**9+7\nfor i in range(N):\n  for j in range(2):\n    for k in range(2):\n      for l in range(2):\n        DP[i][j][k][l]=[[],[],0]\nif S[0]=='X':\n  DP[0][0][1][0]=[[],[],1]\nelse:\n  DP[0][0][0][1]=[[],[],1]\n  DP[0][1][1][1]=[[1],[],mod-1]\ng1=[1,1]\ng2=[1,1]\ninv=[0,1]\nc=[1,2]\nfor i in range(2,N+5):\n  g1.append((g1[-1]*i)%mod)\n  inv.append((-inv[mod%i]*(mod//i))%mod)\n  g2.append((g2[-1]*inv[-1])%mod)\n  c.append((c[-1]+g2[i])%mod)\n\ndef add(x,y):\n  for j in range(2):\n    for i in range(len(y[j])-len(x[j])):\n      x[j].append(0)\n    for i in range(len(y[j])):\n      x[j][i]=(x[j][i]+y[j][i])%mod\n  x[2]=(x[2]+y[2])%mod\n\ndef integrate(p):\n  p[2]=-p[2]%mod\n  for j in range(2):\n    p[j].append(0)\n    for i in range(len(p[j])-2,-1,-1):\n      p[j][i+1]=p[j][i]*inv[i+1]%mod\n      p[j][i]=0\n\ndef fx0(p):\n  integrate(p)\n  p[0][0]=(p[0][0]-p[2])%mod\n\ndef f1x(p):\n  integrate(p)\n  for j in range(2):\n    for i in range(len(p[j])):\n      p[j][i]=-p[j][i]%mod\n  p[2]=-p[2]%mod\n  for i in range(2):\n    p[i][0]=-sum(p[i])%mod\n  p[1][0]=(p[1][0]-p[2])%mod\n\nfor i in range(N-1):\n  if S[i+1]=='X':\n    add(DP[i][1][1][0],DP[i][1][1][1])\n    fx0(DP[i][1][1][0])\n    add(DP[i][1][1][1],DP[i][1][0][1])\n    add(DP[i][1][1][1],DP[i][0][1][1])\n    add(DP[i][1][1][1],DP[i][0][0][1])\n    f1x(DP[i][1][1][1])\n    for j in range(2):\n      add(DP[i+1][0][1][0],DP[i][1][1][j])\n  else:\n    t=[[],[],0]\n    add(DP[i][0][1][0],DP[i][0][1][1])\n    add(DP[i][1][1][0],DP[i][1][1][1])\n    add(DP[i+1][1][1][1],DP[i][0][1][0])\n    fx0(DP[i+1][1][1][1])\n    add(t,DP[i][0][1][0])\n    add(t,DP[i][1][1][0])\n    f1x(t)\n    fx0(DP[i][1][1][0])\n    add(DP[i+1][0][0][1],DP[i][1][1][0])\n    add(DP[i+1][0][0][1],t)\n\ndef f10(p,o,e):\n  r=[0]*3\n  q=deepcopy(p)\n  integrate(q)\n  r[0]=(sum(q[0])-q[2])*o%mod\n  r[1]=(sum(q[1])+q[2])*o%mod\n  for j in range(2):\n    for i in range(len(p[j])):\n      r[j]=(r[j]+p[j][i]*g1[i]*e)%mod\n      r[j+1]=(r[j+1]-p[j][i]*g1[i]*c[i]*e)%mod\n  r[0]=(r[0]+p[2]*inv[2])%mod\n  r[2]=(r[2]-p[2]*inv[2])%mod\n  return r\n\nadd(DP[-1][0][1][1],DP[-1][1][1][1])\nadd(DP[-1][0][1][0],DP[-1][1][1][0])\nadd(DP[-1][0][0][1],DP[-1][1][0][1])\nX=[f10(DP[-1][0][1][1],1,0),f10(DP[-1][0][1][0],0,1),f10(DP[-1][0][0][1],1,mod-1)]\nA=[sum(map(lambda x:x[i],X))%mod for i in range(3)]\nprint(*A)"
  },
  {
    "language": "Python",
    "code": "#参考URL\n#https://qiita.com/ageprocpp/items/104c051b2ec2086f5a9b\n\nmod=10**9+7\ndef value(obj):\n    if type(obj)==modint:\n        tmp=obj.number\n    else:\n        tmp=obj\n    return tmp%mod\nclass modint():\n    number=0\n    def __init__(self,num):\n        self.number=num%mod\n    def __add__(self,other):\n        tmp=value(other)\n        return modint(self.number+tmp)\n    def __iadd__(self,other):\n        tmp=value(other)\n        self.number+=tmp\n        self.number%=mod\n        return self\n    def __sub__(self,other):\n        tmp=value(other)\n        return modint(self.number-tmp)\n    def __isub__(self,other):\n        tmp=value(other)\n        self.number-=tmp\n        self.number%=mod\n        return self\n    def __mul__(self,other):\n        tmp=value(other)\n        return modint(self.number*tmp)\n    def __imul__(self,other):\n        tmp=value(other)\n        self.number*=tmp\n        self.number%=mod\n        return self\n    def __truediv__(self,other):\n        tmp=value(other)\n        return self*pow(tmp,mod-2,mod)\n    def __itruediv(self,other):\n        tmp=value(other)\n        self.number=self/tmp\n        self.number%=mod\n        return self\n    def __repr__(self):\n        return str(self.number)\n    def __eq__(self,other):\n        return value(self)==value(other)\n    def __ne__(self,other):\n        return value(self)!=value(other)\n    def __str__(self):\n        return str(self.number)\n    def __int__(self):\n        return self.number\n    def __hash__(self):\n        return self.number\n\nclass polynomial():\n    sequence=[0]\n    def __init__(self,seq):\n        self.sequence=[]\n        for i in seq:\n            self.sequence.append(value(i))\n    def get(self,x):\n        res=modint(0)\n        tmp=modint(1)\n        for a in self.sequence:\n            res+=tmp*a\n            tmp*=x\n            if tmp==0:\n                break\n        return res\n    def __add__(self,other):\n        res=[]\n        for i,a in enumerate(self.sequence):\n            try:\n                res[i]=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]=a\n        for i,a in enumerate(other.sequence):\n            try:\n                res[i]+=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]+=a\n        \n        return polynomial(res)\n    def __iadd__(self,other):\n        return self+other\n    def __sub__(self,other):\n        res=[]\n        for i,a in enumerate(self.sequence):\n            try:\n                res[i]=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]=a\n        for i,a in enumerate(other.sequence):\n            try:\n                res[i]-=a\n            except IndexError:\n                res.append(modint(0))\n                res[i]-=a\n        return polynomial(res)\n    def __isub__(self,other):\n        return self-other\n    def indef_integral(self):\n        res=[modint(0)]\n        for i,a in enumerate(self.sequence):\n            res.append(modint(a)/(i+1))\n        return polynomial(res)\n    def integrate(self,flag):\n        #0: 0->x\n        #1:x->1\n        if flag==0:\n            return self.indef_integral()\n        else:\n            tmp=self.indef_integral()\n            return polynomial([tmp.get(1)])-tmp\n    def __repr__(self):\n        return str(self.sequence)\n    def __str__(self):\n        return str(self.sequence)\n\nclass func():\n    P=polynomial([modint(0)])\n    Q=polynomial([modint(0)])\n    C=modint(0)\n    def __init__(self,poly1,poly2,cnst):\n        self.P=poly1\n        self.Q=poly2\n        self.C=cnst\n    def __add__(self,other):\n        PP=self.P+other.P\n        QQ=self.Q+other.Q\n        CC=self.C+other.C\n        return func(PP,QQ,CC)\n    def __iadd__(self,other):\n        return self+other\n    def __sub__(self,other):\n        PP=self.P-other.P\n        QQ=self.Q-other.Q\n        CC=self.C-other.C\n        return func(PP,QQ,CC)\n    def __isub__(self,other):\n        return self-other\n    def dintegrate(self,flag):\n        if flag==0:\n            PP=self.P.integrate(0)+polynomial([self.C])\n            QQ=self.Q.integrate(0)\n            CC=modint(-1)*self.C\n        else:\n            PP=self.P.integrate(1)\n            QQ=self.Q.integrate(1)+polynomial([modint(-1)*self.C])\n            CC=self.C\n        return func(PP,QQ,CC)\nMAX_N=1009\nN=int(input())\ns=input()\nfact=[modint(0) for i in range(MAX_N+1)]\ninv=[modint(0) for i in range(MAX_N+1)]\nfact[0]=modint(1)\nfor i in range(MAX_N):\n    fact[i+1]=fact[i]*(i+1)\ninv[-1]=modint(1)/fact[-1]\nfor i in range(MAX_N-1,-1,-1):\n    inv[i]=inv[i+1]*(i+1)\ndp=[[[[func(polynomial([modint(0)]),polynomial([modint(0)]),modint(0)) for l in range(2)]for k in range(2)]for j in range(2)] for i in range(MAX_N+1)]\n\nif s[0]==\"X\":\n    dp[0][0][1][0]=func(polynomial([modint(0)]),polynomial([modint(0)]),modint(1))\nelse:\n    dp[0][0][0][1]=func(polynomial([modint(0)]),polynomial([modint(0)]),modint(1))\n    dp[0][1][1][1]=func(polynomial([modint(1)]),polynomial([modint(0)]),modint(-1))\nfor i in range(1,N):\n    if s[i]==\"X\":\n        dp[i][0][1][0]+=dp[i-1][1][1][0].dintegrate(0)\n        dp[i][0][1][0]+=dp[i-1][1][1][1].dintegrate(0)\n        dp[i][0][1][0]+=dp[i-1][0][0][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][0][1][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][1][0][1].dintegrate(1)\n        dp[i][0][1][0]+=dp[i-1][1][1][1].dintegrate(1)\n    else:\n        dp[i][0][0][1]+=dp[i-1][1][1][0].dintegrate(0)\n        dp[i][0][0][1]+=dp[i-1][1][1][1].dintegrate(0)\n        dp[i][1][1][1]+=dp[i-1][0][1][0].dintegrate(0)\n        dp[i][1][1][1]+=dp[i-1][0][1][1].dintegrate(0)\n        dp[i][0][0][1]+=dp[i-1][0][1][0].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][0][1][1].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][1][1][0].dintegrate(1)\n        dp[i][0][0][1]+=dp[i-1][1][1][1].dintegrate(1)\na=modint(0)\nb=modint(0)\nc=modint(0)\n\np = dp[N-1][0][1][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][0][1][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][0][1][1].C\nb-= dp[N-1][0][1][1].C\np = dp[N-1][1][1][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][1][1][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][1][1][1].C\nb-= dp[N-1][1][1][1].C\nfor x in range(2):\n    for i,v in enumerate(dp[N-1][x][1][0].P.sequence):\n        a+=modint(1)*v*fact[i]\n        for j in range(i+1):\n            b-=modint(1)*v*fact[i]*inv[j]\n    for i,v in enumerate(dp[N-1][x][1][0].Q.sequence):\n        b+=modint(1)*v*fact[i]\n        for j in range(i+1):\n            c-=modint(1)*v*fact[i]*inv[j]\n    a+=dp[N-1][x][1][0].C/2\n    c-=dp[N-1][x][1][0].C/2\n\np = dp[N-1][0][0][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][0][0][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][0][0][1].C\nb-= dp[N-1][0][0][1].C\np = dp[N-1][1][0][1].P.integrate(0)\na+= p.get(1)-p.get(0)\np = dp[N-1][1][0][1].Q.integrate(0)\nb+= p.get(1)-p.get(0)\na+= dp[N-1][1][0][1].C\nb-= dp[N-1][1][0][1].C\nfor x in range(2):\n    for i,v in enumerate(dp[N-1][x][0][1].P.sequence):\n        a-=modint(1)*v*fact[i]\n        for j in range(i+1):\n            b+=modint(1)*v*fact[i]*inv[j]\n    for i,v in enumerate(dp[N-1][x][0][1].Q.sequence):\n        b-=modint(1)*v*fact[i]\n        for j in range(i+1):\n            c+=modint(1)*v*fact[i]*inv[j]\n    a-=dp[N-1][x][0][1].C/2\n    c+=dp[N-1][x][0][1].C/2\n\nprint(a,b,c)\n\n            "
  }
]