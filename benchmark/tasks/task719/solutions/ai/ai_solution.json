[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int **graph = malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        graph[i] = malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            graph[i][j] = INT_MAX;\n        }\n        graph[i][i] = 0;\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int L, R, C;\n        scanf(\"%d %d %d\", &L, &R, &C);\n        L--; R--;\n        \n        for (int s = L; s < R; s++) {\n            for (int t = s + 1; t <= R; t++) {\n                graph[s][t] = MIN(graph[s][t], C);\n                graph[t][s] = graph[s][t];\n            }\n        }\n    }\n    \n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (graph[i][k] != INT_MAX && graph[k][j] != INT_MAX) {\n                    graph[i][j] = MIN(graph[i][j], graph[i][k] + graph[k][j]);\n                }\n            }\n        }\n    }\n    \n    int result = graph[0][N-1];\n    printf(\"%d\\n\", result == INT_MAX ? -1 : result);\n    \n    for (int i = 0; i < N; i++) {\n        free(graph[i]);\n    }\n    free(graph);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, c;\n} Edge;\n\ntypedef struct {\n    int v, cost;\n} Node;\n\ntypedef struct {\n    Node* heap;\n    int size, capacity;\n} PriorityQueue;\n\nPriorityQueue* createPriorityQueue(int capacity) {\n    PriorityQueue* pq = (PriorityQueue*)malloc(sizeof(PriorityQueue));\n    pq->heap = (Node*)malloc(capacity * sizeof(Node));\n    pq->size = 0;\n    pq->capacity = capacity;\n    return pq;\n}\n\nvoid swap(Node* a, Node* b) {\n    Node temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid push(PriorityQueue* pq, int v, int cost) {\n    if (pq->size == pq->capacity) return;\n    pq->heap[pq->size].v = v;\n    pq->heap[pq->size].cost = cost;\n    int i = pq->size;\n    pq->size++;\n    while (i > 0 && pq->heap[(i - 1) / 2].cost > pq->heap[i].cost) {\n        swap(&pq->heap[(i - 1) / 2], &pq->heap[i]);\n        i = (i - 1) / 2;\n    }\n}\n\nNode pop(PriorityQueue* pq) {\n    Node root = pq->heap[0];\n    pq->size--;\n    pq->heap[0] = pq->heap[pq->size];\n    int i = 0;\n    while (1) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int smallest = i;\n        if (left < pq->size && pq->heap[left].cost < pq->heap[smallest].cost)\n            smallest = left;\n        if (right < pq->size && pq->heap[right].cost < pq->heap[smallest].cost)\n            smallest = right;\n        if (smallest == i) break;\n        swap(&pq->heap[i], &pq->heap[smallest]);\n        i = smallest;\n    }\n    return root;\n}\n\nint isEmpty(PriorityQueue* pq) {\n    return pq->size == 0;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    Edge* edges = (Edge*)malloc(M * sizeof(Edge));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].c);\n    }\n\n    int* dist = (int*)malloc((N + 1) * sizeof(int));\n    for (int i = 1; i <= N; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[1] = 0;\n\n    PriorityQueue* pq = createPriorityQueue(N * M);\n    push(pq, 1, 0);\n\n    while (!isEmpty(pq)) {\n        Node node = pop(pq);\n        int u = node.v;\n        if (u == N) break;\n        if (node.cost > dist[u]) continue;\n        for (int i = 0; i < M; i++) {\n            if (edges[i].u <= u && u < edges[i].v) {\n                int v = edges[i].v;\n                int new_dist = dist[u] + edges[i].c;\n                if (new_dist < dist[v]) {\n                    dist[v] = new_dist;\n                    push(pq, v, new_dist);\n                }\n            }\n        }\n    }\n\n    if (dist[N] == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", dist[N]);\n    }\n\n    free(edges);\n    free(dist);\n    free(pq->heap);\n    free(pq);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n};\n\nstruct Node {\n    int id;\n    long long dist;\n    Node(int i, long long d) : id(i), dist(d) {}\n    bool operator>(const Node& other) const {\n        return dist > other.dist;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<Edge>> adj(N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int L, R, C;\n        cin >> L >> R >> C;\n        adj[L].emplace_back(R, C);\n    }\n    \n    for (int i = 1; i < N; ++i) {\n        adj[i+1].emplace_back(i, 0);\n    }\n    \n    vector<long long> dist(N + 1, LLONG_MAX);\n    dist[1] = 0;\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n    pq.emplace(1, 0);\n    \n    while (!pq.empty()) {\n        Node node = pq.top();\n        pq.pop();\n        int u = node.id;\n        if (u == N) break;\n        if (dist[u] < node.dist) continue;\n        \n        for (const Edge& e : adj[u]) {\n            int v = e.to;\n            long long new_dist = dist[u] + e.cost;\n            if (new_dist < dist[v]) {\n                dist[v] = new_dist;\n                pq.emplace(v, new_dist);\n            }\n        }\n    }\n    \n    if (dist[N] == LLONG_MAX) {\n        cout << -1 << endl;\n    } else {\n        cout << dist[N] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int to;\n    int cost;\n\n    Edge(int to, int cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int L = sc.nextInt();\n            int R = sc.nextInt();\n            int C = sc.nextInt();\n            adj.get(L).add(new Edge(R, C));\n        }\n\n        for (int i = 1; i < N; i++) {\n            adj.get(i + 1).add(new Edge(i, 0));\n        }\n\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\n        long[] dist = new long[N + 1];\n        Arrays.fill(dist, Long.MAX_VALUE);\n        dist[1] = 0;\n        pq.add(new Edge(1, 0));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int u = current.to;\n            if (dist[u] < current.cost) continue;\n\n            for (Edge e : adj.get(u)) {\n                int v = e.to;\n                long newDist = dist[u] + e.cost;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.add(new Edge(v, (int) newDist));\n                }\n            }\n        }\n\n        if (dist[N] == Long.MAX_VALUE) {\n            System.out.println(-1);\n        } else {\n            System.out.println(dist[N]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:42:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int shortestPath(int N, int M, int[] L, int[] R, int[] C) {\n        // Initialize graph using adjacency list\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Add edges for each operation\n        for (int i = 0; i < M; i++) {\n            for (int s = L[i] - 1; s < R[i] - 1; s++) {\n                for (int t = s + 1; t < R[i]; t++) {\n                    graph.get(s).add(new Edge(t, C[i]));\n                    graph.get(t).add(new Edge(s, C[i]));\n                }\n            }\n        }\n\n        // Dijkstra's algorithm\n        int[] dist = new int[N];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance);\n        pq.offer(new Node(0, 0));\n\n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int u = current.vertex;\n            int d = current.distance;\n\n            if (d > dist[u]) continue;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = d + edge.weight;\n\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new Node(v, newDist));\n                }\n            }\n        }\n\n        return dist[N - 1] == Integer.MAX_VALUE ? -1 : dist[N - 1];\n    }\n\n    static class Edge {\n        int to, weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    static class Node {\n        int vertex, distance;\n        Node(int vertex, int distance) {\n            this.vertex = vertex;\n            this.distance = distance;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:42:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nconst long long INF = 1e18;\n\nclass Solution {\npublic:\n    int shortestPath(int N, int M, vector<int>& L, vector<int>& R, vector<int>& C) {\n        vector<vector<pair<int, long long>>> graph(N + 1);\n        \n        // Add edges based on operations\n        for (int i = 0; i < M; i++) {\n            for (int s = L[i]; s <= R[i]; s++) {\n                for (int t = s + 1; t <= R[i]; t++) {\n                    graph[s].push_back({t, C[i]});\n                    graph[t].push_back({s, C[i]});\n                }\n            }\n        }\n        \n        // Dijkstra's algorithm\n        vector<long long> dist(N + 1, INF);\n        dist[1] = 0;\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n        pq.push({0, 1});\n        \n        while (!pq.empty()) {\n            auto [currDist, curr] = pq.top();\n            pq.pop();\n            \n            if (currDist > dist[curr]) continue;\n            \n            for (auto [next, edgeLen] : graph[curr]) {\n                if (dist[curr] + edgeLen < dist[next]) {\n                    dist[next] = dist[curr] + edgeLen;\n                    pq.push({dist[next], next});\n                }\n            }\n        }\n        \n        return dist[N] == INF ? -1 : dist[N];\n    }\n};",
    "timestamp": "2025-08-05 22:43:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve(N, M, operations):\n    # Initialize graph\n    graph = {i: [] for i in range(1, N + 1)}\n\n    # Add edges according to operations\n    for L_i, R_i, C_i in operations:\n        for s in range(L_i, R_i):\n            for t in range(s + 1, R_i + 1):\n                graph[s].append((t, C_i))\n                graph[t].append((s, C_i))\n\n    # Dijkstra's algorithm for shortest path from Vertex 1 to Vertex N\n    pq = [(0, 1)]  # (cost, Vertex)\n    distances = {i: float('inf') for i in range(1, N + 1)}\n    distances[1] = 0\n\n    while pq:\n        current_cost, current_vertex = heapq.heappop(pq)\n\n        if current_vertex == N:\n            return current_cost\n\n        if current_cost > distances[current_vertex]:\n            continue\n\n        for neighbor, cost in graph[current_vertex]:\n            new_cost = current_cost + cost\n            if new_cost < distances[neighbor]:\n                distances[neighbor] = new_cost\n                heapq.heappush(pq, (new_cost, neighbor))\n\n    return -1 if distances[N] == float('inf') else distances[N]\n\n# Example usage\nN = 5\nM = 3\noperations = [(1, 3, 2), (2, 4, 1), (3, 5, 3)]\nprint(solve(N, M, operations))  # Output: Length of shortest path or -1 if no path",
    "timestamp": "2025-08-13 12:10:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ShortestPathInGraph {\n\n    static class Edge {\n        int target;\n        int cost;\n\n        Edge(int target, int cost) {\n            this.target = target;\n            this.cost = cost;\n        }\n    }\n\n    public static int shortestPath(int N, int M, int[][] operations) {\n        List<Edge>[] graph = new ArrayList[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int[] op : operations) {\n            int L = op[0], R = op[1], C = op[2];\n            for (int s = L; s < R; s++) {\n                for (int t = s + 1; t <= R; t++) {\n                    graph[s].add(new Edge(t, C));\n                    graph[t].add(new Edge(s, C)); // Since the graph is undirected\n                }\n            }\n        }\n\n        return dijkstra(N, graph, 1, N);\n    }\n\n    private static int dijkstra(int N, List<Edge>[] graph, int start, int end) {\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.cost));\n        pq.add(new Edge(start, 0));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int v = current.target;\n            int d = current.cost;\n\n            if (d > dist[v]) continue;\n\n            for (Edge edge : graph[v]) {\n                int to = edge.target;\n                int len = edge.cost;\n\n                if (dist[v] + len < dist[to]) {\n                    dist[to] = dist[v] + len;\n                    pq.add(new Edge(to, dist[to]));\n                }\n            }\n        }\n\n        return dist[end] == Integer.MAX_VALUE ? -1 : dist[end];\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int M = 2;\n        int[][] operations = {\n            {1, 3, 1},\n            {2, 5, 2}\n        };\n\n        System.out.println(shortestPath(N, M, operations)); // Output the shortest path from Vertex 1 to Vertex N\n    }\n}",
    "timestamp": "2025-08-13 12:10:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define MAX_M 4000\n#define INF INT_MAX\n\ntypedef struct {\n    int u, v, cost;\n} Edge;\n\nEdge edges[MAX_M * MAX_N];\nint dist[MAX_N + 1];\nint N, M;\n\nvoid bellman_ford() {\n    dist[1] = 0;\n    for (int i = 2; i <= N; i++) dist[i] = INF;\n\n    for (int i = 1; i <= N - 1; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (dist[edges[j].u] != INF && dist[edges[j].u] + edges[j].cost < dist[edges[j].v]) {\n                dist[edges[j].v] = dist[edges[j].u] + edges[j].cost;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    int edge_count = 0;\n    for (int i = 0; i < M; ++i) {\n        int L, R, C;\n        scanf(\"%d %d %d\", &L, &R, &C);\n        for (int s = L; s <= R; ++s) {\n            for (int t = s + 1; t <= R; ++t) {\n                edges[edge_count++] = (Edge){s, t, C};\n            }\n        }\n    }\n\n    bellman_ford();\n\n    if (dist[N] == INF) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", dist[N]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:11:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestPath(N, M, operations) {\n    const edges = [];\n    for (let i = 0; i < M; i++) {\n        const [L, R, C] = operations[i];\n        for (let s = L; s < R; s++) {\n            for (let t = s + 1; t <= R; t++) {\n                edges.push([s, t, C]);\n            }\n        }\n    }\n\n    const dist = Array(N + 1).fill(Infinity);\n    dist[1] = 0;\n\n    for (let i = 0; i < N - 1; i++) {\n        for (let [u, v, w] of edges) {\n            if (dist[u] !== Infinity) {\n                dist[v] = Math.min(dist[v], dist[u] + w);\n            }\n        }\n    }\n\n    return dist[N] === Infinity ? -1 : dist[N];\n}\n\n// Example usage:\n// N = number of vertices (e.g., 5)\n// M = number of operations (e.g., 3)\n// operations = array of operations (e.g., [[1, 3, 2], [2, 5, 3], [3, 5, 1]])\n// console.log(shortestPath(N, M, operations));",
    "timestamp": "2025-08-13 12:11:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\n\ndef solve(N, M, L, R, C):\n    graph = [[] for _ in range(N+1)]\n    \n    # Add edges based on operations\n    for l, r, c in zip(L, R, C):\n        for s in range(l, r):\n            for t in range(s+1, r+1):\n                graph[s].append((t, c))\n                graph[t].append((s, c))\n    \n    # Dijkstra's algorithm\n    dist = [float('inf')] * (N+1)\n    dist[1] = 0\n    pq = [(0, 1)]\n    \n    while pq:\n        curr_dist, curr_node = heappop(pq)\n        \n        if curr_node == N:\n            return curr_dist\n        \n        if curr_dist > dist[curr_node]:\n            continue\n        \n        for next_node, edge_cost in graph[curr_node]:\n            new_dist = curr_dist + edge_cost\n            if new_dist < dist[next_node]:\n                dist[next_node] = new_dist\n                heappush(pq, (new_dist, next_node))\n    \n    return -1",
    "timestamp": "2025-08-13 12:11:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function shortestPath(N, M, operations) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const dist = Array(N + 1).fill(Infinity);\n    \n    for (const [L, R, C] of operations) {\n        for (let s = L; s <= R; s++) {\n            for (let t = s + 1; t <= R; t++) {\n                graph[s].push([t, C]);\n                graph[t].push([s, C]);\n            }\n        }\n    }\n    \n    const pq = [[1, 0]];\n    dist[1] = 0;\n    \n    while (pq.length) {\n        pq.sort((a, b) => a[1] - b[1]);\n        const [curr, currDist] = pq.shift();\n        \n        if (currDist > dist[curr]) continue;\n        \n        for (const [next, edgeLength] of graph[curr]) {\n            const newDist = currDist + edgeLength;\n            \n            if (newDist < dist[next]) {\n                dist[next] = newDist;\n                pq.push([next, newDist]);\n            }\n        }\n    }\n    \n    return dist[N] === Infinity ? -1 : dist[N];\n}",
    "timestamp": "2025-08-13 12:11:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    intervals = []\n    for _ in range(M):\n        L = int(data[idx])\n        idx += 1\n        R = int(data[idx])\n        idx += 1\n        C = int(data[idx])\n        idx += 1\n        intervals.append((L, R, C))\n    \n    # Sort intervals by L\n    intervals.sort()\n    \n    INF = 1 << 60\n    dist = [INF] * (N + 2)\n    dist[1] = 0\n    \n    heap = []\n    heapq.heappush(heap, (0, 1))\n    \n    ptr = 0\n    for L, R, C in intervals:\n        while heap and heap[0][1] < L:\n            heapq.heappop(heap)\n        \n        if not heap:\n            break\n        \n        current_dist, u = heap[0]\n        if u > R:\n            continue\n        \n        new_dist = current_dist + C\n        if new_dist < dist[R]:\n            dist[R] = new_dist\n            heapq.heappush(heap, (new_dist, R))\n    \n    if dist[N] == INF:\n        print(-1)\n    else:\n        print(dist[N])\n\nsolve()",
    "timestamp": "2025-08-13 12:11:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const operations = [];\n    for (let i = 1; i <= M; i++) {\n        const [L, R, C] = input[i].split(' ').map(Number);\n        operations.push({ L, R, C });\n    }\n\n    // Sort operations by C in ascending order\n    operations.sort((a, b) => a.C - b.C);\n\n    const parent = new Array(N + 2).fill(-1);\n    const find = (u) => {\n        if (parent[u] < 0) return u;\n        parent[u] = find(parent[u]);\n        return parent[u];\n    };\n    const unite = (u, v) => {\n        u = find(u);\n        v = find(v);\n        if (u === v) return false;\n        if (parent[u] > parent[v]) [u, v] = [v, u];\n        parent[u] += parent[v];\n        parent[v] = u;\n        return true;\n    };\n\n    const adj = new Array(N + 1).fill().map(() => []);\n    for (const { L, R, C } of operations) {\n        let current = find(L);\n        while (current <= R) {\n            if (current > N) break;\n            if (current > L) {\n                adj[current - 1].push([current, C]);\n                adj[current].push([current - 1, C]);\n            }\n            unite(current, current + 1);\n            current = find(current);\n        }\n    }\n\n    const INF = 1e18;\n    const dist = new Array(N + 1).fill(INF);\n    const heap = [];\n    const pushHeap = (d, u) => {\n        heap.push([d, u]);\n        let i = heap.length - 1;\n        while (i > 0) {\n            const p = Math.floor((i - 1) / 2);\n            if (heap[p][0] <= heap[i][0]) break;\n            [heap[p], heap[i]] = [heap[i], heap[p]];\n            i = p;\n        }\n    };\n    const popHeap = () => {\n        if (heap.length === 0) return null;\n        const min = heap[0];\n        const last = heap.pop();\n        if (heap.length > 0) {\n            heap[0] = last;\n            let i = 0;\n            while (true) {\n                const left = 2 * i + 1;\n                const right = 2 * i + 2;\n                let smallest = i;\n                if (left < heap.length && heap[left][0] < heap[smallest][0]) smallest = left;\n                if (right < heap.length && heap[right][0] < heap[smallest][0]) smallest = right;\n                if (smallest === i) break;\n                [heap[i], heap[smallest]] = [heap[smallest], heap[i]];\n                i = smallest;\n            }\n        }\n        return min;\n    };\n\n    dist[1] = 0;\n    pushHeap(0, 1);\n    while (heap.length > 0) {\n        const [d, u] = popHeap();\n        if (u === N) break;\n        if (d > dist[u]) continue;\n        for (const [v, c] of adj[u]) {\n            if (dist[v] > dist[u] + c) {\n                dist[v] = dist[u] + c;\n                pushHeap(dist[v], v);\n            }\n        }\n    }\n\n    console.log(dist[N] === INF ? -1 : dist[N]);\n};\n\nsolve();",
    "timestamp": "2025-08-13 12:11:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    long long cost;\n};\n\nconst long long INF = numeric_limits<long long>::max();\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<Edge>> graph(N + 1);\n    \n    for (int i = 0; i < M; ++i) {\n        int L, R, C;\n        cin >> L >> R >> C;\n        for (int s = L; s < R; ++s) {\n            for (int t = s + 1; t <= R; ++t) {\n                graph[s].push_back({t, C});\n                graph[t].push_back({s, C});  // Since the graph is undirected\n            }\n        }\n    }\n    \n    // Dijkstra's algorithm to find the shortest path from Vertex 1 to Vertex N\n    vector<long long> dist(N + 1, INF);\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    \n    dist[1] = 0;\n    pq.push({0, 1});\n    \n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n        \n        if (d > dist[u]) continue;\n        \n        for (const auto& edge : graph[u]) {\n            int v = edge.to;\n            long long cost = edge.cost;\n            if (dist[u] + cost < dist[v]) {\n                dist[v] = dist[u] + cost;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    \n    cout << (dist[N] == INF ? -1 : dist[N]) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:33:37"
  }
]