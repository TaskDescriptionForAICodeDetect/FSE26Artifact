[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_HOLES 1000\n#define MAX_SAMPLES 1000000\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\nint main() {\n    int N;\n    double R;\n    Point holes[MAX_HOLES];\n    \n    scanf(\"%d %lf\", &N, &R);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &holes[i].x, &holes[i].y);\n    }\n    \n    int total_valid_points = 0;\n    int hole_counts[MAX_HOLES] = {0};\n    \n    for (int sample = 0; sample < MAX_SAMPLES; sample++) {\n        double x = (2.0 * rand() / RAND_MAX - 1.0) * R;\n        double y = (2.0 * rand() / RAND_MAX - 1.0) * R;\n        \n        if (x * x + y * y > R * R) {\n            continue;\n        }\n        \n        total_valid_points++;\n        Point curr_point = {x, y};\n        \n        int nearest_hole = 0;\n        double min_distance = distance(curr_point, holes[0]);\n        \n        for (int j = 1; j < N; j++) {\n            double curr_distance = distance(curr_point, holes[j]);\n            if (curr_distance < min_distance || \n                (curr_distance == min_distance && j < nearest_hole)) {\n                min_distance = curr_distance;\n                nearest_hole = j;\n            }\n        }\n        \n        hole_counts[nearest_hole]++;\n    }\n    \n    for (int i = 0; i < N; i++) {\n        printf(\"%.6lf\\n\", (double)hole_counts[i] / total_valid_points);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y;\n    int index;\n} Hole;\n\nint compare(const void *a, const void *b) {\n    Hole *holeA = (Hole *)a;\n    Hole *holeB = (Hole *)b;\n    double distA = holeA->x * holeA->x + holeA->y * holeA->y;\n    double distB = holeB->x * holeB->x + holeB->y * holeB->y;\n    if (distA < distB) return -1;\n    if (distA > distB) return 1;\n    if (holeA->index < holeB->index) return -1;\n    return 1;\n}\n\nint main() {\n    int N;\n    double R;\n    scanf(\"%d %lf\", &N, &R);\n    Hole *holes = (Hole *)malloc(N * sizeof(Hole));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &holes[i].x, &holes[i].y);\n        holes[i].index = i;\n    }\n\n    qsort(holes, N, sizeof(Hole), compare);\n\n    double *prob = (double *)calloc(N, sizeof(double));\n    if (N == 1) {\n        prob[0] = 1.0;\n    } else {\n        double total_area = M_PI * R * R;\n        double prev_dist = 0.0;\n        for (int i = 0; i < N; i++) {\n            double dist = holes[i].x * holes[i].x + holes[i].y * holes[i].y;\n            double next_dist = (i < N - 1) ? (holes[i+1].x * holes[i+1].x + holes[i+1].y * holes[i+1].y) : R * R;\n            double area = M_PI * (next_dist - dist);\n            prob[holes[i].index] = area / total_area;\n            prev_dist = next_dist;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%.10lf\\n\", prob[i]);\n    }\n\n    free(holes);\n    free(prob);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int N;\n    double R;\n    cin >> N >> R;\n\n    vector<double> x(N), y(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    vector<double> prob(N, 0.0);\n\n    if (N == 1) {\n        cout << fixed << setprecision(10) << 1.0 << endl;\n        return 0;\n    }\n\n    const int samples = 1000000;\n    for (int s = 0; s < samples; ++s) {\n        double theta = 2.0 * M_PI * rand() / RAND_MAX;\n        double r = R * sqrt(rand() / (double)RAND_MAX);\n        double px = r * cos(theta);\n        double py = r * sin(theta);\n\n        int nearest = 0;\n        double min_dist = hypot(px - x[0], py - y[0]);\n        for (int i = 1; i < N; ++i) {\n            double dist = hypot(px - x[i], py - y[i]);\n            if (dist < min_dist || (dist == min_dist && i < nearest)) {\n                min_dist = dist;\n                nearest = i;\n            }\n        }\n        prob[nearest] += 1.0;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        prob[i] /= samples;\n        cout << fixed << setprecision(10) << prob[i] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class HoleProbability {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        double R = scanner.nextDouble();\n        double[] x = new double[N];\n        double[] y = new double[N];\n        \n        for (int i = 0; i < N; i++) {\n            x[i] = scanner.nextDouble();\n            y[i] = scanner.nextDouble();\n        }\n        \n        double[] prob = new double[N];\n        int samples = 1000000;\n        int insideCircle = 0;\n        \n        for (int k = 0; k < samples; k++) {\n            double px = (2 * Math.random() - 1) * R;\n            double py = (2 * Math.random() - 1) * R;\n            if (px * px + py * py > R * R) {\n                continue;\n            }\n            insideCircle++;\n            \n            int closest = 0;\n            double minDist = Double.MAX_VALUE;\n            for (int i = 0; i < N; i++) {\n                double dx = px - x[i];\n                double dy = py - y[i];\n                double dist = dx * dx + dy * dy;\n                if (dist < minDist) {\n                    minDist = dist;\n                    closest = i;\n                } else if (dist == minDist && i < closest) {\n                    closest = i;\n                }\n            }\n            prob[closest]++;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            prob[i] /= insideCircle;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            System.out.printf(\"%.6f\\n\", prob[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:10:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class CircleHolesProbability {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        String[] firstLine = br.readLine().split(\" \");\n        int N = Integer.parseInt(firstLine[0]);\n        int R = Integer.parseInt(firstLine[1]);\n        \n        double[][] holes = new double[N][2];\n        for (int i = 0; i < N; i++) {\n            String[] holeCoords = br.readLine().split(\" \");\n            holes[i][0] = Double.parseDouble(holeCoords[0]);\n            holes[i][1] = Double.parseDouble(holeCoords[1]);\n        }\n        \n        double[] probabilities = new double[N];\n        int totalValidPoints = 0;\n        \n        for (int x = -R; x <= R; x++) {\n            for (int y = -R; y <= R; y++) {\n                if (x * x + y * y <= R * R) {\n                    int nearestHole = findNearestHole(x, y, holes);\n                    probabilities[nearestHole]++;\n                    totalValidPoints++;\n                }\n            }\n        }\n        \n        for (int i = 0; i < N; i++) {\n            pw.printf(\"%.10f\\n\", probabilities[i] / totalValidPoints);\n        }\n        \n        pw.close();\n    }\n    \n    private static int findNearestHole(int x, int y, double[][] holes) {\n        double minDistance = Double.MAX_VALUE;\n        int nearestHoleIndex = 0;\n        \n        for (int i = 0; i < holes.length; i++) {\n            double distance = Math.sqrt(\n                Math.pow(x - holes[i][0], 2) + Math.pow(y - holes[i][1], 2)\n            );\n            \n            if (distance < minDistance || \n                (distance == minDistance && i < nearestHoleIndex)) {\n                minDistance = distance;\n                nearestHoleIndex = i;\n            }\n        }\n        \n        return nearestHoleIndex;\n    }\n}",
    "timestamp": "2025-08-05 23:10:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    int x, y, index;\n};\n\ndouble dist(int x1, int y1, int x2, int y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main() {\n    int N;\n    double R;\n    cin >> N >> R;\n    \n    vector<Point> holes(N);\n    for (int i = 0; i < N; i++) {\n        cin >> holes[i].x >> holes[i].y;\n        holes[i].index = i;\n    }\n    \n    vector<double> probabilities(N, 0);\n    \n    int total_points = 0;\n    for (int x = -R; x <= R; x++) {\n        for (int y = -R; y <= R; y++) {\n            if (x * x + y * y > R * R) continue;\n            \n            total_points++;\n            \n            int min_hole = 0;\n            double min_distance = dist(x, y, holes[0].x, holes[0].y);\n            \n            for (int i = 1; i < N; i++) {\n                double curr_dist = dist(x, y, holes[i].x, holes[i].y);\n                if (curr_dist < min_distance - EPS || \n                    (abs(curr_dist - min_distance) < EPS && holes[i].index < holes[min_hole].index)) {\n                    min_hole = i;\n                    min_distance = curr_dist;\n                }\n            }\n            \n            probabilities[min_hole]++;\n        }\n    }\n    \n    cout << fixed << setprecision(6);\n    for (int i = 0; i < N; i++) {\n        cout << probabilities[i] / total_points << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom scipy.integrate import dblquad\n\ndef probability_of_holes(holes, R):\n    def pdf(x, y):\n        return 1 / (math.pi * R * R)\n    \n    def closest_hole_index(x, y):\n        min_dist = float('inf')\n        min_index = -1\n        for i, (hx, hy) in enumerate(holes):\n            dist = (x - hx) ** 2 + (y - hy) ** 2\n            if dist < min_dist or (dist == min_dist and i < min_index):\n                min_dist = dist\n                min_index = i\n        return min_index\n\n    def integrand(x, y, i):\n        return pdf(x, y) if closest_hole_index(x, y) == i else 0\n\n    probabilities = []\n    for i in range(len(holes)):\n        prob, _ = dblquad(integrand, -R, R,\n                          lambda x: -math.sqrt(R*R - x*x),\n                          lambda x: math.sqrt(R*R - x*x),\n                          args=(i,))\n        probabilities.append(prob)\n        \n    return probabilities\n\n# Example usage:\nN = 3\nholes = [(0, 0), (2, 0), (0, 2)]\nR = 10**6\nprobability = probability_of_holes(holes, R)\nprint(probability)",
    "timestamp": "2025-08-13 13:51:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SnukeHoles {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read the number of holes N\n        int N = sc.nextInt();\n        \n        // Read the radius R\n        double R = sc.nextDouble();\n        \n        // Array to store the coordinates of the holes\n        double[][] holes = new double[N][2];\n        \n        for (int i = 0; i < N; i++) {\n            holes[i][0] = sc.nextDouble();  // x-coordinate\n            holes[i][1] = sc.nextDouble();  // y-coordinate\n        }\n\n        double[] probabilities = new double[N];\n        int numSamples = 1000000;\n        \n        for (int i = 0; i < numSamples; i++) {\n            double x, y;\n            do {\n                x = (Math.random() * 2 * R) - R;\n                y = (Math.random() * 2 * R) - R;\n            } while (x * x + y * y > R * R);\n            \n            int nearestHole = findNearestHole(x, y, holes);\n            probabilities[nearestHole]++;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            probabilities[i] /= numSamples;\n            System.out.printf(\"%.10f%n\", probabilities[i]);\n        }\n    }\n\n    private static int findNearestHole(double x, double y, double[][] holes) {\n        int index = 0;\n        double minDistance = Double.MAX_VALUE;\n        \n        for (int i = 0; i < holes.length; i++) {\n            double dx = holes[i][0] - x;\n            double dy = holes[i][1] - y;\n            double distance = dx * dx + dy * dy;\n            \n            if (distance < minDistance) {\n                minDistance = distance;\n                index = i;\n            }\n        }\n        \n        return index;\n    }\n}",
    "timestamp": "2025-08-13 13:51:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Hole;\n\ndouble distance(double x1, double y1, int x2, int y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint findNearestHole(double x, double y, Hole holes[], int n) {\n    int nearest = 0;\n    double minDist = distance(x, y, holes[0].x, holes[0].y);\n    \n    for (int i = 1; i < n; ++i) {\n        double dist = distance(x, y, holes[i].x, holes[i].y);\n        if (dist < minDist || (dist == minDist && i < nearest)) {\n            nearest = i;\n            minDist = dist;\n        }\n    }\n\n    return nearest;\n}\n\nvoid simulate(int n, Hole holes[], double probabilities[], long num_samples, double R) {\n    for (long i = 0; i < num_samples; ++i) {\n        double x, y;\n        do {\n            x = ((double)rand() / RAND_MAX) * 2 * R - R;\n            y = ((double)rand() / RAND_MAX) * 2 * R - R;\n        } while (x * x + y * y > R * R);\n\n        int idx = findNearestHole(x, y, holes, n);\n        probabilities[idx] += 1.0;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        probabilities[i] /= num_samples;\n    }\n}\n\nint main() {\n    int N;\n    double R;\n    long num_samples = 10000000;\n\n    scanf(\"%d %lf\", &N, &R);\n    \n    Hole *holes = (Hole *)malloc(N * sizeof(Hole));\n    double *probabilities = (double *)calloc(N, sizeof(double));\n\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &holes[i].x, &holes[i].y);\n    }\n\n    simulate(N, holes, probabilities, num_samples, R);\n\n    for (int i = 0; i < N; ++i) {\n        printf(\"%.5f\\n\", probabilities[i]);\n    }\n\n    free(holes);\n    free(probabilities);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:51:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nconst int SAMPLE_POINTS = 1000000; // Increase for better precision\n\nstruct Point {\n    double x, y;\n};\n\ndouble square(double a) {\n    return a * a;\n}\n\ndouble euclideanDistance(const Point& a, const Point& b) {\n    return sqrt(square(a.x - b.x) + square(a.y - b.y));\n}\n\nPoint randomPointInCircle(double R) {\n    double x, y;\n    do {\n        x = ((double)rand() / RAND_MAX) * (2 * R) - R;\n        y = ((double)rand() / RAND_MAX) * (2 * R) - R;\n    } while (square(x) + square(y) > square(R));\n    return {x, y};\n}\n\nstd::vector<double> probabilityHoles(int N, const std::vector<Point>& holes, double R) {\n    std::vector<int> falls(N, 0);\n\n    for (int i = 0; i < SAMPLE_POINTS; i++) {\n        Point randomPoint = randomPointInCircle(R);\n        double minDistance = std::numeric_limits<double>::max();\n        int chosenHole = -1;\n\n        for (int j = 0; j < N; j++) {\n            double dist = euclideanDistance(randomPoint, holes[j]);\n            if (dist < minDistance || (dist == minDistance && j < chosenHole)) {\n                minDistance = dist;\n                chosenHole = j;\n            }\n        }\n        falls[chosenHole]++;\n    }\n\n    std::vector<double> probabilities(N);\n    for (int i = 0; i < N; i++) {\n        probabilities[i] = (double)falls[i] / SAMPLE_POINTS;\n    }\n\n    return probabilities;\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<Point> holes(N);\n    for (int i = 0; i < N; i++) {\n        std::cin >> holes[i].x >> holes[i].y;\n    }\n    \n    double R;\n    std::cin >> R;\n\n    std::vector<double> probabilities = probabilityHoles(N, holes, R);\n    std::cout << std::fixed << std::setprecision(10);\n    for (const double& prob : probabilities) {\n        std::cout << prob << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:51:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve(holes, R):\n    n = len(holes)\n    total_points = 0\n    hole_points = [0] * n\n    \n    # Iterate through points in the circle\n    for x in range(int(-R), int(R)+1):\n        for y in range(int(-R), int(R)+1):\n            # Check if point is inside the circle\n            if x*x + y*y <= R*R:\n                total_points += 1\n                \n                # Find nearest hole\n                min_dist = float('inf')\n                nearest_hole = 0\n                \n                for i in range(n):\n                    dist = math.sqrt((x-holes[i][0])**2 + (y-holes[i][1])**2)\n                    \n                    # Update nearest hole \n                    if dist < min_dist or (dist == min_dist and i < nearest_hole):\n                        min_dist = dist\n                        nearest_hole = i\n                \n                hole_points[nearest_hole] += 1\n    \n    # Calculate probabilities\n    probabilities = [points/total_points for points in hole_points]\n    \n    return probabilities\n\n# Input processing\ndef main():\n    N, R = map(int, input().split())\n    holes = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        holes.append((x, y))\n    \n    result = solve(holes, R)\n    \n    for prob in result:\n        print(f\"{prob:.10f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:52:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    R = float(input[ptr])\n    ptr += 1\n    \n    holes = []\n    for i in range(N):\n        x = float(input[ptr])\n        y = float(input[ptr+1])\n        ptr += 2\n        holes.append((x, y, i))\n    \n    if N == 1:\n        print(1.0)\n        return\n    \n    # Compute Voronoi diagram areas\n    # Since R is very large, we approximate by considering the entire plane\n    # The probability is the area of the Voronoi cell / (pi R^2)\n    # But for large R, the area outside the circle is negligible\n    \n    events = []\n    for i in range(N):\n        xi, yi, idx_i = holes[i]\n        for j in range(i+1, N):\n            xj, yj, idx_j = holes[j]\n            if xi == xj and yi == yj:\n                continue  # same point, but i < j, so i is preferred\n            # Compute the perpendicular bisector\n            mid_x = (xi + xj) / 2.0\n            mid_y = (yi + yj) / 2.0\n            dx = xj - xi\n            dy = yj - yi\n            # The bisector is dx*(x - mid_x) + dy*(y - mid_y) = 0\n            # Which is dx*x + dy*y = dx*mid_x + dy*mid_y\n            # For the Voronoi edge between i and j\n            # We need to find the angle ranges where i is better than j\n            # The bisector is a line, and we need to find the side where i is better\n            # The side is (xi, yi) is on the side where dx*(x - mid_x) + dy*(y - mid_y) < 0\n            # So for a point (x, y), if dx*(x - mid_x) + dy*(y - mid_y) < 0, then i is better\n            # The angle of the bisector is atan2(-dx, dy) (normal vector (dy, -dx))\n            angle = math.atan2(-dx, dy)\n            # The angle of the direction pointing towards i's side\n            # Check a point slightly towards i's side\n            test_x = mid_x - dy * 1e-5\n            test_y = mid_y + dx * 1e-5\n            val = dx * (test_x - mid_x) + dy * (test_y - mid_y)\n            if val < 0:\n                # This is i's side\n                start_angle = angle - math.pi/2\n                end_angle = angle + math.pi/2\n            else:\n                start_angle = angle + math.pi/2\n                end_angle = angle + 3*math.pi/2\n            \n            start_angle = start_angle % (2*math.pi)\n            end_angle = end_angle % (2*math.pi)\n            \n            events.append((start_angle, 1, i, j))\n            events.append((end_angle, -1, i, j))\n    \n    # Sort events\n    events.sort()\n    \n    # Initialize active segments\n    active = set()\n    res = [0.0] * N\n    prev_angle = 0.0\n    \n    # Add a full circle sweep\n    events.append((2*math.pi, 0, -1, -1))\n    \n    for event in events:\n        current_angle = event[0]\n        delta = event[1]\n        i = event[2]\n        j = event[3]\n        \n        if current_angle > prev_angle:\n            # Process the interval [prev_angle, current_angle]\n            if not active:\n                # No constraints, the entire plane is for the closest point\n                # But since R is large, all points are inside the circle\n                # So the closest is the one with minimal distance to origin\n                min_dist = float('inf')\n                best_i = -1\n                for k in range(N):\n                    xk, yk, idx_k = holes[k]\n                    dist = xk*xk + yk*yk\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_i = k\n                    elif dist == min_dist:\n                        if k < best_i:\n                            best_i = k\n                if best_i != -1:\n                    area = (current_angle - prev_angle) / (2*math.pi)\n                    res[best_i] += area\n            else:\n                # Find the minimal distance among active segments\n                min_dist = float('inf')\n                best_i = -1\n                for k in active:\n                    xk, yk, idx_k = holes[k]\n                    dist = xk*xk + yk*yk\n                    if dist < min_dist:\n                        min_dist = dist\n                        best_i = k\n                    elif dist == min_dist:\n                        if k < best_i:\n                            best_i = k\n                if best_i != -1:\n                    area = (current_angle - prev_angle) / (2*math.pi)\n                    res[best_i] += area\n        \n        prev_angle = current_angle\n        \n        if delta == 1:\n            active.add(i)\n        elif delta == -1:\n            active.discard(i)\n    \n    # Normalize by pi R^2, but since R is large, the area outside is negligible\n    # So the probability is res[i] / (pi R^2) * (pi R^2) = res[i]\n    for prob in res:\n        print(\"{0:.10f}\".format(prob))\n\nsolve()",
    "timestamp": "2025-08-13 13:52:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateProbabilities(N, holes, R) {\n  const probabilities = Array(N).fill(0);\n  const areaOfCircle = Math.PI * R * R;\n  const precision = 10 ** -5;\n\n  function distanceSq(x1, y1, x2, y2) {\n    return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n  }\n\n  // Simulate a large number of random points and track nearest hole\n  const numSamples = 1000000;\n  for (let i = 0; i < numSamples; i++) {\n    const theta = Math.random() * 2 * Math.PI;\n    const r = Math.sqrt(Math.random()) * R;\n    const x = r * Math.cos(theta);\n    const y = r * Math.sin(theta);\n\n    let minDistance = Infinity;\n    let nearestHole = -1;\n\n    holes.forEach((hole, index) => {\n      const [hx, hy] = hole;\n      const distSq = distanceSq(x, y, hx, hy);\n      if (distSq < minDistance || (distSq === minDistance && index < nearestHole)) {\n        minDistance = distSq;\n        nearestHole = index;\n      }\n    });\n\n    probabilities[nearestHole]++;\n  }\n\n  // Normalize the probabilities\n  return probabilities.map(count => (count / numSamples).toFixed(5));\n}\n\n// Example usage:\nconst N = 3;\nconst holes = [[1, 1], [-1, -1], [0, 0]];\nconst R = 10000;\nconst probabilities = calculateProbabilities(N, holes, R);\nconsole.log(probabilities);",
    "timestamp": "2025-08-13 13:52:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(holes, R) {\n    const n = holes.length;\n    const validPoints = [];\n    const holeCounts = new Array(n).fill(0);\n\n    for (let x = -R; x <= R; x++) {\n        for (let y = -R; y <= R; y++) {\n            if (x * x + y * y <= R * R) {\n                validPoints.push([x, y]);\n            }\n        }\n    }\n\n    for (const [x, y] of validPoints) {\n        let minDist = Infinity;\n        let nearestHoleIndex = -1;\n\n        for (let i = 0; i < n; i++) {\n            const dist = Math.sqrt((x - holes[i][0]) ** 2 + (y - holes[i][1]) ** 2);\n            \n            if (dist < minDist || (dist === minDist && i < nearestHoleIndex)) {\n                minDist = dist;\n                nearestHoleIndex = i;\n            }\n        }\n\n        holeCounts[nearestHoleIndex]++;\n    }\n\n    return holeCounts.map(count => count / validPoints.length);\n}",
    "timestamp": "2025-08-13 13:52:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateProbabilities(holes, R) {\n    const N = holes.length;\n    const probabilities = new Array(N).fill(0);\n    \n    if (N === 0) return probabilities;\n    \n    // For large R, the probability is proportional to the Voronoi cell area\n    // Since R is very large, the boundary effects are negligible, and the Voronoi cells are effectively infinite\n    // The probability is the area of the Voronoi cell divided by the total area (pi*R^2)\n    // But for large R, the probability is determined by the angles of the Voronoi cell\n    \n    // Compute the angles between holes to determine the Voronoi cell's angular extent\n    // The probability is the angle bisector method\n    \n    // Special case: only one hole\n    if (N === 1) {\n        probabilities[0] = 1;\n        return probabilities;\n    }\n    \n    // For each hole, compute the angular range it covers\n    for (let i = 0; i < N; i++) {\n        const [xi, yi] = holes[i];\n        const angles = [];\n        \n        // Collect all the angles to other holes\n        for (let j = 0; j < N; j++) {\n            if (i === j) continue;\n            const [xj, yj] = holes[j];\n            const dx = xj - xi;\n            const dy = yj - yi;\n            const angle = Math.atan2(dy, dx);\n            angles.push(angle);\n        }\n        \n        // Sort angles\n        angles.sort((a, b) => a - b);\n        \n        // Find the mid angles between consecutive angles\n        const midAngles = [];\n        for (let k = 0; k < angles.length; k++) {\n            const prev = angles[(k - 1 + angles.length) % angles.length];\n            const curr = angles[k];\n            let diff = curr - prev;\n            if (diff < 0) diff += 2 * Math.PI;\n            const mid = prev + diff / 2;\n            midAngles.push(mid);\n        }\n        \n        // The angular range for hole i is the range between midAngles\n        // The probability is the sum of the angular extents divided by (2*pi)\n        let totalAngle = 0;\n        for (let k = 0; k < midAngles.length; k++) {\n            const next = midAngles[(k + 1) % midAngles.length];\n            let angle = next - midAngles[k];\n            if (angle < 0) angle += 2 * Math.PI;\n            totalAngle += angle;\n        }\n        \n        // The probability is the angular range / (2*pi)\n        probabilities[i] = totalAngle / (2 * Math.PI);\n    }\n    \n    // Normalize probabilities to ensure they sum to 1 (due to floating point precision)\n    const sum = probabilities.reduce((a, b) => a + b, 0);\n    for (let i = 0; i < N; i++) {\n        probabilities[i] /= sum;\n    }\n    \n    return probabilities;\n}\n\n// Example usage:\n// const holes = [[0, 0], [1, 0], [0, 1]];\n// const R = 1e6;\n// const probs = calculateProbabilities(holes, R);\n// console.log(probs);",
    "timestamp": "2025-08-13 13:53:19"
  }
]