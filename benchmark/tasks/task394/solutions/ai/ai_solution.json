[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double P, T, V;\n} Runner;\n\ndouble compute_prob(int N, int M, double L, Runner runners[], int idx) {\n    double total_time = L / runners[idx].V;\n    double prob = 1.0;\n\n    for (int k = 0; k < (1 << M); ++k) {\n        double time = total_time;\n        double current_prob = 1.0;\n        for (int m = 0; m < M; ++m) {\n            if (k & (1 << m)) {\n                time += runners[idx].T;\n                current_prob *= runners[idx].P / 100.0;\n            } else {\n                current_prob *= (100.0 - runners[idx].P) / 100.0;\n            }\n        }\n\n        double prob_others = 1.0;\n        for (int i = 0; i < N; ++i) {\n            if (i == idx) continue;\n            double prob_i = 0.0;\n            for (int k_other = 0; k_other < (1 << M); ++k_other) {\n                double time_other = L / runners[i].V;\n                double current_prob_other = 1.0;\n                for (int m = 0; m < M; ++m) {\n                    if (k_other & (1 << m)) {\n                        time_other += runners[i].T;\n                        current_prob_other *= runners[i].P / 100.0;\n                    } else {\n                        current_prob_other *= (100.0 - runners[i].P) / 100.0;\n                    }\n                }\n                if (time_other > time + 1e-9) {\n                    prob_i += current_prob_other;\n                }\n            }\n            prob_others *= prob_i;\n        }\n        prob += current_prob * prob_others;\n    }\n\n    return prob - 1.0; // subtract the initial 1.0\n}\n\nint main() {\n    int N, M;\n    double L;\n    scanf(\"%d %d %lf\", &N, &M, &L);\n\n    Runner runners[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lf %lf %lf\", &runners[i].P, &runners[i].T, &runners[i].V);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        double prob = compute_prob(N, M, L, runners, i);\n        printf(\"%.10lf\\n\", prob);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Runner {\n    double P, T, V;\n};\n\ndouble compute_probability(const vector<Runner>& runners, int m, double l, int winner) {\n    int n = runners.size();\n    vector<vector<double>> dp(n, vector<double>(m + 1, 0.0));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i][0] = 1.0;\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = dp[i][j - 1] * (1.0 - runners[i].P / 100.0);\n        }\n    }\n    \n    double total_prob = 0.0;\n    \n    for (int k = 0; k <= m; ++k) {\n        double prob_k = dp[winner][k];\n        if (k > 0) {\n            prob_k = dp[winner][k] - dp[winner][k - 1];\n        }\n        \n        if (prob_k < 1e-12) continue;\n        \n        double time_winner = l / runners[winner].V + k * runners[winner].T;\n        double prob_all_slower = 1.0;\n        \n        for (int i = 0; i < n; ++i) {\n            if (i == winner) continue;\n            \n            double prob_slower = 0.0;\n            for (int k_other = 0; k_other <= m; ++k_other) {\n                double time_other = l / runners[i].V + k_other * runners[i].T;\n                if (time_other >= time_winner + 1e-12) {\n                    double prob_k_other;\n                    if (k_other == 0) {\n                        prob_k_other = dp[i][0];\n                    } else {\n                        prob_k_other = dp[i][k_other] - dp[i][k_other - 1];\n                    }\n                    prob_slower += prob_k_other;\n                }\n            }\n            prob_all_slower *= prob_slower;\n        }\n        \n        total_prob += prob_k * prob_all_slower;\n    }\n    \n    return total_prob;\n}\n\nint main() {\n    int n, m;\n    double l;\n    cin >> n >> m >> l;\n    \n    vector<Runner> runners(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> runners[i].P >> runners[i].T >> runners[i].V;\n    }\n    \n    cout << fixed << setprecision(10);\n    for (int i = 0; i < n; ++i) {\n        double prob = compute_probability(runners, m, l, i);\n        cout << prob << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Marathon {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        double L = scanner.nextDouble();\n        double[] P = new double[N];\n        double[] T = new double[N];\n        double[] V = new double[N];\n        \n        for (int i = 0; i < N; i++) {\n            P[i] = scanner.nextDouble() / 100.0;\n            T[i] = scanner.nextDouble();\n            V[i] = scanner.nextDouble();\n        }\n        \n        double[] prob = new double[N];\n        \n        for (int i = 0; i < N; i++) {\n            double totalProb = 0.0;\n            double runTime = L / V[i];\n            \n            for (int k = 0; k <= M; k++) {\n                double time = runTime + k * T[i];\n                double p = comb(M, k) * Math.pow(P[i], k) * Math.pow(1 - P[i], M - k);\n                \n                boolean canWin = true;\n                for (int j = 0; j < N; j++) {\n                    if (j == i) continue;\n                    \n                    double minK = Math.max(0, (time - L / V[j]) / T[j]);\n                    if (minK > M) {\n                        canWin = false;\n                        break;\n                    }\n                    \n                    int minKInt = (int) Math.ceil(minK);\n                    if (minKInt < 0) minKInt = 0;\n                    if (minKInt > M + 1) minKInt = M + 1;\n                    \n                    double pj = 0.0;\n                    for (int m = 0; m < minKInt; m++) {\n                        pj += comb(M, m) * Math.pow(P[j], m) * Math.pow(1 - P[j], M - m);\n                    }\n                    \n                    p *= pj;\n                }\n                \n                if (canWin) {\n                    totalProb += p;\n                }\n            }\n            \n            prob[i] = totalProb;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            System.out.printf(\"%.10f\\n\", prob[i]);\n        }\n    }\n    \n    private static double comb(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        double res = 1;\n        for (int i = 1; i <= k; i++) {\n            res = res * (n - k + i) / i;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 21:22:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class MarathonWinProbability {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        double L = Double.parseDouble(st.nextToken());\n        \n        Runner[] runners = new Runner[N];\n        \n        for (int i = 0; i < N; i++) {\n            st = new StringTokenizer(br.readLine());\n            double P = Double.parseDouble(st.nextToken());\n            double T = Double.parseDouble(st.nextToken());\n            double V = Double.parseDouble(st.nextToken());\n            runners[i] = new Runner(P, T, V, L, M);\n        }\n        \n        double[] winProbabilities = calculateWinProbabilities(runners);\n        \n        for (double prob : winProbabilities) {\n            System.out.printf(\"%.6f\\n\", prob);\n        }\n    }\n    \n    static double[] calculateWinProbabilities(Runner[] runners) {\n        int N = runners.length;\n        double[] winProbabilities = new double[N];\n        \n        for (int i = 0; i < N; i++) {\n            double winProb = 0;\n            for (int j = 0; j < N; j++) {\n                if (i != j) {\n                    winProb += calculateWinProbabilityPairwise(runners[i], runners[j]);\n                }\n            }\n            winProbabilities[i] = winProb;\n        }\n        \n        return winProbabilities;\n    }\n    \n    static double calculateWinProbabilityPairwise(Runner r1, Runner r2) {\n        return 1 - r2.totalTimeToFinish() < 1 - r1.totalTimeToFinish() ? \n               r1.winProbability(r2) : 0;\n    }\n    \n    static class Runner {\n        double P, T, V, L;\n        int M;\n        \n        Runner(double P, double T, double V, double L, int M) {\n            this.P = P / 100.0;\n            this.T = T;\n            this.V = V;\n            this.L = L;\n            this.M = M;\n        }\n        \n        double runningTime() {\n            return L / V;\n        }\n        \n        double restTime() {\n            double expectedRests = M * P;\n            return expectedRests * T;\n        }\n        \n        double totalTimeToFinish() {\n            return runningTime() + restTime();\n        }\n        \n        double winProbability(Runner other) {\n            double totalWinProb = 1.0;\n            for (int k = 0; k < M; k++) {\n                double restProbOther = other.P;\n                double noRestProbOther = 1 - restProbOther;\n                double restProbThis = this.P;\n                double noRestProbThis = 1 - restProbThis;\n                \n                double winProb = \n                    (noRestProbThis * noRestProbOther) +\n                    (noRestProbThis * restProbOther * noRestProbThis) +\n                    (restProbThis * noRestProbOther * noRestProbThis);\n                \n                totalWinProb *= winProb;\n            }\n            return totalWinProb;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:23:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_RUNNERS 100\n#define MAX_PLACES 100\n#define EPS 1e-6\n\ntypedef struct {\n    double prob;\n    double rest_time;\n    double speed;\n} Runner;\n\ndouble calculate_total_time(Runner *runner, double marathon_length, int rest_places) {\n    double total_time = 0;\n    double remaining_distance = marathon_length;\n\n    for (int i = 0; i < rest_places; i++) {\n        double dist_to_rest = runner->speed * remaining_distance;\n        \n        if ((double)rand() / RAND_MAX < runner->prob) {\n            total_time += dist_to_rest / runner->speed;\n            total_time += runner->rest_time;\n            remaining_distance -= dist_to_rest;\n        } else {\n            remaining_distance -= dist_to_rest;\n        }\n    }\n\n    total_time += remaining_distance / runner->speed;\n    return total_time;\n}\n\nint main() {\n    int N, M;\n    double L;\n    Runner runners[MAX_RUNNERS];\n    \n    scanf(\"%d %d %lf\", &N, &M, &L);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &runners[i].prob, &runners[i].rest_time, &runners[i].speed);\n    }\n\n    int simulations = 100000;\n    double win_probabilities[MAX_RUNNERS] = {0};\n\n    for (int sim = 0; sim < simulations; sim++) {\n        double min_time = INFINITY;\n        int winner = -1;\n\n        for (int i = 0; i < N; i++) {\n            double time = calculate_total_time(&runners[i], L, M);\n            \n            if (time < min_time) {\n                min_time = time;\n                winner = i;\n            } else if (fabs(time - min_time) < EPS) {\n                winner = -1;\n            }\n        }\n\n        if (winner != -1) {\n            win_probabilities[winner]++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%.5lf\\n\", win_probabilities[i] / simulations);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ndouble calculate_total_time(int M, double L, double P, double T, double V) {\n    double total_time = 0;\n    double running_time = L / V;\n    double break_time = (P / 100.0) * (running_time / (1 - P / 100.0)) * T;\n    total_time = running_time + break_time;\n    return total_time;\n}\n\nint main() {\n    int N, M;\n    double L;\n    cin >> N >> M >> L;\n\n    vector<double> total_times(N);\n    vector<double> win_probabilities(N, 0.0);\n\n    for (int i = 0; i < N; ++i) {\n        double P, T, V;\n        cin >> P >> T >> V;\n        total_times[i] = calculate_total_time(M, L, P, T, V);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        double prob_win = 1.0;\n        for (int j = 0; j < N; ++j) {\n            if (i != j) {\n                if (total_times[i] > total_times[j]) {\n                    prob_win *= 1.0;\n                } else if (total_times[i] < total_times[j]) {\n                    prob_win *= 0.0;\n                } else {\n                    prob_win *= 0.5;\n                }\n            }\n        }\n        win_probabilities[i] = prob_win;\n    }\n\n    cout << fixed << setprecision(6);\n    for (double prob : win_probabilities) {\n        cout << prob << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef marathon_win_probability(N, M, L, runners_info):\n    def runner_time(runner, stops):\n        P_i, T_i, V_i = runner\n        time = L / V_i\n        for stop in stops:\n            if stop == 1:\n                time += T_i\n        return time\n\n    def probability_of_stops(runner):\n        P_i, _, _ = runner\n        return [(1 - P_i / 100)**M] + [P_i / 100] * M\n\n    def compute_win_probability():\n        winning_probability = [0.0] * N\n        states = list(itertools.product(range(2), repeat=M))\n\n        for state in states:\n            stop_prob = [probability_of_stops(runners_info[i])[sum(state)] for i in range(N)]\n            state_probability = 1\n            for p in stop_prob:\n                state_probability *= p\n            \n            finish_times = [runner_time(runners_info[i], state) for i in range(N)]\n            fastest_time = min(finish_times)\n            possible_winners = finish_times.count(fastest_time)\n\n            if possible_winners == 1:\n                winner_index = finish_times.index(fastest_time)\n                winning_probability[winner_index] += state_probability\n\n        return winning_probability\n\n    results = compute_win_probability()\n    return [round(prob, 10) for prob in results]\n\n# Example usage\nN = 3\nM = 2\nL = 100.0\nrunners_info = [\n    (50, 10, 10),\n    (60, 5, 8),\n    (70, 7, 9)\n]\n\nprobabilities = marathon_win_probability(N, M, L, runners_info)\nfor prob in probabilities:\n    print(prob)",
    "timestamp": "2025-08-13 06:09:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Marathon {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read input values\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        double L = scanner.nextDouble();\n\n        double[][] runnerData = new double[N][3];\n        for (int i = 0; i < N; i++) {\n            runnerData[i][0] = scanner.nextDouble(); // Probability P_i\n            runnerData[i][1] = scanner.nextDouble(); // Resting Time T_i\n            runnerData[i][2] = scanner.nextDouble(); // Speed V_i\n        }\n\n        // Store the probability of each runner winning\n        double[] winProbabilities = new double[N];\n\n        // Compute probabilities\n        simulate(N, M, L, runnerData, winProbabilities);\n\n        // Print the probabilities of winning\n        for (int i = 0; i < N; i++) {\n            System.out.printf(\"%.5f\\n\", winProbabilities[i]);\n        }\n\n        scanner.close();\n    }\n\n    private static void simulate(int N, int M, double L, double[][] runnerData, double[] winProbabilities) {\n        int simulations = 1000;\n        for (int sim = 0; sim < simulations; sim++) {\n            double[] times = new double[N];\n\n            for (int i = 0; i < N; i++) {\n                double speed = runnerData[i][2];\n                double time = L / speed;\n\n                for (int j = 0; j < M; j++) {\n                    if (Math.random() < runnerData[i][0] / 100.0) {\n                        time += runnerData[i][1];\n                    }\n                }\n\n                times[i] = time;\n            }\n\n            int minIndex = -1;\n            double minTime = Double.MAX_VALUE;\n\n            // Finding unique winner\n            for (int i = 0; i < N; i++) {\n                if (times[i] < minTime) {\n                    minTime = times[i];\n                    minIndex = i;\n                } else if (times[i] == minTime) {\n                    minIndex = -1;\n                }\n            }\n\n            if (minIndex != -1) {\n                winProbabilities[minIndex]++;\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            winProbabilities[i] /= simulations;\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:10:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_R 15\n#define EPS 1e-9\n\ntypedef struct {\n    double probability;\n    double restTime;\n    double speed;\n} Runner;\n\nRunner runners[MAX_R];\nint N, M;\ndouble L;\n\ndouble calculate_time(double prob, double rest, double speed) {\n    double distance_per_rest = L / (M + 1);\n    double expected_time = 0.0;\n    for (int i = 0; i <= M; i++) {\n        double no_rest_time = distance_per_rest / speed;\n        expected_time += no_rest_time * (1 - prob) + (no_rest_time + rest) * prob;\n    }\n    return expected_time;\n}\n\nint main() {\n    scanf(\"%d %d %lf\", &N, &M, &L);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &runners[i].probability, &runners[i].restTime, &runners[i].speed);\n        runners[i].probability /= 100.0;\n    }\n\n    double win_probabilities[MAX_R] = {0};\n    double min_time[MAX_R];\n    for (int mask = 0; mask < (1 << (N * M)); mask++) {\n        double times[MAX_R] = {0};\n        for (int i = 0; i < N; i++) {\n            double prob_rest = runners[i].probability;\n            double prob_run = 1 - prob_rest;\n            for (int j = 0; j <= M; j++) {\n                double dist = L / (M + 1);\n                double rest_time = (mask & (1 << (i * M + j))) ? runners[i].restTime : 0;\n                times[i] += dist / runners[i].speed + rest_time;\n            }\n        }\n\n        int winner = -1;\n        double best_time = 0;\n        for (int i = 0; i < N; i++) {\n            if (winner == -1 || times[i] < best_time - EPS) {\n                winner = i;\n                best_time = times[i];\n            } else if (fabs(times[i] - best_time) < EPS) {\n                winner = -1;\n            }\n        }\n\n        if (winner != -1) {\n            double prob = 1.0;\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j <= M; j++) {\n                    if (mask & (1 << (i * M + j))) {\n                        prob *= runners[i].probability;\n                    } else {\n                        prob *= (1.0 - runners[i].probability);\n                    }\n                }\n            }\n            win_probabilities[winner] += prob;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%.6lf\\n\", win_probabilities[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:10:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_marathon_problem(N, M, L, runners):\n    def calculate_total_time(runner):\n        P, T, V = runner\n        rest_time = 0\n        for _ in range(M):\n            if random.random() < P:\n                rest_time += T\n        distance_time = L / V\n        return distance_time + rest_time\n\n    def simulate_race(num_simulations):\n        wins = [0] * N\n        for _ in range(num_simulations):\n            times = [calculate_total_time(runner) for runner in runners]\n            winner = times.index(min(times))\n            wins[winner] += 1\n        return [win / num_simulations for win in wins]\n\n    random.seed(42)\n    num_simulations = 100000\n    return simulate_race(num_simulations)\n\nimport random\n\n# Input parsing\nN, M, L = map(int, input().split())\nrunners = []\nfor _ in range(N):\n    P, T, V = map(float, input().split())\n    runners.append((P/100, T, V))\n\n# Solve and print results\nresults = solve_marathon_problem(N, M, L, runners)\nfor prob in results:\n    print(f\"{prob:.6f}\")",
    "timestamp": "2025-08-13 06:10:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom math import comb\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n    L = int(input[ptr])\n    ptr += 1\n    \n    runners = []\n    for _ in range(N):\n        P_i = int(input[ptr])\n        ptr += 1\n        T_i = int(input[ptr])\n        ptr += 1\n        V_i = int(input[ptr])\n        ptr += 1\n        runners.append((P_i, T_i, V_i))\n    \n    res = [0.0] * N\n    \n    for i in range(N):\n        P_i, T_i, V_i = runners[i]\n        if V_i == 0:\n            res[i] = 0.0\n            continue\n        run_time = L / V_i\n        max_breaks = M\n        prob_i = 0.0\n        \n        for k in range(0, M + 1):\n            total_time = run_time + k * T_i\n            # Compute probability that i takes exactly k breaks\n            prob_k = (comb(M, k) * (P_i ** k) * ((100 - P_i) ** (M - k))) / (100 ** M)\n            \n            # Now compute the probability that all other runners have time > total_time\n            prob_others = 1.0\n            for j in range(N):\n                if j == i:\n                    continue\n                P_j, T_j, V_j = runners[j]\n                if V_j == 0:\n                    prob_j = 0.0\n                else:\n                    min_breaks_j = 0\n                    # Find minimal k_j such that run_time_j + k_j * T_j > total_time\n                    # run_time_j = L / V_j\n                    run_time_j = L / V_j\n                    # k_j * T_j > total_time - run_time_j\n                    # k_j > (total_time - run_time_j) / T_j\n                    if T_j == 0:\n                        if run_time_j > total_time:\n                            min_breaks_j = 0\n                        else:\n                            min_breaks_j = M + 1\n                    else:\n                        rhs = (total_time - run_time_j) / T_j\n                        min_breaks_j = int(rhs) + 1\n                        if min_breaks_j < 0:\n                            min_breaks_j = 0\n                    \n                    max_possible = M\n                    if min_breaks_j > max_possible:\n                        prob_j = 0.0\n                    else:\n                        # Compute P(j has >= min_breaks_j breaks)\n                        prob_j = 0.0\n                        for k_j in range(min_breaks_j, M + 1):\n                            term = comb(M, k_j) * (P_j ** k_j) * ((100 - P_j) ** (M - k_j)) / (100 ** M)\n                            prob_j += term\n                prob_others *= prob_j\n            prob_i += prob_k * prob_others\n        res[i] = prob_i\n    \n    for num in res:\n        print(\"{0:.10f}\".format(num))\n\nsolve()",
    "timestamp": "2025-08-13 06:11:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\ndouble calculateExpectedTime(int L, double P, double T, double V, int M) {\n    double probabilityNoRest = pow(1 - P, M);\n    double expectedRestTime = M * P * T;\n    double expectedTotalTime = L / V + expectedRestTime / M;\n    return expectedTotalTime * probabilityNoRest + L / V * (1 - probabilityNoRest);\n}\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<double> probabilities(N), restingTimes(N), speeds(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> probabilities[i] >> restingTimes[i] >> speeds[i];\n        probabilities[i] /= 100.0;\n    }\n    \n    vector<double> expectedTimes(N);\n    for (int i = 0; i < N; ++i) {\n        expectedTimes[i] = calculateExpectedTime(L, probabilities[i], restingTimes[i], speeds[i], M);\n    }\n    \n    vector<double> winProbabilities(N, 1.0);\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i != j && expectedTimes[i] >= expectedTimes[j]) {\n                winProbabilities[i] = 0.0;\n                break;\n            }\n        }\n    }\n    \n    cout << fixed << setprecision(5);\n    for (int i = 0; i < N; ++i) {\n        cout << winProbabilities[i] << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:22"
  }
]