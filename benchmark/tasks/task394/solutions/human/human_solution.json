[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++)cin >> p[i] >> t[i] >> v[i];\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(!v[i])time[i][j] = 1e+10;\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  double k = 1.0;\n  for(int i=0;i<m;i++)k*=100.0;\n  //cout << k << endl;\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(100-p[i],m);\n    prob[i][0] /= k;\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(100-p[i],m-j) * pow(p[i],j);\n      prob[i][j] /= k;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define INF 999999999\n\nint N, M, L;\ndouble P[102], T[102], V[102];\ndouble dp[102][102];\ndouble p[102][102];\n\nint main(){\n  while(cin >> N >> M >> L){\n    for(int i = 0; i < N; i++){\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n\n    for(int k = 0; k < N; k++){\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1.0;\n\n      for(int i = 0; i < M; i++){\n        for(int j = 0; j <= M; j++){\n          dp[i + 1][j] += dp[i][j] * (1 - P[k]);\n          dp[i + 1][j + 1] += dp[i][j] * P[k];\n        }\n      }\n\n      for(int j = 0; j <= M; j++){\n        p[k][j] = dp[M][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      double ans = 0;\n\n      for(int j = 0; j <= M; j++){\n        double ti = INF;\n        if(V[i] != 0) ti = (double)j * T[i] + (double)L / V[i];\n\n        double mul = 1.0;\n\n        for(int k = 0; k < N; k++){\n          if(k == i) continue;\n\n          double sum = 0;\n\n          for(int l = 0; l <= M; l++){\n            double tk = INF;\n            if(V[k] != 0) tk = (double)l * T[k] + (double)L / V[k];\n            if(ti >= tk) continue;\n            sum += p[k][l];\n          }\n\n          mul *= sum;\n        }\n\n        ans += mul * p[i][j];\n      }\n\n      printf(\"%.8lf\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>;\n\nld comb(ll l, ll r) {\n\tld res = 1;\n\tREP(i, r) {\n\t\tres *= l - i;\n\t\tres /= i + 1;\n\t}\n\treturn res;\n}\n\n// [person][rest-number] -> prob\nvector<vector<ld>> calc_prob_table(const vector<ar3>& info, const int M) {\n\tconst int N = info.size();\n\tvector<vector<ld>> res(N, vector<ld>(M + 1));\n\tREP(i, N)REP(j, M + 1) {\n\t\tld rest = info[i][0];\n\t\tres[i][j] = comb(M, j)*powl(rest / 100., j)*powl(1 - rest / 100., M - j);\n\t}\n\t//REP(i, N)REP(j, M - 1)res[i][j + 1] += res[i][j];\n\treturn res;\n}\n\nld lose_prob(const vector<ld>& prob, ar3 info, ld time, const ld L) {\n\tconst int M = prob.size();\n\ttime -= L / info[2];\n\tif (info[1] == 0) {\n\t\ttime = INF * (time >= 0 ? 1 : -1);\n\t}\n\telse {\n\t\ttime /= (ld)info[1];\n\t}\n\n\tld res = 0;\n\tREP(i, min(time + 1e-3, (ld)M)) {\n\t\tres += prob[i];\n\t}\n\treturn 1 - res;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<ar3> info(N);\n\tREP(i, N)REP(j, 3)cin >> info[i][j];\n\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tauto table = calc_prob_table(info, M);\n\tREP(i, N) {\n\t\tld res = 0;\n\t\tREP(rest, M + 1) {\n\t\t\tif (info[i][2] == 0)break;\n\t\t\tld tres = table[i][rest];\n\t\t\tld time = (ld)L / info[i][2] + info[i][1] * rest;\n\t\t\tREP(opp, N)if (opp != i) {\n\t\t\t\ttres *= lose_prob(table[opp], info[opp], time, L);\n\t\t\t}\n\t\t\tres += tres;\n\t\t}\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n \nlong double fact(int x){\n  long double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n \nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n    if(i!=k){\n      int x=upper_bound(at[k],at[k]+m+1,at[i][j]+1e-9)-at[k];\n      c*=1-acp[k][x];\n    }\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n;\n\tint m;\n\tint l;\n\tcin >> n >> m >> l;\n\tvector<int> p;\n\tvector<int> t;\n\tvector<int> v;\n\tint a;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> a;\n\t\tp.push_back(a);\n\t\tcin >> a;\n\t\tt.push_back(a);\n\t\tcin >> a;\n\t\tv.push_back(a);\n\t}\n\tvector<int> c;\n\tfor ( int i = 0; i <= m; i++ ) {\n\t\ta = 1;\n\t\tfor ( int j = m - i + 1; j <= m; j++ ) {\n\t\t\ta = a * j;\n\t\t}\n\t\tfor ( int j = 1; j <= i; j++ ) {\n\t\t\ta = a / j;\n\t\t}\n\t\tc.push_back(a);\n\t}\n\tdouble goaltime;\n\tdouble pro;\n\tdouble s;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\ts = 0.00;\n\t\tif ( v[i] == 0 ) {\n\t\t\tcout << fixed << s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( int x = 0; x <= m; x++ ) {\n\t\t\tgoaltime = double(l) / v[i] + t[i] * x;\n\t\t\tpro = pow( 0.01*p[i] , x ) * pow( 1.00 - 0.01*p[i] , m - x ) * c[x];\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tif ( i == j ) continue;\n\t\t\t\tif ( v[j] == 0 ) {\n\t\t\t\t\tcout << fixed << 0.00 << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble g;\n\t\t\t\tg = goaltime - double(l) / v[j];\n\t\t\t\tint y;\n\t\t\t\tif ( t[j] == 0 ) {\n\t\t\t\t\tif ( g >= 0 ) y = m + 1;\n\t\t\t\t}else {\n\t\t\t\t\ty = (int)g / t[j] + 1;\n\t\t\t\t}\n\t\t\t\tif ( g < 0 ) y = 0;\n\t\t\t\tif ( y > m ) {\n\t\t\t\t\tpro = 0.00;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble z = 0.00;\n\t\t\t\tfor ( y; y <= m; y++ ) {\n\t\t\t\t\tz += pow( 0.01*p[j] , y ) * pow( 1.00 - 0.01*p[j] , m - y ) * c[y];\n\t\t\t\t}\n\t\t\t\tpro = pro * z;\n\t\t\t}\n\t\t\ts += pro;\n\t\t}\n\t\tcout << fixed << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  /*\n  if(n==1){\n    printf(\"%.8lf\\n\",1.0);\n    return 0;\n  }\n  */\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(1-p[i],m);\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(1-p[i],m-j) * pow(p[i],j) ;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <string.h>\nusing namespace std;\n#define PI 3.1415926535897932384626433832795028\n#define N 510\n#define M 10010\n#define inf 1000000000\ntypedef long long LL;\ndouble p[109][55],tt[109][55];\ndouble c[55][55];\nvoid set()\n{\n\tfor(int i=1;i<=51;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j>=1) c[i][j]=c[i][j-1]*((double)(i-j+1.0)/j);\n\t\t\telse c[i][j]=1;\n\t//\t if(i==50)\tprintf(\"%.0lf \",c[i][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n}\ndouble Pow(int a,int b,double h)\n{\n\tdouble pp=1.0;\n\tint j;\n\tfor(j=1;j<=b;j++) pp*=h;\n\tfor(j;j<=a;j++) pp*=(1.0-h);\n\treturn pp*c[a][b];\n}\n\nint main()\n{\n\tint n,m,i,j;\n\tdouble l,pp,t,v;\n\tset();\n\twhile(scanf(\"%d %d %lf\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf %lf\",&pp,&t,&v);\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tp[i][j]=Pow(m,j,pp/100.0);\n\t\t\t\ttt[i][j]=l/v+j*t;\n\t\t\t//\tprintf(\"%.8lf \",p[i][j]);\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tdouble ans=0;\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tdouble ans1=p[i][j];\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\tdouble q=0.0;\n\t\t\t\t\tfor(int  x=m;x>=0;x--){\n\t\t\t\t\t\tif(tt[k][x]>tt[i][j]) q+=p[k][x];\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tans1*=q;\n\t\t\t\t}\n\t\t\t\tans+=ans1;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\",ans);\n\t\t}\n\t}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n);\n    for(int i=0;i<n;i++){\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\nint N, M, L, P[110], T[110], V[110];\ndouble RP[110][55], RT[110][55];\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\n\tminit(RP, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\tRT[i][0] = V[i] > 0 ? (double)L / (double)V[i] : 1e9;\n\t\tfor_(j,0,M) RT[i][j + 1] = RT[i][j] + (double)T[i];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tvector< double > p(M+1, 1.0), pm(M+1, 1.0);\n\t\t\n\t\tfor_(k,0,M) {\n\t\t\tp[k + 1] = p[k] * (double)P[i] / 100.0;\n\t\t\tpm[k + 1] = pm[k] * (1.0 - (double)P[i] / 100.0);\n\t\t}\n\t\t\n\t\tlong long mCk = 1;\n\t\t\n\t\tfor_(k,0,M + 1) {\n\t\t\tRP[i][k] =  (double)mCk * p[k] * pm[M - k];\n\t\t\tmCk *= (M - k);\n\t\t\tmCk /= k + 1;\n\t\t}\n\t\t\n\t\tfor_rev(k,M,1) RP[i][k-1] += RP[i][k];\n\t}\n\t\t\n\tfor_(i,0,N) {\n\t\tif (V[i] == 0) {\n\t\t\tcout << \"0.000000000\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble ans = 0.0;\n\t\t\n\t\tfor_(k,0,M+1) {\n\t\t\tdouble t = RT[i][k];\n\t\t\tdouble p = RP[i][k] - RP[i][k + 1];\n\t\t\t\t\t\t\n\t\t\tfor_(ii,0,N) {\n\t\t\t\tif (ii == i || V[ii] == 0) continue;\n\t\t\t\tint id = upper_bound(RT[ii], RT[ii] + M + 1, t) - RT[ii];\n\t\t\t\tp *= RP[ii][id];\n\t\t\t}\n\t\t\t\n\t\t\tans += p;\n\t\t}\n\t\t\n\t\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nconst double eps = 1e-6;\nconst int MAXN = 102;\nconst int MAXM = 52;\nint N, M, L;\ndouble P[MAXN];\nint T[MAXN];\nint V[MAXN];\nlli comb[MAXM][MAXM];\n\nvector<double> U[MAXN];\nvector<double> Q[MAXN];\nvector<double> R[MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvoid make() {\n  comb[0][0] = 1;\n  for(int i = 1; i < MAXM; ++i) {\n    for(int j = 0; j <= i; ++j) {\n      comb[i][j] = 0;\n      if(j) comb[i][j] += comb[i-1][j-1];\n      if(j <= i-1) comb[i][j] += comb[i-1][j];\n    }\n  }\n}\n\nint main() {\n  make();\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n    for(int i = 0; i < MAXN; ++i) {\n      U[i].clear();\n      Q[i].clear();\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int k = 0; k <= M; ++k) { // rest k times.\n\tU[i].push_back(L/(double)V[i]+(double)T[i]*k);\n\tQ[i].push_back(pow(P[i],k)*pow(1.0-P[i],M-k)*comb[M][k]);\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      double res = 0.0;\n      double sum = 0.0;\n      for(int k = 0; k <= M; ++k) {\n\tdouble tmp = Q[i][k];\n\tfor(int j = 0; j < N; ++j) {\n\t  if(i == j) continue;\n\t  vector<double>::iterator it = \n\t    lower_bound(U[j].begin(), U[j].end(), U[i][k]);\n\t  double a = 0;\n\t  for(int b = it-U[j].begin(); b < U[j].size(); ++b) {\n\t    if(equals(U[j][b], U[i][k]) || U[j][b] < U[i][k]) continue;\n\t    a += Q[j][b];\n\t  }\n\t  tmp *= a;\n\t}\n\tres += tmp;\n      }\n      printf(\"%.8f\\n\", res);\n    }\n    //puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\ndouble A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[m-i]*B[i]*nCr(m,i);\n  \n  for(int i=1;i<n;i++){\n    for(int j=0;j<=m;j++){\n      for(int k=0;k<=m;k++){\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[m-k]*B[k]*nCr(m,k);\n      }\n    }\n  }\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  A[0]=B[0]=1;\n  for(int i=1;i<n;i++)A[i]=A[i-1]*(1-p[i]),B[i]=B[i-1]*p[i];\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nvector<vector<double>> c;\n\ndouble pp(int m, int k, double p){\n  double ans=c[m][k];\n  rep(i,k) ans*=p;\n  rep(i,m-k) ans*=1-p;\n  return ans;\n}\n\nint main(){\n  c=vector<vector<double>>(51,vector<double>(51));\n  c[0][0]=1;\n  repp(i,1,51){\n    c[i][0]=1,c[i][i]=1;\n    repp(j,1,i){\n      c[i][j]=c[i-1][j-1]+c[i-1][j];\n    }\n  }\n  int n,m;\n  double l;\n  cin >> n >> m >> l;\n  vector<vector<double>> time(n,vector<double>(m+1)),prob(n,vector<double>(m+1));\n  double p,t,v;\n  rep(i,n){\n    cin >> p >> t >> v;\n    rep(j,m+1){\n      time[i][j]=l/v+t*j;\n      prob[i][j]=pp(m,j,p/100);\n    }\n  }\n  cout << fixed << setprecision(10);\n  rep(i,n){\n    double ans=0;\n    rep(j,m+1){\n      double tmp=prob[i][j];\n      rep(k,n){\n        if(i==k) continue;\n        double tmpp=0;\n        per(l,m+1){\n          if(time[k][l]<=time[i][j]) break;\n          tmpp+=prob[k][l];\n        }\n        tmp*=tmpp;\n      }\n      ans+=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 101;\nconst int M = 51;\ndouble dp[N][M][M];//probability: who,ith place,num of QK\ndouble t[N][M];//num: who,num of QK,\n\nvoid solve(int n,int I,double prob){\n  dp[I][0][0]=1-prob;\n  dp[I][0][1]=prob;\n  REP(i,1,n){\n    REP(j,0,n+1){\n      dp[I][i][j]=0;\n      dp[I][i][j]+=dp[I][i-1][j]*(1-prob);\n      if (j-1 >= 0){\n        dp[I][i][j]+=dp[I][i-1][j-1]*prob;\n      }\n    }\n  }\n}\n\nint main(){\n  int n,m,l;\n  while(cin>>n>>m>>l){\n    double p[n],ti[n],v[n];\n    rep(i,n){\n      cin>>p[i]>>ti[i]>>v[i];\n      p[i]=p[i]/100.0;\n      double tttt=l/v[i];\n      rep(j,m+1){\n        t[i][j]=tttt+j*ti[i];\n      }\n    }\n    rep(i,n)solve(m,i,p[i]);\n    /*\n    rep(i,n){\n      rep(j,m+1){\n        cout << t[i][j] <<\",\" << dp[i][m-1][j] <<\" \";\n      }\n      cout << endl;\n    }\n    */\n    if (m == 0){\n      rep(i,n){\n        double a=1;\n        rep(j,n){\n          if (i == j)continue;\n          if (v[i] <= v[j])a=0;\n        }\n        printf(\"%.12lf\\n\",a);\n      }\n    }else {\n      rep(i,n){//\n        double sum=0;\n        rep(k,m+1){\n          double prob=1;\n          rep(j,n){\n            if (i == j)continue;\n            double ahoge=0;\n            rep(l,m+1){\n              if (t[i][k] < t[j][l])ahoge+=dp[j][m-1][l];\n            }\n            prob*=ahoge;\n          }\n          sum+=prob*dp[i][m-1][k];\n        }\n        printf(\"%.12lf\\n\",sum);\n      }\n      //cout << endl;\n#ifdef DEBUG\n      printf(\"end\\n\");\n#endif\n    }\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <cstdlib>\n#include <map>\n#include <memory.h>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst double EPS = 1e-12;\nconst int INF = 1 << 29;\n\ndouble cprob[100][100];\ndouble P[110];\ndouble T[110];\ndouble V[110];\n\ndouble comb(int n, int r){\n  double res = 1.0;\n  r = min(n - r, r);\n  rep(i, r){\n    res = res * (n - i) / (i + 1);\n  }\n  return res;\n}\n\ndouble getp(int M, int j, int id){\n  double res = comb(M, j);\n  rep(i, j) res *= P[id] / 100.0;\n  rep(i, M - j) res *= (1 - P[id] / 100.0);\n  return res;\n}\n\nint main(){\n  int N, M, L;\n  double prob, p, p2;\n  while(cin >> N >> M >> L && (N || M || L)){\n    rep(i, N){\n      cin >> P[i] >> T[i] >> V[i];\n    }\n    rep(i, N)rep(j, M + 1) cprob[i][j] = getp(M, j, i);\n    rep(i, N){\n      prob = 0.0;\n      rep(j, M + 1){\n\tp = getp(M, j, i);\n\tdouble need = (double)L / V[i] + j * T[i];\n\trep(k, N){\n\t  double p1 = 0.0;\n\t  if(i == k) continue;\n\t  rep(l, M + 1){\n\t    p2 = cprob[k][l];\n\t    double ene = (double)L / V[k] + l * T[k];\n\t    if(ene > need) {\n\t      p1 += p2;\n\t    }\n\t  }\n\t  p *= p1;\n\t}\n\tprob += p;\n      }\n      cout << fixed << setprecision(12) << prob << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\nlong long C[N][N];\n\nlong double prob[N][N];\nlong double _time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\tif (!v[i]) continue;\n\t\t_time[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) _time[i][j] = _time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tlong double a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tlong double ct = _time[i][j];\n\t\t\tlong double cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tlong double tmp = 0;\n\t\t\t\twhile (idx >= 0 && _time[k][idx] > ct) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\nconstexpr double pi = acos(-1);\nconstexpr double EPS = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\ndouble comb(int n, int r){\n    double u = 1, d = 1;\n    for(int i=0; i<r; i++) u *= (n - i);\n    for(int i=1; i<=r; i++) d *= i;\n    return u / d;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, l; cin>>n>>m>>l;\n    vector<double> p(n), t(n), v(n);\n    for(int i=0; i<n; i++) cin>>p[i]>>t[i]>>v[i];\n\n    vector<vector<double>> proba(n, vector<double>(m+1));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<=m; j++){\n            proba[i][j] = pow(1. * p[i] / 100, j) * pow(1 - 1. * p[i] / 100, m - j) * comb(m, j);\n        }\n    }\n\n    for(int i=0; i<n; i++){\n        double ans = 0;\n        for(int j=0; j<=m; j++){\n            double ctime = 1. * l / v[i] + t[i] * j;\n            double sum = 1;\n            for(int ii=0; ii<n; ii++){\n                if(i == ii) continue;\n                double proba_sum = 0;\n                for(int jj=0; jj<=m; jj++){\n                    double ntime = 1. * l / v[ii] + t[ii] * jj;\n                    if(ctime < ntime){\n                        proba_sum += proba[ii][jj];\n                    }\n                }\n                \n                sum *= proba_sum;\n            }\n\n            ans += sum * proba[i][j];\n        }\n\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\n\nint main() {\n  int n,m;\n  double l;\n  cin>>n>>m>>l;\n  vector<vector<ld>> prob(n, vector<ld>(m+1));\n  vector<vector<ld>> tm(n, vector<ld>(m+1));\n  REP(i,n) {\n    ld p,t,v;\n    cin>>p>>t>>v;\n    p /= 100.0;\n    prob[i][0] = 1.0;\n    REP(j,m) {\n      vector<ld> tmp(m+1);\n      tmp[0] = prob[i][0] * (1-p);\n      REP(k,m)\n        tmp[k+1] = prob[i][k] * p + prob[i][k+1] * (1-p);\n      swap(prob[i], tmp);\n    }\n    REP(j,m+1)\n      tm[i][j] = l/v + t*j;\n  }\n  REP(i,n) {\n    ld psum = 0.0;\n    REP(j,m+1) {\n      ld T = tm[i][j];\n      ld p = prob[i][j];\n      REP(k,n) {\n        if(i==k) continue;\n        ld sp = 0.0;\n        REP(l,m+1){\n          if (tm[k][l] > T) sp += prob[k][l];\n        }\n        p *= sp;\n      }\n      psum += p;\n    }\n    cout << setprecision(10) << fixed << psum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//10\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ndouble fact(int x){\n  double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n\tif(i!=k){\n\t  int x=lower_bound(at[k],at[k]+m+1,at[i][j]+x1e-9)-at[k];\n\t  c*=1-acp[k][x];\n\t}\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#define AA 1125899906842624\nint N,M,L;\ntypedef struct tttttttt\n{\n    int ti,vi;\n    double pi;\n}Ru;\nlong long fact[51];\nRu runners[102];\nint times[102][52];\ndouble pos[102][52];\ndouble po[102];\nvoid pre()\n{\n    int i;\n    memset(fact,0,sizeof(fact));\n    fact[0]=fact[1]=1;\n    for(i=2;i<=50;i++)\n        fact[i]=i*fact[i-1];\n}\nvoid caltime()\n{\n    int i,j;\n    for(i=1;i<=N;i++)\n    {\n        int ot=L/runners[i].vi;\n        for(j=0;j<=M;j++)\n        {\n            times[i][j]=ot+j*runners[i].ti;\n        }\n    }\n}\nvoid calpos()\n{\n    int i,j;\n    for(i=1;i<=N;i++)\n    {\n        for(j=0;j<=M;j++)\n        {\n            pos[i][j]=fact[M]/(fact[j]*fact[M-j])*(pow(runners[i].pi,(double)j))*(pow((1-runners[i].pi),(double)(M-j)));\n        }\n    }\n}\ndouble calpo(int x)\n{\n    int i,j,k;\n    double pp=0;\n    for(i=0;i<=M;i++)\n    {\n        int xt=times[x][i];\n        double p=pos[x][i];\n        for(j=1;j<=N;j++)\n        {\n            if(j==x) continue;\n            double p0=0;\n            for(k=0;k<=M;k++)\n            {\n                if(times[j][k]>xt) p0+=pos[j][k];\n            }\n            p*=p0;\n        }\n        pp+=p;\n    }\n    return pp;\n}\nint main()\n{\n    memset(runners,0,sizeof(runners));\n    memset(times,0,sizeof(times));\n    memset(po,0,sizeof(po));\n    memset(pos,0,sizeof(pos));\n    scanf(\"%d%d%d\",&M,&N,&L);\n    int i;\n    for(i=1;i<=N;i++) scanf(\"%lf%d%d\",&runners[i].pi,&runners[i].ti,&runners[i].vi);\n    caltime();\n    calpos();\n    for(i=1;i<=N;i++)\n    {\n        printf(\"%.8f\\n\",calpo(i));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nconstexpr double eps = 1e-10;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<vector<vector<double>>> cmb(N, vector<vector<double>>(M+1, vector<double>(M+1)));\n    for(int i=0; i<N; ++i) {\n        cmb[i][0][0] = 1;\n    }\n    vector<double> P(N), T(N), V(N);\n    for(int i=0; i<N; ++i) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n    for(int i=0; i<N; ++i) {\n        for(int j=1; j<=M; ++j) {\n            for(int k=0; k<=j; ++k) {\n                cmb[i][j][k] = cmb[i][j-1][k] * (1 - P[i]) + (k-1 >= 0 ? cmb[i][j-1][k-1] * P[i] : 0);\n            }\n        }\n    }\n    for(int i=0; i<N; ++i) {\n        if(V[i] == 0) {\n            cout << 0 << endl;\n            continue;\n        }\n        double res = 0;\n        for(int j=0; j<=M; ++j) {\n            double t = L / V[i] + T[i] * j;\n            double p = cmb[i][M][j];\n            for(int k=0; k<N; ++k) {\n                if(i == k || V[k] == 0) {\n                    continue;\n                }\n                double tt = L / V[k];\n                if(T[k] == 0 && tt - t <= 0) {\n                    p = 0;\n                    break;\n                }\n                int cnt = (T[k] == 0 ? 0 : ceil(max(0.0, t - tt) / T[k]));\n                if(tt + T[k] * cnt - t < eps) {\n                    cnt += 1;\n                } \n                double pp = 0;\n                for(int l=cnt; l<=M; ++l) {\n                    pp += cmb[k][M][l];\n                }\n                p *= pp;\n            }\n            res += p;\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(abs(p[i]-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p[i],m);\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = (prob[i][j-1] * p[i] * (m-j+1))/( (1-p[i]) * j );\n      }\n    }\n  }\n  for(int i=0;i<n;i++){\n    double sum = 0.0;\n    for(int j=0;j<=m;j++){\n      cout << prob[i][j] << \" \";\n      sum += prob[i][j];\n    }\n    cout << endl;\n    cout << sum << endl;\n  }\n\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ndouble binom(int m,int k,double p)\n{\n\tdouble x=pow(p,k)*pow(1-p,m-k);\n\tfor(int i=0;i<k;i++)\n\t\tx*=(m-i)/(i+1.);\n\treturn x;\n}\n\nint main()\n{\n\tfor(int n,m,L;cin>>n>>m>>L;){\n\t\tvector<double> ps(n);\n\t\tvector<int> ts(n),vs(n);\n\t\tfor(int i=0;i<n;i++) cin>>ps[i]>>ts[i]>>vs[i],ps[i]/=100;\n\t\t\n\t\tvector<vector<double>> ss(n,vector<double>(m+1));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t\tss[i][j]=binom(m,j,ps[i]);\n\t\t\n\t\tvector<double> res(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tdouble temp=1;\n\t\t\t\tfor(int k=0;k<n;k++) if(k!=i){\n\t\t\t\t\tdouble win=0;\n\t\t\t\t\tfor(int l=0;l<=m;l++)\n\t\t\t\t\t\t// l/vs[i]+j*ts[i] < l/vs[k]+l*ts[k]\n\t\t\t\t\t\tif((L+j*ts[i]*vs[i])*vs[k]<(L+l*ts[k]*vs[k])*vs[i])\n\t\t\t\t\t\t\twin+=ss[k][l];\n\t\t\t\t\ttemp*=win;\n\t\t\t\t}\n\t\t\t\tres[i]+=ss[i][j]*temp;\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tprintf(\"%.8f\\n\",res[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nlong double fact(int x){\n\tlong double r=1;\n\twhile(x){\n\t\tr*=x--;\n\t}\n\treturn r;\n}\n\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tdouble ap[100][51],acp[100][52]={{}};\n\tdouble at[100][51];\n\tfor(int i=0;i<n;i++){\n\t\tdouble p,t,v;\n\t\tcin>>p>>t>>v;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tat[i][j]=l/v+t*j;// time for athlete i to rest for j times\n\t\t\tap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);// probability to rest for j times\n\t\t\tacp[i][j+1]=acp[i][j]+ap[i][j];// sum of probability of less than j rests\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdouble a=0;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tdouble c=ap[i][j];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(i!=k){\n\t\t\t\t\tint x=upper_bound(at[k],at[k]+m+1,at[i][j]+1e-9)-at[k];\n\t\t\t\t\tc*=1-acp[k][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\ta+=c;\n\t\t}\n\t\tcout<<fixed<<a<<endl;   \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[2][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[0][0]=1;\n        for (int i=1;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n, m;\ndouble l;\ndouble p[100], t[100], v[100];\ndouble cb[100][51];\n\nvoid init(){\n\trep(u,n){\n\t\trep(i,m+1){\n\t\t\tint j = m-i;\n\t\t\tcb[u][i] = 1.0;\n\t\t\tint cnt1 = i, cnt2 = j;\n\t\t\tfor(int k = 1; k <= i; k++){\n\t\t\t\tcb[u][i] = cb[u][i]*(m-k+1)/k;\n\t\t\t\twhile(cb[u][i] > 1.0){\n\t\t\t\t\tif(cnt1 > 0){\n\t\t\t\t\t\tcb[u][i] *= p[u];\n\t\t\t\t\t\tcnt1--;\n\t\t\t\t\t} else if(cnt2 > 0){\n\t\t\t\t\t\tcb[u][i] *= (1-p[u]);\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt1 == 0 && cnt2 == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,cnt1) cb[u][i] *= p[u];\n\t\t\trep(k,cnt2) cb[u][i] *= (1-p[u]);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] *= 0.01;\n\t}\n\tinit();\n\trep(i,n){\n\t\tdouble pos;\n\t\t//double ti;\n\t\tdouble ans = 0.0;\n\t\tif(v[i] == 0.0){\n\t\t\tputs(\"0.00000000000\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tpos = cb[i][j];\n\t\t\trep(k,n){\n\t\t\t\tif(k == i) continue;\n\t\t\t\tif(v[k] == 0.0) continue;\n\t\t\t\tif(t[k] == 0.0){\n\t\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] > 0) pos *= 0.0;\n\t\t\t\t\telse pos *= 1.0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] < 0) c = 0;\n\t\t\t\telse c = ((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k])/((int)t[k]*(int)v[i]*(int)v[k]) + 1;\n\t\t\t\tdouble tmp = 0.0;\n\t\t\t\tfor(int l = c; l <= m; l++){\n\t\t\t\t\ttmp += cb[k][l];\n\t\t\t\t}\n\t\t\t\tpos *= tmp;\n\t\t\t}\n\t\t\tans += pos;\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint N,M,L;\ndouble X[105];\nint T[105],V[105];\ndouble C[105][105];\ndouble P[105][55];\ndouble rest[105][55];\ndouble ans[105];\ninline void calC()\n{\n\tint i,j;C[0][0]=1;C[1][0]=1;C[1][1]=1;\n\tfor(i=2;i<=50;i++)\n\t{\n\t\tC[i][i]=1;C[i][0]=1;\n\t\tfor(j=1;j<i;j++)\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t}\n}\ninline void calR()\n{\n\tint i,j;\n\tfor(i=1;i<=N;i++)\n\t{\n\t\trest[i][0]=L*1.0/(V[i]*1.0);\n\t\tfor(j=1;j<=M;j++)\n\t\t\trest[i][j]=rest[i][j-1]+T[i];\n\t}\n}\ninline void calP()\n{\n\tint i,j;\n\tfor(i=1;i<=N;i++)\n\t\tfor(j=0;j<=M;j++)\n\t\t\tP[i][j]=C[M][j]*pow(X[i],j*1.0)*pow((1-X[i]),(M-j)*1.0);\n}\ninline double cal(int pos,double MAXN)\n{\n\tint i,j;double temp;\n\tdouble ret=1.0;\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tif(i==pos)\n\t\t\tcontinue;\n\t\ttemp=0.0;\n\t\tfor(j=M;j>=0&&rest[i][j]>MAXN;j--)\n\t\t\ttemp+=P[i][j];\n\t\tret*=temp;\n\t}\n\treturn ret;\n}\ninline void solve()\n{\n\tint i,j;\n\tcalC();calR();calP();\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tans[i]=0.0;double temp=1.0;\n\t\tfor(j=0;j<=M;j++)\n\t\t\tans[i]+=P[i][j]*cal(i,rest[i][j]);\n\t}\n\tfor(i=1;i<=N;i++)\n\t\tprintf(\"%.7lf\\n\",ans[i]);\n}\nint main()\n{\n\tint i,a,b,c;\n\tscanf(\"%d%d%d\",&N,&M,&L);\t\n\tfor(i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tX[i]=a*1.0/100;T[i]=b;V[i]=c;\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MAXM = 55;\n\n\nint N, M, L;\nint P[MAXN], T[MAXN], V[MAXN];\nlong long C[MAXM][MAXM];\nvoid init() {\n    C[0][0] = 1;\n    for(int i = 1; i < MAXM; i++) {\n        C[i][0] = 1;\n        for(int j = 1; j <= i; j++)\n            C[i][j] = C[i][j - 1] * (i - j + 1) / j;\n    }\n}\n\ndouble ans[MAXN];\nvoid calc(int cur_id) {\n    if(V[cur_id] == 0) {\n        ans[cur_id] = 0;\n        return ;\n    }\n    double res = 0;\n    for(int k = 0; k <= M; k++) {\n        double ts = 1.0 * L / V[cur_id] + T[cur_id] * k;\n        double pk = pow(1.0 * P[cur_id] / 100, k) * pow(1 - 1.0 * P[cur_id] / 100, M - k) * C[M][k];\n        double res1 = 1;\n        for(int i = 0; i < N; i++) if(i != cur_id) {\n            if(V[i] == 0) continue;\n            double ti = 1.0 * L / V[i];\n            if(T[i] == 0) {\n                res1 *= ts < ti ? 1 : 0;\n                continue;\n            }\n            int k = (int)((ts - ti) / T[i] + 1.00000001);\n            if(k < 0) continue;\n            //k++;\n            double pi = 0;\n            for(int j = k; j <= M; j++) {\n                pi += pow(1.0 * P[i] / 100, j) * pow(1 - 1.0 * P[i] / 100, M - j) * C[M][j];\n            }\n            res1 *= pi;\n        }\n        res += res1 * pk;\n    }\n\n    ans[cur_id] = res;\n}\nint main() {\n  //  freopen(\"in.txt\", \"r\", stdin);\n    init();\n    while(scanf(\"%d%d%d\", &N, &M, &L) != EOF) {\n        for(int i = 0; i < N; i++)\n            scanf(\"%d%d%d\", &P[i], &T[i], &V[i]);\n        for(int i = 0; i < N; i++) {\n            calc(i);\n        }\n        for(int i = 0; i < N; i++)\n            printf(\"%.10f\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    for (int i = 0; i < N; i++)\n        P[i] = P[i] / 100.;\n\n    vector<vector<double> > times(N, vector<double>(M + 1)), prob(N, vector<double>(M + 1));\n    for (int i = 0; i < N; i++)\n        times[i][0] = (double)L / V[i];\n\n    vector<vector<int> > comb(M + 1, vector<int>(M + 1));\n    for (auto& i : comb) i[0] = 1;\n    for (int i = 1; i <= M; i++)\n        for (int j = 1; j <= M; j++) {\n            int up = comb[i-1][j];\n            int left = comb[i-1][j-1];\n            comb[i][j] = up + left;\n        }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= M; j++) {\n            if (j > 0) times[i][j] = times[i][j-1] + T[i];\n            prob[i][j] = pow(P[i], j) * pow(1.000 - P[i], M - j) * comb[M][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        double ans = 0.0000;\n        for (int j = 0; j <= M; j++) {\n            double tmp = 1.0000;\n            for (int k = 0; k < N; k++) {\n                if (k == i) continue;\n                double sum = 0.0000;\n                for (int l = 0; l <= M; l++) {\n                    if (times[i][j] < times[k][l]) sum += prob[k][l];\n                }\n                tmp *= sum;\n            }\n            ans += prob[i][j] * tmp;\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>;\n\nld comb(ll l, ll r) {\n\tld res = 1;\n\tREP(i, r) {\n\t\tres *= l - i;\n\t\tres /= i + 1;\n\t}\n\treturn res;\n}\n\n// [person][rest-number] -> prob\nvector<vector<ld>> calc_prob_table(const vector<ar3>& info, const int M) {\n\tconst int N = info.size();\n\tvector<vector<ld>> res(N, vector<ld>(M + 1));\n\tREP(i, N)REP(j, M + 1) {\n\t\tld rest = info[i][0];\n\t\tres[i][j] = comb(M, j)*powl(rest / 100., j)*powl(1 - rest / 100., M - j);\n\t}\n\t//REP(i, N)REP(j, M - 1)res[i][j + 1] += res[i][j];\n\treturn res;\n}\n\nld lose_prob(const vector<ld>& prob, ar3 info, ld time, const ld L) {\n\tconst int M = prob.size();\n\ttime -= L / info[2];\n\tif (info[1] == 0) {\n\t\ttime = INF;\n\t}\n\telse {\n\t\ttime /= (ld)info[1];\n\t}\n\n\tld res = 0;\n\tREP(i, min(time + 1e-3, (ld)M)) {\n\t\tres += prob[i];\n\t}\n\treturn 1 - res;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<ar3> info(N);\n\tREP(i, N)REP(j, 3)cin >> info[i][j];\n\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tauto table = calc_prob_table(info, M);\n\tREP(i, N) {\n\t\tld res = 0;\n\t\tREP(rest, M + 1) {\n\t\t\tld tres = table[i][rest];\n\t\t\tld time = (ld)L / info[i][2] + info[i][1] * rest;\n\t\t\tREP(opp, N)if (opp != i) {\n\t\t\t\ttres *= lose_prob(table[opp], info[opp], time, L);\n\t\t\t}\n\t\t\tres += tres;\n\t\t}\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//10\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nlong double fact(int x){\n  long double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n\tif(i!=k){\n\t  int x=upper_bound(at[k],at[k]+m+1,at[i][j]+1e-9)-at[k];\n\t  c*=1-acp[k][x];\n\t}\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_M 50\n#define INF (1<<29)\n\nint main()\n{\n    int N, M;\n    double L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n    double p[MAX_N][MAX_M+1][MAX_M+1];\n    memset(p, 0, sizeof(p));\n\n    for (int i = 0; i < N; i++) {\n        p[i][0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k < M; k++) {\n                p[i][j+1][k]   += p[i][j][k] * (1 - P[i]);\n                p[i][j+1][k+1] += p[i][j][k] * P[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        double res = 0;\n        for (int j = 0; j <= M; j++) {\n            double r = 1;\n            bool win = 1;\n            for (int k = 0; k < N; k++) {\n                if (i == k) {\n                    continue;\n                }\n                double rr = 0;\n                bool ok = 0;\n                for (int l = M; l >= 0; l--) {\n                    if (V[k]*L+V[k]*V[i]*T[i]*j <\n                        V[i]*L+V[i]*V[k]*T[k]*l) {\n                        ok = 1;\n                        rr += p[k][M][l];\n                    } else {\n                        break;\n                    }\n                }\n                if (!ok) {\n                    win = 0;\n                    break;\n                }\n                r *= rr;\n            }\n            res += (win ? r * p[i][M][j] : 0);\n        }\n        printf(\"%.8f\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define eps (1e-7)\n#define inf 10000000\nstruct node\n{\n    double p,t,v;\n    double time[60];\n    double po[60];\n    double posum[60];\n    double ans;\n}me[109];\nlong long f[60][60];\ndouble solve(double p, int k, int m)\n{\n    double res = f[m][k];\n    int i,j;\n    for(i = 1; i <= k; i++)\n    res *= p;\n    for(i = 1; i <= m - k; i++)\n    res *= (1.0 - p);\n    return res;\n}\nint main()\n{\n    int m,n,i,j,k,x,flag;\n    double l,ss;\n    for(i = 1; i < 55; i++)\n    {\n    f[i][0] = 1;\n    f[i][i] = 1;\n    f[i][1] = i;\n    }\n    for(i = 2; i <= 53; i++)\n        for(j = 1; j <= i; j++)\n        f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        while(~scanf(\"%d%d%lf\",&n,&m,&l))\n        {\n        for(i = 1; i <= n; i++)\n        {\n            scanf(\"%lf%lf%lf\",&me[i].p,&me[i].t,&me[i].v);\n            me[i].posum[0] = 0;\n            for(j = 1; j <= m + 1; j++)\n            {\n            me[i].posum[j] = 0;\n            if(me[i].v != 0)\n            {\n            me[i].time[j] = l / me[i].v + (j - 1) * me[i].t;\n            me[i].po[j] = solve(me[i].p / 100,j - 1,m);\n            me[i].posum[j] = me[i].posum[j - 1] + me[i].po[j];\n            }\n            else\n            {\n            me[i].time[j] = inf;\n            me[i].po[j] = 0;\n            me[i].posum[j] = 0;\n            }\n            }\n        }\n            for(i = 1; i <= n; i++)\n            {\n                me[i].ans = 0;\n                for(j = 1; j <= m + 1; j++)\n                {\n                    ss = me[i].po[j];\n                    for(k = 1; k <= n; k++)\n                    if(i == k);\n                    else\n                    {\n                        flag = 0;\n                        for(x = 1; x <= m + 1; x++)\n                        if(me[i].time[j] < me[k].time[x] )\n                        {\n                        ss *= (1.0 - me[k].posum[x - 1]);\n                        flag = 1;\n                        break;\n                        }\n                        if(flag == 0)\n                        break;\n                    }\n                    if(flag == 0)\n                    break;\n                    me[i].ans += ss;\n                }\n            }\n            for(i = 1; i <= n; i++)\n            printf(\"%lf\\n\",me[i].ans);\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint N,M,L;\ndouble a[105][105],b[105][105],t[105][105],P,T,V;\n\nlong double f(int x)\n{\n\tlong double r=1;\n\tfor(;x;)r*=x--;\n\treturn r;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%lf%lf%lf\",&P,&T,&V);\n\t\tfor(int j=0;j<=M;j++)\n\t\t{\n\t\t\tt[i][j]=L/V+T*j;\n\t\t\ta[i][j]=pow(P/100,j)*pow(1-P/100,M-j)*f(M)/f(j)/f(M-j);\n\t\t\tb[i][j+1]=b[i][j]+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tdouble n=0;\n\t\tfor(int j=0;j<=M;j++)\n\t\t{\n\t\t\tdouble c=a[i][j];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\tif(i!=k)\n\t\t\t\t{\n\t\t\t\t\tint x=upper_bound(t[k],t[k]+M+1,t[i][j]+1e-9)-t[k];\n\t\t\t\t\tc*=1-b[k][x];\n\t\t\t\t}\n\t\t\tn+=c;\n\t\t}\n\t\tprintf(\"%.8f\\n\",n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#define maxn 105\n\nusing namespace std;\ndouble dp[maxn][maxn];\ndouble dt[maxn][maxn];\ndouble sum[maxn][maxn]={0};\ndouble ans[maxn]={0};\nlong long num[maxn][maxn]={0};\nint p[maxn],v[maxn],t[maxn];\nlong long getc(int k,int s)\n{\n    if(k*2>s)k=s-k;\n    if(k==0)return 1;\n    if(k==1)return s;\n    if(num[k][s])return num[k][s];\n    num[k][s]=getc(k,s-1)+getc(k-1,s-1);\n    return num[k][s];\n}\nint n,m,l;\n/*\ndouble pow(int a,int k,long long b)\n{\n    double ans=b;\n    for(int i=0;i<k;i++)\n    {\n        ans=ans*a/100;\n    }\n    for(int i=0;i<m-k;i++)\n     ans=ans*(100-a)/100;\n    return ans;\n}*/\nvoid work()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(v[i]==0)continue;\n        for(int j=0;j<=m;j++)\n        {\n            double temp=dp[i][j];\n            for(int k=1;k<=n;k++)\n            {\n                if(k==i)continue;\n                int where=upper_bound(dt[k],dt[k]+m+1,dt[i][j])-dt[k];\n                if(where==m+1)temp=0;\n                else temp*=sum[k][where];\n            }\n            ans[i]+=temp;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(ans[i]<0)ans[i]=0;\n        printf(\"%.8lf\\n\",ans[i]);\n    }\n}\nint main()\n{\n //   freopen(\"in.txt\",\"r\",stdin);\n //   freopen(\"out.txt\",\"w\",stdout);\n    scanf(\"%d%d%d\",&n,&m,&l);\n    for(int i=1;i<=n;i++)\n     scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n    for(int i=1;i<=n;i++)\n    {\n        if(v[i]==0)\n        {\n            ans[i]=0;\n            continue;\n        }\n        double temp=(double)l/v[i];\n        double tp=(double)p[i]/100.0;\n        double tq=(double)(100-p[i])/100.0;\n        for(int j=0;j<=m;j++)\n        {\n          //  long long temp3=getc(j,m);\n           // dp[i][j]=pow(p[i],j,temp3);\n            dp[i][j]=(double)getc(j,m)*(double)pow(tp,j)*(double)pow(tq,m-j);\n            dt[i][j]=temp+t[i]*j;\n        }\n        for(int j=m;j>=0;j--)\n        {\n            if(j==m)sum[i][j]=dp[i][j];\n            else sum[i][j]=dp[i][j]+sum[i][j+1];\n        }\n    }\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.8f\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[2][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n#define LL long long\ndouble p[105];\nint t[105];\nint v[105];\ndouble dp[105][105];\ndouble sum[105][105];\nLL c[55][55];\n\n\nint main(){\n\tint n,m,l;\n\tcin >> n >> m >> l;\n\tfor(int i = 0;i < n;i++){\n\t\tint a;\n\t\tscanf(\"%d%d%d\",&a,&t[i],&v[i]);\n\t\tp[i] = a/100.0;\n\t}\n\tfor(int i = 0;i <= m;i++){\n\t\tc[i][0] = 1;\n\t\tc[i][i] = 1;\n\t\tfor(int j  =1 ;j < m;j++){\n\t\t\tc[i][j] = c[i-1][j-1] + c[i][j-1];\n\t\t}\n\t}\t\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j <= m;j++){\n\t\t\tdp[i][j] = c[m][j]*pow(p[i],j) * pow(1-p[i],m-j);\n\t\t}\n\t\tsum[i][m] = dp[i][m];\n\t\tfor(int j = m-1;j >= 0;j--){\n\t\t\tsum[i][j] = sum[i][j+1] + dp[i][j]; \n\t\t}\n\t}\n\t\n\tfor(int i = 0;i < n;i++){\n\t\tdouble ans = 0;\n\t\tfor(int j = 0;j <= m;j++){\n\t\t\tdouble ut = l*1.0/v[i] + j * t[i];\n\t\t\tdouble pq = dp[i][j];\n\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\tif(i!=k){\n\t\t\t\t\tint g = 0;\n\t\t\t\t\tdouble cur = l*1.0/v[k];\n\t\t\t\t\tif(cur > ut){\n\t\t\t\t\t\tpq *= 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(t[k] == 0){\n\t\t\t\t\t\tpq *= 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tint g = floor((ut-cur)*1.0/t[k]);\n\t\t\t\t\t\tcur += g * t[k];\t\t\t\t\t\t\n\t\t\t\t\t\twhile(cur <= ut && g <= m){\n\t\t\t\t\t\t\tcur += t[k];\n\t\t\t\t\t\t\tg++;\n\t\t\t\t\t\t} \n\t\t\t\t\t\tif(g  <= m){\n\t\t\t\t\t\t\tpq *= sum[k][g];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tpq *= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tans += pq;\n\t\t}\n\t\tprintf(\"%.8f\\n\",ans); \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <map>\ntypedef long long LL ;\n#define lson(x)(x << 1)\n#define rson(x)(x << 1 | 1)\n#define clr(a)(memset(a, 0, sizeof(a)))\n#define CLR(a)(memset(a, -1, sizeof(a)))\n#define lson l, mid, rt<<1\n#define rson mid+1, r, rt<<1|1\n#define eps 1e-12\n#define N 110\n#define INF 1<<29\nusing namespace std;\ntypedef pair <int, int> pii ;\nint dir[4][2] ={-1, 0, 0, 1, 0, -1, 1, 0} ;\n\nstruct Player{\n    double c[N] ;\n    double p[N] ;\n    double sum[N] ;\n}s[N] ;\n\nint n, m, l ;\nint p[N], t[N], v[N] ;\ndouble c[N][N] ;\ndouble ans[N] ;\n\n\nvoid init(){\n    clr(c) ;\n    c[0][0] = 1 ;\n    int n = 100 ;\n    for(int i=1; i<=n; i++){\n        c[i][0] = 1 ;\n        for(int j=1; j<=i; j++){\n            c[i][j] = c[i-1][j] + c[i-1][j-1] ;\n        }\n    }\n}\n\ndouble Pow(double p, int n){\n    double res = 1 ;\n    while(n--) res *= p  ;\n    return res ;\n}\n\nvoid deal(int idx){\n    double pro = p[idx] / 100.0 ;\n    for(int i=0; i<=m; i++){\n        s[idx].p[i] = c[m][i] * Pow(pro, i) * Pow((1-pro), m - i) ;\n        s[idx].c[i] = (double)i * t[idx] + l * 1.0 / (double)v[idx] ;\n    }\n}\n\ndouble cal(int idx, double t){\n    double res = 1 ;\n    for(int i=1; i<=n; i++){\n        if(i == idx)    continue ;\n        int k = upper_bound(s[i].c, s[i].c + m + 2, t+eps) - s[i].c ;\n        res = res * s[i].sum[k] ;\n    }\n    return res ;\n}\n\ndouble win(int idx){\n    double res = 0 ;\n    for(int i=0; i<=m; i++){\n        res += s[idx].p[i] * cal(idx, s[idx].c[i]) ;\n    }\n    return res ;\n}\n\nvoid pre(int idx){\n    s[idx].sum[m+1] = 0 ;\n    for(int i=m; i>=0; i--){\n        s[idx].sum[i] = s[idx].sum[i+1] + s[idx].p[i] ;\n    }\n}\n\nint main(){\n    freopen(\"input.txt\", \"r\", stdin) ;\n    init() ;\n    scanf(\"%d %d %d\", &n, &m, &l) ;\n    for(int i=1; i<=n; i++){\n        scanf(\"%d %d %d\", &p[i], &t[i], &v[i]) ;\n    }\n    for(int i=1; i<=n; i++){\n        deal(i) ;\n    }\n    for(int i=1; i<=n; i++){\n        pre(i) ;\n    }\n    /*\n    for(int i=1; i<=n; i++){\n        for(int j=0; j<=m; j++){\n            printf(\"%d : %lf %lf\", j, s[i].p[j], s[i].c[j]) ;\n        }\n        puts(\"\") ;\n    }\n    */\n\n    for(int i=1; i<=n; i++){\n        ans[i] = win(i) ;\n    }\n    for(int i=1; i<=n; i++){\n        printf(\"%lf\\n\", ans[i]) ;\n    }\n    return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <string>\nusing namespace std;\n#define min(a,b) a<b?a:b;\n#define max(a,b) a>b?a:b;\n#define LL long long\nconst int N = 210;\nconst double eps = 1e-8;\ndouble p[N][N],ans[N];//\ndouble zu[N][N];\nint n;\nstruct node{\n\tdouble p,t,v;\n}data[N];\nvoid zuhe()\n{\n\tmemset(zu,0,sizeof(zu));\n\tint i,j;\n\tfor(i=0;i<=50;i++)//i=0,会wa\n\t{\n\t\tzu[i][0]=1;\n\t\tzu[i][1]=i;\n\t}\n\tfor(i=1;i<=50;i++)\n\t\tfor(j=1;j<=i;j++)\n\t\t\tzu[i][j]=zu[i-1][j]+zu[i-1][j-1];\n}\nint main()\n{\n\tint i,j,z,k,m,l;\n\tdouble sum,res,time1,time2;\n\tzuhe();\n\twhile(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tscanf(\"%lf%lf%lf\",&data[i].p,&data[i].t,&data[i].v);\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t\tp[i][j]=zu[m][j]*pow(data[i].p/100.0,j*1.0)*pow((1-data[i].p/100.0),(m-j)*1.0);\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tans[i]=0;\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tres=p[i][j];\n\t\t\t\ttime1=j*data[i].t+l/data[i].v;\n\t\t\t\tfor(z=1;z<=n;z++)\n\t\t\t\t{\n\t\t\t\t\tsum=0;\n\t\t\t\t\tif(z==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(k=0;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttime2=k*data[z].t+l/data[z].v;\n\t\t\t\t\t\tif(time1<time2)\n\t\t\t\t\t\t\tsum+=p[z][k];\n\t\t\t\t\t}\n\t\t\t\t\tres*=sum;\n\t\t\t\t}\n\t\t\t\tans[i]+=res;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"%.8lf\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n\n\n\n/*\n2 2 50\n30 50 1\n30 50 2\n\n2 1 100\n100 100 10\n0 100 1\n\n3 1 100\n50 1 1\n50 1 1\n50 1 1\n\n2 2 50\n30 0 1\n30 50 2\n\n  */"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble pt[101][101];\nint dat[101][3],n,m,l;\n\nbool readin()\n{\n\tif(scanf(\"%d%d%d\",&n,&m,&l)!=3) return false;\n\tfor(int i=1;i<=n;++i)\n\t scanf(\"%d%d%d\",&dat[i][0],&dat[i][1],&dat[i][2]);\n    return true;\n}\n\nint com(int m,int n)    \n{    \n   if(m==1)    \n     return n;    \n   else    \n     return com(m-1,n)*(n-m+1)/m;    \n}   \n\n\n\ndouble cal(int i,int j)\n{\n\tdouble mid=0,m1,m2,p1=(double)dat[i][0]/100,p2=(double)dat[j][0]/100;\n\tdouble t1=(double)l/dat[i][2],t2=(double)l/dat[i][1];\n\tfor(int k=0;k<=m;++k)\n\t{\n\t\tdouble nt1=t1+k*dat[i][1];\n\t\tint k1=min((int)floor((nt1-t2)/dat[j][1]),m);\n\t\tm1=(double)com(k,m)*pow(p1,k)*pow(1-p1,m-k);\n\t\tm2=(double)com(k1,m)*pow(p2,k1)*pow(1-p2,m-k1);\n\t\tmid+=m1*m2;\n\t}\n\tpt[i][j]=mid;\n\treturn mid;\n}\n\nmain()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\twhile(readin())\n\t{\n\t\tfor(int i=1;i<=n-1;++i)\n\t\t for(int j=i+1;j<=n;++j)\n\t\t  pt[j][i]=1-cal(i,j);\n\t    double mid=0;\n\t    for(int i=1;i<=n;++i)\n\t    {\n\t    \tmid=1;\n    \t\tfor(int j=1;j<=n;++j)\n   \t\t    {\n    \t\t   \tif(i==j) continue;\n    \t\t   \tmid*=pt[i][j];\n \t\t    }\n \t\t    printf(\"&lf\\n\",mid);\n    \t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nconst double inf = 1.0e100;\nconst double eps = 1e-6;\nconst int MAXN = 102;\nconst int MAXM = 52;\nint N, M;\ndouble L;\ndouble P[MAXN];\ndouble T[MAXN];\ndouble V[MAXN];\nlli comb[MAXM][MAXM];\n\nvector<double> U[MAXN];\nvector<double> Q[MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvoid make() {\n  comb[0][0] = 1;\n  for(int i = 1; i < MAXM; ++i) {\n    for(int j = 0; j <= i; ++j) {\n      comb[i][j] = 0;\n      if(j) comb[i][j] += comb[i-1][j-1];\n      if(j <= i-1) comb[i][j] += comb[i-1][j];\n    }\n  }\n}\n\nint main() {\n  make();\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n\n    for(int i = 0; i < MAXN; ++i) {\n      U[i].clear();\n      Q[i].clear();\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int k = 0; k <= M; ++k) { // rest k times.\n\tif(V[i] == 0.0) U[i].push_back(inf);\n\telse U[i].push_back(L/V[i] + T[i]*k);\n\tQ[i].push_back(pow(P[i],k)*pow(1.0-P[i],M-k)*comb[M][k]);\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      double res = 0.0;\n      for(int k = 0; k <= M; ++k) {\n\tif(V[i] == 0.0) break;\n\tdouble tmp = Q[i][k];\n\tfor(int j = 0; j < N; ++j) {\n\t  if(i == j) continue;\n\t  /*\n\t  vector<double>::iterator it = \n\t    lower_bound(U[j].begin(), U[j].end(), U[i][k]);\n\t  */\n\t  double a = 0;\n\t  for(int b = 0; b < U[j].size(); ++b) {\n\t    if(equals(U[j][b], U[i][k]) || U[j][b] < U[i][k]) continue;\n\t    a += Q[j][b];\n\t  }\n\t  tmp *= a;\n\t}\n\tres += tmp;\n      }\n      printf(\"%.8f\\n\", res);\n    }\n    //puts(\"\");\n    return 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-12;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<double,int,double> tp;\ntypedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tdouble l;\n\tcin>>n>>m>>l;\n\tvt in;\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta/=100;\n\t\tdouble sum=0;\n\t\tvd dp(200);\n\t\tdp[100]=1;\n\t\trep(j,m){\n\t\t\tvd ndp(200);\n\t\t\trep(k,200)if(dp[k]>0){\n\t\t\t\tndp[k+1]+=dp[k]*a;\n\t\t\t\tndp[k-1]+=dp[k]*(1-a);\n\t\t\t}\n\t\t\tdp=ndp;\n\t\t}\n\t\trep(j,m+1){\n\t\t\tsum=dp[100-m+2*j];\n\t\t\tin.pb(tp(l/c+j*b,i,sum));\n\t\t}\n\t}\n\tsort(all(in));\n\tvd out(n);\n//\tdouble t=1;\n\tvd t(n,1);\n\trep(i,in.size()){\n\t\tdouble a,c;int b;\n\t\ttie(a,b,c)=in[i];\n//\t\tcout<<shosu(4)<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t\tvt tmp;\n\t\ttmp.pb(in[i]);\n\t\tt[b]-=c;\n\t\twhile(i!=in.size()-1){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=in[i+1];\n\t\t\tif(abs(a-d)<EPS){\n\t\t\t\ti++;\n\t\t\t\ttmp.pb(in[i]);\n\t\t\t\tt[e]-=f;\n\t\t\t}else break;\n\t\t}\n//\t\trep(j,t.size())cout<<\" \"<<t[j];cout<<endl;\n\t\trep(j,tmp.size()){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=tmp[j];\n\t\t\tdouble sum=f;\n\t\t\trep(k,n)if(k!=e)sum*=t[k];\n\t\t\tout[e]+=sum;\n\t\t}\n//\t\tcout<<t<<endl;\n\t}\n\trep(i,n)cout<<shosu(9)<<out[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<climits>\n#include<cstdio>\n#include<iomanip>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 500\n\nusing namespace std;\n\ndouble C[MAX][MAX];\n \nvoid makeC()\n{\n  C[0][0] = 1;\n  rep(i,MAX-1)rep(j,i+1)\n    {\n      C[i+1][j] += C[i][j];\n      if(j+1<MAX)C[i+1][j+1] += C[i][j];\n    }\n}\n\n\nint N,M;\ndouble L;\n\n\nint main(){\n\n  makeC();\n\n  cin >> N >> M >> L;\n  vector<double> P(N),T(N),V(N),PB[N],TM[N];\n\n  //cout << \"C[\" << M << \"][\" << 0 << \"] = \" << C[M][0] << endl;\n\n  rep(i,N){\n    cin >> P[i] >> T[i] >> V[i];\n    double p = P[i] / 100.0;\n    rep(j,M+1){\n      TM[i].push_back( L / V[i] + j * T[i] );\n      PB[i].push_back( C[M][j] * pow(p,j) * pow(1-p,M-j) );\n    }\n  }\n\n  rep(sp,N){\n    double ans = 0;\n    rep(i,TM[sp].size()){\n      double cost = 1;\n      rep(gp,N){\n\tdouble cost2 = 0;\n\tif(sp == gp)continue;\n\trep(j,TM[gp].size()){\n\t  if(TM[sp][i] >= TM[gp][j]){\n\t    cost2 += PB[gp][j];\n\t  } else break;\n\t}\n\tcost *= ( 1 - cost2 );\n      }\n      ans += cost * PB[sp][i];\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nlong double comb(int a, int b) {\n\tlong double ans = 1.0L;\n\tfor (int i = 0; i < b; ++i) {\n\t\tans *= (long double)(a - i);\n\t\tans /= (long double)(i + 1);\n\t}\n\treturn ans;\n}\n\nlong double prob(long double percent, int a, int b) {\n\tlong double ans = 1.0L;\n\tpercent /= 100.0L;\n\tfor (int i = 0; i < a; ++i) {\n\t\tif (i < b) {\n\t\t\tans *= percent;\n\t\t}\n\t\telse {\n\t\t\tans *= (1.0L - percent);\n\t\t}\n\t}\n\tans *= comb(a, b);\n\treturn ans;\n}\n\nvoid solve(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\tvector<tuple<int, int, long double>> inputs;\n\tREP(i, n) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tinputs.push_back(make_tuple(a, b, (long double)l / (long double)c));\n\t}\n\tREP(i, n) {\n\t\tlong double ans = 0;\n\t\tfor (int q = 0; q <= m; ++q) {\n\t\t\tlong double req_time = q * get<1>(inputs[i]);\n\t\t\treq_time += get<2>(inputs[i]);\n\t\t\tlong double pre = prob(get<0>(inputs[i]), m, q);\n\t\t\tREP(j, n) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tlong double tmp = 0.0L;\n\t\t\t\tfor (int t = 0; t <= m; ++t) {\n\t\t\t\t\tlong double now_time = t * get<1>(inputs[j]);\n\t\t\t\t\tnow_time += get<2>(inputs[j]);\n\t\t\t\t\tif (now_time > req_time + eps) {\n\t\t\t\t\t\ttmp += prob(get<0>(inputs[j]), m, t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre *= tmp;\n\t\t\t}\n\t\t\tans += pre;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(!v[i])continue;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=(int)(s-1.0*l/v[k]);\n\tif(s-1.0*l/v[k]<0)idx=0;\n\telse idx++;\n\tif(T<=idx){\n\t  x=0;\n\t  break;\n\t}\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nint fac(int a)\n{\n\tint ret = 1;\n\n\trep(i, 1, a + 1)\n\t{\n\t\tret *= i;\n\t}\n\n\treturn ret;\n}\n\n\n\n\nint aCb(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fac(a) / (fac(a - b) * fac(b));\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvi P(N), T(N), V(N);\n\trep(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n\tvvd per(N, vd(M+1, 0));\n\trep(i, 0, N)\n\t{\n\t\tdouble p = P[i] / 100.0;\n\t\tdouble pp = 1.0 - p;\n\t\trep(j, 0, M + 1) per[i][j] = pow(pp, M - j) * pow(p, j) * (double)aCb(M, j);\n\t}\n\n\tvvd imos(N, vd(M + 2, 0));\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, M + 1) imos[i][j] = per[i][j];\n\t\trrep(j, M, 0) imos[i][j] += imos[i][j + 1];\n\t}\n\n\trep(i, 0, N)\n\t{\n\t\tdouble ans = 0;\n\t\trep(j, 0, M + 1)\n\t\t{\n\t\t\tdouble _ans = per[i][j];\n\t\t\tdouble deadline = (double)L / V[i] + (double)T[i] * j;\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tif (i == k) continue;\n\t\t\t\tdouble fastest = (double)L / V[k];\n\t\t\t\tif (deadline < fastest - EPS) continue;\n\n\t\t\t\tif (T[k] == 0)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint minrest = (deadline - fastest + T[k] - 1) / T[k];\n\t\t\t\tdouble test = fastest + T[k] * minrest;\n\t\t\t\tif (abs(deadline - test) < EPS) minrest++;\n\t\t\t\tif (M < minrest)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_ans *= imos[k][minrest];\n\t\t\t}\n\n\t\t\tans += _ans;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N];\nvector<double> A[N],B[N];\n\ndouble mem[M][M];\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  if(r==0||n==r)return 1;\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n    \n    A[i].resize(m+1),B[i].resize(m+1);\n    A[i][0]=B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]);\n      B[i][j]=B[i][j-1]*p[i];\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\nint sgn(const double&r){return (r>EPS)-(r<-EPS);} // a>0  : sgn(a)>0\nint sgn(const double&a,const double&b){return sgn(a-b);} // b<=c : sgn(b,c)<=0\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\nint mpow(int v, ll a) {\n    ll x = v, n = a, res = 1;\n    while ( n ) {\n        if ( n & 1 )res = res*x%MOD;\n        x = x*x%MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nclass mint {\nprivate:\n    ll v;\npublic:\n    static ll mod(ll a) { return ( a % MOD + MOD ) % MOD; }\n    mint(ll a = 0) { this->v = mod(a); };\n    mint(const mint &a) { v = a.v; }\n    mint operator+(const mint &a) { return mint(v + a.v); }\n    mint operator+(const ll a) { return mint(v + a % MOD); }\n    mint operator+(const signed a) { return mint(v + a % MOD); }\n    friend mint operator+(const ll a, const mint &b) { return mint(a % MOD + b.v); }\n    void operator+=(const mint &a) { v = ( v + a.v ) % MOD; }\n    void operator+=(const ll a) { v = mod(v + a % MOD); }\n    void operator+=(const signed a) { v = mod(v + a % MOD); }\n    friend void operator+=(ll &a, const mint &b) { a = mod(a % MOD + b.v); }\n    mint operator-(const mint &a) { return mint(v - a.v); }\n    mint operator-(const ll a) { return mint(v - a % MOD); }\n    mint operator-(const signed a) { return mint(v - a % MOD); }\n    friend mint operator-(const ll a, const mint &b) { return mint(a % MOD - b.v); }\n    void operator-=(const mint &a) { v = mod(v - a.v); }\n    void operator-=(const ll a) { v = mod(v - a % MOD); }\n    void operator-=(const signed a) { v = mod(v - a % MOD); }\n    friend void operator-=(ll &a, const mint &b) { a = mod(a % MOD - b.v); }\n    mint operator*(const mint &a) { return mint(v * a.v); }\n    mint operator*(const ll a) { return mint(v * ( a % MOD )); }\n    mint operator*(const signed a) { return mint(v * ( a % MOD )); }\n    friend mint operator*(const ll a, const mint &b) { return mint(a % MOD * b.v); }\n    void operator*=(const mint &a) { v = ( v * a.v ) % MOD; }\n    void operator*=(const ll a) { v = mod(v * ( a % MOD )); }\n    void operator*=(const signed a) { v = mod(v * ( a % MOD )); }\n    friend void operator*=(ll &a, const mint &b) { a = mod(a % MOD * b.v); }\n    mint operator/(const mint &a);\n    mint operator/(const ll a);\n    mint operator/(const signed a);\n    friend mint operator/(const ll a, const mint &b);\n    void operator/=(const mint &a);\n    void operator/=(const ll a);\n    void operator/=(const signed a);\n    friend void operator/=(ll &a, const mint &b);\n    mint operator^(const mint &a) { return mpow(v, a.v); };\n    mint operator^(const ll a) { return mpow(v, a); };\n    mint operator^(const signed a) { return mpow(v, a); };\n    friend mint operator^(const ll a, const mint &b) { return mpow(a, b.v); };\n    void operator^=(const mint &a) { v = mpow(v, a.v); }\n    void operator^=(const ll a) { v = mpow(v, a); }\n    void operator^=(const signed a) { v = mpow(v, a); }\n    mint operator+() { return *this; }\n    mint operator++() { v++; return *this; }\n    mint operator++(signed d) { mint res = *this; v++; return res;}\n    mint operator-() { return operator*(-1); }\n    mint operator--() { v--; return *this; }\n    mint operator--(signed d) { mint res = *this; v--; return res;}\n    bool operator==(mint &a) { return v == a.v; }\n    bool operator==(signed a) { return v == a; }\n    friend bool operator==(signed a, mint &b) { return a == b.v; }\n    bool operator!=(mint &a) { return v != a.v; }\n    bool operator!=(signed a) { return v != a; }\n    friend bool operator!=(signed a, mint &b) { return a != b.v; }\n    operator int() { return v; }\n};\nconst int setModMax = 510000;\nmint fac[setModMax], finv[setModMax], inv[setModMax];\nvoid setMod() {\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n    for ( int i = 2; i < setModMax; i++ ) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * ( MOD / i ) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nmint minv(ll a) {\n    if ( fac[0] == 0 )setMod();\n    if ( a < setModMax ) return inv[a];\n    a %= MOD;\n    ll b = MOD, x = 1, y = 0;\n    while ( b ) {\n        ll t = a / b;\n        a -= t*b; swap(a, b);\n        x -= t*y; swap(x, y);\n    }\n    return ( x % MOD + MOD ) % MOD;\n}\n\nmint mint::operator/(const mint &a) { return mint(v * minv(a.v)); }\nmint mint::operator/(const ll a) { return mint(v * minv(a)); }\nmint mint::operator/(const signed a) { return mint(v * minv(a)); }\nmint operator/(const ll a, const mint &b) { return mint(a % MOD * minv(b.v)); }\nvoid mint::operator/=(const mint &a) { v = ( v * minv(a.v) ) % MOD; }\nvoid mint::operator/=(const ll a) { v = mod(v * minv(a)); }\nvoid mint::operator/=(const signed a) { v = mod(v * minv(a)); }\nvoid operator/=(ll &a, const mint &b) { a = mint::mod(a % MOD * minv(b.v)); }\nauto&operator>>(istream&is,mint&t){ll a; cin>>a; t=a; return is;};\nauto&operator<<(ostream&os,mint&t){cout<<((int)t); return os;};\nmint operator\"\" _m(unsigned long long a){return mint(a);}\nusing vm=vector<mint>;\nusing vvm=vector<vm>;\nmint nCr(ll n,ll r){\n    if ( fac[0] == 0 )setMod();\n    return fac[n]*finv[r]*finv[n-r];\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,m,l;\n    cin>>n>>m>>l;\n    vd p(n),t(n),v(n);\n    rep(i,n){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n    vvd prec(n,vd(m+1,0));\n    vvd time(n,vd(m+1,0));\n    rep(i,n){\n        double p_rest = pow(1-p[i],m);\n        rep(j,m+1){\n            prec[i][j] = 1;\n            rep(k,j)prec[i][j] *= p[i];\n            rep(k,m-j)prec[i][j] *= (1-p[i]);\n            rep(k,j)prec[i][j] *= (m-k) / (double)(j-k);\n            // puta(i,j,prec[i][j]);\n            time[i][j] = v[i]==0 ? 1000000000.0 : l/v[i] + t[i] * j;\n        }\n    }\n    rep(i,n){\n        double ans=0;\n        rep(j,m+1){\n            double val = 1;\n            rep(k,n)if(i!=k){\n                double p_win = 0;\n                rep(q,m+1){\n                    if(time[i][j]<time[k][q])p_win += prec[k][q];\n                }\n                val *= p_win;\n            }\n            ans += val * prec[i][j];\n        }\n        fcout(8)<<ans<<endl;\n    }\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\n\nconst int MAX_N = 100 + 10;\nconst int MAX_M = 50 + 2;\nconst double eps = 0.0000000000001;\n\nstruct runner {\n    double p, t, v;\n    double tm[MAX_N], pp[MAX_M];\n} R[MAX_N];\n\nint C[MAX_M][MAX_M];\nvoid init()\n{\n    for (int i = 1; i < MAX_M; ++ i)\n    {\n        C[i][1] = i;\n        C[i][0] = C[i][i] = 1;\n    }\n    for (int i = 2; i < MAX_M; ++ i)\n        for (int j = 1; j < i; ++ j)\n            C[i][j] = C[i-1][j-1] + C[i-1][j];\n}\n\nint main(int argc, char *argv[])\n{\n    init();\n    int N, M, L;\n    while (cin >> N >> M >> L)\n    {\n        for (int i = 0; i < N; ++ i)\n            cin >> R[i].p >> R[i].t >> R[i].v;\n\n        for (int i = 0; i < N; ++ i)\n        {\n            for (int j = 0; j <= M; ++ j)\n            {\n                R[i].tm[j] = L/R[i].v + j * R[i].t;\n                R[i].pp[j] = C[M][j] * pow(R[i].p/100, j) * pow((100 - R[i].p)/100, M-j);\n            }\n        }\n\n        for (int i = 0; i < N; ++ i)\n        {\n            double ppp = 0;\n            for (int j = 0; j <= M; ++ j)\n            {\n                double pp = R[i].pp[j];\n                for (int ii = 0; ii < N; ++ ii)\n                {\n                    if (ii == i)\n                        continue;\n\n                    double p2 = 0;\n                    for (int jj = 0; jj <= M; ++ jj)\n                        if (R[ii].tm[jj] > R[i].tm[j])\n                            p2 += R[ii].pp[jj];\n                    pp *= p2;\n                }\n                ppp += pp;\n            }\n            printf(\"%.10lf\\n\", ppp);\n        }\n    } \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\t  if(N==1){\n\t\t\tcout << 1.0 << endl;\n\t\t\treturn 0;\n\t  }\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  if(p[i] != 100)\n\t\t\t\t\t\tprob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n\t\t\t\t  else\n\t\t\t\t\t\tprob[i][j] = 1.0;\n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t\t  if(sum[i][j] > 1) sum[i][j] = 1;\n\t\t\t}\n\t  }\n\t  /*\n\t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << dist[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << prob[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t   ans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  /*\n\t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << ans[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tif(p[i] == 100) tmp = ans[i][M];\n\t\t\telse\n\t\t\t\t  for(int j=0; j<=M; j++)\n\t\t\t\t\t\ttmp += ans[i][j];\n//\t\t\tcout << tmp << endl;\n\t\t\tif(tmp > 1) tmp = 0;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[100][100] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,L;\nint P[111],T[111],V[111];\n\ndouble Time[111][111];\ndouble pa[111][111];\ndouble ncr[111][111];\n\nconst double EPS = 1E-9;\nconst double INF = 1E50;\n\nvoid getncr(){\n  for(int i=0;i<=100;i++) ncr[i][i] = ncr[i][0] = 1LL;\n  for(int i=2;i<=100;i++)\n    for(int j=1;j<i;j++)\n      ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];\n      \t\n}\n\nint main(){\n  cin >> N >> M >> L;\n  for(int i=0;i<N;i++){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n\n  getncr();\n\n  for(int i=0;i<N;i++){\n    double ka = 1.0f;\n\n    if( P[i] == 100 ){\n      for(int j=0;j<=M;j++){\n\tif( V[i] == 0 )\n\t  Time[i][j] = INF;\n\telse\n\t  Time[i][j] = (double)L / (double)V[i] + (double)T[i]*(double)j;\t\n\tpa[i][j] = 0.0f;\n      }      \n      pa[i][M] = 1.0f;\n    } else {\n      for(int l=0;l<M;l++){\n\tka *= (double)(100-P[i])/100.0;\n      }\n      //  cout <<i << endl;\n      for(int j=0;j<=M;j++){\n\tif( V[i] == 0 )\n\t  Time[i][j] = INF;\n\telse\n\t  Time[i][j] = (double)L / (double)V[i] + (double)T[i]*(double)j;\n\t\n\tif( ka > 1.0 - EPS ) pa[i][j] = 1.0f;\n\telse pa[i][j] = ka*ncr[M][j];  \n\t\n\tka /= (double)(100-P[i])/100.0;\n\tka *= (double)P[i]/100.0;       \n      }\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    double res = 0.0f;\n    for(int j=0;j<=M;j++){\n\n      double H = Time[i][j];\n      double ret = 1.0f;\n      for(int k=0;k<N;k++){\n\tif( i == k ) continue;\n\tdouble kk = 0.0f;\n\n\tfor(int l=0;l<=M;l++){\n\t  // cout << H << \" \" << Time[k][l] << \" \" << pa[k][l] << endl;\n\t  if( Time[k][l] > H+EPS ){\n\t    //      cout << pa[k][l] << endl;\n\t    kk += pa[k][l];\n\t  }\n\t}\n\n\t//\tcout << \"k= \" << k << \" \"<< kk << endl;\n\tret *= kk;\n      }\n      // cout << \"i , j = \" << i << \" \"<< j << \" \"<< ret << \" * \" << pa[i][j] << \" \"<< ret*pa[i][j] << endl;\n      res += ret*pa[i][j];\n    }\n\n     printf(\"%.10lf\\n\",res);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Input parallel\ntemplate<typename T>\nvoid input_at(size_t idx, T& a) {\n    cin >> a[idx];\n}\ntemplate<typename T, typename... Ts>\nvoid input_at(size_t idx, T& a, Ts&... ts) {\n    input_at<T>(idx, a);\n    input_at<T>(idx, ts...);\n}\ntemplate<typename T>\nvoid input_parallel(T& a) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<T>(idx, a);\n    }\n}\ntemplate<typename T, typename...Ts>\nvoid input_parallel(T& a, Ts&... ts) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<Ts...>(idx, a, ts...);\n    }\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<typename Field>\nstruct Comb {\n    vector<vector<Field>> c;\n    Comb(int n) {\n        c.resize(n+1, vector<Field>(n+1));\n        for (int i = 0; i <= n; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                if (j == i || j == 0) {\n                    c[i][j] = Field{1};\n                } else {\n                    c[i][j] = c[i-1][j-1] + c[i-1][j];\n                }\n            }\n        }\n    }\n    Field operator()(int n, int r) {\n        return c[n][r];\n    }\n};\n\nint main()\n{\n    int n, m; cin >> n >> m;\n    double L; cin >> L;\n    vector<double> p(n), t(n), v(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> p[i] >> t[i] >> v[i];\n        p[i] /= 100;\n    }\n\n    auto comb = Comb<double>(m);\n    auto prob = make_v<double>(n, m+1);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            prob[i][j] = pow(p[i], j) * pow(1-p[i], m-j) * comb(m, j);\n        }\n    }\n\n    auto ans = make_v<double>(n, m+1);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            double time = L / v[i] + t[i] * j;\n\n            ans[i][j] = prob[i][j];\n            for (int k = 0; k < n; ++k) if (i != k) {\n                double _p = 0;\n                for (int l = 0; l <= m; ++l) {\n                    double _t = L / v[k] + t[k] * l;\n                    if (_t > time + EPS) break;\n                    _p += prob[k][l];\n                }\n                ans[i][j] *= (1 - _p);\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        double s = accumulate(ans[i].begin(), ans[i].end(), 0.);\n        printf(\"%.7lf\\n\", s);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n,m;\ndouble l;\nint t[101];\ndouble pp[101][51];\ndouble psum[101][51];\ndouble p[101],v[101];\ndouble tt[101][51];\ndouble win[101];\ndouble comb[101][101];\n\nint main(void){\n\tfor(int i=1;i<=100;i++){\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t}\n\t}\n\tscanf(\"%d %d %lf\",&n,&m,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %d %lf\",&p[i],&t[i],&v[i]);\n\t\tp[i]=p[i]/100.0;\n\t}\n\tfor(int j=0;j<n;j++){\n\t\tfor(int k=0;k<=m;k++){\n\t\t\tpp[j][k]=comb[m][k];\n\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\tpp[j][k]*=p[j];\n\t\t\t}\n\t\t\tfor(int l=0;l<m-k;l++){\n\t\t\t\tpp[j][k]*=(1.0-p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tpsum[i][j+1]=psum[i][j]+pp[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\ttt[i][0]=l/v[i];\n\t\tfor(int j=1;j<=m;j++){\n\t\t\ttt[i][j]=tt[i][j-1]+t[i];\n\t\t}\n\t\ttt[i][m+1]=1000000000.0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int l=0;l<=m;l++){\n\t\t\tdouble wp=pp[i][l];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tint uk=upper_bound(tt[k],tt[k]+m+2,tt[i][l])-tt[k];\n\t\t\t\twp*=(1.0-psum[k][uk]);\n\t\t\t\t//printf(\"%lf %lf %f\\n\",tt[i][l],tt[k][uk],psum[k][uk]);\n\t\t\t}\n\t\t\twin[i]+=wp;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%.10f\\n\",win[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n\n#define MAXX 51\n\nshort n,m,i,j,k,l;\nint len;\ndouble t;\ndouble ans,sum,sum1;\nlong long C[MAXX][MAXX];\ndouble mat[MAXX<<1][MAXX];\ndouble p[MAXX<<1][MAXX];\n\nstruct node\n{\n    short p,t,v;\n}run[MAXX];\n\nint main()\n{\n    for(i=1;i<MAXX;++i)\n    {\n        C[1][i]=i;\n        C[0][i]=1;\n        C[i][i]=1;\n    }\n    for(i=2;i<MAXX;++i)\n        for(j=2;j<=i;++j)\n            C[j][i]=C[j-1][i]*(i-j+1)/j;\n    scanf(\"%hd %hd %d\",&n,&m,&len);\n    for(i=0;i<n;++i)\n        scanf(\"%hd %hd %hd\",&run[i].p,&run[i].t,&run[i].v);\n    for(i=0;i<n;++i)\n    {\n        t=(double)len/run[i].v;\n        for(j=0;j<=m;++j)\n        {\n            p[i][j]=C[j][m];\n            for(k=0;k<j;++k)\n                p[i][j]*=(double)run[i].p/100;\n            for(k=0;k<m-j;++k)\n                p[i][j]*=(double)(100-run[i].p/100)/100;\n            mat[i][j]=t+j*run[i].t;\n        }\n    }\n    /*\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",mat[i][j]);\n        printf(\"\\n\");\n    }\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",p[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\\n\");\n    */\n    for(i=0;i<n;++i)\n    {\n        sum=0;\n        for(j=0;j<=m;++j)\n        {\n            ans=p[i][j];\n            for(k=0;k<n;++k)\n                if(i!=k)\n                {\n                    sum1=0;\n                    for(l=0;l<=m;++l)\n                        if(mat[i][j]<mat[k][l])\n                            sum1+=p[k][l];\n                    ans*=sum1;\n                }\n            sum+=ans;\n        }\n        printf(\"%f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\ndouble C[N][N];\n\ndouble prob[N][N];\ndouble _time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\tif (!v[i]) continue;\n\t\t_time[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) _time[i][j] = _time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tdouble a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tdouble ct = _time[i][j];\n\t\t\tdouble cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tdouble tmp = 0;\n\t\t\t\twhile (idx >= 0 && _time[k][idx] > ct - (1e-9)) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define eps 0.0000001\n\n\nbool zero(double a,double b){\n    if((a-b)<eps && (a-b)>-eps)return true;\n    return false;\n}\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][200];\ndouble sp[200][200];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p*p,k/2);\n    if(k%2==0)return ret;\n    else return ret*p;\n}\n\ndouble res[210];\ndouble tmp;\ndouble solve(double p,int m,int n)\n{\n    double ret=1;\n    for(int i=0;i<n;i++)\n    {\n        ret=ret*(m-i);\n        ret=ret/(i+1);\n        ret=ret*p;\n    }\n    for(int i=n;i<m;i++)\n    {\n        ret=ret*(1.0-p);\n    }\n    \n    return ret;\n}\nint main(){\n    \n    //freopen(\"D.in\", \"r\", stdin);\n    //freopen(\"D.out3\", \"w\", stdout);\n    \n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l) != EOF){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            //cout<<pl[i].p<<endl;\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=solve(pl[i].p,(int)m,(int)j);\n                //c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+pl[i].t*(double)j<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+pl[i].t*(double)j>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+pl[i].t*(double)j,l/pl[k].v+m*pl[k].t)){\n                            tmp=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+pl[i].t*(double)j-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp*rp[i][j];\n            }\n            if(res[i]<eps)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n        break;\n    }\n\n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] < 1e-10){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = 0;\n\t\t\t\tif(time >= base_time[k]){\n\t\t\t\t\trest = (time - base_time[k]) / t[k];\n\t\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t}\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nconst int MAX_N = 10000; //400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\nll nCr(int n, int r){\n    static bool done[MAX_N+1][MAX_N/2+2];\n    static ll dp[MAX_N+1][MAX_N/2+2]; // 400MB\n    if (n < 0 || r < 0 || n < r) return 0;\n    if (r==0) return 1;\n    if (r > n-r) r = n-r;\n    ll &res = dp[n][r];\n    if (done[n][r]) return res;\n    done[n][r] = true;\n    return res = (nCr(n-1,r-1)+nCr(n-1,r));\n}\n\nint N,M;\ndouble L;\ndouble P[120], T[120], V[120];\n\ndouble dp[110][60];\ndouble f(int i, int k){\n    double res = dp[i][k];\n    if(res==-1) res = nCr(M,k)*pow(P[i],k)*pow(1-P[i],M-k);\n    return res;\n}\n\nint main(){\n    while(cin >> N >> M >> L){\n        rep(i,N)rep(j,M+1) dp[i][j] = -1;\n        rep(i,N){\n            cin >> P[i] >> T[i] >> V[i];\n            P[i]/=100;\n        }\n        rep(i,N){\n            double ans = 0;\n            rep(j,M+1){\n                double t = L/V[i]+j*T[i];\n                double x = 1;\n                rep(ii,N)if(i!=ii){\n                    double y = 0;\n                    rep(jj,M+1){\n                        double tt = L/V[ii]+jj*T[ii];\n                        if(t<tt && abs(t-tt)>1e-10){\n                            y += f(ii,jj);\n                        }\n                    }\n                    x*=y;\n                }\n                ans += x*f(i,j);\n            }\n            printf(\"%.10lf\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N,M,L;\nstruct node\n{   double t,p;\n}per[101][51];\nlong long c[51][51]={0};\nvoid prepare()\n{   c[0][0]=1;c[1][0]=1;\n    for(int i=1;i<51;i++)\n    for(int j=0;j<51;j++)\n    {   if(j==0) c[i][j]=1;\n        else c[i][j]=c[i-1][j]+c[i-1][j-1];\n    }\n}\nint main()\n{   int T;\n    prepare();\n    cin>>N>>M>>L;\n    for(int i=0;i<N;i++)\n    {   double p,t,v;\n        cin>>p>>t>>v;p*=0.01;\n        per[i][0].t=L/v;\n        per[i][0].p=pow(1-p,M);\n        for(int j=1;j<=M;j++)\n        {   per[i][j].p=c[M][j]*pow(1-p,M-j)*pow(p,j);\n            per[i][j].t=per[i][j-1].t+t;\n        }\n    }\n//    for(int i=0;i<N;i++){\n//    for(int j=0;j<=M;j++)\n//    {   cout<<per[i][j].t<<'('<<per[i][j].p<<')'<<' ';\n//\n//    }puts(\"\");}\n    for(int i=0;i<N;i++)\n    {   double s=0;\n        for(int j=0;j<=M;j++)\n        {   double tt=per[i][j].p;\n            for(int k=0;k<N;k++)\n            if(k!=i)\n            {   double ts=0;\n                for(int t=M;t>=0 && per[k][t].t>per[i][j].t;t--)\n                {   ts+=per[k][t].p;\n                }\n                tt*=ts;\n               // cout<<ts<<endl;\n            }\n            s+=tt;\n        }\n        printf(\"%.8lf\\n\",s);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include <iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\nint n,m;\ndouble L;\nint tot;\nlong long flag[110];\nstruct Person\n{\n    int id;\n    double T;\n    double P;\n} person[5050];\ndouble x,y,z;\ndouble ans1[110],ans2[110];\nbool cmp(Person a,Person b)\n{\n    return a.T<b.T;\n}\nint main()\n{\n    while(~scanf(\"%d%d%lf\",&n,&m,&L))\n    {\n        tot=0;\n        flag[0]=1;\n        for(int i=1;i<=n;i++)\n        {ans1[i]=1.0;ans2[i]=0.0;}\n        for(int i=1;i<=m;i++)\n        {\n            flag[i]=flag[i-1]*(m+1-i)/i;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%lf%lf%lf\",&x,&y,&z);\n            double t=L/z;\n            x/=100.0;\n            double fuck=1.0;\n            for(int k=1;k<=m;k++)\n            fuck*=(1.0-x);\n            if((x!=1.0&&x!=0.0)&&y!=0.0)\n            {\n                for(int j=0;j<=m;j++)\n            {\n                double p;\n                if(j)  t+=y;\n                p=(double)flag[j]*fuck;\n                fuck=fuck*x/(1.0-x);\n                ++tot;\n                person[tot].P=p;\n                person[tot].T=t;\n                person[tot].id=i;\n                /*printf(\"%lf %lf %d %d\\n\",p,t,i,flag[j]);*/\n            }\n            }\n            else\n            {\n                ++tot;person[tot].P=1.0;\n                t+=m*y;\n                person[tot].T=t;\n                person[tot].id=i;\n                /*printf(\"%lf %lf %d\\n\",1.0,t,i);*/\n            }\n\n        }\n        sort(person+1,person+1+tot,cmp);\n        for(int i=1;i<=tot;i++)\n        {\n            int id=person[i].id;\n            if(person[i].T==person[i+1].T) {ans1[id]-=person[i].P;continue;}\n            double p1=person[i].P;\n            for(int j=1;j<=n;j++)\n            {\n                if(j==id) continue;\n                p1*=ans1[j];\n                /*printf(\"%d %lf..\\n\",j,ans1[j]);*/\n            }\n            /*printf(\"%d %lf %lf %lf\\n\",id,p1,person[i].P,person[i].T);*/\n            ans2[id]+=p1;\n            if(person[i].T==person[i-1].T)\n            {\n                double sign=person[i].T;\n                for(int k=i-1;k;k--)\n                {\n                    if(person[k].T!=sign) break;\n                    int v=person[k].id;\n                    ans2[v]+=p1;\n                }\n            }\n            ans1[id]-=person[i].P;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            printf(\"%lf\\n\",ans2[i]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] != 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define RST(A) memset(A, 0, sizeof(A))\n#define FLC(A, x) memset(A, x, sizeof(A))\n\ntypedef double DB;\n\nconst int N = int(1e2) + 9, M = int(5e1) + 9;\nDB p[N][M], sp[N][M], t[N], t0[N];\nint n, m, l;\n\nDB f(int i, DB ti){\n    DB z = 1; REP(j, n) if (i != j){\n        if (t0[j] + m*t[j] <= ti) return 0;\n        REP(k, m+1) if (t0[j] + k*t[j] > ti){\n            z *= (1 - sp[j][k]);\n            break;\n        }\n    }\n    return z;\n}\n\nint main(){\n\n    while (~scanf(\"%d%d%d\", &n, &m, &l)){\n\n        RST(p); REP(i, n){\n            int _p, v; scanf(\"%d%lf%d\", &_p, &t[i], &v); t0[i] = (DB) l / v; DB pp = (DB) _p / 100;\n            //cout <<\" \" << pp << endl;\n            p[i][0] = 1; DO(m){\n                DWN_1(j, m, 1) p[i][j] = p[i][j-1] * pp + p[i][j] * (1-pp);\n                p[i][0] = p[i][0] * (1-pp);\n            }\n\n            REP_1(j, m) sp[i][j] = sp[i][j-1] + p[i][j-1];\n        }\n\n        REP(i, n){\n            DB z = 0; REP(j, m+1) z += p[i][j] * f(i, t0[i] + t[i]*j);\n            printf(\"%.9f\\n\", z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define eps (1e-10)\n\nint N,M;\ndouble L;\ndouble P[100],T[100],V[100];\ndouble a[100][100],b[100][100];\n\ndouble mem[100][100];\ndouble ncr(int n,int r){\n  if(mem[n][r]!=-1.0)return mem[n][r];\n  r=min(r,n-r);\n  double res=1.0;\n  for(int i=0;i<r;i++){\n    res=res*(double)(n-i);\n    res=res/(double)(i+1);\n  }\n  return mem[n][r]=res;\n}\n\ndouble solve(int x){\n  double res=0;\n  for(int i=0;i<=M;i++){\n    double p=a[x][i];\n    double d=b[x][i];\n    for(int j=0;j<N;j++){\n      if(x==j)continue;\n      double sum=0;\n      for(int k=0;k<=M;k++){\n        if(b[j][k]<d+eps)continue;\n        sum+=a[j][k];\n      }\n      p*=sum;\n    }\n    res+=p;\n  }\n  return res;\n}\n\nint main(){\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      mem[i][j]=-1.0;\n  \n  cin>>N>>M>>L;\n  for(int i=0;i<N;i++){\n    cin>>P[i]>>T[i]>>V[i];\n    double p=P[i]/100.0;\n    double q=1.0-p;\n    for(int j=0;j<=M;j++){\n      a[i][j]=ncr(M,j)*pow(p,j)*pow(q,M-j);\n      b[i][j]=L/V[i]+T[i]*j;\n      //cout<<a[i][j]<<' '<<b[i][j]<<endl;\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<N;i++){\n    printf(\"%.10f\\n\",solve(i));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] != 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y)\n{\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\nint mod_inverse(int a, int m)\n{\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//int fact[INT_MAX];\n//int mod_fact(int n, int p, int &e)\n//{\n//\te = 0;\n//\tif (n == 0) return 1;\n//\tint res = mod_fact(n / p, p, e);\n//\te += n / p;\n//\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n//\treturn res * fact[n % p] % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (n < 0 || k < 0 || n < k) return 0;\n//\tint e1, e2, e3;\n//\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n//\tif (e1 > e2 + e3) return 0;\n//\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (k < 1) return 1;\n//\tll bunshi = 1, bunbo = 1;\n//\tll ans=1;\n//\tREP(i,n){\n//\t\tbunshi*=n-i;\n//\t\tbunshi%=M;\n//\t}\n//\tREP(i,k){\n//\t\tbunbo*=k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tREP(i,n-k){\n//\t\tbunbo*=n-k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tans=bunshi;\n//\tans*=mod_inverse\n//\treturn mod_inverse(bunshi,\n//\t\n//\tREP(i,n-k){\n//\t\tans*=bunshi;\n//\t\tans/=bunbo;\n//\t\tbunshi--;\n//\t\tbunbo--;\n//\t}\n//\tcerr << n << \", \" << k << \" => \" << ans << endl;\n//\treturn ans;\n//}\n\nll combination(int n,int k){\n\tif (k < 1) return 1;\n\tll ans=1;\n\tFOR(i,1,n-k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : INT_MAX;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\trunner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t]) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p*p,k/2);\n    if(k%2==0)return ret;\n    else return ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+j*pl[i].t,pl[k].v+m*pl[k].t)){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti++;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.5f\\n\",res[i]);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<27;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tdouble w;\n\tcin>>n>>m>>w;\n\tvvd a(n),b(n,vd(m+1));\n\tfor(int i=0;i<n;i++){\n\t\tdouble p,t,v;\n\t\tcin>>p>>t>>v;\n\t\tvd dp(1);\n\t\tdp[0]=1;\n\t\tp/=100;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tvd DP(j+2);\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tDP[k]+=(1-p)*dp[k];\n\t\t\t\tDP[k+1]+=p*dp[k];\n\t\t\t}\n\t\t\tdp=DP;\n\t\t}\n\t\ta[i]=dp;\n\t\tfor(int j=0;j<=m;j++) b[i][j]=w/v+j*t;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdouble res=0;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tdouble tmp=a[i][j];\n\t\t\tfor(int k=0;k<n;k++) if(k!=i){\n\t\t\t\tdouble sum=0;\n\t\t\t\tfor(int l=0;l<=m;l++) if(b[k][l]>b[i][j]+eps) sum+=a[k][l];\n\t\t\t\ttmp*=sum;\n\t\t\t}\n\t\t\tres+=tmp;\n\t\t}\n\t\tcout<<syosu(9)<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\ndouble l;\ndouble p[1000];\ndouble t[1000];\ndouble v[1000];\ndouble prob[2][101][51];\ndouble sum[101][55];\ndouble ans[101];\n\ninline double Sum(int i, int j) { return sum[i][j + 1]; }\n\nint main() {\n  while (scanf(\"%d %d %lf\", &n, &m, &l) > 0) {\n    MEMSET(prob, 0);\n    MEMSET(sum, 0);\n    MEMSET(ans, 0);\n    REP(i, n) {\n      scanf(\"%lf %lf %lf\", &p[i], &t[i], &v[i]);\n      p[i] /= 100.0;\n      prob[0][i][0] = 1;\n      REP(j, m) {\n        int prev = j & 1;\n        int next = prev ^ 1;\n        //MEMSET(prob[next][i], 0);\n        FOREQ(k, 0, m) {\n          prob[next][i][k] = (1.0 - p[i]) * prob[prev][i][k];\n          assert(prob[next][i][k] >= 0.0);\n          if (k != 0) {\n            prob[next][i][k] += p[i] * prob[prev][i][k - 1];\n          }\n          assert(prob[next][i][k] >= 0.0);\n        }\n      }\n      FOREQ(j, 0, m) {\n        sum[i][j + 1] = sum[i][j] + prob[m & 1][i][j];\n      }\n    }\n\n\n    REP(i, n) {\n      if (v[i] == 0) { continue; }\n      FOREQ(j, 0, m) {\n        double time = l / v[i] + t[i] * j;\n        if (isnan(time)) { continue; }\n        double lans = 1.0;\n        REP(k, n) {\n          if (i == k || v[k] == 0) { continue; }\n          double ntime = l / v[k];\n          double lp = 1.0;\n          FOREQ(cnt, 0, m) {\n            if (ntime  - time > EPS) { break; }\n            lp -= prob[m  & 1][k][cnt];\n            assert(lp >= -EPS);\n            ntime += t[k];\n          }\n          lans *= lp;\n          if (lans == 0) { break; }\n        }\n        ans[i] += lans * prob[m & 1][i][j];\n      }\n    }\n    REP(i, n) {\n      printf(\"%.8f\\n\", ans[i]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\ndouble get(int c,int n,double p)\n{\n    return C(c,n)*pow(p,c)*pow(1-p,n-c);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        memset(peo,0,sizeof(peo));\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=get(j,m,p[i]/100.0);\n            }\n        for(int i=0; i<n; i++)\n        {\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i||!v[i])\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nint P[100], T[100], V[100];\ndouble dp[101][52];\ndouble tim[52][52];\ndouble small[52][52];\n\nint main()\n{\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> P[i] >> T[i] >> V[i];\n  }\n\n  \n  for(int i = 0; i < N; i++) {\n    memset(small, 0, sizeof(small));\n    small[0][0] = 1.0;\n    for(int j = 0; j < M; j++) {\n      for(int k = 0; k <= j; k++) {\n        small[j + 1][k + 1] += small[j][k] / 100.0 * P[i];\n        small[j + 1][k]     += small[j][k] / 100.0 * (100 - P[i]);\n      }\n    }\n    for(int j = 0; j <= M; j++) {\n      tim[i][j] = (V[i] == 0 ? 1e18 : 1.0 * L / V[i] + j * T[i]);\n      dp[i][j] = small[M][j];\n    }\n  }\n  cout << fixed << setprecision(10);\n  \n  for(int i = 0; i < N; i++) {\n    double ret = 0;\n    for(int j = 0; j <= M; j++) {\n      double per = dp[i][j];\n      for(int k = 0; k < N; k++) {\n        if(i == k) continue;\n        double qur = 0.0;\n        for(int l = 0; l <= M; l++) {\n          if(tim[i][j] < tim[k][l]) qur += dp[k][l];\n        }\n        per *= qur;\n      }\n      ret += per;\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1001001001;\nconst ll LONGINF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst double EPS = 1e-12;\ndouble dp[110][51][51];\nint main() {\n    int N, M, L; cin >> N >> M >> L;\n    vector<int> P(N), T(N), V(N);\n    for(int i=0; i<N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n    }\n\n    for(int x=0; x<N; x++) {\n        dp[x][0][0] = 1.0;\n        double p = 1.0 * P[x] / 100;\n        \n        for(int i=0; i<=M; i++) {\n            for(int j=0; j<=M; j++) {\n                // fprintf(stderr, \"dp[%d][%d][%d] = %.12f\\n\", x, i, j, dp[x][i][j]);\n                \n                if(i == M or dp[x][i][j] < EPS) continue;\n                // やすむ\n                dp[x][i+1][j+1] += dp[x][i][j] * p;\n\n                // やすまない\n                dp[x][i+1][j  ] += dp[x][i][j] * (1 - p);\n            }\n        }\n\n        // るいせき\n        for(int j=1; j<=M; j++) dp[x][M][j] += dp[x][M][j-1];\n    }\n\n    for(int x=0; x<N; x++) {\n        // x 番目の人が i 回休んだ場合\n        double ans = 0.0;\n        for(int i=0; i<=M; i++) {\n            double p = (i ? dp[x][M][i] - dp[x][M][i-1] : dp[x][M][i]);\n            double tx = 1.0 * L / V[x] + T[x] * i;\n            \n            // y 番目の人が j 回休む\n            for(int y=0; y<N; y++) {\n                if(x == y) continue;\n\n                bool defeat = false;\n                for(int j=0; j<=M; j++) {\n                    double ty = 1.0 * L / V[y] + T[y] * j;\n                    if(ty - tx > EPS) {\n                        // fprintf(stderr, \"x = %d, i = %d, y = %d, j = %d: tx = %.12f, ty = %.12f\\n\", x, i, y, j, tx, ty);\n                        // j 回以上休んだら勝てる\n                        double q = (j ? dp[y][M][j-1] : 0);\n                        p *= (1 - q);\n                        defeat = true;\n                        break;\n                    }\n                }\n\n                if(!defeat) p = 0;\n            }\n            ans += p;\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.16lf\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nstatic const double EPS = 1e-7;\n\nstruct runner {\n  int p, t, v;\n};\n\nint main()\n{\n  static double comb[55][55];\n  for (int i = 0; i <= 50; i++) {\n    comb[i][0] = 1.0;\n  }\n  for (int i = 1; i <= 50; i++) {\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n    }\n  }\n\n  int N, M, L;\n  cin >> N >> M >> L;\n  vector<runner> v;\n  for (int i = 0; i < N; i++) {\n    runner r;\n    cin >> r.p >> r.t >> r.v;\n    v.push_back(r);\n  }\n\n  vector<vector<double> > ps(N, vector<double>(M+1));\n  vector<vector<double> > ps_integral(N, vector<double>(M+1));\n  vector<vector<double> > ts(N, vector<double>(M+1));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= M; j++) {\n      ps[i][j] = pow(v[i].p/100.0, j) * pow((100-v[i].p)/100.0, M-j) * comb[M][j];\n      if (j == 0) {\n        ps_integral[i][j] = ps[i][j];\n      } else {\n        ps_integral[i][j] = ps_integral[i][j-1] + ps[i][j];\n      }\n      ts[i][j] = double(L)/v[i].v + v[i].t*j;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    double ans = 0.0;\n    for (int j = 0; j <= M; j++) {\n      double p = 1.0;\n      for (int k = 0; k < N; k++) {\n        if (k != i) {\n          int l = lower_bound(ts[k].begin(), ts[k].end(), ts[i][j]+EPS) - ts[k].begin();\n          if (l != 0) {\n            p *= (1.0 - ps_integral[k][l-1]);\n          }\n        }\n      }\n      ans += ps[i][j] * p;\n    }\n    printf(\"%.6f\\n\", ans + EPS);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\twin_prob =0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n#define EPS 1e-12\nusing namespace std;\n\nint i;\ndouble pr[111][55], tim[111][55];\ndouble t[111], p[111], v[111];\nint n, m;\nlong long comb[55][55];\ndouble l;\n\ndouble compute_t(int x, double v, double t) {\n  return 1. * l / v + t * x;\n}\n\ndouble compute_p(int x, double p) {\n  return (1.0 * comb[m][x]) * pow(p, x) * pow(1.0 - p, m - x);\n}\n\nvoid Pascal()\n{\n  for(int i = 0; i <= 50; i++) {\n    comb[i][0] = 1;\n    for(int j = 1; j <= i; j++) {\n      comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n    }\n  }\n}\n\nint main() {\n  Pascal();         \n  cin >> n >> m >> l;\n  for(int i = 1; i <= n; i++) {\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100.0;\n  }\n\n  for(int i = 1; i <= n; i++)\n    for(int j = 0; j <= m; j++) {\n      tim[i][j] = compute_t(j, v[i], t[i]);\n      pr[i][j] = compute_p(j, p[i]);\n    }\n                              \n  cout << fixed << setprecision(6);\n  \n  \n  for(int i = 1; i <= n; i++) {\n    double ans = 0.;\n    for(int x = 0; x <= m; x++) {\n      double prob = 1.;\n      for(int j = 1; j <= n; j++) {\n        if(j == i) continue;\n        int ind = m;\n        double pp = 0.;\n        while(ind >= 0 && tim[j][ind] > tim[i][x]) pp += pr[j][ind--];\n        prob *= pp;                                  \n      }\n     // cout << i << ' ' << x << ' ' << prob << '\\n';\n      ans += prob * pr[i][x];\n    }\n    cout << ans << '\\n';\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][51],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)time[i][j] = (double)l/v[i] + t[i]*j;\n  }\n  \n \n  for(int i=0;i<n;i++){\n    if(abs(p[i]-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p[i],m);\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = ( prob[i][j-1] * p[i] * (m-j+1) ) / ( (1-p[i])*j );\n      }\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j]){\n\t\thoge += prob[k][l];\n\t      }\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n);\n    for(int i=0;i<n;i++){\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(!v[i])time[i][j] = 1e+10;\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(1-p[i],m);\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(1-p[i],m-j) * pow(p[i],j) ;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] != 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.16f\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n\nstruct node\n{\n    double p,t,v;\n}nd[105];\nint n,m,L;\ndouble dp[105][55][55];\nint main()\n{\n    while(~scanf(\"%d%d%d\",&n,&m,&L))\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf\",&nd[i].p,&nd[i].t,&nd[i].v);\n            nd[i].p/=100.0;\n        }\n        for(int i=0;i<n;i++)\n        {\n            dp[i][0][0]=1;\n            for(int j=1;j<=m;j++)\n                for(int k=0;k<=j;k++)\n                {\n                    if(k>0)\n                        dp[i][j][k]=dp[i][j-1][k]*(1-nd[i].p)+dp[i][j-1][k-1]*nd[i].p;\n                    else dp[i][j][k]=dp[i][j-1][k]*(1-nd[i].p);\n                }\n        }\n        /*for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<=m;j++)\n            {\n                for(int k=0;k<=m;k++)\n                    printf(\"%.6f \",dp[i][j][k]);\n                puts(\"\");\n            }\n            puts(\"\");\n        }\n         */\n        for(int i=0;i<n;i++)\n        {\n            double ans=0;\n            for(int j=0;j<=m;j++)\n            {\n                double ans1=dp[i][m][j],t=L/(nd[i].v)+j*nd[i].t;\n                for(int ii=0;ii<n;ii++)\n                {\n                    if(ii==i)continue;\n                    double tem=0,tt=L/nd[ii].v;\n                    for(int jj=0;jj<=m;jj++)\n                    {\n                        if(tt+jj*(nd[ii].t)>t||fabs(tt+jj*(nd[ii].t)-t)<eps)\n                            break;\n                        tem+=dp[ii][m][jj];\n                    }\n                    ans1*=(1.0-tem);\n                }\n                ans+=ans1;\n            }\n            printf(\"%.5f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define CLR(arr,val) memset(arr,val,sizeof(arr));\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define Lowbit(x) ((x)&(-x))\nconst double eps = 1e-10;\nconst int inf = 1000000000;\nconst int M   = 100000;\nconst int N   = 105;\ntypedef long long LL;\n\nstruct Node{\n\tdouble p;\n\tint t,v;\n}a[N];\ndouble pp[N][55],tt[N][55];\nint c[55][55];\nvoid C(){\n\tfor(int i=0; i<55; i++)\n\t\tc[0][i] = 1;\n\tfor(int i=1; i<55; i++)\n\t\tfor(int j=i; j<55; j++)\n\t\t\tc[i][j] = c[i-1][j-1]+c[i][j-1];\n}\ninline double Pow(double a,int k){\n\tdouble res = 1.0;\n\twhile( k-- ) res *= a;\n\treturn res;\n}\nint main(){\n\tC();\n\tint n, m, l;\n\twhile( scanf(\"%d%d%d\", &n, &m, &l) != EOF ){\n\t\tCLR( pp, 0 );\n\t\tCLR( tt, 0 );\n\t\tint p;\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tscanf(\"%d%d%d\", &p, &a[i].t, &a[i].v);\n\t\t\ta[i].p = p/100.0;\n\t\t}\n\t\tfor(int i=0 ; i < n ; ++i)\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\tpp[i][j] = c[j][m]*Pow(a[i].p,j)*Pow(1.0-a[i].p,m-j);\n\t\t\t\ttt[i][j] = 1.0*l/a[i].v+1.0*a[i].t*j;\n\t\t\t}\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tdouble tmp, ppp = 0.0;\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\ttmp = pp[i][j];\n\t\t\t\tfor(int k=0 ; k < n ; ++k){\n\t\t\t\t\tdouble t = 0.0;\n\t\t\t\t\tif( k == i ) continue;\n\t\t\t\t\tfor(int q=0 ; q <= m ; ++q){\n\t\t\t\t\t\tif( tt[k][q]-tt[i][j] > eps )\n\t\t\t\t\t\t\tt += pp[k][q];\n\t\t\t\t\t}\n\t\t\t\t\ttmp *= t;\n\t\t\t\t}\n\t\t\t\tppp += tmp;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\", ppp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-8;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// dp: 人iがj回目まででk回休憩する確率\n// iがj回休憩して優勝する確率は (iがj回休憩する確率) * Π(j!=iがm回目まででpj回以上休憩する確率)\n// pjは算数で求められる 累積和とっとくと楽そう\n// t,vが0の場合に注意\n\nint n, m, l, t[111], v[111];\ndouble p[111], dp[111][55][55], r[111][55];\n\nsigned main() {\n\tcin >> n >> m >> l;\n\trep(i,n) cin >> p[i] >> t[i] >> v[i];\n\trep(i,n) p[i] /= 100;\n\trep(i,n) {\n\t\tdp[i][0][0] = 1;\n\t\trep(j,m) rept(k,j) {\n\t\t\tdp[i][j+1][k+1] += dp[i][j][k] * p[i];\n\t\t\tdp[i][j+1][k] += dp[i][j][k] * (1. - p[i]);\n\t\t}\n\t\trepr(j,m) r[i][j] = r[i][j+1] + dp[i][m][j];\n\t}\n\trep(i,n) {\n\t\tdouble res = 0;\n\t\trept(j,m) {\n\t\t\tif (v[i]==0) break;\n\t\t\tdouble ti = 1.*l/v[i] + 1.*j*t[i], pl = dp[i][m][j];\n\t\t\trep(k,n) if (i!=k) {\n\t\t\t\tif (v[k]==0) continue; // 勝ち確\n\t\t\t\tif (t[k]==0) {\n\t\t\t\t\tif (deq(ti,1.*l/v[k]) || ti+eps>1.*l/v[k]) pl = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ti<1.*l/v[k]) continue; // kが休憩0でもiの方が速い場合\n\t\t\t\tint pj = ceil((ti-1.*l/v[k])/t[k]);\n\t\t\t\tif (deq((ti-1.*l/v[k])/t[k],pj)) pj++;\n\t\t\t\tif (pj>m) {\n\t\t\t\t\tpl = 0; // kが毎回休憩してもj回休憩したiより速い場合\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse pl *= r[k][pj];\n\t\t\t}\n\t\t\tres += pl;\n\t\t}\n\t\tprintf(\"%.14lf\\n\",res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n, m;\ndouble l;\ndouble p[100], t[100], v[100];\ndouble cb[100][51];\n\nvoid init(){\n\trep(u,n){\n\t\trep(i,m+1){\n\t\t\tint j = m-i;\n\t\t\tcb[u][i] = 1.0;\n\t\t\tint cnt1 = i, cnt2 = j;\n\t\t\tfor(int k = 1; k <= i; k++){\n\t\t\t\tcb[u][i] = cb[u][i]*(m-k+1)/k;\n\t\t\t\twhile(cb[u][i] > 1.0){\n\t\t\t\t\tif(cnt1 > 0){\n\t\t\t\t\t\tcb[u][i] *= p[u];\n\t\t\t\t\t\tcnt1--;\n\t\t\t\t\t} else if(cnt2 > 0){\n\t\t\t\t\t\tcb[u][i] *= (1-p[u]);\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t}\n\t\t\t\t\tif(cnt1 == 0 && cnt2 == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,cnt1) cb[u][i] *= p[u];\n\t\t\trep(k,cnt2) cb[u][i] *= (1-p[u]);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] *= 0.01;\n\t}\n\tinit();\n\trep(i,n){\n\t\tdouble pos;\n\t\t//double ti;\n\t\tdouble ans = 0.0;\n\t\tif(v[i] == 0.0){\n\t\t\tputs(\"0.00000000000\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tpos = cb[i][j];\n\t\t\trep(k,n){\n\t\t\t\tif(k == i) continue;\n\t\t\t\tif(v[k] == 0.0) continue;\n\t\t\t\tif(t[k] == 0.0){\n\t\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] >= 0) pos *= 0.0;\n\t\t\t\t\telse pos *= 1.0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] < 0) c = 0;\n\t\t\t\telse c = ((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k])/((int)t[k]*(int)v[i]*(int)v[k]) + 1;\n\t\t\t\tdouble tmp = 0.0;\n\t\t\t\tfor(int l = c; l <= m; l++){\n\t\t\t\t\ttmp += cb[k][l];\n\t\t\t\t}\n\t\t\t\tpos *= tmp;\n\t\t\t}\n\t\t\tans += pos;\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nconst int MAX_M = 50;\nlong long memo[MAX_M + 1][MAX_M + 1];\nlong long combination(int n, int k) {\n\tif(k == 0 || k == n)\n\t\treturn 1;\n\n\tif(k * 2 > n)\n\t\tk = n - k;\n\n\tif(memo[n][k] > 0)\n\t\treturn memo[n][k];\n\n\treturn memo[n][k] = combination(n - 1, k - 1) + combination(n - 1, k);\n}\n\nint main() {\n\tint n, m, l;\n\tscanf(\"%d %d %d\", &n, &m, &l);\n\n\tvector<int> t(n), v(n);\n\tvector<double> p(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf %d %d\", &p[i], &t[i], &v[i]);\n\t\tp[i] /= 100.0;\n\t}\n\n\tvector<vector<double>> time(n, vector<double>(m + 1));\n\tfor(int i = 0; i < n; ++i) {\n\t\ttime[i][0] = static_cast<double>(l) / v[i];\n\t\tfor(int j = 1; j <= m; ++j) {\n\t\t\ttime[i][j] = time[i][j - 1] + t[i];\n\t\t}\n\t}\n\n\tvector<vector<double>> probability(n, vector<double>(m + 1));\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst double q = 1.0 - p[i];\n\t\tfor(int j = 0; j <= m; ++j) {\n\t\t\tprobability[i][j] = combination(m, j) * pow(p[i], j) * pow(q, m - j);\n\t\t}\n\t}\n\n\tvector<vector<double>> sum(probability);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = m - 1; j >= 0; --j) {\n\t\t\tsum[i][j] += sum[i][j + 1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tdouble ans = 0.0;\n\t\tfor(int j = 0; j <= m; ++j) {\n\t\t\tdouble tmp = probability[i][j];\n\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tconst int idx = upper_bound(time[k].begin(), time[k].end(), time[i][j]) - time[k].begin();\n\t\t\t\ttmp *= sum[k][idx];\n\t\t\t}\n\t\t\tans += tmp;\n\t\t}\n\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nconst double eps = 1e-6;\nconst int MAXN = 102;\nconst int MAXM = 52;\nint N, M;\ndouble L;\ndouble P[MAXN];\ndouble T[MAXN];\ndouble V[MAXN];\nlli comb[MAXM][MAXM];\n\nvector<double> U[MAXN];\nvector<double> Q[MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvoid make() {\n  comb[0][0] = 1;\n  for(int i = 1; i < MAXM; ++i) {\n    for(int j = 0; j <= i; ++j) {\n      comb[i][j] = 0;\n      if(j) comb[i][j] += comb[i-1][j-1];\n      if(j <= i-1) comb[i][j] += comb[i-1][j];\n    }\n  }\n}\n\nint main() {\n  make();\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n\n    for(int i = 0; i < MAXN; ++i) {\n      U[i].clear();\n      Q[i].clear();\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int k = 0; k <= M; ++k) { // rest k times.\n\tU[i].push_back(L/V[i] + T[i]*k);\n\tQ[i].push_back(pow(P[i],k)*pow(1.0-P[i],M-k)*comb[M][k]);\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      double res = 0.0;\n      for(int k = 0; k <= M; ++k) {\n\tdouble tmp = Q[i][k];\n\tfor(int j = 0; j < N; ++j) {\n\t  if(i == j) continue;\n\t  /*\n\t  vector<double>::iterator it = \n\t    lower_bound(U[j].begin(), U[j].end(), U[i][k]);\n\t  */\n\t  double a = 0;\n\t  for(int b = 0; b < U[j].size(); ++b) {\n\t    if(equals(U[j][b], U[i][k]) || U[j][b] < U[i][k]) continue;\n\t    a += Q[j][b];\n\t  }\n\t  tmp *= a;\n\t}\n\tres += tmp;\n      }\n      printf(\"%.8f\\n\", res);\n    }\n    //puts(\"\");\n    return 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int MAXN=100+10;\ndouble P[MAXN],T[MAXN],V[MAXN];\ndouble late[MAXN][MAXN];\ndouble C[MAXN][MAXN];\nint n,m,l;\nint main()\n{\n//    freopen(\"in\",\"r\",stdin);\n    for(int n=0; n<=50;n++)\n    {\n        C[n][0]=1;\n        for(int k=0; k<n; k++)\n            C[n][k+1]=C[n][k]*(n-k)/(k+1.0);\n    }\n\n    while(~scanf(\"%d%d%d\",&n,&m,&l))\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%lf%lf%lf\",P+i,T+i,V+i),P[i]/=100;\n\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<=m; j++)\n            {\n                late[i][j]=C[m][j]*pow(P[i],j)*pow(1-P[i],m-j);\n//                printf(\"late[%d][%d]=%f \",i,j,late[i][j]);\n            }\n//            putchar(10);\n        }\n        for(int i=0; i<n; i++)\n        {\n            double ans=0,t=l/V[i];\n            for(int k=0; k<=m; k++)\n            {\n                double one=late[i][k];\n                for(int j=0; j<n && one; j++)\n                {\n                    if(i==j) continue;\n                    double jp=0;\n                    for(int kk=0; kk<=m ; kk++)\n                        if(kk*T[j]+l/V[j]>t)\n                            jp+=late[j][kk];\n                    one*=jp;\n                }\n                ans+=one;\n//                printf(\"%d %d %.8f\\n\",i,k,one);\n                t+=T[i];\n            }\n            printf(\"%.8f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL maxn = 111;\nLL v[maxn], t[maxn];\nLL c[maxn][maxn];\n\ndouble p[maxn];\ndouble lv[maxn];\nLL n, m, l;\n\ndouble ff (LL u, LL state, LL v) {\n\tdouble ret = 0;\n\tfor (LL i = 0; i <= m; ++i) {\n\t\tif (lv[v] + i * t[v] > lv[u] + state * t[u]) {\n\t\t\tret += 1.0 * c[i][m] * pow (1.0 * p[v], 1.0*i) * pow (1.0 - p[v], 1.0*m - i);\n\t\t}\n\t}\n\treturn ret;\n}\ndouble f (LL u, LL state) {\n\tdouble ret = 1.0 * c[state][m] * pow (1.0 * p[u], 1.0 * state) * pow (1.0 - p[u], 1.0 * m - state);\n\tfor (LL i = 0; i < n; ++i) {\n\t\tif (i == u) continue;\n\t\tret *= ff (u, state, i);\n\t}\n\treturn ret;\n}\ndouble solve (LL u) {\n\tdouble ret = 0;\n\tfor (LL i = 0; i <= m; ++i) {\n\t\tret += f (u, i);\n\t}\n\treturn ret;\n}\n\n//生成C(m, n)\nLL combination (LL m, LL n) {\n\tLL ret = 1;\n\tLL up[maxn], low[maxn];\n\tfor (LL i = 1; i <= n; ++i) low[i] = up[i] = i;\n\tfor (LL i = m + 1; i <= n; ++i) {\n\t\tfor (LL j = 1; j <= n - m; ++j) {\n\t\t\tif (up[i] % low[j] == 0) {\n\t\t\t\tup[i] /= low[j];\n\t\t\t\tlow[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (LL i = 1; i <= n; ++i) ret *= up[i];\n\tfor (LL i = 1; i <= n - m; ++i) ret /= low[i];\n\treturn ret;\n}\nint main () {\n\tLL i;\n\twhile (~scanf (\"%lld%lld%lld\", &n, &m, &l)) {\n\t\t//生成所有c[i][m]的&#32452;合数\n\t\tfor (i = 0; i <= (m >> 1); ++i) {\n\t\t\tc[i][m] = c[m-i][m] = combination (i, m);\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tscanf (\"%lf%lld%lld\", &p[i], &t[i], &v[i]);\n\t\t\tlv[i] = 1.0 * l / v[i];\n\t\t\tp[i] /= 100;\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tdouble ans = solve (i);\n\t\t\tprintf (\"%.8lf\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double real;\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\nreal EPS = 1e-9;\n\nconst int MAX_N = 101;\nconst int MAX_M = 53;\n\nconst bool debug = false;\n\nint N, M, L;\nvector<real> P, T, V;\nvoid input() {\n    cin >> N >> M >> L;\n    P.clear(); P.resize(N);\n    T.clear(); T.resize(N);\n    V.clear(); V.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n}\n\nreal X[MAX_N][MAX_M]; // X[i][j] :: i人目がm回休む確率\nreal S[MAX_N][MAX_M]; // S[i][j] :: i人目がm回未満だけ休む確率\n\nvoid init() {\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M; j++) X[i][j] = 0;\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M + 1; j++) S[i][j] = 0;\n    for (int i = 0; i < N; i++) {\n        static real dp[MAX_M][MAX_M];\n        for (int j = 0; j <= M; j++) for (int k = 0; k <= M; k++) dp[j][k] = 0;\n        dp[0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[j + 1][k] += dp[j][k] * (1.0 - P[i]);\n                dp[j + 1][k + 1] += dp[j][k] * P[i];\n            }\n        }\n        for (int k = 0; k <= M; k++) {\n            X[i][k] = dp[M][k];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        S[i][0] = 0;\n        for (int j = 0; j <= M; j++) {\n            S[i][j + 1] = S[i][j] + X[i][j];\n        }\n    }\n    if (debug) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= M; j++) {\n                printf(\"%3.3Lf \", X[i][j]);\n            }\n            cout << endl;\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for (int i = 0; i < N; i++) { // i人目\n        if (V[i] == 0) {\n            printf(\"%.12Lf\\n\", real(N == 1 ? 1 : 0));\n            continue;\n        }\n        real ans = 0;\n        for (int j = 0; j <= M; j++) { // j回休んだ\n            real p = X[i][j];\n            real time = L / V[i] + j * T[i];\n            for (int k = 0; k < N; k++) { // k人目\n                if (i == k) continue;\n                if (T[k] == 0) {\n                    p *= (L / V[k] - EPS > time);\n                    continue;\n                }\n                // c回以上休む必要\n                int c = int(ceil((time - L / V[k]) / T[k] + EPS) + EPS);\n                if (c > M) {\n                    p = 0;\n                    break;\n                }\n                real pk = 1.0 - S[k][c];\n                p *= pk;\n            }\n            ans += p;\n        }\n        printf(\"%.12Lf\\n\", ans);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, p[100], t[100], v[100];\ndouble dp[100][51], sum[100][51];\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\trep(i, n){\n\t\tdp[i][0] = 1;\n\t\trep(j, m) for(int k = m; k >= 0; k--){\n\t\t\tdp[i][k + 1] += dp[i][k] * p[i] / 100.0;\n\t\t\tdp[i][k] *= 1 - p[i] / 100.0;\n\t\t}\n\t\tsum[i][m] = dp[i][m];\n\t\tfor(int j = m - 1; j >= 0; j--) sum[i][j] = sum[i][j + 1] + dp[i][j];\n\t\t/*\n\t\trep(j, m + 1) cerr<<dp[i][j]<<(j==m?\"\\n\":\" \");\n\t\trep(j, m + 1) cerr<<sum[i][j]<<(j==m?\"\\n\":\" \");\n\t\t*/\n\t}\n\t\n\trep(i, n){\n\t\tdouble s = 0;\n\t\trep(j, m + 1){\n\t\t\tdouble e = dp[i][j];\n\t\t\trep(k, n) if(k != i){\n\t\t\t\tint tm = (int)ceil((l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j) / t[k] + EPS);\n\t\t\t\t\n\t\t\t\ttm = max(tm, 0);\n\t\t\t\tif(t[k] == 0) tm = l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j < - EPS ? 0 : m + 1;\n\t\t\t\tif(tm <= m) e *= sum[k][tm];\n\t\t\t\telse e = 0;\n\t\t\t}\n\t\t\ts += e;\n\t\t}\n\t\tprintf(\"%.9f\\n\", s);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 D : Marathon Match\n\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint N, M, L;\n\tint P[100], T[100], V[100];\n\t// [P][M][lest]\n\tstatic double dp[101][101][101];\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int k=0;k<=100;k++) dp[i][j][k] = 0.0;\n\t\tdp[i][0][0] = 1.0;\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tdp[i][j+1][k  ] += dp[i][j][k]*(100-i)/100.0;\n\t\t\t\tdp[i][j+1][k+1] += dp[i][j][k]*i/100.0;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N >> M >> L){\n\t\tfor(int i=0;i<N;i++) cin >> P[i] >> T[i] >> V[i];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble res = 0.0;\n\t\t\tfor(int j=0;j<=M;j++){\n\t\t\t\tdouble cur = dp[P[i]][M][j];\n\t\t\t\tdouble time = (double)L/V[i] + j*T[i];\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\tdouble sum = 0.0;\n\t\t\t\t\tfor(int l=0;l<=M;l++){\n\t\t\t\t\t\tdouble otime = (double)L/V[k] + l*T[k];\n\t\t\t\t\t\tif(otime - time < 1e-8) continue;\n\t\t\t\t\t\tsum += dp[P[k]][M][l];\n\t\t\t\t\t}\n\t\t\t\t\tcur *= sum;\n\t\t\t\t}\n\t\t\t\tres += cur;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\", res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <stdio.h>\n//#include <math.h>\n//#include <iostream>\n//#include <algorithm>\n//#include <queue>\n//#include <vector>\n//#include <map>\n//using namespace std;\n//\n//const int Max=109;\n//#define LL long long\n//LL C[52][52];\n//\n//struct P{\n//\tint t,v;\n//\tdouble p;\n//}stu[Max];\n//\n//\n//#define eps 1e-8\n//int dd(double x,double y){ return fabs(x-y)<eps;} // x==y\n//int dy(double x,double y){ return x>y+eps;}   // x>y   \n//int xy(double x,double y){ return x<y-eps;}   //x<y\n//int dyd(double x,double y){ return x>y-eps;}  //x>=y\n//int xyd(double x,double y){ return x<y+eps;}  //x<=y\n//\n//double poww(double p,int t){\n//\tdouble s=1;\n//\tfor(int i=0;i<t;i++)\n//\t\ts*=p;\n//\treturn s;\n//}\n//\n//int main(){\n//\tC[0][0]=1;\n//\tfor (int i=1; i<=50; ++i)\n//\t{\n//\t\tC[i][0]=C[i][i]=1;\n//\t\tfor (int j=1; j<i; ++j)\n//\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n//\t}\n//\tdouble l;\n//\tint n,st;\n//\tscanf(\"%d %d %lf\",&n,&st,&l);\n//\tfor(int i=0;i<n;i++){\n//\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n//\t\tstu[i].p/=100;\n//\t}\n//\tdouble pp,t,t1,p2,ppp;\n//\tfor(int i=0;i<n;i++){\n//\t\tppp=0;\n//\t\tfor(int j=0;j<=st;j++){\n//\t\t\tt=j*stu[i].t+l/(stu[i].v*1.0);\n//\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow((1-stu[i].p),(double)(st-j));\n//\t\t\tfor(int k=0;k<n;k++){\n//\t\t\t\tif(k==i)\n//\t\t\t\t\tcontinue;\n//\t\t\t\tp2=0;\n//\t\t\t\tfor(int u=0;u<=st;u++){\n//\t\t\t\t\tt1=u*stu[k].t+l/(stu[k].v*1.0);\n//\t\t\t\t\tif(dy(t1,t))\n//\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow((1-stu[i].p),(double)(st-u));\n//\t\t\t\t}\n//\t\t\t\tpp*=p2;\n//\t\t\t}\n//\t\t\tppp+=pp;\n//\t\t}\n//\t\tprintf(\"%lf\\n\",ppp);\n//\t}\n//\treturn 0;\n//}\n\n#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\n\nLL C[55][55];\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\n#define eps 1e-7\nint dd(double x,double y){ return fabs(x-y)<eps;} // x==y\nint dy(double x,double y){ return x>y+eps;}   // x>y   \nint xy(double x,double y){ return x<y-eps;}   //x<y\nint dyd(double x,double y){ return x>y-eps;}  //x>=y\nint xyd(double x,double y){ return x<y+eps;}  //x<=y\n\n\nint main(){\n\tC[0][0]=1;\n\tfor (int i=0; i<=50; ++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l) == 3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(dy(t1,t))\n\t\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tif(dy(p2,0))\n\t\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%lf\\n\",ppp);\n\t\t}\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//10\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ndouble fact(int x){\n  double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n\tif(i!=k){\n\t  int x=lower_bound(at[k],at[k]+m+1,at[i][j]+1e-9)-at[k];\n\t  c*=1-acp[k][x];\n\t}\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_M 50\n#define INF (1<<29)\n\nint main()\n{\n    int N, M;\n    double L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n    double p[MAX_N][MAX_M+1][MAX_M+1];\n    memset(p, 0, sizeof(p));\n\n    for (int i = 0; i < N; i++) {\n        p[i][0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k < M; k++) {\n                p[i][j+1][k]   += p[i][j][k] * (1 - P[i]);\n                p[i][j+1][k+1] += p[i][j][k] * P[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        double res = 0;\n        for (int j = 0; j <= M; j++) {\n            double r = 1;\n            bool win = 1;\n            for (int k = 0; k < N; k++) {\n                if (i == k) {\n                    continue;\n                }\n                double rr = 0;\n                bool ok = 0;\n                for (int l = M; l >= 0; l--) {\n                    if (V[k]*L+V[k]*V[i]*T[i]*j <\n                        V[i]*L+V[i]*V[k]*T[k]*l) {\n                        ok = 1;\n                        rr += p[k][M][l];\n                    } else {\n                        break;\n                    }\n                }\n                if (!ok) {\n                    win = 0;\n                    break;\n                }\n                r *= rr;\n            }\n            res += (win ? r * p[i][M][j] : 0);\n        }\n        printf(\"%.8f\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    int p,v,t;\n    double time[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L;\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\nint main()\n{\n//#ifndef ONLINE_JUDGE\n//    freopen(\"in.txt\",\"r\",stdin);\n//#endif // ONLINE_JUDGE\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&peo[i].p,&peo[i].t,&peo[i].v);\n        if(n==1)\n        {\n            printf(\"%.8lf\\n\",peo[0].v!=0?1:0);\n            continue;\n        }\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].time[j]=(L+0.0)/peo[i].v+j*peo[i].t;\n                peo[i].pp[j]=C(j,m)*pow(peo[i].p*0.01,j)*pow((100-peo[i].p)*0.01,m-j);\n            }\n        for(int i=0; i<n; i++)\n        {\n            if(!peo[i].v)\n            {\n                printf(\"%.8lf\\n\",0);\n                continue;\n            }\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=peo[i].pp[j];\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[k].time[l]>peo[i].time[j])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp;\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n \nint N, M, L;\ndouble P[102], T[102], V[102];\ndouble dp[102][102];\ndouble p[102][102];\n \nint main(){\n  while(cin >> N >> M >> L){\n    for(int i = 0; i < N; i++){\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n \n    for(int k = 0; k < N; k++){\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1.0;\n \n      for(int i = 0; i < M; i++){\n        for(int j = 0; j <= M; j++){\n          dp[i + 1][j] += dp[i][j] * (1 - P[k]);\n          dp[i + 1][j + 1] += dp[i][j] * P[k];\n        }\n      }\n \n      for(int j = 0; j <= M; j++){\n        p[k][j] = dp[M][j];\n      }\n    }\n \n    for(int i = 0; i < N; i++){ //iが勝つ\n      double ans = 0;\n \n      for(int j = 0; j <= M; j++){ //iがj回休む\n        double ti = (double)j * T[i] + (double)L / V[i];\n        double mul = 1.0;\n \n        for(int k = 0; k < N; k++){ //kはiに負ける\n          if(k == i) continue;\n \n          double sum = 0;\n \n          for(int l = 0; l <= M; l++){ //kはl回休む\n            double tk = (double)l * T[k] + (double)L / V[k];\n            //printf(\"%dが%d休み. %dが%d休み. = %.5f, %.5fn\", i,j,k,l,ti,tk);\n            if(ti >= tk) continue;\n            sum += p[k][l];\n          }\n \n          mul *= sum;\n        }\n \n        ans += mul * p[i][j];\n      }\n \n      printf(\"%.10f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define CLR(arr,val) memset(arr,val,sizeof(arr));\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define Lowbit(x) ((x)&(-x))\nconst double eps = 1e-8;\nconst int inf = 1000000000;\nconst int M   = 100000;\nconst int N   = 105;\ntypedef long long LL;\n\nstruct Node{\n\tdouble p;\n\tint t,v;\n}a[N];\ndouble pp[N][55],tt[N][55];\nint c[55][55];//c[k][n]\nvoid C(){\n\tfor(int i=0; i<51; i++)\n\t\tc[0][i] = 1;\n\tfor(int i=1; i<51; i++)\n\t\tfor(int j=i; j<51; j++)\n\t\t\tc[i][j] = c[i-1][j-1]+c[i][j-1];\n}\ninline double Pow(double a,int k){\n\tdouble res = 1.0;\n\twhile( k-- ) res *= a;\n\treturn res;\n}\nint main(){\n\tC();\n\tint n, m, l;\n\twhile( scanf(\"%d%d%d\", &n, &m, &l) != EOF ){\n\t\tint p;\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tscanf(\"%d%d%d\", &p, &a[i].t, &a[i].v);\n\t\t\ta[i].p = p/100.0;\n\t\t}\n\t\tCLR( pp, 0 );\n\t\tCLR( tt, 0 );\n\t\tfor(int i=0 ; i < n ; ++i)\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\tpp[i][j] = c[j][m]*Pow(a[i].p,j)*Pow(1-a[i].p,m-j);\n\t\t\t\ttt[i][j] = l/a[i].v+a[i].t*j;\n\t\t\t}\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tdouble tmp, ppp = 0;\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\ttmp = pp[i][j];\n\t\t\t\tfor(int k=0 ; k < n ; ++k){\n\t\t\t\t\tdouble t = 0;\n\t\t\t\t\tif( k == i ) continue;\n\t\t\t\t\tfor(int q=0 ; q <= m ; ++q){\n\t\t\t\t\t\tif( tt[k][q] > tt[i][j] )\n\t\t\t\t\t\t\tt += pp[k][q];\n\t\t\t\t\t}\n\t\t\t\t\ttmp *= t;\n\t\t\t\t}\n\t\t\t\tppp += tmp;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\", ppp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <math.h>\n# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <algorithm>\n# include <iostream>\n\n# define For(i,x,y)   for((i)=(x);i<(y);(i)++)\n# define MAX(x,y)   ((x)>(y)? (x):(y))\n# define MIN(x,y)   ((x)<(y)? (x):(y))\n# define sz(a)      (sizeof(a))\n# define mem(a)     (memset((a),0,sizeof(a)))\n\n# define fop freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n# define print(x) (printf(\"%d\\n\",x))\n# define scan(x) (scanf(\"%d\",&x))\n# define printc(x) (printf(\"%c\\n\",x))\n# define scanc(x) (scanf(\"%c\",&x))\n# define INF 0x7fffffff\n\nusing namespace std;\n\ntypedef long long           ll;\nll c[55][55];\ndouble a[105][55],f[105][55],p[105];\nint t[105],v[105];\nint main()\n{\n    int i,j,k,n,m,l,ii,jj;\n    double ans,tot,tmp;\n    c[0][0]=1;\n    for (i=1;i<=50;i++)\n      for (j=0;j<=i;j++)\n        c[i][j]=c[i-1][j]+c[i-1][j-1];\n    scan(n);scan(m);scan(l);\n    //print(n);print(m);print(l);\n    For(i,1,n+1)\n    {\n        scanf(\"%lf\",&p[i]);\n        p[i]=p[i]/100.0;\n        scan(t[i]);scan(v[i]);\n    }\n    For(i,1,n+1)\n      For(j,0,m+1)\n      {\n          a[i][j]=pow(p[i],j)*c[m][j]*pow(1-p[i],m-j);\n          if (v[i])\n          {\n              f[i][j]=(double)l/(double)v[i];\n              f[i][j]+=j*t[i];\n          }\n          else f[i][j]=INF;\n      }\n    For (i,1,n+1)\n    {\n        ans=0;\n        For (j,0,m+1)\n        {\n            tmp=a[i][j];\n            For(ii,1,n+1) if (ii!=i)\n            {\n\n              tot=0;\n              For (jj,0,m+1)\n                if (f[i][j]<f[ii][jj])\n                  tot+=a[ii][jj];\n              tmp*=tot;\n            }\n            ans+=tmp;\n        }\n        printf(\"%.8lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nlint gcd(lint p, lint q){\n    p = abs(p);\n    q = abs(q);\n    while(q){\n        lint r = p % q;\n        p = q;\n        q = r;\n    }\n    return p;\n}\n\ntypedef struct Fraction{\n    lint n, d; // n / d\n\n    Fraction(lint n_=0, lint d_=1): n(n_), d(d_){\n        if(d == 0) n = (n < 0 ? -1 : 1);\n        else{\n            lint g = gcd(n, d);\n            n /= g;\n            d /= g;\n        }\n    }\n\n    Fraction operator-() const{\n        return Fraction(-n, d);\n    }\n    Fraction &operator+=(const Fraction &rhs){\n        n = n * rhs.d + rhs.n * d;\n        d = d * rhs.d;\n        return *this = Fraction(n, d);\n    }\n    Fraction &operator-=(const Fraction &rhs){\n        n = n * rhs.d - rhs.n * d;\n        d = d * rhs.d;\n        return *this = Fraction(n, d);\n    }\n    Fraction &operator*=(const Fraction &rhs){\n        n = n * rhs.n;\n        d = d * rhs.d;\n        return *this = Fraction(n, d);\n    }\n    Fraction &operator/=(const Fraction &rhs){\n        n = n * rhs.d;\n        d = d * rhs.n;\n        return *this = Fraction(n, d);\n    }\n\n    Fraction operator+(const Fraction &rhs) const{\n        Fraction ret(*this);\n        return ret += rhs;\n    }\n    Fraction operator-(const Fraction &rhs) const{\n        Fraction ret(*this);\n        return ret -= rhs;\n    }\n    Fraction operator*(const Fraction &rhs) const{\n        Fraction ret(*this);\n        return ret *= rhs;\n    }\n    Fraction operator/(const Fraction &rhs) const{\n        Fraction ret(*this);\n        return ret /= rhs;\n    }\n\n    bool operator==(const Fraction &rhs) const{\n        return n == rhs.n && d == rhs.d;\n    }\n    bool operator!=(const Fraction &rhs) const{\n        return !(*this == rhs);\n    }\n\n    bool operator<(const Fraction &rhs) const{\n        return n * rhs.d < rhs.n * d;\n    }\n    bool operator>(const Fraction &rhs) const{\n        return rhs < *this;\n    }\n    bool operator<=(const Fraction &rhs) const{\n        return !(*this > rhs);\n    }\n    bool operator>=(const Fraction &rhs) const{\n        return !(*this < rhs);\n    }\n\n}frac;\n\nint main(){\n    int n, m, L;\n    scanf(\"%d%d%d\", &n, &m, &L);\n\n    double comb[m + 1][m + 1];\n    rep(i, m + 1)rep(j, m + 1) comb[i][j] = 0;\n    comb[0][0] = 1;\n    rep(i, m)rep(j, i + 1){\n        comb[i + 1][j] += comb[i][j];\n        comb[i + 1][j + 1] += comb[i][j];\n    }\n\n    double prob[n][m + 1];\n    Fraction time[n][m + 1];\n    int p[n], t[n], v[n];\n    rep(i, n){\n        scanf(\"%d%d%d\", &p[i], &t[i], &v[i]);\n        rep(k, m + 1){\n            time[i][k] = Fraction(L + k * t[i] * v[i], v[i]);\n            prob[i][k] = comb[m][k] * pow((double)p[i] / 100, k) * pow(1 - (double)p[i] / 100, m - k);\n        }\n    }\n\n    rep(i, n){\n        double ans = 0;\n        rep(k, m + 1){\n            double tmp = prob[i][k];\n            rep(j, n)if(i != j){\n                double ttmp = 0;\n                rep(l, m + 1){\n                    if(time[i][k] < time[j][l]) ttmp += prob[j][l];\n                }\n                tmp *= ttmp;\n            }\n            ans += tmp;\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint n,m,L;\ndouble p[100];\nint t[100],v[100];\ndouble c[51][100];\nmain()\n{\n\tcin>>n>>m>>L;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>p[i]>>t[i]>>v[i];\n\t\tp[i]/=100;\n\t\tif(p[i]==1)\n\t\t{\n\t\t\tc[m][i]=1;\n\t\t}\n\t\telse if(p[i]==0)\n\t\t{\n\t\t\tc[0][i]=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0][i]=1;\n\t\t\tfor(int j=0;j<m;j++)c[0][i]*=1-p[i];\n\t\t\tfor(int j=0;j<m;j++)c[j+1][i]=c[j][i]*(m-j)/(j+1)/(1/p[i]-1);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdouble ans=0;\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tdouble np=c[j][i];\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t{\n\t\t\t\tif(i==k)continue;\n\t\t\t\tint cnt=0;\n\t\t\t\tdouble P=1;\n\t\t\t\twhile(cnt<=m&&L*v[k]+j*t[i]*v[i]*v[k]>=L*v[i]+cnt*t[k]*v[i]*v[k])\n\t\t\t\t{\n\t\t\t\t\tP-=c[cnt][k];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tnp*=P;\n\t\t\t}\n\t\t\tans+=np;\n\t\t}\n\t\tcout<<fixed<<setprecision(9)<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<long double> p(n),t(n),v(n);\n    rep(i,0,n){\n        cin >> p[i] >> t[i] >> v[i];\n        if(v[i]==0) v[i]=1e-12;\n    }\n\n    ll comb[51][51]={};\n    rep(i,0,51){\n        comb[i][i]=1;\n        comb[i][0]=1;\n    }\n    rep(i,1,51) rep(j,1,i){\n        if(i>0 and i>j) comb[i][j]+=comb[i-1][j];\n        if(j>0) comb[i][j]+=comb[i-1][j-1];\n    }\n\n    vector<map<int,long double>> x(n);\n    rep(i,0,n) rep(j,0,m+1) x[i][t[i]*j]+=powl((100-p[i])/100,m-j)*comb[m][j]*powl(p[i]/100,j);\n    rep(i,0,n){\n        long double s1=0;\n        for(const auto& p1:x[i]){\n            long double tmp=p1.second;\n            rep(j,0,n){\n                if(j==i) continue;\n                long double s2=0;\n                for(const auto& p2:x[j]) if(p2.first+l/v[j]>p1.first+l/v[i]) s2+=p2.second;\n                tmp*=s2;\n            }\n            s1+=tmp;\n        }\n        cout << fixed << setprecision(8) << s1 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>;\n\nld comb(ll l, ll r) {\n\tld res = 1;\n\tREP(i, r) {\n\t\tres *= l - i;\n\t\tres /= i + 1;\n\t}\n\treturn res;\n}\n\n// [person][rest-number] -> prob\nvector<vector<ld>> calc_prob_table(const vector<ar3>& info, const int M) {\n\tconst int N = info.size();\n\tvector<vector<ld>> res(N, vector<ld>(M + 1));\n\tREP(i, N)REP(j, M + 1) {\n\t\tld rest = info[i][0];\n\t\tres[i][j] = comb(M, j)*powl(rest / 100., j)*powl(1 - rest / 100., M - j);\n\t}\n\t//REP(i, N)REP(j, M - 1)res[i][j + 1] += res[i][j];\n\treturn res;\n}\n\nld lose_prob(const vector<ld>& prob, ar3 info, ld time, const ld L) {\n\tconst int M = prob.size();\n\ttime -= L / info[2];\n\tif (info[1] == 0) {\n\t\ttime = INF * (time >= 0 ? 1 : -1);\n\t}\n\telse {\n\t\ttime /= (ld)info[1];\n\t}\n\n\tld res = 0;\n\tREP(i, min(time + 1e-3, (ld)M)) {\n\t\tres += prob[i];\n\t}\n\treturn 1 - res;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<ar3> info(N);\n\tREP(i, N)REP(j, 3)cin >> info[i][j];\n\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tauto table = calc_prob_table(info, M);\n\tREP(i, N) {\n\t\tld res = 0;\n\t\tREP(rest, M + 1) {\n\t\t\tld tres = table[i][rest];\n\t\t\tld time = (ld)L / info[i][2] + info[i][1] * rest;\n\t\t\tREP(opp, N)if (opp != i) {\n\t\t\t\ttres *= lose_prob(table[opp], info[opp], time, L);\n\t\t\t}\n\t\t\tres += tres;\n\t\t}\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\nconst int fa=101;\nconst int ma=90000000;\nint n,m,l;\nstruct wgh\n{\n    int v;\n    double ans,p,t2,t;\n}a[fa];\ndouble dp[fa][fa];\ndouble p[fa][fa];\ndouble sum[fa][fa];\nint main()\n{\n    int i,j,k;double v,g;\n    scanf(\"%d%d%d\",&n,&m,&l);\n    for(i=1;i<=n;i++)\n    {\n        scanf(\"%lf%lf %d\",&a[i].p,&a[i].t,&a[i].v);\n        a[i].p/=100;\n        if(v!=0)\n        a[i].t2=double(l)/double(a[i].v);\n        else\n        a[i].t2=ma;\n        if(a[i].p==0)\n        {\n            p[i][0]=1;\n            sum[i][0]=1;\n            dp[i][0]=a[i].t2;\n            for(j=1;j<=m;j++)\n            {\n                dp[i][j]=dp[i][j-1]+a[i].t;\n                sum[i][j]=1;\n            }\n            continue;\n        }\n        if(a[i].p==1)\n        {\n            p[i][1]=1;\n            sum[i][1]=1;\n            dp[i][0]=a[i].t2;\n            for(j=1;j<=m;j++)\n            {\n                dp[i][j]=dp[i][j-1]+a[i].t;\n            }\n            continue;\n        }\n        g=1;\n        for(j=1;j<=m;j++)\n        g=g*(1.0-a[i].p);\n        p[i][0]=g;\n        sum[i][0]=g;\n        dp[i][0]=a[i].t2;\n        for(j=1;j<=m;j++)\n        {\n            p[i][j]=p[i][j-1]*double(m-j+1)/double(j)*a[i].p/(1.0-a[i].p);\n            sum[i][j]=p[i][j]+sum[i][j-1];\n            dp[i][j]=dp[i][j-1]+a[i].t;\n            //cout<<dp[i][j]<<' ';\n        }\n        //cout<<endl;\n    }\n    /*\n    for(i=1;i<=n;i++)\n    {\n        for(j=0;j<=m;j++)\n        {\n            cout<<dp[i][j]<<\" \";\n        }cout<<endl;\n    }\n      for(i=1;i<=n;i++)\n    {\n        for(j=0;j<=m;j++)\n        {\n            cout<<sum[i][j]<<\" \";\n        }cout<<endl;\n    }\n     for(i=1;i<=n;i++)\n    {\n        for(j=0;j<=m;j++)\n        {\n            cout<<p[i][j]<<\" \";\n        }cout<<endl;\n    }*/\n    double ans=0;\n    for(i=1;i<=n;i++)\n    {\n        ans=0;\n        for(j=0;j<=m;j++)\n        {\n            double k=0,ans1=0;\n            ans1=p[i][j];\n            for(int ii=1;ii<=n;ii++)\n            {\n                k=0;\n                if(ii!=i){\n                for(int jj=0;jj<=m;jj++)\n                {\n\n                    if(dp[i][j]<dp[ii][jj])\n                    {\n                        k+=(1-sum[ii][jj])+p[ii][jj];\n\n                        break;\n                    }\n                }\n                ans1=ans1*k;\n                }\n            }\n            ans+=ans1;\n        }\n        printf(\"%lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nll combi(ll n, ll k) {\n  static ll c[55][55];\n  if(c[0][0] == 0) {\n    REP(i, 55) {\n      c[i][0] = c[i][i] = 1;\n      FOR(j, 1, i) c[i][j] = c[i-1][j] + c[i-1][j-1];\n    }\n  }\n  return c[n][k];\n}\n\npair<double, double> dp[105][55];\nint p[105], t[105], v[105];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m, L;\n  cin >> n >> m >> L;\n  REP(i, n) cin >> p[i] >> t[i] >> v[i];\n\n  combi(2, 0);\n\n  REP(i, n) {\n    REP(j, m+1) {\n      dp[i][j] = {j*t[i] + (double)L/v[i], combi(m, j) * pow(p[i]/100.0, j) * pow((100-p[i])/100.0, m-j)};\n      // cout << (double)combi(m, j) << \",\" << pow(p[i]/100.0, j) << \",\" << pow((100-p[i])/100.0, m-j) << \",\" << (100-p[i])/100.0 << \" \";\n      // cout << dp[i][j] << \" \";\n    }\n    // cout << endl;\n  }\n\n  vector<double> ans(n, 0);\n  // i人目がj回休んだ時に優勝する確率\n  REP(i, n) {\n    REP(j, m+1) {\n      double prob = dp[i][j].second;\n      REP(k, n) {\n        if(i==k) continue;\n        double sum = 0;\n        for(int l=m; l>=0; --l) {\n          if(dp[k][l].first <= dp[i][j].first) {\n            prob *= sum;\n            break;\n          }\n          sum += dp[k][l].second;\n        }\n      }\n      ans[i] += prob;\n    }\n  }\n\n  cout << fixed << setprecision(9);\n  REP(i, n) cout << ans[i] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+j*pl[i].t,pl[k].v+m*pl[k].t)){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n            if(res[i]<0.000000000001)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.5f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(abs(p[i]-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p[i],m);\n      long long int c = m;\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = c * pow(1-p[i],m-j) * pow(p[i],j) ;\n\tc *= m-j;\n\tc /= j+1;\n      }\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define N 120\n#define eps 1e-8\nusing namespace std;\n\nint dlcmp(double x) {return x<-eps?-1:x>eps;}\n\ndouble p[N],speed[N],rest[N][N],sum[N][N];\ndouble time[N];\nint n,m;\ndouble l;\n\nvoid calc(double p,double s[])\n{\n\tint i,j;\n\n\tmemset(rest,0,sizeof(rest));\n\trest[0][0]=1;\n\tfor (i=1;i<=m;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t{\n\t\t\trest[i][j]+=rest[i-1][j]*(1-p);\n\t\t\tif (j-1>=0)\n\t\t\t\trest[i][j]+=rest[i-1][j-1]*p;\n\t\t}\n\n\n\tfor (i=m;i>=0;i--)\n\t\ts[i]=s[i+1]+rest[m][i];\n}\n\nint main()\n{\n\tint i,j,k;\n\tdouble ans,curT;\n\n\twhile (scanf(\"%d%d%lf\",&n,&m,&l)!=EOF)\n\t{\n\t\tmemset(sum,0,sizeof(sum));\n\t\tfor (i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf%lf\",&p[i],&time[i],&speed[i]);\n\t\t\tp[i]/=100;\n\n\t\t\tcalc(p[i],sum[i]);\n\t\t}\n\n\t\t/*\n\t\tfor (i=1;i<=n;i++,printf(\"\\n\"))\n\t\t\tfor (j=0;j<=m;j++)\n\t\t\t\tprintf(\"%.3f \",sum[i][j]);\n\t\t*/\n\n\t\tfor (i=1;i<=n;i++)\n\t\t{\n\t\t\tans=0;\n\t\t\tfor (j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tcurT=l/speed[i]+time[i]*j;\n\t\t\t\tdouble tmp=sum[i][j]-sum[i][j+1];\n\t\t\t\tint flag=1;\n\n\t\t\t\tfor (k=1;k<=n;k++)\n\t\t\t\t\tif (k!=i)\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble r=curT-l/speed[k];\n\n\t\t\t\t\t\tint idx=r/time[k];\n\t\t\t\t\t\tidx=max(0,idx);\n\t\t\t\t\t\twhile (dlcmp(idx*time[k]-r)<=0&&idx<=m)\tidx++;\n\n\t\t\t\t\t\tif (idx>m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttmp*=sum[k][idx];\n\t\t\t\t\t}\n\n\t\t\t\tif (flag)\n\t\t\t\t\tans+=tmp;\n\t\t\t}\n\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nll comb[51][51];\nint N, M, L;\nint P[110], T[110], V[110];\ndouble pos[110][51], cpos[110][51];\ndouble t[110][51];\n\nvoid init() {\n  for (int i = 0; i <= 50; i++) {\n    comb[i][0] = comb[i][i] = 1;\n    for (int j = 1; j < i; j++) {\n      comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  init();\n  cin >> N >> M >> L;\n  for (int i = 0; i < N; i++) {\n    cin >> P[i] >> T[i] >> V[i];\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= M; j++) {\n      double tmp = 1.0;\n      for (int k = 0; k < j; k++) {\n        tmp *= P[i] / 100.0;\n      }\n      for (int k = 0; k < M - j; k++) {\n        tmp *= (100 - P[i]) / 100.0;\n      }\n      pos[i][j] = comb[M][j] * tmp; \n    }\n    cpos[i][M] = pos[i][M];\n    for (int j = M-1; j >= 0; j--) {\n      cpos[i][j] = pos[i][j] + cpos[i][j+1];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= M; j++) {\n      t[i][j] = (double)L / V[i] + j * T[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    double sum = 0;\n    for (int j = 0; j <= M; j++) {\n      double tmp = pos[i][j];\n      for (int k = 0; k < N; k++) {\n        if (k == i) continue;\n        bool cant = true;\n        for (int l = 0; l <= M; l++) {\n          if (t[i][j] < t[k][l]) {\n            tmp *= cpos[k][l];\n            cant = false;\n            break;\n          }\n        }\n        if (cant) tmp = 0;\n      }\n      sum += tmp;\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[110];\nint t[110];\nint v[110];\ndouble dp[110][110];\ndouble prob[110][110];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",p+i,t+i,v+i);\n\t\tfor(int j=0;j<=b;j++)for(int k=0;k<=b;k++)dp[j][k]=0;\n\t\tdp[0][0]=1;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tdp[j+1][k+1]+=dp[j][k]*p[i]/100;\n\t\t\t\tdp[j+1][k]+=dp[j][k]*(100-p[i])/100;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=b;j++)prob[i][j]=dp[b][j];\n\t}\n\tdouble EPS=1e-9;\n\tfor(int i=0;i<a;i++){\n\t\tdouble ret=0;\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tdouble time=(double)c/v[i]+j*t[i];\n\t\t\tdouble ks=prob[i][j];\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(i==k)continue;\n\t\t\t\tdouble tmp=0;\n\t\t\t\tfor(int l=0;l<=b;l++){\n\t\t\t\t\tif(time+EPS>(double)c/v[k]+l*t[k])continue;\n\t\t\t\t\ttmp+=prob[k][l];\n\t\t\t\t}\n\t\t\t\tks*=tmp;\n\t\t\t}\n\t\t\tret+=ks;\n\t\t}\n\t\tprintf(\"%.12f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[100][100] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\ndouble get(int c,int n,double p)\n{\n    return C(c,n)*pow(p,c)*pow(1-p,n-c);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        memset(peo,0,sizeof(peo));\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        if(n==1)\n        {\n            printf(\"%.8lf\\n\",v[i]?1:0);\n            continue;\n        }\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=get(j,m,p[i]/100.0);\n            }\n        for(int i=0; i<n; i++)\n        {\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i||!v[i])\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint N, M, L, P[100], T[100], V[100];\ndouble p[100][51];\n\nll combination(ll n, ll r) {\n  static ll comb[51][51];\n  ll &ret = comb[n][r];\n  if(ret != 0) return ret;\n  if(n == 0 || r == 0) return ret = 1;\n  if(n == r) return ret = 1;\n  if(r == 1) return ret = n;\n  return ret = combination(n - 1, r - 1) + combination(n - 1, r);\n}\n\nbool ok(int ai, int aj, int bi, int bj) {\n  double ta = L / V[ai] + T[ai] * aj;\n  double tb = L / V[bi] + T[bi] * bj;\n  return ta < tb;\n}\n\nint main(void) {\n  cin >> N >> M >> L;\n  REP(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n  REP(i, 0, N) REP(j, 0, M + 1) {\n    p[i][j] = combination(M, j) * pow(P[i] / 100.0, j) * pow(1 - P[i] / 100.0, M - j);\n  }\n\n  REP(i, 0, N) {\n    double ans = 0;\n    double pi = 0;\n    REP(j, 0, M + 1) {\n      pi = p[i][j];\n      double pij = pi;\n      REP(k, 0, N) if(i != k) {\n        double pk = 0;\n        REP(l, 0, M + 1) if(ok(i, j, k, l)) pk += p[k][l];\n        pij *= pk;\n      }\n      ans += pij;\n    }\n    printf(\"%.8lf\\n\", ans);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nlong long cm(int n,int m){  \n  m=n-m<m?n-m:m;\n  long long a=1;\n  int b=n-m+1,c=1;\n  for(;c<=m;){\n    a=a*b/c;\n    ++b;\n    ++c;\n  }\n  return a;\n}\nint main(){\n  int i,j,k;\n  int n,m,l;\n  scanf(\"%d%d%d\",&n,&m,&l);\n  int a[100],b[100],c[100];\n  for(i=0;i<n;++i)\n    scanf(\"%d%d%d\",a+i,b+i,c+i);\n  long long d[51];\n  for(i=0;i<=(m+1)/2;++i)\n    d[i]=d[m-i]=cm(m,i);\n  double e[100][51],f[100][51],g[100][52];\n  for(i=0;i<n;++i){\n    g[i][m+1]=0;\n    for(j=m;j>=0;--j){\n      e[i][j]=(double)l/c[i]+b[i]*j;\n      f[i][j]=pow((double)a[i]/100,j)*pow((double)(100-a[i])/100,m-j)*d[j];\n      g[i][j]=g[i][j+1]+f[i][j];\n    }\n  }\n  for(i=0;i<n;++i){\n    double pr=0;\n    for(j=0;j<=m;++j){\n      double pi=f[i][j];\n      for(k=0;k<n;++k){\n\tif(i!=k)\n\t  pi*=g[k][upper_bound(e[k],e[k]+m+1,e[i][j])-e[k]];\n      }\n      pr+=pi;\n    }\n    printf(\"%.8f\\n\",pr);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++)cin >> p[i] >> t[i] >> v[i];\n\n  if(n==1){\n    printf(\"%.8lf\\n\",1.0);\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(!v[i])time[i][j] = 1e+10;\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  double k = 1.0;\n  for(int i=0;i<m;i++)k*=100.0;\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(100-p[i],m);\n    prob[i][0] /= k;\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(100-p[i],m-j) * pow(p[i],j);\n      prob[i][j] /= k;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nstruct Tag {\n    double p, t, v;\n};\n\ndouble dp[51][100][51]; // dp[M][N][k] for k rests\ndouble tim[100][51];\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n\n    vector<Tag> v;\n    for(int i = 0; i < N; ++i) {\n        Tag t;\n        cin >> t.p >> t.t >> t.v;\n        t.p /= 100;\n        v.push_back(t);\n    }\n\n    for(int i = 0; i < N; ++i) {\n        dp[0][i][0] = 1;\n    }\n    for(int m = 1; m <= M; ++m) {\n        for(int n = 0; n < N; ++n) {\n            for(int k = 0; k <= M; ++k) {\n                dp[m][n][k] = v[n].p*dp[m-1][n][k-1] + (1-v[n].p)*dp[m-1][n][k];\n                //printf(\"%d %d %d = %d\\n\", m, n, k, dp[m][n][k]);\n            }\n        }\n    }\n    for(int n = 0; n < N; ++n) {\n        tim[n][0] = (double)L / v[n].v;\n        for(int k = 1; k <= M; ++k) {\n            tim[n][k] = tim[n][k-1] + v[n].t;\n        }\n    }\n    for(int n = 0; n < N; ++n) {\n        double prob = 0;\n        if(v[n].v == 0) goto END;\n\n        for(int k = 0; k <= M; ++k) {\n            double tmp = dp[M][n][k];\n            for(int nn = 0; nn < N; ++nn) {\n                if(n == nn) continue;\n                double *bound = upper_bound(tim[nn], tim[nn]+M+1, tim[n][k]);\n                int idx = bound - tim[nn];\n                double sum = 0;\n                for(int i = idx; i <= M; ++i) sum += dp[M][nn][i];\n                tmp *= sum;\n            }\n            prob += tmp;\n        }\nEND:\n        printf(\"%.6f\\n\", prob);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define FOR(i,c) for (__typeof((c).begin())i=(c).begin(); i!=(c).end(); ++i)\n\nint main() {\n    int n, m , L;\n    cin >> n >> m >> L;\n    int v[n];\n    double t[n][m+1], p[n][m+1], sump[n][m+1];\n    for (int i=0; i<n; ++i) {\n        double pp, tt;\n        cin >> pp>>tt>>v[i];\n        pp/=100;\n        \n        for (int k=0; k<=m; ++k) {\n            p[i][k] = 1;\n            for (int l=0; l<=m; ++l) {\n                if (l < k) p[i][k] *= m-l;\n                if (k-l >= 1) {\n                    p[i][k] /= k-l;\n                }\n                if (l<k) p[i][k] *= pp;\n                if (l<m-k) p[i][k] *= (1.0-pp);\n            }\n            t[i][k] = (double)L/v[i] + k*tt;\n//            printf(\"i=%d, k=%d %f\\n\", i,k,p[i][k]);\n            if (k>0)\n                sump[i][k] = sump[i][k-1] + p[i][k];\n            else\n                sump[i][k] = p[i][k];\n        }\n    }\n    \n    double ans[n];\n    for (int i=0;i<n;++i) ans[i] = 0;\n\n    for (int i=0; i<n; ++i) {\n        for (int j=0; j<=m; ++j) {           \n            double tmp = p[i][j];\n            for (int k=0; k<n; ++k) {\n                if (i==k) continue;\n                if (upper_bound(t[k], t[k]+m+1, t[i][j])-t[k] == 0) {\n                    \n//                    printf(\"zero %d %d\\n\", i, j);\n                    // tmp = 0;\n                    // break;\n                }\n                else \n                    tmp *= (1.0 - sump[k][upper_bound(t[k], t[k]+m+1, t[i][j])-t[k]-1]);\n            }\n//            printf(\"%d,%d %f\\n\", i,j,tmp);\n            ans[i] += tmp;\n        }\n    }\n\n    for (int i=0;i<n;++i)\n        printf(\"%.12f\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_M 50\n#define INF (1<<29)\n\nint get_time(double L, double V, double T, double A)\n{\n    return L/V + T*A;\n}\n\nint main()\n{\n    int N, M;\n    double L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n    double p[MAX_N][MAX_M+2][MAX_M+2];\n    memset(p, 0, sizeof(p));\n\n    for (int i = 0; i < N; i++) {\n        p[i][0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k < M; k++) {\n                p[i][j+1][k]   += p[i][j][k] * (1 - P[i]);\n                p[i][j+1][k+1] += p[i][j][k] * P[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        double res = 0;\n        for (int j = 0; j <= M; j++) {\n            double t = get_time(L, V[i], T[i], j);\n            double r = 1;\n            bool win = 1;\n            for (int k = 0; k < N; k++) {\n                if (i == k) {\n                    continue;\n                }\n                double rr = 0;\n                bool ok = 0;\n                for (int l = 0; l <= M; l++) {\n                    double t2 = get_time(L, V[k], T[k], l);\n                    if (t < t2) {\n                        ok = 1;\n                        rr += p[k][M][l];\n                    } \n                }\n                if (!ok) {\n                    win = 0;\n                    break;\n                }\n                r *= rr;\n            }\n            res += (win ? r * p[i][M][j] : 0);\n        }\n        printf(\"%.8f\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define Max 200\n#define eps 1e-10\n#define LL long long\n\nLL comb(LL n,LL m){\n\tLL ret=1,i;\n\tm=m<(n-m)?m:(n-m);\n\tfor (i=n-m+1;i<=n;ret*=(i++));\n\tfor (i=1;i<=m;ret/=(i++));\n\treturn m<0?0:ret;\n}\n\ndouble a[Max][Max], aa[Max][Max];\n\nstruct node\n{\n\tdouble p, time, v;\n}Node[Max], Nodeb[Max];\n\ndouble ppow (double p, LL num)\n{\n\tdouble ans = 1.0;\n\tfor (LL i = 1;i <= num;i ++)\n\t\tans = ans * p;\n\treturn ans;\n}\n\nint main ()\n{\n\tLL n, m, L, i, j, k, q, num;\n\twhile (scanf (\"%lld%lld%lld\", &n, &m, &L) == 3)\n\t{\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tscanf (\"%lf%lf%lf\", &Node[i].p, &Node[i].time, &Node[i].v);\n\t\t\tNode[i].p /= 100.0;\n\t\t}\n\t\tmemset (a, 0, sizeof (a));\n\t\tmemset (aa, 0, sizeof (aa));\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tfor (j = 0;j <= m;j ++)\n\t\t\t{\n\t\t\t\tnum = comb(m, j);\n\t\t\t\ta[i][j] = (double)num * ppow (Node[i].p, j) * ppow((1 - Node[i].p), m - j);\n\t\t\t\taa[i][j] = (double)j * Node[i].time + 1.0 * L / Node[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdouble res = 0.0;\n\t\tfor(i = 0 ; i < n ; i++)\n\t\t{\n\t\t\tdouble tmp;\n\t\t\tres = 0.0;\n\t\t\tfor(j = 0 ; j <= m ;j++)\n\t\t\t{\n\t\t\t\ttmp = a[i][j];\n\t\t\t\tfor(k = 0 ; k < n ; k++)\n\t\t\t\t{\n\t\t\t\t\tif( k == i ) continue;\n\n\t\t\t\t\tdouble t = 0.0;\n\t\t\t\t\tfor(q = 0 ; q <= m ; q++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif( aa[k][q]-aa[i][j] > eps )\n\t\t\t\t\t\t\tt += a[k][q];\n\t\t\t\t\t}\n\t\t\t\t\ttmp *= t;\n\t\t\t\t}\n\t\t\t\tres += tmp;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\", res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\nlong double C[N][N];\n\nlong double prob[N][N];\nlong double _time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\tif (!v[i]) continue;\n\t\t_time[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) _time[i][j] = _time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tlong double a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tlong double ct = _time[i][j];\n\t\t\tlong double cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tlong double tmp = 0;\n\t\t\t\twhile (idx >= 0 && _time[k][idx] > ct) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N],mem[M][M];\n\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=pow(1-p[0],m-i)*pow(p[0],i)*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*pow(1-p[i],m-k)*pow(p[i],k)*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.16lf\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // N 人, M 箇所, 距離 L\n    int N, M, L;\n    cin >> N >> M >> L;\n    // 休憩確率, 休憩時間, 速度\n    vector<ld> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++)\n    {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n    // comb[i][j] := iCj\n    ld comb[60][60];\n    for (int i = 0; i <= 50; i++)\n        comb[i][0] = 1.0;\n    for (int i = 1; i <= 50; i++)\n    {\n        for (int j = 1; j <= i; j++)\n        {\n            comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n        }\n    }\n    // pn[i][j] := i 人目が j 回休憩する確率\n    // tn[i][j] := i 人目が j 回休んだ時の所要時間 (L/V[i] + j*T)\n    vector<vector<ld>> pn(N, vector<ld>(M + 1)), tn(N, vector<ld>(M + 1));\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j <= M; j++)\n        {\n            tn[i][j] = ld(L) / V[i] + j * T[i];\n            pn[i][j] = comb[M][j] * pow(P[i], j) * pow(1.0 - P[i], M - j);\n        }\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (abs(V[i]) < EPS)\n        {\n            cout << fixed << setprecision(10) << 0.0 << endl;\n            continue;\n        }\n        ld res = 0;\n        for (int j = 0; j <= M; j++)\n        {\n            ld p = pn[i][j];\n            for (int k = 0; k < N; k++)\n            {\n                if (k == i)\n                    continue;\n                if (abs(V[i]) < EPS)\n                    continue;\n                ld sum = 0;\n                for (int l = 0; l <= M; l++)\n                {\n                    if (tn[k][l] > tn[i][j] + EPS)\n                        sum += pn[k][l];\n                }\n                p *= sum;\n            }\n            res += p;\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define eps 1e-6\n#define inf 10000000\nstruct node\n{\n    double p,t,v;\n    double time[60];\n    double po[60];\n    double posum[60];\n    double ans;\n}me[109];\ndouble f[60][60];\ndouble solve(double p, int k, int m)\n{\n    double res = 1;\n    int i,j;\n    for(i = 1; i <= k; i++)\n    res *= p;\n    for(i = 1; i <= m - k; i++)\n    res *= (1 - p);\n    return res;\n}\nint main()\n{\n    int m,n,i,j,k,x,flag;\n    double l,ss;\n    for(i = 1; i < 51; i++)\n    {\n    f[i][0] = 1;\n    f[i][i] = 1;\n    f[i][1] = i;\n    }\n    for(i = 2; i <= 50; i++)\n        for(j = 1; j <= i; j++)\n        f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n    while(~scanf(\"%d%d%lf\",&n,&m,&l))\n    {\n        for(i = 1; i <= n; i++)\n        {\n            scanf(\"%lf%lf%lf\",&me[i].p,&me[i].t,&me[i].v);\n            me[i].posum[0] = 0;\n            for(j = 1; j <= m + 1; j++)\n            {\n            me[i].posum[j] = 0;\n            me[i].time[j] = l / me[i].v + (j - 1) * me[i].t;\n            me[i].po[j] = solve(me[i].p / 100.0,j - 1,m) * f[m][j - 1];\n            me[i].posum[j] = me[i].posum[j - 1] + me[i].po[j];\n            }\n            me[i].posum[m + 1] = 1;\n        }\n            for(i = 1; i <= n; i++)\n            {\n                me[i].ans = 0;\n                for(j = 1; j <= m + 1; j++)\n                {\n                    ss = me[i].po[j];\n                    for(k = 1; k <= n; k++)\n                    if(i == k);\n                    else\n                    {\n                        flag = 0;\n                        for(x = 1; x <= m + 1; x++)\n                        if(me[i].time[j] < me[k].time[x])\n                        {\n                        ss *= (1 - me[k].posum[x] + me[k].po[x]);\n                        flag = 1;\n                        break;\n                        }\n                        if(flag == 0)\n                        break;\n                    }\n                    if(flag == 0)\n                    ss = 0;\n                    me[i].ans += ss;\n                }\n            }\n            for(i = 1; i <= n; i++)\n            printf(\"%lf\\n\",me[i].ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N],mem[M][M];\n\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=pow(1-p[0],m-i)*pow(p[0],i)*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*pow(1-p[i],m-k)*pow(p[i],k)*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAXN 110\n#define INF 0x3f3f3f3f\n#define PI acos(-1.0)\n#define MAX(a,b) (a>b?a:b)\n#define MIN(a,b) (a<b?a:b)\n#define ABS(m) (m<0?-m:m)\ntypedef long long LL;\n\nint n,m,l;\nLL c[MAXN][MAXN];\nint p[MAXN],t[MAXN],v[MAXN];\n\nvoid Init()\n{\n    int i,j;\n    scanf(\"%d%d%d\",&n,&m,&l);\n    for(i=1;i<=n;++i)\n        scanf(\"%d%d%d\",p+i,t+i,v+i);\n    c[0][0]=1;\n    for(i=1;i<=50;++i)\n        for(j=1,c[i][0]=1;j<=i;++j)\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n}\n\nlong double C(long double P,int N,int M)\n{\n    int i; long double ans=c[N][M];\n    for(i=1;i<=M;++i) ans*=P;\n    for(;i<=N;++i) ans*=(1-P);\n    return ans;\n}\n\nvoid Work()\n{\n    int i,j,k,x;\n    long double ans,r1,r2;\n    long double P[MAXN][2];\n    LL t1,t2;\n    for(i=1;i<=n;++i){\n        for(ans=0,j=0;j<=m;++j){\n            t1=l+1LL*j*t[i]*v[i];\n            r1=C(p[i]/100.0,m,j);\n            for(k=1;k<=n;++k){\n                if(k==i) continue;\n                for(x=1,P[0][0]=P[0][1]=1;x<=m;++x)\n                    P[x][0]=P[x-1][0]*p[k]/100.0,P[x][1]=P[x-1][1]*(1-p[k]/100.0);\n                for(x=r2=0,t2=l;x<=m&&t2*v[i]<=t1*v[k];t2+=1LL*t[k]*v[k],++x);\n                for(r2=0;x<=m;++x) r2+=((long double)c[m][x])*P[x][0]*P[m-x][1];\n                r1*=r2;\n            }\n            ans+=r1;\n        }\n        printf(\"%.12f\\n\",(double)ans);\n    }\n}\n\nint main()\n{\n    Init();\n    Work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int64_t i64;\nconst int NMAX = 1000;\nconst long double eps = 1e-9;\n\nint N, M, L;\nint P[NMAX], T[NMAX], V[NMAX];\nlong double answer[NMAX];\nvector<long double> value[NMAX], prob[NMAX];\n\nint getSign(long double value) {\n\tif (value < -eps)\n\t\treturn -1;\n\tif (value > eps)\n\t\treturn 1;\n\treturn 0;\n}\n\ni64 repeatedPerm(int a, int b) {\n\tunordered_map<int, int> primeFact;\n\tint c = a + b;\n\tfor (int i = 2; i <= c; ++i) {\n\t\tint currNum = i;\n\t\tfor (int j = 2; j <= sqrt(currNum) + 0.5; j += 2) {\n\t\t\twhile (currNum % j == 0) {\n\t\t\t\t++primeFact[j];\n\t\t\t\tcurrNum /= j;\n\t\t\t}\n\t\t\tif (j == 2)\n\t\t\t\tj = 1;\n\t\t}\n\t\tif (currNum > 1)\n\t\t\t++primeFact[currNum];\n\t}\n\tfor (int i = 2; i <= a; ++i) {\n\t\tint currNum = i;\n\t\tfor (int j = 2; j <= sqrt(currNum) + 0.5; j += 2) {\n\t\t\twhile (currNum % j == 0) {\n\t\t\t\t--primeFact[j];\n\t\t\t\tcurrNum /= j;\n\t\t\t}\n\t\t\tif (j == 2)\n\t\t\t\tj = 1;\n\t\t}\n\t\tif (currNum > 1)\n\t\t\t--primeFact[currNum];\n\t}\n\tfor (int i = 2; i <= b; ++i) {\n\t\tint currNum = i;\n\t\tfor (int j = 2; j <= sqrt(currNum) + 0.5; j += 2) {\n\t\t\twhile (currNum % j == 0) {\n\t\t\t\t--primeFact[j];\n\t\t\t\tcurrNum /= j;\n\t\t\t}\n\t\t\tif (j == 2)\n\t\t\t\tj = 1;\n\t\t}\n\t\tif (currNum > 1)\n\t\t\t--primeFact[currNum];\n\t}\n\n\ti64 answer = 1;\n\tfor (auto it: primeFact) {\n\t\tint curr = it.second;\n\t\twhile (curr--)\n\t\t\tanswer *= it.first;\n\t}\n\treturn answer;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j, k, l;\n\n\tcin >> N >> M >> L;\n\tfor (i = 1; i <= N; ++i)\n\t\tcin >> P[i] >> T[i] >> V[i];\n\n\tfor (i = 1; i <= N; ++i) {\n\t\tlong double time = L / (long double)V[i];\n\t\tfor (j = 0; j <= M; ++j, time += T[i]) {\n\t\t\ti64 currCases = repeatedPerm(j, M - j);\n\t\t\tlong double probability = pow(P[i] / (long double)100, j) * pow(1 - P[i] / (long double)100, M - j);\n\t\t\tprob[i].push_back(probability * currCases);\n\t\t\tvalue[i].push_back(time);\n\t\t}\n\t}\n\n\tfor (i = 1; i <= N; ++i) {\n\t\tfor (j = 0; j <= M; ++j) {\n\t\t\tlong double currProb = prob[i][j];\n\t\t\tfor (k = 1; k <= N; ++k) {\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tlong double nowProb = 0;\n\t\t\t\tfor (l = M; l >= 0 && value[k][l] > value[i][j]; --l)\n\t\t\t\t\tnowProb += prob[k][l];\n\t\t\t\tcurrProb *= nowProb;\n\t\t\t}\n\t\t\tanswer[i] += currProb;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(8);\n\tfor (i = 1; i <= N; ++i)\n\t\tcout << answer[i] << '\\n';\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//10\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ndouble fact(int x){\n  double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n\tif(i!=k){\n\t  int x=lower_bound(at[k],at[k]+m+1,at[i][j]+1e-5)-at[k];\n\t  c*=1-acp[k][x];\n\t}\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n;\n\tint m;\n\tint l;\n\tcin >> n >> m >> l;\n\tvector<int> p;\n\tvector<int> t;\n\tvector<int> v;\n\tint a;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> a;\n\t\tp.push_back(a);\n\t\tcin >> a;\n\t\tt.push_back(a);\n\t\tcin >> a;\n\t\tv.push_back(a);\n\t}\n\tlong long int c[51][51] = {0};\n\tfor ( int i = 0; i <= m; i++ ) {\n\t\tfor ( int j = 0; j <= i; j++ ) {\n\t\t\tif ( j == 0 || j == i ) {\n\t\t\t\tc[i][j] = 1;\n\t\t\t}else {\n\t\t\t\tc[i][j] = c[i-1][j-1] + c[i-1][j];\n\t\t\t}\n\t\t}\n\t}\n\tdouble goaltime;\n\tdouble pro;\n\tdouble s;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\ts = 0.00;\n\t\tif ( v[i] == 0 ) {\n\t\t\tcout << fixed << s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( int x = 0; x <= m; x++ ) {\n\t\t\tgoaltime = double(l) / v[i] + t[i] * x;\n\t\t\tpro = pow( 0.01*p[i] , x ) * pow( 1.00 - 0.01*p[i] , m - x ) * c[m][x];\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tif ( i == j ) continue;\n\t\t\t\tif ( v[j] == 0 ) {\n\t\t\t\t\tcout << fixed << 0.00 << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble g;\n\t\t\t\tg = goaltime - double(l) / v[j];\n\t\t\t\tint y;\n\t\t\t\tif ( t[j] == 0 ) {\n\t\t\t\t\tif ( g >= 0 ) y = m + 1;\n\t\t\t\t}else {\n\t\t\t\t\ty = (int)g / t[j] + 1;\n\t\t\t\t}\n\t\t\t\tif ( g < 0 ) y = 0;\n\t\t\t\tif ( y > m ) {\n\t\t\t\t\tpro = 0.00;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble z = 0.00;\n\t\t\t\tfor ( y; y <= m; y++ ) {\n\t\t\t\t\tz += pow( 0.01*p[j] , y ) * pow( 1.00 - 0.01*p[j] , m - y ) * c[m][y];\n\t\t\t\t}\n\t\t\t\tpro = pro * z;\n\t\t\t}\n\t\t\ts += pro;\n\t\t}\n\t\tcout << fixed << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\nlong long C[N][N];\n\nlong double prob[N][N];\nlong double _time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\t_time[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) _time[i][j] = _time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tlong double a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tlong double ct = _time[i][j];\n\t\t\tlong double cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tlong double tmp = 0;\n\t\t\t\twhile (idx >= 0 && _time[k][idx] > ct) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\ndouble C(int a,int b)\n{\n\tb=std::min(a-b,b);\n\tdouble r=1;\n\tfor(int i=1;i<=b;++i)r=r*(a-b+i)/i;\n\treturn r;\n}\ndouble F(double a,int b)\n{\n\tdouble r=1,x=a;\n\tfor(;b;b>>=1)\n\t{\n\t\tif(b&1)r*=x;\n\t\tx*=x;\n\t}\n\treturn r;\n}\nint n,m,l;\nint p[100],t[100],v[100];\ndouble EPS = 5e-10;\ntypedef std::pair<double,double>P;\nP*q,a[100][51];\ndouble R(int i,int j){return C(m,j)*F(p[i]/100.0,j)*F(1-p[i]/100.0,m-j);}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&l);;\n\tint i,j,k;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tscanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n\t\tdouble x=0;\n\t\tfor(j=0;j<=m;++j)\n\t\t{\n\t\t\ta[i][j].first = j*t[i] + (double)l/v[i];\n\t\t\ta[i][j].second=R(i,j)+x;\n\t\t\tx+=a[i][j].second;\n\t\t}\n\t}\n\tdouble t,r;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tr=0;\n\t\tfor(j=0;j<=m;++j)\n\t\t{\n\t\t\tt=1;\n\t\t\tfor(k=0;k<n;++k)\n\t\t\t{\n\t\t\t\tif(i==k)continue;\n\t\t\t\tif(a[i][j].first+EPS < a[k][0].first);\n\t\t\t\telse if(a[i][j].first-EPS > a[k][m].first)t=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tq=std::lower_bound(a[k],a[k]+m+1,P(a[i][j].first+EPS,-1));\n\t\t\t\t\tt*=(1-q[-1].second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr+=t*R(i,j);\n\t\t}\n\t\tprintf(\"%.12f\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nstruct runner{\n\tint t,v;\n\tdouble p;\n};\n\nconst int INF=1000000000;\n\nvector<runner> vr;\ndouble mem[101][51][101];\n// kÍxe·éêÌ\ndouble calcPer(int n,int k,int idx){\n\tif(!EQ(mem[n][k][idx],INF))\n\t\treturn mem[n][k][idx];\n\tdouble p = vr[idx].p;\n\tif(k==0)\n\t\treturn 1.0;\n    return mem[n][k][idx]=(((double)n/k)*calcPer(n-1,k-1,p)*p);\n}\n\nint main(){\n\tint n,m,L;\n\tfor(int i = 0; i < 101; i++)\n\t\tfor(int j = 0; j < 51; j++)\n\t\t\tfor(int k = 0; k < 101; k++)\n\t\t\t\tmem[i][j][k]=INF;\n\tcin>>n>>m>>L;\n\tfor(int i = 0; i < n; i++){\n\t\trunner r;\n\t\tint p;\n\t\tcin>>p>>r.t>>r.v;\n\t\tr.p=(double)p/100;\n\t\tvr.push_back(r);\n\t}\n\t// êl¸ÂßÄ¢­\n\tfor(int i = 0; i < n; i++){\n\t\tdouble sumPer=0.0;\n\t\tif(vr[i].v!=0){\n\t\t\t// ©ªª¢­ÂÌêÅxe·é©\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t// »ÝÌxeÅxe·ém¦\n\t\t\t\tdouble cper=calcPer(m,j,i)*pow((double)(1-vr[i].p),m-j);\n\t\t\t\tdouble selfTime=((double)L/vr[i].v)+vr[i].t*j;\n\t\t\t\t// »ê¼êÌGÉÂ¢Ä²×é\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t// ©ª©gÜ½ÍA¬xª0Ìi[Í³·é\n\t\t\t\t\tif(i==k||EQ(vr[k].v,0.0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble enemPer=1.0;\n\t\t\t\t\t// èª¢­ÂÈãÌêÅxeµ½çAÔÉ¤©ð`FbN\n\t\t\t\t\tfor(int l = 0; l <= m; l++){\n\t\t\t\t\t\t// GÌBðvZ\n\t\t\t\t\t\tdouble enemyTime=((double)L/vr[k].v)+vr[k].t*l;\n\t\t\t\t\t\t// àµGÌBÔª©ªÌBÔðãñÁ½çI¹\n\t\t\t\t\t\tif(!EQ(enemyTime,selfTime)&&enemyTime>selfTime)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// ±ÌÌêÅxe·ém¦\n                        double p=calcPer(m,l,k)*pow((double)(1-vr[k].p),m-l);\n\t\t\t\t\t\tenemPer-=p;\n\t\t\t\t\t}\n\t\t\t\t\t// »ÝcÁÄ¢ém¦ªAGª©ªæèx­B·ém¦\n\t\t\t\t\tcper*=enemPer;\n\t\t\t\t}\n\t\t\t\t// cperª»Ìm¦\n\t\t\t\tsumPer+=cper;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",sumPer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[2][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<iomanip>\nusing namespace std;\n\n#define MAX_N 1000\n\ndouble x[MAX_N][MAX_N];\ndouble t[MAX_N][MAX_N];\nint n, m, l;\nint p[MAX_N][3];\ndouble dp[MAX_N][MAX_N];\ndouble boss[MAX_N];\ndouble kakuritsu;\ndouble res;\n\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int h = 0; h < n; h++) {\n\t\tcin >> p[h][0] >> p[h][1] >> p[h][2];\n\t\t//kakuritsu calc.\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1.0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * (100.0 - p[h][0]) / 100.0;\n\t\t\t\tdp[i][j + 1] += 1.0 * dp[i - 1][j] * p[h][0] / 100.0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tx[h][i] = dp[m][i];\n\t\t}\n\t\t//time calc.\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tt[h][i] = (1.0*l / p[h][2]) + p[h][1] * i;\n\t\t}\n\t}\n\t//kakuritsu calc 2.\n\tfor (int h = 0; h < n; h++) {\n\t\tres = 0.0;\n\t\tfor (int i = 0; i <= m; i++) {\n\t\tmemset(boss, 0, sizeof(boss));\n\t\tkakuritsu = 1.0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (h != j) {\n\t\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\t\tif (t[h][i] < t[j][k]) {\n\t\t\t\t\t\t\tboss[j] += x[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkakuritsu *= boss[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += kakuritsu*x[h][i];\n\t\t}\n\t\tcout << fixed << setprecision(15) << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p;\n  int t,v;\n  double time[100][51],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p >> t >> v;\n    p /= 100;\n    for(int j=0;j<=m;j++)time[i][j] = (double)l/v + t*j;\n  \n    if(abs(p-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p,m);\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = ( prob[i][j-1] * p * (m-j+1) ) / ( (1-p)*j );\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    for(int j=0;j<=m;j++){\n      double tmp = 1.0;\n      for(int k=0;k<n;k++){\n\tif(k!=i){\n\t  double hoge = 0.0;\n\t  for(int l=m;l>=0;l--){\n\t    if(time[k][l] > time[i][j]){\n\t      hoge += prob[k][l];\n\t    }else break;\n\t  }\n\t    tmp *= hoge;\n\t}\n      }\n      ans += tmp*prob[i][j];\n    }\n    printf(\"%.8lf\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n,vector<ld>(m+1,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=m;j++){\n            pos[i][j]=j*log(p[i]+1e-30)+(m-j)*log(1-p[i]+1e-30);\n            for(int k=0;k<=m;k++){\n                pos\n            }\n            pos[i][j]=exp(pos[i][j]);\n        }\n        // vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        // comb[0][0]=1;\n        // for(int j=0;j<=m;j++){\n        //     for(int k=0;k<=j;k++){\n        //         if(k==0){\n        //             comb[j][k]=(p[i]==1 ? ld(0) : ld(pow(1-p[i],ld(j))));\n        //         }\n        //         else if(k==j){\n        //             comb[j][k]=(p[i]==0 ? ld(0) : ld(pow(p[i],j)));\n        //         }\n        //         else{\n        //             comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n        //         }\n        //     }\n        // }\n        // pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                ld z=0;\n                for(int y=0;y<=m;y++){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]<l*v[i]+y*t[j]*v[i]*v[j]){\n                        z+=pos[j][y];\n                    }\n                }\n                sc*=z;\n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nld dp[55][55];\n\nld cal(ld p, int n, int k)\n{\n\tif (n == 0) return(k == 0 ? 1.0 : 0);\n\tif (dp[n][k] >= 0) return dp[n][k];\n\tld l = (1 - p)*cal(p, n - 1, k);\n\tld r = p*cal(p, n - 1, k - 1);\n\treturn dp[n][k] = l + r;\n}\n\n\nint main()\n{\n\tint n, m;\n\tld l;\n\tcin >> n >> m >> l;\n\tvector<vector<pair<ld, ld>>> v(n);\n\tREP(i, n)\n\t{\n\t\tld p, t, s;\n\t\tcin >> p >> t >> s;\n\t\tp /= 100;\n\t\tif (s == 0)\n\t\t{\n\t\t\tv[i].emplace_back(INF, 1.0);\n\t\t\tcontinue;\n\t\t}\n\t\tMS(dp, -1);\n\t\tREP(j, m + 1) v[i].emplace_back(l / s + t*j, cal(p, m, j));\n\t}\n\tvector<ld> ans;\n\tREP(i, n)\n\t{\n\t\tld sum = 0;\n\t\tREP(j, v[i].size())\n\t\t{\n\t\t\tld ex = v[i][j].second;\n\t\t\tld t = v[i][j].first;\n\t\t\tREP(k, n)\n\t\t\t{\n\t\t\t\tif (k == i) continue;\n\t\t\t\tld ext = 0;\n\t\t\t\tREP(kk, v[k].size())\n\t\t\t\t{\n\t\t\t\t\tif (v[k][kk].first > t)\n\t\t\t\t\t{\n\t\t\t\t\t\text += v[k][kk].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tex *= ext;\n\t\t\t}\n\t\t\tsum += ex;\n\t\t}\n\t\tans.push_back(sum);\n\t}\n\tREP(i, n) cout << D10 << ans[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n\nll C[51][51];\nint N,M,L;\nint P[102],T[102],V[102];\ndouble A[102][51];\ndouble B[102][51];\n\ndouble f(int a,int b) {\n    double ret=A[a][b];\n    rep(i,N) if(a!=i) {\n        double p=0;\n        rep(j,M+1) {\n            if(B[a][b]<B[i][j]) p+=A[i][j];\n        }\n        ret*=p;\n    }\n\n    return ret;\n}\nint main() {\n    rep(i,51) C[i][0]=1;\n    rep(i,51) for(int j=1;j<=i;j++) C[i][j]=C[i-1][j-1]+C[i-1][j];\n\n    cin>>N>>M>>L;\n    rep(i,N) cin>>P[i]>>T[i]>>V[i];\n\n    rep(i,N) {\n        // j?????????\n        rep(j,M+1) {\n            double p=C[M][j];\n            rep(k,j) p*=P[i]/100.0;\n            rep(k,M-j) p*=(100-P[i])/100.0;\n            A[i][j]=p;\n\n            double t=0;\n            t+=j*T[i];\n            t+=1.0*L/V[i];\n            B[i][j]=t;\n        }\n    }\n\n    double ans[102];\n\n    rep(i,N) {\n        ans[i]=0;\n        rep(j,M+1) {\n            ans[i]+=f(i,j);\n        }\n    }\n    rep(i,N) printf(\"%.20f\\n\",ans[i]);\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 D : Marathon Match\n\n#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint N, M, L;\n\tint P[100], T[100], V[100];\n\t// [P][M][lest]\n\tstatic double dp[101][101][101];\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++)\n\t\t\tfor(int k=0;k<=100;k++) dp[i][j][k] = 0.0;\n\t\tdp[i][0][0] = 1.0;\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tdp[i][j+1][k  ] += dp[i][j][k]*(100-i)/100.0;\n\t\t\t\tdp[i][j+1][k+1] += dp[i][j][k]*i/100.0;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> N >> M >> L){\n\t\tfor(int i=0;i<N;i++) cin >> P[i] >> T[i] >> V[i];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdouble res = 0.0;\n\t\t\tfor(int j=0;j<=M;j++){\n\t\t\t\tdouble cur = dp[P[i]][M][j];\n\t\t\t\tif(V[i]==0) break;\n\t\t\t\tdouble time = (double)L/V[i] + j*T[i];\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\tif(V[k]==0) continue;\n\t\t\t\t\tdouble sum = 0.0;\n\t\t\t\t\tfor(int l=0;l<=M;l++){\n\t\t\t\t\t\tdouble otime = (double)L/V[k] + l*T[k];\n\t\t\t\t\t\tif(otime - time < 1e-8) continue;\n\t\t\t\t\t\tsum += dp[P[k]][M][l];\n\t\t\t\t\t}\n\t\t\t\t\tcur *= sum;\n\t\t\t\t}\n\t\t\t\tres += cur;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\", res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N],mem[M][M];\n\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=pow(1-p[0],m-i)*pow(p[0],i)*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*pow(1-p[i],m-k)*pow(p[i],k)*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  if(n==1){\n    printf(\"%.8lf\\n\",1.0);\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(1-p[i],m);\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(1-p[i],m-j) * pow(p[i],j) ;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\ndouble calc(double r, int a, int b)\n{\n\tdouble ret = r;\n\tb = min(a - b, b);\n\tif (b == 0) return ret;\n\trep(i, 1, b + 1) ret *= (double)(a - i + 1) / i;\n\treturn ret;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvi P(N), T(N), V(N);\n\trep(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n\tvvd per(N, vd(M+1, 0));\n\trep(i, 0, N)\n\t{\n\t\tdouble p = P[i] / 100.0;\n\t\tdouble pp = 1.0 - p;\n\t\trep(j, 0, M + 1) per[i][j] = calc(pow(pp, M - j) * pow(p, j), M, j);\n\t}\n\n\tvvd imos(N, vd(M + 2, 0));\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, M + 1) imos[i][j] = per[i][j];\n\t\trrep(j, M, 0) imos[i][j] += imos[i][j + 1];\n\t}\n\n\trep(i, 0, N)\n\t{\n\t\tdouble ans = 0;\n\t\trep(j, 0, M + 1)\n\t\t{\n\t\t\tdouble _ans = per[i][j];\n\t\t\tif (V[i] == 0) continue;\n\t\t\tdouble deadline = (double)L / V[i] + (double)T[i] * j;\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tif (i == k) continue;\n\t\t\t\tif (V[i] == 0) continue;\n\t\t\t\tdouble fastest = (double)L / V[k];\n\t\t\t\tif (deadline < fastest - EPS) continue;\n\n\t\t\t\tif (T[k] == 0)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint minrest = (deadline - fastest + T[k] - 1) / T[k];\n\t\t\t\tdouble test = fastest + T[k] * minrest;\n\t\t\t\tif (abs(deadline - test) < EPS) minrest++;\n\t\t\t\tif (M < minrest)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_ans *= imos[k][minrest];\n\t\t\t}\n\n\t\t\tans += _ans;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, p[100], t[100], v[100];\ndouble dp[100][52], sum[100][52];\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\trep(i, n){\n\t\tdp[i][0] = 1;\n\t\trep(j, m) for(int k = m; k >= 0; k--){\n\t\t\tdp[i][k + 1] += dp[i][k] * p[i] / 100.0;\n\t\t\tdp[i][k] *= 1 - p[i] / 100.0;\n\t\t}\n\t\tsum[i][m] = dp[i][m];\n\t\tfor(int j = m - 1; j >= 0; j--) sum[i][j] = sum[i][j + 1] + dp[i][j];\n\t\t/*\n\t\trep(j, m + 1) cerr<<dp[i][j]<<(j==m?\"\\n\":\" \");\n\t\trep(j, m + 1) cerr<<sum[i][j]<<(j==m?\"\\n\":\" \");\n\t\t*/\n\t}\n\t\n\trep(i, n){\n\t\tdouble s = 0;\n\t\trep(j, m + 1){\n\t\t\tdouble e = dp[i][j];\n\t\t\trep(k, n) if(k != i){\n\t\t\t\tint tm = (int)ceil((l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j) / t[k] + EPS);\n\t\t\t\t\n\t\t\t\ttm = max(tm, 0);\n\t\t\t\tif(t[k] == 0) tm = l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j < - EPS ? 0 : m + 1;\n\t\t\t\tif(tm <= m) e *= sum[k][tm];\n\t\t\t\telse e = 0;\n\t\t\t}\n\t\t\ts += e;\n\t\t}\n\t\tprintf(\"%.9f\\n\", s);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    for (int i = 0; i < N; i++)\n        P[i] = P[i] / 100.;\n\n    vector<vector<double> > times(N, vector<double>(M + 1)), prob(N, vector<double>(M + 1));\n    for (int i = 0; i < N; i++)\n        times[i][0] = (double)L / V[i];\n\n    vector<vector<long long int> > comb(M + 1, vector<long long int>(M + 1));\n    for (auto& i : comb) i[0] = 1LL;\n    for (int i = 1; i <= M; i++)\n        for (int j = 1; j <= M; j++) {\n            int up = comb[i-1][j];\n            int left = comb[i-1][j-1];\n            comb[i][j] = up + left;\n        }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= M; j++) {\n            if (j > 0) times[i][j] = times[i][j-1] + T[i];\n            prob[i][j] = pow(P[i], j) * pow(1.000 - P[i], M - j) * comb[M][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        double ans = 0.0000;\n        for (int j = 0; j <= M; j++) {\n            double tmp = 1.0000;\n            for (int k = 0; k < N; k++) {\n                if (k == i) continue;\n                double sum = 0.0000;\n                for (int l = 0; l <= M; l++) {\n                    if (times[i][j] < times[k][l]) sum += prob[k][l];\n                }\n                tmp *= sum;\n            }\n            ans += prob[i][j] * tmp;\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass State{\npublic:\n  double probability;\n  double cost;\n  State(double _p,double _c) : probability(_p),cost(_c){}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int total_players;\n  int total_resting_places;\n  int goal_distance;\n  while(~scanf(\"%d %d %d\",&total_players,&total_resting_places,&goal_distance)){\n\n    vector<vector<State> > players;\n\n    for(int player_idx=0;player_idx<total_players;player_idx++){\n      int probability;\n      int resting_duration;\n      int speed;\n      scanf(\"%d %d %d\",&probability,&resting_duration,&speed);\n      \n      double dp[51][5001];\n      vector<State> player;\n      memset(dp,0,sizeof(dp));\n\n      dp[0][0] = 1.0;\n      for(int resting_place_idx=0;resting_place_idx<total_resting_places;resting_place_idx++){\n\tfor(int total_resting_duration = 0; total_resting_duration <= 5000; total_resting_duration++){\n\t  if(dp[resting_place_idx][total_resting_duration] <= EPS) continue;\n\n\t  dp[resting_place_idx+1][total_resting_duration + resting_duration]\n\t    += dp[resting_place_idx][total_resting_duration] * (double)probability/100.0;\n\n\t  dp[resting_place_idx+1][total_resting_duration]\n\t    += dp[resting_place_idx][total_resting_duration] * (1.0 - (double)probability/100.0);\n\t}\n      }\n\n      for(int total_resting_duration = 0; total_resting_duration <= 5000; total_resting_duration++){\n\tif(dp[total_resting_places][total_resting_duration] != 0){\n\t  // printf(\"rest:%d prob:%lf\\n\",total_resting_duration,dp[total_resting_places][total_resting_duration]);\n\t  player.push_back(State(dp[total_resting_places][total_resting_duration],total_resting_duration + (double)goal_distance/(double)speed));\n\t}\n      }\n      sort(player.begin(),player.end());\n      players.push_back(player);\n    }\n\n    for(int player_idx=0;player_idx<total_players;player_idx++){\n\n      double win_prob = 0.0;\n      for(int state_idx=0;state_idx<players[player_idx].size();state_idx++){\n\tdouble cost = players[player_idx][state_idx].cost;\n\tdouble player_prob = players[player_idx][state_idx].probability;\n\n\tdouble rival_prob = 1.0;\n\tfor(int rival_idx=0;rival_idx<total_players;rival_idx++){\n\t  if(player_idx == rival_idx) continue;\n\t  double tmp_prob = 0.0;\n\t  for(int rival_state_idx=0;rival_state_idx<players[rival_idx].size();rival_state_idx++){\n\t    if(players[rival_idx][rival_state_idx].cost > cost){\n\t      tmp_prob += players[rival_idx][rival_state_idx].probability;\n\t    }\n\t  }\n\n\t  rival_prob *= tmp_prob;\n\t}\n\twin_prob += player_prob * rival_prob;\n      }\n\n      printf(\"%.7lf\\n\",win_prob);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<climits>\n#include<cstdio>\n#include<iomanip>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 500\n\nusing namespace std;\n\ndouble C[MAX][MAX];\n \nvoid makeC()\n{\n  C[0][0] = 1;\n  rep(i,MAX-1)rep(j,i+1)\n    {\n      C[i+1][j] += C[i][j];\n      if(j+1<MAX)C[i+1][j+1] += C[i][j];\n    }\n}\n\n\nint N,M;\ndouble L;\n\n\nint main(){\n\n  makeC();\n\n  cin >> N >> M >> L;\n  vector<double> P(N),T(N),V(N),PB[N],TM[N];\n\n  //cout << \"C[\" << M << \"][\" << 0 << \"] = \" << C[M][0] << endl;\n\n  rep(i,N){\n    cin >> P[i] >> T[i] >> V[i];\n    double p = P[i] / 100.0;\n    rep(j,M+1){\n      TM[i].push_back( L / V[i] + j * T[i] );\n      PB[i].push_back( C[M][j] * pow(p,j) * pow(1-p,M-j) );\n    }\n  }\n\n  rep(sp,N){\n    double ans = 0;\n    rep(i,TM[sp].size()){\n      double cost = 1;\n      rep(gp,N){\n\tdouble cost2 = 0;\n\tif(sp == gp)continue;\n\trep(j,TM[gp].size()){\n\t  if(TM[sp][i] >= TM[gp][j]){\n\t    cost2 += PB[gp][j];\n\t  } else break;\n\t}\n\tcost *= ( 1 - cost2 );\n      }\n      ans += cost * PB[sp][i];\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 111\n#define M 55\nusing namespace std;\n\ndouble l,p[N],t[N],d[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1;\n  for(int i=0;i<r;i++) a*=n-i;\n  for(int i=1;i<=r;i++)a/=i;\n  return a;\n}\n\nint n,m;\ndouble DP(){\n  double dp[N][M]={},sum=0;\n  for(int i=0;i<=m;i++){\n    dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n    sum+=dp[0][i];\n  }\n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[i]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>d[i],p[i]/=100,d[i]=l/d[i];\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j?????????????¢???????\n    A[i]=B[i]=vector<double>(m+1,0);\n    A[i][0]=B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]);\n      B[i][j]=B[i][j-1]*p[i];\n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <time.h>\nusing namespace std;\n\n#define LL long long \n#define clr(x) memset(x,0,sizeof(x))\n#define eps 1e-6\n#define PI 3.1415926535897932384626433832795028          \n#define MAXN 105\n\nstruct number{\n   \n\tLL p,t,v;\n    double c[MAXN];\n\tdouble ps[MAXN];\n\n}mem[MAXN];\n\nLL c[55][55];\n\nvoid C()\n{\n\t for(LL i = 0;i < 55; i++ )\n\t       c[0][i]=1;\n\t for(LL i = 1;i < 55; i++ )\n\t {\n\t\t for(LL j = i;j < 55; j++ )\n\n\t\t\t c[i][j]=c[i-1][j-1]+c[i][j-1];\n\t\t \n\t }\n\t \n}\n\nint main()\n{\n\n\tLL n,m,l,p,t,v;\n\tC();\n\twhile(scanf(\"%lld%lld%lld\", &n, &m, &l)!=EOF)\n\t{\n\t\t for(LL i = 0 ;i < n; i++ )\n\t\t {\n\t\t\t scanf(\"%lld%lld%lld\", &mem[i].p, &mem[i].t, &mem[i].v); \n\t\t\t \n\t\t\t mem[i].c[0]=l*1.0/mem[i].v;\n\t\t\t for(int j = 1 ;j <= m; j++)\n\t\t\t {\n\t\t\t\tmem[i].c[j]+=mem[i].t+mem[i].c[j-1];\n\t\t\t }\n            mem[i].ps[0]=c[0][m]*pow(mem[i].p/100.0,0.0)*pow(1.0-mem[i].p/100.0,m*1.0);\n\t\t\tfor(int j = 1; j <= m; j++ )\n\t\t\t\tmem[i].ps[j]=c[j][m]*(double)pow(mem[i].p/100.0,j*1.0)*pow(1.0-mem[i].p/100.0,(m-j)*1.0);\n\t\t\t//for(int j = 0; j <= m; j++ )\n\t\t\t\t//printf(\"%lf \",mem[i].ps[j]);\n\t\t }\n\n\t\t  for(LL i = 0; i< n ; i++ )\n\t\t  {\n\t\t\t  double tp,pp=0.0;\n\t\t\t  for(LL j = 0; j <= m; j++ )\n\t\t\t  {\n\t\t\t\t  tp=mem[i].ps[j];\n\n\t\t\t\t  for(LL k = 0; k < n; k++ )\n\t\t\t\t  {\n\t\t\t\t\t  double t=0.0;\n\t\t\t\t\t  if(k==i)\n\t\t\t\t\t\t  continue;\n\t\t\t\t\t  for(LL q = 0; q <= m; q++ )\n\t\t\t\t\t\t  if(mem[k].c[q]>mem[i].c[j]+eps)\n\t\t\t\t\t\t\t  t+=mem[k].ps[q];\n\t\t\t\t\t  tp*=t;\n\t\t\t\t  }\n\n\t\t\t\t   pp+=tp;\n\t\t\t  }\n\t\t\t  \n\t\t\t  printf(\"%lf\\n\",pp);\n\t\t  }\n\t \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n,vector<ld>(m+1,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=m;j++){\n            pos[i][j]=j*log(p[i]+1e-30)+(m-j)*log(1-p[i]+1e-30);\n            for(int k=0;k<j;k++){\n                pos[i][j]+=log(m-k)-log(k+1);\n            }\n            pos[i][j]=exp(pos[i][j]);\n        }\n        // vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        // comb[0][0]=1;\n        // for(int j=0;j<=m;j++){\n        //     for(int k=0;k<=j;k++){\n        //         if(k==0){\n        //             comb[j][k]=(p[i]==1 ? ld(0) : ld(pow(1-p[i],ld(j))));\n        //         }\n        //         else if(k==j){\n        //             comb[j][k]=(p[i]==0 ? ld(0) : ld(pow(p[i],j)));\n        //         }\n        //         else{\n        //             comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n        //         }\n        //     }\n        // }\n        // pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                ld z=0;\n                for(int y=0;y<=m;y++){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]<l*v[i]+y*t[j]*v[i]*v[j]){\n                        z+=pos[j][y];\n                    }\n                }\n                sc*=z;\n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nint p[100];\nint t[100];\nint v[100];\n\ndouble rui[100];\ndouble ruitmp[100];\ndouble ans[100];\n\nint main(){\n  int n,m,l;\n  scanf(\"%d%d%d\", &n, &m, &l);\n\n  REP(i,n) scanf(\"%d%d%d\", p+i, t+i, v+i);\n  REP(i,n) rui[i] = ans[i] = 0.0;\n\n  vector<pair<double,pair<int,int> > > vv;\n  map<double, int> cnt;\n\n  REP(i,n) REP(j,m + 1){\n    double tm = (double)l / v[i] + t[i] * j;\n    vv.push_back(make_pair(tm, make_pair(i, j)));\n    cnt[tm]++;\n  }\n\n  sort(vv.begin(), vv.end());\n  vector<pair<int, double> > buff;\n\n  REP(i,vv.size()){\n    {\n      int id = vv[i].second.first;\n      int rest = vv[i].second.second;\n      \n      double rp = 1.0; // p^rest * (1-p)^(m-rest) * m C rest\n      REP(j,rest){\n\trp *= (p[id] / 100.0);\n\trp *= (double)(m - j) / (rest - j);\n      }\n      REP(j,m-rest){\n\trp *= 1 - (p[id] / 100.0);\n      }\n\n      ruitmp[id] += rp;\n\n      buff.push_back(make_pair(id, rp));\n      rui[id] += rp;\n    }\n\n    if(i == vv.size() - 1 || vv[i].first != vv[i+1].first){\n      REP(ii, buff.size()){\n\tdouble rp = buff[ii].second;\n\tint id = buff[ii].first;\n\tdouble prob = 1.0;\n\tREP(j,n) if(id != j){\n\t  prob *= (1.0 - rui[j]);\n\t}\n\tans[id] += prob * rp;\t\n      }\n      buff.clear();\n    }\n  }\n\n  REP(i,n) printf(\"%.6f\\n\", ans[i]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint N, M, L;\nint P[100], T[100], V[100];\ndouble prob[55][100];\n\nvoid calc(int x)\n{\n\tdouble p = P[x] / 100.0;\n\tdouble rest[55][55];\n\n\tfor(int i=0; i<=M; i++)\n\tfor(int j=0; j<=M; j++)\n\t\trest[j][i] = 0.0;\n\n\trest[0][0] = 1.0;\n\n\tfor(int i=0; i<M; i++)\n\tfor(int j=0; j<M; j++)\n\t{\n\t\trest[i+1][j] += rest[i][j] * (1-p);\n\t\trest[i+1][j+1] += rest[i][j] * p;\n\t}\n\n\n\tfor(int i=0; i<=M; i++)\n\t\tprob[i][x] = rest[M][i];\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<N; i++)\n\t\tcalc(i);\n\n\tfor(int i=0; i<N; i++)\n\t{\n\t\tdouble res = 0.0;\n\t\tfor(int j=0; j<=M; j++)\n\t\t{\n\t\t\tdouble p = prob[j][i];\n\t\t\tdouble ltm = 1.0*L/V[i] + (T[i]*j);\n\n\t\t\tfor(int k=0; k<N; k++)\n\t\t\t{\n\t\t\t\tif(k==i) continue;\n\t\t\t\t\n\t\t\t\tdouble t = 0.0;\n\t\t\t\tfor(int l=0; l<=M; l++)\n\t\t\t\t{\n\t\t\t\t\tdouble rtm = 1.0*L/V[k] + (T[k]*l);\n\t\t\t\t\tif(ltm < rtm) t += prob[l][k];\n\t\t\t\t}\n\n\t\t\t\tp *= t;\n\t\t\t}\n\n\t\t\tres += p;\n\t\t}\n\n\t\tcout.setf(ios::fixed);\n\t\tcout.precision(11);\n\t\tcout << res << endl;\n\t}\n}\n\n\n\nint main()\n{\n\t\n\tcin >> N >> M >> L;\n\n\tfor(int i=0; i<N; i++)\n\t\tcin >> P[i] >> T[i] >> V[i];\n\n\tsolve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst double INF = 1e10;\nconst double EPS = 1e-10;\n\nint main(){\n    int n,m;\n    double l;\n    cin >> n >> m >> l;\n    vector<double> p(n), t(n), v(n);\n    for(int i=0; i<n; i++){\n        cin >> p[i] >> t[i] >> v[i];\n        p[i] /= 100.0;\n    }\n\n    vector<vector<double> > c(m+1, vector<double>(m+1, 0));\n    for(int i=0; i<=m; i++) c[i][0] = 1;\n    for(int i=1; i<=m; i++){\n        for(int j=1; j<=i; j++){\n            c[i][j] = c[i-1][j-1] +c[i-1][j];\n        }\n    }\n\n    vector<vector<double> > prob(n, vector<double>(m+1)), time(n, vector<double>(m+1));\n    for(int i=0; i<n; i++){\n        double ttime = l/v[i];\n        for(int j=0; j<=m; j++){\n            prob[i][j] = pow(p[i], j) *pow(1-p[i], m-j) *c[m][j];\n            time[i][j] = ttime;\n            ttime += t[i];\n        }\n    }\n    vector<vector<double> > accumprob = prob;\n    for(int i=0; i<n; i++){\n        for(int j=m-1; j>=0; j--){\n            accumprob[i][j] += accumprob[i][j+1];\n        }\n    }\n\n    cout << fixed;\n    cout << setprecision(10);\n    for(int i=0; i<n; i++){\n        double subans = 0;\n        for(int j=0; j<=m; j++){\n            double pr = prob[i][j];\n            for(int k=0; k<n; k++){\n                if(i==k) continue;\n                double subpr = 0;\n                for(int s=0; s<=m; s++){\n                    if(time[k][s] > time[i][j] +EPS){\n                        subpr = accumprob[k][s];\n                        break;\n                    }\n                }\n                pr *= subpr;\n            }\n            subans += pr;\n        }\n        cout << subans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include<cstdio>\n#include<algorithm>\n#include <cstring>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\nint n,m,l,t20[101],p20[101];\ndouble p[101],p2[101],pw[101],t[101],v[101],t2[101][3000],pp2[101][3000];\n\ndouble outt(double p1,int now)\n{\n    int i,h;double ta;ta=1;\n    for (i=1;i<=now;i++) ta*=p1;\n    for (i=1;i<=m-now;i++) ta*=(1-p1);\n    h=m-now;\n    if (m-h<h) h=m-h;\n    for (i=1;i<=h;i++)\n    {\n        ta*=(m-i+1);\n    }\n    return(ta);\n}\nvoid mmm()\n{\n  int i,j,p1;\n  for (i=1;i<=n;i++)\n    {scanf(\"%lf%lf%lf\",&p[i],&t[i],&v[i]);p[i]=p[i]/100;}\n\n  memset(pp2,0,sizeof(pp2));\n  memset(pw,0,sizeof(pw));\n  for (i=1;i<=n;i++)\n    {\n        double t1=l/v[i];\n        p2[i]=0;\n        for (j=0;j<=m;j++)\n          {\n              t20[i]+=1;\n              t2[i][t20[i]]=t1+j*t[i];\n              p20[i]+=1;\n              pp2[i][p20[i]]=outt(p[i],j);\n          }\n    }\n  for (i=1;i<=n;i++)\n  {\n      int maxx,j;\n      maxx=t20[i];\n      for (j=maxx;j>0;j--)\n      {\n          int h;double ansp,anst;\n          ansp=pp2[i][j];anst=t2[i][j];\n          for (h=1;h<=n;h++)\n            if (h!=i)\n            {\n                int k;double ans1=1;\n                for (k=t20[h];k>0;k--)\n                  {\n                      if (t2[h][k]<=anst) ans1-=pp2[h][k];\n                  }\n                ansp*=ans1;\n            }\n          pw[i]+=ansp;\n      }\n  }\n  for (i=1;i<=n;i++)\n     cout<<fixed<<setprecision(8)<<pw[i]<<endl;\n}\nmain()\n{\n    scanf(\"%d%d%d\",&n,&m,&l);\n    mmm();\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint N, M, L;\ndouble P[102], T[102], V[102];\ndouble dp[102][102];\ndouble p[102][102];\n\nint main(){\n  while(cin >> N >> M >> L){\n    for(int i = 0; i < N; i++){\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n\n    for(int k = 0; k < N; k++){\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1.0;\n\n      for(int i = 0; i < M; i++){\n        for(int j = 0; j <= M; j++){\n          dp[i + 1][j] += dp[i][j] * (1 - P[k]);\n          dp[i + 1][j + 1] += dp[i][j] * P[k];\n        }\n      }\n\n      for(int j = 0; j <= M; j++){\n        p[k][j] = dp[M][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){ //iが勝つ\n      double ans = 0;\n\n      for(int j = 0; j <= M; j++){ //iがj回休む\n        double ti = (double)j * T[i] + (double)L / V[i];\n        double mul = 1.0;\n\n        for(int k = 0; k < N; k++){ //kはiに負ける\n          if(k == i) continue;\n\n          double sum = 0;\n\n          for(int l = 0; l <= M; l++){ //kはl回休む\n            double tk = (double)l * T[k] + (double)L / V[k];\n            //printf(\"%dが%d休み. %dが%d休み. = %.5f, %.5f\\n\", i,j,k,l,ti,tk);\n            if(ti >= tk) continue;\n            sum += p[k][l];\n          }\n\n          mul *= sum;\n        }\n\n        ans += mul * p[i][j];\n      }\n\n      printf(\"%.10f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\ntypedef long long LL;\ntypedef pair<double,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst int INF=1<<30;\nint dx[]={0,0,1,1,1,-1,-1,-1};\nint dy[]={1,-1,1,0,-1,1,0,-1};\n\nvector<double> fact;\n \ndouble combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]/fact[n-r]/fact[r];\n}\n \n \nvoid set_combi(){\n    double s=1.0;\n    fact.push_back(1.0);\n    for(int i=1;i<=50;i++){\n        s*=i;\n        fact.push_back(s);\n    }\n}\n\ndouble fpow(double a, int n){\n    double x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a;\n        }\n        a=a*a;\n        n >>= 1;\n    }\n    return x;\n}\n\nint main(){\n    set_combi();\n    int n,m,l;cin >> n >> m >> l;\n    vector<LL> p(n),t(n),v(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i] >> t[i] >> v[i];\n    }\n    vector<vector<double>> d(n,vector<double>(m+1,0.0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= m; j++) {\n            d[i][j] = combi(m,j) * fpow(p[i]/100.,j) * fpow((100-p[i])/100.,m-j);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        double ans = 0.0;\n        for (int j = 0; j <= m; j++) {\n            double pp = d[i][j];\n            for (int k = 0; k < n; k++) {\n                if(i==k) continue;\n                double tmp = 0.0;\n                for (int c = 0; c <= m; c++) {\n                    if(c * t[k] * v[k] * v[i] + l * v[i] <= j * t[i] * v[k] * v[i] + l * v[k]) continue;\n                    tmp += d[k][c];\n                }\n                pp *= tmp;\n            }\n            ans += pp;\n        }\n        cout << setprecision(30) << fixed << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M, L;\n    cin >> N >> M >> L;\n    vector<double> P(N), T(N), V(N);\n    for (int i = 0; i < N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    for (int i = 0; i < N; i++)\n        P[i] = P[i] / 100.;\n\n    vector<vector<double> > times(N, vector<double>(M + 1)), prob(N, vector<double>(M + 1));\n    for (int i = 0; i < N; i++)\n        times[i][0] = (double)L / V[i];\n\n    vector<vector<long long int> > comb(M + 1, vector<long long int>(M + 1));\n    for (auto& i : comb) i[0] = 1LL;\n    for (int i = 1; i <= M; i++)\n        for (int j = 1; j <= M; j++) {\n            long long int up = comb[i-1][j];\n            long long int left = comb[i-1][j-1];\n            comb[i][j] = up + left;\n        }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= M; j++) {\n            if (j > 0) times[i][j] = times[i][j-1] + T[i];\n            prob[i][j] = pow(P[i], j) * pow(1.000 - P[i], M - j) * comb[M][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        double ans = 0.0000;\n        for (int j = 0; j <= M; j++) {\n            double tmp = 1.0000;\n            for (int k = 0; k < N; k++) {\n                if (k == i) continue;\n                double sum = 0.0000;\n                for (int l = 0; l <= M; l++) {\n                    if (times[i][j] < times[k][l]) sum += prob[k][l];\n                }\n                tmp *= sum;\n            }\n            ans += prob[i][j] * tmp;\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nstruct runner { ld p, t, v; };\nrunner a[100];\nld pas[100][100];\nvoid init() {\n\trep(i, 100) {\n\t\trep(j, 100) {\n\t\t\tif (i == 0 || j == 0)pas[i][j] = 1;\n\t\t\telse pas[i][j] = pas[i - 1][j] + pas[i][j - 1];\n\t\t}\n\t}\n}\n//i番目の人がj回休憩をとる確率\nld pr[100][51];\nint main(){\n\tinit();\n\tcout << fixed << setprecision(10);\n\tint n, m;ld L; cin >> n >> m >> L;\n\trep(i, n) {\n\t\tld p, t, v; cin >> p >> t >> v;\n\t\tp /= 100.0;\n\t\ta[i] = { p,t,v };\n\t\trep(j, m + 1) {\n\t\t\tpr[i][j] = pas[m - j][j];\n\t\t\trep(k, j) {\n\t\t\t\tpr[i][j] *= p;\n\t\t\t}\n\t\t\trep(k, m-j) {\n\t\t\t\tpr[i][j] *= (1 - p);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tld out = 0;\n\t\trep(j, m + 1) {\n\t\t\tld sum = j * a[i].t + L / a[i].v;\n\t\t\tld ssum = pr[i][j];\n\t\t\trep(k, n) {\n\t\t\t\tif (i == k)continue;\n\t\t\t\tld csum = 0;\n\t\t\t\trep(l, m+1) {\n\t\t\t\t\tld pp = l * a[k].t + L / a[k].v;\n\t\t\t\t\tif (pp > sum) {\n\t\t\t\t\t\tcsum += pr[k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tssum *= csum;\n\t\t\t}\n\t\t\tout += ssum;\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double time[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\nint main()\n{\n//#ifndef ONLINE_JUDGE\n//    freopen(\"in.txt\",\"r\",stdin);\n//#endif // ONLINE_JUDGE\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        if(n==1)\n        {\n            printf(\"%.8lf\\n\",v[0]!=0?1:0);\n            continue;\n        }\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].time[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=C(j,m)*pow(p[i]*0.01,j)*pow((100-p[i])*0.01,m-j);\n            }\n        for(int i=0; i<n; i++)\n        {\n            if(!v[i])\n            {\n                printf(\"%.8lf\\n\",0);\n                continue;\n            }\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=peo[i].pp[j];\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[k].time[l]>peo[i].time[j])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp;\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  double sum=0;\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i),sum+=dp[0][i];\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n  \n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j??????????????°???\n    A[i]=B[i]=vector<double>(m+1,1);\n    if(p[i]==1)A[i]=vector<double>(m+1,0),A[i][0]=1;\n    if(p[i]==0)B[i]=vector<double>(m+1,0),B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]),B[i][j]=B[i][j-1]*p[i];\n      \n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.8f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/8 15:34:52\n * File Name: d.cpp\n * solve: d.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset(x,0,sizeof(x))\n#define clrs( x , y ) memset(x,y,sizeof(x))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-13;\nconst int maxn = 100 + 10;\nconst int maxm = 50 + 10;\ndouble p[maxn], t[maxn], v[maxn];\nint n, m, L;\ndouble con[maxm][maxm];\ndouble pow_p[maxn][maxm], pow_np[maxn][maxm], f[maxn][maxm], sum[maxn][maxm];\ndouble ans[maxn];\ndouble times[maxn][maxm];\nint zore[maxn];\nint sgn(double x) {\n    return (x > esp) - (x < -esp);\n}\nbool cmp(const double &a, const double &b) {\n    return sgn(a - b) < 0;\n}\nvoid init() {\n    rep (i, n) {\n        scanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n        p[i] /= 100;\n        zore[i] = 0;\n        if(sgn(v[i]) == 0) {\n            zore[i] = 1;\n        }\n    }\n    repf (i, 1, m) {\n        con[i][0] = con[i][i] = 1;\n        repf (j, 1, i - 1)\n            con[i][j] = con[i - 1][j] + con[i - 1][j - 1];\n    }\n    \n    rep (i, n) {\n        if(zore[i]) continue;\n        pow_p[i][0] = 1;\n        pow_np[i][0] = 1;\n        times[i][0] = L * 1.0 / v[i];\n        repf (j, 1, m) {\n            pow_p[i][j] = pow_p[i][j - 1] * p[i];\n            pow_np[i][j] = pow_np[i][j - 1] * (1 - p[i]);\n            times[i][j] = times[i][j - 1] + t[i];\n        }\n    }\n    \n    rep (i, n) {\n        if(zore[i]) continue;\n        sum[i][0] = f[i][0] = con[m][0] * pow_np[i][m] * pow_p[i][0];\n        repf (j, 1, m) {\n            f[i][j] = con[m][j] * pow_np[i][m - j] * pow_p[i][j];\n            sum[i][j] = sum[i][j - 1] + f[i][j];\n        }\n    }\n}\ndouble gao(double lim, int w) {\n    int h = m + 1;\n    int hh = upper_bound(times[w], times[w] + m + 1, lim, cmp) - times[w];\n    if(zore[w]) return 1;\n    rep (i, m + 1)\n        if(sgn(times[w][i] - lim) > 0) {\n            h = i;\n            break;\n        }\n    //printf(\"%d %d %f %f %f %f\\n\", h, hh, lim, times[w][h], times[w][hh], 1 - sum[w][h - 1]);\n    //out(h);\n    if(h - 1 < 0)  return 1;\n    else return 1 - sum[w][h - 1];\n}\nint main()  {\n    int blank = 0;\n    while( scanf(\"%d%d%d\", &n, &m, &L) == 3) {\n        if(blank) printf(\"\\n\");\n        init();\n        //if(n == 1) {\n            //printf(\"%.8f\\n\", 1.0);\n            //continue;\n        //}\n        rep (i, n) {\n            ans[i] = 0;\n            if(!zore[i]) \n                repf (j, 0, m) {\n                    double res = 1;\n                    rep (k, n) {\n                        if(k == i) continue;\n                        res *= gao(times[i][j], k);\n                        //if(i == 1) printf(\"%f %f %d\\n\", gao(times[i][j], k), times[i][j], k);\n                    }\n                    //printf(\"%f %f %d %d\\n\", res, f[i][j], i, j);\n                    ans[i] += res * f[i][j];\n                }\n            printf(\"%.12f\", ans[i]);\n            if(i != n - 1) printf(\"\\n\");\n        }\n        blank = 1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double real;\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\nreal EPS = 1e-9;\n\nconst int MAX_N = 101;\nconst int MAX_M = 53;\n\nconst bool debug = false;\n\nint N, M, L;\nvector<real> P, T, V;\nvoid input() {\n    cin >> N >> M >> L;\n    P.clear(); P.resize(N);\n    T.clear(); T.resize(N);\n    V.clear(); V.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n}\n\nreal X[MAX_N][MAX_M]; // X[i][j] :: i人目がm回休む確率\nreal S[MAX_N][MAX_M]; // S[i][j] :: i人目がm回未満だけ休む確率\n\nvoid init() {\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M; j++) X[i][j] = 0;\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M + 1; j++) S[i][j] = 0;\n    for (int i = 0; i < N; i++) {\n        static real dp[MAX_M][MAX_M];\n        for (int j = 0; j <= M; j++) for (int k = 0; k <= M; k++) dp[j][k] = 0;\n        dp[0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[j + 1][k] += dp[j][k] * (1.0 - P[i]);\n                dp[j + 1][k + 1] += dp[j][k] * P[i];\n            }\n        }\n        for (int k = 0; k <= M; k++) {\n            X[i][k] = dp[M][k];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        S[i][0] = 0;\n        for (int j = 0; j <= M; j++) {\n            S[i][j + 1] = S[i][j] + X[i][j];\n        }\n    }\n    if (debug) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= M; j++) {\n                printf(\"%3.3Lf \", X[i][j]);\n            }\n            cout << endl;\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for (int i = 0; i < N; i++) { // i人目\n        if (V[i] == 0) {\n            printf(\"%.12Lf\\n\", real(N == 1 ? 1 : 0));\n            continue;\n        }\n        real ans = 0;\n        for (int j = 0; j <= M; j++) { // j回休んだ\n            real p = X[i][j];\n            real time = L / V[i] + j * T[i];\n            for (int k = 0; k < N; k++) { // k人目\n                if (i == k) continue;\n                if (T[k] == 0) {\n                    p *= (L / V[k] + EPS > time);\n                    continue;\n                }\n                // c回以上休む必要\n                int c = int(ceil((time - L / V[k]) / T[k] + EPS) + EPS);\n                if (c > M) {\n                    p = 0;\n                    break;\n                }\n                real pk = 1.0 - S[k][c];\n                p *= pk;\n            }\n            ans += p;\n        }\n        printf(\"%.12Lf\\n\", ans);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+j*pl[i].t,pl[k].v+m*pl[k].t)){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n            if(res[i]<0.000000000001)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n,m;\ndouble l;\nint t[101];\ndouble pp[101][55];\ndouble psum[101][55];\ndouble p[101],v[101];\ndouble tt[101][55];\ndouble win[101];\ndouble comb[101][101];\n\nint main(void){\n\tfor(int i=1;i<=100;i++){\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t}\n\t}\n\tscanf(\"%d %d %lf\",&n,&m,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %d %lf\",&p[i],&t[i],&v[i]);\n\t\tp[i]=p[i]/100.0;\n\t}\n\tfor(int j=0;j<n;j++){\n\t\tfor(int k=0;k<=m;k++){\n\t\t\tpp[j][k]=comb[m][k];\n\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\tpp[j][k]*=p[j];\n\t\t\t}\n\t\t\tfor(int l=0;l<m-k;l++){\n\t\t\t\tpp[j][k]*=(1.0-p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tpsum[i][j+1]=psum[i][j]+pp[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\ttt[i][0]=l/v[i];\n\t\tfor(int j=1;j<=m;j++){\n\t\t\ttt[i][j]=tt[i][j-1]+t[i];\n\t\t}\n\t\ttt[i][m+1]=1000000000.0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int l=0;l<=m;l++){\n\t\t\tdouble wp=pp[i][l];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tint uk=upper_bound(tt[k],tt[k]+m+2,tt[i][l])-tt[k];\n\t\t\t\twp*=(1.0-psum[k][uk]);\n\t\t\t\t//printf(\"%lf %lf %f\\n\",tt[i][l],tt[k][uk],psum[k][uk]);\n\t\t\t}\n\t\t\twin[i]+=wp;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%.10f\\n\",win[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ndouble C(int x,int y){\n  double res=1;\n  for(int i=0;i<y;i++) res*=x-i;\n  for(int i=1;i<=y;i++) res/=i;\n  return res;\n}\nint main(){\n  int n,m;\n  double l;\n  cin >> n >> m >> l;\n  int i,j,k,a;\n  double p[n],t[n],v[n];\n  double b[n][m+1];\n  for(i=0;i<n;i++) {\n    cin >> p[i] >> t[i] >> v[i];\n    for(j=0;j<=m;j++){\n      b[i][j]=C(m,j)*pow(p[i]/100,j)*pow(1.0-p[i]/100,m-j);\n      //cout << i << \"/\" << j << \":\" << b[i][j] <<\"_\" << l/v[i]+t[i]*j << endl;\n    }\n  }\n  double ans,x,y;\n  for(i=0;i<n;i++){\n    ans=0;\n    for(j=0;j<=m;j++){\n      x=b[i][j];\n      for(k=0;k<n;k++){\n\tif(i==k) continue;\n\ty=0;\n\tfor(a=m;a>=0;a--){\n\t  if(l/v[k]+t[k]*a>l/v[i]+t[i]*j) y+=b[k][a];\n\t  else break;\n\t}\n\t//cout << \"y:\" << y << endl;\n\tx*=y;\n      }\n      //cout << \"x:\" << x << endl;\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\ndouble calc(double r, int a, int b)\n{\n\tdouble ret = r;\n\tb = min(a - b, b);\n\tif (b == 0) return ret;\n\trep(i, 1, b + 1) ret *= (double)(a - i + 1) / i;\n\treturn ret;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvi P(N), T(N), V(N);\n\trep(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n\tvvd per(N, vd(M+1, 0));\n\trep(i, 0, N)\n\t{\n\t\tdouble p = P[i] / 100.0;\n\t\tdouble pp = 1.0 - p;\n\t\trep(j, 0, M + 1) per[i][j] = calc(pow(pp, M - j) * pow(p, j), M, j);\n\t}\n\n\tvvd imos(N, vd(M + 2, 0));\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, M + 1) imos[i][j] = per[i][j];\n\t\trrep(j, M, 0) imos[i][j] += imos[i][j + 1];\n\t}\n\n\trep(i, 0, N)\n\t{\n\t\tdouble ans = 0;\n\t\trep(j, 0, M + 1)\n\t\t{\n\t\t\tdouble _ans = per[i][j];\n\t\t\tdouble deadline = (double)L / V[i] + (double)T[i] * j;\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tif (i == k) continue;\n\t\t\t\tdouble fastest = (double)L / V[k];\n\t\t\t\tif (deadline < fastest - EPS) continue;\n\n\t\t\t\tif (T[k] == 0)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint minrest = (deadline - fastest + T[k] - 1) / T[k];\n\t\t\t\tdouble test = fastest + T[k] * minrest;\n\t\t\t\tif (abs(deadline - test) < EPS) minrest++;\n\t\t\t\tif (M < minrest)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_ans *= imos[k][minrest];\n\t\t\t}\n\n\t\t\tans += _ans;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>=l/pl[k].v+m*pl[k].t){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti++;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n            if(res[i]<0.000000000001)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.5f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint N,M,L;\ndouble a[105][105],b[105][105],t[105][105],P,T,V;\n\nlong double f(int x)\n{\n\tlong double r=1;\n\tfor(;x;)r*=x--;\n\treturn r;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&L);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(\"%lf%lf%lf\",&P,&T,&V);\n\t\tfor(int j=0;j<M;j++)\n\t\t{\n\t\t\tt[i][j]=L/V+T*j;\n\t\t\ta[i][j]=pow(P/100,j)*pow(1-P/100,M-j)*f(M)/f(j)/f(M-j);\n\t\t\tb[i][j+1]=b[i][j]+a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tdouble n=0;\n\t\tfor(int j=0;j<=M;j++)\n\t\t{\n\t\t\tdouble c=a[i][j];\n\t\t\tfor(int k=0;k<N;k++)\n\t\t\t\tif(i!=k)\n\t\t\t\t{\n\t\t\t\t\tint x=upper_bound(a[k],a[k]+M+1,a[i][j]+1e-9)-a[k];\n\t\t\t\t\tc*=1-b[k][x];\n\t\t\t\t}\n\t\t\tn+=c;\n\t\t}\n\t\tprintf(\"%.8f\\n\",n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+j*pl[i].t,pl[k].v+m*pl[k].t)){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n            if(res[i]<0.000000000001)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\n\nconst int MAX_N = 100 + 10;\nconst int MAX_M = 50 + 2;\nconst double eps = 0.00000000001;\n\nstruct runner {\n    int p, t, v;\n    double pp[MAX_M];\n} R[MAX_N];\n\ndouble C[MAX_M][MAX_M];\nvoid init()\n{\n    for (int i = 1; i < MAX_M; ++ i)\n    {\n        C[i][1] = i;\n        C[i][0] = C[i][i] = 1;\n    }\n    for (int i = 2; i < MAX_M; ++ i)\n        for (int j = 1; j < i; ++ j)\n            C[i][j] = C[i-1][j-1] + C[i-1][j];\n}\n\nint main(int argc, char *argv[])\n{\n    init();\n    cout << C[10][3] << endl;\n    int N, M, L;\n    while (cin >> N >> M >> L)\n    {\n        for (int i = 0; i < N; ++ i)\n            cin >> R[i].p >> R[i].t >> R[i].v;\n\n        for (int i = 0; i < N; ++ i)\n            for (int j = 0; j <= M; ++ j)\n                R[i].pp[j] = C[M][j] * pow(R[i].p*1.0/100, j) * pow((100.0 - R[i].p)/100, M-j);\n\n        for (int i = 0; i < N; ++ i)\n        {\n            double ppp = 0;\n            for (int j = 0; j <= M; ++ j)\n            {\n                double pp = R[i].pp[j];\n                for (int ii = 0; ii < N; ++ ii)\n                {\n                    if (ii == i)\n                        continue;\n\n                    double p2 = 0;\n                    for (int jj = 0; jj <= M; ++ jj)\n                    {\n                        int a = L * R[i].v + jj * R[ii].t * R[i].v * R[ii].v;\n                        int b = L * R[ii].v + j * R[i].t * R[ii].v * R[i].v;\n                        if (a > b)\n                            p2 += R[ii].pp[jj];\n                    }\n                    pp *= p2;\n                }\n                ppp += pp;\n            }\n            printf(\"%.10lf\\n\", ppp);\n        }\n    } \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ndouble C(int x,int y){\n  double res=1;\n  for(int i=0;i<y;i++) res*=x-i;\n  for(int i=1;i<=y;i++) res/=i;\n  return res;\n}\nint main(){\n  int n,m;\n  double l;\n  cin >> n >> m >> l;\n  int i,j,k,a;\n  double p[n],t[n],v[n];\n  double b[n][m+1];\n  for(i=0;i<n;i++) {\n    cin >> p[i] >> t[i] >> v[i];\n    for(j=0;j<=m;j++){\n      b[i][j]=C(m,j)*pow(p[i]/100,j)*pow(1.0-p[i]/100,m-j);\n    }\n  }\n  double ans,x,y;\n  for(i=0;i<n;i++){\n    ans=0;\n    for(j=0;j<=m;j++){\n      x=b[i][j];\n      for(k=0;k<n;k++){\n    if(i==k) continue;\n    y=0;\n    for(a=m;a>=0;a--){\n      if(l/v[k]+t[k]*a>l/v[i]+t[i]*j) y+=b[k][a];\n      else break;\n    }\n    x*=y;\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\tbase_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double pp[MAXN],time[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\nLL Com[MAXN][MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\",\"r\",stdin);\n#endif // ONLINE_JUDGE\n    Com[0][0]=1;\n    for(int i=1;i<=50;i++)\n    {\n        Com[i][0]=Com[i-1][0];\n        for(int j=1;j<=i;j++)\n            Com[i][j]=Com[i-1][j]+Com[i-1][j-1];\n    }\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n\n///                double x=C(j,m);\n                double x=Com[m][j];\n                int k;\n                for(k=1;k<=j;k++)\n                    x*=p[i]/100.0;\n                for(;k<=m;k++)\n                    x*=(100-p[i])/100.0;\n                peo[i].pp[j]=x;\n                peo[i].time[j]=(L+0.0)/v[i]+j*t[i];\n            }\n        for(int i=0; i<n; i++)\n        {\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double x=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[k].time[l]>peo[i].time[j])\n                            x+=peo[k].pp[l];\n                    tmp*=x;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.8f\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<double> p(n),t(n),v(n);\n    rep(i,0,n){\n        cin >> p[i] >> t[i] >> v[i];\n        if(v[i]==0) v[i]=1e-12;\n    }\n\n    int comb[51][51]={};\n    rep(i,0,51){\n        comb[i][i]=1;\n        comb[i][0]=1;\n    }\n    rep(i,1,51) rep(j,1,i){\n        if(i>0 and i>j) comb[i][j]+=comb[i-1][j];\n        if(j>0) comb[i][j]+=comb[i-1][j-1];\n    }\n\n    vector<map<double,double>> x(n);\n    rep(i,0,n) rep(j,0,m+1) x[i][l/v[i]+t[i]*j]+=pow((100-p[i])/100.,m-j)*pow(p[i]/100.,j)*comb[m][j];\n    rep(i,0,n){\n        double s1=0;\n        for(const auto& p1:x[i]){\n            double tmp=p1.second;\n            rep(j,0,n){\n                if(j!=i){\n                    double s2=0;\n                    for(const auto& p2:x[j]) if(p2.first>p1.first) s2+=p2.second;\n                    tmp*=s2;\n                }\n            }\n            s1+=tmp;\n        }\n        cout << fixed << setprecision(8) << s1 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n,m;\ndouble l;\nint t[101];\ndouble pp[101][55];\ndouble psum[101][55];\ndouble p[101],v[101];\ndouble tt[101][55];\ndouble win[101];\ndouble comb[101][101];\n\nint main(void){\n\tcomb[0][0]=1;\n\tfor(int i=1;i<=100;i++){\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t}\n\t}\n\tscanf(\"%d %d %lf\",&n,&m,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %d %lf\",&p[i],&t[i],&v[i]);\n\t\tp[i]=p[i]/100.0;\n\t}\n\tfor(int j=0;j<n;j++){\n\t\tfor(int k=0;k<=m;k++){\n\t\t\tpp[j][k]=comb[m][k];\n\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\tpp[j][k]*=p[j];\n\t\t\t}\n\t\t\tfor(int l=0;l<m-k;l++){\n\t\t\t\tpp[j][k]*=(1.0-p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tpsum[i][j+1]=psum[i][j]+pp[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i]==0.0){\n\t\t\tfor(int j=0;j<=m+1;j++){\n\t\t\t\ttt[i][j]=1000000000.0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttt[i][0]=l/v[i];\n\t\tfor(int j=1;j<=m;j++){\n\t\t\ttt[i][j]=tt[i][j-1]+t[i];\n\t\t}\n\t\ttt[i][m+1]=1000000000.0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i]==0.0)continue;\n\t\tfor(int l=0;l<=m;l++){\n\t\t\tdouble wp=pp[i][l];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tif(v[k]==0.0)continue;\n\t\t\t\tint uk=upper_bound(tt[k],tt[k]+m+2,tt[i][l])-tt[k];\n\t\t\t\twp*=(1.0-psum[k][uk]);\n\t\t\t\t//printf(\"%lf %lf %f\\n\",tt[i][l],tt[k][uk],psum[k][uk]);\n\t\t\t}\n\t\t\twin[i]+=wp;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%.8f\\n\",win[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ndouble eps=1e-9;\ntypedef pair<double,double> P;\ntypedef pair<P,int> PP;\nvector<PP> vc;\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\trep(i,n){\n\t\tdouble p,t,v;\n\t\tcin>>p>>t>>v;\n\t\tp/=100;\n\t\tdouble pro=1;\n\t\tif(p==1){\n\t\t\tvc.pb(PP(P(l/v+m*t,1),i));\n\t\t\tcontinue;\n\t\t}\n\t\tif(p==0){\n\t\t\tvc.pb(PP(P(l/v,1),i));\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,m) pro*=(1-p);\n\t\trep(j,m+1){\n\t\t\tvc.pb(PP(P(l/v+j*t,pro),i));\n\t\t\tpro*=p/(1-p);\n\t\t\tpro*=(double)(m-j)/(j+1);\n\t\t}\n\t}\n\tsort(all(vc));\n\tdouble ans[100]={};\n\trep(i,vc.size()){\n\t\tdouble cnt[100]={};\n\t\tfor(int j=i+1;j<vc.size();j++){\n\t\t\tif(vc[j].fs.fs<vc[i].fs.fs+eps) continue;\n\t\t\tcnt[vc[j].sc]+=vc[j].fs.sc;\n\t\t}\n\t\tdouble ret=1;\n\t\trep(j,n){\n\t\t\tif(j==vc[i].sc) ret*=vc[i].fs.sc;\n\t\t\telse ret*=cnt[j];\n\t\t}\n\t\tans[vc[i].sc]+=ret;\n\t}\n\trep(i,n) printf(\"%.9f\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MAXM = 55;\n\n\nint N, M, L;\nint P[MAXN], T[MAXN], V[MAXN];\nlong long C[MAXM][MAXM];\nvoid init() {\n    for(int i = 1; i < MAXM; i++) {\n        C[i][0] = 1;\n        for(int j = 1; j <= i; j++)\n            C[i][j] = C[i][j - 1] * (i - j + 1) / j;\n    }\n}\n\ndouble ans[MAXN];\nvoid calc(int cur_id) {\n    if(V[cur_id] == 0) {\n        ans[cur_id] = 0;\n        return ;\n    }\n    double res = 0;\n    for(int k = 0; k <= M; k++) {\n        double ts = 1.0 * L / V[cur_id] + T[cur_id] * k;\n        double pk = pow(1.0 * P[cur_id] / 100, k) * pow(1 - 1.0 * P[cur_id] / 100, M - k) * C[M][k];\n        double res1 = 1;\n        for(int i = 0; i < N; i++) if(i != cur_id) {\n            if(V[i] == 0) continue;\n            double ti = 1.0 * L / V[i];\n            if(T[i] == 0) {\n                res1 *= ts < ti ? 1 : 0;\n                continue;\n            }\n            int k = (int)((ts - ti) / T[i] + 1.00000001);\n            if(k < 0) continue;\n            //k++;\n            double pi = 0;\n            for(int j = k; j <= M; j++) {\n                pi += pow(1.0 * P[i] / 100, j) * pow(1 - 1.0 * P[i] / 100, M - j) * C[M][j];\n            }\n            res1 *= pi;\n        }\n        res += res1 * pk;\n    }\n\n    ans[cur_id] = res;\n}\nint main() {\n  //  freopen(\"in.txt\", \"r\", stdin);\n    init();\n    while(scanf(\"%d%d%d\", &N, &M, &L) != EOF) {\n        for(int i = 0; i < N; i++)\n            scanf(\"%d%d%d\", &P[i], &T[i], &V[i]);\n        for(int i = 0; i < N; i++) {\n            calc(i);\n        }\n        for(int i = 0; i < N; i++)\n            printf(\"%.10f\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100 + 10;\nconst int MAXM = 6000 + 10;\nconst double eps = 1e-8;\n\nint n, m, l, tot;\ndouble org[MAXN];\ndouble p[MAXN], t[MAXN], v[MAXN];\ndouble b[MAXM], c[MAXM], tp1[MAXM], tp2[MAXM];\ndouble C[MAXN][MAXN];\n\nint Find(double x) {\n        for (int i = 1; i <= tot; ++i)\n\t\tif (fabs(x - c[i]) < eps)\n\t\t\treturn i;\n}\n\ndouble co[MAXN][MAXM];\n\ninline int lowbit(int x) {\n\treturn x & (-x);\n}\n\ninline void Add(int i, int x, double v) {\n\tif (x == 0)\n\t\treturn;\n\tfor (; x <= tot; x += lowbit(x))\n\t\tco[i][x] += v;\n}\n\ninline double Query(int i, int x) {\n\tdouble ret = 0;\n\tfor (; x > 0; x -= lowbit(x))\n\t\tret += co[i][x];\n\treturn ret;\n}\nint main() {\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= 50; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n\t\torg[i] = 1.0 * l / v[i];\n\t\tp[i] = p[i] / 100;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tb[++tot] = -(org[i] + j * t[i]);\n\t\t}\n\tsort(b + 1, b + 1 + tot);\n\tint tmp = 0;\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tif (i == 1 || fabs(b[i] - b[i - 1]) > eps) {\n\t\t\tc[++tmp] = b[i];\n\t\t}\n\t}\n\ttot = tmp;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = C[m][j];\n\t\t        for (int k = 1; k <= j; ++k)\n\t\t\t\tcurp *= p[i];\n\t\t\tfor (int k = 1; k <= m - j; ++k)\n\t\t\t\tcurp *= (1 - p[i]);\n\t\t\tint cur = Find(curs);\n\t\t\tAdd(i, cur, curp);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = C[m][j];\n\t\t\tfor (int k = 1; k <= j; ++k)\n\t\t\t\tcurp *= p[i];\n\t\t\tfor (int k = 1; k <= m - j; ++k)\n\t\t\t\tcurp *= (1 - p[i]);\n\t\t\t//\tcout << i << ' ' << j << ' ' << curp << endl;\n\t\t\tint cur = Find(curs);\n\t\t\tfor (int k = 1; k <= n; ++k) if (i != k) {\n\t\t\t\t\tcurp *= Query(k, cur - 1);\n\t\t\t}\n\t\t\tans += curp;\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define eps 0.0000001\n\n\nbool zero(double a,double b){\n    if((a-b)<eps && (a-b)>-eps)return true;\n    return false;\n}\n\ndouble c[110][110];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[210];\ndouble rp[210][110];\ndouble sp[210][110];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<110;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p*p,k/2);\n    if(k%2==0)return ret;\n    else return ret*p;\n}\n\ndouble res[210];\ndouble tmp;\ndouble solve(double p,int m,int n)\n{\n    double ret=1;\n    for(int i=0;i<n;i++)\n    {\n        ret=ret*(m-i);\n        ret=ret/(i+1);\n        ret=ret*p;\n    }\n    for(int i=n;i<m;i++)\n    {\n        ret=ret*(1.0-p);\n    }\n    \n    return ret;\n}\nint main(){\n    \n    //freopen(\"D.in\", \"r\", stdin);\n    //freopen(\"D.out3\", \"w\", stdout);\n    \n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l) != EOF){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            //cout<<pl[i].p<<endl;\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=solve(pl[i].p,(int)m,(int)j);\n                //c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+pl[i].t*(double)j<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+pl[i].t*(double)j>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+pl[i].t*(double)j,l/pl[k].v+m*pl[k].t)){\n                            tmp=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+pl[i].t*(double)j-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp*rp[i][j];\n            }\n            if(res[i]<eps)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n        break\n    }\n\n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAXN 110\n#define INF 0x3f3f3f3f\n#define PI acos(-1.0)\n#define MAX(a,b) (a>b?a:b)\n#define MIN(a,b) (a<b?a:b)\n#define ABS(m) (m<0?-m:m)\ntypedef long long LL;\n\nint n,m,l;\nLL c[MAXN][MAXN];\nint p[MAXN],t[MAXN],v[MAXN];\n\nvoid Init()\n{\n    int i,j;\n    scanf(\"%d%d%d\",&n,&m,&l);\n    for(i=1;i<=n;++i)\n        scanf(\"%d%d%d\",p+i,t+i,v+i);\n    c[0][0]=1;\n    for(i=1;i<=50;++i)\n        for(j=1,c[i][0]=1;j<=i;++j)\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n}\n\ndouble C(double P,int N,int M)\n{\n    int i; double ans=1;\n    for(i=1;i<=M;++i) ans*=P;\n    for(;i<=N;++i) ans*=(1-P);\n    return ans*c[N][M];\n}\n\nvoid Work()\n{\n    int i,j,k,x;\n    double ans,r1,r2,r,t1,t2;\n    for(i=1;i<=n;++i){\n        for(ans=0,j=0;j<=m;++j){\n            t1=(double)l/v[i]+j*t[i];\n            r1=C(p[i]/100.0,m,j);\n            for(k=1;k<=n;++k){\n                if(k==i) continue;\n                t2=(double)l/v[k];\n                for(x=r2=0;x<=m&&t2<=t1;t2+=t[k],++x);\n                if(x<=m){\n                    r=r2=C(p[k]/100.0,m,x);\n                    for(++x;x<=m;++x)\n                        r2+=r=r/(1-p[k]/100.0)*(p[k]/100.0)/c[m][x-1]*c[m][x];\n                }\n                r1*=r2;\n            }\n            ans+=r1;\n        }\n        printf(\"%.12f\\n\",ans);\n    }\n}\n\nint main()\n{\n    Init();\n    Work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nvector<double> P, T, V;\ndouble F[51];\ndouble C[51][51];\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    F[0] = 1;\n    for(int i=1; i<51; i++)\n        F[i] = F[i-1] * i;\n    for(int i=0; i<51; i++)\n        for(int j=0; j<=i; j++)\n            C[i][j] = F[i] / F[i-j] / F[j];\n    \n    cin >> N >> M >> L;\n    P.resize(N); T.resize(N); V.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    \n    for(int i=0; i<N; i++){\n        double ans = 0;\n        for(int j=0; j<N; j++) if(i != j){\n            for(int k=0; k<=M; k++){ //????????????i????????????????????????\n                double ti = L / V[i] + T[i]*k;\n                double tans = 0;\n                for(int l=0; l<=M; l++){ //????????????j????????????????????????\n                    double tj = L / V[j] + T[j]*l;\n                    if(ti < tj){\n                        tans += pow(P[j]/100, l) * pow(1-P[j]/100, M-l) * C[M][l];\n                    }\n                }\n                ans += tans * pow(P[i]/100, k) * pow(1-P[i]/100, M-k) * C[M][k];\n            }\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][51],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)time[i][j] = (double)l/v[i] + t[i]*j;\n  }\n  \n \n  for(int i=0;i<n;i++){\n    if(abs(p[i]-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p[i],m);\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = ( prob[i][j-1] * p[i] * (m-j+1) ) / ( (1-p[i])*j );\n      }\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j]){\n\t\thoge += prob[k][l];\n\t      }else break;\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define eps 1e-14\nusing namespace std;\ndouble f_pow(double x,int n){\n\tdouble res=1;\n\twhile(n--)res*=x;\n\treturn res;\n}\n\nstruct Man{\n\tdouble p,t,v;\n\tvoid get(){\n\t\tscanf(\"%lf%lf%lf\",&p,&t,&v);\n\t\tp/=100;\n\t}\n};\nMan man[200];\nint N,M;\ndouble L;\ndouble tim[200][61],tsum[200][61];\ndouble rate[200][61];\ndouble C[61][61];\nvoid get_C(){\n\tint i,j;\n\tC[0][0]=1;\n\tC[1][0]=C[1][1]=1;\n\tfor(i=2;i<61;i++){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n\t}\n}\nvoid get_data(){\n\tscanf(\"%d%d%lf\",&N,&M,&L);\n\tint i;\n\tfor(i=0;i<N;i++)man[i].get();\n}\nvoid get_tim(){\n\tint i,j;\n\tfor(i=0;i<N;i++){\n\t\trate[i][0]=f_pow(1-man[i].p,M);\n\t\tif(man[i].v<eps)tim[i][0]=2000000000;\n\t\telse tim[i][0]=L/man[i].v;\n\t\tfor(j=1;j<=M;j++){\n\t\t\tif(M-j>=j)rate[i][j]=C[M][j]*f_pow(man[i].p*(1-man[i].p),j)*f_pow(1-man[i].p,M-j-j);\n\t\t\telse rate[i][j]=C[M][j]*f_pow(man[i].p*(1-man[i].p),M-j)*f_pow(man[i].p,j+j-M);\n\t\t\ttim[i][j]=tim[i][j-1]+man[i].t;\n\t\t}\n\t\ttsum[i][M]=rate[i][M];\n\t\tfor(j=M-1;j>=0;j--)tsum[i][j]=tsum[i][j+1]+rate[i][j];\n\t}\n}\ndouble bina(int ren,double t){\n\tint h=M,l=0,mid;\n\twhile(h>l){\n\t\tmid=(h+l)>>1;\n\t\tif(tim[ren][mid]<t+eps)l=mid+1;\n\t\telse h=mid;\n\t}\n\treturn tsum[ren][h];\n}\ndouble get_win(int winner,double t){\n\tint i;\n\tdouble res=1;\n\tfor(i=0;i<N;i++){\n\t\tif(i==winner)continue;\n\t\tif(tim[i][M]<t+eps)return 0;\n\t\tres*=bina(i,t);\n\t}\n\treturn res;\n}\nvoid run(){\n\tint i,j;\n\tdouble sum;\n\tfor(i=0;i<N;i++){\n\t\tif(man[i].v<eps){\n\t\t\tprintf(\"0.0000000000\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tsum=0;\n\t\tfor(j=0;j<=M;j++){\n\t\t\tsum+=rate[i][j]*get_win(i,tim[i][j]);\n\t\t}\n\t\tprintf(\"%.9lf\\n\",sum);\n\t}\n}\nint main(){\n\tget_C();\n\tget_data();\n\tget_tim();\n\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#define inf 10000000000\n\nusing namespace std;\ntypedef pair<double, double> P;\n\nint N, M, L;\ndouble p[105], T[105], V[105];\nP table[105][55];\n\ndouble pow(double a, int n)\n{\n\tif(n == 0) return 1.0;\n\tif(n % 2) return a * pow(a, n-1);\n\telse{\n\t\tdouble t = pow(a, n/2);\n\t\treturn t * t;\n\t}\n}\n\ndouble comb(double n, double k)\n{\n\tdouble ret = 1.0;\n\tfor(int i = 0; i < k; i++){\n\t\tret *= (n-i)/(k-i);\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> L;\n\t\n\tint pp;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> pp >> T[i] >> V[i];\n\t\tp[i] = pp / 100.0;\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j <= M; j++){\n\t\t\ttable[i][j] = make_pair( L/V[i] + j*T[i], comb(M, j) * pow(p[i],j) * pow(1.0-p[i],M-j) );\n\t\t\tif(j != 0) table[i][j].second += table[i][j-1].second;\n\t\t}\n\t}\n\t\n\tP *ix;\n\tdouble ans, prob;\n\tfor(int i = 0; i < N; i++){\n\t\tans = 0.0;\n\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\n\t\t\tprob = table[i][j].second;\n\t\t\tif(j != 0) prob -= table[i][j-1].second;\n\t\t\t\n\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tix = lower_bound(table[k], table[k] + M+1, make_pair(table[i][j].first, 1.1));\n\t\t\t\tif(ix != table[k]){\n\t\t\t\t\tprob *= 1.0 - ix[-1].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += prob;\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint p[110];\nint t[110];\nint v[110];\ndouble dp[110][110];\ndouble prob[110][110];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",p+i,t+i,v+i);\n\t\tfor(int j=0;j<=b;j++)for(int k=0;k<=b;k++)dp[j][k]=0;\n\t\tdp[0][0]=1;\n\t\tfor(int j=0;j<b;j++){\n\t\t\tfor(int k=0;k<=j;k++){\n\t\t\t\tdp[j+1][k+1]+=dp[j][k]*p[i]/100;\n\t\t\t\tdp[j+1][k]+=dp[j][k]*(100-p[i])/100;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=b;j++)prob[i][j]=dp[b][j];\n\t}\n\tdouble EPS=1e-12;\n\tfor(int i=0;i<a;i++){\n\t\tdouble ret=0;\n\t\tfor(int j=0;j<=b;j++){\n\t\t\tif(!v[i])continue;\n\t\t\tdouble time=(double)c/v[i]+j*t[i];\n\t\t\tdouble ks=prob[i][j];\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(i==k)continue;\n\t\t\t\tdouble tmp=0;\n\t\t\t\tfor(int l=0;l<=b;l++){\n\t\t\t\t\tif(v[k]&&time+EPS>(double)c/v[k]+l*t[k])continue;\n\t\t\t\t\ttmp+=prob[k][l];\n\t\t\t\t}\n\t\t\t\tks*=tmp;\n\t\t\t}\n\t\t\tret+=ks;\n\t\t}\n\t\tprintf(\"%.12f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 100;\nconst int M = 51;\nconst double EPS = 1e-9;\n\nint n, m, L, t[N], v[N];\ndouble p[N], C[M+1][M+1], ps[N][N], s_ps[N][N], ts[N][N];\n\nmain(){\n  for(int i=0;i<=M;i++) C[i][0] = 1.0;\n  for(int i=1;i<=M;i++) for(int j=1;j<=i;j++) C[i][j] = C[i-1][j-1] + C[i-1][j];\n  cin >> n >> m >> L;\n  for(int i=0;i<n;i++) cin >> p[i] >> t[i] >> v[i];\n  bool f = true;\n  for(int i=0;i<n;i++) if(v[i]) f = false;\n  if(f){\n    for(int i=0;i<n;i++) printf(\"%.8f\\n\", 0+EPS);\n    return 0;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      ps[i][j] = C[m][j] * pow(p[i]/100.0, j) * pow((100 - p[i])/100.0, m - j);\n      if(j == 0) s_ps[i][j] = ps[i][j];\n      else s_ps[i][j] = s_ps[i][j-1] + ps[i][j];\n      ts[i][j] = (double)L / v[i] + t[i] * j;\n    }\n  }\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    for(int j=0;j<=m;j++){\n      double tmp = 1.0;\n      for(int k=0;k<n;k++){\n        if(k == i) continue;\n        int l = lower_bound(ts[k], ts[k]+m+1, ts[i][j]+EPS) - ts[k];\n        if(l != 0) tmp *= (1.0 - s_ps[k][l-1]);\n      }\n      ans += ps[i][j] * tmp;\n    }\n    printf(\"%.8f\\n\", ans+EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double real;\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\nreal EPS = 1e-9;\n\nconst int MAX_N = 101;\nconst int MAX_M = 53;\n\nconst bool debug = false;\n\nint N, M; real L;\nvector<real> P, T, V;\nvoid input() {\n    cin >> N >> M >> L;\n    P.clear(); P.resize(N);\n    T.clear(); T.resize(N);\n    V.clear(); V.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n}\n\nreal X[MAX_N][MAX_M]; // X[i][j] :: i人目がm回休む確率\nreal S[MAX_N][MAX_M]; // S[i][j] :: i人目がm回未満だけ休む確率\n\nvoid init() {\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M; j++) X[i][j] = 0;\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M + 1; j++) S[i][j] = 0;\n    for (int i = 0; i < N; i++) {\n        static real dp[MAX_M][MAX_M];\n        for (int j = 0; j <= M; j++) for (int k = 0; k <= M; k++) dp[j][k] = 0;\n        dp[0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[j + 1][k] += dp[j][k] * (1.0 - P[i]);\n                dp[j + 1][k + 1] += dp[j][k] * P[i];\n            }\n        }\n        for (int k = 0; k <= M; k++) {\n            X[i][k] = dp[M][k];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        S[i][0] = 0;\n        for (int j = 0; j <= M; j++) {\n            S[i][j + 1] = S[i][j] + X[i][j];\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for (int i = 0; i < N; i++) { // i人目\n        if (V[i] == 0) {\n            printf(\"%.12Lf\\n\", real(0));\n            continue;\n        }\n        real ans = 0;\n        for (int j = 0; j <= M; j++) { // j回休んだ\n            real p = X[i][j];\n            real time = L / V[i] + j * T[i];\n            for (int k = 0; k < N; k++) { // k人目\n                if (i == k) continue;\n                if (EQ(T[k], 0)) {\n                    p *= (L / V[k] - EPS > time);\n                } else {\n                    // c回以上休む必要\n                    int c = max(0, int(ceil((time - L / V[k]) / T[k] + EPS) + EPS));\n                    if (c > M) {\n                        p = 0;\n                        break;\n                    }\n                    real pk = 1.0 - S[k][c];\n                    p *= pk;\n                }\n            }\n            ans += p;\n        }\n        printf(\"%.12Lf\\n\", ans);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>;\n\nld comb(ll l, ll r) {\n\tld res = 1;\n\tREP(i, r) {\n\t\tres *= l - i;\n\t\tres /= i + 1;\n\t}\n\treturn res;\n}\n\n// [person][rest-number] -> prob\nvector<vector<ld>> calc_prob_table(const vector<ar3>& info, const int M) {\n\tconst int N = info.size();\n\tvector<vector<ld>> res(N, vector<ld>(M + 1));\n\tREP(i, N)REP(j, M + 1) {\n\t\tld rest = info[i][0];\n\t\tres[i][j] = comb(M, j)*powl(rest / 100., j)*powl(1 - rest / 100., M - j);\n\t}\n\t//REP(i, N)REP(j, M - 1)res[i][j + 1] += res[i][j];\n\treturn res;\n}\n\nld lose_prob(const vector<ld>& prob, ar3 info, ld time, const ld L) {\n\tconst int M = prob.size();\n\ttime -= L / info[2];\n\ttime /= (ld)info[1];\n\n\tld res = 0;\n\tREP(i, min(time + 1e-5, (ld)M)) {\n\t\tres += prob[i];\n\t}\n\treturn 1 - res;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<ar3> info(N);\n\tREP(i, N)REP(j, 3)cin >> info[i][j];\n\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tauto table = calc_prob_table(info, M);\n\tREP(i, N) {\n\t\tld res = 0;\n\t\tREP(rest, M + 1) {\n\t\t\tld tres = table[i][rest];\n\t\t\tld time = (ld)L / info[i][2] + info[i][1] * rest;\n\t\t\tREP(opp, N)if (opp != i) {\n\t\t\t\ttres *= lose_prob(table[opp], info[opp], time, L);\n\t\t\t}\n\t\t\tres += tres;\n\t\t}\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<< #str << \" \" str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\nusing ar3 = array<int, 3>;\n\nld comb(ll l, ll r) {\n\tld res = 1;\n\tREP(i, r) {\n\t\tres *= l - i;\n\t\tres /= i + 1;\n\t}\n\treturn res;\n}\n\n// [person][rest-number] -> prob\nvector<vector<ld>> calc_prob_table(const vector<ar3>& info, const int M) {\n\tconst int N = info.size();\n\tvector<vector<ld>> res(N, vector<ld>(M + 1));\n\tREP(i, N)REP(j, M + 1) {\n\t\tld rest = info[i][0];\n\t\tres[i][j] = comb(M, j)*powl(rest / 100., j)*powl(1 - rest / 100., M - j);\n\t}\n\t//REP(i, N)REP(j, M - 1)res[i][j + 1] += res[i][j];\n\treturn res;\n}\n\nld lose_prob(const vector<ld>& prob, ar3 info, ld time, const ld L) {\n\tconst int M = prob.size();\n\ttime -= L / info[2];\n\tif (info[1] == 0) {\n\t\ttime = INF * (time >= 0 ? 1 : -1);\n\t}\n\telse {\n\t\ttime /= (ld)info[1];\n\t}\n\n\tld res = 0;\n\tREP(i, min(time + 1e-5, (ld)M)) {\n\t\tres += prob[i];\n\t}\n\treturn 1 - res;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvector<ar3> info(N);\n\tREP(i, N)REP(j, 3)cin >> info[i][j];\n\n\tif (N == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\n\tauto table = calc_prob_table(info, M);\n\tREP(i, N) {\n\t\tld res = 0;\n\t\tREP(rest, M + 1) {\n\t\t\tif (info[i][2] == 0)break;\n\t\t\tld tres = table[i][rest];\n\t\t\tld time = (ld)L / info[i][2] + info[i][1] * rest;\n\t\t\tREP(opp, N)if (opp != i && info[opp][2] != 0) {\n\t\t\t\ttres *= lose_prob(table[opp], info[opp], time, L);\n\t\t\t}\n\t\t\tres += tres;\n\t\t}\n\t\tcout << fixed << setprecision(10) << res << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 1e15\nusing namespace std;\ntypedef long long ll;\n\nint N, M, L, P[100], T[100], V[100];\ndouble p[100][51];\n\nll combination(ll n, ll r) {\n  static ll comb[51][51];\n  ll &ret = comb[n][r];\n  if(ret != 0) return ret;\n  if(n == 0 || r == 0) return ret = 1;\n  if(n == r) return ret = 1;\n  if(r == 1) return ret = n;\n  return ret = combination(n - 1, r - 1) + combination(n - 1, r);\n}\n\nbool ok(int ai, int aj, int bi, int bj) {\n  double ta = V[ai] > 0 ? (double) L / V[ai] + T[ai] * aj : INF;\n  double tb = V[bi] > 0 ? (double) L / V[bi] + T[bi] * bj : INF;\n  return ta < tb;\n}\n\nint main(void) {\n  cin >> N >> M >> L;\n  REP(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n  REP(i, 0, N) REP(j, 0, M + 1) {\n    p[i][j] = combination(M, j) * pow(P[i] / 100.0, j) * pow(1 - P[i] / 100.0, M - j);\n  }\n\n  REP(i, 0, N) {\n    double ans = 0;\n    double pi = 0;\n    REP(j, 0, M + 1) {\n      pi = p[i][j];\n      double pij = pi;\n      REP(k, 0, N) if(i != k) {\n        double pk = 0;\n        REP(l, 0, M + 1) if(ok(i, j, k, l)) pk += p[k][l];\n        pij *= pk;\n      }\n      ans += pij;\n    }\n    printf(\"%.8lf\\n\", ans);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n#define LL long long\ndouble p[200];\nint t[200];\nint v[200];\nLL C[100][100];\ndouble dp[105][55];\n\nint main(){\n    int n,m,l;\n    cin >>  n >> m >> l;\n    for(int i = 0;i < n;i++){\n        int x,tt,vv;\n        scanf(\"%d%d%d\",&x,&tt,&vv);\n        p[i] = x / 100.0,t[i] = tt,v[i] = vv;\n    }\n\n    for(int i = 0;i <= 50;i++){\n        C[i][0] = 1;\n        C[i][i] = 1;\n        for(int j = 1;j < i;j++){\n            C[i][j] = C[i-1][j]+C[i-1][j-1];\n            //cout<<C[i][j] << endl;\n        }\n    }\n    for(int i = 0;i < n;i++){\n        dp[i][m+1] = 0;\n        for(int j = m;j >= 0;j--){ //休息>j次\n            dp[i][j] = dp[i][j+1] + C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n            //cout << dp[i][j] << endl;\n        }\n    }\n\n    for(int i = 0;i < n;i++){\n        double ans = 0;\n        if(v[i] != 0){\n            for(int j = 0;j <= m;j++){\n                double ut = l*1.0/v[i] + j*t[i];\n                double pa = C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n                for(int k = 0;k < n;k++){//?k个人的概率\n                    if(k != i){\n                        if(v[i] == 0){\n                            pa *= 1;\n                            continue;\n                        }\n                        int tim;\n                        if(t[k] == 0){\n                            if(l*1.0/v[k] <= ut){\n                                pa *= 0;\n                            }\n                            else{\n                                pa *= 1;\n                            }\n                            continue;\n                        }\n                        tim = floor((ut-(l*1.0/v[k]))/t[k]);\n                        while((tim*t[k]+l*1.0/v[k]) <= ut) tim++;\n                        if(tim > m){\n                            pa *= 0;\n                        }\n                        else{\n                            pa *= dp[k][tim];\n                        }\n                    }\n                }\n                //printf(\"%lf\\n\",pa);\n                ans += pa;\n            }\n        }\n        printf(\"%f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst double eps=1e-10;\n\nint main()\n{\n    int n,m,L;\n    scanf(\" %d %d %d\", &n, &m, &L);\n    vector<int> p(n),t(n),v(n);\n    rep(i,n) scanf(\" %d %d %d\", &p[i], &t[i], &v[i]);\n\n    // i???????????????j???????????????????¢???????????????¨?????????????????????\n    double rest[100][51];\n    double total[100][51];\n\n    double dp[51][51];\n    rep(i,n)\n    {\n        memset(dp,0,sizeof(dp));\n        dp[0][0]=1;\n        rep(j,m)rep(k,j+1)\n        {\n            dp[j+1][k]+=dp[j][k]*(100-p[i])/100;\n            dp[j+1][k+1]+=dp[j][k]*p[i]/100;\n        }\n\n        rep(j,m+1)\n        {\n            rest[i][j]=dp[m][j];\n            total[i][j]=(double)L/v[i]+j*t[i];\n        }\n    }\n\n    double win[100]={0};\n\n    // i???????????????j??????????????????????????????????¢????\n    rep(i,n)rep(j,m+1)\n    {\n        double add=1;\n        double mytime=total[i][j];\n\n        rep(k,n)\n        {\n            if(k==i) continue;\n\n            if(mytime>=total[k][m])\n            {\n                add=0;\n                break;\n            }\n\n            int idx=0;\n            while(idx<m && mytime>=total[k][idx]) ++idx;\n\n            double q=0;\n            for(int l=idx; l<=m; ++l) q+=rest[k][l];\n\n            add*=q;\n        }\n\n        win[i]+=add*rest[i][j];\n    }\n\n    rep(i,n) printf(\"%.10f\\n\", win[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) //cout << #x << \" = \" << x << endl;\ndouble eps=1e-9,inf=1e100;\ntypedef pair<double,double> P;\ntypedef pair<P,int> PP;\nvector<PP> vc;\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\trep(i,n){\n\t\tdouble p,t,v;\n\t\tcin>>p>>t>>v;\n\t\tif(p==1){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v+m*t;\n\t\t\tvc.pb(PP(P(tt,1),i));\n\t\t\t//cout << \"i\" << i << \" \" << l/v+m*t << \" \" << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(p==0){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v;\n\t\t\tvc.pb(PP(P(tt,1),i));\n\t\t\t//cout << \"i\" << i << \" \" << l/v << \" \" << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tp/=100;\n\t\tdouble pro=1;\n\t\trep(j,m) pro*=(1-p);\n\t\trep(j,m+1){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v+j*t;\n\t\t\tvc.pb(PP(P(tt,pro),i));\n\t\t\t//cout << \"i\" << i << \" \" << l/v+j*t << \" \" << pro << endl;\n\t\t\tpro*=p/(1-p);\n\t\t\tpro*=(double)(m-j)/(j+1);\n\t\t}\n\t}\n\tsort(all(vc));\n\tdouble ans[100]={};\n\trep(i,vc.size()){\n\t\tif(vc[i].fs.fs>1e50) break;\n\t\tdouble cnt[100]={};\n\t\tfor(int j=i+1;j<vc.size();j++){\n\t\t\tif(vc[j].fs.fs<vc[i].fs.fs+eps) continue;\n\t\t\tcnt[vc[j].sc]+=vc[j].fs.sc;\n\t\t}\n\t\tdouble ret=1;\n\t\trep(j,n){\n\t\t\tif(j==vc[i].sc) ret*=vc[i].fs.sc;\n\t\t\telse ret*=cnt[j];\n\t\t}\n\t\tans[vc[i].sc]+=ret;\n\t}\n\trep(i,n) printf(\"%.9f\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nvector<double> P, T, V;\ndouble F[51];\ndouble C[51][51];\ndouble pTable[50][101];\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    F[0] = 1;\n    for(int i=1; i<51; i++)\n        F[i] = F[i-1] * i;\n    for(int i=0; i<51; i++)\n        for(int j=0; j<=i; j++)\n            C[i][j] = F[i] / F[i-j] / F[j];\n    \n    cin >> N >> M >> L;\n    P.resize(N); T.resize(N); V.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    \n    double tmp1[101], tmp2[101];\n    for(int i=0; i<N; i++){\n        tmp1[0] = tmp2[0] = 1;\n        for(int j=1; j<=M; j++){\n            tmp1[j] = tmp1[j-1] * P[i]/100;\n            tmp2[j] = tmp2[j-1] * (1 - P[i]/100);\n        }\n        \n        for(int j=0; j<=M; j++){\n            pTable[i][j] = tmp1[j] * tmp2[M-j] * C[M][j];\n        }\n    }\n    \n    for(int i=0; i<N; i++){\n        double ans = 0;\n        for(int k=0; k<=M; k++){ //????????????i????????????????????????\n            double ti = L / V[i] + T[i]*k;\n            double ttans = 1;\n            for(int j=0; j<N; j++) if(i != j){\n                double tans = 0;\n                for(int l=0; l<=M; l++){ //????????????j????????????????????????\n                    double tj = L / V[j] + T[j]*l;\n                    if(ti < tj){\n                        tans += pTable[j][l];\n                    }\n                }\n                ttans *= tans;\n            }\n            ans += ttans * pTable[i][k];\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define eps 1e-6\n#define inf 10000000\nstruct node\n{\n    double p,t,v;\n    double time[60];\n    double po[60];\n    double posum[60];\n    double ans;\n}me[109];\ndouble solve(double p, int k, int m)\n{\n    double res = 1;\n    //res = pow(p,k) * pow(1 - p,m - k);\n    long long t = 1,s = 1;\n    int i,j;\n    for(i = 1; i <= k; i++)\n    res *= p;\n    for(i = 1; i <= m - k; i++)\n    res *= (1 - p);\n    for(i = m,j = k; j >= 1; i--,j--)\n    {\n        t *= i;\n        s *= j;\n        if(t % s == 0)\n        {\n            t /= s;\n            s = 1;\n        }\n    }\n    return (double)res * t;\n}\nint main()\n{\n    int m,n,i,j,k,x,flag;\n    double l,ss;\n    while(~scanf(\"%d%d%lf\",&n,&m,&l))\n    {\n        for(i = 1; i <= n; i++)\n        {\n            scanf(\"%lf%lf%lf\",&me[i].p,&me[i].t,&me[i].v);\n            me[i].posum[0] = 0;\n            for(j = 1; j <= m + 1; j++)\n            {\n            me[i].posum[j] = 0;\n            if(me[i].v != 0)\n            {\n            me[i].time[j] = l / me[i].v + (j - 1) * me[i].t;\n            if(j - 1 < m / 2)\n            me[i].po[j] = solve(me[i].p / 100.0,j - 1,m);\n            else\n            me[i].po[j] = solve(me[i].p / 100.0,m - j + 1,m);\n            me[i].posum[j] += me[i].posum[j - 1] + me[i].po[j];\n            }\n            else\n            {\n                me[i].time[j] = inf;\n                me[i].po[j] = 0;\n                me[i].posum[j] = 0;\n            }\n            //printf(\"%lf %lf %lf %lf\\n\",me[i].time[j],me[i].po[j],me[i].posum[j],me[i].posum[j - 1]);\n            }\n            me[i].posum[j] = 1;\n        }\n            for(i = 1; i <= n; i++)\n            {\n                me[i].ans = 0;\n                for(j = 1; j <= m + 1; j++)\n                {\n                    ss = me[i].po[j];\n                    for(k = 1; k <= n; k++)\n                    if(i == k);\n                    else\n                    {\n                        flag = 0;\n                        for(x = 1; x <= m + 1; x++)\n                        if(me[i].time[j]  + eps < me[k].time[x])\n                        {\n                        ss *= (1 - me[k].posum[x] + me[k].po[x]);\n                        flag = 1;\n                        //printf(\"%lf %lf %lf\\n\",me[i].po[j],me[k].po[x],me[k].posum[x]);\n                        break;\n                        }\n                        if(x == m + 2 && flag == 0)\n                        break;\n                    }\n                    if(!flag)\n                ss = 0;\n                   me[i].ans += ss;\n                }\n            }\n            for(i = 1; i <= n; i++)\n            printf(\"%lf\\n\",me[i].ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100 + 10;\nconst int MAXM = 6000 + 10;\nconst double eps = 1e-8;\n\nint n, m, l, tot;\ndouble org[MAXN];\ndouble p[MAXN], t[MAXN], v[MAXN];\ndouble b[MAXM], c[MAXM], tp1[MAXM], tp2[MAXM];\ndouble C[MAXN][MAXN];\n\nint Find(double x) {\n\tint l = 1, r = tot;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tif (fabs(c[mid] - x) < eps)\n\t\t\treturn mid;\n\t\tif (c[mid] > x)\n\t\t\tr = mid - 1;\n\t\telse\n\t\t\tl = mid + 1;\n\t}\n\tif (fabs(c[1] - x) < eps)\n\t\treturn 1;\n\tif (fabs(c[tot] - x) < eps)\n\t\treturn tot;\n\treturn 0;\n}\n\ndouble co[MAXN][MAXM];\n\ninline int lowbit(int x) {\n\treturn x & (-x);\n}\n\ninline void Add(int i, int x, double v) {\n\tif (x == 0)\n\t\treturn;\n\tfor (; x <= tot; x += lowbit(x))\n\t\tco[i][x] += v;\n}\n\ninline double Query(int i, int x) {\n\tdouble ret = 0;\n\tfor (; x > 0; x -= lowbit(x))\n\t\tret += co[i][x];\n\treturn ret;\n}\n\ndouble Pow(double a, int b) {\n\tdouble ret = 1.0;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tret = ret * a;\n\t\tb >>= 1;\n\t\ta = a * a;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= 50; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n\t\torg[i] = 1.0 * l / v[i];\n\t\tp[i] = p[i] / 100;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tb[++tot] = -(org[i] + j * t[i]);\n\t\t}\n\tsort(b + 1, b + 1 + tot);\n\tint tmp = 0;\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tif (i == 1 || fabs(b[i] - b[i - 1]) > eps) {\n\t\t\tc[++tmp] = b[i];\n\t\t}\n\t}\n\ttot = tmp;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = Pow(p[i], j) * Pow(1 - p[i], m - j) * C[m][j];\n\t\t\tint cur = Find(curs);\n\t\t\tAdd(i, cur, curp);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = Pow(p[i], j) * Pow(1 - p[i], m - j) * C[m][j];\n\t\t\t//\tcout << i << ' ' << j << ' ' << curp << endl;\n\t\t\tint cur = Find(curs);\n\t\t\tfor (int k = 1; k <= n; ++k) if (i != k) {\n\t\t\t\t\tcurp *= Query(k, cur - 1);\n\t\t\t}\n\t\t\tans += curp;\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = 0;\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\tint n;\n\tint m;\n\tint l;\n\tcin >> n >> m >> l;\n\tvector<int> p;\n\tvector<int> t;\n\tvector<int> v;\n\tint a;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> a;\n\t\tp.push_back(a);\n\t\tcin >> a;\n\t\tt.push_back(a);\n\t\tcin >> a;\n\t\tv.push_back(a);\n\t}\n\tlong long int c[51][51] = {0};\n\tfor ( int i = 0; i <= m; i++ ) {\n\t\tfor ( int j = 0; j <= i; j++ ) {\n\t\t\tif ( j == 0 || j == i ) {\n\t\t\t\tc[i][j] = 1;\n\t\t\t}else {\n\t\t\t\tc[i][j] = c[i-1][j-1] + c[i-1][j];\n\t\t\t}\n\t\t}\n\t}\n\tdouble goaltime;\n\tdouble pro;\n\tdouble s;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\ts = 0.00;\n\t\tif ( v[i] == 0 ) {\n\t\t\tcout << fixed << s << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ( int x = 0; x <= m; x++ ) {\n\t\t\tgoaltime = double(l) / v[i] + t[i] * x;\n\t\t\tpro = pow( 0.01*p[i] , x ) * pow( 1.00 - 0.01*p[i] , m - x ) * c[m][x];\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tif ( i == j ) continue;\n\t\t\t\tif ( v[j] == 0 ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble g;\n\t\t\t\tg = goaltime - double(l) / v[j];\n\t\t\t\tint y;\n\t\t\t\tif ( t[j] == 0 ) {\n\t\t\t\t\tif ( g >= 0 ) y = m + 1;\n\t\t\t\t}else {\n\t\t\t\t\ty = (int)g / t[j] + 1;\n\t\t\t\t}\n\t\t\t\tif ( g < 0 ) y = 0;\n\t\t\t\tif ( y > m ) {\n\t\t\t\t\tpro = 0.00;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdouble z = 0.00;\n\t\t\t\tfor ( y; y <= m; y++ ) {\n\t\t\t\t\tz += pow( 0.01*p[j] , y ) * pow( 1.00 - 0.01*p[j] , m - y ) * c[m][y];\n\t\t\t\t}\n\t\t\t\tpro = pro * z;\n\t\t\t}\n\t\t\ts += pro;\n\t\t}\n\t\tcout << fixed << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\nint N, M, L, P[110], T[110], V[110];\ndouble RP[110][55], RT[110][55];\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\t\n\tfor_(i,0,N) {\n\t\tRT[i][0] = V[i] > 0 ? (double)L / (double)V[i] : 1e9;\n\t\tfor_(j,0,M) RT[i][j + 1] = RT[i][j] + (double)T[i];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tvector< double > p(M+1, 1.0), pm(M+1, 1.0);\n\t\t\n\t\tfor_(k,0,M) {\n\t\t\tp[k + 1] = p[k] * (double)P[i] / 100.0;\n\t\t\tpm[k + 1] = pm[k] * (1.0 - (double)P[i] / 100.0);\n\t\t}\n\t\t\n\t\tint mCk = 1;\n\t\t\n\t\tfor_(k,0,M + 1) {\n\t\t\tRP[i][k] =  (double)mCk * p[k] * pm[M - k];\n\t\t\tmCk *= (M - k);\n\t\t\tmCk /= k + 1;\n\t\t}\n\t\t\n\t\tfor_rev(k,M,1) RP[i][k-1] += RP[i][k];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tdouble ans = 0.0;\n\t\t\n\t\tfor_(k,0,M+1) {\n\t\t\tdouble t = RT[i][k];\n\t\t\tdouble p = RP[i][k] - RP[i][k + 1];\n\t\t\t\n\t\t\tfor_(ii,0,N) {\n\t\t\t\tif (ii == i) continue;\n\t\t\t\tint id = upper_bound(RT[ii], RT[ii] + M + 1, t) - RT[ii];\n\t\t\t\t\n\t\t\t\tif (id > M) {\n\t\t\t\t\tp = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tp *= RP[ii][id];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += p;\n\t\t}\n\t\t\n\t\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n\nint N, M, L, P[110], T[110], V[110];\ndouble p[110][55];\n\nvoid solve() {\n\tfor_(i,0,N) {\n\t\tdouble dp[55][55] = { 0.0 }, pi = (double)P[i] / 100.;\n\t\tdp[0][0] = 1.0;\n\t\t\n\t\tfor_(j,0,M) for_(k,0,M) {\n\t\t\tdp[j+1][k] += dp[j][k] * (1.0 - pi);\n\t\t\tdp[j+1][k+1] += dp[j][k] * pi;\n\t\t}\n\t\t\n\t\tfor_(k,0,M+1) p[i][k] = dp[M][k];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tdouble ans = 0.0;\n\t\t\n\t\tif (V[i] > 0) {\n\t\t\tfor_(j,0,M+1) {\n\t\t\t\tdouble t1 = (double)L / (double)V[i] + (double)(j * T[i]);\n\t\t\t\tdouble mul = 1.0;\n\t\t\t\t\n\t\t\t\tfor_(ii,0,N) {\n\t\t\t\t\tif (i != ii && V[ii] > 0) {\n\t\t\t\t\t\tdouble mii = 0.0;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tdouble t2 = (double)L / (double)V[ii] + (double)(M * T[ii]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor_rev(k,M,0) {\n\t\t\t\t\t\t\tif (t2 - t1 < 1e-9) break;\n\t\t\t\t\t\t\tmii += p[ii][k];\n\t\t\t\t\t\t\tt2 -= (double)T[ii];\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tmul *= mii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans += mul * p[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.9lf\\n\", (N == 1) ? 1.0 : ans);\n\t}\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\",\"r\",stdin);\n#endif // ONLINE_JUDGE\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        if(n==1)\n        {\n            printf(\"%.8lf\\n\",v[0]?1:0);\n            continue;\n        }\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=C(j,m)*pow(p[i]*0.01,j)*pow((100-p[i])*0.01,m-j);\n            }\n        for(int i=0; i<n; i++)\n        {\n            if(!v[i])\n            {\n                printf(\"%.8lf\\n\",0);\n                continue;\n            }\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, m, l, p[111], t[111], v[111]; long double r[111][55], dp[55][55];\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++) cin >> p[i] >> t[i] >> v[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) fill(dp[j], dp[j] + m + 1, 0.0);\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j + 1][k] += dp[j][k] * (100 - p[i]) / 100;\n\t\t\t\tdp[j + 1][k + 1] += dp[j][k] * p[i] / 100;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= m; j++) r[i][j] = dp[m][j];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tlong double ret = 0;\n\t\tif (v[i] != 0) {\n\t\t\tlong double time1 = 1.0L * l / v[i];\n\t\t\tfor (int j = 0; j <= m; j++, time1 += t[i]) {\n\t\t\t\tlong double res = r[i][j];\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (i == k) continue;\n\t\t\t\t\tlong double sum = 0;\n\t\t\t\t\tif (v[k] != 0) {\n\t\t\t\t\t\tdouble time2 = 1.0 * l / v[k];\n\t\t\t\t\t\tfor (int l = 0; l <= m; l++, time2 += t[k]) {\n\t\t\t\t\t\t\tif (time1 + 1e-10L < time2) sum += r[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse sum = 1;\n\t\t\t\t\tres *= sum;\n\t\t\t\t}\n\t\t\t\tret += res;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 101,maxm = 51;\nint P[maxn],T[maxn],V[maxn];\nlong long C[maxm][maxm];\ndouble rst[maxn][maxm];\ndouble tim[maxn][maxm];\nconst double eps = 1e-11;\n//#define LOCAL\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n#endif\n    int n,m,l; scanf(\"%d%d%d\",&n,&m,&l);\n    C[0][0] = 1;\n    for(int i = 1; i < maxm; i++){\n        C[i][i] = C[i][0] = 1;\n        for(int j = 1; j < i; j++){\n            C[i][j] = C[i-1][j] + C[i-1][j-1];\n        }\n        //cout<<C[i][i/2]<<endl;\n    }\n    for(int i = 0; i < n; i++){\n        scanf(\"%d%d%d\",P+i,T+i,V+i);\n    }\n    int rt = 0;\n    for(int i = 0; i < n; i++){\n        double p = P[i]/100., t0 = l*1./V[i];\n        for(int j = 0; j <= m; j++){\n            rst[i][j] = C[m][j]*(pow(p,j))*(pow(1-p,m-j));\n            tim[i][j] = t0+j*T[i];\n        }\n        //for(int j = 1; j <= m; j++){\n       //     rst[i][j] += rst[i][j-1];\n      //  }\n    }\n    for(int i = 0; i < n; i++){\n        double ans = 0;\n        for(int j = 0; j <= m; j++){\n            double t = tim[i][j], wn = 1;\n            for(int k = 0; k < n; k++){\n                if(k == i) continue;\n                double twn = 0;\n                for(int j2 = m; j2 >= 0; j2--){\n                    if(tim[k][j2] <= t) break;\n                    twn += rst[k][j2];\n                }\n                wn *= twn;\n            }\n            ans += wn*rst[i][j];\n        }\n        printf(\"%lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 111\n#define M 55\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  double sum=0;\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i),sum+=dp[0][i];\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n  \n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j??????????????°???\n    A[i]=B[i]=vector<double>(m+1,1);\n    if(p[i]==1)A[i]=vector<double>(m+1,0),A[i][0]=1;\n    if(p[i]==0)B[i]=vector<double>(m+1,0),B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]),B[i][j]=B[i][j-1]*p[i];\n      \n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.8f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  double sum=0;\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i),sum+=dp[0][i];\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n  \n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j??????????????°???\n    A[i]=B[i]=vector<double>(m+1,1);\n    if(p[i]==1)A[i]=vector<double>(m+1,0),A[i][0]=1;\n    if(p[i]==0)B[i]=vector<double>(m+1,0),B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]),B[i][j]=B[i][j-1]*p[i];\n      \n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nconst double eps = 1e-12;\n#define REP(i, x) for (int i=0;i<x;i++)\n\ndouble tmp[107][107];\ndouble rest[107][107],rsum[107][107];\nint N,M,L;\nint p[107],t[107],v[107];\ndouble pp[107];\n\nint main()\n{\n    while (scanf(\"%d%d%d\",&N,&M,&L) != EOF)\n    {\n        REP(i,N) scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        REP(i,N) pp[i] = p[i] / 100.0;\n        REP(i,N)\n        {\n            REP(j,M+1) REP(k,M+1) tmp[j][k] = 0;\n            tmp[0][0] = 1.00;\n            for (int j = 1;j <= M;++j)\n                for (int k = 0;k <= j;++k)\n                {\n                    tmp[j][k] = tmp[j-1][k] * (1-pp[i]);\n                    if (k) tmp[j][k] += tmp[j-1][k-1] * pp[i];\n                }\n            for (int j = M;j >= 0;--j)\n            {\n                rest[i][j] = tmp[M][j];\n                rsum[i][j] = tmp[M][j];\n           //     cout<<rest[i][j]<<\" \";\n                if (j!=M) rsum[i][j] += rsum[i][j+1];\n            }\n        }\n        REP(i,N)\n        {\n            double ans = 0;\n            for (int times = 0;times <= M && v[i] != 0;++times)\n            {\n                double part = 1.00;\n                double use = L / (double)v[i] + t[i] * times;\n                for (int k = 0;k < N;++k)\n                    if (k != i)\n                    {\n                        if (v[k] == 0) continue;\n                        int l = 0,r = M;\n                        while (l < r)\n                        {\n                            int mid = (l+r)>>1;\n                            double total = L / (double) v[k] + t[k] * mid;\n                            if (total <= use)\n                                l = mid+1;\n                            else r = mid;\n                        }\n                        double total = L / (double) v[k] + t[k] * l;\n                        \n                      //  --l;\n                        if (total <= use)\n                        {\n                            part = 0.00;\n                            break;\n                        } else\n                            part *= rsum[k][l];\n                    }\n                ans += rest[i][times] * part;\n            }\n            printf(\"%.8f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<long double> p(n),t(n),v(n);\n    rep(i,0,n){\n        cin >> p[i] >> t[i] >> v[i];\n        if(v[i]==0) v[i]=1e-12;\n    }\n\n    ll comb[51][51]={};\n    rep(i,0,51){\n        comb[i][i]=1;\n        comb[i][0]=1;\n    }\n    rep(i,1,51) rep(j,1,i){\n        if(i>0 and i>j) comb[i][j]+=comb[i-1][j];\n        if(j>0) comb[i][j]+=comb[i-1][j-1];\n    }\n\n    vector<map<int,long double>> x(n);\n    rep(i,0,n) rep(j,0,m+1) x[i][t[i]*j]=powl((100-p[i])/100,m-j)*comb[m][j]*powl(p[i]/100,j);\n    rep(i,0,n){\n        long double s1=0;\n        for(const auto& p1:x[i]){\n            long double tmp=p1.second;\n            rep(j,0,n){\n                if(j==i) continue;\n                long double s2=0;\n                for(const auto& p2:x[j]) if((p2.first*v[j]+l)*v[i]>(p1.first*v[i]+l)*v[j]) s2+=p2.second;\n                tmp*=s2;\n            }\n            s1+=tmp;\n        }\n        cout << fixed << setprecision(8) << s1 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \ntemplate <class T>  \ninline bool rd(T &ret) {  \n    char c; int sgn;  \n    if(c=getchar(),c==EOF) return 0;  \n    while(c!='-'&&(c<'0'||c>'9')) c=getchar();  \n    sgn=(c=='-')?-1:1;  \n    ret=(c=='-')?0:(c-'0');  \n    while(c=getchar(),c>='0'&&c<='9') ret=ret*10+(c-'0');  \n    ret*=sgn;  \n    return 1;  \n}  \ntemplate <class T>  \ninline void pt(T x) {  \n    if (x <0) {  \n        putchar('-');  \n        x = -x;  \n    }  \n    if(x>9) pt(x/10);  \n    putchar(x%10+'0');  \n}  \nusing namespace std;  \ntypedef long long ll;  \nconst int MAXN = 55;  \ndouble C[MAXN+1][MAXN+1];  \nvoid Initial()  \n{  \n    memset(C, 0, sizeof C);  \n    for(int i=0; i<=MAXN; ++i)  \n    {  \n        C[0][i] = 0.0;  \n        C[i][0] = 1.0;  \n    }  \n    for(int i=1; i<=MAXN; ++i)  \n    {  \n        for(int j=1; j<=MAXN; ++j)  \n        C[i][j] = C[i-1][j] + C[i-1][j-1];  \n    }  \n}  \nconst int N = 110;  \nint n, m;  \nint l, t[N], v[N];  \ndouble p[N];  \ndouble Pow(double x, int y){  \n    double ans = 1.0;  \n    while(y){  \n        if(y&1)ans *= x;  \n        x = x*x;  \n        y >>= 1;  \n    }  \n    return ans;  \n}  \ndouble work(int x){  \n    double ans = 0.0;  \n    for(int i = 0; i <= m; i++)  \n    {  \n        double pp = C[m][i] * Pow(p[x], i) * Pow(1.0-p[x], m-i);  \n        for(int j = 1; j <= n; j++)  \n        {  \n            if(j == x)continue;  \n            double siz = 0;  \n            for(int k = m; k >= 0; k--)  \n            {  \n                if(l*v[j] + i*t[x]*v[j]*v[x] < l*v[x] + k*t[j]*v[x]*v[j])  \n                    siz += C[m][k] * Pow(p[j], k) * Pow(1.0-p[j], m-k);  \n                else break;  \n            }  \n            pp *= siz;  \n        }  \n        ans += pp;  \n    }  \n    return ans;  \n}  \nvoid input(){  \n    for(int i = 1; i <= n; i++)  \n        {  \n            rd(p[i]);rd(t[i]);rd(v[i]);  \n            p[i] /= 100.0;  \n        }  \n}  \nint main(){  \n    Initial();  \n    while(cin>>n>>m>>l){  \n        input();  \n        for(int i = 1; i <= n; i++)  \n            printf(\"%.10f\\n\", work(i));  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <tuple>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M, L;\n\nvector<tuple<int, int, int>> vs;\n\ndouble P[111][111];\ndouble T[111][111];\n\nnamespace math { namespace combination {\n\n#define COMBINATION_MAX 200\nusing return_type = ll;\n\nnamespace memorized { namespace combination { enum { max_value = COMBINATION_MAX }; bool __computed = false; inline bool computed() {if(__computed) { return true; } else { __computed = true; return false; }} return_type dp[max_value][max_value];} }\n\nreturn_type comb(int N, int K) {\n  using memorized::combination::dp;\n  if(memorized::combination::computed()) { return dp[N][K]; }\n\n  rep(i, memorized::combination::max_value) {\n    dp[i][0] = 1;\n    REP(j, 1, i+1) {\n      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n//      dp[i][j] %= MOD;\n    }\n  }\n  return dp[N][K];\n}}}\n\nvoid solve() {\n  rep(i, N) {\n    rep(j, M+1) {\n      P[i][j] = pow(get<0>(vs[i]) * 0.01, j) * pow((100-get<0>(vs[i])) * 0.01, M - j) * math::combination::comb(M, j);\n      if(j) T[i][j] = T[i][j-1] + get<2>(vs[i]);\n      else T[i][0] = 1.0 * L / get<1>(vs[i]);\n    }\n  }\n\n  rep(i, N) {\n    double res = 0;\n\n    if(get<1>(vs[i]) == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    rep(j, M+1) {\n      double losers_prob = 1.0;\n      rep(k, N) {\n        if(i == k) continue;\n        double sum = 0.0;\n        rep(l, M+1) {\n          if(T[i][j] < T[k][l]) sum += P[k][l];\n        }\n        losers_prob *= sum;\n      }\n      res += losers_prob * P[i][j];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n\n  cin >> N >> M >> L;\n  rep(i, N) {\n    int p, t, v; cin >> p >> t >> v;\n    vs.push_back({p, v, t});\n  }\n\n  N = vs.size();\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define Max 200\n#define eps 1e-10\n#define LL long long\n\nLL comb(LL n,LL m){\n\tLL ret=1,i;\n\tm=m<(n-m)?m:(n-m);\n\tfor (i=n-m+1;i<=n;ret*=(i++));\n\tfor (i=1;i<=m;ret/=(i++));\n\treturn m<0?0:ret;\n}\n\ndouble a[Max][Max], aa[Max][Max];\n\nstruct node\n{\n\tdouble p, time, v;\n}Node[Max], Nodeb[Max];\n\ndouble ppow (double p, LL num)\n{\n\tdouble ans = 1.0;\n\tfor (LL i = 1;i <= num;i ++)\n\t\tans = ans * p;\n\treturn ans;\n}\n\nint main ()\n{\n\tLL n, m, L, i, j, k, ll, num;\n\twhile (scanf (\"%lld%lld%lld\", &n, &m, &L) == 3)\n\t{\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tscanf (\"%lf%lf%lf\", &Node[i].p, &Node[i].time, &Node[i].v);\n\t\t\tNode[i].p /= 100.0;\n\t\t}\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tfor (j = 0;j <= m;j ++)\n\t\t\t{\n\t\t\t\tnum = comb(m, j);\n\t\t\t\ta[i][j] = (double)num * ppow (Node[i].p, j) * ppow((1 - Node[i].p), m - j);\n\t\t\t\taa[i][j] = (double)j * Node[i].time + L / Node[i].v;\n\t\t\t\t//cout << aa[i][j] << endl;\n\t\t\t}\n\t\t}\n\n\t\tdouble res = 0.0;\n\t\tint nn = 0;\n\t\tbool flag;\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tfor (j = 0;j < n;j ++)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tif (i == j) continue;\n\t\t\t\tfor (k = 0;k <= m;k ++)\n\t\t\t\t{\n\t\t\t\t\tfor (ll = 0; ll <= m; ll ++)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (aa[i][k] < aa[j][ll] && nn == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tres = res + a[i][k] * a[j][ll];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (aa[i][k] < aa[j][ll] && nn != 0)\n\t\t\t\t\t\t\tres = res * a[j][ll];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) nn ++;\n\t\t\t}\n\t\t\tprintf (\"%.8lf\\n\", res);\n\t\t\tres = 0.0;\n\t\t\tnn = 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <string>\nusing namespace std;\n#define min(a,b) a<b?a:b;\n#define max(a,b) a>b?a:b;\n#define LL long long\nconst int N = 210;\n#define inf 100000000\ndouble dp[N][N],p[N][N],ans[N];//莠コ?御シ第?蜃?惻縲よ慮髣エ?梧ヲら紫\ndouble zu[N][N];\nint n;\nstruct node{\n\tdouble p,t,v;\n}data[N];\nvoid zuhe()\n{\n\tint i,j;\n\tfor(i=1;i<=110;i++)\n\t{\n\t\tzu[i][0]=1;\n\t\tzu[i][1]=i;\n\t}\n\tfor(i=2;i<=110;i++)\n\t\tfor(j=1;j<=i;j++)\n\t\t\tzu[i][j]=zu[i-1][j]+zu[i-1][j-1];\n}\nint main()\n{\n\tint i,j,z,k,m,l;\n\tdouble sum,res;\n\tzuhe();\n\twhile(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\tscanf(\"%lf%lf%lf\",&data[i].p,&data[i].t,&data[i].v);\n\t\tdata[i].p/=100;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdouble pp=data[i].p;\n\t\t\tfor(z=1;z<m;z++)\n\t\t\t\tpp=pp*data[i].p;\n\t\t\tfor(j=m;j>=0;j--)\n\t\t\t{\n\t\t\t\tif(data[i].v==0)\n\t\t\t\t\tdp[i][j]=inf;\n\t\t\t\telse\n\t\t\t\t\tdp[i][j]=j*data[i].t+l/data[i].v;\n\t\t\t\tp[i][j]=pp*zu[m][j];\n\t\t\t\tif(pp==0)\n\t\t\t\t{\n\t\t\t\t\tif(j==1)\n\t\t\t\t\t\tpp=1;\n\t\t\t\t}\n\t\t\t\telse if(pp==1)\n\t\t\t\t{\n\t\t\t\t\t\tpp=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tpp=pp/data[i].p*(1-data[i].p);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tans[i]=0;\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tres=p[i][j];\n\t\t\t\tfor(z=1;z<=n;z++)\n\t\t\t\t{\n\t\t\t\t\tsum=0;\n\t\t\t\t\tif(z==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(k=0;k<=m;k++)\n\t\t\t\t\t\tif(dp[i][j]<dp[z][k])\n\t\t\t\t\t\t\tsum+=p[z][k];\n\t\t\t\t\tres*=sum;\n\t\t\t\t}\n\t\t\t\tans[i]+=res;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"%.8lf\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n\t\t\t\t\n\n/*\n2 2 50\n30 50 1\n30 50 2\n\n2 1 100\n100 100 10\n0 100 1\n\n3 1 100\n50 1 1\n50 1 1\n50 1 1\n\n2 2 50\n30 0 1\n30 50 2\n\n  */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\nint C(int n,int k)\n{\n\tint y=1;\n\tfor(int i=n-k+1,j=2;i<=n;i++){\n\t\ty*=i;\n\t\twhile(y%j==0&&j<=k){\n\t\t\ty=y/j;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn y;\n}\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\n#define eps 1e-6\nint dd(double x,double y){ return fabs(x-y)<eps;} // x==y\nint dy(double x,double y){ return x>y+eps;}   // x>y   \nint xy(double x,double y){ return x<y-eps;}   //x<y\nint dyd(double x,double y){ return x>y-eps;}  //x>=y\nint xyd(double x,double y){ return x<y+eps;}  //x<=y\n\n\nint main(){\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l) == 3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C(st,j)*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(dy(t1,t))\n\t\t\t\t\t\t\tp2+=C(st,u)*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%lf\\n\",ppp);\n\t\t}\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define Max 200\n#define eps 1e-10\n#define LL long long\n\nLL comb(LL n,LL m){\n\tLL ret=1,i;\n\tm=m<(n-m)?m:(n-m);\n\tfor (i=n-m+1;i<=n;ret*=(i++));\n\tfor (i=1;i<=m;ret/=(i++));\n\treturn m<0?0:ret;\n}\n\ndouble a[Max][Max], aa[Max][Max];\n\nstruct node\n{\n\tdouble p, time, v;\n}Node[Max], Nodeb[Max];\n\ndouble ppow (double p, LL num)\n{\n\tdouble ans = 1.0;\n\tfor (LL i = 1;i <= num;i ++)\n\t\tans = ans * p;\n\treturn ans;\n}\n\nint main ()\n{\n\tLL n, m, L, i, j, k, ll, num;\n\twhile (scanf (\"%lld%lld%lld\", &n, &m, &L) == 3)\n\t{\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tscanf (\"%lf%lf%lf\", &Node[i].p, &Node[i].time, &Node[i].v);\n\t\t\tNode[i].p /= 100.0;\n\t\t}\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tfor (j = 0;j <= m;j ++)\n\t\t\t{\n\t\t\t\tnum = comb(m, j);\n\t\t\t\ta[i][j] = num * ppow (Node[i].p, j) * ppow((1 - Node[i].p), m - j);\n\t\t\t\taa[i][j] = Node[i].time * j + L / Node[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdouble res = 0.0;\n\t\tfor (i = 0;i < n;i ++)\n\t\t{\n\t\t\tfor (j = 0;j < n;j ++)\n\t\t\t{\n\t\t\t\tif (i == j) continue;\n\t\t\t\tfor (k = 0;k <= m;k ++)\n\t\t\t\t{\n\t\t\t\t\tfor (ll = 0; ll <= m; ll ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (aa[i][k] < aa[j][ll])\n\t\t\t\t\t\t\tres = res + a[i][k] * a[j][ll];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf (\"%.8lf\\n\", res);\n\t\t\tres = 0.0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nint n,m;\ndouble l;\ndouble p[100],t[100],v[100];\ndouble comb[160][160];\ndouble kaku[100][160];\ndouble kaku2[100][160];\nvector<pal> ve[110];\ndouble bekijou(double r,double k){\n\tif(r==0) return 0;\n\tif(k==1) return r;\n\tif(k==0) return 1;\n\treturn bekijou(r,k-1)*r;\n}\n\n   signed main(){\ncin>>n>>m>>l;\n   \tif(n==1){\n   \tcout<<1<<endl;\n   \t\treturn 0;\n   \t}\n   \tfor(int i=0;i<60;i++)comb[i][0]=1.0,comb[i][i]=1.0;\n   \t\n   \tfor(int k=1;k<60;k++)for(int j=1;j<k;j++) comb[k][j]=comb[k-1][j-1]+comb[k-1][j];\n   \t\n   \tfor(int i=0;i<n;i++){\n   \t\tcin>>p[i]>>t[i]>>v[i];\n   \t\tp[i]/=100;\n   \t}\n   \t\n   \tfor(int i=0;i<n;i++)for(int j=0;j<=m;j++){\n   \t//\tcout<<i<<\" \"<<j<<endl;\n   \t\tif(j==0)kaku[i][j]=bekijou(1-p[i],m);\n   \t\telse if(j==m) kaku[i][j]=bekijou(p[i],m);\n   \t\telse{\n   \t\t\tkaku[i][j]=comb[m][j]*bekijou(p[i],j)*bekijou(1.0-p[i],m-j);\n   \t\t}\n   \t\tkaku2[i][j]=kaku[i][j];\n   \t//\tcout<<i<<\" \"<<l/v[i]+j*t[i]<<\" \"<<kaku2[i][j]<<endl;\n   \t\tif(j>0) kaku[i][j]+=kaku[i][j-1];\n   \t\tve[i].pb(mp(l/v[i]+j*t[i],kaku[i][j]));\n   \t}\n \t//cout<<\"he\"<<endl;\n   \tfor(int i=0;i<n;i++){\n   \t\tdouble ans=0;\n   \t\t\n   \t\tfor(int j=0;j<=m;j++){\n   \t\t\tdouble d=1;\n   \t\t\t\n   \t\t\tfor(int l=0;l<n;l++)if(l!=i){\n   \t\t\t\tpal er=mp(ve[i][j].first,inf);\n   \t\t\t\tint r=lower_bound(ve[l].begin(),ve[l].end(),er)-ve[l].begin();\n   \t\t\t\tif(r!=0){\n   \t\t\t\t\td*=1.0-ve[l][r-1].second;\n   \t\t\t\t}\n   \t\t\t}\n   \t//\t\tcout<<i<<\" \"<<j<<\" \"<<d<<endl;\n   \t\t\tans+=kaku2[i][j]*d;\n   \t\t}\n   \t\tprintf(\"%.10lf\\n\",ans);\n   \t}\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M,L;\ndouble P[100],T[100],V[100];\n\ndouble p[100][55],t[100][55];\n\ndouble dp[55][55];\n\nsigned main(){\n    cin>>N>>M>>L;\n    rep(i,N)cin>>P[i]>>T[i]>>V[i],P[i]/=100;\n\n    rep(i,N){\n        memset(dp,0,sizeof(dp));\n        dp[0][0]=1.0;\n        for(int j=0;j<M;j++){\n            for(int k=0;k<=j;k++){\n                dp[j+1][k+1]+=dp[j][k]*P[i];\n                dp[j+1][k]+=dp[j][k]*(1-P[i]);\n            }\n        }\n\n        for(int j=0;j<=M;j++){\n            t[i][j]=L/V[i]+j*T[i];\n            p[i][j]=dp[M][j];\n        }\n    }\n\n    rep(i,N){\n        double latte=0.0;\n        for(int j=0;j<=M;j++){\n            double malta=p[i][j];\n            for(int k=0;k<N;k++)if(k!=i){\n                double mocha=0.0;\n                for(int l=0;l<=M;l++)if(t[k][l]>t[i][j])mocha+=p[k][l];\n                malta*=mocha;\n            }\n            latte+=malta;\n        }\n        printf(\"%.20f\\n\",latte);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 100;\nconst int M = 51;\nconst double EPS = 1e-9;\n\nint n, m, L, t[N], v[N];\nlong double p[N], C[M+1][M+1], ps[N][N], s_ps[N][N], ts[N][N];\n\nmain(){\n  for(int i=0;i<=M;i++) C[i][0] = 1.0;\n  for(int i=1;i<=M;i++) for(int j=1;j<=i;j++) C[i][j] = C[i-1][j-1] + C[i-1][j];\n  cin >> n >> m >> L;\n  for(int i=0;i<n;i++) cin >> p[i] >> t[i] >> v[i];\n  bool f = true;\n  for(int i=0;i<n;i++) if(v[i]) f = false;\n  if(f){\n    printf(\"%.8f\\n\", 0+EPS);\n    return 0;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      ps[i][j] = C[m][j] * pow(p[i]/100.0, j) * pow((100 - p[i])/100.0, m - j);\n      if(j == 0) s_ps[i][j] = ps[i][j];\n      else s_ps[i][j] = s_ps[i][j-1] + ps[i][j];\n      ts[i][j] = (double)L / v[i] + t[i] * j;\n    }\n  }\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    for(int j=0;j<=m;j++){\n      double tmp = 1.0;\n      for(int k=0;k<n;k++){\n        if(k == i) continue;\n        int l = lower_bound(ts[k], ts[k]+m+1, ts[i][j]+EPS) - ts[k];\n        if(l != 0) tmp *= (1.0 - s_ps[k][l-1]);\n      }\n      ans += ps[i][j] * tmp;\n    }\n    printf(\"%.8f\\n\", ans+EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\nint N, M, L, P[110], T[110], V[110];\ndouble RP[110][55], RT[110][55];\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\n\tminit(RP, 0);\n\t\t\n\tfor_(i,0,N) {\n\t\tRT[i][0] = V[i] > 0 ? (double)L / (double)V[i] : 1e9;\n\t\tfor_(j,0,M) RT[i][j + 1] = RT[i][j] + (double)T[i];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tvector< double > p(M+1, 1.0), pm(M+1, 1.0);\n\t\t\n\t\tfor_(k,0,M) {\n\t\t\tp[k + 1] = p[k] * (double)P[i] / 100.0;\n\t\t\tpm[k + 1] = pm[k] * (1.0 - (double)P[i] / 100.0);\n\t\t}\n\t\t\n\t\tint mCk = 1;\n\t\t\n\t\tfor_(k,0,M + 1) {\n\t\t\tRP[i][k] =  (double)mCk * p[k] * pm[M - k];\n\t\t\tmCk *= (M - k);\n\t\t\tmCk /= k + 1;\n\t\t}\n\t\t\n\t\tfor_rev(k,M,1) RP[i][k-1] += RP[i][k];\n\t}\n\t\t\n\tfor_(i,0,N) {\n\t\tif (V[i] == 0) {\n\t\t\tcout << \"0.000000000\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble ans = 0.0;\n\t\t\n\t\tfor_(k,0,M+1) {\n\t\t\tdouble t = RT[i][k];\n\t\t\tdouble p = RP[i][k] - RP[i][k + 1];\n\t\t\t\t\t\t\n\t\t\tfor_(ii,0,N) {\n\t\t\t\tif (ii == i || V[ii] == 0) continue;\n\t\t\t\tint id = upper_bound(RT[ii], RT[ii] + M + 1, t) - RT[ii];\n\t\t\t\tp *= RP[ii][id];\n\t\t\t}\n\t\t\t\n\t\t\tans += p;\n\t\t}\n\t\t\n\t\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<double,int,double> tp;\ntypedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tdouble l;\n\tcin>>n>>m>>l;\n\tvt in;\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta/=100;\n\t\tdouble sum=0;\n\t\tvd dp(200);\n\t\tdp[100]=1;\n\t\trep(j,m){\n\t\t\tvd ndp(200);\n\t\t\trep(k,200)if(dp[k]>0){\n\t\t\t\tndp[k+1]+=dp[k]*a;\n\t\t\t\tndp[k-1]+=dp[k]*(1-a);\n\t\t\t}\n\t\t\tdp=ndp;\n\t\t}\n\t\trep(j,m+1){\n\t\t\tsum=dp[100-m+2*j];\n\t\t\tin.pb(tp(l/c+j*b,i,sum));\n\t\t}\n\t}\n\tsort(all(in));\n\tvd out(n);\n//\tdouble t=1;\n\tvd t(n,1);\n\trep(i,in.size()){\n\t\tdouble a,c;int b;\n\t\ttie(a,b,c)=in[i];\n//\t\tcout<<shosu(4)<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t\tvt tmp;\n\t\ttmp.pb(in[i]);\n\t\tt[b]-=c;\n\t\twhile(i!=in.size()-1){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=in[i+1];\n\t\t\tif(abs(a-d)<EPS){\n\t\t\t\ti++;\n\t\t\t\ttmp.pb(in[i]);\n\t\t\t\tt[e]-=f;\n\t\t\t}else break;\n\t\t}\n//\t\trep(j,t.size())cout<<\" \"<<t[j];cout<<endl;\n\t\trep(j,tmp.size()){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=tmp[j];\n\t\t\tdouble sum=f;\n\t\t\trep(k,n)if(k!=e)sum*=t[k];\n\t\t\tout[e]+=sum;\n\t\t}\n//\t\tcout<<t<<endl;\n\t}\n\trep(i,n)cout<<shosu(9)<<out[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 1000\n\ndouble x[MAX_N][MAX_N];\ndouble t[MAX_N][MAX_N];\nint n, m, l;\nint p[MAX_N][3];\ndouble dp[MAX_N][MAX_N];\ndouble boss[MAX_N];\ndouble kakuritsu;\ndouble res;\n\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int h = 0; h < n; h++) {\n\t\tcin >> p[h][0] >> p[h][1] >> p[h][2];\n\t\t//kakuritsu calc.\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1.0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] * (100.0 - p[h][0]) / 100.0;\n\t\t\t\tdp[i][j + 1] += 1.0 * dp[i - 1][j] * p[h][0] / 100.0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tx[h][i] = dp[m][i];\n\t\t}\n\t\t//time calc.\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tt[h][i] = (1.0*l / p[h][2]) + p[h][1] * i;\n\t\t}\n\t}\n\t//kakuritsu calc 2.\n\tfor (int h = 0; h < n; h++) {\n\t\tres = 0.0;\n\t\tfor (int i = 0; i <= m; i++) {\n\t\tmemset(boss, 0, sizeof(boss));\n\t\tkakuritsu = 1.0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (h != j) {\n\t\t\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\t\t\tif (t[h][i] < t[j][k]) {\n\t\t\t\t\t\t\tboss[j] += x[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkakuritsu *= boss[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += kakuritsu*x[h][i];\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define CLR(arr,val) memset(arr,val,sizeof(arr));\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define Lowbit(x) ((x)&(-x))\nconst double eps = 1e-8;\nconst int inf = 1000000000;\nconst int M   = 100000;\nconst int N   = 105;\ntypedef long long LL;\n\nstruct Node{\n\tdouble p;\n\tint t,v;\n}a[N];\ndouble pp[N][55],tt[N][55];\nint c[55][55];\nvoid C(){\n\tfor(int i=0; i<51; i++)\n\t\tc[0][i] = 1;\n\tfor(int i=1; i<51; i++)\n\t\tfor(int j=i; j<51; j++)\n\t\t\tc[i][j] = c[i-1][j-1]+c[i][j-1];\n}\ninline double Pow(double a,int k){\n\tdouble res = 1.0;\n\twhile( k-- ) res *= a;\n\treturn res;\n}\nint main(){\n\tC();\n\tint n, m, l;\n\twhile( scanf(\"%d%d%d\", &n, &m, &l) != EOF ){\n\t\tint p;\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tscanf(\"%d%d%d\", &p, &a[i].t, &a[i].v);\n\t\t\ta[i].p = p/100.0;\n\t\t}\n\t\tCLR( pp, 0 );\n\t\tCLR( tt, 0 );\n\t\tfor(int i=0 ; i < n ; ++i)\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\tpp[i][j] = c[j][m]*Pow(a[i].p,j)*Pow(1.0-a[i].p,m-j);\n\t\t\t\ttt[i][j] = 1.0*l/a[i].v+a[i].t*j;\n\t\t\t}\n\t\tfor(int i=0 ; i < n ; ++i){\n\t\t\tdouble tmp, ppp = 0;\n\t\t\tfor(int j=0 ; j <= m ; ++j){\n\t\t\t\ttmp = pp[i][j];\n\t\t\t\tfor(int k=0 ; k < n ; ++k){\n\t\t\t\t\tdouble t = 0;\n\t\t\t\t\tif( k == i ) continue;\n\t\t\t\t\tfor(int q=0 ; q <= m ; ++q){\n\t\t\t\t\t\tif( tt[k][q] > tt[i][j] )\n\t\t\t\t\t\t\tt += pp[k][q];\n\t\t\t\t\t}\n\t\t\t\t\ttmp *= t;\n\t\t\t\t}\n\t\t\t\tppp += tmp;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\", ppp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++)cin >> p[i] >> t[i] >> v[i];\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(!v[i])time[i][j] = 1e+10;\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  double k = 1.0;\n  for(int i=0;i<m;i++)k*=100.0;\n  cout << k << endl;\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(100-p[i],m);\n    prob[i][0] /= k;\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(100-p[i],m-j) * pow(p[i],j);\n      prob[i][j] /= k;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": " /* Author: happywu \n *  File: d.cpp\n *  Create Date: 2015-10-01\n */\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <time.h>\n#include <map>\n#include <set>\n#include <utility>\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 100000;\nconst double eps = 1e-7;\nint n,m,s;\nlong long C[55][55];\nstruct node{\n\tint p,t,v;\n}a[110];\nvoid init(){\n\tC[0][0]=1;C[1][0]=1;\n\tfor(int i=1;i<=51;i++)C[i][0]=1;\n\tfor(int i=1;i<=51;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n}\ndouble calc(int idx,int x){\n\tif(x>m)return 0;\n\tdouble ans=0;\n\tfor(int i=x;i<=m;i++){\n\t\tans+=C[m][i]*pow(a[idx].p*1.0/100,i)*pow(1-a[idx].p*1.0/100,m-i);\n\t}\n\treturn ans;\n}\nint main(int argc, char* argv[]){\n\tinit();\n\tscanf(\"%d%d%d\",&n,&m,&s);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d%d\",&a[i].p,&a[i].t,&a[i].v);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble ans=0;\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tdouble t=s*1.0/a[i].v+a[i].t*j;\n\t\t\tdouble p1=1;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(i==k)continue;\n\t\t\t\tif(a[k].t==0){\n\t\t\t\t\tdouble tk1=s*1.0;\n\t\t\t\t\tif(tk1>t){p1*=calc(k,0);}\n\t\t\t\t\telse p1=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdouble tk1=s*1.0/a[k].v;\n\t\t\t\tint x=(t-tk1)/a[k].t;\n\t\t\t\tif(tk1+a[k].t*x<t||(tk1+a[k].t*x-t)<eps)x++;\n\t\t\t\tp1*=calc(k,x);\n\t\t\t}\n\t\t\tans+=C[m][j]*pow(a[i].p*1.0/100,j)*pow(1-a[i].p*1.0/100,m-j)*p1;\n\t\t}\n\t\tprintf(\"%.7f\\n\",ans);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define MAXX 51\n\nshort n,m,i,j,k,l;\nint len;\ndouble t;\ndouble ans,sum,sum1;\nunsigned long long C[MAXX][MAXX];\ndouble mat[MAXX<<1][MAXX];\ndouble p[MAXX<<1][MAXX];\n\nstruct node\n{\n    short p,t,v;\n}run[MAXX];\n\nint main()\n{\n    for(i=1;i<MAXX;++i)\n    {\n        C[1][i]=i;\n        C[0][i]=1;\n        C[i][i]=1;\n    }\n    for(i=2;i<MAXX;++i)\n        for(j=2;j<=i;++j)\n            C[j][i]=C[j-1][i]*(i-j+1)/j;\n    scanf(\"%hd %hd %d\",&n,&m,&len);\n    for(i=0;i<n;++i)\n        scanf(\"%hd %hd %hd\",&run[i].p,&run[i].t,&run[i].v);\n    for(i=0;i<n;++i)\n    {\n        t=(double)len/run[i].v;\n        for(j=0;j<=m;++j)\n        {\n            p[i][j]=C[j][m];\n            for(k=0;k<j;++k)\n                p[i][j]*=(double)run[i].p/100;\n            for(k=0;k<m-j;++k)\n                p[i][j]*=(double)(100-run[i].p)/100;\n            mat[i][j]=t+j*run[i].t;\n        }\n    }\n    /*\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",mat[i][j]);\n        printf(\"\\n\");\n    }\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",p[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\\n\");\n    */\n    for(i=0;i<n;++i)\n    {\n        sum=0;\n        for(j=0;j<=m;++j)\n        {\n            ans=p[i][j];\n            for(k=0;k<n;++k)\n                if(i!=k)\n                {\n                    sum1=0;\n                    for(l=0;l<=m;++l)\n                        if(mat[i][j]<mat[k][l])\n                            sum1+=p[k][l];\n                    ans*=sum1;\n                }\n            sum+=ans;\n        }\n        printf(\"%f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nint N, M, L;\nint P[200], T[200], V[200];\n\ndouble prob[200][200];\ndouble sum[200][200];\n\nvoid calc_Btry() {\n    for (int i = 0; i < N; ++i) {\n        prob[i][0] = 1.0;\n        for (int j = 1; j <= M; ++j) prob[i][j] = 0.0;\n        for (int j = 0; j < M; ++j) {\n            for (int k = j; k >= 0; --k) {\n                prob[i][k+1] += prob[i][k] * (double)(P[i]) / 100;\n                prob[i][k] *= 1.0 - (double)(P[i]) / 100;\n            }\n        }\n        for (int j = 0; j <= M; ++j) sum[i][j] = 0.0;\n        sum[i][M] = prob[i][M];\n        for (int j = M-1; j >= 0; --j) sum[i][j] = sum[i][j+1] + prob[i][j];\n    }\n}\n\n\n\nint main() {\n    while (cin >> N >> M >> L) {\n        for (int i = 0; i < N; ++i) cin >> P[i] >> T[i] >> V[i];\n        calc_Btry();\n        \n//        for (int i = 0; i < N; ++i) {\n//            cout << i << \" : \";\n//            for (int j = 0; j <= M; ++j) cout << sum[i][j] << \", \" ;\n//            cout << endl;\n//        }\n        \n        cout << fixed << setprecision(7);\n        for (int i = 0; i < N; ++i) {\n            double res = 0.0;\n            for (int j = 0; j <= M; ++j) {\n                double tmp = prob[i][j];\n                double aite = 1.0;\n                for (int k = 0; k < N; ++k) {\n                    if (k == i) continue;\n                    \n                    int lim = M;\n                    while ( (double)(L)/V[k] + T[k]*lim > (double)(L)/V[i] + T[i]*j ) {\n                        if (lim < 0) break;\n                        --lim;\n                    }\n                    ++lim;\n                    \n                    if (lim > M) aite = 0.0;\n                    else aite *= sum[k][lim];\n                }\n                res += tmp * aite;\n            }\n            cout << res << endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++){\n    cin >> p[i] >> t[i] >> v[i];\n    p[i] /= 100;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    if(abs(p[i]-1.0)<1e-10){\n      for(int j=0;j<m;j++)prob[i][j] = 0.0;\n      prob[i][m] = 1.0;\n    }else{\n      prob[i][0] = pow(1-p[i],m);\n      for(int j=1;j<=m;j++){\n\tprob[i][j] = (prob[i][j-1] * p[i] * (m-j+1))/( (1-p[i]) * j );\n      }\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    double sum = 0.0;\n    for(int j=0;j<=m;j++){\n      cout << prob[i][j] << \" \";\n      sum += prob[i][j];\n    }\n    cout << endl;\n    cout << sum << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=0;l<=m;l++){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\ndouble C[N][N];\n\ndouble prob[N][N];\ndouble time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\tif (!v[i]) continue;\n\t\ttime[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) time[i][j] = time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tdouble a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tdouble ct = time[i][j];\n\t\t\tdouble cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tdouble tmp = 0;\n\t\t\t\twhile (idx >= 0 && time[k][idx] > ct - (1e-9)) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nstruct runner{\n\tint t,v;\n\tdouble p;\n};\n\nconst int INF=1000000000;\n\nvector<runner> vr;\ndouble mem[101][51][101];\n// kÍxe·éêÌ\ndouble calcPer(int n,int k,int idx){\n\tif(!EQ(mem[n][k][idx],INF))\n\t\treturn mem[n][k][idx];\n\tdouble p = vr[idx].p;\n\tif(k==0)\n\t\treturn 1.0;\n\telse{\n\t\treturn mem[n][k][idx]=(((double)n/k)*calcPer(n-1,k-1,p)*p);\n\t}\n}\n\nint main(){\n\n\tint n,m,L;\n\tfor(int i = 0; i < 101; i++)\n\t\tfor(int j = 0; j < 51; j++)\n\t\t\tfor(int k = 0; k < 101; k++)\n\t\t\t\tmem[i][j][k]=INF;\n\n\tcin>>n>>m>>L;\n\tfor(int i = 0; i < n; i++){\n\t\trunner r;\n\t\tint p;\n\t\tcin>>p>>r.t>>r.v;\n\t\tr.p=(double)p/100;\n\t\tvr.push_back(r);\n\t}\n\t// êl¸ÂßÄ¢­\n\tfor(int i = 0; i < n; i++){\n\t\tdouble sumPer=0.0;\n\t\tif(vr[i].v==0)\n\t\t\tsumPer=0.0;\n\t\telse{\n\t\t\t// ©ªª¢­ÂÌêÅxe·é©\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t// »ÝÌxeÅxe·ém¦\n\t\t\t\tdouble cper=calcPer(m,j,i)*pow((double)(1-vr[i].p),m-j);\n\t\t\t\tdouble selfTime=((double)L/vr[i].v)+vr[i].t*j;\n\t\t\t\t// »ê¼êÌGÉÂ¢Ä²×é\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t// ©ª©gÜ½ÍA¬xª0Ìi[Í³·é\n\t\t\t\t\tif(i==k||EQ(vr[k].v,0.0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble enemPer=1.0;\n\t\t\t\t\t// èª¢­ÂÈãÌêÅxeµ½çAÔÉ¤©ð`FbN\n\t\t\t\t\tfor(int l = 0; l <= m; l++){\n\t\t\t\t\t\t// GÌBðvZ\n\t\t\t\t\t\tdouble enemyTime=((double)L/vr[k].v)+vr[k].t*l;\n\t\t\t\t\t\t// àµGÌBÔª©ªÌBÔðºñÁ½çI¹\n\t\t\t\t\t\tif(EQ(enemyTime,selfTime)||enemyTime>selfTime){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ±ÌÌêÅxe·ém¦\n\t\t\t\t\t\tdouble p=calcPer(m,l,k)*pow((double)(1-vr[k].p),m-l);\n\t\t\t\t\t\tenemPer-=p;\n\t\t\t\t\t}\n\t\t\t\t\t// »ÝcÁÄ¢ém¦ªAGª©ªæèx­B·ém¦\n\t\t\t\t\tcper*=enemPer;\n\t\t\t\t}\n\t\t\t\t// cperª»Ìm¦\n\t\t\t\tsumPer+=cper;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",sumPer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define RST(A) memset(A, 0, sizeof(A))\n#define FLC(A, x) memset(A, x, sizeof(A))\n\ntypedef double DB;\n\nconst int N = int(1e2) + 9, M = int(5e1) + 9;\nDB p[N][M], sp[N][M], t[N], t0[N];\nint n, m, l;\n\nDB f(int i, DB ti){\n    DB z = 1; REP(j, n) if (i != j){\n        if (t0[j] + m*t[j] <= ti) return 0;\n        REP(k, m+1) if (t0[j] + k*t[j] > ti){\n            z *= (1 - sp[j][k]);\n            break;\n        }\n    }\n    return z;\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    while (~scanf(\"%d%d%d\", &n, &m, &l)){\n\n        RST(p); REP(i, n){\n            int _p, v; scanf(\"%d%lf%d\", &_p, &t[i], &v); t0[i] = (DB) l / v; DB pp = (DB) _p / 100;\n            //cout <<\" \" << pp << endl;\n            p[i][0] = 1; DO(m){\n                DWN_1(j, m, 1) p[i][j] = p[i][j-1] * pp + p[i][j] * (1-pp);\n                p[i][0] = p[i][0] * (1-pp);\n            }\n\n            REP(j, m+1) cout << t0[i] << \" \";\n            cout <<endl;\n\n            REP_1(j, m) sp[i][j] = sp[i][j-1] + p[i][j-1];\n        }\n\n        REP(i, n){\n            DB z = 0; REP(j, m+1) z += p[i][j] * f(i, t0[i] + t[i]*j);\n            printf(\"%.9f\\n\", z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double pp[MAXN],time[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\nLL Com[MAXN][MAXN];\n\nint main()\n{\n    Com[0][0]=1;\n    for(int i=1;i<=50;i++)\n    {\n        Com[i][0]=Com[i-1][0];\n        for(int j=1;j<=i;j++)\n            Com[i][j]=Com[i-1][j]+Com[i-1][j-1];\n    }\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                double x=Com[m][j];\n                int k;\n                for(k=1;k<=j;k++)\n                    x*=p[i]/100.0;\n                for(;k<=m;k++)\n                    x*=(100-p[i])/100.0;\n                peo[i].pp[j]=x;\n                peo[i].time[j]=(L+0.0)/v[i]+j*t[i];\n            }\n        for(int i=0; i<n; i++)\n        {\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double x=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[k].time[l]>peo[i].time[j])\n                            x+=peo[k].pp[l];\n                    tmp*=x;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\ndouble calc(double r, int a, int b)\n{\n\tdouble ret = r;\n\tb = min(a - b, b);\n\tif (b == 0) return ret;\n\trep(i, a - b, a + 1) ret *= i;\n\trep(i, 1, b + 1) ret /= i;\n\treturn ret;\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvi P(N), T(N), V(N);\n\trep(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n\tvvd per(N, vd(M+1, 0));\n\trep(i, 0, N)\n\t{\n\t\tdouble p = P[i] / 100.0;\n\t\tdouble pp = 1.0 - p;\n\t\trep(j, 0, M + 1) per[i][j] = calc(pow(pp, M - j) * pow(p, j), M, j);\n\t}\n\n\tvvd imos(N, vd(M + 2, 0));\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, M + 1) imos[i][j] = per[i][j];\n\t\trrep(j, M, 0) imos[i][j] += imos[i][j + 1];\n\t}\n\n\trep(i, 0, N)\n\t{\n\t\tdouble ans = 0;\n\t\trep(j, 0, M + 1)\n\t\t{\n\t\t\tdouble _ans = per[i][j];\n\t\t\tdouble deadline = (double)L / V[i] + (double)T[i] * j;\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tif (i == k) continue;\n\t\t\t\tdouble fastest = (double)L / V[k];\n\t\t\t\tif (deadline < fastest - EPS) continue;\n\n\t\t\t\tif (T[k] == 0)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint minrest = (deadline - fastest + T[k] - 1) / T[k];\n\t\t\t\tdouble test = fastest + T[k] * minrest;\n\t\t\t\tif (abs(deadline - test) < EPS) minrest++;\n\t\t\t\tif (M < minrest)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_ans *= imos[k][minrest];\n\t\t\t}\n\n\t\t\tans += _ans;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "//10\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nlong double fact(int x){\n  long double r=1;\n  while(x){\n    r*=x--;\n  }\n  return r;\n}\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  double ap[100][51],acp[100][52]={{}};\n  double at[100][51];\n  for(int i=0;i<n;i++){\n    double p,t,v;\n    cin>>p>>t>>v;\n    for(int j=0;j<=m;j++){\n      at[i][j]=l/v+t*j;\n      ap[i][j]=pow(p/100,j)*pow(1-p/100,m-j)*fact(m)/fact(j)/fact(m-j);\n      acp[i][j+1]=acp[i][j]+ap[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    double a=0;\n    for(int j=0;j<=m;j++){\n      double c=ap[i][j];\n      for(int k=0;k<n;k++){\n\tif(i!=k){\n\t  int x=lower_bound(at[k],at[k]+m+1,at[i][j]+1e-9)-at[k];\n\t  c*=1-acp[k][x];\n\t}\n      }\n      a+=c;\n    }\n    cout<<fixed<<a<<endl;\t  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M, L;\n\nvector<tuple<int, int, int>> vs;\n\ndouble P[111][111];\ndouble T[111][111];\n\nnamespace math { namespace combination {\n\n#define COMBINATION_MAX 200\nusing return_type = ll;\n\nnamespace memorized { namespace combination { enum { max_value = COMBINATION_MAX }; bool __computed = false; inline bool computed() {if(__computed) { return true; } else { __computed = true; return false; }} return_type dp[max_value][max_value];} }\n\nreturn_type comb(int N, int K) {\n  using memorized::combination::dp;\n  if(memorized::combination::computed()) { return dp[N][K]; }\n\n  rep(i, memorized::combination::max_value) {\n    dp[i][0] = 1;\n    REP(j, 1, i+1) {\n      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n//      dp[i][j] %= MOD;\n    }\n  }\n  return dp[N][K];\n}}}\n\nvoid solve() {\n  rep(i, N) {\n    rep(j, M+1) {\n      P[i][j] = pow(get<0>(vs[i]) * 0.01, j) * pow((100-get<0>(vs[i])) * 0.01, M - j) * math::combination::comb(M, j);\n      if(j) T[i][j] = T[i][j-1] + get<2>(vs[i]);\n      else T[i][0] = 1.0 * L / get<1>(vs[i]);\n    }\n  }\n\n  rep(i, N) {\n    double res = 0;\n\n    if(get<1>(vs[i]) == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    rep(j, M+1) {\n      double losers_prob = 1.0;\n      rep(k, N) {\n        if(i == k) continue;\n        double sum = 0.0;\n        rep(l, M+1) {\n          if(T[i][j] < T[k][l]) sum += P[k][l];\n        }\n        losers_prob *= sum;\n      }\n      res += losers_prob * P[i][j];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n\n  cin >> N >> M >> L;\n  rep(i, N) {\n    int p, t, v; cin >> p >> t >> v;\n    vs.push_back({p, v, t});\n  }\n\n  N = vs.size();\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, p[100], t[100], v[100];\ndouble dp[100][52], sum[100][52];\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\trep(i, n){\n\t\tdp[i][0] = 1;\n\t\trep(j, m) for(int k = m; k >= 0; k--){\n\t\t\tdp[i][k + 1] += dp[i][k] * p[i] / 100.0;\n\t\t\tdp[i][k] *= 1 - p[i] / 100.0;\n\t\t}\n\t\tsum[i][m] = dp[i][m];\n\t\tfor(int j = m - 1; j >= 0; j--) sum[i][j] = sum[i][j + 1] + dp[i][j];\n\t\t/*\n\t\trep(j, m + 1) cerr<<dp[i][j]<<(j==m?\"\\n\":\" \");\n\t\trep(j, m + 1) cerr<<sum[i][j]<<(j==m?\"\\n\":\" \");\n\t\t*/\n\t}\n\t\n\trep(i, n){\n\t\tdouble s = 0;\n\t\tif(v[i]) rep(j, m + 1){\n\t\t\tdouble e = dp[i][j];\n\t\t\trep(k, n) if(k != i){\n\t\t\t\tint tm = (int)ceil((l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j) / t[k] + EPS);\n\t\t\t\t\n\t\t\t\ttm = max(tm, 0);\n\t\t\t\tif(t[k] == 0) tm = l * 1.0 / v[i] - l * 1.0 / v[k] + t[i] * j < - EPS ? 0 : m + 1;\n\t\t\t\tif(v[k] == 0) tm = 0;\n\t\t\t\tif(tm <= m) e *= sum[k][tm];\n\t\t\t\telse e = 0;\n\t\t\t}\n\t\t\ts += e;\n\t\t}\n\t\tprintf(\"%.9f\\n\", s);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst double INF = 1e30;\n\ntypedef struct\n{\n  int P, T, V;\n  double goal;\n} Runner;\n\nint main()\n{\n  int N, M, L;\n  while (~scanf(\"%d %d %d\", &N, &M, &L)) {\n    vector<Runner> r(N);\n    for (int i = 0; i < N; ++i) {\n      scanf(\"%d %d %d\", &r[i].P, &r[i].T, &r[i].V);\n      if (r[i].V == 0)\n\tr[i].goal = INF;\n      else\n\tr[i].goal = L / static_cast<double>(r[i].V);\n    }\n\n    vector<vector<double> > p(N, vector<double>(M+1, 1.0));\n    for (int i = 0; i < N; ++i) {\n      vector<vector<double> > dp(M+1, vector<double>(M+1, 0.0));\n      dp[0][0] = 1.0;\n      for (int j = 0; j < M; ++j) {\n\tfor (int k = 0; k < M; ++k) {\n\t  dp[j+1][k]   += dp[j][k] * ((100 - r[i].P) / 100.0);\n\t  dp[j+1][k+1] += dp[j][k] * (r[i].P / 100.0);\n\t}\n      }\n      for (int j = 0; j < M+1; ++j)\n\tp[i][j] = dp[M][j];\n    }\n\n    vector<vector<double> > pp(N, vector<double>(M+1));\n    for (int i = 0; i < N; ++i) {\n      for (int j = M; j >= 0; --j) {\n\tpp[i][j] = p[i][j];\n\tif (j != M)\n\t  pp[i][j] += pp[i][j+1];\n      }\n    }\n\n    vector<double> ans(N, 0.0);\n    for (int i = 0; i < N; ++i) {\n      if (r[i].goal == INF)\n\tcontinue;\n\n      for (int j = 0; j < M+1; ++j) {\n\tdouble m_ans = p[i][j];\n\tdouble time = r[i].goal + r[i].T * j;\n\tfor (int k = 0; k < N; ++k) {\n\t  if (i == k)\n\t    continue;\n\t  if (time - r[k].goal >= 0.0) {\n\t    int rest = static_cast<int>((time - r[k].goal) / static_cast<double>(r[k].T)) + 1;\n\t    if (rest > M || r[k].T == 0) {\n\t      m_ans = 0.0;\n\t      break;\n\t    }\n\t    m_ans *= pp[k][rest];\n\t  }\n\t}\n\tans[i] += m_ans;\n      }\n    }\n\n    for (int i = 0; i < N; ++i)\n      printf(\"%.8f\\n\", ans[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstruct Runner{\n  int p,t,v;\n  Runner(int _p,int _t,int _v):p(_p),v(_v),t(_t){\n\n  }\n  Runner(){}\n};\n\ndouble RepeatedPow(double base, int64_t exponent) {\n  if (exponent == 0)\n    return 1;\n  else if (exponent % 2 == 0) {\n    double root = RepeatedPow(base, exponent / 2);\n    return (root * root);\n  } else {\n    return (base * RepeatedPow(base, exponent - 1));\n  }\n}\n\nint64_t ncr[101][101]={};\n\ndouble probability(int m,int p, int a){\n  double result=1;\n  result*=ncr[m][a];\n  result*=pow(p/(double)100,a);\n  result*=pow((1-p/(double)100),m-a);\n  return result;\n}\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  int n,m,l;\n  cin>>n>>m>>l;\n\n\n\n  for(int i=0;i<=100;i++){\n    for(int j=0;j<=i;j++){\n      if(j==0||j==i){\n        ncr[i][j]=1;\n      }else{\n        ncr[i][j]=ncr[i-1][j-1]+ncr[i-1][j];\n      }\n    }\n  }\n\n  std::vector<Runner> runner(n);\n  for(int i=0;i<n;i++){\n    int p, t, v;\n    cin >> p >> t >> v;\n    runner[i]=Runner(p,t,v);\n  }\n\n  for(int i=0;i<n;i++){\n    double result=0;\n    for(int a=0;a<=m;a++){\n      double term=probability(m,runner[i].p,a);\n      double i_time=(double)l/runner[i].v+a*runner[i].t;\n      for(int b=0;b<n;b++){\n        if(i==b) continue;\n        double win_rate=0;\n        for(int c=m;c>=0;c--){\n          double probability_b=probability(m,runner[b].p,c);\n          double b_time=(double)l/runner[b].v+c*runner[b].t;\n          if(i_time<b_time){\n            win_rate+=probability_b;\n          }else{\n            break;\n          }\n        }\n        term*=win_rate;\n      }\n      result+=term;\n    }\n    cout<<result<<endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n      for(int j=0;j<T;j++){\n\tif(!dp[i][m%2][j])continue;\n\tdouble x=dp[i][m%2][j];\n\tdouble s=j+1.0*l/v[i];\n\tfor(int k=0;k<n;k++){\n\t  if(i==k||!v[k])continue;\n\t  int idx=(int)(s-1.0*l/v[k]);\n\t  if(s-1.0*l/v[k]<0)idx=0;\n\t  else idx++;\n\t  if(T<=idx){\n\t    x=0;\n\t    break;\n\t  }\n\t  x*=sum[k][idx];\n\t}\n\tans+=x;\n      }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][M][T],sum[N][T];\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++) cin>>p[i]>>t[i]>>v[i];\n\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++)\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j][k])continue;\n\tdp[i][j+1][k]+=dp[i][j][k]*(100.0-p[i])/100.0;\n\tdp[i][j+1][k+t[i]]+=dp[i][j][k]*p[i]/100.0;\n      }\n  }\n\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--) sum[i][j]=sum[i][j+1]+dp[i][m][j];\n\n  for(int i=0;i<n;i++){\n    double ans=0;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m][j])continue;\n      double x=dp[i][m][j];\n      double s=j+1.0*l/v[i];\n\n      for(int k=0;k<n;k++){\n\tif(i==k)continue;\n\tint idx=max(0,(int)(s-1.0*l/v[k])+1);\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\nconst double eps=1e-7;\nconst int maxn=110;\nconst int maxm=110;\ndouble lin[maxm][maxm],tmp[maxm][maxm],c[maxm][maxm],ans[maxm],p[maxm],v[maxm],t[maxm];\nint main()\n{\n\tfor(int i=0;i<maxm;i++)\n\t{\n\t\tc[i][0]=c[i][i]=1;\n\t\tfor(int j=1;j<i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1];\n\t}\n\tint n,m;\n\tdouble l;\n\twhile(scanf(\"%d%d%lf\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(int i=0;i<n;i++) scanf(\"%lf%lf%lf\",&p[i],&t[i],&v[i]);\n\t\tfor(int i=0;i<n;i++) p[i]/=100;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\ttmp[i][j]=l/v[i]+j*t[i];\n\t\t\t\tlin[i][j]=pow(p[i],j)*pow((1-p[i]),m-j)*c[m][j];\n\t\t\t}\n\t\t\tfor(int j=m-1;j>=0;j--) lin[i][j]+=lin[i][j+1];\n\t\t\t//for(int j=0;j<=m;j++) printf(\"%f \",lin[i][j]);\n\t\t\t//printf(\"\\n\");\n\t\t\tlin[i][m+1]=0;\t\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int k=0;k<=m;k++) ans[k]=pow(p[i],k)*pow((1-p[i]),m-k)*c[m][k];\n\t\t\tfor(int j=0;j<n;j++) \n\t\t\t\tif(j!=i)\n\t\t\t\t{\n\t\t\t\t\tint q=m;\n\t\t\t\t\tfor(int p=m;p>=0;p--)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile(q>=0 && tmp[i][q]>=tmp[j][p]-eps) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans[q]*=lin[j][p+1];\n\t\t\t\t\t\t\tq--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(q==-1) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdouble sum=0;\n\t\t\tfor(int k=0;k<=m;k++) sum+=ans[k];\n\t\t\tprintf(\"%.9f\\n\",sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>d[i],p[i]/=100,d[i]=l/d[i];\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j?????????????¢???????\n    A[i]=B[i]=vector<double>(m+1,0);\n    A[i][0]=B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]);\n      B[i][j]=B[i][j-1]*p[i];\n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N, M, L;\nvector<double> P, T, V;\n\ndouble t[101][51]; // ??°???i???j????????????????????´???????????§?????????\n\ndouble dp[101][51][51]; // ??°???i????????????j?????§???k??????????¢????\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M >> L;\n  P.resize(N); T.resize(N); V.resize(N);\n  rep(i, N) cin >> P[i] >> T[i] >> V[i], P[i] /= 100;\n\n  rep(i, N) rep(j, M+1) {\n    if(V[i]) t[i][j] = L/V[i] + j*T[i];\n    else t[i][j] = 1e9;\n  }\n\n  rep(i, N) dp[i][0][0] = 1;\n  rep(i, N) rep(j, M) rep(k, j+1) {\n    dp[i][j+1][k+1] += dp[i][j][k] * P[i];\n    dp[i][j+1][k] += dp[i][j][k] * (1 - P[i]);\n  }\n\n  rep(i, N) {\n    double ans = 0;\n    rep(j, M+1) {\n      double p = dp[i][M][j];\n      rep(k, N) if(i != k) {\n\tdouble q = 0;\n\trep(l, M+1) if(t[i][j] < t[k][l]) {\n\t  q += dp[k][M][l];\n\t}\n\tp *= q;\n      }\n      ans += p;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\ndouble dfact(const int a) {\n\tassert(a >= 0);\n\tif (a == 0)return 1;\n\treturn a*dfact(a - 1);\n}\ndouble dcomb(const int a, const int b) {\n\treturn (dfact(a) / dfact(b)) / dfact(a-b);\n}\ndouble eps = 1e-9;\n\nint main() {\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<map<double, double>>mps,ruisekimps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tdouble P,T,V; cin >> P >> T >> V;\n\t\tP /= 100;\n\t\tmap<double, double>mp;\n\t\tif (T < eps) {\n\t\t\tmp[L / V] = 1;\n\t\t}\n\t\telse {\n\t\t\tfor (int rest = 0; rest <= M; ++rest) {\n\t\t\t\tmp[L / V + T*rest] = pow(P, rest)*pow(1 - P, M - rest)*dcomb(M, rest);\n\t\t\t}\n\t\t}\n\t\t\n\t\tmps.push_back(mp);\n\t}\n\tfor (int rn = 0; rn < N; ++rn) {\n\t\tmap<double, double>mp;\n\t\tdouble nowprob = 0;\n\t\tmp[0] = 0;\n\t\t\n\t\tfor (auto prob : mps[rn]) {\n\t\t\tnowprob += prob.second;\n\t\t\tmp[prob.first] = nowprob;\n\t\t}\n\t\tmp[1e18] = 1;\n\t\truisekimps.push_back(mp);\n\t}\n\tfor (int rn = 0; rn < N; ++rn) {\n\t\tdouble ans = 0;\n\t\tfor(auto i:mps[rn]){\n\t\t\tdouble atime = i.first;\n\t\t\tdouble prob = i.second;\n\t\t\tfor (int ob = 0; ob < N; ++ob) {\n\t\t\t\tif (rn == ob)continue;\n\t\t\t\t\n\t\t\t\tauto it(ruisekimps[ob].lower_bound(atime + eps));\n\t\t\t\tprob *= (1-prev(it)->second);\n\t\t\t}\n\t\t\tans += prob;\n\t\t}\n\t\tcout <<setprecision(22)<<fixed<< ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] == 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k] - 5;\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\nint n, m, l;\nint t[111], v[111];\ndouble p[111];\nbool comp(pint a, pint b)\n{\n    int i = a.first, j = b.first;\n    int ra = a.second, rb = b.second;\n\n    int x = v[j] * (v[i] * ra * t[i] + l);\n    int y = v[i] * (v[j] * rb * t[j] + l);\n    return x > y;\n}\nint main()\n{\n    cin >> n >> m >> l;\n    rep(i, n)\n        cin >> p[i] >> t[i] >> v[i], p[i] /= 100;\n\n    vector<pint> time; // (index, rest)\n    rep(i, n) erep(j, m)\n        time.pb(pint(i, j));\n    sort(all(time), comp);\n    int rank[111][55]; // (index, rest) -> rank\n    rep(i, time.size())\n        rank[time[i].first][time[i].second] = i;\n    \n    double c[111][111];\n    CL(c, 0);\n    erep(i, m)\n    {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n    }\n\n    double run_p[111][55]; // (index, rest) -> prob\n    double sum[111][111 * 55]; // (index, rank) -> [0, rank)sum prob\n    CL(sum, 0);\n    rep(i, n)\n    {\n        double pp[55], np[55];\n        pp[0] = np[0] = 1;\n        rep(j, m)\n        {\n            pp[j + 1] = pp[j] * p[i];\n            np[j + 1] = np[j] * (1 - p[i]);\n        }\n\n        erep(j, m)\n            run_p[i][j] = c[m][j] * pp[j] * np[m - j];\n\n        erep(j, m)\n            sum[i][rank[i][j] + 1] = run_p[i][j];\n        rep(j, time.size())\n            sum[i][j + 1] += sum[i][j];\n    }\n\n    rep(i, n)\n    {\n        double res = 0;\n        erep(j, m)\n        {\n            int k = lower_bound(all(time), pint(i, j), comp) - time.begin();\n\n            double win_p = 1;\n            rep(w, n)\n                if (w != i)\n                    win_p *= sum[w][k];\n\n            res += run_p[i][j] * win_p;\n        }\n        printf(\"%.10f\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 110;\nconst double eps = 1e-12;\n\ndouble pro[MAXN][55][55];\ndouble speed[MAXN], rest[MAXN], p[MAXN];\ndouble to[MAXN][55];\ndouble dis;\nint n, m;\n\nvoid read()\n{\n    for(int i = 0; i < n; ++i)\n    {\n        scanf(\"%lf%lf%lf\", p + i, rest + i, speed + i);\n        p[i] *= 0.01;\n    }\n\n    memset(pro, 0, sizeof(pro));\n    for(int i = 0; i < n; ++i)\n    {\n        pro[i][0][0] = 1.0;\n        for(int j = 1; j <= m; ++j)\n        {\n            pro[i][j][0] = pro[i][j - 1][0] * (1 - p[i]);\n            for(int k = 1; k <= j; ++k)\n                pro[i][j][k] = pro[i][j -  1][k] * (1 - p[i]) + pro[i][j - 1][k - 1] * p[i];\n        }\n    }\n\n    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j <= m; ++j)\n            to[i][j] = dis / speed[i] + j * rest[i];\n    }\n}\ndouble ans[MAXN];\nint main()\n{\n    while(scanf(\"%d%d%lf\", &n, &m, &dis) != EOF)\n    {\n        read();\n        for(int i = 0; i < n; ++i)\n        {\n            ans[i] = 0.0;\n            for(int j = 0; j <= m; ++j)\n            {\n                double hh(pro[i][m][j]);\n                for(int k = 0; k < n; ++k)\n                {\n                    if(k == i)  continue;\n                    double tmp = 1.0;\n                    for(int u = 0; u <= m; ++u)\n                    {\n                        if(to[k][u] > to[i][j] + eps)  break;\n                        tmp -= pro[k][m][u];\n                    }\n                    hh *= tmp;\n                }\n                ans[i] += hh;\n            }\n        }\n        for(int i = 0; i < n; ++i)\n            printf(\"%lf\\n\", ans[i]);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define eps (1e-8)\n\nint N,M;\ndouble L;\ndouble P[100],T[100],V[100];\ndouble a[100][100],b[100][100];\n\ndouble mem[100][100];\ndouble ncr(int n,int r){\n  if(mem[n][r]!=-1.0)return mem[n][r];\n  r=min(r,n-r);\n  double res=1.0;\n  for(int i=0;i<r;i++){\n    res=res*(double)(n-i);\n    res=res/(double)(i+1);\n  }\n  return mem[n][r]=res;\n}\n\ndouble solve(int x){\n  if(V[x]<eps)return 0;\n  \n  double res=0;\n  for(int i=0;i<=M;i++){\n    double p=a[x][i];\n    double d=b[x][i];\n    for(int j=0;j<N;j++){\n      if(x==j)continue;\n      if(V[j]<eps){\n        continue;\n      }\n      double sum=0;\n      for(int k=0;k<=M;k++){\n        if(b[j][k]<d+eps)continue;\n        sum+=a[j][k];\n      }\n      p*=sum;\n    }\n    res+=p;\n  }\n  return res;\n}\n\nint main(){\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      mem[i][j]=-1.0;\n  \n  cin>>N>>M>>L;\n  for(int i=0;i<N;i++){\n    cin>>P[i]>>T[i]>>V[i];\n    if(V[i]<eps)continue;\n\n    double p=P[i]/100.0;\n    double q=1.0-p;\n    for(int j=0;j<=M;j++){\n      a[i][j]=ncr(M,j)*pow(p,j)*pow(q,M-j);\n      b[i][j]=L/V[i]+T[i]*j;\n      //cout<<a[i][j]<<' '<<b[i][j]<<endl;\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<N;i++){\n    printf(\"%.10f\\n\",solve(i));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? 0 : pow(1-p[i],j));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? 0 : pow(p[i],j));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                ld z=0;\n                for(int y=0;y<=m;y++){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]<l*v[i]+y*t[j]*v[i]*v[j]){\n                        z+=pos[j][y];\n                    }\n                }\n                sc*=z;\n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\tif(p[i] != 1) rep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] != 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing graph = vector<vector<int>>;\nusing wgraph = vector<vector<pair<int, long long int>>>;\nlong long int INF = 1001001001001001LL;\nint inf = 100100100;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = 1; i <= (n); i++)\n#define drep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define srep(i,s,t) for(int i = s; i < t; i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\ndouble comb(int n, int r) {\n  double ue = 1;\n  double sita = 1;\n  for(int i = 0; i < r; i++) ue *= (n - i);\n  for(int i = r; i >= 1; i--) sita *= i;\n  return ue / sita;\n}\n\nint main(){\n  \n  double l;\n  int n, m; cin >> n >> m >> l;\n    \n  vector<double> p(n);\n  vector<double> t(n);\n  vector<double> v(n);\n  \n  for(int i = 0; i < n; i++) cin >> p[i] >> t[i] >> v[i];\n\n  vector<vector<double>> g(n, vector<double> (m + 1, 0.0));\n\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j <= m; j++) {\n      // i 番目の人が, j 回休む確率\n      double val = pow(p[i] / (double)100, j) * pow(1 - p[i] / (double)100, m - j) * comb(m, j);\n      g[i][j] = val;\n\n    }\n  }\n\n  for(int i = 0; i < n; i++) {\n    // i 番目の人が勝つ確率\n    double ans = 0.0;\n\n    for(int j = 0; j <= m; j++) {\n      // i 番目の人が, j 回休んだ時\n      // i 番目の人は it でゴールする\n      double mul = 1.0;\n      double it = l / v[i] + t[i] * j;\n\n      // 全員に勝たなきゃいけない\n      for(int k = 0; k < n; k++) {\n        if(i == k) continue;\n        double add = 0.0;\n        for(int ll = 0;ll <= m; ll++) {\n          // k 番目の人は ll 回休む\n          // 勝てるなら\n          double kt = l / v[k] + t[k] * ll;\n          if(it < kt){\n            add += g[k][ll];\n          }\n        }\n\n        mul *= add;\n      }\n\n      ans += mul * g[i][j];\n    }\n\n    printf(\"%.10f\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\nconst int MAX_M = 51;\n\nll comb[MAX_M][MAX_M];\ndouble p[MAX_N];\nint t[MAX_N],v[MAX_N];\ndouble bp[MAX_N][MAX_M];\ndouble prt[MAX_N];\ndouble ans[MAX_N];\n\nint main()\n{\n    int n,m,L;\n\tcin >> n >> m >> L;\n\trep(i,n){\n        cin >> p[i] >> t[i] >> v[i];\n        p[i] /= 100.0;\n\t}\n    comb[0][0] = 1;\n    for(int i = 1;i<=m;i++){\n        comb[i][0] = 1;\n        for(int j=1;j<=i;j++){\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n        }\n    }\n    rep(i,n){\n        prt[i] = (double)L / v[i];\n    }\n    rep(i,n){\n        rep(j,m+1){\n            bp[i][j] = 1.0;\n            bp[i][j] *= comb[m][j];\n            rep(k,j){\n                bp[i][j] *= p[i];\n            }\n            rep(k,m-j){\n                bp[i][j] *= (1.0 - p[i]);\n            }\n        }\n    }\n    rep(i,n){\n        bool flag = false;\n        ans[i] = 0.0;\n        rep(j,m+1){\n            double tm = bp[i][j];\n            rep(k,n){\n                double sm = 0.0;\n                if(k != i){\n                    if(prt[i] + j*t[i] >= prt[k]){\n                        if(t[k] == 0){\n                            flag = true;\n                            break;\n                        }\n                        int c = (int)((prt[i] + j*t[i] - prt[k] + EPS) / t[k]) + 1;\n                        if(c > m){\n                            flag = true;\n                            break;\n                        }\n                        for(int l=c;l<=m;l++){\n                            sm += bp[k][l];\n                        }\n                    }else{\n                        sm = 1.0;\n                    }\n                    tm *= sm;\n                }\n            }\n            if(flag){\n                break;\n            }\n            ans[i] += tm;\n        }\n        printf(\"%.10lf\\n\",ans[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\t  if(N==1){\n\t\t\tcout << 1.0 << endl;\n\t\t\treturn 0;\n\t  }\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  if(p[i] != 100)\n\t\t\t\t\t\tprob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n\t\t\t\t  else\n\t\t\t\t\t\tprob[i][j] = 1.0;\n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t\t  if(sum[i][j] > 1) sum[i][j] = 1;\n\t\t\t}\n\t  }\n\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t   ans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tif(p[i] == 100) tmp = ans[i][M];\n\t\t\telse\n\t\t\t\t  for(int j=0; j<=M; j++)\n\t\t\t\t\t\ttmp += ans[i][j];\n\t\t\tif(tmp > 1) tmp = 0;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int n, m, l;\n    cin >> n >> m >> l;\n    using P = pair<double, double>;\n    vector<vector<P>> v(n, vector<P>(m+1, {0,0}));\n    for (int i = 0; i < n; ++i) {\n        double p, t, k;\n        cin >> p >> t >> k;\n        p /= 100; k = l/k;\n        vector<vector<double>> dp(m+1, vector<double>(m+1, 0));\n        dp[0][0] = 1.0;\n        for (int j = 0; j < m; ++j) {\n            for (int jj = 0; jj <= j; ++jj) {\n                dp[j+1][jj] += dp[j][jj]*(1-p);\n                dp[j+1][jj+1] += dp[j][jj]*p;\n            }\n        }\n        for (int j = 0; j <= m; ++j) {\n            v[i][m-j] = make_pair(-k-t*j, dp[m][j]);\n        }\n        for (int j = 0; j <= m; ++j) {\n            if(j) v[i][j].second += v[i][j-1].second;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        double ans = 0;\n        for (int j = 0; j <= m; ++j) {\n            double x = v[i][j].second;\n            if(j) x -= v[i][j-1].second;\n            for (int k = 0; k < n; ++k) {\n                if(i == k) continue;\n                auto cur = lower_bound(v[k].begin(),v[k].end(), make_pair(v[i][j].first, 0.0));\n                if(cur == v[k].begin()) x *= 0;\n                else {\n                    cur--;\n                    x *= cur->second;\n                }\n            }\n            ans += x;\n        }\n        printf(\"%.10lf\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\nstruct node\n{\n    double p,t,v;\n}nd[105];\nint n,m,L;\ndouble dp[105][55][55];\nint main()\n{\n    //freopen(\"D.in\", \"r\", stdin);\n    //freopen(\"D.out3\", \"w\", stdout);\n    \n    while(~scanf(\"%d%d%d\",&n,&m,&L))\n    {\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%lf%lf%lf\",&nd[i].p,&nd[i].t,&nd[i].v);\n            nd[i].p/=100.0;\n        }\n        for(int i=0;i<n;i++)\n        {\n            dp[i][0][0]=1;\n            for(int j=1;j<=m;j++)\n                for(int k=0;k<=j;k++)\n                {\n                    if(k>0)\n                        dp[i][j][k]=dp[i][j-1][k]*(1-nd[i].p)+dp[i][j-1][k-1]*nd[i].p;\n                    else dp[i][j][k]=dp[i][j-1][k]*(1-nd[i].p);\n                }\n        }\n        /*for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<=m;j++)\n            {\n                for(int k=0;k<=m;k++)\n                    printf(\"%.6f \",dp[i][j][k]);\n                puts(\"\");\n            }\n            puts(\"\");\n        }\n         */\n        for(int i=0;i<n;i++)\n        {\n            double ans=0;\n            for(int j=0;j<=m;j++)\n            {\n                double ans1=dp[i][m][j],t=L/(nd[i].v)+j*nd[i].t;\n                for(int ii=0;ii<n;ii++)\n                {\n                    if(ii==i)continue;\n                    double tem=0,tt=L/nd[ii].v;\n                    for(int jj=0;jj<=m;jj++)\n                    {\n                        if(tt+jj*(nd[ii].t)>t)\n                            break;\n                        tem+=dp[ii][m][jj];\n                    }\n                    ans1*=(1.0-tem);\n                }\n                ans+=ans1;\n            }\n            printf(\"%.8f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  int P[N], T[N], V[N];\n  for(int i = 0; i < N; ++i){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n  double prob[N][M+1];\n\n  for(int i = 0; i < N; ++i) prob[i][0] = 1.0;\n  for(int i = 0; i < N; ++i){\n\n    for(int j = 1; j <= M; ++j){\n      prob[i][j] = prob[i][j-1]*P[i]/100.0*(M-j+1)/j;\n    }\n    double t = 1.0;\n    for(int j = M; j >= 0; --j){\n      prob[i][j] *= t;\n      t *= (1.0 - (double)P[i]/100.0);\n    }\n  }\n  double acum[N][M+2];\n  for(int i = 0; i < N; ++i) acum[i][M+1] = 0;\n  for(int i = 0; i < N; ++i){\n    for(int j = M; j >= 0; --j){\n      acum[i][j] = acum[i][j+1] + prob[i][j];\n    }\n  }\n  vector< vector<double> > time(N,vector<double>(M+1));\n  for(int i = 0; i < N; ++i) time[i][0] = (double)L/V[i];\n  for(int i = 0; i < N; ++i){\n    for(int j = 1; j <= M; ++j){\n      time[i][j] = time[i][j-1] + T[i];\n    }\n  }\n  for(int i = 0; i < N; ++i){\n    double ans = 0.0;\n    for(int j = M; j >= 0; --j){\n      double t = prob[i][j];\n      for(int k = 0; k < N; ++k){\n        if(k == i) continue;\n        int id = upper_bound(time[k].begin(),time[k].end(),time[i][j]) - time[k].begin();\n        if(id > M){\n          t = 0;\n          break;\n        }\n        t *= acum[k][id];\n      }\n      ans += t;\n    }\n    printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nint P[100], T[100], V[100];\ndouble dp[101][52];\ndouble tim[101][52];\ndouble small[52][52];\n\nint main()\n{\n  cin >> N >> M >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> P[i] >> T[i] >> V[i];\n  }\n\n  \n  for(int i = 0; i < N; i++) {\n    memset(small, 0, sizeof(small));\n    small[0][0] = 1.0;\n    for(int j = 0; j < M; j++) {\n      for(int k = 0; k <= j; k++) {\n        small[j + 1][k + 1] += small[j][k] / 100.0 * P[i];\n        small[j + 1][k]     += small[j][k] / 100.0 * (100 - P[i]);\n      }\n    }\n    for(int j = 0; j <= M; j++) {\n      tim[i][j] = (V[i] == 0 ? 1e18 : 1.0 * L / V[i] + j * T[i]);\n      dp[i][j] = small[M][j];\n    }\n  }\n  cout << fixed << setprecision(10);\n  \n  for(int i = 0; i < N; i++) {\n    double ret = 0;\n    for(int j = 0; j <= M; j++) {\n      double per = dp[i][j];\n      for(int k = 0; k < N; k++) {\n        if(i == k) continue;\n        double qur = 0.0;\n        for(int l = 0; l <= M; l++) {\n          if(tim[i][j] < tim[k][l]) qur += dp[k][l];\n        }\n        per *= qur;\n      }\n      ret += per;\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL maxn = 111;\nLL v[maxn], t[maxn];\nLL c[maxn][maxn];\n\ndouble p[maxn];\ndouble lv[maxn];\nLL n, m, l;\n\ndouble ff (LL u, LL state, LL v) {\n\tdouble ret = 0;\n\tfor (LL i = 0; i <= m; ++i) {\n\t\tif (lv[v] + i * t[v] > lv[u] + state * t[u]) {\n\t\t\tret += 1.0 * c[i][m] * pow (1.0 * p[v], 1.0*i) * pow (1.0 - p[v], 1.0*m - i);\n\t\t}\n\t}\n\treturn ret;\n}\ndouble f (LL u, LL state) {\n\tdouble ret = 1.0 * c[state][m] * pow (1.0 * p[u], 1.0 * state) * pow (1.0 - p[u], 1.0 * m - state);\n\tfor (LL i = 0; i < n; ++i) {\n\t\tif (i == u) continue;\n\t\tret *= ff (u, state, i);\n\t}\n\treturn ret;\n}\ndouble solve (LL u) {\n\tdouble ret = 0;\n\tfor (LL i = 0; i <= m; ++i) {\n\t\tret += f (u, i);\n\t}\n\treturn ret;\n}\n\n//快速求&#32452;合数 c(m, n)\nLL combination(LL m, LL n) {\n\tLL i, a, b, p;\n\tif (n < m) n ^= m ^= n ^= m;\n\tp = 1;\n\ta = n - m < m ? n-m : m;\n\tb = n - m > m ? n-m : m;\n\tfor (i = 1; i <= a; ++i) p += p * b / i;\n\treturn p;\n}\n\nint main () {\n\tLL i;\n\twhile (~scanf (\"%lld%lld%lld\", &n, &m, &l)) {\n\t\t//生成所有c[i][m]的&#32452;合数\n\t\tfor (i = 0; i <= (m >> 1); ++i) {\n\t\t\tc[i][m] = c[m-i][m] = combination (i, m);\n\t\t}\n\t\t/*for (i = 0; i <= m; ++i) {\n\t\t\tprintf (\"c[%lld][%lld] = %lld\\n\", i, m, c[i][m]);\n\t\t}*/\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tscanf (\"%lf%lld%lld\", &p[i], &t[i], &v[i]);\n\t\t\tlv[i] = 1.0 * l / v[i];\n\t\t\tp[i] /= 100;\n\t\t}\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tdouble ans = solve (i);\n\t\t\tprintf (\"%.8lf\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n#define LL long long\ndouble p[200];\nint t[200];\nint v[200];\nLL C[100][100];\ndouble dp[105][55];\n\nint main(){\n    int n,m,l;\n    cin >>  n >> m >> l;\n    for(int i = 0;i < n;i++){\n        int x,tt,vv;\n        scanf(\"%d%d%d\",&x,&tt,&vv);\n        p[i] = x / 100.0,t[i] = tt,v[i] = vv;\n    }\n\n    for(int i = 0;i <= 50;i++){\n        C[i][0] = 1;\n        C[i][i] = 1;\n        for(int j = 1;j < i;j++){\n            C[i][j] = C[i-1][j]+C[i-1][j-1];\n            //cout<<C[i][j] << endl;\n        }\n    }\n    for(int i = 0;i < n;i++){\n        dp[i][m+1] = 0;\n        for(int j = m;j >= 0;j--){ //休息>j次\n            dp[i][j] = dp[i][j+1] + C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n            //cout << dp[i][j] << endl;\n        }\n    }\n\n    for(int i = 0;i < n;i++){\n        double ans = 0;\n        if(v[i] != 0){\n            for(int j = 0;j <= m;j++){\n                double ut = l*1.0/v[i] + j*t[i];\n                double pa = C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n                for(int k = 0;k < n;k++){//?k个人的概率\n                    if(k != i){\n                        if(v[k] == 0){\n                            pa *= 1;\n                            continue;\n                        }\n                        int tim;\n                        if(t[k] == 0){\n                            if(l*1.0/v[k] <= ut){\n                                pa *= 0;\n                            }\n                            else{\n                                pa *= 1;\n                            }\n                            continue;\n                        }\n                        tim = floor((ut-(l*1.0/v[k]))/t[k]);\n                        while((tim*t[k]+l*1.0/v[k]) <= ut) tim++;\n                        if(tim > m){\n                            pa *= 0;\n                        }\n                        else if(tim < 0){\n                            pa *= 1;\n                        }else{\n                            pa *= dp[k][tim];\n                        }\n\n                    }\n                }\n                //printf(\"%lf\\n\",pa);\n                ans += pa;\n            }\n        }\n        printf(\"%.8f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 誤差ゲー\n#include<iostream>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\ntypedef long double ld;\nconst ld EPS = 1e-10;\n\nld comb[100][51][51] = {};\n\nint main(){\n    int n, m, l;\n    cin >> n >> m >> l;\n    vector<ld> p(n), t(n), v(n);\n    for(int i = 0; i < n; i++)  cin >> p[i] >> t[i] >> v[i], p[i]/=100.0;\n    for(int i = 0; i < n; i++){\n        comb[i][0][0] = 1;\n        for(int j = 1; j <= m; j++){\n            for(int k = 0; k <= j; k++){\n                comb[i][j][k] = (k>0 ? comb[i][j-1][k-1] : 0)*p[i]+comb[i][j-1][k]*(1-p[i]);\n            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(v[i] == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        ld ans = 0;\n        for(int j = 0; j <= m; j++){\n            ld me = l/v[i]+t[i]*j;\n            ld add = comb[i][m][j];\n            for(int k = 0; k < n; k++){\n                if(i == k || v[k] == 0)  continue;\n                ld oppo = l/v[k]+t[k]*m;\n                ld tim = 0;\n                int now = m;\n                while(now>=0 && oppo-me > EPS){\n                    tim += comb[k][m][now--], oppo -= t[k];\n                }\n                add *= tim;\n            }\n            ans += add;\n        }\n        cout << fixed << setprecision(12) << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble P[100], T[100], V[100];\ndouble ncr[55][55];\nint main(){\n\tncr[0][0] = 1.0;\n\tfor(int i = 0 ; i < 50 ; i++)\n\t\tfor(int j = 0 ; j < 50 ; j++)\n\t\t\tncr[i+1][j] += ncr[i][j],\n\t\t\tncr[i+1][j+1] += ncr[i][j];\n\t\n\tint N,M,L;\n\tcin >> N >> M >> L;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tcin >> P[i] >> T[i] >> V[i];\n\t\tP[i] /= 100.0;\n\t\t//P[i] = 1 - P[i];\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t\tdouble sum2 = 0;\n\t\tfor(int l = 0 ; l <= M ; l++){\n\t\t\tdouble myTime = L / V[i] + l * T[i];\n\t\t\tdouble prob1 = ncr[M][l] * pow(P[i],l) * pow(1-P[i],M-l);\n\t\t\t//cout << i << \" \" << l << \" \" << prob1 << endl;\n\t\t\tdouble OKProb = 1.0;\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tif( i == j ) continue;\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int k = 0 ; k <= M ; k++){\n\t\t\t\t\tdouble time = L / V[j] + k * T[j];\n\t\t\t\t\tdouble prob2 = ncr[M][k] * pow(P[j],k) * pow(1-P[j],M-k);\n\t\t\t\t\tif( time > myTime + 1e-10 ){\n\t\t\t\t\t\tsum += prob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOKProb *= sum;\n\t\t\t}\n\t\t\tsum2 += OKProb * prob1;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",sum2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M, L;\n\nvector<tuple<int, int, int>> vs;\n\ndouble P[111][111];\ndouble T[111][111];\n\nnamespace math { namespace combination {\n\n#define COMBINATION_MAX 200\n//using return_type = ll;\n#define return_type ll\n\nnamespace memorized { namespace combination { enum { max_value = COMBINATION_MAX }; bool __computed = false; inline bool computed() {if(__computed) { return true; } else { __computed = true; return false; }} return_type dp[max_value][max_value];} }\n\nreturn_type comb(int N, int K) {\n  using memorized::combination::dp;\n  if(memorized::combination::computed()) { return dp[N][K]; }\n\n  rep(i, memorized::combination::max_value) {\n    dp[i][0] = 1;\n    REP(j, 1, i+1) {\n      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n//      dp[i][j] %= MOD;\n    }\n  }\n  return dp[N][K];\n}}}\n\nvoid solve() {\n  rep(i, N) {\n    rep(j, M+1) {\n      P[i][j] = pow(get<0>(vs[i]) * 0.01, j) * pow((100-get<0>(vs[i])) * 0.01, M - j) * math::combination::comb(M, j);\n      if(j) T[i][j] = T[i][j-1] + get<2>(vs[i]);\n      else T[i][0] = 1.0 * L / get<1>(vs[i]);\n    }\n  }\n\n  rep(i, N) {\n    double res = 0;\n\n    if(get<1>(vs[i]) == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    rep(j, M+1) {\n      double losers_prob = 1.0;\n      rep(k, N) {\n        if(i == k) continue;\n        double sum = 0.0;\n        rep(l, M+1) {\n          if(T[i][j] < T[k][l]) sum += P[k][l];\n        }\n        losers_prob *= sum;\n      }\n      res += losers_prob * P[i][j];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n\n  cin >> N >> M >> L;\n  rep(i, N) {\n    int p, t, v; cin >> p >> t >> v;\n    vs.push_back({p, v, t});\n  }\n\n  N = vs.size();\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <map>\n#include <iostream>\n#include <set>\n#include <queue>\n#define zero(x) (((x)>0?(x):-(x))<eps)\n#define mem(a,b) memset((a),(b),sizeof((a)))\n#define lld long long\n#define INF 0x3f3f3f3f\n#define eps 1e-11\n#define MAX 20010\n\n#define MAXV 20100\n#define MAXE 1000010\n#define EQ(x, y) (fabs((x) - (y)) < eps)\n\nusing namespace std;\n\nint n, m;\ndouble l;\ndouble p[109], t[109], v[109];\ndouble c[59][59];\ndouble num[109][59];\n\ndouble fast_pow(double a, int b) {\n    double ret = 1;\n    while(b) {\n        if(b & 1) ret *= a;\n        a = a * a;\n        b /= 2;\n    }\n    return ret;\n}\n\ndouble cal(int a, double b) {\n//    return 1;\n    double ret = 1;\n    for(int i = 0; i < n; i++) {\n        if(i == a) continue;\n        if(b > v[i] + m * t[i] - eps) {\n            return 0;\n        }\n        int l = 0;\n        int r = m;\n        int mid;\n        int ans;\n        while(l <= r) {\n            mid = (l + r) / 2;\n            if(v[i] + mid * t[i] > b) {\n                r = mid - 1;\n                ans = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        ret *= num[i][ans];\n    }\n//    printf(\"%d %lf %lf\\n\", a, b, ret);\n    return ret;\n}\n\ndouble solve(int a) {\n    double ret = 0;\n    for(int i = 0; i <= m; i++) {\n        ret += fast_pow(p[a], i) * fast_pow(1 - p[a], m - i) * c[m][i] * cal(a, v[a] + t[a] * i);\n    }\n    return ret;\n}\n\nint MAIN() {\n    mem(c, 0);\n    mem(num, 0);\n    c[0][0] = 1;\n    for(int i = 1; i <= 50; i++) {\n        c[i][0] = 1;\n        for(int j = 1; j <= i; j++) {\n            c[i][j] = c[i - 1][j] + c[i - 1][j - 1];\n        }\n    }\n    scanf(\"%d%d%lf\", &n, &m, &l);\n    for(int i = 0; i < n; i++) {\n        scanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n        p[i] /= 100.;\n        v[i] = l / v[i];\n    }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j <= m; j++) {\n            num[i][j] = fast_pow(1 - p[i], m - j) * fast_pow(p[i], j) * c[m][j];\n        }\n        for(int j = m - 1; j >= 0; j--) num[i][j] += num[i][j + 1];\n    }\n    for(int i = 0; i < n; i++) {\n        printf(\"%.10f\\n\", solve(i));\n    }\n    return 0;\n}\n\nint main() {\n#ifdef LOCAL_TEST\n    freopen(\"F:/ACMData.txt\",\"r\",stdin);\n#endif\n    MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2303.cc: Marathon Match\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 50;\n\ntypedef long long ll;\n\n/* typedef */\n\nstruct Stat {\n  double t, p;\n  int i, j;\n  Stat() {}\n  Stat(double _t, double _p, int _i, int _j): t(_t), p(_p), i(_i), j(_j) {}\n  bool operator<(const Stat &s) const { return t < s.t; }\n};\n\ntypedef vector<Stat> vs;\n\n/* global variables */\n\nll combs[MAX_M + 1][MAX_M + 1];\nStat rs[MAX_N][MAX_M + 1];\ndouble psums[MAX_N][MAX_M + 2], ans[MAX_N];\nint cs[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m, l;\n  cin >> n >> m >> l;\n\n  for (int i = 0; i <= m; i++) {\n    combs[i][0] = combs[i][i] = 1;\n    for (int j = 1; j < i; j++)\n      combs[i][j] = combs[i - 1][j - 1] + combs[i - 1][j];\n  }\n\n  vs allrs;\n  \n  for (int i = 0; i < n; i++) {\n    int pi, ti, vi;\n    cin >> pi >> ti >> vi;\n\n    double p = (double)pi / 100;\n    double t0 = (double)l / vi;\n    for (int j = 0; j <= m; j++) {\n      double tj = t0 + ti * j;\n      double pj = combs[m][j] * pow(p, j) * pow(1.0 - p, m - j);\n      rs[i][j] = Stat(tj, pj, i, j);\n      allrs.push_back(rs[i][j]);\n    }\n    psums[i][m + 1] = 0.0;\n    for (int j = m; j >= 0; j--) psums[i][j] = psums[i][j + 1] + rs[i][j].p;\n    //printf(\"%d: %lf\\n\", i, psums[i][0]);\n  }\n\n  sort(allrs.begin(), allrs.end());\n  int rn = allrs.size();\n\n  for (int i = 0; i < n; i++) ans[i] = 0.0, cs[i] = 0;\n\n  for (int i = 0; i < rn; i++) {\n    Stat &r = allrs[i];\n    double pp = r.p;\n\n    for (int j = 0; j < n; j++)\n      if (r.i != j) {\n\tint cj = cs[j];\n\tif (cj <= m && rs[j][cj].t == r.t) cj++;\n\tpp *= psums[j][cj];\n      }\n\n    ans[r.i] += pp;\n    cs[r.i]++;\n  }\n\n  for (int i = 0; i < n; i++) printf(\"%.8lf\\n\", ans[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[100][100] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n,vector<ld>(m+1,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=m;j++){\n            pos[i][j]=-(j+1)*j/2+(m+m-j+1)*j/2+j*log(p[i])+log(1-p[i])*(m-j);\n            pos[i][j]=exp(pos[i][j]);\n        }\n        // vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        // comb[0][0]=1;\n        // for(int j=0;j<=m;j++){\n        //     for(int k=0;k<=j;k++){\n        //         if(k==0){\n        //             comb[j][k]=(p[i]==1 ? ld(0) : ld(pow(1-p[i],ld(j))));\n        //         }\n        //         else if(k==j){\n        //             comb[j][k]=(p[i]==0 ? ld(0) : ld(pow(p[i],j)));\n        //         }\n        //         else{\n        //             comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n        //         }\n        //     }\n        // }\n        // pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                ld z=0;\n                for(int y=0;y<=m;y++){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]<l*v[i]+y*t[j]*v[i]*v[j]){\n                        z+=pos[j][y];\n                    }\n                }\n                sc*=z;\n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, m, l, p[111], t[111], v[111]; double r[111][55], dp[55][55];\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++) cin >> p[i] >> t[i] >> v[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) fill(dp[j], dp[j] + m + 1, 0.0);\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j + 1][k] += dp[j][k] * (100 - p[i]) / 100;\n\t\t\t\tdp[j + 1][k + 1] += dp[j][k] * p[i] / 100;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= m; j++) r[i][j] = dp[m][j];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble ret = 0;\n\t\tif (v[i] != 0) {\n\t\t\tdouble time1 = l / v[i];\n\t\t\tfor (int j = 0; j <= m; j++, time1 += t[i]) {\n\t\t\t\tdouble res = r[i][j];\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (i == k) continue;\n\t\t\t\t\tdouble sum = 0;\n\t\t\t\t\tif (v[k] != 0) {\n\t\t\t\t\t\tdouble time2 = l / v[k];\n\t\t\t\t\t\tfor (int l = 0; l <= m; l++, time2 += t[k]) {\n\t\t\t\t\t\t\tif (time1 < time2) sum += r[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse res = 1;\n\t\t\t\t\tres *= sum;\n\t\t\t\t}\n\t\t\t\tret += res;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double real;\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\nreal EPS = 1e-9;\n\nconst int MAX_N = 101;\nconst int MAX_M = 53;\n\nconst bool debug = false;\n\nint N, M; real L;\nvector<real> P, T, V;\nvoid input() {\n    cin >> N >> M >> L;\n    P.clear(); P.resize(N);\n    T.clear(); T.resize(N);\n    V.clear(); V.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n}\n\nreal X[MAX_N][MAX_M]; // X[i][j] :: i人目がm回休む確率\nreal S[MAX_N][MAX_M]; // S[i][j] :: i人目がm回未満だけ休む確率\n\nvoid init() {\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M; j++) X[i][j] = 0;\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M + 1; j++) S[i][j] = 0;\n    for (int i = 0; i < N; i++) {\n        static real dp[MAX_M][MAX_M];\n        for (int j = 0; j <= M; j++) for (int k = 0; k <= M; k++) dp[j][k] = 0;\n        dp[0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[j + 1][k] += dp[j][k] * (1.0 - P[i]);\n                dp[j + 1][k + 1] += dp[j][k] * P[i];\n            }\n        }\n        for (int k = 0; k <= M; k++) {\n            X[i][k] = dp[M][k];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        S[i][0] = 0;\n        for (int j = 0; j <= M; j++) {\n            S[i][j + 1] = S[i][j] + X[i][j];\n        }\n    }\n    if (debug) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= M; j++) {\n                printf(\"%3.3Lf \", X[i][j]);\n            }\n            cout << endl;\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for (int i = 0; i < N; i++) { // i人目\n        if (V[i] == 0) {\n            printf(\"%.12Lf\\n\", 0);\n            continue;\n        }\n        real ans = 0;\n        for (int j = 0; j <= M; j++) { // j回休んだ\n            real p = X[i][j];\n            real time = L / V[i] + j * T[i];\n            for (int k = 0; k < N; k++) { // k人目\n                if (i == k) continue;\n                if (EQ(T[k], 0)) {\n                    p *= (L / V[k] - EPS > time);\n                    continue;\n                }\n                // c回以上休む必要\n                int c = max(0, int(ceil((time - L / V[k]) / T[k] + EPS) + EPS));\n                if (c > M) {\n                    p = 0;\n                    break;\n                }\n                real pk = 1.0 - S[k][c];\n                p *= pk;\n            }\n            ans += p;\n        }\n        printf(\"%.12Lf\\n\", ans);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef pair<double,P> DP;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n//// combination using double\ndouble comb(int n,int r){\n\tif(n<r)return 0.0;\n\tif(n-r<r)r=n-r;\n\tdouble res=1;\n\trep(i,r){\n\t\tres*=n;\n\t\tn--;\n\t\tres/=i+1;\n\t}\n\treturn res;\n}\n\nint n,m;\ndouble l;\ndouble p[111],t[111],v[111];\nDP times[111*55];\ndouble res[111];\ndouble sum[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m>>l;\n\trep(i,n){\n\t\tcin>>p[i]>>t[i]>>v[i];\n\t\tp[i]/=100;\n\t}\n\tint num=n*(m+1);\n\trep(i,n)rep(j,m+1){\n\t\ttimes[i*(m+1)+j].fi=(double)j*t[i]+(double)(l/v[i]);\n\t\ttimes[i*(m+1)+j].se=P(i,j);\n\t}\n\tsort(times,times+num);\n\tmemset(res,0,sizeof(res));\n\trep(i,num){\n\t\tdouble ntimes=times[i].fi;\n\t\tint ni=times[i].se.fi,nj=times[i].se.se;\n\t\tmemset(sum,0,sizeof(sum));\n\t\trep(j,num){\n\t\t\tif(times[j].fi<ntimes||(times[j].se.fi!=ni&&times[j].fi==ntimes))continue;\n\t\t\tint nni=times[j].se.fi,nnj=times[j].se.se;\n\t\t\tif(times[j].se.fi==ni){\n\t\t\t\tsum[nni]=comb(m,nj)*pow(p[ni],nj)*pow(1-p[ni],m-nj);\n\t\t\t}else{\n\t\t\t\tsum[nni]+=comb(m,nnj)*pow(p[nni],nnj)*pow(1-p[nni],m-nnj);\n\t\t\t}\n\t\t}\n\t\tdouble pp=1;\n\t\trep(i,n)pp*=sum[i];\n\t\tres[ni]+=pp;\n\t}\n\trep(i,n)printf(\"%.10f\\n\", res[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nll conb(int a, int b) {\n\tll p = 1;\n\tFOR(i, 1, b+1) {\n\t\tp = p*(a - i + 1) / i;\n\t}\n\treturn p;\n}\n\n\nint main() {\n\tint n, m;\n\tdouble l;\n\tcin >> n >> m >> l;\n\tvector<vector<pair<double, double>>> goal(n,vector<pair<double,double>>(m+1));//time ,prob\n\tREP(i, n) {\n\t\tdouble pro,time,v;\n\t\tcin>> pro>> time>> v;\n\t\tpro /= 100.0;\n\t\tREP(j,m+1) {\n\t\t\tgoal[i][j] = {l/v+time*(j),(double)conb(m,j)*pow(pro,j)*pow(1.0-pro,m-j)};\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tdouble ans=0.0;\n\t\tREP(j, m+1) {\n\t\t\tdouble res=goal[i][j].second;\n\t\t\tbool win=true;\n\t\t\tREP(k, n) {\n\t\t\t\tif (i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble res2=1.0;\n\t\t\t\tREP(l,m+1) {\n\t\t\t\t\tif (goal[i][j].first<goal[k][l].first-1e-9) {\n\t\t\t\t\t\tres *= res2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tres2 -= goal[k][l].second;\n\t\t\t\t\t\tif (l == m)\n\t\t\t\t\t\t\twin = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(win)\n\t\t\tans += res;\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = 0;\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n,vector<ld>(m+1,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<=m;j++){\n            pos[i][j]=j*log(p[i]+1e-30)+(m-j)*log(1-p[i]+1e-30);\n            for(int k=0;k<j;k++){\n                pos[i][j]+=log(m-k)-log(k+1);\n            }\n            pos[i][j]=exp(pos[i][j]);\n        }\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=(p[i]==1 ? ld(0) : ld(pow(1-p[i],ld(j))));\n                }\n                else if(k==j){\n                    comb[j][k]=(p[i]==0 ? ld(0) : ld(pow(p[i],j)));\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n,0);\n    for(int i=0;i<n;i++){\n        if(v[i]==0) continue;\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j || v[j]==0) continue;\n                ld z=0;\n                for(int y=0;y<=m;y++){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]<l*v[i]+y*t[j]*v[i]*v[j]){\n                        z+=pos[j][y];\n                    }\n                }\n                sc*=z;\n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(8)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\nint N, M, L, P[110], T[110], V[110];\ndouble RP[110][55], RT[110][55];\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\t\n\tfor_(i,0,N) {\n\t\tRT[i][0] = V[i] > 0 ? (double)L / (double)V[i] : 1e9;\n\t\tfor_(j,0,M) RT[i][j + 1] = RT[i][j] + (double)T[i];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tvector< double > p(M+1, 1.0), pm(M+1, 1.0);\n\t\t\n\t\tfor_(k,0,M) {\n\t\t\tp[k + 1] = p[k] * (double)P[i] / 100.0;\n\t\t\tpm[k + 1] = pm[k] * (1.0 - (double)P[i] / 100.0);\n\t\t}\n\t\t\n\t\tint mCk = 1;\n\t\t\n\t\tfor_(k,0,M + 1) {\n\t\t\tRP[i][k] =  (double)mCk * p[k] * pm[M - k];\n\t\t\tmCk *= (M - k);\n\t\t\tmCk /= k + 1;\n\t\t}\n\t\t\n\t\tfor_rev(k,M,1) RP[i][k-1] += RP[i][k];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tif (V[i] == 0) {\n\t\t\tcout << \"0.000000000\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble ans = 0.0;\n\t\t\n\t\tfor_(k,0,M+1) {\n\t\t\tdouble t = RT[i][k];\n\t\t\tdouble p = RP[i][k] - RP[i][k + 1];\n\t\t\t\n\t\t\tfor_(ii,0,N) {\n\t\t\t\tif (ii == i || V[ii] == 0) continue;\n\t\t\t\tint id = upper_bound(RT[ii], RT[ii] + M + 1, t) - RT[ii];\n\t\t\t\t\n\t\t\t\tif (id > M) {\n\t\t\t\t\tp = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tp *= RP[ii][id];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += p;\n\t\t}\n\t\t\n\t\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\n\nLL C[55][55];\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\n#define eps 1e-8\nint dd(double x,double y){ return fabs(x-y)<eps;} // x==y\nint dy(double x,double y){ return x>y+eps;}   // x>y   \nint xy(double x,double y){ return x<y-eps;}   //x<y\nint dyd(double x,double y){ return x>y-eps;}  //x>=y\nint xyd(double x,double y){ return x<y+eps;}  //x<=y\n\n\nint main(){\n\tC[0][0]=1;\n\tfor (int i=0; i<=50; ++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l) == 3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(dy(t1,t))\n\t\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\",ppp);\n\t\t}\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n\nint n, m;\ndouble l;\ndouble p[100], t[100], v[100];\ndouble a[100][60], b[100][60];\ndouble dp[60][60];\n\ndouble calc(int i, int j, double p)\n{\n\tif (i == 0) return j == 0 ? 1.0 : 0.0;\n\tif (dp[i][j] > -1.0) return dp[i][j];\n\tdouble vl = p * calc(i - 1, j - 1, p);\n\tdouble vr = (1.0 - p) * calc(i - 1, j, p);\n\treturn dp[i][j] = vl + vr;\n}\n\nint main()\n{\n\tcin >> n >> m >> l;\n\trep(i, n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\trep(i, n){\n\t\tfill_n(*dp, 60 * 60, -1.0);\n\t\trep(j, m + 1) a[i][j] = calc(m, j, p[i]);\n\t\trep(j, m + 1) b[i][j] = l / v[i] + t[i] * j;\n\t}\n\n\trep(i, n){\n\t\tdouble s = 0.0;\n\t\trep(j, m + 1){\n\t\t\tdouble t = 1.0;\n\t\t\trep(x, n){\n\t\t\t\tif (i == x) continue;\n\t\t\t\tdouble u = 0.0;\n\t\t\t\trep(y, m + 1){\n\t\t\t\t\tif (b[i][j] < b[x][y] - 1e-8){\n\t\t\t\t\t\tu += a[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt *= u;\n\t\t\t}\n\t\t\ts += t * a[i][j];\n\t\t}\n\t\tprintf(\"%.20f\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " t[n][m+1], p[n][m+1], sump[n][m+1];\n    for (int i=0; i<n; ++i) {\n        double pp, tt;\n        cin >> pp>>tt>>v[i];\n        pp/=100;\n        \n        for (int k=0; k<=m; ++k) {\n            p[i][k] = 1;\n            for (int l=0; l<=m; ++l) {\n                if (l < k) p[i][k] *= m-l;\n                if (k-l >= 1) {\n                    p[i][k] /= k-l;\n                }\n                if (l<k) p[i][k] *= pp;\n                if (l<m-k) p[i][k] *= (1.0-pp);\n            }\n            t[i][k] = (double)L/v[i] + k*tt;\n//            printf(\"i=%d, k=%d %f\\n\", i,k,p[i][k]);\n            if (k>0)\n                sump[i][k] = sump[i][k-1] + p[i][k];\n            else\n                sump[i][k] = p[i][k];\n        }\n    }\n    \n    double ans[n];\n    for (int i=0;i<n;++i) ans[i] = 0;\n\n    for (int i=0; i<n; ++i) {\n        for (int j=0; j<=m; ++j) {           \n            double tmp = p[i][j];\n            for (int k=0; k<n; ++k) {\n                if (i==k) continue;\n                if (upper_bound(t[k], t[k]+m+1, t[i][j])-t[k] == 0) {\n                    \n//                    printf(\"zero %d %d\\n\", i, j);\n                    // tmp = 0;\n                    // break;\n                }\n                else \n                    tmp *= (1.0 - sump[k][upper_bound(t[k], t[k]+m+1, t[i][j])-t[k]-1]);\n            }\n//            printf(\"%d,%d %f\\n\", i,j,tmp);\n            ans[i] += tmp;\n        }\n    }\n\n    for (int i=0;i<n;++i)\n        printf(\"%.12f\\n\", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, L;\n  while(cin>>N>>M>>L){\n    double P[100], T[100], V[100];\n    REP(i, N) cin>>P[i]>>T[i]>>V[i];\n    REP(i, N) P[i] /= 100;\n    double p[100][51];\n    double f[100][51];\n    REP(i, N){\n      REP(j, M + 1){\n        f[i][j] = (double)L/V[i] + j * T[i];\n        p[i][j] = pow(P[i], j) * pow(1 - P[i], M - j);\n        REP(k, j) p[i][j] *= (M - k);\n        REP(k, j) p[i][j] /= (k + 1);\n      }\n    }\n    double a[100] = {};\n    REP(i, N){\n      REP(j, M + 1){\n        double tp = p[i][j];\n        REP(k, N) if(i != k){\n          double p_k = 0;\n          REP(l, M + 1){\n            if(f[k][l] > f[i][j]){\n              p_k += p[k][l];\n            }\n          }\n          tp *= p_k;\n        }\n        a[i] += tp;\n      }\n      printf(\"%.8f\\n\", a[i]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nstruct runner{\n\tint t,v;\n\tdouble p;\n};\n\nconst int INF=1000000000;\n\nvector<runner> vr;\ndouble mem[101][51][101];\n// kÍxe·éêÌ\ndouble calcPer(int n,int k,int idx){\n\tif(!EQ(mem[n][k][idx],INF))\n\t\treturn mem[n][k][idx];\n\tdouble p = vr[idx].p;\n\tif(k==0)\n\t\treturn 1.0;\n\telse{\n\t\treturn mem[n][k][idx]=(((double)n/k)*calcPer(n-1,k-1,p)*p);\n\t}\n}\n\nint main(){\n\n\tint n,m,L;\n\tfor(int i = 0; i < 101; i++)\n\t\tfor(int j = 0; j < 51; j++)\n\t\t\tfor(int k = 0; k < 101; k++)\n\t\t\t\tmem[i][j][k]=INF;\n\n\tcin>>n>>m>>L;\n\tfor(int i = 0; i < n; i++){\n\t\trunner r;\n\t\tint p;\n\t\tcin>>p>>r.t>>r.v;\n\t\tr.p=(double)p/100;\n\t\tvr.push_back(r);\n\t}\n\t// êl¸ÂßÄ¢­\n\tfor(int i = 0; i < n; i++){\n\t\tdouble sumPer=0.0;\n\t\tif(vr[i].v==0)\n\t\t\tsumPer=0.0;\n\t\telse{\n\t\t\t// ©ªª¢­ÂÌêÅxe·é©\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t// »ÝÌxeÅxe·ém¦\n\t\t\t\tdouble cper=calcPer(m,j,i)*pow((double)(1-vr[i].p),m-j);\n\t\t\t\tdouble selfTime=((double)L/vr[i].v)+vr[i].t*j;\n\t\t\t\t// »ê¼êÌGÉÂ¢Ä²×é\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t// ©ª©gÜ½ÍA¬xª0Ìi[Í³·é\n\t\t\t\t\tif(i==k||EQ(vr[k].v,0.0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble enemPer=1.0;\n\t\t\t\t\t// èª¢­ÂÈãÌêÅxeµ½çAÔÉ¤©ð`FbN\n\t\t\t\t\tfor(int l = 0; l <= m; l++){\n\t\t\t\t\t\t// GÌBðvZ\n\t\t\t\t\t\tdouble enemyTime=((double)L/vr[k].v)+vr[k].t*l;\n\t\t\t\t\t\t// àµGÌBÔª©ªÌBÔðºñÁ½çI¹\n\t\t\t\t\t\tif(EQ(enemyTime,selfTime)||enemyTime>selfTime){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ±ÌÌêÅxe·ém¦\n\t\t\t\t\t\tdouble p=calcPer(m,l,k)*pow((double)(1-vr[k].p),m-l);\n\t\t\t\t\t\tenemPer-=p;\n\t\t\t\t\t}\n\t\t\t\t\t// »ÝcÁÄ¢ém¦ªAGª©ªæèx­B·ém¦\n\t\t\t\t\tcper*=enemPer;\n\t\t\t\t}\n\t\t\t\t// cperª»Ìm¦\n\t\t\t\tsumPer+=cper;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",sumPer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[0][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={},a=1,b=1;\n  for(int i=0;i<m;i++) a*=(1-p[0]);\n  for(int i=0;i<=m;i++){\n    dp[0][i]=a*b*nCr(m,i),b*=p[0],a/=(1-p[0]);\n    if(a==0)break;\n  }\n\n  for(int i=1;i<n;i++){\n    for(int j=0;j<=m;j++){\n      a=b=1;\n      for(int k=0;k<m;k++)a*=(1-p[i]);\n      for(int k=0;k<=m;k++,b*=p[i],a/=(1-p[i])){\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) dp[i][j]+= dp[i-1][j]*a*b*nCr(m,k);\n\tif(a==0)break;\n      }\n\n    }\n  }\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n    for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(!v[i])continue;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=(int)(s-1.0*l/v[k]+EPS);\n\tif(idx<0)idx=0;\n\telse idx++;\n\tif(T<=idx){\n\t  x=0;\n\t  break;\n\t}\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 1e10\nusing namespace std;\ntypedef long long ll;\n\nint N, M, L, P[100], T[100], V[100];\ndouble p[100][51];\n\nll combination(ll n, ll r) {\n  static ll comb[51][51];\n  ll &ret = comb[n][r];\n  if(ret != 0) return ret;\n  if(n == 0 || r == 0) return ret = 1;\n  if(n == r) return ret = 1;\n  if(r == 1) return ret = n;\n  return ret = combination(n - 1, r - 1) + combination(n - 1, r);\n}\n\nbool ok(int ai, int aj, int bi, int bj) {\n  double ta = V[ai] > 0 ? L / V[ai] + T[ai] * aj : INF;\n  double tb = V[bi] > 0 ? L / V[bi] + T[bi] * bj : INF;\n  return ta < tb;\n}\n\nint main(void) {\n  cin >> N >> M >> L;\n  REP(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n  REP(i, 0, N) REP(j, 0, M + 1) {\n    p[i][j] = combination(M, j) * pow(P[i] / 100.0, j) * pow(1 - P[i] / 100.0, M - j);\n  }\n\n  REP(i, 0, N) {\n    double ans = 0;\n    double pi = 0;\n    REP(j, 0, M + 1) {\n      pi = p[i][j];\n      double pij = pi;\n      REP(k, 0, N) if(i != k) {\n        double pk = 0;\n        REP(l, 0, M + 1) if(ok(i, j, k, l)) pk += p[k][l];\n        pij *= pk;\n      }\n      ans += pij;\n    }\n    printf(\"%.8lf\\n\", ans);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++) cin>>p[i]>>t[i]>>v[i];\n\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--) sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  \n  \n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=max(0,(int)(s-1.0*l/v[k])+1);\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <cfloat>\nusing namespace std;\n\nconst double INF = DBL_MAX / 2;\nconst double EPS = 1.0e-10;\n\nint main()\n{\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<int> p(n), t(n), v(n);\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> p[i] >> t[i] >> v[i];\n\n\tvector<vector<double> > time(n, vector<double>(m+2, INF));\n\tvector<vector<double> > prob(n, vector<double>(m+1, 0.0)), sumProb(n, vector<double>(m+2, 0.0));\n\tfor(int i=0; i<n; ++i){\n\t\tdouble comb = 1.0;\n\t\tfor(int j=m; j>=0; --j){\n\t\t\ttime[i][j] = l / (double) v[i] + j * t[i];\n\t\t\tprob[i][j] = comb * pow(p[i]/100.0, j) * pow(1.0-p[i]/100.0, m-j);\n\t\t\tsumProb[i][j] = sumProb[i][j+1] + prob[i][j];\n\t\t\tcomb *= j;\n\t\t\tcomb /= m-j+1;\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; ++i){\n\t\tdouble ret = 0.0;\n\t\tfor(int j=0; j<=m; ++j){\n\t\t\tdouble tmp = prob[i][j];\n\t\t\tfor(int k=0; k<n; ++k){\n\t\t\t\tif(i == k)\n\t\t\t\t\tcontinue;\n\t\t\t\tint left = 0;\n\t\t\t\tint right = m+1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint middle = (left + right) / 2;\n\t\t\t\t\tif(time[i][j] < time[k][middle] - EPS){\n\t\t\t\t\t\tright = middle;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tleft = middle + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(time[i][j] < time[k][left] - EPS)\n\t\t\t\t\ttmp *= sumProb[k][left];\n\t\t\t\telse\n\t\t\t\t\ttmp *= 0.0;\n\t\t\t}\n\t\t\tret += tmp;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-12;\n\nclass State{\npublic:\n  double probability;\n  double cost;\n  State(double _p,double _c) : probability(_p),cost(_c){}\n  bool operator<(const State& s) const{\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const{\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int total_players;\n  int total_resting_places;\n  int goal_distance;\n  while(~scanf(\"%d %d %d\",&total_players,&total_resting_places,&goal_distance)){\n\n    vector<vector<State> > players;\n\n    for(int player_idx=0;player_idx<total_players;player_idx++){\n      int probability;\n      int resting_duration;\n      int speed;\n      scanf(\"%d %d %d\",&probability,&resting_duration,&speed);\n      \n      double dp[51][5001];\n      vector<State> player;\n      memset(dp,0,sizeof(dp));\n\n      dp[0][0] = 1.0;\n      for(int resting_place_idx=0;resting_place_idx<total_resting_places;resting_place_idx++){\n\tfor(int total_resting_duration = 0; total_resting_duration <= 5000; total_resting_duration += resting_duration){\n\t  if(dp[resting_place_idx][total_resting_duration] <= EPS) continue;\n\n\t  dp[resting_place_idx+1][total_resting_duration + resting_duration] += dp[resting_place_idx][total_resting_duration] * (double)probability/100.0;\n\t  dp[resting_place_idx+1][total_resting_duration] += dp[resting_place_idx][total_resting_duration] * (1.0 - (double)probability/100.0);\n\t}\n      }\n\n      for(int total_resting_duration = 0; total_resting_duration <= 5000; total_resting_duration += resting_duration){\n\tif(dp[total_resting_places][total_resting_duration] != 0){\n\t  // printf(\"rest:%d prob:%lf\\n\",total_resting_duration,dp[total_resting_places][total_resting_duration]);\n\t  player.push_back(State(dp[total_resting_places][total_resting_duration],total_resting_duration + (double)goal_distance/(double)speed));\n\t}\n      }\n      sort(player.begin(),player.end());\n      players.push_back(player);\n    }\n\n    for(int player_idx=0;player_idx<total_players;player_idx++){\n\n      double win_prob = 0.0;\n      for(int state_idx=0;state_idx<players[player_idx].size();state_idx++){\n\tdouble cost = players[player_idx][state_idx].cost;\n\tdouble player_prob = players[player_idx][state_idx].probability;\n\n\tdouble rival_prob = 1.0;\n\tfor(int rival_idx=0;rival_idx<total_players;rival_idx++){\n\t  if(player_idx == rival_idx) continue;\n\t  double tmp_prob = 0.0;\n\t  for(int rival_state_idx=0;rival_state_idx<players[rival_idx].size();rival_state_idx++){\n\t    if(players[rival_idx][rival_state_idx].cost > cost){\n\t      tmp_prob += players[rival_idx][rival_state_idx].probability;\n\t    }\n\t  }\n\n\t  rival_prob *= tmp_prob;\n\t}\n\twin_prob += player_prob * rival_prob;\n      }\n\n      printf(\"%.7lf\\n\",win_prob);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[0][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ndouble combination(int a, int b){\n  double ret = 1;\n  for(int i = 0; i < b; ++i){\n    ret *= (double)(a-i)/(i+1);\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  int P[N], T[N], V[N];\n  for(int i = 0; i < N; ++i){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n  double prob[N][M+1];\n\n  for(int i = 0; i < N; ++i) prob[i][0] = 1.0;\n  for(int i = 0; i < N; ++i){\n\n    for(int j = 1; j <= M; ++j){\n      prob[i][j] = prob[i][j-1]*P[i]/100.0*(M-j+1)/j;\n    }\n    double t = 1.0;\n    for(int j = M; j >= 0; --j){\n      prob[i][j] *= t;\n      t *= (1.0 - (double)P[i]/100.0);\n    }\n  }\n  double acum[N][M+2];\n  for(int i = 0; i < N; ++i) acum[i][M+1] = 0;\n  for(int i = 0; i < N; ++i){\n    for(int j = M; j >= 0; --j){\n      acum[i][j] = acum[i][j+1] + prob[i][j];\n    }\n  }\n  vector< vector<double> > time(N,vector<double>(M+1));\n  for(int i = 0; i < N; ++i) time[i][0] = (double)L/V[i];\n  for(int i = 0; i < N; ++i){\n    for(int j = 1; j <= M; ++j){\n      time[i][j] = time[i][j-1] + T[i];\n    }\n  }\n  for(int i = 0; i < N; ++i){\n    double ans = 0.0;\n    for(int j = M; j >= 0; --j){\n      double t = prob[i][j];\n      for(int k = 0; k < N; ++k){\n        if(k == i) continue;\n        int id = upper_bound(time[k].begin(),time[k].end(),time[i][j]) - time[k].begin();\n        if(id > M){\n          t = 0;\n          break;\n        }\n        t *= acum[k][id];\n      }\n      ans += t;\n    }\n    printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nconst int MAXN = 105;\nconst double EPS = 1e-8;\n\nint n, m, l;\nint P[MAXN], T[MAXN], V[MAXN];\ndouble f[MAXN][55][55];\ndouble sumf[MAXN][55];\n\nvoid gao() {\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 0; i < n; ++i) {\n\t\tf[i][0][0] = 1;\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tf[i][j][0] = f[i][j-1][0] * (1-1.0*P[i]/100);\n\t\t\t//\tprintf(\"%d %d %d: %.12lf\\n\",i,j,0,f[i][j][0]);\n\t\t\tfor (int k = 1; k <= j; ++k) {\n\t\t\t\tf[i][j][k] = f[i][j-1][k]*(1-1.0*P[i]/100) + f[i][j-1][k-1]*1.0*P[i]/100;\n\t\t\t//\tprintf(\"%d %d %d: %.12lf\\n\",i,j,k,f[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(sumf, 0, sizeof(sumf));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = m; j >= 0; --j) {\n\t\t\tsumf[i][j] = sumf[i][j+1] + f[i][m][j];\n\t\t\t//printf(\"%lf \",sumf[i][j]);\n\t\t\tassert(sumf[i][j] > -EPS && sumf[i][j] < 1+EPS);\n\t\t}\n\t\tassert(fabs(sumf[i][0]-1) < EPS);\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 0; i < n; ++i) {\n\t\tdouble ans = 0;\n\t\tif (V[i] == 0) {\n\t\t\tprintf(\"0.00000000\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= m; ++k) {\n\t\t\tdouble Ti = l*1.0 / V[i] + k * T[i];\n\t\t//\tprintf(\"Ti: %lf\\t\",Ti);\n\t\t\tdouble z = 1;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (j != i) {\n\t\t\t\t\tif (V[j] == 0) continue;\n\t\t\t\t\tdouble tmp;\n\t\t\t\t\tif (T[j] == 0) {\n\t\t\t\t\t\tif (1LL*l*V[i] <= l*V[j] + 1LL*k*T[i]*V[i]*V[j]) z=0;\n\t\t\t\t\t\ttmp = -10;\n\t\t\t\t\t}\n\t\t\t\t\telse tmp = (Ti - l*1.0/V[j]) / T[j];\n\t\t\t\t\t//assert(V[j] != 0);\n\t\t\t\t\tint kj = (int)ceil(tmp); \n\t\t\t\t\tif (fabs(tmp - kj) < EPS) ++kj;\n\t\t\t\t\tif (kj < 0) kj = 0;\n\t\t\t\t\tz *= sumf[j][kj];\n\t\t\t\t//\tprintf(\"j: %d %d %lf\\n\",j,kj,sumf[j][kj]);\n\t\t\t\t}\n\t\t\tans += z*f[i][m][k];\n\t\t}\n\t\tprintf(\"%.9lf\\n\", ans);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", P+i, T+i, V+i);\n\t}\n\tgao();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\nlong long C(int n,int k)\n{\n\tlong long y=1;\n\tfor(int i=n-k+1,j=2;i<=n;i++){\n\t\ty*=i;\n\t\twhile(y%j==0&&j<=k){\n\t\t\ty=y/j;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn y;\n}\n\nint main(){\n\tdouble l;\n\tint n,st;\n\tscanf(\"%d %d %lf\",&n,&st,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\tstu[i].p/=100;\n\t}\n\tdouble pp,t,t1,p2,ppp;\n\tfor(int i=0;i<n;i++){\n\t\tppp=0;\n\t\tfor(int j=0;j<=st;j++){\n\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\tpp=static_cast<double>(C(st,j))*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)\n\t\t\t\t\tcontinue;\n\t\t\t\tp2=0;\n\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\tif(t1>t)\n\t\t\t\t\t\tp2+=C(st,u)*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t}\n\t\t\t\tpp*=p2;\n\t\t\t}\n\t\t\tppp+=pp;\n\t\t}\n\t\tprintf(\"%.8lf\\n\",ppp);\n\t}\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\ntypedef long long int ll;\nconst int MAXN = 110;\nconst ll MAXM = 55;\n\nll comb[MAXM][MAXM];\ndouble ac[MAXN][MAXM];\n\nint main() {\n  rep(i,0,MAXM) comb[i][0] = 1;\n  rep(i,1,MAXM) rep(j,1,i+1) comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n  \n  int N, M, L;\n  scanf(\"%d %d %d\", &N, &M, &L);\n\n  if (N == 0)\n    return 1;\n\n  std::vector<int> T(N), V(N);\n  std::vector<double> P(N);\n  for (int i=0; i<N; ++i) {\n    int p;\n    scanf(\"%d %d %d\", &p, &T[i], &V[i]);\n    P[i] = p / 100.0;\n  }\n\n  rep(i,0,N) rep(j,0,M+1) {\n    double prev = (j ? ac[i][j-1] : 0);\n    ac[i][j] = prev + comb[M][j] * pow(P[i], j) * pow(1-P[i], M-j);\n  }\n\n  rep(i,0,N) {\n    double ans = 0;\n    rep(j,0,M+1) {\n      double cur = ac[i][j] - (j ? ac[i][j-1] : 0);\n      double user_time = 1.0 * L / V[i] + T[i] * j;\n      rep(x,0,N) {\n        if(x == i) continue;\n        bool flag = false;\n        rep(y,0,M+1) {\n          double rival_time = 1.0 * L / V[x] + T[x] * y;\n          if(user_time < rival_time) {\n            flag = true;\n            double rival_prob = ac[x][M] - (y ? ac[x][y-1] : 0);\n            cur *= rival_prob;\n            // printf(\"user = (%d, %d), rival = (%d, %d), prob = %.12f\\n\", i+1, j, x+1, y, rival_prob);\n            break;\n          }\n        }\n        if(!flag) cur = 0;\n      }\n      ans += cur;\n    }\n    printf(\"%.12f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ndouble combination(int a, int b){\n  double ret = 1;\n  for(int i = 0; i < b; ++i){\n    ret *= (double)(a-i)/(i+1);\n  }\n  return ret;\n}\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  int P[N], T[N], V[N];\n  for(int i = 0; i < N; ++i){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n  double prob[N][M+1];\n  //cout << \"______prob_______\" << endl;\n  for(int i = 0; i < N; ++i) prob[i][0] = 1.0;\n  for(int i = 0; i < N; ++i){\n\n    for(int j = 1; j <= M; ++j){\n      prob[i][j] = prob[i][j-1]*P[i]/100.0*(M-j+1)/j;\n    }\n    double t = 1.0;\n    for(int j = M; j >= 0; --j){\n      prob[i][j] *= t;\n      t *= (1.0 - (double)P[i]/100.0);\n    }\n    //cout << i << \" | \" << prob[i][0] << \" | \";\n    //for(int j = 1; j <= M; ++j) cout << prob[i][j] << \" | \";\n    //cout << endl;\n  }\n  double acum[N][M+2];\n  for(int i = 0; i < N; ++i) acum[i][M+1] = 0;\n  for(int i = 0; i < N; ++i){\n    for(int j = M; j >= 0; --j){\n      acum[i][j] = acum[i][j+1] + prob[i][j];\n    }\n  }\n  /*\n  cout << \"______acum_______\" << endl;\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j <= M; ++j){\n      cout << acum[i][j] << \" | \";\n    }\n    cout << endl;\n  }\n  */\n  \n  //cout << \"______time_______\" << endl;\n  vector< vector<double> > time(N,vector<double>(M+1));\n  for(int i = 0; i < N; ++i) time[i][0] = (double)L/V[i];\n  for(int i = 0; i < N; ++i){\n    //cout << i << \" | \" << time[i][0] << \" | \";\n    for(int j = 1; j <= M; ++j){\n      time[i][j] = time[i][j-1] + T[i];\n      //cout << time[i][j] << \" | \";\n    }\n    //cout << endl;\n  }\n  for(int i = 0; i < N; ++i){\n    double ans = 0.0;\n    for(int j = M; j >= 0; --j){\n      double t = prob[i][j];\n      for(int k = 0; k < N; ++k){\n        if(k == i) continue;\n        int id = upper_bound(time[k].begin(),time[k].end(),time[i][j]) - time[k].begin();\n        if(id > M){\n          t = 0;\n          break;\n        }\n        t *= acum[k][id];\n      }\n      //cout << i << \" \" << j << \" \" << t << endl;\n      ans += t;\n    }\n    printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n\nint N, M;\ndouble L, P[110], T[110], V[110];\ndouble p[110][55];\n\nvoid solve() {\n\tfor_(i,0,N) {\n\t\tdouble dp[55][55] = { 0.0 }, pi = P[i] / 100.;\n\t\tdp[0][0] = 1.0;\n\t\t\n\t\tfor_(j,0,M) for_(k,0,M) {\n\t\t\tdp[j+1][k] += dp[j][k] * (1.0 - pi);\n\t\t\tdp[j+1][k+1] += dp[j][k] * pi;\n\t\t}\n\t\t\n\t\tfor_(k,0,M+1) p[i][k] = dp[M][k];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tdouble ans = 0.0;\n\t\t\n\t\tif (V[i] > 0) {\n\t\t\tfor_(j,0,M+1) {\n\t\t\t\tdouble t1 = L / V[i] + (j * T[i]);\n\t\t\t\tdouble mul = 1.0;\n\t\t\t\t\n\t\t\t\tfor_(ii,0,N) {\n\t\t\t\t\tif (i != ii && V[ii] > 0) {\n\t\t\t\t\t\tdouble mii = 0.0;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tdouble t2 = L / V[ii] + (M * T[ii]);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor_rev(k,M,0) {\n\t\t\t\t\t\t\tif (t2 - t1 < 1e-9) break;\n\t\t\t\t\t\t\tmii += p[ii][k];\n\t\t\t\t\t\t\tt2 -= T[ii];\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\tmul *= mii;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tans += mul * p[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.9lf\\n\", (N == 1) ? 1.0 : ans);\n\t}\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=pow(1-p[i],j);\n                }\n                else if(k==j){\n                    comb[j][k]=pow(p[i],j);\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n);\n    for(int i=0;i<n;i++){\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                if(t[j]==0){\n                    if(l*v[j]+x*t[i]*v[i]*v[j]>=l*v[i]){\n                        sc=0;\n                    }\n                    continue;\n                }\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<double,int,double> tp;\ntypedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n,m;\n\tdouble l;\n\tcin>>n>>m>>l;\n\tvt in;\n\trep(i,n){\n\t\tdouble a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta/=100;\n\t\tdouble sum=0;\n\t\tvd dp(200);\n\t\tdp[100]=1;\n\t\trep(j,m){\n\t\t\tvd ndp(200);\n\t\t\trep(k,200)if(dp[k]>0){\n\t\t\t\tndp[k+1]+=dp[k]*a;\n\t\t\t\tndp[k-1]+=dp[k]*(1-a);\n\t\t\t}\n\t\t\tdp=ndp;\n\t\t}\n\t\trep(j,m+1){\n\t\t\tsum=dp[100-m+2*j];\n\t\t\tif(c)in.pb(tp(l/c+j*b,i,sum));\n\t\t\telse in.pb(tp(inf,i,sum));\n\t\t}\n\t}\n\tsort(all(in));\n\tvd out(n);\n//\tdouble t=1;\n\tvd t(n,1);\n\trep(i,in.size()){\n\t\tdouble a,c;int b;\n\t\ttie(a,b,c)=in[i];\n//\t\tcout<<shosu(4)<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t\tvt tmp;\n\t\ttmp.pb(in[i]);\n\t\tt[b]-=c;\n\t\twhile(i!=in.size()-1){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=in[i+1];\n\t\t\tif(abs(a-d)<EPS){\n\t\t\t\ti++;\n\t\t\t\ttmp.pb(in[i]);\n\t\t\t\tt[e]-=f;\n\t\t\t}else break;\n\t\t}\n//\t\trep(j,t.size())cout<<\" \"<<t[j];cout<<endl;\n\t\trep(j,tmp.size()){\n\t\t\tdouble d,f;int e;\n\t\t\ttie(d,e,f)=tmp[j];\n\t\t\tdouble sum=f;\n\t\t\trep(k,n)if(k!=e)sum*=t[k];\n\t\t\tout[e]+=sum;\n\t\t}\n//\t\tcout<<t<<endl;\n\t}\n\trep(i,n)cout<<shosu(9)<<out[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N];\nvector<double> A[N],B[N];\n\ndouble mem[M][M];\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  if(r==0||n==r)return 1;\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>d[i],p[i]/=100,d[i]=l/d[i];\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j?????????????¢???????\n    A[i]=B[i]=vector<double>(m+1,0);\n    A[i][0]=B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]);\n      B[i][j]=B[i][j-1]*p[i];\n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Runner{\n  double p, t, v;\n  Runner(double p, double t, double v) : p(p), t(t), v(v){}  \n};\n\nint main(){\n  int N, M, L;\n  cin >> N >> M >> L;\n  \n  vector<Runner> r;\n  \n  for(int i = 0 ; i < N ; i++){\n    double p, t, v;\n    cin >> p >> t >> v;\n    r.push_back(Runner(p/100.0, t, v));\n  }\n  \n  double dp[55][110][55]; // iテァツ閉ェテァツ崢ョテ」ツ?ァ j テ」ツ??kテ・ツ崢?テ、ツシツ妥」ツつ?ァツ「ツコテァツ篠?\n  memset(dp, 0, sizeof(dp));\n  for(int i = 0 ; i < N ; i++) dp[0][i][0] = 1;\n  \n  for(int i = 1 ; i <= M ; i++){\n    for(int j = 0 ; j < N ; j++){\n      for(int k = 0 ; k <= M ; k++){\n\tdp[i][j][k] = (r[j].p * dp[i-1][j][k-1]) + ((1.0-r[j].p) * dp[i-1][j][k]);\n      }\n    }\n  }\n  \n  double sum[110][55];\n  for(int i = 0 ; i < N ; i++){\n    sum[i][0] = (double)(L / r[i].v);\n    for(int j = 1 ; j <= M ; j++){\n      sum[i][j] = sum[i][j-1] + r[i].t;\n    }\n  }\n  \n  double sum2[110][55];\n  for(int i = 0 ; i < N ; i++){\n    sum2[i][0] = dp[M][i][0];\n    for(int j = 1 ; j <= M ; j++){\n      sum2[i][j] = sum2[i][j-1] + dp[M][i][j];\n    }\n  }\n  \n  for(int i = 0 ; i < N ; i++){\n    double ans = 0.0;\n\n    for(int j = 0 ; j <= M ; j++){\n      double p = dp[M][i][j];\n      for(int ii = 0 ; ii < N ; ii++){\n\tif(i == ii) continue;\n\n\tint index = upper_bound(sum[ii], sum[ii]+M+1, sum[i][j]) - sum[ii];\n\n\tdouble s = sum2[ii][M] - sum2[ii][index-1];\n\tp *= s;\t\n      }\n      ans += p;\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nstruct State {\n\tstring dial; int cnt;\n\tState(string _d, int _c) : dial(_d), cnt(_c) {}\n};\n\nint k;\nstring S, T;\n\nchar add(char c, int x) {\n\tint y = c - '0';\n\treturn char('0' + (y + x) % 10);\n}\n\nvoid solve() {\n\tset< string > vis;\n\tvis.insert(S);\n\t\n\tqueue< State > q;\n\tq.push(State(S, 0));\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tif (s.dial == T) {\n\t\t\tcout << s.cnt << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor_(i,0,k) if (s.dial[i] != T[i]) {\n\t\t\tint dif = (T[i] - s.dial[i] + 10) % 10;\n\t\t\n\t\t\tfor_(j,i,k) {\n\t\t\t\ts.dial[j] = add(s.dial[j], dif);\n\t\t\t\tif (vis.find(s.dial) == vis.end()) q.push(State(s.dial, s.cnt + 1));\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> k, k) {\n\t\tcin >> S >> T;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\nusing namespace std;\nint p[100],t[100],v[100];\nunsigned long long c[50][50];\ndouble rest[100][50],time[100][50];\nint main()\n{\nint n,m,l;\nscanf(\"%d%d%d\",&n,&m,&l);\nc[0][0]=1;\nfor(int i=1;i<50;i++){\n\tc[i][i]=c[i][0]=1;\n\tfor(int j=1;j<i;j++){\n\t\tc[i][j]=c[i-1][j]+c[i-1][j-1];\n\t\t}\n\t}\nfor(int i=0;i<n;i++){\n\tscanf(\"%d%d%d\",p[i],t[i],v[i]);\n\t}\nint rt=0;\nfor(int i=0;i<n;i++){\n\tdouble p1=p[i]/100.,t0=l*1./v[i];\nfor(int j=0;j<=m;j++){\n\trest[i][j]=c[m][j]*(pow(p1,j))*(pow(1-p1,m-j));\n\ttime[i][j]=t0+j*t[i];\n\t}\n}\nfor(int i=0;i<n;i++){\n\tdouble ans=0;\n\tfor(int j=0;j<=m;j++){\n\t\tdouble t=time[i][j],win=1;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(k==i)continue;\n\t\t\tdouble tmp=0;\n\t\t\tfor(int j2=m;j2>=0;j2--){\n\t\t\tif(time[k][j2]<=t)break;\n\t\t\ttmp+=rest[k][j2];\n\t\t}\n\twin*=tmp;\n\t}\n\tans+=win*rest[i][j];\n\t}\nprintf(\"%lf\\n\",ans);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 100005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++) cin>>p[i]>>t[i]>>v[i];\n\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--) sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  \n  \n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=max(0,(int)(s-1.0*l/v[k])+1);\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++) cin>>p[i]>>t[i]>>v[i];\n\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--) sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n\n  for(int i=0;i<n;i++){\n    double ans=0;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n\n      for(int k=0;k<n;k++){\n\tif(i==k)continue;\n\tint idx=max(0,(int)(s-1.0*l/v[k])+1);\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nconst double eps = 1e-6;\nconst int MAXN = 102;\nconst int MAXM = 52;\nint N, M, L;\ndouble P[MAXN];\nint T[MAXN];\nint V[MAXN];\nlli comb[MAXM][MAXM];\n\nvector<double> U[MAXN];\nvector<double> Q[MAXN];\nvector<double> R[MAXN];\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nvoid make() {\n  comb[0][0] = 1;\n  for(int i = 1; i < MAXM; ++i) {\n    for(int j = 0; j <= i; ++j) {\n      comb[i][j] = 0;\n      if(j) comb[i][j] += comb[i-1][j-1];\n      if(j <= i-1) comb[i][j] += comb[i-1][j];\n    }\n  }\n}\n\nint main() {\n  make();\n  while(cin >> N >> M >> L) {\n    for(int i = 0; i < N; ++i) {\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n    for(int i = 0; i < MAXN; ++i) {\n      U[i].clear();\n      Q[i].clear();\n    }\n    for(int i = 0; i < N; ++i) {\n      for(int k = 0; k <= M; ++k) { // rest k times.\n\tU[i].push_back(L/(double)V[i]+(double)T[i]*k);\n\tQ[i].push_back(pow(P[i],k)*pow(1.0-P[i],M-k)*comb[M][k]);\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      double res = 0.0;\n      for(int k = 0; k <= M; ++k) {\n\tdouble tmp = Q[i][k];\n\tfor(int j = 0; j < N; ++j) {\n\t  if(i == j) continue;\n\t  /*\n\t  vector<double>::iterator it = \n\t    lower_bound(U[j].begin(), U[j].end(), U[i][k]);\n\t  */\n\t  double a = 0;\n\t  for(int b = 0; b < U[j].size(); ++b) {\n\t    if(equals(U[j][b], U[i][k]) || U[j][b] < U[i][k]) continue;\n\t    a += Q[j][b];\n\t  }\n\t  tmp *= a;\n\t}\n\tres += tmp;\n      }\n      printf(\"%.8f\\n\", res);\n    }\n    //puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][51],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++)cin >> p[i] >> t[i] >> v[i];\n\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)time[i][j] = (double)l/v[i] + t[i]*j;\n  }\n  \n  double k = 1.0;\n  for(int i=0;i<m;i++)k*=100.0;\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow((double)(100-p[i]),m);\n    prob[i][0] /= k;\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow((double)(100-p[i]),m-j) * pow((double)p[i],j);\n      prob[i][j] /= k;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(prob[i][j] < 0)cout << i << \" \" << j << endl;;\n    }\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j]){\n\t\thoge += prob[k][l];\n\t      }\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tprintf(\"%.8f\\n\",ans);\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\nint N, M, L, P[110], T[110], V[110];\ndouble RP[110][55], RT[110][55];\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\t\t\n\tfor_(i,0,N) {\n\t\tRT[i][0] = V[i] > 0 ? (double)L / (double)V[i] : 1e9;\n\t\tfor_(j,0,M) RT[i][j + 1] = RT[i][j] + (double)T[i];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tvector< double > p(M+1, 1.0), pm(M+1, 1.0);\n\t\t\n\t\tfor_(k,0,M) {\n\t\t\tp[k + 1] = p[k] * (double)P[i] / 100.0;\n\t\t\tpm[k + 1] = pm[k] * (1.0 - (double)P[i] / 100.0);\n\t\t}\n\t\t\n\t\tint mCk = 1;\n\t\t\n\t\tfor_(k,0,M + 1) {\n\t\t\tRP[i][k] =  (double)mCk * p[k] * pm[M - k];\n\t\t\tmCk *= (M - k);\n\t\t\tmCk /= k + 1;\n\t\t}\n\t\t\n\t\tfor_rev(k,M,1) RP[i][k-1] += RP[i][k];\n\t}\n\t\n\tfor_(i,0,N) {\n\t\tif (V[i] == 0) {\n\t\t\tcout << \"0.000000000\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble ans = 0.0;\n\t\t\n\t\tfor_(k,0,M+1) {\n\t\t\tdouble t = RT[i][k];\n\t\t\tdouble p = RP[i][k] - RP[i][k + 1];\n\t\t\t\n\t\t\tfor_(ii,0,N) {\n\t\t\t\tif (ii == i) continue;\n\t\t\t\tint id = upper_bound(RT[ii], RT[ii] + M + 1, t) - RT[ii];\n\t\t\t\t\n\t\t\t\tif (id > M) {\n\t\t\t\t\tp = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tp *= RP[ii][id];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += p;\n\t\t}\n\t\t\n\t\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\nconst int MAX_M = 51;\n\nll comb[MAX_M][MAX_M];\ndouble p[MAX_N];\nint t[MAX_N],v[MAX_N];\ndouble bp[MAX_N][MAX_M];\ndouble prt[MAX_N];\ndouble ans[MAX_N];\n\nint main()\n{\n    int n,m,L;\n\tcin >> n >> m >> L;\n\trep(i,n){\n        cin >> p[i] >> t[i] >> v[i];\n        p[i] /= 100.0;\n\t}\n    comb[0][0] = 1;\n    for(int i = 1;i<=m;i++){\n        comb[i][0] = 1;\n        for(int j=1;j<=i;j++){\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n        }\n    }\n    rep(i,n){\n        if(v[i] == 0){\n            prt[i] = INF;\n        }else{\n            prt[i] = (double)L / v[i];\n        }\n    }\n    rep(i,n){\n        rep(j,m+1){\n            bp[i][j] = 1.0;\n            bp[i][j] *= comb[m][j];\n            rep(k,j){\n                bp[i][j] *= p[i];\n            }\n            rep(k,m-j){\n                bp[i][j] *= (1.0 - p[i]);\n            }\n        }\n    }\n    rep(i,n){\n        bool flag = false;\n        ans[i] = 0.0;\n        rep(j,m+1){\n            double tm = bp[i][j];\n            rep(k,n){\n                double sm = 0.0;\n                if(k != i){\n                    if(prt[i] + j*t[i] >= prt[k]){\n                        if(t[k] == 0){\n                            flag = true;\n                            break;\n                        }\n                        int c = (int)((prt[i] + j*t[i] - prt[k] + EPS) / t[k]) + 1;\n                        if(c > m){\n                            flag = true;\n                            break;\n                        }\n                        for(int l=c;l<=m;l++){\n                            sm += bp[k][l];\n                        }\n                    }else{\n                        sm = 1.0;\n                    }\n                    tm *= sm;\n                }\n            }\n            if(flag){\n                break;\n            }\n            ans[i] += tm;\n        }\n        printf(\"%.10lf\\n\",ans[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define INF INT_MAX/2\n#define EPS 1e-10\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nint fac(int a)\n{\n\tint ret = 1;\n\n\trep(i, 1, a + 1)\n\t{\n\t\tret *= i;\n\t}\n\n\treturn ret;\n}\n\n\n\n\nint aCb(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fac(a) / (fac(a - b) * fac(b));\n}\n\nint main()\n{\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tvi P(N), T(N), V(N);\n\trep(i, 0, N) cin >> P[i] >> T[i] >> V[i];\n\n\tvvd per(N, vd(M+1, 0));\n\trep(i, 0, N)\n\t{\n\t\tdouble p = P[i] / 100.0;\n\t\tdouble pp = 1.0 - p;\n\t\trep(j, 0, M + 1) per[i][j] = pow(pp, M - j) * pow(p, j) * (double)aCb(M, j);\n\t}\n\n\tvvd imos(N, vd(M + 2, 0));\n\trep(i, 0, N)\n\t{\n\t\trep(j, 0, M + 1) imos[i][j] = per[i][j];\n\t\trrep(j, M, 0) imos[i][j] += imos[i][j + 1];\n\t}\n\n\trep(i, 0, N)\n\t{\n\t\tdouble ans = 0;\n\t\trep(j, 0, M + 1)\n\t\t{\n\t\t\tdouble _ans = per[i][j];\n\t\t\tdouble deadline = (double)L / V[i] + (double)T[i] * j;\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tif (i == k) continue;\n\t\t\t\tdouble fastest = (double)L / V[k];\n\t\t\t\tif (deadline < fastest - EPS) continue;\n\n\t\t\t\tif (T[k] == 0)\n\t\t\t\t{\n\t\t\t\t\t_ans = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint minrest = (deadline - fastest + T[k] - 1) / T[k];\n\t\t\t\tdouble test = fastest + T[k] * minrest;\n\t\t\t\tif (abs(deadline - test) < EPS) minrest++;\n\t\t\t\tif (M < minrest) minrest = M;\n\t\t\t\t_ans *= imos[k][minrest];\n\t\t\t}\n\n\t\t\tans += _ans;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+j*pl[i].t,pl[k].v+m*pl[k].t)){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n            if(res[i]<0.000000000001)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\ndouble choose(int n, int k){\n  double res = 1.;\n  for(int i=0;i<k;++i)\n\tres *= (n - i) * 1. / (k - i);\n  return res;\n}\n\ndouble bin(double p, int M, int x, int T){\n  double res = 0.;\n  for(int i=0;i<=M;++i)\n\tres += choose(M,i) * pow(p,i) * pow(1-p,M-i) * i * T;\n  return res;\n}\n\nint main(){\n  int N, M, L; cin >> N >> M >> L;\n  vector<int> P(N), T(N), V(N);\n  for(int i=0;i<N;++i){\n\tcin >> P[i] >> T[i] >> V[i];\n  }\n\n  double S[110][100], prob[110][100];\n  vector<double> ans(N,0);\n  for(int i=0;i<N;++i){\n\tfor(int j=0;j<=M;++j){\n\t  prob[i][j] = choose(M,j) * pow(P[i]/100.,j) * pow((100-P[i])/100.,M-j);\n\t  S[i][j] = L *1./V[i] + j*T[i];\n\t}\n  }\n\n  for(int i=0;i<N;++i)\n\tfor(int j=0;j<=M;++j){\n\t  double p = 1.;\n\t  for(int i1=0;i1<N;++i1){\n\t\tif(i == i1) continue;\n\t\tdouble q = 0.;\n\t\tfor(int j1=0;j1<=M;++j1){\n\t\t  if(S[i1][j1] > S[i][j])\n\t\t\tq += prob[i1][j1];\n\t\t}\n\t\tp *= q;\n\t  }\n\t  ans[i] += p * prob[i][j];\n\t}\n  for(int i=0;i<N;++i)\n\tcout << fixed << setprecision(9) << ans[i] << endl;\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y)\n{\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\nint mod_inverse(int a, int m)\n{\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//int fact[INT_MAX];\n//int mod_fact(int n, int p, int &e)\n//{\n//\te = 0;\n//\tif (n == 0) return 1;\n//\tint res = mod_fact(n / p, p, e);\n//\te += n / p;\n//\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n//\treturn res * fact[n % p] % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (n < 0 || k < 0 || n < k) return 0;\n//\tint e1, e2, e3;\n//\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n//\tif (e1 > e2 + e3) return 0;\n//\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (k < 1) return 1;\n//\tll bunshi = 1, bunbo = 1;\n//\tll ans=1;\n//\tREP(i,n){\n//\t\tbunshi*=n-i;\n//\t\tbunshi%=M;\n//\t}\n//\tREP(i,k){\n//\t\tbunbo*=k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tREP(i,n-k){\n//\t\tbunbo*=n-k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tans=bunshi;\n//\tans*=mod_inverse\n//\treturn mod_inverse(bunshi,\n//\t\n//\tREP(i,n-k){\n//\t\tans*=bunshi;\n//\t\tans/=bunbo;\n//\t\tbunshi--;\n//\t\tbunbo--;\n//\t}\n//\tcerr << n << \", \" << k << \" => \" << ans << endl;\n//\treturn ans;\n//}\n\nll combination(int n,int k){\n\tif (k < 1) return 1;\n\tll ans=1;\n\tFOR(i,1,n-k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = (double)L / V;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\trunner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t]) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint n,m;\ndouble l,p[111],t[111],v[111],ans;\ndouble dp[111][111][111],T[111][111];\n\nint main(){\n  cin>>n>>m>>l;\n  r(i,n)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  r(i,n){\n    dp[i][0][0]=1;\n    r(j,m+1){\n      if(j!=m)r(k,j+1){\n        dp[i][j+1][k+1]+=dp[i][j][k]*p[i];\n        dp[i][j+1][k]+=dp[i][j][k]*(1.0-p[i]);\n      }\n      if(v[i]>0)T[i][j]=l/v[i]+t[i]*j;\n      else T[i][j]=1e9;\n    }\n  }\n  r(i,n){\n    ans=0;\n    if(v[i]==0){\n      cout<<0<<endl;\n      continue;\n    }\n    r(j,m+1){\n      double p=dp[i][m][j];\n      r(k,n)if(k!=i){\n        double sum=0;\n        r(x,m+1) if(T[i][j]<T[k][x]) sum+=dp[k][m][x];\n        p*=sum;\n      }\n      ans+=p;\n    }\n    printf(\"%.9f\\n\",ans);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[2][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nbool zero(double a,double b){\n    if((a-b)<0.00000000001 && (a-b)>-0.00000000001)return true;\n    return false;\n}\n\n\ndouble c[100][100];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[200];\ndouble rp[200][100];\ndouble sp[200][100];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<100;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p,k/2);\n    if(k%2==0)return ret*ret;\n    else return ret*ret*p;\n}\n\ndouble res[200];\ndouble tmp[100];\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in\",\"r\",stdin);\n#endif\n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l)==3){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0;\n            for(j=0;j<=m;j++){\n                tmp[j]=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+j*pl[i].t<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+j*pl[i].t>=l/pl[k].v+m*pl[k].t){\n                            tmp[j]=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+j*pl[i].t-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti++;\n                            tmp[j]*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp[j]*rp[i][j];\n            }\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.5f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n      for(int j=0;j<T;j++){\n\tif(!dp[i][m%2][j])continue;\n\tdouble x=dp[i][m%2][j];\n\tdouble s=j+1.0*l/v[i];\n \tfor(int k=0;k<n;k++){\n\t  if(i==k||!v[k])continue;\n\t  int idx=max(0,(int)(s-1.0*l/v[k]+EPS)+1);\n\t  x*=sum[k][idx];\n\t}\n\tans+=x;\n      }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\n\nint N, M, L, P[200], T[200], V[200];\ndouble zp[200][200], zt[200][200];\n\nInt C[100][100];\n\nint main() {\n    C[0][0] = 1;\n    rep(i, 80) rep(j, 80) C[i+1][j]+=C[i][j], C[i+1][j+1]+=C[i][j];\n\n    scanf(\"%d%d%d\", &N, &M, &L);\n    rep(i, N) scanf(\"%d%d%d\", P+i, T+i, V+i);\n    rep(i, N) rep(j, M+1) {\n        const double p = P[i]/100.0;\n        zt[i][j] = (double)L/V[i] + (double)j*T[i];\n        zp[i][j] = (double)C[M][j] * pow(p, j) * pow(1-p, M-j);\n    }\n    rep(i, N) {\n        double ans = 0;\n        if(V[i]!=0) rep(j, M+1) {\n            double f = 1.0;\n            rep(k, N) if(i!=k) {\n                double p = 0;\n                rep(l, M+1) if(zt[i][j]<zt[k][l]) p += zp[k][l];\n                f *= p;\n            }\n            ans += zp[i][j] * f;\n        }\n        printf(\"%.9f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  cout << fixed << setprecision(5);\n  int N, M, L;\n  cin >> N >> M >> L;\n  vector<int> P(N), T(N), V(N);\n  for (int i = 0; i < N; i++){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n  vector<vector<vector<double>>> dp(N, vector<vector<double>>(M + 1, vector<double>(M + 1, 0)));\n  for (int i = 0; i < N; i++){\n    dp[i][0][0] = 1;\n    double p = (double) P[i] / 100;\n    for (int j = 0; j < M; j++){\n      for (int k = 0; k <= j; k++){\n        dp[i][j + 1][k] += dp[i][j][k] * (1 - p);\n        dp[i][j + 1][k + 1] += dp[i][j][k] * p;\n      }\n    }\n  }\n  for (int i = 0; i < N; i++){\n    double ans = 0;\n    for (int j = 0; j <= M; j++){\n      double t = (double) L / V[i] + j * T[i];\n      double tmp = dp[i][M][j];\n      for (int k = 0; k < N; k++){\n        if (k != i){\n          double sum = 0;\n          for (int l = 0; l <= M; l++){\n            if ((double) L / V[k] + l * T[k] <= t){\n              sum += dp[k][M][l];\n            }\n          }\n          tmp *= 1 - sum;\n        }\n      }\n      ans += tmp;\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\t//printf(\"%.16f\\n\",ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105,INF=1<<20;\nconst double eps=1e-9;\ndouble ti[MAX][MAX],p[MAX][MAX],pre[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M,L;cin>>N>>M>>L;\n    \n    for(int i=0;i<N;i++){\n        memset(pre,0,sizeof(pre));\n        double a,b,c;cin>>a>>b>>c;\n        pre[0][0]=1.0;\n        \n        for(int j=0;j<M;j++){\n            for(int k=0;k<=j;k++){\n                pre[j+1][k]+=pre[j][k]*(100.0-a)/100.0;\n                pre[j+1][k+1]+=pre[j][k]*a/100.0;\n            }\n        }\n        \n        for(int k=0;k<=M;k++){\n            p[i][k]=pre[M][k];\n            if(c==0) ti[i][k]=INF;\n            else ti[i][k]=L/c+b*k;\n        }\n    }\n    \n    for(int i=0;i<N;i++){\n        double ans=0.0;\n        for(int j=0;j<=M;j++){\n            double can=p[i][j];\n            for(int k=0;k<N;k++){\n                if(i==k) continue;\n                double sum=0.0;\n                for(int l=0;l<=M;l++){\n                    if(ti[i][j]<ti[k][l]-eps) sum+=p[k][l];\n                }\n                can*=sum;\n            }\n            ans+=can;\n        }\n        \n        cout<<fixed<<setprecision(25)<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y)\n{\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\nint mod_inverse(int a, int m)\n{\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//int fact[INT_MAX];\n//int mod_fact(int n, int p, int &e)\n//{\n//\te = 0;\n//\tif (n == 0) return 1;\n//\tint res = mod_fact(n / p, p, e);\n//\te += n / p;\n//\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n//\treturn res * fact[n % p] % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (n < 0 || k < 0 || n < k) return 0;\n//\tint e1, e2, e3;\n//\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n//\tif (e1 > e2 + e3) return 0;\n//\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (k < 1) return 1;\n//\tll bunshi = 1, bunbo = 1;\n//\tll ans=1;\n//\tREP(i,n){\n//\t\tbunshi*=n-i;\n//\t\tbunshi%=M;\n//\t}\n//\tREP(i,k){\n//\t\tbunbo*=k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tREP(i,n-k){\n//\t\tbunbo*=n-k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tans=bunshi;\n//\tans*=mod_inverse\n//\treturn mod_inverse(bunshi,\n//\t\n//\tREP(i,n-k){\n//\t\tans*=bunshi;\n//\t\tans/=bunbo;\n//\t\tbunshi--;\n//\t\tbunbo--;\n//\t}\n//\tcerr << n << \", \" << k << \" => \" << ans << endl;\n//\treturn ans;\n//}\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : INT_MAX;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream & operator>>(istream & is, vector<T> &);\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream &, tuple<T...> &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream & is, tuple<T...> & t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream & operator>>(istream & is, tuple<T...> & t){ _it<0>(is, t); return is; }\ntemplate<class T, class U> istream & operator<<(istream & is, pair<T,U> & p){ return is >> p.first >> p.second; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> istream & operator>>(istream & is, vector<T> & v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nconst int MAX_N = 10000; //400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\nll nCr(int n, int r){\n    static bool done[MAX_N+1][MAX_N/2+2];\n    static ll dp[MAX_N+1][MAX_N/2+2]; // 400MB\n    if (n < 0 || r < 0 || n < r) return 0;\n    if (r==0) return 1;\n    if (r > n-r) r = n-r;\n    ll &res = dp[n][r];\n    if (done[n][r]) return res;\n    done[n][r] = true;\n    return res = (nCr(n-1,r-1)+nCr(n-1,r));\n}\n\n\ndouble P[120], T[120], V[120];\n\nint main(){\n    int N,M;\n    double L;\n    while(cin >> N >> M >> L){\n        rep(i,N){\n            cin >> P[i] >> T[i] >> V[i];\n            P[i]/=100;\n        }\n        rep(i,N){\n            double ans = 0;\n            rep(j,M+1){\n                double t = L/V[i]+j*T[i];\n                double x = 1;\n                rep(ii,N)if(i!=ii){\n                    double y = 0;\n                    rep(jj,M+1){\n                        double tt = L/V[ii]+jj*T[ii];\n                        if(t<tt && abs(t-tt)>1e-10){\n                            y += nCr(M,jj)*pow(P[ii],jj)*pow(1-P[ii],M-jj);\n                        }\n                    }\n                    x*=y;\n                }\n                ans += x*nCr(M,j)*pow(P[i],j)*pow(1-P[i],M-j);\n            }\n            printf(\"%.10lf\\n\", ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n  \nint N, M, L;\ndouble P[102], T[102], V[102];\ndouble dp[102][102];\ndouble p[102][102];\n  \nint main(){\n  while(cin >> N >> M >> L){\n    for(int i = 0; i < N; i++){\n      cin >> P[i] >> T[i] >> V[i];\n      P[i] /= 100.0;\n    }\n  \n    for(int k = 0; k < N; k++){\n      memset(dp, 0, sizeof(dp));\n      dp[0][0] = 1.0;\n  \n      for(int i = 0; i < M; i++){\n        for(int j = 0; j <= M; j++){\n          dp[i + 1][j] += dp[i][j] * (1 - P[k]);\n          dp[i + 1][j + 1] += dp[i][j] * P[k];\n        }\n      }\n  \n      for(int j = 0; j <= M; j++){\n        p[k][j] = dp[M][j];\n      }\n    }\n  \n    for(int i = 0; i < N; i++){ //iが勝つ\n      double ans = 0;\n  \n      for(int j = 0; j <= M; j++){ //iがj回休む\n        double ti = (double)j * T[i] + (double)L / V[i];\n        double mul = 1.0;\n  \n        for(int k = 0; k < N; k++){ //kはiに負ける\n          if(k == i) continue;\n  \n          double sum = 0;\n  \n          for(int l = 0; l <= M; l++){ //kはl回休む\n            double tk = (double)l * T[k] + (double)L / V[k];\n            //printf(\"%dが%d休み. %dが%d休み. = %.5f, %.5fn\", i,j,k,l,ti,tk);\n            if(ti >= tk) continue;\n            sum += p[k][l];\n          }\n  \n          mul *= sum;\n        }\n  \n        ans += mul * p[i][j];\n      }\n  \n      printf(\"%.8f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double real;\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\nreal EPS = 1e-9;\n\nconst int MAX_N = 101;\nconst int MAX_M = 53;\n\nconst bool debug = false;\n\nint N, M, L;\nvector<real> P, T, V;\nvoid input() {\n    cin >> N >> M >> L;\n    P.clear(); P.resize(N);\n    T.clear(); T.resize(N);\n    V.clear(); V.resize(N);\n    for (int i = 0; i < N; i++) {\n        cin >> P[i] >> T[i] >> V[i];\n        P[i] /= 100;\n    }\n}\n\nreal X[MAX_N][MAX_M]; // X[i][j] :: i人目がm回休む確率\nreal S[MAX_N][MAX_M]; // S[i][j] :: i人目がm回未満だけ休む確率\n\nvoid init() {\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M; j++) X[i][j] = 0;\n    for (int i = 0; i < N; i++) for (int j = 0; j <= M + 1; j++) S[i][j] = 0;\n    for (int i = 0; i < N; i++) {\n        static real dp[MAX_M][MAX_M];\n        for (int j = 0; j <= M; j++) for (int k = 0; k <= M; k++) dp[j][k] = 0;\n        dp[0][0] = 1;\n        for (int j = 0; j < M; j++) {\n            for (int k = 0; k <= j; k++) {\n                dp[j + 1][k] += dp[j][k] * (1.0 - P[i]);\n                dp[j + 1][k + 1] += dp[j][k] * P[i];\n            }\n        }\n        for (int k = 0; k <= M; k++) {\n            X[i][k] = dp[M][k];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        S[i][0] = 0;\n        for (int j = 0; j <= M; j++) {\n            S[i][j + 1] = S[i][j] + X[i][j];\n        }\n    }\n    if (debug) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j <= M; j++) {\n                printf(\"%3.3Lf \", X[i][j]);\n            }\n            cout << endl;\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for (int i = 0; i < N; i++) { // i人目\n        if (V[i] == 0) {\n            printf(\"%.12Lf\\n\", real(N == 1 ? 1 : 0));\n            continue;\n        }\n        real ans = 0;\n        for (int j = 0; j <= M; j++) { // j回休んだ\n            real p = X[i][j];\n            real time = L / V[i] + j * T[i];\n            for (int k = 0; k < N; k++) { // k人目\n                if (i == k) continue;\n                if (T[k] == 0) {\n                    p *= (L / V[k] + EPS > time);\n                    continue;\n                }\n                // c回以上休む必要\n                int c = int(ceil((time - L / V[k]) / T[k] + EPS) + EPS);\n                if (c > M) {\n                    p = 0;\n                    break;\n                }\n                real pk = 1.0 - S[k][c];\n                p *= pk;\n            }\n            ans += p;\n        }\n        printf(\"%.12Lf\\n\", ans);\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef double Double;\n\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst Double EPS = 1e-9;\n\nint N, M, L;\nint P[110], T[110], V[110];\n\nDouble prob[110][55];\nDouble goal[110][55];\n\nlint combination(int n, int m) {\n\tlint res = 1;\n\tif (2 * m > n) m = n - m;\n\tfor_(i,0,m) res = res * (n - i) / (i + 1);\n\treturn res;\n}\n\nDouble calc_prob(int p, int s) {\n\tDouble res = 1.0;\n\t\n\tDouble time_p = goal[p][s];\n\t\n\tfor_(i,0,N) {\n\t\tif (i == p) continue;\n\t\tDouble sum = 0.0;\n\t\tint ind = upper_bound(goal[i], goal[i] + M + 1, time_p) - goal[i];\n\t\tfor_(j,ind,M+1) sum += prob[i][j];\n\t\tres *= sum;\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,N) {\n\t\tDouble f_goal = (Double)L / (Double)V[i];\n\t\t\n\t\tfor_(j,0,M + 1) {\n\t\t\tprob[i][j] = (Double)combination(M, j) * pow((Double)P[i] / 100.0, j) * pow((Double)(100 - P[i]) / 100.0, M - j);\n\t\t\tgoal[i][j] = f_goal + (Double)j * (Double)T[i];\n\t\t}\n\t}\n\t/*\n\tfor_(i,0,N) {\n\t\tfor_(j,0,M + 1) cout << prob[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\t*/\n\t\n\tfor_(i,0,N) {\n\t\tDouble ansi = 0.0;\n\t\tfor_(j,0,M + 1) ansi += calc_prob(i, j) * prob[i][j];\n\t\tprintf(\"%.9lf\\n\", ansi);\n\t}\n}\n\nint main() {\n\tcin >> N >> M >> L;\n\tfor_(i,0,N) cin >> P[i] >> T[i] >> V[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define eps 0.0000001\n\n\nbool zero(double a,double b){\n    if((a-b)<eps && (a-b)>-eps)return true;\n    return false;\n}\n\ndouble c[110][110];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[210];\ndouble rp[210][110];\ndouble sp[210][110];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<110;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p*p,k/2);\n    if(k%2==0)return ret;\n    else return ret*p;\n}\n\ndouble res[210];\ndouble tmp;\ndouble solve(double p,int m,int n)\n{\n    double ret=1;\n    for(int i=0;i<n;i++)\n    {\n        ret=ret*(m-i);\n        ret=ret/(i+1);\n        ret=ret*p;\n    }\n    for(int i=n;i<m;i++)\n    {\n        ret=ret*(1.0-p);\n    }\n    \n    return ret;\n}\nint main(){\n    \n    //freopen(\"D.in\", \"r\", stdin);\n    //freopen(\"D.out3\", \"w\", stdout);\n    \n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l) != EOF){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            //cout<<pl[i].p<<endl;\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=solve(pl[i].p,(int)m,(int)j);\n                //c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+pl[i].t*(double)j<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+pl[i].t*(double)j>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+pl[i].t*(double)j,l/pl[k].v+m*pl[k].t)){\n                            tmp=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+pl[i].t*(double)j-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp*rp[i][j];\n            }\n            if(res[i]<eps)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n    }\n\n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nint main(){\n    int n,m,l;\n    cin>>n>>m>>l;\n    vector<ld> p(n);\n    vector<int> t(n),v(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>t[i]>>v[i];\n        p[i]/=100;\n    }\n\n    vector<vector<ld>> pos(n);\n    for(int i=0;i<n;i++){\n        vector<vector<ld>> comb(m+1,vector<ld>(m+1,0));\n        comb[0][0]=1;\n        for(int j=0;j<=m;j++){\n            for(int k=0;k<=j;k++){\n                if(k==0){\n                    comb[j][k]=pow(1-p[i],j);\n                }\n                else if(k==j){\n                    comb[j][k]=pow(p[i],j);\n                }\n                else{\n                    comb[j][k]=comb[j-1][k-1]*p[i]+comb[j-1][k]*(1-p[i]);\n                }\n            }\n        }\n        pos[i]=comb[m];\n    }\n    vector<vector<ld>> possum(n,vector<ld>(m+2));\n    for(int i=0;i<n;i++){\n        partial_sum(pos[i].begin(),pos[i].end(),possum[i].begin()+1);\n    }\n\n    vector<ld> res(n);\n    for(int i=0;i<n;i++){\n        for(int x=0;x<=m;x++){\n            ld sc=pos[i][x];\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                ld d=((ld(l)/v[i]-ld(l)/v[j])+x*t[i])/t[j]+1e-9;\n                int y=ceil(d);\n                y=min(max(y,0),m+1);\n                sc*=possum[j][m+1]-possum[j][y];                \n            }\n            res[i]+=sc;\n        }\n    }\n    cout<<setprecision(10)<<fixed;\n    for(int i=0;i<n;i++){\n        cout<<res[i]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nstruct runner{\n\tint t,v;\n\tdouble p;\n};\n\nconst int INF=1000000000;\n\nvector<runner> vr;\ndouble mem[51][51][101];\n// kÍxe·éêÌ\ndouble calcPer(int n,int k,int idx){\n\tif(!EQ(mem[n][k][idx],INF))\n\t\treturn mem[n][k][idx];\n\tdouble p = vr[idx].p;\n\tif(k==0)\n\t\treturn 1.0;\n    return mem[n][k][idx]=(((double)n/k)*calcPer(n-1,k-1,idx)*p);\n}\nint main(){\n\tint n,m,L;\n\tfor(int i = 0; i < 51; i++)\n\t\tfor(int j = 0; j < 51; j++)\n\t\t\tfor(int k = 0; k < 101; k++)\n\t\t\t\tmem[i][j][k]=INF;\n\tcin>>n>>m>>L;\n\tfor(int i = 0; i < n; i++){\n\t\trunner r;\n\t\tint p;\n\t\tcin>>p>>r.t>>r.v;\n\t\tr.p=(double)p/100;\n\t\tvr.push_back(r);\n\t}\n\t// êl¸ÂßÄ¢­\n\tfor(int i = 0; i < n; i++){\n\t\tdouble sumPer=0.0;\n\t\tif(vr[i].v!=0){\n\t\t\t// ©ªª¢­ÂÌêÅxe·é©\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t// »ÝÌxeÅxe·ém¦\n\t\t\t\tdouble cper=calcPer(m,j,i)*pow((double)(1-vr[i].p),m-j);\n                double selfTime=((double)L/vr[i].v)+vr[i].t*j;\n\t\t\t\t// »ê¼êÌGÉÂ¢Ä²×é\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t// ©ª©gÜ½ÍA¬xª0Ìi[Í³·é\n\t\t\t\t\tif(i==k||EQ(vr[k].v,0.0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble enemPer=1.0;\n\t\t\t\t\t// èª¢­ÂÈãÌêÅxeµ½çAÔÉ¤©ð`FbN\n\t\t\t\t\tfor(int l = 0; l <= m; l++){\n                        // GÌBðvZ\n                        double enemyTime=((double)L/vr[k].v)+vr[k].t*l;\n\t\t\t\t\t\t// àµGÌBÔª©ªÌBÔðãñÁ½çI¹\n\t\t\t\t\t\tif(!EQ(enemyTime,selfTime)&&enemyTime>selfTime)\n                            break;\n                        // ±ÌÌêÅxe·ém¦\n                        double p=calcPer(m,l,k)*pow((double)(1-vr[k].p),m-l);\n                        // ¡ñÌxeðæéêÍÂ±ÆªoÈ¢ÌÅA}CiX\n\t\t\t\t\t\tenemPer-=p;\n\t\t\t\t\t}\n\t\t\t\t\t// »ÝcÁÄ¢ém¦ªAGª©ªæèx­B·ém¦\n\t\t\t\t\tcper*=enemPer;\n\t\t\t\t}\n\t\t\t\t// cperª»Ìm¦\n\t\t\t\tsumPer+=cper;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",sumPer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=1020;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n}peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nint C(int n,int m)\n{\n    int a=1,b=1;\n    for(int i=m;i>=m-n+1;i--)\n        a*=i;\n    for(int i=1;i<=n;i++)\n        b*=i;\n    return a/b;\n}\n\ndouble get(int c,int n,double p)\n{\n    return C(c,n)*pow(p,c)*pow((1-p),n-c);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        memset(peo,0,sizeof(peo));\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n            if(!v[i])\n                while(1);\n        }\n            \n        for(int i=0;i<n;i++)\n            for(int j=0;j<=m;j++)\n            {\n                    peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=get(j,m,p[i]/100.0);\n            }\n        for(int i=0;i<n;i++)\n        {\n            if(!v[i]||!L)\n            {\n                printf(\"0.00000000\\n\");\n                continue;\n            }\n            double ans=0;\n            for(int j=0;j<=m;j++)\n            {\n                double tmp=1;\n                for(int k=0;k<n;k++)\n                {\n                    if(k==i||!v[i])\n                        continue;\n                    double t=0;\n                    for(int l=0;l<=m;l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n#define LL long long\ndouble p[200];\nint t[200];\nint v[200];\nLL C[100][100];\ndouble dp[105][55];\n\nint main(){\n    int n,m,l;\n    cin >>  n >> m >> l;\n    for(int i = 0;i < n;i++){\n        int x,tt,vv;\n        scanf(\"%d%d%d\",&x,&tt,&vv);\n        p[i] = x / 100.0,t[i] = tt,v[i] = vv;\n    }\n\n    for(int i = 0;i <= 50;i++){\n        C[i][0] = 1;\n        C[i][i] = 1;\n        for(int j = 1;j < i;j++){\n            C[i][j] = C[i-1][j]+C[i-1][j-1];\n            //cout<<C[i][j] << endl;\n        }\n    }\n    for(int i = 0;i < n;i++){\n        dp[i][m+1] = 0;\n        for(int j = m;j >= 0;j--){ //休息>j次\n            dp[i][j] = dp[i][j+1] + C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n            //cout << dp[i][j] << endl;\n        }\n    }\n\n    for(int i = 0;i < n;i++){\n        double ans = 0;\n        for(int j = 0;j <= m;j++){\n            double ut = l*1.0/v[i] + j*t[i];\n            double pa = C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n            for(int k = 0;k < n;k++){//?k个人的概率\n                if(k != i){\n                    int tim;\n                    if(t[k] == 0){\n                        if(l*1.0/v[k] <= ut){\n                            pa *= 0;\n                        }\n                        else{\n                            pa *= 1;\n                        }\n                        continue;\n                    }\n                    tim = floor((ut-(l*1.0/v[k]))/t[k]);\n                    while((tim*t[k]+l*1.0/v[k]) <= ut) tim++;\n                    if(tim > m){\n                        pa *= 0;\n                    }\n                    else{\n                        pa *= dp[k][tim];\n                    }\n                }\n            }\n            //printf(\"%lf\\n\",pa);\n            ans += pa;\n        }\n        printf(\"%f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define eps (1e-8)\n\nint N,M;\ndouble L;\ndouble P[100],T[100],V[100];\ndouble a[100][100],b[100][100];\n\ndouble mem[100][100];\ndouble ncr(int n,int r){\n  if(mem[n][r]!=-1.0)return mem[n][r];\n  r=min(r,n-r);\n  double res=1.0;\n  for(int i=0;i<r;i++){\n    res=res*(double)(n-i);\n    res=res/(double)(i+1);\n  }\n  return mem[n][r]=res;\n}\n\ndouble solve(int x){\n  double res=0;\n  for(int i=0;i<=M;i++){\n    double p=a[x][i];\n    double d=b[x][i];\n    for(int j=0;j<N;j++){\n      if(x==j)continue;\n      double sum=0;\n      for(int k=0;k<=M;k++){\n        if(b[j][k]<d+eps)continue;\n        sum+=a[j][k];\n      }\n      p*=sum;\n    }\n    res+=p;\n  }\n  return res;\n}\n\nint main(){\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      mem[i][j]=-1.0;\n  \n  cin>>N>>M>>L;\n  for(int i=0;i<N;i++){\n    cin>>P[i]>>T[i]>>V[i];\n    if(V[i]<eps){\n      V[i]=eps;\n    }\n    double p=P[i]/100.0;\n    double q=1.0-p;\n    for(int j=0;j<=M;j++){\n      a[i][j]=ncr(M,j)*pow(p,j)*pow(q,M-j);\n      b[i][j]=L/V[i]+T[i]*j;\n      //cout<<a[i][j]<<' '<<b[i][j]<<endl;\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<N;i++){\n    printf(\"%.10f\\n\",solve(i));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define MAX_N 1000\n\ndouble x[MAX_N][MAX_N];\ndouble t[MAX_N][MAX_N];\nint n, m, l;\nint p[MAX_N][3];\ndouble dp[MAX_N][MAX_N];\ndouble boss[MAX_N];\ndouble kakuritsu;\ndouble res;\n\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int h = 0; h < n; h++) {\n\t\tcin >> p[h][0] >> p[h][1] >> p[h][2];\n\t\t//kakuritsu calc.\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1.0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j] * (100.0 - p[h][0]) / 100.0;\n\t\t\t\tdp[i][j + 1] = dp[i - 1][j] * p[h][0] / 100.0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tx[h][i] = dp[m][i];\n\t\t}\n\t\t//time calc.\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tt[h][i] = 10.0*l / p[h][2];\n\t\t}\n\t}\n\t//kakuritsu calc 2.\n\tfor (int h = 0; h < n; h++) {\n\t\tres = 0.0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\tmemset(boss, 0, sizeof(boss));\n\t\tkakuritsu = 1.0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (t[h][i]>t[j][k]) {\n\t\t\t\t\t\t\tboss[j] += x[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkakuritsu *= boss[j];\n\t\t\t}\n\t\t\tres += kakuritsu*x[h][i];\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(!v[i])continue;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=max(0,(int)(s-1.0*l/v[k]+EPS)+1);\n\tif(-1<s-1.0*l/v[k]+EPS&&s-1.0*l/v[k]+EPS<0)idx--;\n\tif(T<=idx){\n\t  x=0;\n\t  break;\n\t}\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define eps (1e-8)\n\nint N,M;\ndouble L;\ndouble P[100],T[100],V[100];\ndouble a[100][100],b[100][100];\n\ndouble mem[100][100];\ndouble ncr(int n,int r){\n  if(mem[n][r]!=-1.0)return mem[n][r];\n  r=min(r,n-r);\n  double res=1.0;\n  for(int i=0;i<r;i++){\n    res=res*(double)(n-i);\n    res=res/(double)(i+1);\n  }\n  return mem[n][r]=res;\n}\n\ndouble solve(int x){\n  double res=0;\n  for(int i=0;i<=M;i++){\n    double p=a[x][i];\n    double d=b[x][i];\n    for(int j=0;j<N;j++){\n      if(x==j)continue;\n      double sum=0;\n      for(int k=0;k<=M;k++){\n        if(b[j][k]<d+eps)continue;\n        sum+=a[j][k];\n      }\n      p*=sum;\n    }\n    res+=p;\n  }\n  return res;\n}\n\nint main(){\n  for(int i=0;i<100;i++)\n    for(int j=0;j<100;j++)\n      mem[i][j]=-1.0;\n  \n  cin>>N>>M>>L;\n  for(int i=0;i<N;i++){\n    cin>>P[i]>>T[i]>>V[i];\n    assert(V[i]>eps);\n\n    double p=P[i]/100.0;\n    double q=1.0-p;\n    for(int j=0;j<=M;j++){\n      a[i][j]=ncr(M,j)*pow(p,j)*pow(q,M-j);\n      b[i][j]=L/V[i]+T[i]*j;\n      //cout<<a[i][j]<<' '<<b[i][j]<<endl;\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<N;i++){\n    printf(\"%.10f\\n\",solve(i));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N];\nvector<double> A[N],B[N];\n\ndouble mem[M][M];\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  if(r==0||n==r)return 1;\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n    \n    A[i].resize(m+1),B[i].resize(m+1);\n    A[i][0]=B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]);\n      B[i][j]=B[i][j-1]*p[i];\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, m, l, p[111], t[111], v[111]; double r[111][55], dp[55][55];\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++) cin >> p[i] >> t[i] >> v[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) fill(dp[j], dp[j] + m + 1, 0.0);\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j + 1][k] += dp[j][k] * (100 - p[i]) / 100;\n\t\t\t\tdp[j + 1][k + 1] += dp[j][k] * p[i] / 100;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= m; j++) r[i][j] = dp[m][j];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble ret = 0, time1 = l / v[i];\n\t\tfor (int j = 0; j <= m; j++, time1 += t[i]) {\n\t\t\tdouble res = r[i][j];\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (i == k) continue;\n\t\t\t\tdouble sum = 0, time2 = l / v[k];\n\t\t\t\tfor (int l = 0; l <= m; l++, time2 += t[k]) {\n\t\t\t\t\tif (time1 < time2) sum += r[k][l];\n\t\t\t\t}\n\t\t\t\tres *= sum;\n\t\t\t}\n\t\t\tret += res;\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-6)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n      for(int j=0;j<T;j++){\n\tif(!dp[i][m%2][j])continue;\n\tdouble x=dp[i][m%2][j];\n\tdouble s=j+1.0*l/v[i];\n \tfor(int k=0;k<n;k++){\n\t  if(i==k||!v[k])continue;\n\t  int idx=max(0,(int)(s-1.0*l/v[k]+EPS)+1);\n\t  x*=sum[k][idx];\n\t}\n\tans+=x;\n      }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    for(int n, m, l; cin >> n >> m >> l;){\n        vector<double> p(n);\n        vi t(n), v(n);\n        rep(i, n){\n            cin >> p[i] >> t[i] >> v[i];\n            p[i] /= 100.0;\n        }\n\n        // [human][location][num_rest]\n        vector<vector<vector<double>>> dp(n, vector<vector<double>>(m + 1, vector<double>(m + 1, 0.0)));\n        rep(i, n) dp[i][0][0] = 1.0;\n        rep(i, n){\n            rep(j, m){\n                rep(k, m){\n                    dp[i][j + 1][k + 1] += dp[i][j][k] * p[i];\n                    dp[i][j + 1][k]     += dp[i][j][k] * (1.0 - p[i]);\n                }\n            }\n        }\n\n        // [human][num_rest]\n        vector<vector<double>> sum_time(n, vector<double>(m + 1, (double)inf));\n        rep(i, n){\n            if(v[i] == 0) continue;\n            rep(j, m + 1){\n                sum_time[i][j] = (double)l / v[i] + (double)t[i] * j;\n            }\n        }\n\n        vector<double> res(n, 0.0);\n        rep(i, n){\n            if(v[i] == 0) continue;\n            rep(a, m + 1){\n                double prov = dp[i][m][a];\n\n                rep(j, n){\n                    if(i == j) continue;\n                    \n                    double q = 0.0;\n                    rep(b, m + 1){\n                        if(sum_time[i][a] < sum_time[j][b]) q += dp[j][m][b];\n                    }\n\n                    prov *= q;\n                }\n\n                res[i] += prov;\n            }\n        }\n\n        rep(i, n) printf(\"%.9f\\n\", res[i]);\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nconst double eps = 1e-8;\n\nstruct Man {\n\tint p, t, v;\n} man[105];\n\nlong long func(int n,int k)\n{\n\tlong long y=1;\n\tfor(int i=n-k+1,j=2;i<=n;i++){\n\t\ty*=i;\n\t\twhile(y%j==0&&j<=k){\n\t\t\ty=y/j;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn y;\n}\n\ndouble people[105][55];\n\nint main() {\n\tint n, m, l;\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &man[i].p, &man[i].t, &man[i].v);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tpeople[i][j] = (double)func(m, j) * pow(man[i].p/100.0, 1.0*j) * pow(1.0-man[i].p/100.0, 1.0*(m-j));\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tdouble pp = people[i][j];\n\t\t\tdouble time = (1.0 * l / man[i].v) + j * man[i].t;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (k == i) continue;\n\t\t\t\tdouble subans = 0;\n\t\t\t\tfor (int x = 0; x <= m; x++) {\n\t\t\t\t\tdouble subtime = (1.0 * l / man[k].v) + x * man[k].t;\n\t\t\t\t\tif (subtime - time >0) { //won\n\t\t\t\t\t\tsubans += people[k][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpp *= subans;\n\t\t\t}\n\t\t\tans += pp;\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MAXM = 55;\n\n\nint N, M, L;\nint P[MAXN], T[MAXN], V[MAXN];\nlong long C[MAXM][MAXM];\nvoid init() {\n    for(int i = 1; i < MAXM; i++) {\n        C[i][0] = 1;\n        for(int j = 1; j <= i; j++)\n            C[i][j] = C[i][j - 1] * (i - j + 1) / j;\n    }\n}\n\ndouble ans[MAXN];\nvoid calc(int cur_id) {\n    if(V[cur_id] == 0) {\n        ans[cur_id] = 0;\n        return ;\n    }\n    double res = 0;\n    for(int k = 0; k <= M; k++) {\n        double ts = 1.0 * L / V[cur_id] + T[cur_id] * k;\n        double pk = pow(1.0 * P[cur_id] / 100, k) * pow(1 - 1.0 * P[cur_id] / 100, M - k) * C[M][k];\n        double res1 = 1;\n        for(int i = 0; i < N; i++) if(i != cur_id) {\n            if(V[i] == 0) continue;\n            double ti = 1.0 * L / V[i];\n            if(T[i] == 0) {\n                res1 *= (ts - ti) <= 0;\n                continue;\n            }\n            int k = (int)((ts - ti) / T[i] + 1.00000001);\n            if(k < 0) continue;\n            //k++;\n            double pi = 0;\n            for(int j = k; j <= M; j++) {\n                pi += pow(1.0 * P[i] / 100, j) * pow(1 - 1.0 * P[i] / 100, M - j) * C[M][j];\n            }\n            res1 *= pi;\n        }\n        res += res1 * pk;\n    }\n\n    ans[cur_id] = res;\n}\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    init();\n    while(scanf(\"%d%d%d\", &N, &M, &L) != EOF) {\n        for(int i = 0; i < N; i++)\n            scanf(\"%d%d%d\", &P[i], &T[i], &V[i]);\n        for(int i = 0; i < N; i++) {\n            calc(i);\n        }\n        for(int i = 0; i < N; i++)\n            printf(\"%.10f\\n\", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ndouble binom(int m,int k,double p)\n{\n\tdouble x=pow(p,k)*pow(1-p,m-k);\n\tfor(int i=0;i<k;i++)\n\t\tx*=(m-i)/(i+1.);\n\treturn x;\n}\n\nint main()\n{\n\tfor(int n,m,L;cin>>n>>m>>L;){\n\t\tvector<double> ps(n);\n\t\tvector<int> ts(n),vs(n);\n\t\tfor(int i=0;i<n;i++) cin>>ps[i]>>ts[i]>>vs[i],ps[i]/=100;\n\t\t\n\t\tvector<vector<double>> ss(n,vector<double>(m+1));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t\tss[i][j]=binom(m,j,ps[i]);\n\t\t\n\t\tvector<double> res(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tdouble temp=1;\n\t\t\t\tfor(int k=0;k<n;k++) if(k!=i){\n\t\t\t\t\tdouble win=0;\n\t\t\t\t\tfor(int l=0;l<=m;l++)\n\t\t\t\t\t\t// l/vs[i]+j*ts[i] < l/vs[k]+l*ts[k]\n\t\t\t\t\t\tif((L+j*ts[i]*vs[i])*vs[k]<(L+l*ts[k]*vs[k])*vs[i])\n\t\t\t\t\t\t\twin+=ss[k][l];\n\t\t\t\t\ttemp*=win;\n\t\t\t\t}\n\t\t\t\tres[i]+=ss[i][j]*temp;\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tprintf(\"%.8f\\n\",res[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = 0xfffffff;\n\n\ndouble p[101][55],T[101][55];\nint n,m;\ndouble l;\ndouble c[55][55],pp[101],t[101],v[101];\nvoid init()\n{\n\tc[0][0]=1;\n\tfor(int i=1;i<55;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tc[i][j]=c[i-1][j]+c[i-1][j-1];\n\t\t}\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp[j][i]=c[m][i]*pow(pp[j],i)*pow((1-pp[j]),m-i);\n\t\t\tT[j][i]=l/v[j]+i*t[j];\n\t\t\t//cout<<j<<\" \"<<i<<\" \"<<p[j][i]<<\" \"<<T[j][i]<<endl;\n\t\t}\n\t}\n}\ndouble Ans[101];\ndouble tmp=0;\nvoid dfs(int cur,double cmp,int N,double P){\n\tif(N==n){\n\t\ttmp=P;\n\t\treturn ;\n\t}\n\tif(cur==N){\n\t\tdfs(cur,cmp,N+1,P);return ;\n\t}\n\tdouble O=0;\n\tfor(int i=0;i<=m;i++){\n\t\tif(T[N][i]>cmp)O+=p[N][i];\n\t}\n\t//cout<<O<<\" \"<<N<<endl;\n\tdfs(cur,cmp,N+1,P*O);\n}\nint main()\n{\n\tcin>>n>>m>>l;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf%lf%lf\",&pp[i],&t[i],&v[i]);\n\t\tpp[i]/=100.0;\n\t}\n\tinit();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\ttmp=0;\n\t\t\tdfs(i,T[i][j],0,p[i][j]);\n\t\t\t//cout<<tmp<<\" \"<<T[i][j]<<\" \"<<p[i][j]<<endl;\n\t\t\tAns[i]+=tmp;\n\t\t}\n\t\tprintf(\"%.10f\\n\",Ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n#define INF (1<<30)\n#define eps (1e-7)\nconst int N=55;\nint C[N][N],v[N];\ndouble rate[N][N];\nvoid calu()\n{\n\tfor(int i=0;i<N;i++) {C[i][0]=C[0][i]=1;C[i][i]=1;}\n\tfor(int i=2;i<N;i++)\n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n\t}\n}\ndouble calu_rate(int a,int n1,int n2)\n{\n    double res=1,tmp1=(double)a/100,tmp2=(double)(100-a)/100;\n    for(int i=1;i<=n1;i++) res*=tmp1;\n    for(int i=1;i<=n2-n1;i++) res*=tmp2;\n    return res;\n}\nint main()\n{\n\tint n,m,l;\n\twhile(cin>>n>>m>>l)\n\t{\n\t\tcalu();\n\t\tint data[N*2][N*2];\n\t\tdouble mi=1;\n\t\tfor(int i=0;i<m;i++) mi*=2;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tv[i]=c;\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tdata[i][j]=(j*b);\n\t\t\t}\n\t\t\tfor(int j=0;j<=m;j++)\n\t\t\t{\n\t\t\t    rate[i][j]=calu_rate(a,j,m);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdouble res=0;;\n\t\t\tfor(int k=0;k<=m;k++)\n\t\t\t{\n\t\t\t\tdouble total=1;\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tdouble sum1=0,sum2=0;\n\t\t\t\t\tint ind=N;\n\t\t\t\t\tint itime=data[i][k]*v[j]*v[i]+l*v[j];\n\t\t\t\t\tfor(int z=0;z<=m;z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp=(l*v[i]+data[j][z]*v[i]*v[j]);\n\t\t\t\t\t\tif(itime<tmp){\n\t\t\t\t\t\t\tind=z;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int z=ind;z<=m;z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum1+=(double)C[m][z]*rate[j][z];\n\t\t\t\t\t}\n\t\t\t\t\ttotal*=sum1;\n\t\t\t\t}\n\t\t\t\tres+=total*C[m][k]*rate[i][k];\n\t\t\t}\n\t\t\tprintf(\"%.10lf\\n\",res);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include<cstdio>\n#include<algorithm>\n#include <cstring>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint n,m,l,pk[101];\ndouble p[101][3000],t[101][3000];\n\ndouble outt(double p1,int now)\n{\n    int i,j,h; double ta=1;\n    for (i=1;i<=now;i++) ta*=p1;\n    for (i=1;i<=m-now;i++) ta*=(1-p1);\n    h=m-now;\n    if (h>now) h=now;\n    for (i=1;i<=h;i++)\n      ta*=m-i+1;\n    return(ta);\n}\nvoid mmm()\n{\n    int i;\n    for (i=1;i<=n;i++)\n    {\n        double t1,p1,v1;\n        scanf(\"%lf%lf%lf\",&p1,&t1,&v1);\n        p1=p1/100;\n        int j;\n        pk[i]=0;\n        for (j=0;j<=m;j++)\n        {\n            p[i][pk[i]]=outt(p1,j);\n            t[i][pk[i]]=l/v1+j*t1;\n            pk[i]++;\n        }\n    }\n    for (i=1;i<=n;i++)\n    {\n        double win=0;\n        int k,j;\n        for (k=0;k<=pk[i];k++)\n          {\n              double pn=p[i][k],tn=t[i][k];\n              for (j=1;j<=n;j++)\n              if (j!=i)\n              {\n                  int h; double pj=0;\n                  for (h=0;h<=pk[j];h++)\n                    if (t[j][h]>tn) pj+=p[j][h];\n                 pn*=pj;\n              }\n              win+=pn;\n          }\n        cout<<fixed<<setprecision(8)<<win<<endl;\n    }\n}\n\n\nmain()\n{\n    scanf(\"%d%d%d\",&n,&m,&l);\n    mmm();\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\nconst int MAX_M = 51;\n\nll comb[MAX_M][MAX_M];\ndouble p[MAX_N];\nint t[MAX_N],v[MAX_N];\ndouble bp[MAX_N][MAX_M];\ndouble prt[MAX_N];\ndouble ans[MAX_N];\n\nint main()\n{\n    int n,m,L;\n\tcin >> n >> m >> L;\n\trep(i,n){\n        cin >> p[i] >> t[i] >> v[i];\n        p[i] /= 100.0;\n\t}\n    comb[0][0] = 1;\n    for(int i = 1;i<=m;i++){\n        comb[i][0] = 1;\n        for(int j=1;j<=i;j++){\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n        }\n    }\n    rep(i,n){\n        prt[i] = (double)L / v[i];\n    }\n    rep(i,n){\n        rep(j,m+1){\n            bp[i][j] = 1.0;\n            bp[i][j] *= comb[m][j];\n            rep(k,j){\n                bp[i][j] *= p[i];\n            }\n            rep(k,m-j){\n                bp[i][j] *= (1.0 - p[i]);\n            }\n        }\n    }\n    rep(i,n){\n        bool flag = false;\n        ans[i] = 0.0;\n        rep(j,m+1){\n            double tm = bp[i][j];\n            rep(k,n){\n                double sm = 0.0;\n                if(k != i){\n                    if(prt[i] + j*t[i] >= prt[k]){\n                        int c = (int)((prt[i] + j*t[i] - prt[k] + EPS) / t[k]) + 1;\n                        if(c > m){\n                            flag = true;\n                            break;\n                        }\n                        for(int l=c;l<=m;l++){\n                            sm += bp[k][l];\n                        }\n                    }else{\n                        sm = 1.0;\n                    }\n                    tm *= sm;\n                }\n            }\n            if(flag){\n                break;\n            }\n            ans[i] += tm;\n        }\n        printf(\"%.10lf\\n\",ans[i]);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst int N = 105;\nconst int M = 55;\n\nint n, m, l, t[N], v[N];\ndouble dp[N][M];\ndouble sum[N][M];\n\nvoid gao(double p, double dp[], double sum[]) {\n\tdouble q = 1-p, f[2][M] = {};\n\tf[0][0] = 1;\n\tfor (int i = 1, x = 1; i <= m; ++i, x^=1) {\n\t\tf[x][0] = f[!x][0] * q;\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tf[x][j] = f[!x][j-1] * p + f[!x][j] * q;\n\t\t}\n\t}\n\tdp[m+1] = sum[m+1] = 0;\n\tfor (int i = m, x = m & 1; i >= 0; --i) {\n\t\tsum[i] = sum[i+1] + (dp[i] = f[x][i]);\n\t}\n}\n\n// return true if (i,j) < (x,y)\nbool faster(int i, int j, int x, int y) {\n\treturn l*v[x] + t[i]*j*v[i]*v[x] < l*v[i] + t[x]*y*v[i]*v[x];\n}\n\nint binsearch(int i, int j, int k) {\n\tint l = -1, r = m+1, mid;\n\twhile (l + 1 < r) {\n\t\tmid = (l+r)>>1;\n\t\tfaster(i,j,k,mid) ? r=mid : l=mid;\n\t}\n\treturn r;\n}\n\nvoid debug(double a[], int s, int t) {\n\tfor(int i=s;i<t;++i)printf(\"%f \", a[i]);puts(\"\");\n}\n\nint main() {\n\twhile (3==scanf(\"%d%d%d\", &n, &m, &l)) {\n\t\tfor (int p,i = 0; i < n; ++i) {\n\t\t\tscanf(\"%d%d%d\", &p, &t[i], &v[i]);\n\t\t\tgao(p/100., dp[i], sum[i]);\n//\t\t\tdebug(dp[i], 0, m+2);\n//\t\t\tdebug(sum[i], 0, m+2); \n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble ans = 0;\n\t\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\t\tdouble p = dp[i][j];\n\t\t\t\tfor (int r,k = 0; k < n; ++k) {\n\t\t\t\t\tif (i == k) continue;\n\t\t\t\t\tr = binsearch(i, j, k);\n\t\t\t\t\tp *= sum[k][r];\n\t\t\t\t}\n\t\t\t\tans += p;\n\t\t\t}\n\t\t\tprintf(\"%.10f\\n\", ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] == 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k];\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(!v[i])continue;\n    for(int j=0;j<T;j++){\n      if(!dp[i][m%2][j])continue;\n      double x=dp[i][m%2][j];\n      double s=j+1.0*l/v[i];\n      for(int k=0;k<n;k++){\n\tif(i==k||!v[k])continue;\n\tint idx=(int)(s-1.0*l/v[k]+EPS);\n\tif(s-1.0*l/v[k]+EPS<0)idx=0;\n\telse idx++;\n\tif(T<=idx){\n\t  x=0;\n\t  break;\n\t}\n\tx*=sum[k][idx];\n      }\n      ans+=x;\n    }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <memory.h>\n\n#define eps 5e-6\n\nusing namespace std;\n\nstruct point\n{\n    double time,possible;\n    int num;\n};\n\nint n,m,l,i,j,k,last,g[100][100],ii;\ndouble a,b,c,p,q,ans[200],f[200],r;\npoint s[10000];\n\nvoid insert(double time,double possible,int num)\n{\n    s[k].time=time;\n    s[k].possible=possible;\n    s[k].num=num;\n    k++;\n}\n\nbool cmp(point a,point b)\n{\n    return a.time>b.time;\n}\n\ndouble pow(double a,int x)\n{\n    double ans=1.0,p=a;\n    while(x)\n    {\n        if(x&1)ans=ans*p;\n        x=x>>1;\n        p=p*p;\n    }\n    return ans;\n}\n\nint main()\n{\n    for(i=0;i<60;i++)\n    {\n        g[i][0]=1;\n        g[i][i]=1;\n        for(j=1;j<i;j++)\n            g[i][j]=g[i-1][j]+g[i-1][j-1];\n    }\n    scanf(\"%d%d%d\",&n,&m,&l);\n    k=0;\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%lf%lf%lf\",&a,&b,&c);\n        if(fabs(a-0.0)<eps)\n        {\n            insert(l*1.0/c,1.0,i);\n            continue;\n        }\n        else if(fabs(a-100.0)<eps)\n        {\n            insert(l*1.0/c+b*m,1.0,i);\n            continue;\n        }\n        p=a/100.0;\n        q=1.0-p;\n        a=l*1.0/c;\n        r=1.0;\n        for(j=0;j<=m;j++)\n        {\n            insert(a+j*b,g[m][j]*pow(p,j)*pow(q,m-j),i);\n        }\n    }\n    memset(f,0,sizeof(f));\n    sort(s,s+k,cmp);\n    j=0;\n    memset(ans,0,sizeof(ans));\n    for(i=0;i<k;i++)\n    {\n        while(j<i && s[j].time-eps>s[i].time)\n        {\n            f[s[j].num]+=s[j].possible;\n            j++;\n        }\n        p=s[i].possible;\n        for(ii=0;ii<n;ii++)\n        {\n            if(ii==s[i].num)continue;\n            p=p*f[ii];\n        }\n        ans[s[i].num]+=p;\n    }\n    p=0;\n    for(i=0;i<n;i++)\n        printf(\"%.8f\\n\",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nint n,m;\ndouble l;\ndouble p[100],t[100],v[100];\ndouble comb[60][60];\ndouble kaku[100][60];\ndouble kaku2[100][60];\nvector<pal> ve[110];\ndouble bekijou(double r,double k){\n\tif(r==0) return 0;\n\tif(k==1) return r;\n\treturn bekijou(r,k-1)*r;\n}\n\n   signed main(){\ncin>>n>>m>>l;\n   \tif(n==1){\n   \tcout<<1<<endl;\n   \t\treturn 0;\n   \t}\n   \tfor(int i=0;i<60;i++)comb[i][0]=1.0,comb[i][i]=1.0;\n   \t\n   \tfor(int k=1;k<60;k++)for(int j=1;j<k;j++) comb[k][j]=comb[k-1][j-1]+comb[k-1][j];\n   \t\n   \tfor(int i=0;i<n;i++){\n   \t\tcin>>p[i]>>t[i]>>v[i];\n   \t\tp[i]/=100;\n   \t}\n   \t\n   \tfor(int i=0;i<n;i++)for(int j=0;j<=m;j++){\n   \t\tif(j==0)kaku[i][j]=bekijou(1-p[i],m);\n   \t\telse if(j==m) kaku[i][j]=bekijou(p[i],m);\n   \t\telse{\n   \t\t\tkaku[i][j]=comb[m][j]*bekijou(p[i],j)*bekijou(1.0-p[i],m-j);\n   \t\t}\n   \t\tkaku2[i][j]=kaku[i][j];\n   \t//\tcout<<i<<\" \"<<l/v[i]+j*t[i]<<\" \"<<kaku2[i][j]<<endl;\n   \t\tif(j>0) kaku[i][j]+=kaku[i][j-1];\n   \t\tve[i].pb(mp(l/v[i]+j*t[i],kaku[i][j]));\n   \t}\n \t\n   \tfor(int i=0;i<n;i++){\n   \t\tdouble ans=0;\n   \t\t\n   \t\tfor(int j=0;j<=m;j++){\n   \t\t\tdouble d=1;\n   \t\t\t\n   \t\t\tfor(int l=0;l<n;l++)if(l!=i){\n   \t\t\t\tpal er=mp(ve[i][j].first,inf);\n   \t\t\t\tint r=lower_bound(ve[l].begin(),ve[l].end(),er)-ve[l].begin();\n   \t\t\t\tif(r!=0){\n   \t\t\t\t\td*=1.0-ve[l][r-1].second;\n   \t\t\t\t}\n   \t\t\t}\n   \t//\t\tcout<<i<<\" \"<<j<<\" \"<<d<<endl;\n   \t\t\tans+=kaku2[i][j]*d;\n   \t\t}\n   \t\tprintf(\"%.10lf\\n\",ans);\n   \t}\n   \t\n   \t\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m,l;\nint p[110],t[110],v[110];\n\ndouble rt[110][55];\ndouble rp[110][55];\n\ndouble com[55][55];\ndouble ans[110];\n\nvoid init(){\n\trep(i,55)rep(j,i+1){\n\t\tif(j==0||j==i)\n\t\t\tcom[i][j]=1.0;\n\t\telse\n\t\t\tcom[i][j]=com[i-1][j]+com[i-1][j-1];\n\t}\n}\n\nint main(void){\n\tinit();\n\tcin >> n >> m >> l;\n\trep(i,n) cin >> p[i] >> t[i] >> v[i];\n\trep(i,n)rep(j,m+1){\n\t\trt[i][j]=1.0*l/v[i]+1.0*j*t[i];\n\t\trp[i][j]=com[m][j]*pow(1.0*p[i]/100.0,j)*pow( (100.0-p[i])/100.0,m-j);\n\t}\n\n\trep(i,n){\n\t\tans[i]=0.0;\n\t\trep(j,m+1){\n\t\t\tdouble prod=1.0;\n\t\t\trep(a,n){\n\t\t\t\tif(a==i) continue;\n\t\t\t\tdouble sum=0.0;\n\t\t\t\trep(b,m+1) if(rt[i][j]<rt[a][b]) sum+=rp[a][b];\n\t\t\t\tprod*=sum;\n\t\t\t}\n\t\t\tans[i]+=rp[i][j]*prod;\n\t\t}\n\t}\n\n\n\tcout.precision(20);\n\trep(i,n) cout << fixed << ans[i]  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[100][100] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tif(rest == 0) cul *= 1;\n\t\t\t\telse if(rest > m) cul *= 0;\n\t\t\t\telse cul *= 1 - c[k][rest];\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\t//show(cul)\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 105;\nconst double EPS = 1e-12;\n\nint n, m, l;\nint P[MAXN], T[MAXN], V[MAXN];\ndouble f[MAXN][55][55];\ndouble sumf[MAXN][55];\n\nvoid gao() {\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 0; i < n; ++i) {\n\t\tf[i][0][0] = 1;\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tf[i][j][0] = f[i][j-1][0] * (1-1.0*P[i]/100);\n\t\t\t\t//printf(\"%d %d %d: %lf\\n\",i,j,0,f[i][j][0]);\n\t\t\tfor (int k = 1; k <= j; ++k) {\n\t\t\t\tf[i][j][k] = f[i][j-1][k]*(1-1.0*P[i]/100) + f[i][j-1][k-1]*1.0*P[i]/100;\n\t\t\t\t//printf(\"%d %d %d: %lf\\n\",i,j,k,f[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(sumf, 0, sizeof(sumf));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = m; j >= 0; --j) {\n\t\t\tsumf[i][j] = sumf[i][j+1] + f[i][m][j];\n\t\t//\tprintf(\"%lf \",sumf[i][j]);\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 0; i < n; ++i) {\n\t\tdouble ans = 0;\n\t\tif (V[i] == 0) {\n\t\t\tprintf(\"0.00000000\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= m; ++k) {\n\t\t\tdouble Ti = l*1.0 / V[i] + k * T[i];\n\t\t\t//printf(\"Ti: %lf\\t\",Ti);\n\t\t\tdouble z = 1;\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (j != i) {\n\t\t\t\t\tdouble tmp;\n\t\t\t\t\tif (T[j] == 0) {\n\t\t\t\t\t\tif (1LL*l*V[i] <= l*V[j] + 1LL*k*T[i]*V[i]*V[j]) z=0;\n\t\t\t\t\t\ttmp = -10;\n\t\t\t\t\t}\n\t\t\t\t\telse tmp = (Ti - l*1.0/V[j]) / T[j];\n\t\t\t\t\tint kj = (int)ceil(tmp-EPS); \n\t\t\t\t\tif (fabs(tmp - kj) < EPS) ++kj;\n\t\t\t\t\tif (kj < 0) kj = 0;\n\t\t\t\t\tz *= sumf[j][kj];\n\t\t\t\t\t//printf(\"j: %d %d %lf\\n\",j,kj,sumf[j][kj]);\n\t\t\t\t}\n\t\t\tans += z*f[i][m][k];\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d%d%d\", P+i, T+i, V+i);\n\t}\n\tgao();\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <string>\nusing namespace std;\n#define min(a,b) a<b?a:b;\n#define max(a,b) a>b?a:b;\n#define LL long long\nconst int N = 210;\nconst double eps = 1e-8;\ndouble dp[N][N],p[N][N],ans[N];//莠コ?御シ第?蜃?惻縲よ慮髣エ?梧ヲら紫\ndouble zu[N][N];\nint n;\nstruct node{\n\tdouble p,t,v;\n}data[N];\nvoid zuhe()\n{\n\tmemset(zu,0,sizeof(zu));\n\tint i,j;\n\tfor(i=0;i<=50;i++)\n\t{\n\t\tzu[i][0]=1;\n\t\tzu[i][1]=i;\n\t}\n\tfor(i=2;i<=50;i++)\n\t\tfor(j=1;j<=i;j++)\n\t\t\tzu[i][j]=zu[i-1][j]+zu[i-1][j-1];\n}\nint main()\n{\n\tint i,j,z,k,m,l;\n\tdouble sum,res,time1,time2;\n\tzuhe();\n\twhile(scanf(\"%d%d%d\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t\tscanf(\"%lf%lf%lf\",&data[i].p,&data[i].t,&data[i].v);\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t\tp[i][j]=zu[m][j]*pow(data[i].p/100.0,j*1.0)*pow((1-data[i].p/100.0),(m-j)*1.0);\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tans[i]=0;\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tres=p[i][j];\n\t\t\t\ttime1=j*data[i].t+l/data[i].v;\n\t\t\t\tfor(z=1;z<=n;z++)\n\t\t\t\t{\n\t\t\t\t\tsum=0;\n\t\t\t\t\tif(z==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor(k=0;k<=m;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttime2=k*data[z].t+l/data[z].v;\n\t\t\t\t\t\tif(time1<time2-eps)\n\t\t\t\t\t\t\tsum+=p[z][k];\n\t\t\t\t\t}\n\t\t\t\t\tres*=sum;\n\t\t\t\t}\n\t\t\t\tans[i]+=res;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tprintf(\"%.8lf\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n\n\n\n/*\n2 2 50\n30 50 1\n30 50 2\n\n2 1 100\n100 100 10\n0 100 1\n\n3 1 100\n50 1 1\n50 1 1\n50 1 1\n\n2 2 50\n30 0 1\n30 50 2\n\n  */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tif(p[i] != 0) p[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\tif(p[i] != 1) run_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ndouble f(int L, int V, int T, int j) {\n\treturn (double)L / V + j * T;\n}\n\nint main() {\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<int> P(N), T(N), V(N);\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> P[i] >> T[i] >> V[i];\n\tvector< vector<double> > a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tvector< vector<double> > dp(M + 1, vector<double>(M + 1));\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 0; j < M; j++)\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j + 1][k] += (1 - P[i] / 100.0) * dp[j][k];\n\t\t\t\tdp[j + 1][k + 1] += P[i] / 100.0 * dp[j][k];\n\t\t\t}\n\t\ta[i] = dp[M];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tdouble pro = 1;\n\t\t\tfor (int _i = 0; _i < N; _i++) {\n\t\t\t\tif (_i == i) continue;\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int _j = 0; _j <= M; _j++)\n\t\t\t\t\tif (f(L, V[i], T[i], j) < f(L, V[_i], T[_i], _j) - EPS)\n\t\t\t\t\t\tsum += a[_i][_j];\n\t\t\t\tpro *= sum;\n\t\t\t}\n\t\t\tans += a[i][j] * pro;\n\t\t}\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-6)\n#define T 6005\n#define N 105\n#define M 55\nusing namespace std;\nint n,m,l,p[N],t[N],v[N];\ndouble dp[N][2][T],sum[N][T];\n \nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)\n    cin>>p[i]>>t[i]>>v[i];\n  for(int i=0;i<n;i++){\n    dp[i][0][0]=1;\n    for(int j=0;j<m;j++){\n      for(int k=0;k<T;k++){\n\tif(!dp[i][j%2][k])continue;\n\tdp[i][(j+1)%2][k]+=dp[i][j%2][k]*(100.0-p[i])/100.0;\n\tdp[i][(j+1)%2][k+t[i]]+=dp[i][j%2][k]*p[i]/100.0;\n      }\n      for(int k=0;k<T;k++)dp[i][j%2][k]=0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    for(int j=T-2;j>=0;j--)\n      sum[i][j]=sum[i][j+1]+dp[i][m%2][j];\n  for(int i=0;i<n;i++){\n    double ans=0;\n    if(v[i])\n      for(int j=0;j<T;j++){\n\tif(!dp[i][m%2][j])continue;\n\tdouble x=dp[i][m%2][j];\n\tdouble s=j+1.0*l/v[i];\n \tfor(int k=0;k<n;k++){\n\t  if(i==k||!v[k])continue;\n\t  int idx=max(0,(int)(s-1.0*l/v[k]-EPS)+1);\n\t  x*=sum[k][idx];\n\t}\n\tans+=x;\n      }\n    printf(\"%.8f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <string.h>\nusing namespace std;\n#define PI 3.1415926535897932384626433832795028\n#define N 510\n#define M 10010\n#define inf 1000000000\ntypedef long long LL;\ndouble p[109][55],tt[109][55];\ndouble c[55][55];\nvoid set()\n{\n\tc[0][0]=0;\n\tfor(int i=1;i<=51;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j>=1) c[i][j]=c[i][j-1]*((double)(i-j+1.0)/j);\n\t\t\telse c[i][j]=1;\n\t//\t if(i==50)\tprintf(\"%.0lf \",c[i][j]);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n}\ndouble Pow(int a,int b,double h)\n{\n\tdouble pp=1.0;\n\tint j;\n\tfor(j=1;j<=b;j++) pp*=h;\n\tfor(j;j<=a;j++) pp*=(1.0-h);\n\treturn pp*c[a][b];\n}\n\nint main()\n{\n\tint n,m,i,j;\n\tdouble l,pp,t,v;\n\tset();\n\twhile(scanf(\"%d %d %lf\",&n,&m,&l)!=EOF)\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%lf %lf %lf\",&pp,&t,&v);\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tp[i][j]=Pow(m,j,pp/100.0);\n\t\t\t\ttt[i][j]=l/v+j*t;\n\t\t\t//\tprintf(\"%.8lf \",p[i][j]);\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tdouble ans=0;\n\t\t\tfor(j=0;j<=m;j++)\n\t\t\t{\n\t\t\t\tdouble ans1=p[i][j];\n\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(k==i) continue;\n\t\t\t\t\tdouble q=0.0;\t  \n\t\t\t\t\tfor(int  x=m;x>=0;x--){\n\t\t\t\t\t\tif(tt[k][x]>tt[i][j]) q+=p[k][x];\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tans1*=q;\n\t\t\t\t}\n\t\t\t\tans+=ans1;\n\t\t\t}\n\t\t\tprintf(\"%.12lf\\n\",ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n#include <tuple>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M, L;\n\nvector<tuple<int, int, int>> vs;\n\ndouble P[111][111];\ndouble T[111][111];\n\nnamespace math { namespace combination {\n\n#define COMBINATION_MAX 200\nusing return_type = ll;\n\nnamespace memorized { namespace combination { enum { max_value = COMBINATION_MAX }; bool __computed = false; inline bool computed() {if(__computed) { return true; } else { __computed = true; return false; }} return_type dp[max_value][max_value];} }\n\nreturn_type comb(int N, int K) {\n  using memorized::combination::dp;\n  if(memorized::combination::computed()) { return dp[N][K]; }\n\n  rep(i, memorized::combination::max_value) {\n    dp[i][0] = 1;\n    REP(j, 1, i+1) {\n      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n//      dp[i][j] %= MOD;\n    }\n  }\n  return dp[N][K];\n}}}\n\nvoid solve() {\n  rep(i, N) {\n    rep(j, M+1) {\n      P[i][j] = pow(get<0>(vs[i]) * 0.01, j) * pow((100-get<0>(vs[i])) * 0.01, M - j) * math::combination::comb(M, j);\n      if(j) T[i][j] = T[i][j-1] + get<2>(vs[i]);\n      else T[i][0] = 1.0 * L / get<1>(vs[i]);\n    }\n  }\n\n  rep(i, N) {\n    double res = 0;\n\n    if(get<1>(vs[i]) == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    rep(j, M+1) {\n      double losers_prob = 1.0;\n      rep(k, N) {\n        if(i == k) continue;\n        double sum = 0.0;\n        rep(l, M+1) {\n          if(T[i][j] < T[k][l]) sum += P[k][l];\n        }\n        losers_prob *= sum;\n      }\n      res += losers_prob * P[i][j];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n\n  cin >> N >> M >> L;\n  rep(i, N) {\n    int p, t, v; cin >> p >> t >> v;\n    vs.push_back(make_tuple(p, v, t));\n  }\n\n  N = vs.size();\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tdouble P,T,V;\n};\n\nint calc(int x,int y){\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn calc(y,x%y);\n\t}\n}\n\nint main(){\n\n\tint N,M;\n\tdouble L;\n\n\tscanf(\"%d %d %lf\",&N,&M,&L);\n\n\n\tint mCk[M+1][M+1];\n\tfor(int i = 0; i <= M; i++){\n\t\tfor(int k = 0; k <= M; k++)mCk[i][k] = 1;\n\t}\n\n\tint bunshi[51],bunbo[51],common;\n\n\tfor(int k = 0; k <= M; k++){\n\n\t\tfor(int a = 0; a < k; a++)bunshi[a] = (M-a);\n\t\tfor(int a = 0; a < k; a++)bunbo[a] = (k-a);\n\n\t\tfor(int shita = 0; shita < k; shita++){\n\t\t\tfor(int ue = 0; ue < k; ue++){\n\n\t\t\t\tif(bunshi[ue] >= bunbo[shita]){\n\t\t\t\t\tcommon = calc(bunshi[ue],bunbo[shita]);\n\t\t\t\t}else{\n\t\t\t\t\tcommon = calc(bunbo[shita],bunshi[ue]);\n\t\t\t\t}\n\t\t\t\tbunshi[ue] /= common;\n\t\t\t\tbunbo[shita] /= common;\n\t\t\t}\n\t\t}\n\n\t\tfor(int a = 0; a < k; a++)mCk[k][a] = bunshi[a];\n\t}\n\n\tInfo info[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].P,&info[i].T,&info[i].V);\n\t\tinfo[i].P /= 100.0;\n\t}\n\n\tdouble time[N][M+1];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k <= M; k++){\n\t\t\ttime[i][k] = L/info[i].V + k*info[i].T;\n\t\t}\n\t}\n\n\tdouble table[N][M+1],base;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k <= M; k++){\n\t\t\tbase = 1.0;\n\t\t\tfor(int a = 0; a < k; a++){\n\t\t\t\tbase *= info[i].P;\n\t\t\t}\n\t\t\tfor(int a = 0; a < M-k; a++){\n\t\t\t\tbase *= (1.0-info[i].P);\n\t\t\t}\n\t\t\tfor(int a = 0; a < k; a++){\n\t\t\t\tbase *= mCk[k][a];\n\t\t\t}\n\t\t\ttable[i][k] = base;\n\t\t}\n\t}\n\n\n\tdouble win,base_time,tmp,tmp2;\n\tbool FLG;\n\n\tfor(int i = 0; i < N; i++){\n\t\twin = 0.0;\n\n\t\tFLG = true;\n\t\tfor(int k = 0; k <= M; k++){\n\n\t\t\tbase_time = time[i][k];\n\t\t\ttmp = 1.0;\n\t\t\tfor(int enemy = 0; enemy < N; enemy++){\n\t\t\t\tif(enemy == i)continue;\n\n\t\t\t\tFLG = false;\n\t\t\t\ttmp2 = 0.0;\n\t\t\t\tfor(int a = 0; a <= M; a++){\n\t\t\t\t\tif(time[enemy][a] > base_time){\n\t\t\t\t\t\ttmp2 += table[enemy][a];\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t\ttmp *= tmp2;\n\t\t\t}\n\t\t\tif(!FLG){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\twin += table[i][k]*tmp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\",win);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\trep(j,m + 1){\n\t\t\tdouble rest_p = 1;\n\t\t\tdouble run_p = 1;\n\t\t\tfor(int k = 0; k < j; k++){\n\t\t\t\trest_p *= p[i];\n\t\t\t}\n\t\t\tfor(int k = j; k < m; k++){\n\t\t\t\trun_p *= (1 - p[i]);\n\t\t\t}\n\t\t\tc[i][j] = rest_p * run_p * pas[m][j];\n\t\t}\n\t}\n\n\n\tvector<double> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = INF;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\n\t\t\t\tif(t[k] < 1e-10){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = (time - base_time[k]) / t[k] - 100;\n\t\t\t\twhile(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdouble sum = 0;\n\t\t\t\trange(l,rest,m + 1) sum += c[k][l];\n\t\t\t\tcul *= sum;\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\tans += cul;\n\t\t}\n\t\tcout << fixed << setprecision(8)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tif(rest > m){\n\t\t\t\t\tcul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nstatic const double EPS = 1e-7;\n\nstruct runner {\n  int p, t, v;\n};\n\nint main()\n{\n  static double comb[55][55];\n  for (int i = 0; i <= 50; i++) {\n    comb[i][0] = 1.0;\n  }\n  for (int i = 1; i <= 50; i++) {\n    for (int j = 1; j <= i; j++) {\n      comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n    }\n  }\n\n  int N, M, L;\n  cin >> N >> M >> L;\n  vector<runner> v;\n  bool all_zero = true;\n  for (int i = 0; i < N; i++) {\n    runner r;\n    cin >> r.p >> r.t >> r.v;\n    v.push_back(r);\n    if (r.v != 0) {\n      all_zero = false;\n    }\n  }\n\n  if (all_zero) {\n    for (int i = 0; i < N; i++) {\n      cout << \"0.0000000\" << endl;\n    }\n    return 0;\n  }\n\n  vector<vector<double> > ps(N, vector<double>(M+1));\n  vector<vector<double> > ps_integral(N, vector<double>(M+1));\n  vector<vector<double> > ts(N, vector<double>(M+1));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= M; j++) {\n      ps[i][j] = pow(v[i].p/100.0, j) * pow((100-v[i].p)/100.0, M-j) * comb[M][j];\n      if (j == 0) {\n        ps_integral[i][j] = ps[i][j];\n      } else {\n        ps_integral[i][j] = ps_integral[i][j-1] + ps[i][j];\n      }\n      ts[i][j] = double(L)/v[i].v + v[i].t*j;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    double ans = 0.0;\n    for (int j = 0; j <= M; j++) {\n      double p = 1.0;\n      for (int k = 0; k < N; k++) {\n        if (k != i) {\n          int l = lower_bound(ts[k].begin(), ts[k].end(), ts[i][j]+EPS) - ts[k].begin();\n          if (l != 0) {\n            p *= (1.0 - ps_integral[k][l-1]);\n          }\n        }\n      }\n      ans += ps[i][j] * p;\n    }\n    printf(\"%.6f\\n\", ans + EPS);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nstruct runner{\n\tint t,v;\n\tdouble p;\n};\n\nconst int INF=1000000000;\n\nvector<runner> vr;\ndouble mem[101][51][101];\n// kÍxe·éêÌ\ndouble calcPer(int n,int k,int idx){\n\tif(!EQ(mem[n][k][idx],INF))\n\t\treturn mem[n][k][idx];\n\tdouble p = vr[idx].p;\n\tif(k==0)\n\t\treturn 1.0;\n\telse{\n\t\treturn mem[n][k][idx]=(((double)n/k)*calcPer(n-1,k-1,p)*p);\n\t}\n}\n\nint main(){\n\n\tint n,m,L;\n\tfor(int i = 0; i < 101; i++)\n\t\tfor(int j = 0; j < 51; j++)\n\t\t\tfor(int k = 0; k < 101; k++)\n\t\t\t\tmem[i][j][k]=INF;\n\n\tcin>>n>>m>>L;\n\tfor(int i = 0; i < n; i++){\n\t\trunner r;\n\t\tint p;\n\t\tcin>>p>>r.t>>r.v;\n\t\tr.p=(double)p/100;\n\t\tvr.push_back(r);\n\t}\n\t// êl¸ÂßÄ¢­\n\tfor(int i = 0; i < n; i++){\n\t\tdouble sumPer=0.0;\n\t\tif(vr[i].v==0)\n\t\t\tsumPer=0.0;\n\t\telse{\n\t\t\t// ©ªª¢­ÂÌêÅxe·é©\n\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t// »ÝÌxeÅxe·ém¦\n\t\t\t\tdouble cper=calcPer(m,j,i)*pow((double)(1-vr[i].p),m-j);\n\t\t\t\tdouble selfTime=((double)L/vr[i].v)+vr[i].t*j;\n\t\t\t\t// »ê¼êÌGÉÂ¢Ä²×é\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t// ©ª©gÜ½ÍA¬xª0Ìi[Í³·é\n\t\t\t\t\tif(i==k||EQ(vr[k].v,0.0))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble enemPer=1.0;\n\t\t\t\t\t// èª¢­ÂÈãÌêÅxeµ½çAÔÉ¤©ð`FbN\n\t\t\t\t\tfor(int l = 0; l <= m; l++){\n\t\t\t\t\t\t// GÌBðvZ\n\t\t\t\t\t\tdouble enemyTime=((double)L/vr[k].v)+vr[k].t*l;\n\t\t\t\t\t\t// àµGÌBÔª©ªÌBÔðºñÁ½çI¹\n\t\t\t\t\t\tif(!EQ(enemyTime,selfTime)&&enemyTime>selfTime){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// ±ÌÌêÅxe·ém¦\n\t\t\t\t\t\tdouble p=calcPer(m,l,k)*pow((double)(1-vr[k].p),m-l);\n\t\t\t\t\t\tenemPer-=p;\n\t\t\t\t\t}\n\t\t\t\t\t// »ÝcÁÄ¢ém¦ªAGª©ªæèx­B·ém¦\n\t\t\t\t\tcper*=enemPer;\n\t\t\t\t}\n\t\t\t\t// cperª»Ìm¦\n\t\t\t\tsumPer+=cper;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\",sumPer);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nlong long nck[60][60];\n\nint main() {\n  rep (i, 60) nck[i][i] = 1;\n  rep (i, 60) nck[i][0] = 1;\n  rep (i, 55) rep (j, i) nck[i + 1][j + 1] = nck[i][j] + nck[i][j + 1];\n  int n, m;\n  double l;\n  cin >> n >> m >> l;\n  double p[n], t[n], v[n];\n  rep (i, n) cin >> p[i] >> t[i] >> v[i];\n  rep (i, n) p[i] /= 100;\n  double tt[n][m + 1];\n  rep (i, n) rep (j, m + 1) tt[i][j] = l / v[i] + t[i] * j;\n  double pp[n][m + 1];\n  rep (i, n) rep (j, m + 1) {\n    pp[i][j] = nck[m][j];\n    rep (k, j) pp[i][j] *= p[i];\n    rep (k, m - j) pp[i][j] *= 1 - p[i];\n  }\n  rep (i, n) {\n    double res = 0;\n    rep (j, m + 1) {\n      double r = pp[i][j];\n      rep (ii, n) if (i != ii) {\n\tdouble rr = 0;\n\trep (jj, m + 1) if (tt[i][j] < tt[ii][jj] - 1e-8) rr += pp[ii][jj];\n\tr *= rr;\n      }\n      res += r;\n    }\n    printf(\"%.12lf\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(){\n  int n,m,l;\n  double p[100];\n  int t[100],v[100];\n  double time[100][50],prob[100][51];\n\n  cin >> n >> m >> l;\n  for(int i=0;i<n;i++)cin >> p[i] >> t[i] >> v[i];\n\n  if(n==1){\n    printf(\"%.8lf\\n\",1.0);\n    return 0;\n  }\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      if(!v[i])time[i][j] = 1e+10;\n      time[i][j] = (double)l/v[i] + t[i]*j;\n    }\n  }\n\n  double k = 1.0;\n  for(int i=0;i<m;i++)k*=100.0;\n\n  for(int i=0;i<n;i++){\n    prob[i][0] = pow(100-p[i],m);\n    prob[i][0] /= k;\n    double c = m;\n    for(int j=1;j<=m;j++){\n      prob[i][j] = c * pow(100-p[i],m-j) * pow(p[i],j);\n      prob[i][j] /= k;\n      c *= m-j;\n      c /= j+1;\n    }\n  }\n  /*\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++)cout << prob[i][j] << \" \";\n    cout << endl;\n  }\n  */\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    if(!v[i])printf(\"%.8lf\\n\",ans);\n    else{\n      for(int j=0;j<=m;j++){\n\tdouble tmp = 1.0;\n\tfor(int k=0;k<n;k++){\n\t  if(k!=i){\n\t    double hoge = 0.0;\n\t    for(int l=m;l>=0;l--){\n\t      if(time[k][l] > time[i][j])hoge += prob[k][l];\n\t    }\n\t    tmp *= hoge;\n\t  }\n\t}\n\tans += tmp*prob[i][j];\n      }\n      printf(\"%.8lf\\n\",ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100 + 10;\nconst int MAXM = 6000 + 10;\nconst double eps = 1e-8;\n\nint n, m, l, tot;\ndouble org[MAXN];\ndouble p[MAXN], t[MAXN], v[MAXN];\ndouble b[MAXM], c[MAXM], tp1[MAXM], tp2[MAXM];\ndouble C[MAXN][MAXN];\n\nint Find(double x) {\n        for (int i = 1; i <= tot; ++i)\n\t\tif (fabs(x - c[i]) < eps)\n\t\t\treturn i;\n}\n\ndouble co[MAXN][MAXM];\n\ninline int lowbit(int x) {\n\treturn x & (-x);\n}\n\ndouble Pow(double a, int b) {\n\tdouble ret = 1.0;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tret = ret * a;\n\t\tb >>= 1;\n\t\ta = a * a;\n\t}\n\treturn ret;\n}\n\ninline void Add(int i, int x, double v) {\n\tif (x == 0)\n\t\treturn;\n\tfor (; x <= tot; x += lowbit(x))\n\t\tco[i][x] += v;\n}\n\ninline double Query(int i, int x) {\n\tdouble ret = 0;\n\tfor (; x > 0; x -= lowbit(x))\n\t\tret += co[i][x];\n\treturn ret;\n}\nint main() {\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= 50; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t}\n\tscanf(\"%d%d%d\", &n, &m, &l);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n\t\torg[i] = 1.0 * l / v[i];\n\t\tp[i] = p[i] / 100;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tb[++tot] = -(org[i] + j * t[i]);\n\t\t}\n\tsort(b + 1, b + 1 + tot);\n\tint tmp = 0;\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tif (i == 1 || fabs(b[i] - b[i - 1]) > eps) {\n\t\t\tc[++tmp] = b[i];\n\t\t}\n\t}\n\ttot = tmp;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = Pow(p[i], j) * Pow(1 - p[i], m - j) * C[m][j];\n\t\t\tint cur = Find(curs);\n\t\t\tAdd(i, cur, curp);\n\t\t\t/*\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = C[m][j];\n\t\t        for (int k = 1; k <= j; ++k)\n\t\t\t\tcurp *= p[i];\n\t\t\tfor (int k = 1; k <= m - j; ++k)\n\t\t\t\tcurp *= (1 - p[i]);\n\t\t\tint cur = Find(curs);\n\t\t\tAdd(i, cur, curp);\n\t\t\t*/\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= m; ++j) {\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = Pow(p[i], j) * Pow(1 - p[i], m - j) * C[m][j];\n\t\t\t//\tcout << i << ' ' << j << ' ' << curp << endl;\n\t\t\tint cur = Find(curs);\n\t\t\tfor (int k = 1; k <= n; ++k) if (i != k) {\n\t\t\t\t\tcurp *= Query(k, cur - 1);\n\t\t\t}\n\t\t\tans += curp;\n\t\t\t/*\n\t\t\tdouble curs = -(org[i] + j * t[i]);\n\t\t\tdouble curp = C[m][j];\n\t\t\tfor (int k = 1; k <= j; ++k)\n\t\t\t\tcurp *= p[i];\n\t\t\tfor (int k = 1; k <= m - j; ++k)\n\t\t\t\tcurp *= (1 - p[i]);\n\t\t\t//\tcout << i << ' ' << j << ' ' << curp << endl;\n\t\t\tint cur = Find(curs);\n\t\t\tfor (int k = 1; k <= n; ++k) if (i != k) {\n\t\t\t\t\tcurp *= Query(k, cur - 1);\n\t\t\t}\n\t\t\tans += curp;\n\t\t\t*/\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  if(p[i] != 100)\n\t\t\t\t\t\tprob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n\t\t\t\t  else\n\t\t\t\t\t\tprob[i][j] = 1.0;\n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t\t  if(sum[i][j] > 1) sum[i][j] = 1;\n\t\t\t}\n\t  }\n\t  /*\n\t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << dist[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << prob[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t   ans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  /*\n\t  \t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << ans[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  tmp += ans[i][j];\n//\t\t\tcout << tmp << endl;\n\t\t\tif(tmp > 1) tmp = 0;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=220;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n} peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nLL C(LL n,LL m)\n{\n    LL a=1,b=1;\n    for(int i=m; i>=m-n+1; i--)\n        a*=i;\n    for(int i=1; i<=n; i++)\n        b*=i;\n    return a/b;\n}\n\ndouble get(int c,int n,double p)\n{\n    return C(c,n)*pow(p,c)*pow(1-p,n-c);\n}\n\nint main()\n{\n//#ifndef ONLINE_JUDGE\n//    freopen(\"in.txt\",\"r\",stdin);\n//#endif // ONLINE_JUDGE\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        for(int i=0; i<n; i++)\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n        if(n==1)\n        {\n            printf(\"%.8lf\\n\",v[0]?1:0);\n            continue;\n        }\n        for(int i=0; i<n; i++)\n            for(int j=0; j<=m; j++)\n            {\n                peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=get(j,m,p[i]*0.01);\n            }\n        for(int i=0; i<n; i++)\n        {\n            if(!v[i])\n            {\n                printf(\"%.8lf\\n\",0);\n                continue;\n            }\n            double ans=0;\n            for(int j=0; j<=m; j++)\n            {\n                double tmp=1;\n                for(int k=0; k<n; k++)\n                {\n                    if(k==i)\n                        continue;\n                    double t=0;\n                    for(int l=0; l<=m; l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define RST(A) memset(A, 0, sizeof(A))\n#define FLC(A, x) memset(A, x, sizeof(A))\n\ntypedef double DB;\n\nconst int N = int(1e2) + 9, M = int(5e1) + 9;\nDB p[N][M], sp[N][M], t[N], t0[N];\nint n, m, l;\n\nDB f(int i, DB ti){\n    DB z = 1; REP(j, n) if (i != j){\n        if (t0[j] + m*t[j] <= ti) return 0;\n        REP(k, m+1) if (t0[j] + k*t[j] > ti){\n            z *= (1 - sp[j][k]);\n            break;\n        }\n    }\n    return z;\n}\n\nint main(){\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\n    while (~scanf(\"%d%d%d\", &n, &m, &l)){\n\n        RST(p); REP(i, n){\n            int _p, v; scanf(\"%d%lf%d\", &_p, &t[i], &v); t0[i] = (DB) l / v; DB pp = (DB) _p / 100;\n            //cout <<\" \" << pp << endl;\n            p[i][0] = 1; DO(m){\n                DWN_1(j, m, 1) p[i][j] = p[i][j-1] * pp + p[i][j] * (1-pp);\n                p[i][0] = p[i][0] * (1-pp);\n            }\n\n            REP(j, m+1) cout << t0[i] << \" \";\n            cout <<endl;\n\n            REP_1(j, m) sp[i][j] = sp[i][j-1] + p[i][j-1];\n        }\n\n        REP(i, n){\n            DB z = 0; REP(j, m+1) z += p[i][j] * f(i, t0[i] + t[i]*j);\n            printf(\"%.9f\\n\", z);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<stdlib.h>\n#include<ctype.h>\n#include<queue>\n#include<bitset>\n#include<deque>\n#include<set>\n#include<time.h>\n#include<sstream>\n#include<functional>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n\n#define LL long long\ndouble p[109];\nint t[109], v[109];\nint n,m,l;\ndouble dp[109][109];\n\nvoid init(){\n\tmemset(dp,0,sizeof(dp));\n\tfor(int i=0;i<=101;i++){\n\t\tdp[0][i] = dp[i][0] = dp[i][i] =1.0;\n\t\tdp[1][i]=i+0.0;\n\t}\n\tdp[0][0]=0;\n\tfor(int i=1;i<=101;i++)\n\t\tfor(int j=1;j<=101;j++){\n\t\t\tif( i != j)\n\t\t\t\tdp[i][j] = (dp[i][j-1] + dp[i-1][j-1]);\n\t\t}\n\n}\ndouble cc(int num,int m){\n\treturn dp[num][m];\n}\ndouble _pow(double p,int k){\n\tdouble tmp=1.0;\n\tfor(int i=0;i<k;i++)\n\t\ttmp*=p;\n\treturn tmp;\n}\ndouble cul(int num,double p){\n\treturn cc(num,m)*_pow(p*1.0,num)*_pow(1.0*(1-p),m-num);\n}\nint main()\n{\n\tinit();\n\twhile(scanf(\"%d%d%d\", &n, &m, &l)!=EOF){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%d%d\", &p[i], &t[i], &v[i]);\n\t\t\tp[i] = p[i]/100;\n\t\t}\n\t\tfor(int wp=0; wp<n; wp++){\n\t\t\tdouble wpp=0;\n\t\t\tfor(int xx=0; xx<=m; xx++){\n\n\t\t\t\tdouble at = l/v[wp] + xx*t[wp];\n\t\t\t\tdouble pp = cul(xx, p[wp]);\n\n\t\t\t\tfor(int lp=0; lp<n;lp++){\n\n\t\t\t\t\tif(lp == wp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble np=0;\n\t\t\t\t\tfor(int xi=0; xi<=m; xi++){\n\n\t\t\t\t\t\tdouble lt = l/v[lp] + xi*t[lp];\n\t\t\t\t\t\tif(lt > at){\n\t\t\t\t\t\t\tnp += cul(xi, p[lp]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpp *= np;\n\t\t\t\t}\n\n\t\t\t\twpp += pp;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\",wpp);\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  if(p[i] != 100)\n\t\t\t\t\t\tprob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n\t\t\t\t  else\n\t\t\t\t\t\tprob[i][j] = 1.0;\n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t\t  if(sum[i][j] > 1) sum[i][j] = 1;\n\t\t\t}\n\t  }\n\t  /*\n\t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << dist[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << prob[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t   ans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  /*\n\t  \t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << ans[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  tmp += ans[i][j];\n//\t\t\tcout << tmp << endl;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "//#include <stdio.h>\n//#include <math.h>\n//#include <iostream>\n//#include <algorithm>\n//#include <queue>\n//#include <vector>\n//#include <map>\n//using namespace std;\n//\n//const int Max=109;\n//#define LL long long\n//LL C[52][52];\n//\n//struct P{\n//\tint t,v;\n//\tdouble p;\n//}stu[Max];\n//\n//\n//#define eps 1e-8\n//int dd(double x,double y){ return fabs(x-y)<eps;} // x==y\n//int dy(double x,double y){ return x>y+eps;}   // x>y   \n//int xy(double x,double y){ return x<y-eps;}   //x<y\n//int dyd(double x,double y){ return x>y-eps;}  //x>=y\n//int xyd(double x,double y){ return x<y+eps;}  //x<=y\n//\n//double poww(double p,int t){\n//\tdouble s=1;\n//\tfor(int i=0;i<t;i++)\n//\t\ts*=p;\n//\treturn s;\n//}\n//\n//int main(){\n//\tC[0][0]=1;\n//\tfor (int i=1; i<=50; ++i)\n//\t{\n//\t\tC[i][0]=C[i][i]=1;\n//\t\tfor (int j=1; j<i; ++j)\n//\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n//\t}\n//\tdouble l;\n//\tint n,st;\n//\tscanf(\"%d %d %lf\",&n,&st,&l);\n//\tfor(int i=0;i<n;i++){\n//\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n//\t\tstu[i].p/=100;\n//\t}\n//\tdouble pp,t,t1,p2,ppp;\n//\tfor(int i=0;i<n;i++){\n//\t\tppp=0;\n//\t\tfor(int j=0;j<=st;j++){\n//\t\t\tt=j*stu[i].t+l/(stu[i].v*1.0);\n//\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow((1-stu[i].p),(double)(st-j));\n//\t\t\tfor(int k=0;k<n;k++){\n//\t\t\t\tif(k==i)\n//\t\t\t\t\tcontinue;\n//\t\t\t\tp2=0;\n//\t\t\t\tfor(int u=0;u<=st;u++){\n//\t\t\t\t\tt1=u*stu[k].t+l/(stu[k].v*1.0);\n//\t\t\t\t\tif(dy(t1,t))\n//\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow((1-stu[i].p),(double)(st-u));\n//\t\t\t\t}\n//\t\t\t\tpp*=p2;\n//\t\t\t}\n//\t\t\tppp+=pp;\n//\t\t}\n//\t\tprintf(\"%lf\\n\",ppp);\n//\t}\n//\treturn 0;\n//}\n\n#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\n\nLL C[55][55];\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\n#define eps 1e-8\nint dd(double x,double y){ return fabs(x-y)<eps;} // x==y\nint dy(double x,double y){ return x>y+eps;}   // x>y   \nint xy(double x,double y){ return x<y-eps;}   //x<y\nint dyd(double x,double y){ return x>y-eps;}  //x>=y\nint xyd(double x,double y){ return x<y+eps;}  //x<=y\n\n\nint main(){\n\tC[0][0]=1;\n\tfor (int i=0; i<=50; ++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l) == 3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(dy(t1,t))\n\t\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tif(dd(p2,0))\n\t\t\t\t\t\t;\n\t\t\t\t\telse\n\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%lf\\n\",ppp);\n\t\t}\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int MAX_M = 50;\nlong long int comb[MAX_M+5][MAX_M+5];\nint P[MAX_N+5], T[MAX_N+5], V[MAX_N+5];\ndouble prob[MAX_N+5][MAX_M+5];\ndouble goal_t[MAX_N+5][MAX_M+5];\n\nvoid init_comb() {\n    comb[0][0] = 1;\n    for(int i=1; i<=MAX_M; i++) {\n        comb[i][0] = 1;\n        for(int j=1; j<=MAX_M; j++) {\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n        }\n    }\n}\n\nint main() {\n    init_comb();\n    int N, M, L; scanf(\"%d%d%d\", &N, &M, &L);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d%d%d\", &P[i], &T[i], &V[i]);\n        for(int k=0; k<=M; k++) {\n            goal_t[i][k] = 1.0 * L / V[i] + k * T[i];\n            prob[i][k] = comb[M][k] * pow(P[i] / 100.0, k) * pow((100-P[i]) / 100.0, M-k);\n            if(k != 0) prob[i][k] += prob[i][k-1];\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        double ans = 0.0;\n        for(int k=0; k<=M; k++) {\n            double player_t = goal_t[i][k], tmp = prob[i][k] - (k != 0 ? prob[i][k-1] : 0);\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                // かてない\n                if(player_t > goal_t[j][M]) tmp = 0;\n                // よゆう\n                else if(player_t < goal_t[j][0]) continue;\n                else {\n                    int idx = upper_bound(goal_t[j], goal_t[j]+M+1, player_t) - goal_t[j] - 1;\n                    tmp *= (1.0 - prob[j][idx]);\n                }\n            }\n            // printf(\"initial tmp = %.12f, current = %.12f\\n\", prob[i][k], tmp);\n            ans += tmp;\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n, m;\ndouble l;\ndouble p[100], t[100], v[100];\ndouble cb[100][51];\n\nvoid init(){\n\trep(u,n){\n\t\trep(i,m+1){\n\t\t\tint j = m-i;\n\t\t\tcb[u][i] = 1.0;\n\t\t\tint cnt1 = i, cnt2 = j;\n\t\t\tfor(int k = 1; k <= i; k++){\n\t\t\t\tcb[u][i] = cb[u][i]*(m-k+1)/k;\n\t\t\t\twhile(cb[u][i] > 1.0){\n\t\t\t\t\tif(cnt1 > 0){\n\t\t\t\t\t\tcb[u][i] *= p[u];\n\t\t\t\t\t\tcnt1--;\n\t\t\t\t\t} else if(cnt2 > 0){\n\t\t\t\t\t\tcb[u][i] *= (1-p[u]);\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(k,cnt1) cb[u][i] *= p[u];\n\t\t\trep(k,cnt2) cb[u][i] *= (1-p[u]);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n >> m >> l;\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] *= 0.01;\n\t}\n\tinit();\n\trep(i,n){\n\t\tdouble pos;\n\t\t//double ti;\n\t\tdouble ans = 0.0;\n\t\tif(v[i] == 0.0){\n\t\t\tputs(\"0.00000000000\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j <= m; j++){\n\t\t\tpos = cb[i][j];\n\t\t\trep(k,n){\n\t\t\t\tif(k == i) continue;\n\t\t\t\tif(v[k] == 0.0) continue;\n\t\t\t\tif(t[k] == 0.0){\n\t\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] > 0) pos *= 0.0;\n\t\t\t\t\telse pos *= 1.0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint c;\n\t\t\t\tif((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k] < 0) c = 0;\n\t\t\t\telse c = ((int)l*(int)v[k]-(int)l*(int)v[i]+(int)t[i]*j*(int)v[i]*(int)v[k])/((int)t[k]*(int)v[i]*(int)v[k]) + 1;\n\t\t\t\tdouble tmp = 0.0;\n\t\t\t\tfor(int l = c; l <= m; l++){\n\t\t\t\t\ttmp += cb[k][l];\n\t\t\t\t}\n\t\t\t\tpos *= tmp;\n\t\t\t}\n\t\t\tans += pos;\n\t\t}\n\t\tprintf(\"%.9f\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define eps 1e-9\nusing namespace std;\ndouble f_pow(double x,int n){\n\tdouble res=1;\n\twhile(n--)res*=x;\n\treturn res;\n}\n\nstruct Man{\n\tdouble p,t,v;\n\tvoid get(){\n\t\tscanf(\"%lf%lf%lf\",&p,&t,&v);\n\t\tp/=100;\n\t}\n};\nMan man[100];\nint N,M;\ndouble L;\ndouble tim[100][51],tsum[100][51];\ndouble rate[100][51];\ndouble C[51][51];\nvoid get_C(){\n\tint i,j;\n\tC[1][0]=C[1][1]=1;\n\tfor(i=2;i<51;i++){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n\t}\n}\nvoid get_data(){\n\tscanf(\"%d%d%lf\",&N,&M,&L);\n\tint i;\n\tfor(i=0;i<N;i++)man[i].get();\n}\nvoid get_tim(){\n\tint i,j;\n\tfor(i=0;i<N;i++){\n\t\trate[i][0]=f_pow(1-man[i].p,M);\n\t\ttim[i][0]=L/man[i].v;\n\t\tfor(j=1;j<=M;j++){\n\t\t\trate[i][j]=C[M][j]*f_pow(1-man[i].p,M-j)*f_pow(man[i].p,j);\n\t\t\ttim[i][j]=tim[i][j-1]+man[i].t;\n\t\t}\n\t\ttsum[i][M]=rate[i][M];\n\t\tfor(j=M-1;j>=0;j--)tsum[i][j]=tsum[i][j+1]+rate[i][j];\n\t}\n}\ndouble bina(int ren,double t){\n\tint h=M,l=0,mid;\n\twhile(h>l){\n\t\tmid=(h+l)>>1;\n\t\tif(tim[ren][mid]<t+eps)l=mid+1;\n\t\telse h=mid;\n\t}\n\treturn tsum[ren][h];\n}\ndouble get_win(int winner,double t){\n\tint i;\n\tdouble res=1;\n\tfor(i=0;i<N;i++){\n\t\tif(i==winner)continue;\n\t\tif(tim[i][M]<t+eps)return 0;\n\t\tres*=bina(i,t);\n\t}\n\treturn res;\n}\nvoid run(){\n\tint i,j;\n\tdouble sum;\n\tfor(i=0;i<N;i++){\n\t\tsum=0;\n\t\tfor(j=0;j<=M;j++){\n\t\t\tsum+=rate[i][j]*get_win(i,tim[i][j]);\n\t\t}\n\t\tprintf(\"%.9lf\\n\",sum);\n\t}\n}\nint main(){\n\tget_C();\n\tget_data();\n\tget_tim();\n\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stdlib.h>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 105;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[N][N] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) {\n\t\tif(v[i] == 0) base_time[i] = -1;\n\t\telse base_time[i] = l / v[i];\n\t}\n\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\tif(base_time[i] == -1){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y)\n{\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\nint mod_inverse(int a, int m)\n{\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//int fact[INT_MAX];\n//int mod_fact(int n, int p, int &e)\n//{\n//\te = 0;\n//\tif (n == 0) return 1;\n//\tint res = mod_fact(n / p, p, e);\n//\te += n / p;\n//\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n//\treturn res * fact[n % p] % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (n < 0 || k < 0 || n < k) return 0;\n//\tint e1, e2, e3;\n//\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n//\tif (e1 > e2 + e3) return 0;\n//\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (k < 1) return 1;\n//\tll bunshi = 1, bunbo = 1;\n//\tll ans=1;\n//\tREP(i,n){\n//\t\tbunshi*=n-i;\n//\t\tbunshi%=M;\n//\t}\n//\tREP(i,k){\n//\t\tbunbo*=k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tREP(i,n-k){\n//\t\tbunbo*=n-k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tans=bunshi;\n//\tans*=mod_inverse\n//\treturn mod_inverse(bunshi,\n//\t\n//\tREP(i,n-k){\n//\t\tans*=bunshi;\n//\t\tans/=bunbo;\n//\t\tbunshi--;\n//\t\tbunbo--;\n//\t}\n//\tcerr << n << \", \" << k << \" => \" << ans << endl;\n//\treturn ans;\n//}\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : INT_MAX;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nint P[100], T[100], V[100];\ndouble prob[100][51];\ndouble comb[51][51];\nint main() {\n\tint N, M, L;\n\tcin >> N >> M >> L;\n\tcomb[0][0] = 1;\n\tfor (int i = 1; i <= M; i++) {\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcomb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i] >> T[i] >> V[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tprob[i][j] = comb[M][j] * pow(P[i] / 100.0, j)*pow(1 - P[i] / 100.0, M - j);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (V[i] == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tdouble t1 = (double)L / V[i] + T[i] * j;\n\t\t\tdouble p = 1;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (k == i) continue;\n\t\t\t\tif (V[k] == 0) continue;\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int l = 0; l <= M; l++) {\n\t\t\t\t\tdouble t2 = (double)L / V[k] + T[k] * l;\n\t\t\t\t\tif (t1 < t2) sum += prob[k][l];\n\t\t\t\t}\n\t\t\t\tp *= sum;\n\t\t\t}\n\t\t\tans += prob[i][j] * p;\n\t\t}\n\t\tprintf(\"%.15lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<long double> p(n),t(n),v(n);\n    rep(i,0,n){\n        cin >> p[i] >> t[i] >> v[i];\n        if(v[i]==0) v[i]=1e-12;\n    }\n\n    ll comb[51][51]={};\n    rep(i,0,51){\n        comb[i][i]=1;\n        comb[i][0]=1;\n    }\n    rep(i,1,51) rep(j,1,i){\n        if(i>0 and i>j) comb[i][j]+=comb[i-1][j];\n        if(j>0) comb[i][j]+=comb[i-1][j-1];\n    }\n\n    vector<map<int,long double>> x(n);\n    rep(i,0,n) rep(j,0,m+1) x[i][t[i]*j]=powl((100-p[i])/100,m-j)*comb[m][j]*powl(p[i]/100,j);\n    rep(i,0,n){\n        long double s1=0;\n        for(const auto& p1:x[i]){\n            long double tmp=p1.second;\n            rep(j,0,n){\n                if(j==i) continue;\n                long double s2=0;\n                for(const auto& p2:x[j]) if((p2.first+l)*v[i]>(p1.first+l)*v[j]) s2+=p2.second;\n                tmp*=s2;\n            }\n            s1+=tmp;\n        }\n        cout << fixed << setprecision(8) << s1 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={},a=1,b=1;\n  for(int i=0;i<m;i++) a*=(1-p[0]);\n  for(int i=0;i<=m&&a!=0;i++,b*=p[0],a/=(1-p[0]))dp[0][i]=a*b*nCr(m,i);\n  if(a==1)dp[0][0]=1;\n  if(a==0)dp[0][0]=0;\n  \n  for(int i=1;i<n;i++){\n    for(int j=0;j<=m;j++){\n      a=b=1;\n      for(int k=0;k<m;k++)a*=(1-p[i]);\n      if(a==0) dp[i][j] += dp[i-1][j];\n      for(int k=0+(a==1);k<=m&&a!=0;k++,b*=p[i],a/=(1-p[i]))\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) dp[i][j]+= dp[i-1][j]*a*b*nCr(m,k);\n\n\n    }\n  }\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n    for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\ndouble C(int a,int b)\n{\n\tb=std::min(a-b,b);\n\tdouble r=1;\n\tfor(int i=1;i<=b;++i)r=r*(a-b+i)/i;\n\treturn r;\n}\ndouble F(double a,int b)\n{\n\tdouble r=1,x=a;\n\tfor(;b;b>>=1)\n\t{\n\t\tif(b&1)r*=x;\n\t\tx*=x;\n\t}\n\treturn r;\n}\nint n,m,l;\nint p[100],t[100],v[100];\ndouble EPS = 5e-10;\ntypedef std::pair<double,double>P;\nP*q,a[100][51];\ndouble R(int i,int j){return C(m,j)*F(p[i]/100.0,j)*F(1-p[i]/100.0,m-j);}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&l);;\n\tint i,j,k;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tscanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n\t\tdouble x=0,y;\n\t\tfor(j=0;j<=m;++j)\n\t\t{\n\t\t\ta[i][j].first = j*t[i] + (double)l/v[i];\n\t\t\ty=R(i,j);\n\t\t\ta[i][j].second=y+x;\n\t\t\tx+=y;\n\t\t}\n\t}\n\tdouble r,x;\n\tfor(i=0;i<n;++i)\n\t{\n\t\tr=0;\n\t\tfor(j=0;j<=m;++j)\n\t\t{\n\t\t\tx=1;\n\t\t\tfor(k=0;k<n;++k)\n\t\t\t{\n\t\t\t\tif(i==k)continue;\n\t\t\t\tif(a[i][j].first+EPS < a[k][0].first);\n\t\t\t\telse if(a[i][j].first-EPS > a[k][m].first)x=0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tq=std::lower_bound(a[k],a[k]+m+1,P(a[i][j].first+EPS,-1));\n\t\t\t\t\tx*=(1-q[-1].second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tr+=x*R(i,j);\n\t\t}\n\t\tprintf(\"%.12f\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<ctime>\n#include<vector>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst double pi=3.141592653;\nconst double eps=1e-10;\nconst int INF=0x3f3f3f3f;\nconst int MOD=10007;\nconst int MAXN=1020;\nstruct people\n{\n    double t[MAXN],pp[MAXN];\n}peo[MAXN];\n\nint n,m,L,p[MAXN],t[MAXN],v[MAXN];\n\nint C(int n,int m)\n{\n    int a=1,b=1;\n    for(int i=m;i>=m-n+1;i--)\n        a*=i;\n    for(int i=1;i<=n;i++)\n        b*=i;\n    return a/b;\n}\n\ndouble get(int c,int n,double p)\n{\n    return C(c,n)*pow(p,c)*pow((1-p),n-c);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&L)!=EOF)\n    {\n        memset(peo,0,sizeof(peo));\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n            if(!v[i]||!p[i]||!t[i]||!L)\n                while(1);\n        }\n            \n        for(int i=0;i<n;i++)\n            for(int j=0;j<=m;j++)\n            {\n                peo[i].t[j]=(L+0.0)/v[i]+j*t[i];\n                peo[i].pp[j]=get(j,m,p[i]/100.0);\n            }\n        for(int i=0;i<n;i++)\n        {\n            if(!v[i]||!L)\n            {\n                printf(\"0.00000000\\n\");\n                continue;\n            }\n            double ans=0;\n            for(int j=0;j<=m;j++)\n            {\n                double tmp=1;\n                for(int k=0;k<n;k++)\n                {\n                    if(k==i||!v[i])\n                        continue;\n                    double t=0;\n                    for(int l=0;l<=m;l++)\n                        if(peo[i].t[j]<peo[k].t[l])\n                            t+=peo[k].pp[l];\n                    tmp*=t;\n                }\n                ans+=tmp*peo[i].pp[j];\n            }\n            printf(\"%.8f\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define MAXX 51\n\nshort n,m,i,j,k,l;\nint len;\ndouble t;\ndouble ans,sum,sum1;\nunsigned long long C[MAXX][MAXX];\ndouble mat[MAXX<<1][MAXX];\ndouble p[MAXX<<1][MAXX];\n\nstruct node\n{\n    short p,t,v;\n}run[MAXX];\n\nint main()\n{\n    for(i=1;i<MAXX;++i)\n    {\n        C[1][i]=i;\n        C[0][i]=1;\n        C[i][i]=1;\n    }\n    for(i=2;i<MAXX;++i)\n        for(j=2;j<=i;++j)\n            C[j][i]=C[j-1][i]*(i-j+1)/j;\n    scanf(\"%hd %hd %d\",&n,&m,&len);\n    for(i=0;i<n;++i)\n        scanf(\"%hd %hd %hd\",&run[i].p,&run[i].t,&run[i].v);\n    for(i=0;i<n;++i)\n    {\n        t=(double)len/run[i].v;\n        for(j=0;j<=m;++j)\n        {\n            p[i][j]=C[j][m];\n            for(k=0;k<j;++k)\n                p[i][j]*=(double)run[i].p/100;\n            for(k=0;k<m-j;++k)\n                p[i][j]*=(double)(100-run[i].p)/100;\n            mat[i][j]=t+j*run[i].t;\n        }\n    }\n    /*\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",mat[i][j]);\n        printf(\"\\n\");\n    }\n    for(i=0;i<n;++i)\n    {\n        for(j=0;j<=m;++j)\n            printf(\"%f\\t\",p[i][j]);\n        printf(\"\\n\");\n    }\n    printf(\"\\n\\n\\n\");\n    */\n    for(i=0;i<n;++i)\n    {\n        sum=0;\n        for(j=0;j<=m;++j)\n        {\n            ans=p[i][j];\n            for(k=0;k<n;++k)\n                if(i!=k)\n                {\n                    sum1=0;\n                    for(l=0;l<=m;++l)\n                        if(mat[i][j]<mat[k][l])\n                            sum1+=p[k][l];\n                    ans*=sum1;\n                }\n            sum+=ans;\n        }\n        printf(\"%.5f\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n#define double long double\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\n\nll combination(int n,int k){\n\tll ans=1;\n\tFOR(i,1,k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nconst double EPS = 1e-9;\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : 1e20;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t] + EPS) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\twin_prob =0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\nlong double C[N][N];\n\nlong double prob[N][N];\nlong double _time[N][N];\n\nint main(){\n\tC[0][0] = 1;\n\trep(i, N - 1) rep(j, i + 1){\n\t\tC[i + 1][j] += C[i][j];\n\t\tC[i + 1][j + 1] += C[i][j];\n\t}\n\n\tint n, m, L;\n\tcin >> n >> m >> L;\n\n\tvector<int> p(n), t(n), v(n);\n\trep(i, n) cin >> p[i] >> t[i] >> v[i];\n\n\trep(i, n){\n\t\tif (!v[i]) continue;\n\t\t_time[i][0] = (double)L / v[i];\n\t\tFOR(j, 1, m + 1) _time[i][j] = _time[i][j - 1] + t[i];\n\n\t\tFOR(j, 0, m + 1){\n\t\t\tprob[i][j] = C[m][j] * pow(p[i] / 100., j) * pow((1 - p[i] / 100.), m - j);\n\t\t\t//cout << pow(p[i] / 100., j) << ' ' << pow(1 - p[i] / 100., m-j) << endl;\n\t\t}\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\trep(i, n){\n\t\tlong double a = 0;\n\t\tif (v[i]) rep(j, m + 1){\n\t\t\tlong double ct = _time[i][j];\n\t\t\tlong double cp = prob[i][j];\n\t\t\trep(k, n){\n\t\t\t\tif (i == k) continue;\n\t\t\t\tint idx = m;\n\t\t\t\tlong double tmp = 0;\n\t\t\t\twhile (idx >= 0 && _time[k][idx] > ct + (1e-9)) tmp += prob[k][idx--];\n\t\t\t\tcp *= tmp;\n\t\t\t}\n\t\t\ta += cp;\n\t\t}\n\t\tcout << a << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 55;\ndouble C[MAXN+1][MAXN+1];\nconst int N = 110;\nint n, m;\nint l, t[N], v[N];\ndouble p[N];\nvoid init()\n{\n    memset(C, 0, sizeof C);\n    for(int i=0; i<=MAXN; ++i)\n    {\n        C[0][i] = 0.0;\n        C[i][0] = 1.0;\n    }\n    for(int i=1; i<=MAXN; ++i)\n    {\n        for(int j=1; j<=MAXN; ++j)\n        C[i][j] = C[i-1][j] + C[i-1][j-1];\n    }\n}\ndouble work(int x)\n{\n    double ans = 0.0;\n    for(int i = 0; i <= m; i++)\n    {\n        double pp = C[m][i] * pow(p[x], i) * pow(1.0-p[x], m-i);\n        for(int j = 1; j <= n; j++)\n        {\n            if(j == x)continue;\n            double siz = 0;\n            for(int k = m; k >= 0; k--)\n            {\n                if(l*v[j] + i*t[x]*v[j]*v[x] < l*v[x] + k*t[j]*v[x]*v[j])\n                    siz += C[m][k] * pow(p[j], k) * pow(1.0-p[j], m-k);\n                else break;\n            }\n            pp *= siz;\n        }\n        ans += pp;\n    }\n    return ans;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    init();\n    while(cin>>n>>m>>l)\n    {\n        for(int i = 1; i <= n; i++)\n        {\n            cin>>p[i]>>t[i]>>v[i];\n            p[i] /= 100.0;\n        }\n        for(int i = 1; i <= n; i++)\n            printf(\"%.10f\\n\", work(i));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 100;\nconst int M = 51;\nconst double EPS = 1e-7;\n\nint n, m, L, t[N], v[N];\ndouble p[N], C[M+1][M+1], ps[N][N], s_ps[N][N], ts[N][N];\n\nmain(){\n  for(int i=0;i<=M;i++) C[i][0] = 1.0;\n  for(int i=1;i<=M;i++) for(int j=1;j<=i;j++) C[i][j] = C[i-1][j-1] + C[i-1][j];\n  cin >> n >> m >> L;\n  for(int i=0;i<n;i++) cin >> p[i] >> t[i] >> v[i];\n  bool f = true;\n  for(int i=0;i<n;i++) if(v[i]) f = false;\n  if(f){\n    printf(\"%.8f\\n\", 0);\n    return 0;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      ps[i][j] = C[m][j] * pow(p[i]/100.0, j) * pow((100 - p[i])/100.0, m - j);\n      if(j == 0) s_ps[i][j] = ps[i][j];\n      else s_ps[i][j] = s_ps[i][j-1] + ps[i][j];\n      ts[i][j] = (double)L / v[i] + t[i] * j;\n    }\n  }\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    for(int j=0;j<=m;j++){\n      double tmp = 1.0;\n      for(int k=0;k<n;k++){\n        if(k == i) continue;\n        int l = lower_bound(ts[k], ts[k]+m+1, ts[i][j]+EPS) - ts[k];\n        if(l != 0) tmp *= (1.0 - s_ps[k][l-1]);\n      }\n      ans += ps[i][j] * tmp;\n    }\n    printf(\"%.8f\\n\", ans+EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nint n,m;\ndouble l;\nint t[101];\ndouble pp[101][55];\ndouble psum[101][55];\ndouble p[101],v[101];\ndouble tt[101][55];\ndouble win[101];\ndouble comb[101][101];\n\nint main(void){\n\tfor(int i=1;i<=100;i++){\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t}\n\t}\n\tscanf(\"%d %d %lf\",&n,&m,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %d %lf\",&p[i],&t[i],&v[i]);\n\t\tp[i]=p[i]/100.0;\n\t}\n\tfor(int j=0;j<n;j++){\n\t\tfor(int k=0;k<=m;k++){\n\t\t\tpp[j][k]=comb[m][k];\n\t\t\tfor(int l=0;l<k;l++){\n\t\t\t\tpp[j][k]*=p[j];\n\t\t\t}\n\t\t\tfor(int l=0;l<m-k;l++){\n\t\t\t\tpp[j][k]*=(1.0-p[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tpsum[i][j+1]=psum[i][j]+pp[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i]==0.0){\n\t\t\tfor(int j=0;j<=m+1;j++){\n\t\t\t\ttt[i][j]=1000000000.0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttt[i][0]=l/v[i];\n\t\tfor(int j=1;j<=m;j++){\n\t\t\ttt[i][j]=tt[i][j-1]+t[i];\n\t\t}\n\t\ttt[i][m+1]=1000000000.0;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i]==0.0)continue;\n\t\tfor(int l=0;l<=m;l++){\n\t\t\tdouble wp=pp[i][l];\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tif(v[k]==0.0)continue;\n\t\t\t\tint uk=upper_bound(tt[k],tt[k]+m+2,tt[i][l])-tt[k];\n\t\t\t\twp*=(1.0-psum[k][uk]);\n\t\t\t\t//printf(\"%lf %lf %f\\n\",tt[i][l],tt[k][uk],psum[k][uk]);\n\t\t\t}\n\t\t\twin[i]+=wp;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%.8f\\n\",win[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int maxn = 105;\nconst int maxm = 55;\n\ndouble c[maxm][maxm], ans[maxn], p[maxn], t[maxn], v[maxn];\ndouble q[maxn][maxm*maxn];\nint n, m;\ndouble l;\nstruct A {\n\tint id;\n\tdouble p, t;\n} a[maxn * maxm];\n\ndouble calc(double k, int x, int y) {\n\tfor(int i = 1; i <= y; ++ i) k *= p[x]/100.0;\n\tfor(int i = 1; i <= m-y; ++ i) k *= (100.0-p[x])/100.0;\n\treturn k;\n}\n\nbool cmp(A a, A b) {\n\treturn a.t < b.t;\n}\n\nint main () {\n\tint tot = 0;\n\twhile(scanf(\"%d%d%lf\", &n, &m, &l)!=-1){\n\ttot = 0;\n\tmemset(v, 0, sizeof v);\n\tfor(int i = 0; i <= m; ++ i) {\n\t\tc[i][0] = 1;\n\t\tfor(int j = 1; j <= i; ++ j) {\n\t\t\tc[i][j] = c[i-1][j] + c[i-1][j-1];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tscanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n\t}\n\tfor(int i = 1; i <= n; ++ i) {\n\t\tfor(int j = 0; j <= m; ++ j) {\n\t\t\t++ tot;\n\t\t\ta[tot].id = i;\n\t\t\ta[tot].p = calc(c[m][j], i, j);\n\t\t\ta[tot].t = l/v[i] + j * t[i];\n\t\t}\n\t}\n\tsort(a+1, a+tot+1, cmp);\n\tmemset(ans, 0, sizeof ans);\n\tmemset(q, 0, sizeof q);\n\tfor(int i = 1; i <= tot; ++ i) {\n\t\tdouble P = 1;\n\t\tint k = i-1;\n\t\twhile(a[k].t == a[i].t) k--;\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif(j == a[i].id) continue;\n\t\t\tP *= q[j][k];\n\t\t}\n\t\tans[a[i].id] += P*a[i].p;\n\t\tfor(int j = 1; j <= n; ++ j) {\n\t\t\tif(j == a[i].id) q[a[i].id][i] = q[a[i].id][i-1] + a[i].p;\n\t\t\telse q[j][i] = q[j][i-1];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; ++ i) printf(\"%.8lf\\n\", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2303>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ndouble powmod(double x, ll n) {\n    double res = 1;\n    while (n > 0) {\n        if (n & 1) { //奇数なら\n            res =(res*x);\n        }\n        x = (x*x);\n        n >>= 1;\n    }\n    return res;\n}\nvoid solve(){\n    int N,M,L; cin >> N >> M >> L;\n    vector<double> P(N),T(N),V(N);\n    for(int i = 0; i < N;i++){\n        cin >> P[i] >> T[i] >> V[i];\n        P[i]/=100.;\n    }\n    const int MAX_M = 50;\n    double comb[MAX_M+1][MAX_M+1];\n    for (int i = 0; i <= MAX_M; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j == 0 || j == i)\n                comb[i][j] = 1;\n            else\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n        }\n    }\n    \n    cout << fixed << setprecision(12);\n    for(int i = 0; i < N;i++){\n        if(V[i] == 0){ cout << 0. << endl; continue;}\n        double ans = 0;\n        for(int j = 0; j <= M;j++){\n            double tans = powmod(P[i],j)*powmod(1-P[i],M-j)*comb[M][j];\n            double Time = T[i]*j + L/V[i];\n            for(int k = 0; k < N;k++){\n                if(i == k) continue;\n                double sum = 0;\n                for(int l = 0; l <= M; l++){\n                    double TTime = T[k]*l + L/V[k];\n                    if(TTime < Time + 1e-9) continue;\n                    sum += powmod(P[k],l)*powmod(1-P[k],M-l)*comb[M][l];\n                }\n                tans *= sum;\n            }\n            ans += tans;\n        }\n        cout << ans << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  xioumu\n * Created Time:  2012/10/8 15:34:52\n * File Name: d.cpp\n * solve: d.cpp\n */\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define sz(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\n#define repd(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr(x) memset(x,0,sizeof(x))\n#define clrs( x , y ) memset(x,y,sizeof(x))\n#define out(x) printf(#x\" %d\\n\", x)\ntypedef long long lint;\nconst int maxint = -1u>>1;\nconst double esp = 1e-13;\nconst int maxn = 100 + 10;\nconst int maxm = 50 + 10;\ndouble p[maxn], t[maxn], v[maxn];\nint n, m, L;\ndouble con[maxm][maxm];\ndouble pow_p[maxn][maxm], pow_np[maxn][maxm], f[maxn][maxm], sum[maxn][maxm];\ndouble ans[maxn];\ndouble times[maxn][maxm];\nint zore[maxn];\nint sgn(double x) {\n    return (x > esp) - (x < -esp);\n}\nbool cmp(const double &a, const double &b) {\n    return sgn(a - b) < 0;\n}\nvoid init() {\n    rep (i, n) {\n        scanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n        p[i] /= 100;\n        zore[i] = 0;\n        if(sgn(v[i]) == 0) {\n            zore[i] = 1;\n        }\n    }\n    con[0][0] = 1;\n    repf (i, 1, m) {\n        con[i][0] = con[i][i] = 1;\n        repf (j, 1, i - 1)\n            con[i][j] = con[i - 1][j] + con[i - 1][j - 1];\n    }\n    \n    rep (i, n) {\n        if(zore[i]) continue;\n        pow_p[i][0] = 1;\n        pow_np[i][0] = 1;\n        times[i][0] = L * 1.0 / v[i];\n        repf (j, 1, m) {\n            pow_p[i][j] = pow_p[i][j - 1] * p[i];\n            pow_np[i][j] = pow_np[i][j - 1] * (1 - p[i]);\n            times[i][j] = times[i][j - 1] + t[i];\n        }\n    }\n    \n    rep (i, n) {\n        if(zore[i]) continue;\n        sum[i][0] = f[i][0] = con[m][0] * pow_np[i][m] * pow_p[i][0];\n        repf (j, 1, m) {\n            f[i][j] = con[m][j] * pow_np[i][m - j] * pow_p[i][j];\n            sum[i][j] = sum[i][j - 1] + f[i][j];\n        }\n    }\n}\ndouble gao(double lim, int w) {\n    //int h = m + 1;\n    if(zore[w]) return 1;\n    int h = upper_bound(times[w], times[w] + m + 1, lim, cmp) - times[w];\n    //rep (i, m + 1)\n        //if(sgn(times[w][i] - lim) > 0) {\n            //h = i;\n            //break;\n        //}\n    //printf(\"%d %d %f %f %f %f\\n\", h, hh, lim, times[w][h], times[w][hh], 1 - sum[w][h - 1]);\n    //out(h);\n    if(h - 1 < 0)  return 1;\n    else return 1 - sum[w][h - 1];\n}\nint main()  {\n    int blank = 0;\n    while( scanf(\"%d%d%d\", &n, &m, &L) == 3) {\n        //if(blank) printf(\"\\n\");\n        init();\n        //if(n == 1) {\n            //printf(\"%.8f\\n\", 1.0);\n            //continue;\n        //}\n        rep (i, n) {\n            ans[i] = 0;\n            if(!zore[i]) \n                repf (j, 0, m) {\n                    double res = 1;\n                    rep (k, n) {\n                        if(k == i) continue;\n                        res *= gao(times[i][j], k);\n                        //if(i == 1) printf(\"%f %f %d\\n\", gao(times[i][j], k), times[i][j], k);\n                    }\n                    //printf(\"%f %f %d %d\\n\", res, f[i][j], i, j);\n                    ans[i] += res * f[i][j];\n                }\n            printf(\"%.12f\\n\", ans[i]);\n            //if(i != n - 1) printf(\"\\n\");\n        }\n        //blank = 1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nvector<double> P, T, V;\ndouble F[51];\ndouble C[51][51];\ndouble pTable[101][51];\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    F[0] = 1;\n    for(int i=1; i<51; i++)\n        F[i] = F[i-1] * i;\n    for(int i=0; i<51; i++)\n        for(int j=0; j<=i; j++)\n            C[i][j] = F[i] / F[i-j] / F[j];\n    \n    cin >> N >> M >> L;\n    P.resize(N); T.resize(N); V.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    \n    double tmp1[51], tmp2[51];\n    for(int i=0; i<N; i++){\n        tmp1[0] = tmp2[0] = 1;\n        for(int j=1; j<=M; j++){\n            tmp1[j] = tmp1[j-1] * P[i]/100;\n            tmp2[j] = tmp2[j-1] * (1 - P[i]/100);\n        }\n        \n        for(int j=0; j<=M; j++){\n            pTable[i][j] = tmp1[j] * tmp2[M-j] * C[M][j];\n        }\n    }\n    \n    for(int i=0; i<N; i++){\n        double ans = 0;\n        for(int k=0; k<=M; k++){ //????????????i????????????????????????\n            double ti = L / V[i] + T[i]*k;\n            double ttans = 1;\n            for(int j=0; j<N; j++) if(i != j){\n                double tans = 0;\n                for(int l=0; l<=M; l++){ //????????????j????????????????????????\n                    double tj = L / V[j] + T[j]*l;\n                    if(ti < tj){\n                        tans += pTable[j][l];\n                    }\n                }\n                ttans *= tans;\n            }\n            ans += ttans * pTable[i][k];\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n,m,l;\n    cin >> n >> m >> l;\n    vector<long double> p(n),t(n),v(n);\n    rep(i,0,n){\n        cin >> p[i] >> t[i] >> v[i];\n        if(v[i]==0) v[i]=1e-12;\n    }\n\n    ll comb[51][51]={};\n    rep(i,0,51){\n        comb[i][i]=1;\n        comb[i][0]=1;\n    }\n    rep(i,1,51) rep(j,1,i){\n        if(i>0 and i>j) comb[i][j]+=comb[i-1][j];\n        if(j>0) comb[i][j]+=comb[i-1][j-1];\n    }\n\n    vector<unordered_map<int,long double>> x(n);\n    rep(i,0,n) rep(j,0,m+1) x[i][t[i]*j]+=powl((100-p[i])/100,m-j)*comb[m][j]*powl(p[i]/100,j);\n    rep(i,0,n){\n        long double s1=0;\n        for(const auto& p1:x[i]){\n            long double tmp=p1.second;\n            rep(j,0,n){\n                if(j==i) continue;\n                long double s2=0;\n                for(const auto& p2:x[j]) if(p2.first+l/v[j]>p1.first+l/v[i]) s2+=p2.second;\n                tmp*=s2;\n            }\n            s1+=tmp;\n        }\n        cout << fixed << setprecision(8) << s1 << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 100;\nconst int M = 51;\nconst double EPS = 1e-9;\n\nint n, m, L, t[N], v[N];\ndouble p[N], C[M+1][M+1], ps[N][N], s_ps[N][N], ts[N][N];\n\nmain(){\n  for(int i=0;i<=M;i++) C[i][0] = 1.0;\n  for(int i=1;i<=M;i++) for(int j=1;j<=i;j++) C[i][j] = C[i-1][j-1] + C[i-1][j];\n  cin >> n >> m >> L;\n  for(int i=0;i<n;i++) cin >> p[i] >> t[i] >> v[i];\n  bool f = true;\n  for(int i=0;i<n;i++) if(v[i]) f = false;\n  if(f){\n    printf(\"%.8f\\n\", 0);\n    return 0;\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=m;j++){\n      ps[i][j] = C[m][j] * pow(p[i]/100.0, j) * pow((100 - p[i])/100.0, m - j);\n      if(j == 0) s_ps[i][j] = ps[i][j];\n      else s_ps[i][j] = s_ps[i][j-1] + ps[i][j];\n      ts[i][j] = (double)L / v[i] + t[i] * j;\n    }\n  }\n  for(int i=0;i<n;i++){\n    double ans = 0.0;\n    for(int j=0;j<=m;j++){\n      double tmp = 1.0;\n      for(int k=0;k<n;k++){\n        if(k == i) continue;\n        int l = lower_bound(ts[k], ts[k]+m+1, ts[i][j]+EPS) - ts[k];\n        if(l != 0) tmp *= (1.0 - s_ps[k][l-1]);\n      }\n      ans += ps[i][j] * tmp;\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M,L;\nint P[111],T[111],V[111];\n\ndouble Time[111][111];\ndouble pa[111][111];\ndouble ncr[111][111];\n\nconst double EPS = 1E-9;\nconst double INF = 1E50;\n\nvoid getncr(){\n  for(int i=0;i<=100;i++) ncr[i][i] = ncr[i][0] = 1LL;\n  for(int i=2;i<=100;i++)\n    for(int j=1;j<i;j++)\n      ncr[i][j] = ncr[i-1][j] + ncr[i-1][j-1];\n      \t\n}\n\nint main(){\n  cin >> N >> M >> L;\n  for(int i=0;i<N;i++){\n    cin >> P[i] >> T[i] >> V[i];\n  }\n\n  getncr();\n\n  for(int i=0;i<N;i++){\n    double ka = 1.0f;\n    for(int l=0;l<M;l++){\n      ka *= (double)(100-P[i])/100.0;\n    }\t\n    //  cout <<i << endl;\n    for(int j=0;j<=M;j++){\n      if( V[i] == 0 )\n\tTime[i][j] = INF;\n      else\n\tTime[i][j] = (double)L / (double)V[i] + (double)T[i]*(double)j;\n\n      pa[i][j] = ka*ncr[M][j];\n      \n      if( P[i] == 100 )\n\tka = 1.0f;\n      else \n\tka /= (double)(100-P[i])/100.0;\n      ka *= (double)P[i]/100.0;       \n    }\n  }\n\n  for(int i=0;i<N;i++){\n    double res = 0.0f;\n    for(int j=0;j<=M;j++){\n\n      double H = Time[i][j];\n      double ret = 1.0f;\n      for(int k=0;k<N;k++){\n\tif( i == k ) continue;\n\tdouble kk = 0.0f;\n\n\tfor(int l=0;l<=M;l++){\n\t  //  cout << H << \" \" << Time[k][l] << \" \" << pa[k][l] << endl;\n\t  if( Time[k][l] > H+EPS ){\n\t    //  cout << pa[k][l] << endl;\n\t    kk += pa[k][l];\n\t  }\n\t}\n\n\t//\tcout << \"k= \" << k << \" \"<< kk << endl;\n\tret *= kk;\n      }\n      //      cout << \"i , j = \" << i << \" \"<< j << \" \"<< ret << \" * \" << pa[i][j] << \" \"<< ret*pa[i][j] << endl;\n      res += ret*pa[i][j];\n    }\n\n    printf(\"%.10lf\\n\",res);\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "//#include <stdio.h>\n//#include <math.h>\n//#include <iostream>\n//#include <algorithm>\n//#include <queue>\n//#include <vector>\n//#include <map>\n//using namespace std;\n//\n//const int Max=109;\n//#define LL long long\n//LL C[52][52];\n//\n//struct P{\n//\tint t,v;\n//\tdouble p;\n//}stu[Max];\n//\n//\n//#define eps 1e-8\n//int dd(double x,double y){ return fabs(x-y)<eps;} // x==y\n//int dy(double x,double y){ return x>y+eps;}   // x>y   \n//int xy(double x,double y){ return x<y-eps;}   //x<y\n//int dyd(double x,double y){ return x>y-eps;}  //x>=y\n//int xyd(double x,double y){ return x<y+eps;}  //x<=y\n//\n//double poww(double p,int t){\n//\tdouble s=1;\n//\tfor(int i=0;i<t;i++)\n//\t\ts*=p;\n//\treturn s;\n//}\n//\n//int main(){\n//\tC[0][0]=1;\n//\tfor (int i=1; i<=50; ++i)\n//\t{\n//\t\tC[i][0]=C[i][i]=1;\n//\t\tfor (int j=1; j<i; ++j)\n//\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n//\t}\n//\tdouble l;\n//\tint n,st;\n//\tscanf(\"%d %d %lf\",&n,&st,&l);\n//\tfor(int i=0;i<n;i++){\n//\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n//\t\tstu[i].p/=100;\n//\t}\n//\tdouble pp,t,t1,p2,ppp;\n//\tfor(int i=0;i<n;i++){\n//\t\tppp=0;\n//\t\tfor(int j=0;j<=st;j++){\n//\t\t\tt=j*stu[i].t+l/(stu[i].v*1.0);\n//\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow((1-stu[i].p),(double)(st-j));\n//\t\t\tfor(int k=0;k<n;k++){\n//\t\t\t\tif(k==i)\n//\t\t\t\t\tcontinue;\n//\t\t\t\tp2=0;\n//\t\t\t\tfor(int u=0;u<=st;u++){\n//\t\t\t\t\tt1=u*stu[k].t+l/(stu[k].v*1.0);\n//\t\t\t\t\tif(dy(t1,t))\n//\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow((1-stu[i].p),(double)(st-u));\n//\t\t\t\t}\n//\t\t\t\tpp*=p2;\n//\t\t\t}\n//\t\t\tppp+=pp;\n//\t\t}\n//\t\tprintf(\"%lf\\n\",ppp);\n//\t}\n//\treturn 0;\n//}\n\n#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\n\nLL C[55][55];\n\nstruct P{\n\tdouble t,v;\n\tdouble p;\n}stu[Max];\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\n#define eps 1e-8\nint dd(double x,double y){ return fabs(x-y)<eps;} // x==y\nint dy(double x,double y){ return x>y+eps;}   // x>y   \nint xy(double x,double y){ return x<y-eps;}   //x<y\nint dyd(double x,double y){ return x>y-eps;}  //x>=y\nint xyd(double x,double y){ return x<y+eps;}  //x<=y\n\n\nint main(){\n\tC[0][0]=1;\n\tfor (int i=0; i<=50; ++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l) == 3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow(1-stu[i].p,(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(dy(t1,t))\n\t\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow(1-stu[i].p,(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tif(dy(p2,0))\n\t\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%lf\\n\",ppp);\n\t\t}\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M, L;\nvector<double> P, T, V;\ndouble F[51];\ndouble C[51][51];\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    F[0] = 1;\n    for(int i=1; i<51; i++)\n        F[i] = F[i-1] * i;\n    for(int i=0; i<51; i++)\n        for(int j=0; j<=i; j++)\n            C[i][j] = F[i] / F[i-j] / F[j];\n    \n    cin >> N >> M >> L;\n    P.resize(N); T.resize(N); V.resize(N);\n    for(int i=0; i<N; i++)\n        cin >> P[i] >> T[i] >> V[i];\n    \n    for(int i=0; i<N; i++){\n        double ans = 0;\n        for(int k=0; k<=M; k++){ //????????????i????????????????????????\n            double ti = L / V[i] + T[i]*k;\n            double ttans = 1;\n            for(int j=0; j<N; j++) if(i != j){\n                double tans = 0;\n                for(int l=0; l<=M; l++){ //????????????j????????????????????????\n                    double tj = L / V[j] + T[j]*l;\n                    if(ti < tj){\n                        tans += pow(P[j]/100, l) * pow(1-P[j]/100, M-l) * C[M][l];\n                    }\n                }\n                ttans *= tans;\n            }\n            ans += ttans * pow(P[i]/100, k) * pow(1-P[i]/100, M-k) * C[M][k];\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int Max=109;\n#define LL long long\nLL C[52][52];\n\nstruct P{\n\tint t,v;\n\tdouble p;\n}stu[Max];\n\n\ndouble poww(double p,int t){\n\tdouble s=1;\n\tfor(int i=0;i<t;i++)\n\t\ts*=p;\n\treturn s;\n}\n\nint main(){\n\tC[0][0]=1;\n\tfor (int i=1; i<=50; ++i)\n\t{\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1]);\n\t}\n\tdouble l;\n\tint n,st;\n\twhile(scanf(\"%d %d %lf\",&n,&st,&l)==3){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %d %d\",&stu[i].p,&stu[i].t,&stu[i].v);\n\t\t\tstu[i].p/=100;\n\t\t}\n\t\tdouble pp,t,t1,p2,ppp;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tppp=0;\n\t\t\tfor(int j=0;j<=st;j++){\n\t\t\t\tt=j*stu[i].t+l/stu[i].v;\n\t\t\t\tpp=C[st][j]*pow(stu[i].p,(double)j)*pow((1-stu[i].p),(double)(st-j));\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(k==i)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp2=0;\n\t\t\t\t\tfor(int u=0;u<=st;u++){\n\t\t\t\t\t\tt1=u*stu[k].t+l/stu[k].v;\n\t\t\t\t\t\tif(t1>t)\n\t\t\t\t\t\t\tp2+=C[st][u]*pow(stu[k].p,(double)u)*pow((1-stu[i].p),(double)(st-u));\n\t\t\t\t\t}\n\t\t\t\t\tpp*=p2;\n\t\t\t\t}\n\t\t\t\tppp+=pp;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\",ppp);\n\t\t}\n\t}\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    using namespace std;\n    double c[101][101],p[101][51],notp[101][51];\n    double t[101],v[101],ans[101];\n    int main()\n    {\n        int n,m,i,j,k,ii;\n        double l,sum;\n        scanf(\"%d%d%lf\",&n,&m,&l);\n        c[0][0]=1;\n        for(i=1;i<=100;++i)\n        {\n            c[i][0]=1;\n            for(j=1;j<=i;++j)\n                c[i][j]=c[i-1][j-1]+c[i-1][j];\n        }\n        //cout <<c[100][50]<<endl;\n        for(i=0;i<n;++i)\n        {\n            scanf(\"%lf%lf%lf\",&p[i][1],&t[i],&v[i]);\n            p[i][1]/=100;\n            notp[i][0]=p[i][0]=1;\n            notp[i][1]=1-p[i][1];\n            for(j=2;j<=m;++j)\n                p[i][j]=p[i][j-1]*p[i][1],notp[i][j]=notp[i][j-1]*notp[i][1];\n        }\n        double sp,ap,at,tim;\n        for(ii=0;ii<n;++ii)\n        {\n            ans[ii]=0;\n            for(i=0;i<=m;++i)\n            {\n                sp=c[m][i]*p[ii][i]*notp[ii][m-i];\n                tim=i*t[ii]+l/v[ii];\n                //cout <<ii<<\" \"<<i<<\" \"<<sp<<\" \"<<tim<<endl;\n                for(j=0;j<n;++j)\n                {\n                    if(j==ii)continue;\n                    sum=0;\n                    for(k=0;k<=m;++k)\n                    {\n                        ap=c[m][k]*p[j][k]*notp[j][m-k];\n                        at=k*t[j]+l/v[j];\n                        if(at>tim)\n                        {\n                            sum+=ap;\n                        }\n                    }\n                    sp*=sum;\n                }\n                ans[ii]+=sp;\n            }\n        }\n        //cout<<c[50][20]<<\" \"<<p[2][20]<<\" \"<<p[2][30]<<\" \"<<c[50][20]*p[2][20]*p[2][30]<<endl;\n        for(i=0;i<n;++i)\n        printf(\"%.5f\\n\",ans[i]);\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);  \n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t}\n\t  }\n\t  /*\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << dist[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << sum[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = lower_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n//\t\t\t\t\t\tcout << id << \": *= \" << sum[k][id] <<  endl;;\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t\tans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  /*\n\t  \t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << ans[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  tmp += ans[i][j];\n//\t\t\tcout << tmp << endl;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\nconst double INF=1e77;\n\nconst int N_BIN=50;\ndouble nCr[N_BIN+1][N_BIN+1];\nvoid binom(){\n\trep(n,N_BIN+1) nCr[n][0]=1;\n\trep(n,N_BIN) rep(r,n+1) nCr[n+1][r+1]=nCr[n][r+1]+nCr[n][r];\n}\n\nint main(){\n\tbinom();\n\n\tint n,m,L; scanf(\"%d%d%d\",&n,&m,&L);\n\tdouble p[100];\n\tint rest[100],v[100];\n\trep(i,n) scanf(\"%lf%d%d\",p+i,rest+i,v+i), p[i]/=100;\n\n\tdouble t[100][51],q[100][51];\n\trep(i,n) rep(j,m+1) {\n\t\tif(v[i]>0) t[i][j]=(double)L/v[i]+j*rest[i];\n\t\telse       t[i][j]=INF;\n\t\tq[i][j]=nCr[m][j]*pow(p[i],j)*pow(1-p[i],m-j);\n\t}\n\n\trep(i,n){\n\t\tif(v[i]==0){ puts(\"0\"); continue; }\n\n\t\tdouble ans=0;\n\t\trep(j,m+1){\n\t\t\tdouble pr=q[i][j];\n\t\t\trep(k,n) if(i!=k) {\n\t\t\t\tdouble tmp=0;\n\t\t\t\trep(l,m+1) if(t[k][l]<0 || t[i][j]+EPS<t[k][l]) tmp+=q[k][l];\n\t\t\t\tpr*=tmp;\n\t\t\t}\n\t\t\tans+=pr;\n\t\t}\n\t\tprintf(\"%.15f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define eps 0.0000001\n\n\nbool zero(double a,double b){\n    if((a-b)<eps && (a-b)>-eps)return true;\n    return false;\n}\n\ndouble c[110][110];\nint n,m;\ndouble l;\nstruct player{\n    double p;\n    double t;\n    double v;\n}pl[210];\ndouble rp[210][110];\ndouble sp[210][110];\n\n\nvoid init(){\n    int i,j;\n    for(i=0;i<110;i++){\n        c[i][0]=1;\n        for(j=1;j<i;j++){\n            c[i][j]=c[i-1][j]+c[i-1][j-1];\n        }\n        c[i][i]=1;\n    }\n    /*\n    for(i=0;i<10;i++){\n        for(j=0;j<10;j++){\n            printf(\"%.0f \",c[i][j]);\n        }\n        printf(\"\\n\");\n    }\n*/\n}\ndouble ppow(double p,int k){\n    if(k==0)return 1.0;\n    else if(k==1)return p;\n    double ret = ppow(p*p,k/2);\n    if(k%2==0)return ret;\n    else return ret*p;\n}\n\ndouble res[210];\ndouble tmp;\ndouble solve(double p,int m,int n)\n{\n    double ret=1;\n    for(int i=0;i<n;i++)\n    {\n        ret=ret*(m-i);\n        ret=ret/(i+1);\n        ret=ret*p;\n    }\n    for(int i=n;i<m;i++)\n    {\n        ret=ret*(1.0-p);\n    }\n    \n    return ret;\n}\nint main(){\n    \n    //freopen(\"D.in\", \"r\", stdin);\n    //freopen(\"D.out3\", \"w\", stdout);\n    \n    int i,j,k;\n    double t;\n    int ti;\n\n    init();\n    while(scanf(\"%d%d%lf\",&n,&m,&l) != EOF){\n        for(i=0;i<n;i++){\n            scanf(\"%lf%lf%lf\",&pl[i].p,&pl[i].t,&pl[i].v);\n            //cout<<pl[i].p<<endl;\n            pl[i].p=pl[i].p/100.0;\n            for(j=0;j<=m;j++){\n                rp[i][j]=solve(pl[i].p,(int)m,(int)j);\n                //c[m][j]*ppow((1.0-pl[i].p),m-j)*ppow(pl[i].p,j);\n                if(j==0)sp[i][j]=rp[i][j];\n                else sp[i][j]=sp[i][j-1]+rp[i][j];\n            }\n        }/*\n        for(i=0;i<n;i++){\n            for(j=0;j<=m;j++){\n                printf(\"<%f,%f> \",rp[i][j],sp[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        \n\n        for(i=0;i<n;i++){\n            res[i]=0.0;\n            for(j=0;j<=m;j++){\n                tmp=1.0;\n                for(k=0;k<n;k++){\n                    if(i!=k){\n                        if(l/pl[i].v+pl[i].t*(double)j<l/pl[k].v){\n                            continue;\n                        }\n                        else if(l/pl[i].v+pl[i].t*(double)j>l/pl[k].v+m*pl[k].t || zero(l/pl[i].v+pl[i].t*(double)j,l/pl[k].v+m*pl[k].t)){\n                            tmp=0.0;\n                            break;\n                        }\n                        else{\n                            t=l/pl[i].v+pl[i].t*(double)j-l/pl[k].v;\n                            ti=(int)(t/pl[k].t);\n                            //if(zero(pl[k].t*ti,t))ti--;\n                            tmp*=(1.0-sp[k][ti]);\n                        }\n                    }\n                }\n                res[i]+=tmp*rp[i][j];\n            }\n            if(res[i]<eps)res[i]=0.0;\n        }\n        for(i=0;i<n;i++){\n            printf(\"%.8f\\n\",res[i]);\n        }\n        //printf(\"\\n\");\n        break;\n    }\n\n    //while(1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nconst int N = 100;\n\n//n???????????¶????????????????????????k???????????¶???????????????????????????\nvoid Pascals(double m[N][N]){\n\tm[0][0] = 1;\n\trange(i,1,N){\n\t\trep(j,i + 1){\n\t\t\tif(j == 0) m[i][j] = m[i - 1][j];\n\t\t\telse if(j == i) m[i][j] = m[i - 1][j - 1];\n\t\t\telse m[i][j] = (m[i - 1][j] + m[i - 1][j - 1]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, l;\n\tcin >> n >> m >> l;\n\n\tvector<double> p(n), t(n), v(n);\n\trep(i,n){\n\t\tcin >> p[i] >> t[i] >> v[i];\n\t\tp[i] /= 100;\n\t}\n\n\tdouble pas[N][N];\n\tPascals(pas);\n\tdouble c[100][100] = {{0}};\n\trep(i,n){\n\t\tdouble rest_p = 1;\n\t\tdouble run_p = 1;\n\t\trep(j,m) run_p *= (1 - p[i]);\n\t\trep(j,m + 1){\n\t\t\tc[i][j + 1] = c[i][j] + rest_p * run_p * pas[m][j];\n\t\t\t//show(c[i][j + 1])\n\t\t\t//cout << rest_p << ' ' << run_p << endl;\n\t\t\trest_p *= p[i];\n\t\t\trun_p /= (1 - p[i]);\n\t\t}\n\t}\n\n\n\tvector<int> base_time(n);\n\trep(i,n) base_time[i] = l / v[i];\n\trep(i,n){\n\t\tdouble ans = 0;\n\t\trep(j,m + 1){\n\t\t\tdouble cul = c[i][j + 1] - c[i][j];\n\t\t\t//cout << \"saisyo \" <<  cul << endl;\n\t\t\tdouble time = base_time[i] + j * t[i];\n\t\t\t//show(time)\n\t\t\trep(k,n){\n\t\t\t\tif(i == k) continue;\n\t\t\t\tif(t[k] == 0){\n\t\t\t\t\tif(time >= base_time[k]) cul *= 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint rest = ceil((time - base_time[k]) / t[k]);\n\t\t\t\tif(rest * t[k] + base_time[k] <= time) rest++;\n\t\t\t\t//cout << \"rest \" << rest << endl;\n\t\t\t\tcul *= 1 - c[k][rest];\n\t\t\t\t//show(cul)\n\t\t\t\t//show(1 - c[k][rest])\n\t\t\t}\n\t\t\tif(isnan(cul)) continue;\n\t\t\t//show(cul)\n\t\t\t//show(ans)\n\t\t\tans += cul;\n\t\t\t//show(ans)\n\t\t}\n\t\tcout << fixed << setprecision(10)<<ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<stdlib.h>\n#include<ctype.h>\n#include<queue>\n#include<bitset>\n#include<deque>\n#include<set>\n#include<time.h>\n#include<sstream>\n#include<functional>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n\n#define LL long long\n\n\ndouble p[1009];\ndouble t[1009], v[1009];\ndouble n,m,l;\nLL dp[309][309];\n\nvoid init(){\n\t/*for(int i=0;i<=101;i++)\n\t\tfor(int j=0;j<=101;j++)\n\t\t\tdp[i][j]=0;\n\tfor(int i=0;i<=101;i++){\n\t\tdp[0][i] = dp[i][0] = dp[i][i] =1;\n\t\tdp[1][i]=i;\n\t}\n\tdp[0][0]=0;\n\tfor(int i=1;i<=101;i++)\n\t\tfor(int j=1;j<=101;j++){\n\t\t\tif( i != j)\n\t\t\t\tdp[i][j] = (dp[i][j-1] + dp[i-1][j-1]);\n\t\t}*/\n\tdp[0][0]=1;\n\tfor (int i=1; i<=50; ++i) \n\t{\n\t\tdp[i][0]=dp[i][i]=1;\n\t\tfor (int j=1; j<i; ++j)\n\t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][j-1]);\n\t}\n}\ndouble cc(int num,int m){\n\treturn double(dp[m][num]);\n}\ndouble _pow(double p,int k){\n\tdouble tmp=1.0;\n\tfor(int i=0;i<k;i++)\n\t\ttmp*=p;\n\treturn tmp;\n}\ndouble cul(int num,double p){\n\treturn cc(num,m)*_pow(p*1.0,num)*_pow(1.0*(1-p),m-num);\n}\nint main()\n{\n\tinit();\n\twhile(scanf(\"%lf%lf%lf\", &n, &m, &l)!=EOF){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf%lf%lf\", &p[i], &t[i], &v[i]);\n\t\t\tp[i] = p[i]/100;\n\t\t}\n\t\tfor(int wp=0; wp<n; wp++){\n\t\t\tdouble wpp=0;\n\t\t\tfor(int xx=0; xx<=m; xx++){\n\n\t\t\t\tdouble at = l/v[wp] + xx*t[wp];\n\t\t\t\tdouble pp = cul(xx, p[wp]);\n\n\t\t\t\tfor(int lp=0; lp<n;lp++){\n\n\t\t\t\t\tif(lp == wp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble np=0;\n\t\t\t\t\tfor(int xi=0; xi<=m; xi++){\n\n\t\t\t\t\t\tdouble lt = l/v[lp] + xi*t[lp];\n\t\t\t\t\t\tif(lt > at){\n\t\t\t\t\t\t\tnp += cul(xi, p[lp]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpp *= np;\n\t\t\t\t}\n\n\t\t\t\twpp += pp;\n\t\t\t}\n\t\t\tprintf(\"%.8lf\\n\",wpp);\n\t\t}\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<double> vd;\n\ndouble mypow(double b ,int e){\n\t  if(e == 0) return 1;\n\t  if(e%2==0)\n\t\t\treturn mypow( b*b, e/2 );\n\t  else\n\t\t\treturn mypow( b*b, e/2 ) * b;\n}\n\nint main(){\n\n\n\t  int N,M,L; cin >> N >> M >> L ;\n\t  if(N==1){\n\t\t\tcout << 1.0 << endl;\n\t\t\treturn 0;\n\t  }\n\t  vector<vd> prob(N,vd(M+1,0.0));\n\t  vector<vd> dist(N,vd(M+1,0.0));\n\n\t  vd p(N),t(N),v(N);\n\t  for(int i=0; i<N; i++)\tcin >> p[i] >> t[i] >> v[i];\n\n\t  // PRE PROCESS\n\t  for(int i=0; i<N; i++){\n\t\t\tdist[i][0] = (double)L / v[i];\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  dist[i][j] = dist[i][j-1] + t[i];\n\t\t\t}\n\t  }\n\t  for(int i=0; i<N; i++)\n\t\t\tprob[i][0] = mypow((100-p[i])/100,M);\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=1; j<=M; j++){\n\t\t\t\t  if(p[i] != 100)\n\t\t\t\t\t\tprob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n\t\t\t\t  else\n\t\t\t\t\t\tprob[i][j] = 1.0;\n\t\t\t}\n\t  }\n\t  double comb = 1;\n\t  for(int j=1; j<=M; j++){\n\t\t\tcomb = comb * (M - j + 1) / j; \n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t  prob[i][j] *= comb;\n\t\t\t}\n\t  }\n\t  \n\t  vector<vd> sum = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=M-1; j>=0; j--){\n\t\t\t\t  sum[i][j] += sum[i][j+1];\n\t\t\t\t  if(sum[i][j] > 1) sum[i][j] = 1;\n\t\t\t}\n\t  }\n\t  /*\n\t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << dist[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << prob[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  vector<vd> ans = prob;\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++){\n\t\t\t\t  for(int k=0; k<N; k++){\n\t\t\t\t\t\tif(i==k) continue;\n\t\t\t\t\t\tint id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n\t\t\t\t\t\tif(id > M) ans[i][j] = 0.0;\n\t\t\t\t\t\telse \t   ans[i][j] *= sum[k][id];\n\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  /*\n\t  \t  \t  //DUMP\n\t  for(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  cout << ans[i][j] << \" \";\n\t\t\tcout << endl;\n\t  }\n\t  */\n\t  for(int i=0; i<N; i++){\n\t\t\tdouble tmp = 0.0;\n\t\t\tfor(int j=0; j<=M; j++)\n\t\t\t\t  tmp += ans[i][j];\n//\t\t\tcout << tmp << endl;\n\t\t\tif(tmp > 1) tmp = 0;\n\t\t\tprintf(\"%.10f\\n\",tmp);\n\t  }\n\t\t\t\t\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\nusing namespace std;\nint n, m, l, p[111], t[111], v[111]; long double r[111][55], dp[55][55];\nint main() {\n\tcin >> n >> m >> l;\n\tfor (int i = 0; i < n; i++) cin >> p[i] >> t[i] >> v[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= m; j++) fill(dp[j], dp[j] + m + 1, 0.0);\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j + 1][k] += dp[j][k] * (100 - p[i]) / 100;\n\t\t\t\tdp[j + 1][k + 1] += dp[j][k] * p[i] / 100;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= m; j++) r[i][j] = dp[m][j];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tlong double ret = 0;\n\t\tif (v[i] != 0) {\n\t\t\tlong double time1 = 1.0L * l / v[i];\n\t\t\tfor (int j = 0; j <= m; j++, time1 += t[i]) {\n\t\t\t\tlong double res = r[i][j];\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (i == k) continue;\n\t\t\t\t\tlong double sum = 0;\n\t\t\t\t\tif (v[k] != 0) {\n\t\t\t\t\t\tdouble time2 = 1.0 * l / v[k];\n\t\t\t\t\t\tfor (int l = 0; l <= m; l++, time2 += t[k]) {\n\t\t\t\t\t\t\tif (time1 + 1e-10L < time2) sum += r[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres *= sum;\n\t\t\t\t}\n\t\t\t\tret += res;\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nint n,m,l,p[100],t[100],v[100];\ndouble time[100][51],poss[100][51],c[0][51],ans,sum[100][51];\nint main(){\n        scanf(\"%d%d%d\",&n,&m,&l);\n        c[1][0]=c[1][1]=1;\n        for (int i=2;i<=m;i++){\n                c[i%2][0]=c[i%2][i]=1;\n\t\tfor (int j=1;j<i;j++) c[i%2][j]=c[(i+1)%2][j-1]+c[(i+1)%2][j];\n        }\n        for (int i=0;i<n;i++){\n                scanf(\"%d%d%d\",&p[i],&t[i],&v[i]);\n                time[i][0]=(double)l/v[i];\n                for (int j=1;j<=m;j++) time[i][j]=time[i][j-1]+t[i];\n                for (int j=0;j<=m;j++) poss[i][j]=c[m%2][j]*pow((double)p[i]/100,j)*pow(1-(double)p[i]/100,m-j);\n\t\tsum[i][m]=poss[i][m];\n\t\tfor (int j=m-1;j>=0;j--) sum[i][j]=sum[i][j+1]+poss[i][j];\n        }\n\tfor (int i=0;i<n;i++){\n\t\tans=0;\n\t\tfor (int j=0;j<=m;j++){\n\t\t\tdouble cur=1,cur_t=time[i][j];\n\t\t\tfor (int k=0;k<n;k++) if (i!=k){\n\t\t\t\tint l=0,r=m,mid,res;\n\t\t\t\twhile (l<=r){\n\t\t\t\t\tmid=l+r>>1;\n\t\t\t\t\tif (time[k][mid]>cur_t){\n\t\t\t\t\t\tres=mid;\n\t\t\t\t\t\tr=mid-1;\n\t\t\t\t\t}\t\n\t\t\t\t\telse l=mid+1; \n\t\t\t\t}\n\t\t\t\tif (time[k][res]>cur_t) cur*=sum[k][res];\n\t\t\t\telse cur=0;\n\t\t\t}\n\t\t\tans+=cur*poss[i][j];\n\t\t}\n\t\tprintf(\"%.10f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define M 51\nusing namespace std;\nint n,m,l;\ndouble p[N],t[N],d[N],mem[M][M];\n\ndouble nCr(int n, int r){\n  if(mem[n][r]!=0)return mem[n][r];\n  double a=1;\n  for(int i=0;i<r;i++) a*=(n-i)/(i+1.0);\n  return mem[n][r]=a;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=pow(1-p[0],m-i)*pow(p[0],i)*nCr(m,i);\n  \n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(d[0]+j*t[0]<d[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*pow(1-p[i],m-k)*pow(p[i],k)*nCr(m,k);\n\n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++){\n    cin>>p[i]>>t[i]>>d[i];\n    p[i]/=100;\n    d[i]=l/d[i];\n  }\n  \n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(d[0],d[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M, L;\n\nvector<tuple<int, int, int>> vs;\n\ndouble P[111][111];\ndouble T[111][111];\n\nnamespace math { namespace combination {\n\n#define COMBINATION_MAX 200\nusing return_type = ll;\n\nnamespace memorized { namespace combination { enum { max_value = COMBINATION_MAX }; bool __computed = false; inline bool computed() {if(__computed) { return true; } else { __computed = true; return false; }} return_type dp[max_value][max_value];} }\n\nreturn_type comb(int N, int K) {\n  using memorized::combination::dp;\n  if(memorized::combination::computed()) { return dp[N][K]; }\n\n  // Make binomial coefficient\n  using memorized::combination::max_value;\n\n  rep(i, max_value) {\n    dp[i][0] = 1;\n    REP(j, 1, i+1) {\n      dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n//      dp[i][j] %= MOD;\n    }\n  }\n  return dp[N][K];\n}}}\n\nvoid solve() {\n  using math::combination::comb;\n  rep(i, N) {\n    rep(j, M+1) {\n      P[i][j] = pow(get<0>(vs[i]) * 0.01, j) * pow((100-get<0>(vs[i])) * 0.01, M - j) * comb(M, j);\n      if(j) T[i][j] = T[i][j-1] + get<2>(vs[i]);\n      else T[i][0] = 1.0 * L / get<1>(vs[i]);\n    }\n  }\n\n  rep(i, N) {\n    double res = 0;\n\n    if(get<1>(vs[i]) == 0) {\n      cout << \"0\\n\";\n      continue;\n    }\n\n    rep(j, M+1) {\n      double losers_prob = 1.0;\n      rep(k, N) {\n        if(i == k) continue;\n        double sum = 0.0;\n        rep(l, M+1) {\n          if(T[i][j] < T[k][l]) sum += P[k][l];\n        }\n        losers_prob *= sum;\n      }\n      res += losers_prob * P[i][j];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint main() {\n\n  cin >> N >> M >> L;\n  rep(i, N) {\n    int p, t, v; cin >> p >> t >> v;\n    vs.push_back({p, v, t});\n  }\n\n  N = vs.size();\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define PB push_back\n\ntypedef vector<double> vd;\n\nconst ll M=1000000000;\n\nclass Runner {\npublic:\n\tvd goal_times;\n\tvd probabilities;\n\n\tRunner() {\n\t\tgoal_times = vd();\n\t\tprobabilities = vd();\n\t}\n\n\tvoid inspect() {\n\t\tcerr << \"goal_times\" << endl;\n\t\tREP(i, goal_times.size()) {\n\t\t\tcerr << \" \" << goal_times[i];\n\t\t}\n\t\tcerr << endl;\n\t\tcerr << \"probabilities\" << endl;\n\t\tREP(i, probabilities.size()) {\n\t\t\tcerr << \" \" << probabilities[i];\n\t\t}\n\t\tcerr << endl;\n\t}\n};\n\nll extgcd(ll a, ll b, ll &x, ll &y)\n{\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\nint mod_inverse(int a, int m)\n{\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//int fact[INT_MAX];\n//int mod_fact(int n, int p, int &e)\n//{\n//\te = 0;\n//\tif (n == 0) return 1;\n//\tint res = mod_fact(n / p, p, e);\n//\te += n / p;\n//\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n//\treturn res * fact[n % p] % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (n < 0 || k < 0 || n < k) return 0;\n//\tint e1, e2, e3;\n//\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n//\tif (e1 > e2 + e3) return 0;\n//\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n//}\n\n//ll combination(int n, int k)\n//{\n//\tif (k < 1) return 1;\n//\tll bunshi = 1, bunbo = 1;\n//\tll ans=1;\n//\tREP(i,n){\n//\t\tbunshi*=n-i;\n//\t\tbunshi%=M;\n//\t}\n//\tREP(i,k){\n//\t\tbunbo*=k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tREP(i,n-k){\n//\t\tbunbo*=n-k-i;\n//\t\tbunbo%=M;\n//\t}\n//\tans=bunshi;\n//\tans*=mod_inverse\n//\treturn mod_inverse(bunshi,\n//\t\n//\tREP(i,n-k){\n//\t\tans*=bunshi;\n//\t\tans/=bunbo;\n//\t\tbunshi--;\n//\t\tbunbo--;\n//\t}\n//\tcerr << n << \", \" << k << \" => \" << ans << endl;\n//\treturn ans;\n//}\n\nll combination(int n,int k){\n\tif (k < 1) return 1;\n\tll ans=1;\n\tFOR(i,1,n-k+1){\n\t\tans*=n-i+1;\n\t\tans/=i;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcout.precision(16);\n\tint N, M, L; cin >> N >> M >> L;\n\tvector<Runner> runners;\n\tREP(i, N) {\n\t\tRunner runner;\n\t\tdouble P; int T, V; cin >> P >> T >> V; P /= 100.0;\n\t\tdouble base_time = V > 0 ? (double)L / V : INT_MAX;\n\t\tREP(t_break, M + 1) {\n\t\t\trunner.goal_times.PB(base_time + T * t_break);\n\t\t\trunner.probabilities.PB(\n\t\t\t\tpow(P, t_break) * pow(1 - P, M - t_break) * combination(M, t_break) );\n\t\t}\n\t\trunners.PB(runner);\n\t\t//runner.inspect();\n\t}\n\n\tREP(i, runners.size()) {\n\t\tRunner &r = runners[i];\n\t\tdouble ans = 0;\n\t\tREP(t, M + 1) {\n\t\t\tdouble prize_prob = r.probabilities[t];\n\t\t\tREP(j, runners.size()) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tRunner &comp = runners[j];\n\t\t\t\tdouble win_prob = 0;\n\t\t\t\tREP(k, M+1) {\n\t\t\t\t\tif(comp.goal_times[k] > r.goal_times[t]) {\n\t\t\t\t\t\twin_prob += comp.probabilities[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprize_prob *= win_prob;\n\t\t\t}\n\t\t\tans += prize_prob;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 111\n#define M 55\nusing namespace std;\nint n,m;\ndouble l,p[N],t[N],v[N];\nvector<double> A[N],B[N];\n\ndouble nCr(int n, int r){\n  if(r==0||n==r)return 1;\n  double a=1,b=1;\n  for(int i=0;i<n-r;i++)a*=(n-i);\n  for(int i=1;i<=r;i++)b*=i;\n  return a/b;\n}\n\ndouble DP(){\n  double dp[N][M]={};\n  for(int i=0;i<=m;i++)dp[0][i]=A[0][m-i]*B[0][i]*nCr(m,i);\n\n  for(int i=1;i<n;i++)\n    for(int j=0;j<=m;j++)\n      for(int k=0;k<=m;k++)\n\tif(l/v[0]+j*t[0]<l/v[i]+k*t[i]) \n\t  dp[i][j]+=dp[i-1][j]*A[i][m-k]*B[i][k]*nCr(m,k);\n  \n  double res=0;\n  for(int i=0;i<=m;i++)res+=dp[n-1][i];\n  return res;\n}\n\nint main(){\n  cin>>n>>m>>l;\n  for(int i=0;i<n;i++)cin>>p[i]>>t[i]>>v[i],p[i]/=100;\n  for(int i=0;i<n;i++) {\n    //A???j?????????????????£????¢????\n    //B???j?????????????¢???????\n    A[i]=B[i]=vector<double>(m+1,0);\n    A[i][0]=B[i][0]=1;\n    if(p[i]==1)A[i]=vector<double>(m+1,0),A[i][0]=1;\n    if(p[i]==0)B[i]=vector<double>(m+1,0),B[i][0]=1;\n    for(int j=1;j<=m;j++){\n      A[i][j]=A[i][j-1]*(1-p[i]),B[i][j]=B[i][j-1]*p[i];\n      \n    }\n  }\n  for(int i=0;i<n;i++){\n      printf(\"%.10f\\n\",DP());\n      swap(p[0],p[i+1]);\n      swap(t[0],t[i+1]);\n      swap(v[0],v[i+1]);    \n      swap(A[0],A[i+1]);    \n      swap(B[0],B[i+1]);    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef vector<int> vi;\ntypedef vector<double> vd;\n \ndouble mypow(double b ,int e){\n      if(e == 0) return 1;\n      if(e%2==0)\n            return mypow( b*b, e/2 );\n      else\n            return mypow( b*b, e/2 ) * b;\n}\n \nint main(){\n \n \n      int N,M,L; cin >> N >> M >> L ;\n      if(N==1){\n            cout << 1.0 << endl;\n            return 0;\n      }\n      vector<vd> prob(N,vd(M+1,0.0));\n      vector<vd> dist(N,vd(M+1,0.0));\n \n      vd p(N),t(N),v(N);\n      for(int i=0; i<N; i++) cin >> p[i] >> t[i] >> v[i];\n \n      // PRE PROCESS\n      for(int i=0; i<N; i++){\n            dist[i][0] = (double)L / v[i];\n            for(int j=1; j<=M; j++){\n                  dist[i][j] = dist[i][j-1] + t[i];\n            }\n      }\n      for(int i=0; i<N; i++)\n            prob[i][0] = mypow((100-p[i])/100,M);\n      for(int i=0; i<N; i++){\n            for(int j=1; j<=M; j++){\n                  if(p[i] != 100)\n                        prob[i][j] = (prob[i][j-1] * (p[i]/100)) / ((100-p[i])/100);\n                  else\n                        prob[i][j] = 1.0;\n            }\n      }\n      double comb = 1;\n      for(int j=1; j<=M; j++){\n            comb = comb * (M - j + 1) / j; \n            for(int i=0; i<N; i++){\n                  prob[i][j] *= comb;\n            }\n      }\n       \n      vector<vd> sum = prob;\n      for(int i=0; i<N; i++){\n            for(int j=M-1; j>=0; j--){\n                  sum[i][j] += sum[i][j+1];\n                  if(sum[i][j] > 1) sum[i][j] = 1;\n            }\n      }\n \n      vector<vd> ans = prob;\n      for(int i=0; i<N; i++){\n            for(int j=0; j<=M; j++){\n                  for(int k=0; k<N; k++){\n                        if(i==k) continue;\n                        int id = upper_bound(dist[k].begin(),dist[k].end(), dist[i][j]) - dist[k].begin();\n                        if(id > M) ans[i][j] = 0.0;\n                        else       ans[i][j] *= sum[k][id];\n \n                  }\n            }\n      }\n \n      for(int i=0; i<N; i++){\n            double tmp = 0.0;\n            if(p[i] == 100) tmp = ans[i][M];\n            else\n                  for(int j=0; j<=M; j++)\n                        tmp += ans[i][j];\n            if(tmp > 1) tmp = 0;\n            printf(\"%.10f\\n\",tmp);\n      }\n                         \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#define INF 0x7fffffff\n#define eps 1e-5\ndouble at[205][5],p[205][95];\ndouble c[95][95];\ndouble fun(int m,int n,double p)\n{\n    if(m == 0 && p < eps) return 1;\n    return c[m][n]*pow(p,m)*pow(1-p,n-m);\n}\nvoid init()\n{\n    int i,j;\n    c[0][1] = c[1][1] = 1.0;\n    for(i = 2; i <= 50; i ++)\n    for(j = 0; j <= i; j ++)\n    {\n        if(j == 0||j == i)\n        c[j][i] = 1.0;\n        else c[j][i] = c[j][i-1]+c[j-1][i-1];\n    }\n    //for(i = 0; i <= 50; i ++)\n    //printf(\"%.0lf \",c[i][50]);\n}\nint main()\n{\n    int n,m;\n    int i,j,k,l,y;\n    init();\n    //for(j = 0; j <= 50; j ++)\n    //printf(\"%I64d\\n\",c[j][50]);\n    //printf(\"\\n\");\n    //freopen(\"in29.txt\",\"r\",stdin);\n    //freopen(\"c.out\",\"w\",stdout);\n    //printf(\"%lf\\n\",pow(0,1));\n    double x,mint,L,myt,ans,as;\n    while(~scanf(\"%d%d%lf\",&n,&m,&L))\n    {\n        for(i = 1; i <= n; i ++)\n        scanf(\"%lf%lf%lf\",&x,&at[i][1],&at[i][2]),at[i][0] = x/100.0;\n        for(i = 1; i <= n; i ++)\n        {\n            double as = 0.0;\n            for(j = m; j >= 0; j --)\n                p[i][j] = fun(j,m,at[i][0]);\n            p[i][m+1] = 0;\n            //printf(\"%lf \",p[i][0]);\n        }\n        for(i = 1; i <= n; i ++)\n        {\n            ans = 0.0;\n            if(at[i][2] < eps)\n            {\n                printf(\"%.8lf\\n\",ans);\n                continue;\n            }\n            for(j = 0; j <= m; j ++)\n            {\n                    myt = L/at[i][2] + j*1.0*at[i][1];\n                    double a= p[i][j];\n                    for(k = 1; k <= n; k ++)\n                    {\n                        if(k == i) continue;\n                        double as = 0.0;\n                        if(at[k][2] < eps) as = 1.0;\n                        else\n                        {\n                            for(l = m; l >= 0; l --)\n                            {\n                                if(eps+myt < L/at[k][2] + l*1.0*at[k][1])\n                                as += p[k][l];\n                                else break;\n                            }\n                        }\n                        //if(l < m)\n                        a *= as;\n                        //printf(\"a = %lf\\n\",a);\n                    }\n                    ans += a;\n            }\n            printf(\"%.8lf\\n\",ans);\n        }\n    }\nreturn 0;\n}\n/*\n3 0 30\n0 0 0\n0 1 1\n0 1 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ndouble eps=1e-9,inf=1e10;\ntypedef pair<double,double> P;\ntypedef pair<P,int> PP;\nvector<PP> vc;\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\trep(i,n){\n\t\tdouble p,t,v;\n\t\tcin>>p>>t>>v;\n\t\tp/=100;\n\t\tif(p==1){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v+m*t;\n\t\t\tvc.pb(PP(P(tt,1),i));\n\t\t\t//cout << \"i\" << i << \" \" << tt << \" \" << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(p==0){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v;\n\t\t\tvc.pb(PP(P(tt,1),i));\n\t\t\t//cout << \"i\" << i << \" \" << tt << \" \" << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tdouble pro=1;\n\t\trep(j,m) pro*=(1-p);\n\t\trep(j,m+1){\n\t\t\tdouble tt;\n\t\t\tif(v==0) tt=inf;\n\t\t\telse tt=l/v+j*t;\n\t\t\tvc.pb(PP(P(tt,pro),i));\n\t\t\t//cout << \"i\" << i << \" \" << tt << \" \" << pro << endl;\n\t\t\tpro*=p/(1-p);\n\t\t\tpro*=(double)(m-j)/(j+1);\n\t\t}\n\t}\n\tsort(all(vc));\n\tdouble ans[100]={};\n\trep(i,vc.size()){\n\t\tif(vc[i].fs.fs>1e9) break;\n\t\tdouble cnt[100]={};\n\t\tfor(int j=i+1;j<vc.size();j++){\n\t\t\tif(vc[j].fs.fs<vc[i].fs.fs+eps) continue;\n\t\t\tcnt[vc[j].sc]+=vc[j].fs.sc;\n\t\t}\n\t\tdouble ret=1;\n\t\trep(j,n){\n\t\t\tif(j==vc[i].sc) ret*=vc[i].fs.sc;\n\t\t\telse ret*=cnt[j];\n\t\t}\n\t\tans[vc[i].sc]+=ret;\n\t}\n\trep(i,n) printf(\"%.9f\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\nlong long c[55][55];\ndouble dp1[105][52],dp2[105][52];\nint main()\n{\n    for(int i=0;i<=50;++i)\n    {\n        c[i][0]=c[i][i]=1;\n        for(int j=1;j<i;++j) c[i][j]=(c[i-1][j]+c[i-1][j-1]);\n    }\n    int n,m,L,P[105],T[105],V[105];\n    scanf(\"%d%d%d\",&n,&m,&L);\n    for(int i=0;i<n;++i) scanf(\"%d%d%d\",&P[i],&T[i],&V[i]);\n    for(int i=0;i<n;++i)\n    {\n        double p[2][55];\n        p[0][0]=1.0;\n        p[1][0]=1.0;\n        for(int j=1;j<=m;++j)\n        {\n            p[0][j]=p[0][j-1]*P[i]/100;\n            p[1][j]=p[1][j-1]*(100-P[i])/100;\n        }\n        for(int j=0;j<=m;++j)\n        {\n            dp1[i][j]=c[m][j]*p[0][j]*p[1][m-j];\n            dp2[i][j]=L*1.0/V[i]+j*T[i];\n        }\n    }\n    for(int i=0;i<n;++i)\n    {\n        double ans=0;\n        for(int j=0;j<=m;++j)\n        {\n            double tp=dp1[i][j];\n            double lim=dp2[i][j];\n            for(int x=0;x<n;++x)\n            {\n                if(x==i) continue;\n                double q=0;\n                for(int y=m;y>=0;--y) if(dp2[x][y]>lim) q+=dp1[x][y];\n                tp*=q;\n            }\n            ans+=tp;\n        }\n        printf(\"%.8lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define eps 1e-14\ndouble f_pow(double x,int n){\n\tdouble res=1;\n\twhile(n--)res*=x;\n\treturn res;\n}\n\nstruct Man{\n\tdouble p,t,v;\n\tvoid get(){\n\t\tscanf(\"%lf%lf%lf\",&p,&t,&v);\n\t\tp/=100;\n\t}\n};\nMan man[100];\nint N,M;\ndouble L;\ndouble tim[100][51],tsum[100][51];\ndouble rate[100][51];\ndouble C[51][51];\nvoid get_C(){\n\tint i,j;\n\tC[0][0]=1;\n\tC[1][0]=C[1][1]=1;\n\tfor(i=2;i<51;i++){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;j++){\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n\t}\n}\nvoid get_data(){\n\tscanf(\"%d%d%lf\",&N,&M,&L);\n\tint i;\n\tfor(i=0;i<N;i++)man[i].get();\n}\nvoid get_tim(){\n\tint i,j;\n\tfor(i=0;i<N;i++){\n\t\trate[i][0]=f_pow(1-man[i].p,M);\n\t\ttim[i][0]=L/man[i].v;\n\t\tfor(j=1;j<=M;j++){\n\t\t\tif(M-j>=j)rate[i][j]=C[M][j]*f_pow(man[i].p*(1-man[i].p),j)*f_pow(1-man[i].p,M-j-j);\n\t\t\telse rate[i][j]=C[M][j]*f_pow(man[i].p*(1-man[i].p),M-j)*f_pow(man[i].p,j+j-M);\n\t\t\ttim[i][j]=tim[i][j-1]+man[i].t;\n\t\t}\n\t\ttsum[i][M]=rate[i][M];\n\t\tfor(j=M-1;j>=0;j--)tsum[i][j]=tsum[i][j+1]+rate[i][j];\n\t}\n}\ndouble bina(int ren,double t){\n\tint h=M,l=0,mid;\n\twhile(h>l){\n\t\tmid=(h+l)>>1;\n\t\tif(tim[ren][mid]<t+eps)l=mid+1;\n\t\telse h=mid;\n\t}\n\treturn tsum[ren][h];\n}\ndouble get_win(int winner,double t){\n\tint i;\n\tdouble res=1;\n\tfor(i=0;i<N;i++){\n\t\tif(i==winner)continue;\n\t\tif(tim[i][M]<t+eps)return 0;\n\t\tres*=bina(i,t);\n\t}\n\treturn res;\n}\nvoid run(){\n\tint i,j;\n\tdouble sum;\n\tfor(i=0;i<N;i++){\n\t\tsum=0;\n\t\tfor(j=0;j<=M;j++){\n\t\t\tsum+=rate[i][j]*get_win(i,tim[i][j]);\n\t\t}\n\t\tprintf(\"%.9lf\\n\",sum);\n\t}\n}\nint main(){\n\tget_C();\n\tget_data();\n\tget_tim();\n\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2303 Marathon Match\n// 2018.4.11 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define EPS 1e-8\nint N, M;\nint p[102], t[102], v[102];\ndouble comb[52][52];\ndouble ps[102][52], ss[102][52], ts[102][52];\n\nint binarySearch(double *a, double x)\n{\n\tint m, l = 0, r = M+1;\n\n    while (l < r) {\n        m = (l+r) >> 1;\n        if (a[m] < x+EPS) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint main()\n{\n\tint i, j, k, f;\n\tdouble L, pp, x, ans;\n\n\tfor (i = 0; i <= 50; i++) comb[i][0] = 1;\n\tfor (i = 1; i <= 50; i++) for (j = 1; j <= i; j++)\n\t\tcomb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n\n\tN = in(), M = in(), L = in();\n\tf = 0; \n\tfor (i = 0; i < N; i++) {\n\t\tp[i] = in(), t[i] = in(), v[i] = in();\n\t\tif (v[i]) f = 1;\n\t}\n\tif (!f) {\n\t\tfor (i = 0; i < N; i++) puts(\"0.00000000\");\n\t\treturn 0;\n\t}\n\n\n\tfor (i = 0; i < N; i++) for (j = 0; j <= M; j++) {\n\t\tps[i][j] = pow(p[i]/100.0, j) * pow((100-p[i])/100.0, M-j) * comb[M][j];\n\t\tif (!j) ss[i][j] = ps[i][j];\n\t\telse    ss[i][j] = ss[i][j-1] + ps[i][j];\n\t\tts[i][j] = L/v[i] + t[i]*j;\n\t}\n\n\tfor (i = 0; i < N; i++) {\n\t\tans = 0;\n\t\tfor (j = 0; j <= M; j++) {\n\t\t\tpp = 1, x = ts[i][j];\n\t\t\tfor (k = 0; k < N; k++) if (k != i) {\n\t\t\t\tif (f = binarySearch(ts[k], x)) pp *= 1 - ss[k][f-1];\n\t\t\t}\n\t\t\tans += ps[i][j] * pp;\n\t\t}\n\t\tprintf(\"%.8f\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,M,L,P[105],T[105],V[105],i,j,k,l,C[105][105];\n\nvoid pasc()\n{\n\tint i,j;\n\tfor(i=0;i<105;i++)\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i==0||j==i)C[i][j]=1;\n\t\t\telse C[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n}\n\ndouble f(int p,int c)//percent of p runnner rest c times\n{\n\tdouble t1=pow((1.0*P[p]/100),c)*C[M][c];\n\tdouble t2=pow(((100.0-P[p])/100),(M-c));\n\treturn t1*t2;\n}\n\nint main()\n{\n\tpasc();\n\tscanf(\"%d%d%d\",&N,&M,&L);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d\",P+i,T+i,V+i);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tdouble t=L/V[i],p,r=0;\n\t\tfor(j=0;j<=M;j++,t+=T[i])\n\t\t{\n\t\t\tp=f(i,j);\n\t\t\tfor(k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tdouble w=1.0*L/V[k],q=0;\n\t\t\t\tif(i==k)continue;\n\t\t\t\tfor(l=0;l<=M;l++,w+=T[k])\n\t\t\t\t{\n\t\t\t\t\tif(t<w)q+=f(k,l);\n\t\t\t\t}\n\t\t\t\tp*=q;\n\t\t\t}\n\t\t\tr+=p;\n\t\t}\n\t\tprintf(\"%.9f\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,M,L,P[105],T[105],V[105],i,j,k,l,C[105][105];\n\nvoid pasc()\n{\n\tint i,j;\n\tfor(i=0;i<105;i++)\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(i==0||j==i)C[i][j]=1;\n\t\t\telse C[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t}\n}\n\ndouble f(int p,int c)//percent of p runnner rest c times\n{\n\tdouble t1=pow((1.0*P[p]/100),c)*C[M][c];\n\tdouble t2=pow(((100.0-P[p])/100),(M-c));\n\treturn t1*t2;\n}\n\nint main()\n{\n\tpasc();\n\tscanf(\"%d%d%d\",&N,&M,&L);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d\",P+i,T+i,V+i);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tdouble t=L/V[i],p,r=0;\n\t\tfor(j=0;j<=M;j++,t+=T[i])\n\t\t{\n\t\t\tp=f(i,j);\n\t\t\tfor(k=0;k<N;k++)\n\t\t\t{\n\t\t\t\tdouble w=1.0*L/V[k],q=0;\n\t\t\t\tif(i==k)continue;\n\t\t\t\tfor(l=0;l<=M;l++,w+=T[k])\n\t\t\t\t{\n\t\t\t\t\tif(t<w)q+=f(k,l);\n\t\t\t\t}\n\t\t\t\tp*=q;\n\t\t\t}\n\t\t\tr+=p;\n\t\t}\n\t\tprintf(\"%lf\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int M = sc.nextInt();\n\t\tfinal int L = sc.nextInt();\n\t\t\n\t\tlong[][] combs = new long[M + 1][M + 1];\n\t\tcombs[0][0] = 1;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tif(combs[i][j] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcombs[i + 1][j    ] += combs[i][j];\n\t\t\t\tcombs[i + 1][j + 1] += combs[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble[][] probs = new double[N][M + 1];\n\t\tdouble[][] probs_sums = new double[N][M + 1];\n\t\tdouble[][] times = new double[N][M + 1];\n\t\t\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfinal double P = sc.nextDouble() / 100;\n\t\t\tfinal int T = sc.nextInt();\n\t\t\tfinal int V = sc.nextInt();\n\t\t\t\n\t\t\t//init_time\n\t\t\tdouble time = (double)(L) / V;\n\t\t\t\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\ttimes[i][j] = time + j * T;\n\t\t\t}\n\t\t\t\n\t\t\t//init_prob\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][j] = combs[M][j];\n\t\t\t}\n\t\t\t\n\t\t\tdouble rest_p = 1.0;\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][j] *= rest_p;\n\t\t\t\trest_p *= P;\n\t\t\t}\n\t\t\t\n\t\t\tdouble unrest_p = 1.0;\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][M - j] *= unrest_p;\n\t\t\t\tunrest_p *= 1 - P;\n\t\t\t}\n\t\t\t\n\t\t\t//sum\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs_sums[i][j] = (j == 0 ? 0 : probs_sums[i][j-1]) + probs[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int fst = 0; fst < N; fst++){\n\t\t\tdouble fst_prob = 0;\n\t\t\t\n\t\t\tfor(int rest = 0; rest <= M; rest++){\n\t\t\t\tfinal double rested_time = times[fst][rest];\n\t\t\t\tdouble to_fst_prob = probs[fst][rest];\n\t\t\t\t\n\t\t\t\tfor(int other = 0; other < N; other++){\n\t\t\t\t\tif(fst == other){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint pos = Arrays.binarySearch(times[other], rested_time);\n\t\t\t\t\tif(pos < 0){\n\t\t\t\t\t\tpos = -(pos + 2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdouble win_prob = 0;\n\t\t\t\t\tif(pos < 0){\n\t\t\t\t\t\twin_prob = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\twin_prob = 1 - probs_sums[other][pos];\n\t\t\t\t\t\twin_prob = Math.max(win_prob, 0);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tto_fst_prob *= win_prob;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfst_prob += to_fst_prob;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.8f\\n\", fst_prob);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint l = sc.nextInt();\n\t\t\tint [][] data = new int[n][3];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble [][][] dp = new double[n][m+1][m+1];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdp[i][0][0] = 1.0;\n\t\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tdp[i][j + 1][k] += dp[i][j][k] * (100 - data[i][0]) / 100;\n\t\t\t\t\t\tdp[i][j + 1][k+1] += dp[i][j][k] * (data[i][0]) / 100;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdouble prob = 0;\n\t\t\t\tfor(int j = 0; j <= m; j++){\n\t\t\t\t\tdouble sec = (double) l / data[i][2] + j * data[i][1];\n\t\t\t\t\tdouble nowsum = dp[i][m][j];\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(i == k) continue;\n\t\t\t\t\t\tdouble sum2 = 0;\n\t\t\t\t\t\tfor(int kk = 0; kk <= m; kk++){\n\t\t\t\t\t\t\tdouble opsec = (double) l / data[k][2] + kk * data[k][1];\n\t\t\t\t\t\t\tif(opsec > sec){\n\t\t\t\t\t\t\t\tsum2 += dp[k][m][kk];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnowsum *= sum2;\n\t\t\t\t\t}\n\t\t\t\t\tprob += nowsum;\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.6f\\n\",prob);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \npublic class Main {\n \n        Scanner sc = new Scanner(System.in);\n \n        void run() {\n                int n = sc.nextInt();\n                int m = sc.nextInt();\n                int l = sc.nextInt();\n                int[] p = new int[n];\n                int[] t = new int[n];\n                int[] v = new int[n];\n \n                for (int i = 0; i < n; i++) {\n                        p[i] = sc.nextInt();\n                        t[i] = sc.nextInt();\n                        v[i] = sc.nextInt();\n                }\n                m++;\n                double win[][] = new double[n][m];\n \n                long time[][] = new long[n][m];\n \n                double rate[][] = new double[n][m];\n \n                double memo[] = new double[m];\n \n                double fact[] = new double[m];\n \n                if (m == 0) {\n                        int z = 0;\n                        boolean ok = true;\n                        for (int i = 0; i < n; i++) {\n                                if (v[i] > v[z]) {\n                                        z = i;\n                                        ok = true;\n                                } else if (v[i] == v[z]) {\n                                        ok = false;\n                                }\n                        }\n \n                        for (int i = 0; i < n; i++) {\n                                if (ok && i == z) {\n                                        System.out.println(1.);\n                                } else {\n                                        System.out.println(0.);\n                                }\n                        }\n \n                }\n                fact[0] = 1;\n                for (int i = 1; i < m; i++) {\n                        fact[i] = fact[i - 1] * i;\n                }\n                double value = 0;\n                memo[0] = 1;\n                value += memo[0];\n                for (int i = 1; i < m; i++) {\n                        memo[i] = fact[m - 1] / fact[m - i - 1] / fact[i];\n                        value += memo[i];\n                }\n \n                for (int i = 0; i < m; i++) {\n//                      memo[i] /= m;\n                }\n//               System.out.println(Arrays.toString(memo));\n                for (int i = 0; i < n; i++) {\n                        double rate1 = 1;\n                        double rate2 = 1;\n                        for (int j = 0; j < m - 1; j++) {\n                                rate2 *= 1 - p[i] / 100.0;\n                        }\n \n                        double rate3 = 0;\n                        for (int j = 0; j < m; j++) {\n//                               System.out.println(rate2+\" \"+rate1);\n                                time[i][j] =  l + v[i] * j * t[i];\n                                if(j==m-1){\n                                        rate2 = 1;\n                                }\n                                rate[i][j] = memo[j] * rate1  * rate2;\n                                rate3 += rate[i][j];\n                                rate1 *= p[i] / 100.0;\n                                if (p[i] != 100) {\n                                        rate2 /= 1 - p[i] / 100.0;\n                                }\n                        }\n//                       System.out.println(i+\" \"+Arrays.toString(time[i]));\n                        \n                        for (int j = 0; j < m; j++) {\n                                rate[i][j] /= rate3;\n                        }\n//                       System.out.println(Arrays.toString([i]));\n                }\n \n                for (int i = 0; i < n; i++) {\n                        double ans = 0;\n                        for (int j = 0; j < m; j++) {\n                                win[i][j] = 1;\n \n                                for (int k = 0; k < n; k++) {\n                                        if (i == k) {\n                                                continue;\n                                        }\n                                        double buffer = 0;\n                                        for (int z = 0; z < m; z++) {\n                        //                      System.out.print(i+\" \"+j + \" \"+ k + \" \"+z);\n                                                if (time[i][j]*v[k] < v[i]*time[k][z]) {\n                                                        buffer += rate[k][z];\n                        //                              System.out.print(\" \"+\"ok\");\n                                                }\n                        //                      System.out.println();\n                                        }\n                                        win[i][j] *= buffer;\n                                }\n                                ans += win[i][j]* rate[i][j];\n                        }\n                        System.out.printf(\"%f\\n\",ans);\n                }\n \n        }\n \n        public static void main(String[] args) {\n                Main m = new Main();\n                m.run();\n        }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble[] P = new double[N];\n\t\tint[] T = new int[N];\n\t\tint[] V = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tP[i] = sc.nextInt() * 0.01;\n\t\t\tT[i] = sc.nextInt();\n\t\t\tV[i] = sc.nextInt();\n\t\t}\n\t\tdouble[][] comb = new double[M + 1][M + 1];\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tcomb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tdouble[][] time = new double[N][M + 1];\n\t\tdouble[][] prob = new double[N][M + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\t\ttime[i][j] = 1. * L / V[i] + j * T[i];\n\t\t\t\tprob[i][j] = comb[M][j] * Math.pow(P[i], j) * Math.pow(1 - P[i], M - j);\n\t\t\t}\n\t\t}\n\t\tdouble EPS = 1e-9;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\t\tdouble t = time[i][j];\n\t\t\t\tdouble p = prob[i][j];\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i) continue;\n\t\t\t\t\tdouble win = 1;\n\t\t\t\t\tfor (int l = 0; l <= M; ++l) {\n\t\t\t\t\t\tif (time[k][l] - EPS > t) break;\n\t\t\t\t\t\twin -= prob[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tp *= win;\n\t\t\t\t}\n\t\t\t\tsum += p;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.8f\\n\", sum);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Marathon Match\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tlong[][] comb = new long[51][51];\n\t\tcomb[0][0] = comb[1][0] = comb[1][1] = 1;\n\t\tfor(int i=2;i<=50;i++){\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t\tfor(int j=1;j<i;j++)comb[i][j] = comb[i-1][j-1]+comb[i-1][j];\n\t\t}\n\t\tdouble[] p = new double[n];\n\t\tint[] t = new int[n];\n\t\tdouble[] v = new double[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tp[i] = sc.nextDouble()/100.0;\n\t\t\tt[i] = sc.nextInt();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tdouble[][] time = new double[n][m+1];\n\t\tdouble[][] pp = new double[n][m+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble r = L/v[i];\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\ttime[i][j] = j*t[i] + r;\n\t\t\t\tpp[i][j] = comb[m][j]*Math.pow(p[i], j)*Math.pow(1-p[i], m-j);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble exp = 0;\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tdouble e = pp[i][j];\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(i==k)continue;\n\t\t\t\t\tdouble ee = 0;\n\t\t\t\t\tfor(int l=0;l<=m;l++){\n\t\t\t\t\t\tif(time[i][j]+1e-8<time[k][l])ee += pp[k][l];\n\t\t\t\t\t}\n\t\t\t\t\te *= ee;\n\t\t\t\t}\n\t\t\t\texp += e;\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.6f\\n\", exp);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int M = sc.nextInt();\n\t\tfinal int L = sc.nextInt();\n\t\t\n\t\tint[][] combs = new int[M + 1][M + 1];\n\t\tcombs[0][0] = 1;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tif(combs[i][j] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcombs[i + 1][j    ] += combs[i][j];\n\t\t\t\tcombs[i + 1][j + 1] += combs[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble[][] probs = new double[N][M + 1];\n\t\tdouble[][] probs_sums = new double[N][M + 1];\n\t\tdouble[][] times = new double[N][M + 1];\n\t\t\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfinal double P = sc.nextDouble() / 100;\n\t\t\tfinal int T = sc.nextInt();\n\t\t\tfinal int V = sc.nextInt();\n\t\t\t\n\t\t\t//init_time\n\t\t\tdouble time = (double)(L) / V;\n\t\t\t\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\ttimes[i][j] = time + j * T;\n\t\t\t}\n\t\t\t\n\t\t\t//init_prob\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][j] = combs[M][j];\n\t\t\t}\n\t\t\t\n\t\t\tdouble rest_p = 1.0;\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][j] *= rest_p;\n\t\t\t\trest_p *= P;\n\t\t\t}\n\t\t\t\n\t\t\tdouble unrest_p = 1.0;\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs[i][M - j] *= unrest_p;\n\t\t\t\tunrest_p *= 1 - P;\n\t\t\t}\n\t\t\t\n\t\t\t//sum\n\t\t\tfor(int j = 0; j <= M; j++){\n\t\t\t\tprobs_sums[i][j] = (j == 0 ? 0 : probs_sums[i][j-1]) + probs[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int fst = 0; fst < N; fst++){\n\t\t\tdouble fst_prob = 0;\n\t\t\t\n\t\t\tfor(int rest = 0; rest <= M; rest++){\n\t\t\t\tfinal double rested_time = times[fst][rest];\n\t\t\t\tdouble to_fst_prob = probs[fst][rest];\n\t\t\t\t\n\t\t\t\tfor(int other = 0; other < N; other++){\n\t\t\t\t\tif(fst == other){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint pos = Arrays.binarySearch(times[other], rested_time);\n\t\t\t\t\tif(pos < 0){\n\t\t\t\t\t\tpos = -(pos + 2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdouble win_prob = 0;\n\t\t\t\t\tif(pos < 0){\n\t\t\t\t\t\twin_prob = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\twin_prob = 1 - probs_sums[other][pos];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tto_fst_prob *= win_prob;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfst_prob += to_fst_prob;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.printf(\"%.8f\\n\", fst_prob);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m, d;\n\tdouble[] ps, rests, ts;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\td=sc.nextInt();\n\t\tps=new double[n];\n\t\trests=new double[n];\n\t\tts=new double[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tps[i]=sc.nextDouble()/100.0;\n\t\t\trests[i]=sc.nextDouble();\n\t\t\tdouble v=sc.nextDouble();\n\t\t\tts[i]=d/v;\n\t\t}\n\t\tlong[][] C=new long[m+1][m+1];\n\t\tC[0][0]=1;\n\t\tfor(int j=1; j<=m; j++){\n\t\t\tC[j][0]=1;\n\t\t\tfor(int i=1; i<=m; i++){\n\t\t\t\tC[j][i]=C[j-1][i-1]+C[j-1][i];\n\t\t\t}\n\t\t\t// debug(C[j]);\n\t\t}\n\n\t\tfor(int a=0; a<n; a++){\n\t\t\tdouble totP=0;\n\t\t\tfor(int i=0; i<=m; i++){\n\t\t\t\tdouble ta=ts[a]+i*rests[a];\n\t\t\t\tdouble pp=C[m][i]*pow(ps[a], i)*pow(1-ps[a], m-i);\n\t\t\t\tfor(int b=0; b<n; b++){\n\t\t\t\t\tif(b==a){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble p=0;\n\t\t\t\t\tint j;\n\t\t\t\t\tfor(j=0; j<=m; j++){\n\t\t\t\t\t\tdouble tb=ts[b]+j*rests[b];\n\t\t\t\t\t\tif(ta+EPS<tb){\n\t\t\t\t\t\t\tp+=C[m][j]*pow(ps[b], j)*pow(1-ps[b], m-j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpp*=p;\n\t\t\t\t}\n\t\t\t\ttotP+=pp;\n\t\t\t}\n\t\t\t// debug(totP);\n\t\t\tprintln(String.format(\"%.7f\", totP));\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\t/* combination */\n\tdouble[][] pascalTriangle(int n) {\n\t\tdouble[][] res = new double[n+1][n+1];\n\t\t\n\t\tres[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\tif (j < i) res[i][j] = (res[i][j] + res[i-1][j]);\n\t\t\t\tif (j > 0) res[i][j] = (res[i][j] + res[i-1][j-1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic void solve() {\t\n\t\tdouble[][] comb = pascalTriangle(100);\n\t\t\n\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\tdouble[] P = new double[n];\n\t\tint[] T = new int[n];\n\t\tint[] V = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tP[i] = in.nextInt() / 100.0;\n\t\t\tT[i] = in.nextInt();\n\t\t\tV[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] restProb = new double[n][m+1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\trestProb[i][j] = Math.pow(P[i], j) * Math.pow(1.0 - P[i], m - j) * comb[m][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int next = 0; next < n; next++) {\n\t\t\tdouble res = 0.0;\n\t\t\t\n\t\t\tfor (int i = m; i >= 0; i--) {\n\t\t\t\tdouble prob = 1.0;\n\t\t\t\tfor (int other = 0; other < n; other++) {\n\t\t\t\t\tif (next == other) continue;\n\t\t\t\t\tdouble sum = 1.0;\n\t\t\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\t\t\tif ((double)l / V[next] + T[next] * i < (double)l / V[other] + T[other] * j) break;\n\t\t\t\t\t\tsum -= restProb[other][j];\n\t\t\t\t\t}\n\t\t\t\t\tprob *= sum;\n\t\t\t\t}\n\t\t\t\tres += prob * restProb[next][i];\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (int other = 0; other < n; other++) {\n\t\t\t\tif (next == other) continue;\n\t\t\t\t\n\t\t\t\tint cur = m;\n\t\t\t\tdouble sum = 1.0;\n\t\t\t\tdouble prob = 0;\n\t\t\t\tfor (int i = m; i >= 0; i--) {\n\t\t\t\t\twhile (cur >= 0 && \n\t\t\t\t\t\t\t(double)l / V[next] + T[next] * cur >= (double)l / V[other] + T[other] * i) {\n\t\t\t\t\t\tsum -= restProb[next][cur--];\n\t\t\t\t\t}\n\t\t\t\t\tprob += sum * restProb[other][i];\n\t\t\t\t}\n\t\t\t\tSystem.out.println(prob);\n\t\t\t\tres *= prob;\n\t\t\t}\n\t\t\t*/\n\t\t\tSystem.out.printf(\"%.8f\\n\", res);\n\t\t}\n\t\t\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Map.Entry;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\t/* combination */\n\tdouble[][] pascalTriangle(int n) {\n\t\tdouble[][] res = new double[n+1][n+1];\n\t\t\n\t\tres[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\tif (j < i) res[i][j] = (res[i][j] + res[i-1][j]);\n\t\t\t\tif (j > 0) res[i][j] = (res[i][j] + res[i-1][j-1]);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n\tpublic void solve() {\t\n\t\tdouble[][] comb = pascalTriangle(100);\n\t\t\n\t\tint n = in.nextInt(), m = in.nextInt(), l = in.nextInt();\n\t\tdouble[] P = new double[n];\n\t\tint[] T = new int[n];\n\t\tint[] V = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tP[i] = in.nextInt() / 100.0;\n\t\t\tT[i] = in.nextInt();\n\t\t\tV[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] restProb = new double[n][m+1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\trestProb[i][j] = Math.pow(P[i], j) * Math.pow(1.0 - P[i], m - j) * comb[m][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int next = 0; next < n; next++) {\n\t\t\tdouble res = 0.0;\n\t\t\t\n\t\t\tfor (int i = m; i >= 0; i--) {\n\t\t\t\tdouble prob = 1.0;\n\t\t\t\tfor (int other = 0; other < n; other++) {\n\t\t\t\t\tif (next == other) continue;\n\t\t\t\t\tdouble sum = 1.0;\n\t\t\t\t\tfor (int j = 0; j <= m; j++) {\n\t\t\t\t\t\tif ((double)l / V[next] + T[next] * i < (double)l / V[other] + T[other] * j) break;\n\t\t\t\t\t\tsum -= restProb[other][j];\n\t\t\t\t\t}\n\t\t\t\t\tprob *= sum;\n\t\t\t\t}\n\t\t\t\tres += prob * restProb[next][i];\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (int other = 0; other < n; other++) {\n\t\t\t\tif (next == other) continue;\n\t\t\t\t\n\t\t\t\tint cur = m;\n\t\t\t\tdouble sum = 1.0;\n\t\t\t\tdouble prob = 0;\n\t\t\t\tfor (int i = m; i >= 0; i--) {\n\t\t\t\t\twhile (cur >= 0 && \n\t\t\t\t\t\t\t(double)l / V[next] + T[next] * cur >= (double)l / V[other] + T[other] * i) {\n\t\t\t\t\t\tsum -= restProb[next][cur--];\n\t\t\t\t\t}\n\t\t\t\t\tprob += sum * restProb[other][i];\n\t\t\t\t}\n\t\t\t\tSystem.out.println(prob);\n\t\t\t\tres *= prob;\n\t\t\t}\n\t\t\t*/\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\t\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\nimport java.util.function.IntPredicate;\n\npublic class Main {\n\n    static int N, M, L;\n    static int[] P, T, V;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        L = sc.nextInt();\n\n        P = new int[N];\n        T = new int[N];\n        V = new int[N];\n        for (int i = 0; i < N; i++) {\n            P[i] = sc.nextInt();\n            T[i] = sc.nextInt();\n            V[i] = sc.nextInt();\n        }\n\n\n        double[] ans = solve();\n        for (double d : ans) {\n            pw.println(BigDecimal.valueOf(d).toPlainString());\n        }\n        pw.flush();\n    }\n\n    static double[] solve() {\n        long[] B = calcBinominal(M);\n\n        double[][] prob = new double[N][M+1];\n        double[][] probCum = new double[N][M+1];\n        for (int i = 0; i < N; i++) {\n            double[] use = calcProbs((double)P[i]/100);\n            double[] notUse = calcProbs((double)(100-P[i])/100);\n            for (int m = M; m >= 0; m--) {\n                // Mの休憩所のうちm回休む確率\n                double p = use[m] * notUse[M-m] * B[m];\n                prob[i][m] = p;\n                probCum[i][m] = p;\n                if( m != M ) {\n                    probCum[i][m] += probCum[i][m+1];\n                }\n            }\n        }\n\n        double[] ans = new double[N];\n\n        for (int i = 0; i < N; i++) {\n            for (int m = 0; m <= M; m++) {\n                double time = (double)L/V[i] + m * T[i];\n\n                double p = prob[i][m];\n\n                for (int j = 0; j < N; j++) {\n                    if( i == j ) continue;\n                    int fj = j;\n                    int a = minimize(0, M+1, x -> {\n                        double s = (double)L/V[fj] + x * T[fj];\n                        return s > time;\n                    });\n\n                    if( a == M+1 ) {\n                        p = 0.0;\n                    } else {\n                        p *= probCum[j][a];\n                    }\n                }\n                ans[i] += p;\n            }\n        }\n\n        return ans;\n    }\n\n    static int minimize(int lo, int hi, IntPredicate p) {\n        while(lo < hi) {\n            int x = ((hi - lo) >>> 1) + lo;\n            if( p.test(x) ) {\n                hi = x;\n            } else {\n                lo = x + 1;\n            }\n        }\n        return lo;\n    }\n\n    static double EPS = 1e-11;\n\n    static double[] calcProbs(double p) {\n        double[] probs = new double[M+1];\n        probs[0] = 1.0;\n        for (int i = 0; i < M; i++) {\n            probs[i+1] = probs[i] * p;\n        }\n        return probs;\n    }\n\n    static long[] calcBinominal(int n) {\n        long[] b = new long[n+1];\n        b[0] = 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j > 0; j--) {\n                b[j] += b[j-1];\n            }\n        }\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner scanner = new Scanner(System.in);\n\tstatic long[][] com = new long[51][51];\n\n\tstatic class Person {\n\t\tpublic Person(double p, double t, double v) {\n\t\t\tP = p;\n\t\t\tT = t;\n\t\t\tV = v;\n\t\t}\n\n\t\tdouble P;\n\t\tdouble T;\n\t\tdouble V;\n\n\t}\n\n\tstatic class Match {\n\t\tint N;\n\t\tint M;\n\t\tint L;\n\t\tPerson[] persons;\n\t\tdouble[] time;\n\t\tdouble[] pro;\n\n\t\tpublic Match() {\n\t\t\tN = scanner.nextInt();\n\t\t\tM = scanner.nextInt();\n\t\t\tL = scanner.nextInt();\n\t\t\tpersons = new Person[N];\n\t\t\ttime = new double[N];\n\t\t\tpro = new double[N];\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tpersons[i] = new Person(scanner.nextDouble() / 100,\n\t\t\t\t\t\tscanner.nextDouble(), scanner.nextDouble());\n\t\t\t\tif(persons[i].V == 0)\n\t\t\t\t\ttime[i] = Integer.MAX_VALUE;\n\t\t\t\telse \n\t\t\t\t\ttime[i] = L / persons[i].V;\n\t\t\t\tpro[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic void personWin(int n) {\n\n\t\t\tfor (int i = 0; i <= M; i++) {\n\t\t\t\tdouble aPro = 1;\n\t\t\t\tdouble pn = 1;\n\t\t\t\tdouble nowtime = time[n] + i * persons[n].T;\n\t\t\t\taPro *= com[M][i] * Math.pow(persons[n].P, i)\n\t\t\t\t\t\t* Math.pow(1 - persons[n].P, M - i);\n\t\t\t\tfor (int j = 0; j < N; j++) {\t\n\t\t\t\t\tdouble p = 0;\n\t\t\t\t\tif (j != n) {\n\t\t\t\t\t\tif (nowtime >= time[j]) {\n\t\t\t\t\t\t\tif (persons[j].T != 0) {\n\t\t\t\t\t\t\t\tdouble tmp = (nowtime - time[j]) / persons[j].T;\n\t\t\t\t\t\t\t\tint test = (int) (tmp) + 1;\n\t\t\t\t\t\t\t\tif (test > M)\n\t\t\t\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (int k = test; k <= M; k++) {\n\t\t\t\t\t\t\t\t\t\tp += com[M][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* Math.pow(persons[j].P, k)\n\t\t\t\t\t\t\t\t\t\t\t\t* Math.pow(1 - persons[j].P, M\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t- k);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpn *= p;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tpro[n] += pn * aPro;\n\t\t\t}\n\t\t}\n\n\t\tpublic void personWin() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tpersonWin(i);\n\t\t\t\tSystem.out.format(\"%.8f\", pro[i]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tcom[0][0] = 1;\n\t\tfor (int i = 1; i < 51; i++)\n\t\t\tcom[i][0] = 1;\n\t\tfor (int i = 1; i < 51; i++)\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tcom[i][j] = com[i - 1][j - 1] + com[i - 1][j];\n\n\t\t// for(int i=0;i<51;i++)\n\t\t// for(int j=0;j<=i;j++){\n\t\t// System.out.println(i+\" \"+j+\" \"+com[i][j]);\n\t\t// }\n\t\tMatch match = new Match();\n\t\tmatch.personWin();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble[] P = new double[N];\n\t\tint[] T = new int[N];\n\t\tint[] V = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tP[i] = sc.nextInt() * 0.01;\n\t\t\tT[i] = sc.nextInt();\n\t\t\tV[i] = sc.nextInt();\n\t\t}\n\t\tdouble[][] comb = new double[M + 1][M + 1];\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tcomb[i][0] = comb[i][i] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= M; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tcomb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tdouble[][] time = new double[N][M + 1];\n\t\tdouble[][] prob = new double[N][M + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\t\ttime[i][j] = 1. * L / V[i] + j * T[i];\n\t\t\t\tprob[i][j] = comb[M][j] * Math.pow(P[i], j) * Math.pow(1 - P[i], M - j);\n\t\t\t}\n\t\t}\n\t\tdouble EPS = 1e-9;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble sum = 0;\n\t\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\t\tdouble t = time[i][j];\n\t\t\t\tdouble p = prob[i][j];\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k == i) continue;\n\t\t\t\t\tdouble win = 1;\n\t\t\t\t\tfor (int l = 0; l <= M; ++l) {\n\t\t\t\t\t\tif (time[k][l] - EPS > t) break;\n\t\t\t\t\t\twin -= prob[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tp *= win;\n\t\t\t\t}\n\t\t\t\tsum += p;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic Scanner scanner = new Scanner(System.in);\n\tstatic long[][] com = new long[51][51];\n\n\tstatic class Person {\n\t\tpublic Person(double p, double t, double v) {\n\t\t\tP = p;\n\t\t\tT = t;\n\t\t\tV = v;\n\t\t}\n\n\t\tdouble P;\n\t\tdouble T;\n\t\tdouble V;\n\n\t}\n\n\tstatic class Match {\n\t\tint N;\n\t\tint M;\n\t\tint L;\n\t\tPerson[] persons;\n\t\tdouble[] time;\n\t\tdouble[] pro;\n\n\t\tpublic Match() {\n\t\t\tN = scanner.nextInt();\n\t\t\tM = scanner.nextInt();\n\t\t\tL = scanner.nextInt();\n\t\t\tpersons = new Person[N];\n\t\t\ttime = new double[N];\n\t\t\tpro = new double[N];\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tpersons[i] = new Person(scanner.nextDouble() / 100,\n\t\t\t\t\t\tscanner.nextDouble(), scanner.nextDouble());\n\t\t\t\tif(persons[i].V == 0)\n\t\t\t\t\ttime[i] = Integer.MAX_VALUE;\n\t\t\t\telse \n\t\t\t\t\ttime[i] = L / persons[i].V;\n\t\t\t\tpro[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic void personWin(int n) {\n\n\t\t\tfor (int i = 0; i <= M; i++) {\n\t\t\t\tdouble aPro = 1;\n\t\t\t\tdouble pn = 1;\n\t\t\t\tdouble nowtime = time[n] + i * persons[n].T;\n\t\t\t\taPro *= com[M][i] * Math.pow(persons[n].P, i)\n\t\t\t\t\t\t* Math.pow(1 - persons[n].P, M - i);\n\t\t\t\tfor (int j = 0; j < N; j++) {\t\n\t\t\t\t\tdouble p = 0;\n\t\t\t\t\tif (j != n) {\n\t\t\t\t\t\tif (nowtime >= time[j]) {\n\t\t\t\t\t\t\tif (persons[j].T != 0) {\n\t\t\t\t\t\t\t\tdouble tmp = (nowtime - time[j]) / persons[j].T;\n\t\t\t\t\t\t\t\tint test = (int) (tmp) + 1;\n\t\t\t\t\t\t\t\tif (test > M)\n\t\t\t\t\t\t\t\t\tp = 0;\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tfor (int k = test; k <= M; k++) {\n\t\t\t\t\t\t\t\t\t\tp += com[M][k]\n\t\t\t\t\t\t\t\t\t\t\t\t* Math.pow(persons[j].P, k)\n\t\t\t\t\t\t\t\t\t\t\t\t* Math.pow(1 - persons[j].P, M\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t- k);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpn *= p;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tpro[n] += pn * aPro;\n\t\t\t}\n\t\t}\n\n\t\tpublic void personWin() {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tpersonWin(i);\n\t\t\t\tSystem.out.format(\"%.8f\", pro[i]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tcom[0][0] = 1;\n\t\tfor (int i = 1; i < 51; i++)\n\t\t\tcom[i][0] = 1;\n\t\tfor (int i = 1; i < 51; i++)\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tcom[i][j] = com[i - 1][j - 1] + com[i - 1][j];\n\n\t\t// for(int i=0;i<51;i++)\n\t\t// for(int j=0;j<=i;j++){\n\t\t// System.out.println(i+\" \"+j+\" \"+com[i][j]);\n\t\t// }\n\t\tMatch match = new Match();\n\t\tmatch.personWin();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.HCPC2019_29\n{\n    class D\n    {\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            int[] nml = ReadInts();\n            int n = nml[0];\n            int m = nml[1];\n            int l = nml[2];\n            int[][] ptvs = new int[n][];\n            double[] bases = new double[n];\n            for (int i = 0; i < n; i++) {\n                ptvs[i] = ReadInts();\n                bases[i] = 1.0 * l / ptvs[i][2];\n            }\n            double[,] probs = new double[n, m + 1];\n            for(int i = 0; i < n; i++)\n            {\n                for(int j = 0; j <= m; j++)\n                {\n                    double val = 1;\n                    for(int k = 0; k < m; k++)\n                    {\n                        if (k < j)\n                        {\n                            val *= ptvs[i][0] * 0.01;\n                            val *= 1.0 * (m - k) / (j - k);\n                        }\n                        else\n                        {\n                            val *= 1 - (ptvs[i][0] * 0.01);\n                        }\n                    }\n                    probs[i, j] = val;\n                }\n            }\n            for(int h = 0; h < n; h++)\n            {\n                double res = 0;\n                for(int i = 0; i <= m; i++)\n                {\n                    double tmp = 1;\n                    double time = bases[h] + ptvs[h][1] * i;\n                    for (int j = 0; j < n; j++)\n                    {\n                        if (h == j) continue;\n                        double tmp2 = 0;\n                        for(int k = 0; k <= m; k++)\n                        {\n                            if (bases[j] + ptvs[j][1] * k > time) break;\n                            tmp2 += probs[j,k];\n                        }\n                        tmp2 = 1 - tmp2;\n                        tmp *= tmp2;\n                    }\n                    tmp *= probs[h, i];\n                    res += tmp;\n                }\n                WriteLine(res.ToString(\"F8\"));\n            }\n        }\n\n        class CaseCalculator\n        {\n            long mask;\n            long[] allPermutations;\n\n            public CaseCalculator(long mask, long permutationCnt)\n            {\n                this.mask = mask;\n                allPermutations = AllPermutations(permutationCnt);\n            }\n\n            public long Combination(long n, long m)\n            {\n                if (n < m) return 0;\n\n                if (n - m < m) m = n - m;\n\n                return Multi(allPermutations[n],\n                    Reverse(\n                        Multi(allPermutations[n - m], allPermutations[m]),\n                        mask - 2));\n            }\n\n            public long Permutation(long n, long m)\n            {\n                if (n < m) return 0;\n\n                return Multi(allPermutations[n],\n                    Reverse(allPermutations[n - m], mask - 2));\n            }\n\n            long[] AllPermutations(long n)\n            {\n                var perms = new long[n + 1];\n                perms[0] = 1;\n                for (int i = 1; i <= n; i++)\n                {\n                    perms[i] = Multi(perms[i - 1], i);\n                }\n                return perms;\n            }\n\n            public long Multi(long a, long b)\n            {\n                return ((a % mask) * (b % mask)) % mask;\n            }\n\n            long Reverse(long a, long pow)\n            {\n                if (pow == 0) return 1;\n                else if (pow == 1) return a % mask;\n                else\n                {\n                    long halfMod = Reverse(a, pow / 2);\n                    long nextMod = Multi(halfMod, halfMod);\n                    if (pow % 2 == 0)\n                    {\n                        return nextMod;\n                    }\n                    else\n                    {\n                        return Multi(nextMod, a);\n                    }\n                }\n            }\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n \nEPS = 1e-9\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  s = l / v[i]\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\n\nprob_set = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  (m + 1).times do |j|\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    time = l / v[i] + t[i] * j\n    n.times do |k|\n      next if i == k\n      base = l / v[k]\n      upper = (time - base) / t[k] + EPS\n      if upper >= m\n        prob = 0\n        break\n      end\n      upper = upper < 0 ? 0 : upper.ceil\n      prob *= prob_sum[k][upper]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nn, m, l = gets.split.map &:to_i\n\ndef comb(n, k)\n\tc = 1\t\n\t(1..k).each do |i|\n\t\tc = c * (n - i + 1) / i\n\tend\n\tc\nend\n\na = []\n(0..n-1).each do |i|\n\ta[i] = []\n\tp, r, v = gets.split.map &:to_i\t\t\n\tp /= 100.0\n\ta[i] = (0..m).map do |k|\n\t\tprob = p ** k * (1 - p) ** (m - k) * comb(m, k)\n\t\t[(v == 0 ? Float::INFINITY : l.to_f / v + r * k), prob]\n\tend\n\t\n\ttmp = a[i].map(&:last).reverse.accum[1..-1].reverse\n\t(0..m).each {|k| a[i][k] << tmp[k] }\nend\n\n(0..n-1).each do |i|\n\ttotal_prob = 0\n\t(0..m).map do |k|\n\t\ttime, prob = a[i][k]\n\t\t(0..n-1).each do |j|\n\t\t\tnext if j == i\n\t\t\tdist = a[j]\n\t\t\titem = dist.bsearch_first_item {|t, _, _| t > time}\t\n\t\t\tprob *= (item ? item[-1] : 0)\n\t\tend\n\t\ttotal_prob += prob\n\tend\n\tp total_prob\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n \nEPS = 1e-9\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\ntime_set = n.times.map{ [] }\nprob_set = n.times.map{ [] }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  s = l / v[i]\n  (m + 1).times do |j|\n    time_set[i] << s + t[i] * j\n    prob_set[i] << (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nn, m, l = gets.split.map &:to_i\n\ndef comb(n, k)\n\tc = 1\t\n\t(1..k).each do |i|\n\t\tc = c * (n - i + 1) / i\n\tend\n\tc\nend\n\na = []\n(0..n-1).each do |i|\n\ta[i] = []\n\tp, r, v = gets.split.map &:to_i\t\t\n\tp /= 100.0\n\ta[i] = (0..m).map do |k|\n\t\tprob = p ** k * (1 - p) ** (m - k) * comb(m, k)\n\t\t[(v == 0 ? Float::INFINITY : l.to_f / v + r * k), prob]\n\tend\n\t\n\ttmp = a[i].map(&:last).reverse.accum[1..-1].reverse\n\t(0..m).each {|k| a[i][k] << tmp[k] }\nend\n\n(0..n-1).each do |i|\n\ttotal_prob = 0\n\t(0..m).map do |k|\n\t\ttime, prob = a[i][k]\n\t\t(0..n-1).each do |j|\n\t\t\tnext if j == i\n\t\t\tdist = a[j]\n\t\t\titem = dist.bsearch_first_item {|t, _, _| t > time}\t\n\t\t\tprob *= (item ? item[-1] : 0)\n\t\tend\n\t\ttotal_prob += prob\n\tend\n    puts \"%.08f\" % total_prob\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n \nEPS = 1e-9\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nprob_sum = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  s = l / v[i]\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n    prob_sum[i][j+1] = prob_sum[i][j] + prob_set[i][j]\n  end\nend\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= 1 - prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nFactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = l / v[i]\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * Factorial[m] / Factorial[m - j] / Factorial[j]\n  end\nend\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_set[k][idx..-1].reduce(:+)\n    end\n    ret += prob\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nFactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i].to_f\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * Factorial[m] / Factorial[m - j] / Factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| ps.reverse.each_with_object([0]){ |p, arr| arr << arr[-1] + p }[1..-1].reverse }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nFactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i]\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = ((p[i] / 100.0) ** j) * ((1 - p[i] / 100.0) ** (m - j)) * Factorial[m] / Factorial[m - j] / Factorial[j]\n  end\nend\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_set[k][idx..-1].reduce(:+)\n    end\n    ret += prob\n  end\n  p ret\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\n\nprob_set = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  (m + 1).times do |j|\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    time = l / v[i] + t[i] * j\n    n.times do |k|\n      next if i == k\n      base = l / v[k]\n      upper = (time - base) / t[k] + EPS\n      if upper >= m || time - base == 0 && t[k] == 0\n        prob = 0\n        break\n      end\n      upper = upper < 0 ? 0 : upper.ceil\n      prob *= prob_sum[k][upper]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "class Integer\n  def combination(k)\n    self.factorial/(k.factorial*(self-k).factorial)\n  end\n\n  def factorial\n    return 1 if self == 0\n    (1..self).inject(:*)\n  end\nend\n\ndef upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\n\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i].to_f\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = ((p[i] / 100.0) ** j) * ((1 - p[i] / 100.0) ** (m - j)) * m.combination(j)\n  end\nend\n\nprob_sum = prob_set.map{ |ps| ps.reverse.each_with_object([0]){ |p, arr| arr << arr[-1] + p }[1..-1].reverse }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\n@combination = (0..m).map{ [0] * (m + 1) }\n(0..m).each{ |i| @combination[i][0] = @combination[i][i] = 1 }\n(2..m).each do |i|\n  (1..m).each do |j|\n    @combination[i][j] = @combination[i-1][j] + @combination[i-1][j-1]\n  end\nend\n\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i].to_f\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * @combination[m][j]\n  end\nend\n\nprob_sum = prob_set.map{ |ps| ps.reverse.each_with_object([0]){ |p, arr| arr << arr[-1] + p }[1..-1].reverse }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\n\nprob_set = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  (m + 1).times do |j|\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    time = l / v[i] + t[i] * j\n    n.times do |k|\n      next if i == k\n      base = l / v[k]\n      upper = (time - base) / t[k] + EPS\n      if upper >= m || time - base == 0 && t[k] == 0 || v[i] == 0 && v[k] == 0\n        prob = 0\n        break\n      end\n      upper = upper < 0 ? 0 : upper.ceil\n      prob *= prob_sum[k][upper]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n \nEPS = 1e-9\nfactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n \nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = l / v[i]\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n \nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_sum[k][idx]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\nINF = Float::INFINITY\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_f) }.transpose\nv.map!{ |e| l / e }\nprob_set = n.times.map{ [0] * (m + 1) }\n\nfactorial = (1..m).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\nn.times do |i|\n  (m + 1).times do |j|\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * factorial[m] / factorial[m - j] / factorial[j]\n  end\nend\nprob_sum = prob_set.map{ |ps| (0..m).map{ |i| ps[i..-1].reduce(:+) } }\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    time = v[i] + t[i] * j\n    n.times do |k|\n      next if i == k\n      upper = (time - v[k]) / t[k] + EPS\n      if upper >= m || time - v[k] == 0 && t[k] == 0 || v[i] == INF && v[k] == INF\n        prob = 0\n        break\n      end\n      upper = upper < 0 ? 0 : upper.ceil\n      prob *= prob_sum[k][upper]\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Ruby",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nFactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i].to_f\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * Factorial[m] / Factorial[m - j] / Factorial[j]\n  end\nend\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_set[k][idx..-1].reduce(:+)\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nnm = {}\ndef nCr(n, b):\n    if b > n - b:\n        b = n - b\n    key = (n,b)\n    if key in nm:\n        return nm[key]\n    r = 1\n    for k in range(n, n-b, -1):\n        r = r * k\n    d = 1\n    for k in range(1, b+1):\n        d = d * k\n    nm[key] = r / d\n    return nm[key]\n\n\ndef main():\n    rr = []\n\n    n,m,l = LI()\n    ps = [LI() for _ in range(n)]\n    ts = []\n    rs = []\n    us = []\n\n    for p,t,v in ps:\n        p /= 100\n        u = l / v\n        ti = []\n        ri = []\n        for i in range(m+1):\n            ti.append(u+t*i)\n            k = pow(1-p, m-i) * pow(p, i) * nCr(m, i)\n            ri.append(k)\n        ts.append(ti)\n        rs.append(ri)\n        ui = ri[:]\n        for i in range(1,m+1):\n            ui[i] += ui[i-1]\n        us.append(ui)\n\n    for i in range(n):\n        r = 0\n        for j in range(m+1):\n            tr = rs[i][j]\n            tt = ts[i][j] + 1.0 / 10**10\n            for k in range(n):\n                if i == k:\n                    continue\n                bi = bisect.bisect_left(ts[k], tt)\n                if bi > 0:\n                    tr *= 1 - us[k][bi-1]\n            r += tr\n        rr.append('{:.9f}'.format(r))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN, M, L = map(int, raw_input().split())\n\ndef fact(n):\n    if n <= 1:\n        return 1\n    return fact(n - 1) * n\nMC = []\nfor i in range(M + 1):\n    MC.append(fact(M) / fact(i) / fact(M - i))\n\np_lst = []\nP_val = []\nP_sum = []\n\nfor i in range(N):\n    P, T, V = map(int, raw_input().split())\n    p_lst.append((T, V))\n    PP = []\n    for k in range(M + 1):\n        PP.append(MC[k] * (P ** k) * ((100 - P) ** (M - k)))\n    P_val.append(list(PP))\n    for k in range(M, 0, -1):\n        PP[k - 1] += PP[k]\n    P_sum.append(PP)\n\ndef comp(p1, p2, k1, k2):\n    T1, V1 = p1\n    T2, V2 = p2\n    return L * (V2 - V1) < V1 * V2 * (k2 * T2 - k1 * T1)\n\nfor i in range(N):\n    ans = 0\n    index_lst = [0 for j in range(N)]\n    for k1 in range(M + 1):\n        ret = P_val[i][k1]\n        for j in range(N):\n            if i == j:\n                continue\n            flag = True\n            while True:\n                k2 = index_lst[j]\n                if k2 > M:\n                    ret *= 0\n                    break\n                if comp(p_lst[i], p_lst[j], k1, k2):\n                    ret *= P_sum[j][k2]\n                    break\n                index_lst[j] += 1\n        ans += ret\n    ans = float(ans) / 100 ** (N * M)\n    print ans\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN, M, L = map(int, raw_input().split())\n\ndef fact(n):\n    if n <= 1:\n        return 1\n    return fact(n - 1) * n\nMC = []\nfor i in range(M + 1):\n    MC.append(fact(M) / fact(i) / fact(M - i))\n\np_lst = []\nP_val = []\nP_sum = []\n\nfor i in range(N):\n    P, T, V = map(int, raw_input().split())\n    p_lst.append((T, V))\n    PP = []\n    for k in range(M + 1):\n        PP.append(float(MC[k] * (P ** k) * ((100 - P) ** (M - k))) / 100 ** M)\n    P_val.append(list(PP))\n    for k in range(M, 0, -1):\n        PP[k - 1] += PP[k]\n    P_sum.append(PP)\n\ndef comp(p1, p2, k1, k2):\n    T1, V1 = p1\n    T2, V2 = p2\n    return L * (V2 - V1) < V1 * V2 * (k2 * T2 - k1 * T1)\n\nfor i in range(N):\n    ans = 0\n    index_lst = [0 for j in range(N)]\n    for k1 in range(M + 1):\n        ret = P_val[i][k1]\n        for j in range(N):\n            if i == j:\n                continue\n            while True:\n                k2 = index_lst[j]\n                if k2 > M:\n                    ret *= 0\n                    break\n                if comp(p_lst[i], p_lst[j], k1, k2):\n                    ret *= P_sum[j][k2]\n                    break\n                index_lst[j] += 1\n        ans += ret\n    print '%.10f' % ans\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\nnm = {}\ndef nCr(n, b):\n    if b > n - b:\n        b = n - b\n    key = (n,b)\n    if key in nm:\n        return nm[key]\n    r = 1\n    for k in range(n, n-b, -1):\n        r = r * k % mod\n    d = 1\n    for k in range(1, b+1):\n        d = d * k % mod\n    nm[key] = r * inv(d) % mod\n    return nm[key]\n\n\ndef main():\n    rr = []\n\n    n,m,l = LI()\n    ps = [LI() for _ in range(n)]\n    ts = []\n    rs = []\n    us = []\n\n    for p,t,v in ps:\n        p /= 100\n        u = l / v\n        ti = []\n        ri = []\n        for i in range(m+1):\n            ti.append(u+t*i)\n            k = pow(1-p, m-i) * pow(p, i) * nCr(m, i)\n            ri.append(k)\n        ts.append(ti)\n        rs.append(ri)\n        ui = ri[:]\n        for i in range(1,m+1):\n            ui[i] += ui[i-1]\n        us.append(ui)\n\n    for i in range(n):\n        r = 0\n        for j in range(m+1):\n            tr = rs[i][j]\n            tt = ts[i][j] + eps\n            for k in range(n):\n                if i == k:\n                    continue\n                bi = bisect.bisect_left(ts[k], tt)\n                if bi > 0:\n                    tr *= 1 - us[k][bi-1]\n            r += tr\n        rr.append(r)\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def upper_bound(arr, v)\n  l = -1\n  r = arr.size\n  while l + 1 < r\n    m = (l + r) / 2\n    if arr[m] <= v then l = m\n    else r = m\n    end\n  end\n  r\nend\n\nEPS = 1e-9\nFactorial = (1..50).each_with_object([1]) { |i, arr| arr << arr[-1] * i }\n\nn, m, l = gets.split.map(&:to_i)\np, t, v = n.times.map{ gets.split.map(&:to_i) }.transpose\ntime_set = n.times.map{ [0] * (m + 1) }\nprob_set = n.times.map{ [0] * (m + 1) }\nn.times do |i|\n  s = v[i] == 0 ? Float::INFINITY : l / v[i].to_f\n  (m + 1).times do |j|\n    time_set[i][j] = s + t[i] * j\n    prob_set[i][j] = (p[i] / 100.0) ** j * (1 - p[i] / 100.0) ** (m - j) * Factorial[m] / Factorial[m - j] / Factorial[j]\n  end\nend\n\nn.times do |i|\n  ret = 0\n  (m + 1).times do |j|\n    prob = prob_set[i][j]\n    n.times do |k|\n      next if i == k\n      idx = upper_bound(time_set[k], time_set[i][j] + EPS)\n      if idx == m + 1\n        prob = 0\n        break\n      end\n      prob *= prob_set[k][idx..-1].reduce(:+)\n    end\n    ret += prob\n  end\n  puts '%.8f' % ret\nend"
  },
  {
    "language": "Python",
    "code": "\nimport bisect\ndef nCr(n, r):\n    r = min(r, n-r)\n    numerator = 1\n    for i in range(n, n-r, -1):\n        numerator *= i\n    denominator = 1\n    for i in range(r, 1, -1):\n        denominator *= i\n    return numerator // denominator\n\nn,m,l=map(int,input().split())\ndata = [[0 for i in range(m+1)]for i in range(n)]\nfor i in range(n):\n    p,t,v=map(int,input().split())\n    for j in range(m+1):\n        data[i][j]=((t*j+l/v)if v!=0 else 9999999999999999, (p/100.0)**(j) * nCr(m,j) * (1-p/100.0)**(m-j))\n\nans=[]\nfor i in range(n):\n    win=0\n    for j in range(m+1):\n        wintmp=data[i][j][1]\n        for x in range(n):\n            if i==x:\n                continue\n            tmp=0\n            for a,b in data[x][bisect.bisect_right(data[x],(data[i][j][0],5)):]:\n                tmp+=b\n            wintmp*=tmp\n        win+=wintmp\n    ans.append(win)\n\nfor a in ans:\n    print('%.8f'%a)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nnm = {}\ndef nCr(n, b):\n    if b > n - b:\n        b = n - b\n    key = (n,b)\n    if key in nm:\n        return nm[key]\n    r = 1\n    for k in range(n, n-b, -1):\n        r = r * k\n    d = 1\n    for k in range(1, b+1):\n        d = d * k\n    nm[key] = r / d\n    return nm[key]\n\n\ndef main():\n    rr = []\n\n    n,m,l = LI()\n    ps = [LI() for _ in range(n)]\n    ts = []\n    rs = []\n    us = []\n\n    for p,t,v in ps:\n        if v == 0:\n            ts.append(0)\n            rs.append(0)\n            us.append(0)\n            continue\n        p /= 100\n        u = l / v\n        ti = []\n        ri = []\n        for i in range(m+1):\n            ti.append(u+t*i)\n            k = pow(1-p, m-i) * pow(p, i) * nCr(m, i)\n            ri.append(k)\n        ts.append(ti)\n        rs.append(ri)\n        ui = ri[:]\n        for i in range(1,m+1):\n            ui[i] += ui[i-1]\n        us.append(ui)\n\n    for i in range(n):\n        r = 0\n        if ts[i] == 0:\n            rr.append(r)\n            continue\n        for j in range(m+1):\n            tr = rs[i][j]\n            tt = ts[i][j] + 1.0 / 10**10\n            for k in range(n):\n                if i == k or ts[k] == 0:\n                    continue\n                bi = bisect.bisect_left(ts[k], tt)\n                if bi > 0:\n                    tr *= 1 - us[k][bi-1]\n            r += tr\n        rr.append('{:.9f}'.format(r))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN, M, L = map(int, raw_input().split())\n\ndef fact(n):\n    if n <= 1:\n        return 1\n    return fact(n - 1) * n\nMC = []\nfor i in range(M + 1):\n    MC.append(fact(M) / fact(i) / fact(M - i))\n\np_lst = []\nP_val = []\nP_sum = []\n\nfor i in range(N):\n    P, T, V = map(int, raw_input().split())\n    p_lst.append((T, V))\n    PP = []\n    for k in range(M + 1):\n        PP.append(float(MC[k] * (P ** k) * ((100 - P) ** (M - k))) / 100 ** M)\n    P_val.append(list(PP))\n    for k in range(M, 0, -1):\n        PP[k - 1] += PP[k]\n    P_sum.append(PP)\n\ndef comp(p1, p2, k1, k2):\n    T1, V1 = p1\n    T2, V2 = p2\n    return L * (V2 - V1) < V1 * V2 * (k2 * T2 - k1 * T1)\n\nfor i in range(N):\n    ans = 0\n    index_lst = [0 for j in range(N)]\n    for k1 in range(M + 1):\n        ret = P_val[i][k1]\n        for j in range(N):\n            if i == j:\n                continue\n            flag = True\n            while True:\n                k2 = index_lst[j]\n                if k2 > M:\n                    ret *= 0\n                    break\n                if comp(p_lst[i], p_lst[j], k1, k2):\n                    ret *= P_sum[j][k2]\n                    break\n                index_lst[j] += 1\n        ans += ret\n    print '%.10f' % ans\n\n"
  }
]