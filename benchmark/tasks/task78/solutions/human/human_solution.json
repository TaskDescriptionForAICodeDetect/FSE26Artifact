[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\ndouble square_calc(double x1, double y1, double x2, double y2, double x3, double y3)\n{\n\tdouble square = 0;\n\tdouble a = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\tdouble b = sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));\n\tdouble c = sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n\tdouble s = (a + b + c) / 2;\n\treturn(sqrt(s * (s - a ) * (s - b) * (s - c)));\n}\n\nvoid solve()\n{\n\tint n;\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tdouble xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\t\tdouble square = square_calc(xp1, yp1, xp2, yp2, xp3, yp3);\n\t\t\tdouble square1 = square_calc(xk, yk, xp1, yp1, xp2, yp2) + square_calc(xk, yk, xp1, yp1, xp3, yp3) + square_calc(xk, yk, xp2, yp2, xp3, yp3);\n\t\t\tdouble square2 = square_calc(xs, ys, xp1, yp1, xp2, yp2) + square_calc(xs, ys, xp1, yp1, xp3, yp3) + square_calc(xs, ys, xp2, yp2, xp3, yp3);\n\t\t\tif(fabs(square - square1) <= 1e-6 && fabs(square - square2) >= 1e-6 ||\n\t\t\t   fabs(square - square1) >= 1e-6 && fabs(square - square2) <= 1e-6)\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// テ・ツ?・テ・ツ環崚」ツつケテ」ツδ暗」ツδェテ」ツδシテ」ツδ?」ツ?凝」ツつ嘉・ツョツ淌ヲツ閉ーテ、ツコツ古」ツ?、テ」ツつ津」ツ?ィテ」ツ?」テ」ツ?ヲ Point テ」ツ?ク\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// テ・ツ、ツ姪ァツゥツ催ッツシツ暗」ツつッテ」ツδュテ」ツつケテァツゥツ催ッツシツ?\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// CCW テゥツ鳴「テヲツ閉ーテ」ツ?? -> b -> c テ」ツ?ィテゥツ?イテ」ツつ?」ツ?ィテ」ツ?催」ツ??・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツつ?1, テァツ崢エテゥツ?イテ」ツ?ェテ」ツつ?0, テヲツ卍づィツィツ暗・ツ崢榲」ツつ甘」ツ?ェテ」ツつ?-1\n// include : cross\nint ccw( const Point &a, const Point &b, const Point &c )\n{\n\tif ( cross( ( b - a ), ( c - a ) ) < -EPS )\n\t{\n\t\treturn -1;\n\t}\n\telse if ( EPS < cross( ( b - a ), ( c - a ) ) )\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n// テァツつケ p テ」ツ?古・ツ、ツ堙ィツァツ津・ツスツ「 qs テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ」ツ?づ」ツつ凝」ツ??( Winding Number Algorithm) :TODO\n// include : ccw\nbool point_in_polygon( const Point &p, const vector<Point> &qs )\n{\n\tconst int N = qs.size();\n\t\n\tint wn = 0;\n\tfor ( int i = 0; i < N; ++i )\n\t{\n\t\tconst Point &s = qs[i], &t = qs[ ( i + 1 ) % N ];\n\t\tif ( s.imag() - EPS <= t.imag() && s.imag() - EPS < p.imag() && p.imag() + EPS < t.imag() ) // テ、ツクツ甘・ツ青妥」ツ?催」ツ?ョティツセツコ\n\t\t{\n\t\t\twn += ccw( s, p, t ) == -1;\n\t\t}\n\t\telse if ( t.imag() - EPS <= s.imag() && t.imag() - EPS < p.imag() && p.imag() + EPS < s.imag() )\n\t\t{\n\t\t\twn -= ccw( t, p, s ) == -1;\n\t\t}\n\t}\n\treturn wn;\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\tREP( i, 0, n )\n\t{\n\t\tvector<Point> tri( 3 );\n\t\tREP( j, 0, 3 )\n\t\t{\n\t\t\tcin >> tri[j];\n\t\t}\n\t\tPoint s, t;\n\t\tcin >> s >> t;\n\n\t\tcout << ( point_in_polygon( s, tri ) ^ point_in_polygon( t, tri ) ? \"OK\" : \"NG\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps){\n  point a,b;\n  a=b=p;\n\n  b.x=1000000;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p)!=inside(s,p))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=Crosspoint(pq,ks);\n    ans+=Crosspoint(qr,ks);\n    ans+=Crosspoint(rp,ks);\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\t//if (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\ntypedef struct POINT_tag{\n  int x, y;\n}POINT_t;\n\ntypedef struct LINE_tag{\n  POINT_t a, b;\n}LINE_t;\n\ntypedef struct TRIANGLE_tag{\n  POINT_t a, b, c;\n}TRIANGLE_t;\n\nint side(POINT_t *p, LINE_t *e){\n  POINT_t p1 = *p;\n  POINT_t p2 = e->a;\n  POINT_t p3 = e->b;\n\n  const int n = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);\n  if(n > 0) return 1;\n  else if(n > 0) return -1;\n  else return 0;\n}\n\nint solve(POINT_t *p, TRIANGLE_t *t){\n  LINE_t ab, bc, ca;\n  ab.a = t->a; ab.b = t->b;\n  bc.a = t->b; bc.b = t->c;\n  ca.a = t->c; ca.b = t->a;\n  const int pab = side(p, &ab);\n  const int pbc = side(p, &bc);\n  const int pca = side(p, &ca);\n\n  if((0 < pab) && (0 < pbc) && (0 < pca)) return 1;\n  if((0 > pab) && (0 > pbc) && (0 > pca)) return 1;\n  if((0 <= pab) && (0 <= pbc) && (0 <= pca)) return -1;\n  if((0 <= pab) && (0 >= pbc) && (0 >= pca)) return -1;\n  return 0;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    TRIANGLE_t t;\n    POINT_t k, s;\n    scanf(\"%d%d%d%d%d%d%d%d%d%d\", &t.a.x, &t.a.y, &t.b.x, &t.b.y, &t.c.x, &t.c.y, &k.x, &k.y, &s.x, &s.y);\n    if(solve(&k, &t) != solve(&s, &t)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init));\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\ndouble EPS = 1e-10;\ndouble add(double a, double b){\n  if(abs(a+b) < EPS* (abs(a) + abs(b))) return 0;\n  return a+b;\n}\n\nstruct P{\n  double x,y;\n  P(){}\n  P(double _x,double _y):x(_x),y(_y){}\n  P operator + (P p){\n    return P(add(x,p.x) ,add(y,p.y));\n  }\n  P operator - (P p){\n    return P(add(x,-p.x) ,add(y,-p.y));\n  }\n  P operator * (double d){\n    return P(x * d,y * d);\n  }\n  friend ostream& operator<<(ostream& os,const P& p){\n    os << \"(\"<<p.x <<\",\"<<p.y<<\")\";\n    return os;\n  }\n  double norm(){\n    return sqrt(x*x + y*y);\n  }\n  double dot(P p){\n    return add(x * p.x,y*p.y);\n  }\n  double det(P p){\n    return add(x*p.y,-y*p.x);\n  }\n  double dist2(P p){\n    return ((*this-p).x * (*this-p).x) + ((*this-p).y * (*this-p).y);\n  }\n  P GetCenter(P &p){\n    return P((*this+p).x/2,(*this+p).y/2);\n  }\n  double GetSlope(P &p){\n    P tmp = *this - p;\n    return tmp.y/tmp.x;\n  }\n};\nbool on_seg(P p1,P p2,P q){\n  return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\nP intersection(P p1, P p2, P q1,P q2){\n  return p1 + (p2-p1) * ((q2 - q1).det(q1-p1) / (q2 - q1).det(p2-p1)) ;\n}\n\nint check(P p1,P p2,P p3){\n  P a = p2-p1,b = p3 - p1;\n  if(a.det(b) > EPS) return 1;\n  else if(a.det(b) < -EPS) return -1;\n  return 0;\n}\nbool solve(double a,double b,double c,double d,double e,double f,double xp,double yp){\n  P p1 = P(a,b),p2 = P(c,d),p3 = P(e,f),p4 = P(xp,yp);\n  int A = check(p1,p2,p4);\n  int B = check(p2,p3,p4);\n  int C = check(p3,p1,p4);\n  if(A == B && B == C && (B == 1 || B == -1)){\n    return true;\n  }\n  return false;\n}\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  double a,b,c,d,e,f,xk,yk,xs,ys;\n  rep(i,n){\n    cin >> a >> b >> c >> d >> e >> f >> xk >> yk >> xs >> ys;\n    if(solve(a,b,c,d,e,f,xk,yk) == solve(a,b,c,d,e,f,xs,ys)){\n      cout << \"NG\"<<endl;\n    }\n    else{\n      cout << \"OK\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n#include <algorithm>\n#include <bitset>\n#include <set>\n#include <functional>\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\ntypedef long long int lint;\n\nclass Point {\npublic:\n\tint x;\n\tint y;\n\n\tPoint() {\n\t\tx = y = 0;\n\t}\n\tPoint(int x, int y) {\n\t\tthis->x = x; this->y = y;\n\t}\n\n\tPoint operator + (Point obj) {\n\t\treturn Point(this->x + obj.x, this->y + obj.y);\n\t}\n\tPoint operator - (Point obj) {\n\t\treturn Point(this->x - obj.x, this->y - obj.y);\n\t}\n\tint operator * (Point obj) {\n\t\treturn (this->x * obj.y - this->y * obj.x);\n\t}\n\n\tfriend std::ostream& operator << (std::ostream& ostr, const Point& p) {\n\t\tstd::cout << \"{\" << p.x << \", \" << p.y << \"}\";\n\t\treturn ostr;\n\t}\n};\n\nbool interior(Point p1, Point p2, Point p3, Point p) {\n\tPoint v1, v2, v3, pp1, pp2, pp3;\n\tv1 = p2 - p1; v2 = p3 - p2; v3 = p1 - p3;\n\tpp1 = p - p1; pp2 = p - p2; pp3 = p - p3;\n\tint cp1, cp2, cp3;\n\tcp1 = v1 * pp1; cp2 = v2 * pp2; cp3 = v3 * pp3;\n\tif (cp1 < 0 && cp2 < 0 && cp3 < 0) return true;\n\tif (cp1 > 0 && cp2 > 0 && cp3 > 0) return true;\n\treturn false;\n}\n\nvoid AOJ0143()\n{\n\tPoint p[3], k, s;\n\tREP(i, 3) {\n\t\tcin >> p[i].x >> p[i].y;\n\t}\n\tcin >> k.x >> k.y >> s.x >> s.y;\n\n\tif (interior(p[0], p[1], p[2], k) ^ interior(p[0], p[1], p[2], s)) {\n\t\tcout << \"OK\" << endl;\n\t}\n\telse cout << \"NG\" << endl;\n\n\treturn;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n) AOJ0143();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n\tdouble S = abs(p[0] - p[1]) * dist(p[0] ,p[1], p[2]);\n\t\n\trep(i, 3) S -= abs(p[i] - p[(i + 1) % 3]) * dist(p[i], p[(i + 1) % 3], x);\n\t\n\treturn abs(S) < EPS;\n}\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\t\n\twhile(n--)\n\t{\n\t\tP p[3];\n\t\tP k, s;\n\t\t\n\t\trep(i, 3) cin >> p[i].real() >> p[i].imag();\n\t\tcin >> k.real() >> k.imag() >> s.real() >> s.imag();\n\t\n\t\tif(isInTriangle(p, k) ^ isInTriangle(p, s))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n// must template\ntypedef long double D;\nconst D INF = 1e12,EPS = 1e-10;\n\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nistream& operator >> (istream& is,complex<D>& p){D x,y;is >> x >> y; p=P(x,y); return is;}\n\nint sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\ntemplate<typename T> bool eq(const T& a,const T& b){return sig(abs(a-b))==0;}\nbool compX (const P& a,const P& b){return !eq(a.X,b.X)?sig(a.X,b.X)<0:sig(a.Y,b.Y)<0;}\nnamespace std{\n\tbool operator <  (const P& a,const P& b){return compX(a,b);}\n  \tbool operator == (const P& a,const P& b){return eq(a,b);}\n};\n// a×b\nD cross(const P& a,const P& b){return imag(conj(a)*b);}\n// a・b\nD dot(const P& a,const P& b) {return real(conj(a)*b);}\nint ccw(const P& a,P b,P c){\n    b -= a; c -= a;\n    if (sig(cross(b,c)) > 0)   return +1;       // counter clockwise\n    if (sig(cross(b,c)) < 0)   return -1;       // clockwise\n    if (sig(dot(b,c)) < 0)     return +2;       // c--a--b on line\n    if (sig(norm(b),norm(c))<0) return -2;       // a--b--c on line\n    return 0; //a--c--b on line (c==b,c==a)\n}\n// //must template\n\ntypedef vector<P> Poly,ConvexPoly;\nenum { OUT, ON, IN };\nint contains(const Poly& ps, const P& p) {\n  \tbool in = false;int n=ps.size();\n  \tREP(i,n){\n\t\tP a = ps[i] - p, b = ps[pmod(i+1,n)] - p;\n\t\tif(a.Y > b.Y) swap(a, b);\n\t\tif(a.Y <= 0 && 0 < b.Y)if(sig(cross(a, b)) < 0) in = !in;\n    \tif(sig(cross(a, b)) == 0 && sig(dot(a, b)) <= 0) return ON;\n  \t}\n\treturn in ? IN : OUT;\n}\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tREP(i,N){\n\t\t\tvector<P> ps(3); REP(j,3)cin >>ps[j];\n\t\t\tP k,s;cin >> k >> s;\n\t\t\tbool ok=false;\n\t\t\tREP(j,3)if(!contains(ps,k) && contains(ps,s))ok=true;\n\t\t\tcout <<(ok?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcerr <<fixed<<setprecision(20);\t\n\tcout <<fixed<<setprecision(20);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n};\n\nint ccw(P p0, P p1, P p2)\n{\n\tdouble dx1 = p1.x-p0.x;\n\tdouble dy1 = p1.y-p0.y;\n\tdouble dx2 = p2.x-p0.x;\n\tdouble dy2 = p2.y-p0.y;\n\t\n\tif(dx1*dy2 > dy1*dx2){\n\t\treturn 1;\n\t} \n\tif(dx1*dy2 < dy1*dx2){\n\t\treturn -1;\n\t}\n\tif((dx1*dx2 < 0) || (dy1*dy2 < 0)){\n\t\treturn -1;\n\t}\n\tif((dx1*dx1+dy1*dy1)<(dx2*dx2+dy2*dy2)){\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}\n\nint intersect(P p1, P p2, P p3, P p4)\n{\n\treturn (((ccw(p1, p2, p3)*ccw(p1, p2, p4)) <= 0)\n\t\t\t\t &&((ccw(p3, p4, p1)*ccw(p3, p4, p2)) <= 0));\n}\n\nint main()\n{\n\tint n, c;\n\tbool f;\n\tP pr[3], s, t;\n\t\n\twhile(cin>>n && n){\n\t\twhile(n--){\n\t\t\tc = 0;\n\t\t\tcin >> pr[0].x >> pr[0].y >> pr[1].x >> pr[1].y >> pr[2].x >> pr[2].y >> s.x >> s.y >> t.x >> t.y;\n\t\t\tif(intersect(pr[0], pr[1], s, t) == 1){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(intersect(pr[0], pr[2], s, t) == 1){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(intersect(pr[1], pr[2], s, t) == 1){\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(c == 1){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n\n\nusing namespace std;\nconst int MOD = 1000000009; // check!!!\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\n#pragma region テ・ツ淞コテヲツ慊ャティツヲツ?ァツエツ?struct,typedef)\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//テヲツッツ氾ィツシツεァツ板ィ\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n#pragma endregion \n\n#pragma region テ・ツ淞コテヲツ慊ャティツヲツ?ァツエツ?テゥツ鳴「テヲツ閉ー)\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs2(const point<T>& p){return SQ(p.x) + SQ(p.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(abs2(p));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //ティツェツ、テ・ツキツョテ・ツッツセテァツュツ?(テゥツ?淌・ツコツヲテ」ツ?古」ツつ?」ツ?ーテ」ツ??ヲツ卍づ」ツ?ッテ・ツ、ツ姪」ツ?凖」ツ?凝」ツ??、ツコツ古、ツケツ療」ツ?ォテァツスツョテ」ツ?催ヲツ渉崚」ツ?暗」ツつ?\n    if(rdir> EPS * len) return CCW; //cテ」ツ?径bテ」ツつ暗」ツつ甘、ツクツ?テ・ツ渉催ヲツ卍づィツィツ暗・ツ堕ィテ」ツつ?\n    if(rdir<-EPS * len) return CW; // cテ」ツ?径bテ」ツつ暗」ツつ甘、ツクツ?テヲツ卍づィツィツ暗・ツ堕ィテ」ツつ?\n    return ON; // a,b,cテ」ツ?古、ツクツ?ァツ崢エテァツキツ堙、ツクツ?\n}\n\n#pragma endregion\n\n#pragma region テ・ツ?・テ・ツ?コテ・ツ環?\n\nstd::ostream& operator<<(std::ostream& os, const P& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\nstd::ostream& operator<<(std::ostream& os, const S& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\nstd::istream& operator>>(std::istream& is, P& point){return ( is >> point.x >> point.y );}\n\n#pragma endregion\n\n//テ、ツコツ、テァツつケテ」ツ?古・ツュツ佚・ツ慊ィテ」ツ?凖」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool intersected(const S &S1,const S &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\n#pragma region ティツキツ敕ゥツ崢「\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「(2テ、ツケツ?\ndouble dist2(const S &S,const P &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(const S &S,const P &p){ return sqrt(dist2(S,p)); }\n\n//テァツキツ堙・ツ按?」ツ?ィテァツキツ堙・ツ按?」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(const S &S1,const S &S2){\n    if(intersected(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\n//テァツ崢エテァツキツ堙」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(const L &L,const P &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\n//a -- bテ」ツ?ョテゥツ鳴禿」ツ?ョテ・ツ??」ツ?古・ツ?・テ」ツ?」テ」ツ?淌ヲツ卍づ」ツ?ョテ」ツ?‖ - bテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\n//テ・ツ??」ツ?ョテゥツ鳴禿」ツ?ォ\ndouble geodist(P a,P b,const C &c){\n\tdouble r=c.r;\n\tS s(a,b);\n\tif(dist(s,c.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=c.c;\n\tb-=c.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\n#pragma endregion\n\n#pragma region テゥツ敖「テァツゥツ?\n\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble area(const vector<P>& v){\n\tdouble ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\n//テ、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble area(const P &a,const P &b,const P &c){\n\treturn abs(cross(b-a,c-a)) / 2;\n}\n\n#pragma endregion\n\n#pragma region テ・ツ個?・ツ青ォ\n\n//テ・ツ?クテ・ツ個?\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n//テ、ツクツ嘉ィツァツ津・ツスツ「abcテ」ツ?ォpテ」ツ?古・ツ青ォテ」ツ?セテ」ツつ古」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??テァツキツ堙、ツクツ甘」ツ?ョテ・ツ?エテ・ツ青暗」ツつづ・ツ青ォテ」ツつ?\nbool cover(const P& a,const P& b,const P& c,const P& p){\n\treturn area(a,b,c) + EPS >= area(a,b,p) + area(a,c,p) + area(b,c,p);\n}\n\n#pragma endregion\n\n#pragma region テ、ツコツ、テァツつケ\n\ntypedef pair<P,P> PD;\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケ\nPD GetContact(const C& p, const C &q){\n\tP a = q.c-p.c;\n\t//Point b = rot(a,PI / 2);\n\tP b(a.y,-a.x);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (p.r + q.r + c) / 2;\n\tdouble men = sqrt(s * (s - p.r) * (s - q.r) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(p.r) - SQ(l));\n\t\n\ta = a / c * lp;\n\tif(SQ(q.r) - SQ(p.r) - SQ(c) > 0){ //ティツ?ε」ツ?暗」ツ?ヲテ」ツ??」ツつ凝、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョティツァツ津」ツ??0テ・ツコツヲテ、ツサツ・テ、ツクツ甘」ツ?ョテ・ツ?エテ・ツ青?\n\t\ta *= -1;\n\t}\n\tb = b * l;\n\treturn PD(p.c + a + b,p.c + a - b);\n}\n\n// l : ax+by+c=0 テ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ninline void calc_abc(const L &l,double &a,double &b,double &c){\n    a=l.a.y-l.b.y;\n    b=l.b.x-l.a.x;\n    c=l.a.x*l.b.y-l.b.x*l.a.y;\n}\n \n//Pテ」ツ?凝」ツつ鵜テ」ツ?クテ」ツ?ョテ・ツ楪づァツキツ堙」ツ?ョティツカツウ\nP perp_foot(const P &p,const L &l){\n    double a,b,c;\n    calc_abc(l,a,b,c);\n    return p-P(a,b) * ((a*p.x+b*p.y+c)/(a*a+b*b));\n}\n \n//テ・ツ??」ツ?ィテァツ崢エテァツキツ堙」ツ?ョテ、ツコツ、テァツつケ\nint intersect(const C &c,const L &l,P *p=NULL,P *q=NULL){\n    P m=perp_foot(c.c,l);\n    double d2=abs2(c.c-m);\n    if(c.r*c.r+EPS<d2)   return 0;\n    else if(abs(c.r*c.r-d2)<EPS){\n        if(p&&q)    *p=*q=m;\n        return 1;\n    }\n    else{\n        if(p&&q){\n            P v;\n            double n0=abs2(l.a-m),n1=abs2(l.b-m);\n            if(n0<n1)    v=l.b-m,n0=n1;\n            else        v=l.a-m;\n            v*=sqrt((c.r*c.r-d2)/n0);\n            *p=m+v,*q=m-v;\n        }\n        return 2;\n    }\n}\n\n//テ・ツ??」ツ?ィテァツキツ堙・ツ按?」ツ?ョテ、ツコツ、テァツつケ\nint intersect(const C &c,const S &s,P *p=NULL,P *q=NULL){\n    P pp,qq;\n    int n=intersect(c,L(s.a,s.b),&pp,&qq);\n    if(n==0)    return 0;\n    else if(n==1){\n        if(dot(pp-s.a,pp-s.b)<EPS){\n            if(p&&q)    *p=*q=pp;\n            return 1;\n        }\n        return 0;\n    }\n    else{\n        bool bp=(dot(pp-s.a,pp-s.b)<EPS);\n        bool bq=(dot(qq-s.a,qq-s.b)<EPS);\n        if(bp&&bq){\n            if(p&&q)    *p=pp,*q=qq;\n            return 2;\n        }\n        if(bp||bq){\n            if(p&&q)    *p=(bp?pp:qq);\n            return 1;\n        }\n        return 0;\n    }\n}\n\n//テァツ崢エテァツキツ堙」ツ?ョテ、ツコツ、テァツつケ\nP intersect(const L &L1,const L &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+(L2.b-L2.a) * (a2/a1);\n}\n\n#pragma endregion\n\n\n\nint main(){\n\tint n; cin>>n;\n\twhile(n--){\n\t\tP a,b,c,k,s;\n\t\tcin>>a>>b>>c>>k>>s;\n\t\tbool kb = cover(a,b,c,k);\n\t\tbool sb = cover(a,b,c,s);\n\t\tputs(kb == sb ? \"NG\" : \"OK\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n+1;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n    //cout <<inside(k,p,3)<<\" \"<<inside(s,p,3)<<endl;\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> polygon;\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\n#define curr(G, i) G[i]\n#define next(G, i) G[(i+1)%G.size()]\nenum { OUT, ON, IN };\n\nint contains(const polygon& G, const P& p) {\n    bool in = false;\n    for (int i = 0; i < G.size(); ++i) {\n        P a = curr(G,i) - p, b = next(G,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\nint main(){\n    int n;\n    int xp1, yp1, xp2, yp2, xp3, yp3, xa, ya, xb, yb;\n    cin >> n;\n\n    for(int i=0;i<n;i++){\n        polygon triangle;\n        cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xa >> ya >> xb >> yb;\n        triangle.push_back(P(xp1,yp1));\n        triangle.push_back(P(xp2,yp2));\n        triangle.push_back(P(xp3,yp3));\n        int a,b;\n        a = contains(triangle, P(xa,ya));\n        b = contains(triangle, P(xb,yb));\n        if(a+b == 2 && a*b == 0){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double frac;\ntypedef complex<frac> Pt;\nstruct less_c{\n    bool operator() (const Pt& a, const Pt& b){\n\t    return a.real()!=b.real() ? a.real()<b.real() : a.imag()<b.imag();\n    }\n};\nfrac cross(Pt a, Pt b){ //外積\n    return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool in_convex(vector<Pt> p, Pt q){\n    vector<Pt> pp=p;\n    pp.push_back(q);\n    \n    int n=pp.size();\n    sort(pp.begin(),pp.end(),less_c());\n    vector<Pt> ch(2);\n    for(int i=0; i<2; i++) ch[i]=pp[i];\n    for(int i=2; i<n; i++){\n        for(int j=ch.size()-1; j>0; j--){\n            if(cross(pp[i]-ch[j],ch[j-1]-ch[j])<0){\n                ch.erase(ch.begin()+j);\n            }else{\n                break;\n            }\n        }\n        ch.push_back(pp[i]);\n    }\n    \n    int half=ch.size()-1;\n    ch.push_back(pp[n-2]);\n    for(int i=n-3; i>=0; i--){\n        for(int j=ch.size()-1; j>half; j--){\n            if(cross(pp[i]-ch[j],ch[j-1]-ch[j])<0){\n                ch.erase(ch.begin()+j);\n            }else{\n                break;\n            }\n        }\n        ch.push_back(pp[i]);\n    }\n    ch.pop_back();\n\n    sort(ch.begin(),ch.end(),less_c());\n    sort(p.begin(),p.end(),less_c());\n    return ch==p;\n}\n\nint main(){\n\tint n;  cin >> n;\n    for(int i=0; i<n; i++){\n        int x, y;\n        vector<Pt> p(3);\n        for(int j=0; j<3; j++){\n            cin >> x >> y;\n            p[j]={frac(x),frac(y)};\n        }\n        Pt k, s;\n        cin >> x >> y;  k={frac(x),frac(y)};\n        cin >> x >> y;  s={frac(x),frac(y)};\n        \n        cout << (in_convex(p,k)!=in_convex(p,s) ? \"OK\" : \"NG\") << endl; \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(const Point &cc,double rr) : c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble dis2(const Point &a,const Point &b){\n\treturn (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\nPolygon ConvexHull(vector<Point> ps){\n\tint n=ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tvector<Point> ch_u(n);\n\tint n_u=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tch_u[n_u++]=ps[i];\n\t\twhile(n_u>=3 && ccw(ch_u[n_u-3],ch_u[n_u-2],ch_u[n_u-1])!=CCW){\n\t\t\tch_u[n_u-2]=ch_u[n_u-1];\n\t\t\tn_u--;\n\t\t}\n\t}\n\n\tvector<Point> ch_l(n);\n\tint n_l=0;\n\tfor(int i=0;i<n;i++){\n\t\tch_l[n_l++]=ps[i];\n\t\twhile(n_l>=3 && ccw(ch_l[n_l-3],ch_l[n_l-2],ch_l[n_l-1])!=CCW){\n\t\t\tch_l[n_l-2]=ch_l[n_l-1];\n\t\t\tn_l--;\n\t\t}\n\t}\n\n\tPolygon ch;\n\tfor(int i=0;i<n_u-1;i++)\tch.pb(ch_u[i]);\n\tfor(int i=0;i<n_l-1;i++)\tch.pb(ch_l[i]);\n\treturn ch;\n}\n/*\nbool parallel(const Line &l,const Line &m){\n\treturn abs(cross(l[1]-l[0],m[1]-m[0]))<EPS;\n}\n\nbool orthogonal(const Line &l,const Line &m){\n\treturn abs(dot(l[1]-l[0],m[1]-m[0]))<EPS;\n}\n*/\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", \"M sessuru L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nLine perp_bisector(const Point &a,const Point &b){\n\treturn Line(Point((a.x+a.y+b.x-b.y)/2,(b.x+b.y-a.x+a.y)/2),\n\t\t\t\tPoint((b.x+b.y+a.x-a.y)/2,(a.x+a.y-b.x+b.y)/2));\n}\n/*\ndouble area(const Point &a,const Point &b,const Point &c){\n\treturn abs(cross(b-a,c-a))/2;\n}\n*/\ndouble area(const Polygon &pl){\n\tint n=pl.size();\n\tdouble a=0;\n\tfor(int i=0;i<n;i++)\ta+=cross(pl[i],pl[(i+1)%n]);\n\treturn abs(a)/2;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tint n;\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tPoint a,b,c,star[2];\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf\",\n\t\t\t&a.x,&a.y,&b.x,&b.y,&c.x,&c.y,&star[0].x,&star[0].y,&star[1].x,&star[1].y);\n\t\tbool in[2];\n\t\tfor(int i=0;i<2;i++){\n\t\t\tint cnt=0;\n\t\t\tcnt+=ccw(a,b,star[i]);\n\t\t\tcnt+=ccw(b,c,star[i]);\n\t\t\tcnt+=ccw(c,a,star[i]);\n\t\t\tin[i]=(cnt==3*CCW || cnt==3*CW);\n\t\t}\n\t\tputs(in[0]==in[1]?\"NG\":\"OK\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint cross(int ax, int ay, int bx, int by) {\n\treturn ax*by - ay*bx;\n}\nint main() {\n\tint n, xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\tcin >> n;\n\trep(i,n) {\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tint a=1, b=1;\n\t\tif(cross(xp2-xp1,yp2-yp1,xk-xp1,yk-yp1)>0 && cross(xp3-xp2,yp3-yp2,xk-xp2,yk-yp2)>0 && cross(xp1-xp3,yp1-yp3,xk-xp3,yk-yp3)>0 ||\n\t\t   cross(xp2-xp1,yp2-yp1,xk-xp1,yk-yp1)<0 && cross(xp3-xp2,yp3-yp2,xk-xp2,yk-yp2)<0 && cross(xp1-xp3,yp1-yp3,xk-xp3,yk-yp3)<0) a = -1;\n\t\tif(cross(xp2-xp1,yp2-yp1,xs-xp1,ys-yp1)>0 && cross(xp3-xp2,yp3-yp2,xs-xp2,ys-yp2)>0 && cross(xp1-xp3,yp1-yp3,xs-xp3,ys-yp3)>0 ||\n\t\t   cross(xp2-xp1,yp2-yp1,xs-xp1,ys-yp1)<0 && cross(xp3-xp2,yp3-yp2,xs-xp2,ys-yp2)<0 && cross(xp1-xp3,yp1-yp3,xs-xp3,ys-yp3)<0) b = -1;\n\t\tif(a*b<0) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_intersected_ls(point p1, point p2, point p3, point p4) {\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0)&&\n         (ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n\n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n\n\n    if(tri.inter(pk) && !tri.inter(ps))cout << \"OK\" << endl;\n    else if(!tri.inter(pk) && tri.inter(ps))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nclass CPoint;\ntypedef CPoint CVector2D;\nclass CSegment;\ntypedef vector <CSegment> CSegments;\ndouble GetSquare( double );\nbool Equal( double, double );\nbool LessthanEqual( double, double );\ndouble GetCrossProduct( double, double, double, double );\ndouble GetCrossProduct( CPoint, CPoint );\ndouble GetDotProduct( double, double, double, double );\ndouble GetDotProduct( CPoint, CPoint );\ndouble GetGradientFromTwoPoints( CPoint, CPoint );\nint CheckCounterClockWise( CPoint, CPoint, CPoint );\nbool Intersect( CPoint, CPoint, CPoint, CPoint );\nbool Intersect( CSegment, CSegment );\nCPoint GetCrossPoint( CSegment, CSegment );\ndouble GetLength( CPoint, CPoint );\nCPoint GetLowestY( CPoint, CPoint );\nclass CPoint {\npublic:\n    double x, y;\n    CPoint( double x, double y ): x(x), y(y) {}\n    CPoint(): x(0), y(0) {};\n    double getNorm() {\n        return x * x + y * y;\n    }\n    double getAbs() {\n        return sqrt( getNorm() );\n    }\n    CPoint operator + ( CPoint p ) {\n        return CPoint( x + p.x, y + p.y );\n    }\n    CPoint operator - ( CPoint p ) {\n        return CPoint( x - p.x, y - p.y );\n    }\n    CPoint operator * ( double k ) {\n        return CPoint( x * k, y * k );\n    }\n    bool operator < ( const CPoint& p ) const {\n        if ( x < p.x ) return true;\n        if ( x == p.x ) return y < p.y;\n        return false;\n    }\n};\nCPoint operator * ( double k, CPoint p ) {\n    return CPoint( p.x * k, p.y * k );\n}\nostream& operator << ( ostream& os, CPoint p0 ) {\n    os << \"(\" << p0.x << \", \" << p0.y << \")\";\n    return os;\n}\nclass CSegment {\npublic:\n    CPoint a, b;\n    CSegment( int x1, int y1, int x2, int y2 ): a(CPoint( x1, y1 )), b(CPoint( x2, y2 )) {}\n    CSegment( CPoint a, CPoint b ): a(a), b(b) {}\n    CSegment() {}\n    double getGradient() {\n        return GetGradientFromTwoPoints( a, b );\n    }\n    double getLength() {\n        return GetLength( a, b );\n    }\n    double getMinX() {\n        return min( a.x, b.x );\n    }\n    double getMinY() {\n        return min( a.y, b.y );\n    }\n    double getMaxX() {\n        return max( a.x, b.x );\n    }\n    double getMaxY() {\n        return max( a.y, b.y );\n    }\n    bool operator < ( const CSegment& s ) const {\n        return b.y > s.b.y;\n    }\n    \n};\nostream& operator << ( ostream& os, CSegment s0 ) {\n    os << \"(\" << s0.a << \" - \" << s0.b << \")\";\n    return os;\n}\nclass CCircle {\npublic:\n    CPoint p;\n    int r;\n    CCircle(): p( 0, 0 ), r(0) {}\n    CCircle( int x, int y, int r ): p(x, y), r(r) {}\n    CCircle( CPoint p, int r ): p(p), r(r) {}\n};\nostream& operator << ( ostream& os, CCircle c0 ) {\n    os << \"{(\" << c0.p.x << \", \" << c0.p.y << \"), r = \" << c0.r << \")\";\n    return os;\n}\nclass CTriangle {\npublic:\n    CPoint a;\n    CPoint b;\n    CPoint c;\n    CTriangle( int x1, int y1, int x2, int y2, int x3, int y3 ):\n        a(CPoint(x1,y1)), b(CPoint(x2,y2)), c(CPoint(x3,y3)) {}\n    CTriangle( CPoint a, CPoint b, CPoint c ):\n        a(a), b(b), c(c) {}\n};\nostream& operator << ( ostream& os, CTriangle t0 ) {\n    os << \"{\" << t0.a << \", \" << t0.b << \", \" << t0.c << \"}\";\n    return os;\n}\nconst double EPS = 1e-9;\ndouble GetSquare( double x ) {\n    return x * x;\n}\nbool Equal( double a, double b ) {\n    return fabs( b - a ) < EPS;\n}\nbool LessthanEqual( double a, double b ) {\n    return a < b ? true : ( fabs( b - a ) < EPS );\n}\ndouble GetCrossProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * y2 - y1 * x2;\n}\ndouble GetCrossProduct( CPoint a, CPoint b ) {\n    return GetCrossProduct( a.x, a.y, b.x, b.y );\n}\ndouble GetDotProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * x2 + y1 * y2;\n}\ndouble GetDotProduct( CPoint a, CPoint b ) {\n    return GetDotProduct( a.x, a.y, b.x, b.y );\n}\nbool Intersect( CPoint p1, CPoint p2, CPoint p3, CPoint p4 ) {\n    bool f1 = CheckCounterClockWise( p1, p2, p3 ) * CheckCounterClockWise( p1, p2, p4 ) <= 0;\n    bool f2 = CheckCounterClockWise( p3, p4, p1 ) * CheckCounterClockWise( p3, p4, p2 ) <= 0;\n    return f1 && f2;\n}\nbool Intersect( CSegment s1, CSegment s2 ) {\n    return Intersect( s1.a, s1.b, s2.a, s2.b );\n}\nbool Contain( CTriangle a, CPoint p ) {\n    CVector2D AP = p - a.a;\n    CVector2D BP = p - a.b;\n    CVector2D CP = p - a.c;\n    CVector2D AB = a.b - a.a;\n    CVector2D BC = a.c - a.b;\n    CVector2D CA = a.a - a.c;\n    if ( GetCrossProduct( AP, AB ) < 0.0 ) return false;\n    if ( GetCrossProduct( BP, BC ) < 0.0 ) return false;\n    if ( GetCrossProduct( CP, CA ) < 0.0 ) return false;\n    return true;\n}\ndouble GetGradientFromTwoPoints( CPoint a, CPoint b ) {\n    return ( b.y - a.y ) / ( b.x - a.x );\n}\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\nint CheckCounterClockWise( CPoint p0, CPoint p1, CPoint p2 ) {\n    CVector2D a = p1 - p0;\n    CVector2D b = p2 - p0;\n    if ( GetCrossProduct( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n    if ( GetCrossProduct( a, b ) < EPS ) return CLOCKWISE;\n    if ( GetDotProduct( a, b ) < -EPS ) return ONLINE_BACK;\n    if ( a.getNorm() < b.getNorm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nCPoint GetCrossPoint( CSegment s1, CSegment s2 ) {\n    CVector2D base = s2.b - s2.a;\n    double d1 = abs( GetCrossProduct( base, s1.a - s2.a ) );\n    double d2 = abs( GetCrossProduct( base, s1.b - s2.a ) );\n    double t = d1 / ( d1 + d2 );\n    return s1.a + ( s1.b - s1.a ) * t;\n}\ndouble GetLength( CPoint a, CPoint b ) {\n    return sqrt( GetSquare( a.x - b.x ) + GetSquare( a.y - b.y ) );\n}\nCPoint GetLowestY( CPoint a, CPoint b ) {\n    if ( a.y == b.y ) return a.x < b.x ? a : b;\n    return a.y < b.y ? a : b;\n}\ndouble GetDistance( CSegment seg, CPoint p ) {\n    if ( GetDotProduct( seg.b - seg.a, p - seg.a ) < EPS ) return (p - seg.a).getAbs();\n    if ( GetDotProduct( seg.a - seg.b, p - seg.b ) < EPS ) return (p - seg.b).getAbs();\n    return fabs( GetCrossProduct( seg.b - seg.a, p - seg.a ) ) / ( seg.b - seg.a ).getAbs();\n}\nbool CheckIntersect( CSegment seg, CCircle c ) {\n    bool f1 = LessthanEqual( ( c.p - seg.a ).getAbs(), c.r );\n    bool f2 = LessthanEqual( ( c.p - seg.b ).getAbs(), c.r );\n    if ( f1 ^ f2 ) return true;\n    return LessthanEqual( GetDistance( seg, c.p ), c.r ) && ( ! f1 && ! f2 );\n}\n\n\nconst string YES = \"OK\";\nconst string NO = \"NG\";\nint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\nstring solve() {\n    CPoint A( xs, ys ), B( xk, yk );\n    CPoint P[3] = { CPoint( xp1, yp1 ), CPoint( xp2, yp2 ), CPoint( xp3, yp3 ) };\n    sort( P, P+3 );\n    \n    do {\n        CTriangle T( P[0], P[1], P[2] );\n        if ( Contain( T, A ) ^ Contain( T, B ) ) return YES;\n    } while ( next_permutation( P, P + 3 ) );\n    return NO;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for ( int i = 0; i < n; ++ i ) {\n        cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\nconst double EPS = 1e-5;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\ntypedef long long ll;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n \ntypedef complex<double> P;\n \ndouble triangleArea(P a, P b, P c)\n{\n    b -= a;\n    c -= a;\n    \n    return (0.5 * abs(b.imag() * c.real() - c.imag() * b.real()));\n}\n \n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n    int i;\n    double S = triangleArea(p[0], p[1], p[2]);\n    \n    rep(i, 3) S -= triangleArea(x, p[i], p[(i + 1) % 3]);\n    \n    return abs(S) < EPS;\n}\n \nint main()\n{\n    int n;\n        cin >> n;\n        \n        \n        while(n--)\n        {\n                P p[3];\n                P k, s;\n                \n                rep(i, 3) cin >> p[i].real() >> p[i].imag();\n                cin >> k.real() >> k.imag() >> s.real() >> s.imag();\n        \n                if(isInTriangle(p, k) ^ isInTriangle(p, s))\n                {\n                        cout << \"OK\" << endl;\n                }\n                else\n                {\n                        cout << \"NG\" << endl;\n                }\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct Vec2d{\n  double x,y;\n};\n\ndouble cross(Vec2d &A, Vec2d &B){\n  return A.x*B.y - A.y*B.x;\n}\n\nint main(void){\n\tint n;cin>>n;\n  while(n--){\n  \tdouble x1,y1,x2,y2,x3,y3,xk,yk,xs,ys;\n  \tcin>>x1>>y1>>x2>>y2>>x3>>y3>>xk>>yk>>xs>>ys;\n    Vec2d AB,BC,CA,AK,BK,CK,AS,BS,CS;\n    AB.x = x2-x1; AB.y = y2-y1;\n    BC.x = x3-x2; BC.y = y3-y2;\n    CA.x = x1-x3; CA.y = y1-y3;\n    AK.x = xk-x1; AK.y = yk-y1;\n    BK.x = xk-x2; BK.y = yk-y2;\n    CK.x = xk-x3; CK.y = yk-y3;\n    AS.x = xs-x1; AS.y = ys-y1;\n    BS.x = xs-x2; BS.y = ys-y2;\n    CS.x = xs-x3; CS.y = ys-y3;\n    bool k=true,s=true;\n    if(cross(AB,AK)>0.0 && cross(BC,BK)>0.0 && cross(CA,CK)>0.0)\n    k=false;\n    else if(cross(AB,AK)<0.0 && cross(BC,BK)<0.0 && cross(CA,CK)<0.0)\n    k=false;\n    else ;\n    if(cross(AB,AS)>0.0 && cross(BC,BS)>0.0 && cross(CA,CS)>0.0)\n    s=false;\n    else if(cross(AB,AS)<0.0 && cross(BC,BS)<0.0 && cross(CA,CS)<0.0)\n    s=false;\n    else ;\n    \n    if(s!=k) cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint range(double p,double q,double r){\n  return (q<r?q:r)<p&&p<(q<r?r:q);\n}\nint rangea(double p,double q,double r){\n  if(q*r<0&&fabs(q)+fabs(r)>M_PI){\n    p+=2*M_PI*(p<0);\n    q+=2*M_PI*(q<0);\n    r+=2*M_PI*(r<0);\n  }\n  return range(p,q,r);\n}\nint pit(int x0,int y0,int x1,int y1,int x2,int y2,int xp,int yp){\n  if(rangea(atan2(y0-yp,x0-xp),atan2(y0-y1,x0-x1),atan2(y0-y2,x0-x2)))\n    if(rangea(atan2(y1-yp,x1-xp),atan2(y1-y0,x1-x0),atan2(y1-y2,x1-x2)))\n      return 1;\n  return 0;\n}\nint main(){\n  int i;\n  int n,x0,x1,x2,y0,y1,y2,xp,yp,xq,yq;\n  vector<int> b;\n  cin>>n;\n  b.reserve(n);\n  for(i=0;i<n;i++){\n    cin>>x0>>y0>>x1>>y1>>x2>>y2>>xp>>yp>>xq>>yq;\n    if(pit(x0,y0,x1,y1,x2,y2,xp,yp)^pit(x0,y0,x1,y1,x2,y2,xq,yq))\n      b[i]=1;\n    else\n      b[i]=0;\n  }\n  for(i=0;i<n;i++){\n    if(b[i])\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\nbool is_inpolygon(const vector<P> &p, const P &q){\n    int n = p.size(); vector<D> c(n);\n    REP(i,n) c[i] = outprd(p[(i+1)%n]-p[i],q-p[i]);\n    D sig = sign(c[0]);\n    FROMTO(i,1,n) if(sig != sign(c[i])) return false;\n    return true;\n}\n\nstring solve(int xp1, int yp1, int xp2, int yp2, int xp3, int yp3, int xk, int yk, int xs, int ys){\n    vector<P> p;\n    p.pb(P(xp1,yp1)); p.pb(P(xp2,yp2)); p.pb(P(xp3,yp3));\n    pr(polygon_S(p));\n    pr(triangle_S(p[0],p[1],p[2]));\n    if(is_inpolygon(p,P(xk,yk)) != is_inpolygon(p,P(xs,ys))) return \"OK\";\n    return \"NG\";\n}\n\nint main(){\n    int n;\n    cin >> n;\n    int xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n    while(cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys){\n        cout << solve(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint crs(int x1, int y1, int x2, int y2) {\n    return (0 < x1 * y2 - y1 * x2 ? 1 : -1);\n}\n\nint main() {\n    int n,xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n    cin >> n;\n    for (int i=0; i<n; ++i) {\n        cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n        int t1 = 0;\n        t1 += crs(xp2 - xp1, yp2 - yp1, xk - xp1, yk - yp1);\n        t1 += crs(xp3 - xp2, yp3 - yp2, xk - xp2, yk - yp2);\n        t1 += crs(xp1 - xp3, yp1 - yp3, xk - xp3, yk - yp3);\n        int t2 = 0;\n        t2 += crs(xp2 - xp1, yp2 - yp1, xs - xp1, ys - yp1);\n        t2 += crs(xp3 - xp2, yp3 - yp2, xs - xp2, ys - yp2);\n        t2 += crs(xp1 - xp3, yp1 - yp3, xs - xp3, ys - yp3);\n        if ((abs(t1) == 3 && abs(t2) != 3) ||\n            (abs(t1) != 3 && abs(t2) == 3)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) {\n\t\treturn 0;\n\t}\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\nbool cmp_x(const P& p, const P& q) {\n\tif (p.x != q.x) {\n\t\treturn p.x < q.x;\n\t}\n\treturn p.y < q.y;\n}\n\nvector<P> convex_hull(P* ps, int n) {\n\tsort(ps, ps + n, cmp_x);\n\tint k = 0;\n\tvector<P> qs(n * 2);\n\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (k > 1 && (qs[k-1] - qs[k-2]).det(ps[i] - qs[k-1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tfor (int i = n-2, t = k; i >= 0; i--) {\n\t\twhile (k > t && (qs[k-1] - qs[k-2]).det(ps[i] - qs[k-1]) <= 0) {\n\t\t\tk--;\n\t\t}\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\nP ps[10];\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tP pp, qq;\n\t\tP psp[3];\n\t\tcin >> psp[0].x >> psp[0].y >> psp[1].x >> psp[1].y >> psp[2].x >> psp[2].y >> pp.x >> pp.y >> qq.x >> qq.y;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tps[j] = psp[j];\n\t\t}\n\t\tps[3] = pp;\n\t\tvector<P> qs = convex_hull(ps, 4);\n\t\tbool hantei;\n\t\tif (qs.size() == 4) {\n\t\t\thantei = false;\n\t\t} else {\n\t\t\thantei = true;\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tif (qs[j].x == pp.x && qs[j].y == pp.y) {\n\t\t\t\t\thantei = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tps[j] = psp[j];\n\t\t}\n\t\tps[3] = qq;\n\t\tqs = convex_hull(ps, 4);\n\t\tbool hantei2;\n\t\tif (qs.size() == 4) {\n\t\t\thantei2 = false;\n\t\t} else {\n\t\t\thantei2 = true;\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tif (qs[j].x == qq.x && qs[j].y == qq.y) {\n\t\t\t\t\thantei2 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hantei == hantei2) {\n\t\t\tcout << \"NG\" << endl;\n\t\t} else {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    P p[3];\n    REP(i,3) {\n      int x,y;\n      cin >> x >> y;\n      p[i] = P(x,y);\n    }\n    L l[3];\n    REP(i,3)\n    l[i] = L(p[i],p[(i+1)%3]);\n    int xk,yk,xs,ys;\n    cin >> xk >> yk >> xs >> ys;\n\n    P pk(xk,yk), ps(xs,ys);\n    L ll(pk,ps);\n    int c = 0;\n    REP(i,3) {\n      if (intersectSS(l[i],ll))\n        c++;\n    }\n    if (c == 1) cout << \"OK\";\n    else cout << \"NG\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\ntypedef vector<P> L;\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP ps[4];\nL l;\n\nbool solve(){\n    int c=0;\n    rep(i,3){\n        L m{ps[i],ps[i+1]};\n        if(intersectSS(l,m))c++;\n    }\n    return c==1;\n}\n\nint main(){\n    int n;cin>>n;\n    rep(_,n){\n        rep(i,3){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[3]=ps[0];\n        double a,b,c,d;\n        cin>>a>>b>>c>>d;\n        l={P(a,b),P(c,d)};\n        cout << (solve()?\"OK\":\"NG\")<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#define EPS 1e-10\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nclass Point\n{\n  public:\n  double x,y;\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4)\n{\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool isIntersect(Segment s1,Segment s2)\n{\nreturn isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  while(N-- > 0)\n    {\n      vector<Point> T(3);\n      for(int i=0;i<3;i++)\n\t  cin >> T[i].x >> T[i].y;\n      Segment s;\n      cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n      int cnt = 0;\n      if(isIntersect(Segment(T[0],T[1]),s))cnt++;\n      if(isIntersect(Segment(T[1],T[2]),s))cnt++;\n      if(isIntersect(Segment(T[2],T[0]),s))cnt++;\n      if(cnt == 1)\n\tcout << \"OK\" << endl;\n      else\n\tcout << \"NG\" << endl;\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        //入力を多少簡略化\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\ndouble square_calc(double x1, double y1, double x2, double y2, double x3, double y3)\n{\n\tdouble square = 0;\n\tdouble a = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n\tdouble b = sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));\n\tdouble c = sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n\tdouble s = (a + b + c) / 2;\n\treturn(sqrt(s * (s - a ) * (s - b) * (s - c)));\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tdouble xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tdouble square = square_calc(xp1, yp1, xp2, yp2, xp3, yp3);\n\t\tdouble square1 = square_calc(xk, yk, xp1, yp1, xp2, yp2) + square_calc(xk, yk, xp1, yp1, xp3, yp3) + square_calc(xk, yk, xp2, yp2, xp3, yp3);\n\t\tdouble square2 = square_calc(xs, ys, xp1, yp1, xp2, yp2) + square_calc(xs, ys, xp1, yp1, xp3, yp3) + square_calc(xs, ys, xp2, yp2, xp3, yp3);\n\t\tif(fabs(square - square1) <= 1e-6 && fabs(square - square2) >= 1e-6 ||\n\t\t   fabs(square - square1) >= 1e-6 && fabs(square - square2) <= 1e-6)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\nvector<P> tri(3);\nvector<P> aa(2);\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\nint check(P r){\n\tP a=tri[0]-tri[1],ar=r-tri[0];\n\tP b=tri[1]-tri[2],br=r-tri[1];\n\tP c=tri[2]-tri[0],cr=r-tri[2];\n\tdouble A=dot(ar,a),B=dot(br,b),C=dot(cr,c);\n\tif(A>EPS&&B>EPS&&C>EPS) return 1;\n\tif(A<-EPS&&B<-EPS&&C<-EPS) return 1;\n\treturn -1;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,3){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\ttri[j]=P(a,b);\n\t\t}\n\t\trep(j,2){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\taa[j]=P(a,b);\t\n\t\t}\n\t\tif(check(aa[0])*(check(aa[1]))<-EPS){\n\t\t\tcout<<\"OK\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\\n\";\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.1415926535\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    int xp[3],yp[3],xm[2],ym[2];\n    rep(i,3)cin>>xp[i]>>yp[i];\n\n    rep(i,2)cin>>xm[i]>>ym[i];\n\n    bool fe[2];\n    fe[0]=fe[1]=true;\n\n    rep(i,3){\n      int nx1=xp[(i+1)%3]-xp[i],ny1=yp[(i+1)%3]-yp[i];\n      int nx2=xp[(i+2)%3]-xp[i],ny2=yp[(i+2)%3]-yp[i];\n      double nx1ab=sqrt(nx1*nx1+ny1*ny1),nx2ab=sqrt(nx2*nx2+ny2*ny2);\n      double ang=(1.0*(nx1*nx2+ny1*ny2)/nx1ab/nx2ab);\n      //cout<<\"ang \"<<ang;\n      rep(j,2){\n\tint nxm=xm[j]-xp[i],nym=ym[j]-yp[i];\n\tdouble nxmab=sqrt(nxm*nxm+nym*nym);\n\tdouble nang=(1.0*(nxm*nx1+nym*ny1)/nxmab/nx1ab);\n\t//cout<<\" \"<<nang<<\" \";\n\tif(nang<ang)fe[j]=false;\n\tnang=(1.0*(nxm*nx2+nym*ny2)/nxmab/nx2ab);\n\tif(nang<ang)fe[j]=false;\n\t//cout<<nang<<endl;\n      }\n    }\n    //cout<<fe[0]<<fe[1];\n    if(fe[0]==fe[1])cout<<\"NG\";\n    else cout<<\"OK\";\n    cout<<endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Point\n{\n\tPoint(int x, int y):x(x),y(y),z(0){}\n\tPoint():x(0),y(0),z(0){}\n\tint x,y,z;\n};\ninline bool isRight( Point &p, Point &a, Point &b ){\n\treturn ( (b.x-a.x)*(p.y-a.y) - (b.y-a.y)*(p.x-a.x) ) > 0;\n}\nbool isInside( Point &p, vector<Point> &vp ){\n\tfor(unsigned int i = 1; i < vp.size(); ++i){\n\t\tif( !isRight( p, vp[i-1], vp[i] ) )\n\t\t\treturn false;\n\t}\n\treturn isRight( p, vp[vp.size()-1], vp[0] );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int X = 0; X < n; ++X ){\n\t\tPoint A, B, C, ken, ori;\n\t\tbool  bKenInside = false, bOriInside = false;\n\t\tvector<Point> triangle;\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> ken.x >> ken.y >> ori.x >> ori.y;\n\t\ttriangle.push_back(A);triangle.push_back(B);triangle.push_back(C);\n\n\t\tbKenInside = isInside( ken, triangle );\n\t\tbOriInside = isInside( ori, triangle );\n\t\tif( bKenInside ^ bOriInside )\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\ndouble heron(Po a,Po b,Po c){\n  double l1,l2,l3,s;\n  l1 = abs(a-b);\n  l2 = abs(b-c);\n  l3 = abs(c-a);\n  s = (l1+l2+l3)/2;\n  return sqrt(s*(s-l1)*(s-l2)*(s-l3));\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( heron(a,b,x) + heron(b,c,x) + heron(c,a,x) > heron(a,b,c) +EPS)return false;\n  else return true;\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    /*\n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    */\n    //if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong it(long p1x, long p1y,long p2x, long p2y,long p3x, long p3y,long p4x, long p4y){\nlong k=-1,s=-1;\nif((p2x-p1x)*(p3y-p1y)<(p2y-p1y)*(p3x-p1x))k=1;\nif((p2x-p1x)*(p4y-p1y)<(p2y-p1y)*(p4x-p1x))k=1;\nreturn k*s;\n}\nint main(){\nlong n,k,i,s,xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\ncin>>n;\nfor(i=0;i<n;i++){\ncin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\nk=-1;\nif(it(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk)<0)k=1;\nif(it(xp2,yp2,xp3,yp3,xp1,yp1,xk,yk)<0)k=1;\nif(it(xp3,yp3,xp1,yp1,xp2,yp2,xk,yk)<0)k=1;\ns=-1;\nif(it(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys)<0)s=1;\nif(it(xp2,yp2,xp3,yp3,xp1,yp1,xs,ys)<0)s=1;\nif(it(xp3,yp3,xp1,yp1,xp2,yp2,xs,ys)<0)s=1;\nif(k*s>0)cout<<\"NG\"<<endl;else cout<<\"OK\"<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nll const inf = 1<<28;\ndouble const pi = acos(-1);\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){}\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP ps[4];\nL l;\n\nbool solve(){\n    int c=0;\n    rep(i,3){\n        L m(ps[i],ps[i+1]);\n        if(intersectSS(l,m))c++;\n    }\n    return c==1;\n}\n\nint main(){\n    int n;cin>>n;\n    rep(_,n){\n        rep(i,3){\n            double x,y;cin>>x>>y;\n            ps[i]=P(x,y);\n        }\n        ps[3]=ps[0];\n        double a,b,c,d;\n        cin>>a>>b>>c>>d;\n        l={P(a,b),P(c,d)};\n        cout << (solve()?\"OK\":\"NG\")<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i]-c.c, B = u[(i+1)%u.size()]-c.c;\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        Point A, B, C, p, q;\n        cin >> A >> B >> C >> p >> q;\n        Polygon X{A, B, C};\n        if(contains(X, p) != contains(X, q)) puts(\"OK\");\n        else puts(\"NG\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\n\n#define EPS (1e-10)\ntypedef complex<double> Po;\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  else return true;\n}\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n\n    if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=(Crosspoint(pq,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(qr,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(rp,ks)&&Crosspoint(ks,pq));\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(point a1,point a2,point b1,point b2) {\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(point a1,point a2,point b1,point b2) {\n    return dot(a1-a2,b1-b2) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool is_parallel(point a1,point a2,point b1,point b2) {\n    return abs(cross(a2-a1,b2-b1)) < EPS;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(point a1,point a2,point b1,point b2) {\n    return not is_parallel(a1,a2,b1,b2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(point a1,point a2,point b1,point b2) {\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n    return abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n    if(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n    if(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n    return dist_line_and_point(a1,a2,b);\n}\n\n\n// 円と線分の交差判定\nbool is_cross_linesegment_and_circle(point c,double r,point a1,point a2){\n    return (dist_linesegment_and_point(a1,a2,c) < r+EPS and\n            (r < abs(c-a1) + EPS or r < abs(c-a2) + EPS));\n}\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\n// 円が多角形の中にはいっているか\nbool is_inner_point_vertex(vector<point> ps,point a){\n    int cc = ccw(ps[0],ps[1],a);\n    if(not(cc == 1 or cc == -1)) return false;\n    for(int i=0;i<ps.size();i++){\n        if(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n    }\n    return true;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    for(int test=0;test<N;test++){\n        vector<point> triangle(3);\n        for(int i=0;i<3;i++){\n            cin >> triangle[i].real() >> triangle[i].imag();\n        }\n        point a,b;\n        cin >> a.real() >> a.imag() >> b.real() >> b.imag();\n\n        bool ok = false;\n        bool is_a_inner = is_inner_point_vertex(triangle,a);\n        bool is_b_inner = is_inner_point_vertex(triangle,b);\n\n        if(is_a_inner xor is_b_inner){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\n\nsigned main(){\n  int t;\n  cin>>t;\n  while(t--){\n    Polygon p(3);\n    for(int i=0;i<3;i++) cin>>p[i];\n    p=andrewScan(p);\n    Point a,b;\n    cin>>a>>b;\n    if((contains(p,a)==2)^(contains(p,b)==2)) cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=INT_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0,cnt2=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i])){\n      cnt1++;\n      continue;\n    }\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt2++;\n  }\n  return ((cnt1/2)+cnt2)%2;\n}\n\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nbool line(int x1, int y1, int x2, int y2, int x, int y){\n\treturn (x2 - x1) * (y - y1) > (y2 - y1) * (x - x1);\n}\n\nbool triangle(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y){\n\treturn\tline(x1, y1, x2, y2, x, y) == line(x1, y1, x2, y2, x3, y3) &&\n\t\t\tline(x2, y2, x3, y3, x, y) == line(x2, y2, x3, y3, x1, y1) &&\n\t\t\tline(x3, y3, x1, y1, x, y) == line(x3, y3, x1, y1, x2, y2);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i){\n\t\tint x1, y1, x2, y2, x3, y3, ax, ay, bx, by;\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &ax, &ay, &bx, &by);\n\t\tif(triangle(x1, y1, x2, y2, x3, y3, ax, ay) != triangle(x1, y1, x2, y2, x3, y3, bx, by)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        REP(x, v.size()) { cout << v[x] << (x == v.size() - 1 ? \"\\n\" : \" \"); } \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<double> VD;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst ll LINF = 1e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n// Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n    Point operator*(double k) { return Point(x * k, y * k); }\n    Point operator/(double k) { return Point(x / k, y / k); }\n    double norm() { return x * x + y * y; }\n    double abs() { return sqrt(norm()); }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n        // grid-point only\n        // return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n    }\n\n    bool operator==(const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\nstruct EndPoint {\n    Point p;\n    int seg, st;\n    EndPoint() {}\n    EndPoint(Point p, int seg, int st) : p(p), seg(seg), st(st) {}\n    bool operator<(const EndPoint &ep) const {\n        if(p.y == ep.p.y) return st < ep.st;\n        return p.y < ep.p.y;\n    }\n};\n\nistream &operator>>(istream &is, Point &p) {\n    is >> p.x >> p.y;\n    return is;\n}\n\nostream &operator<<(ostream &os, Point p) {\n    os << fixed << setprecision(12) << p.x << \" \" << p.y;\n    return os;\n}\n\nbool sort_x(Point a, Point b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\n\nbool sort_y(Point a, Point b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator>>(istream &is, Polygon &p) {\n    for(int i = 0; i < (int)p.size(); i++) is >> p[i];\n    return is;\n}\n\nstruct Segment {\n    Point p1, p2;\n    Segment() {}\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\nistream &operator>>(istream &is, Segment &s) {\n    is >> s.p1 >> s.p2;\n    return is;\n}\n\nstruct Circle {\n    Point c;\n    double r;\n    Circle() {}\n    Circle(Point c, double r) : c(c), r(r) {}\n};\n\nistream &operator>>(istream &is, Circle &c) {\n    is >> c.c >> c.r;\n    return is;\n}\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nPoint orth(Point p) { return Point(-p.y, p.x); }\n\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n    return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nint ccw(Point p0, Point p1, Point p2);\nbool intersectSS(Point p1, Point p2, Point p3, Point p4);\nbool intersectSS(Segment s1, Segment s2);\nbool intersectPS(Polygon p, Segment l);\nint intersectCC(Circle c1, Circle c2);\nbool intersectSC(Segment s, Circle c);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistanceSS(Segment s1, Segment s2);\nPoint getCrossPointSS(Segment s1, Segment s2);\nPoint getCrossPointLL(Line l1, Line l2);\nPolygon getCrossPointCL(Circle c, Line l);\nPolygon getCrossPointCC(Circle c1, Circle c2);\nint contains(Polygon g, Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p, Line l);\nLine bisector(Point p1, Point p2);\nVector translate(Vector v, double theta);\nvector<Line> corner(Line l1, Line l2);\nvector<vector<int>> segmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS) return CCW_COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS) return CCW_CLOCKWISE;\n    if(dot(a, b) < -EPS) return CCW_ONLINE_BACK;\n    if(a.norm() < b.norm()) return CCW_ONLINE_FRONT;\n    return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersectSS(Segment s1, Segment s2) {\n    return intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nbool intersectPS(Polygon p, Segment l) {\n    int n = p.size();\n    for(int i = 0; i < n; i++)\n        if(intersectSS(Segment(p[i], p[(i + 1) % n]), l)) return 1;\n    return 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n    if(c1.r < c2.r) swap(c1, c2);\n    double d = abs(c1.c - c2.c);\n    double r = c1.r + c2.r;\n    if(equals(d, r)) return ICC_CIRCUMSCRIBE;\n    if(d > r) return ICC_SEPERATE;\n    if(equals(d + c2.r, c1.r)) return ICC_INSCRIBE;\n    if(d + c2.r < c1.r) return ICC_CONTAIN;\n    return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s, Circle c) { return getDistanceSP(s, c.c) <= c.r; }\n\nint intersectCS(Circle c, Segment s) {\n    if(norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n    double d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS))\n        return 1;\n    Point h = project(s, c.c);\n    if(dot(s.p1 - h, s.p2 - h) < 0) return 2;\n    return 0;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n    if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n    if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n    if(intersectSS(s1, s2)) return 0.0;\n    return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n               min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n    for(int k = 0; k < 2; k++) {\n        if(getDistanceSP(s1, s2.p1) < EPS) return s2.p1;\n        if(getDistanceSP(s1, s2.p2) < EPS) return s2.p2;\n        swap(s1, s2);\n    }\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n    double a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n    double b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n    if(abs(a) < EPS && abs(b) < EPS) return l2.p1;\n    return l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPolygon getCrossPointCL(Circle c, Line l) {\n    Polygon ps;\n    Point pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    if(equals(getDistanceLP(l, c.c), c.r)) {\n        ps.emplace_back(pr);\n        return ps;\n    }\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    ps.emplace_back(pr + e * base);\n    ps.emplace_back(pr - e * base);\n    return ps;\n}\n\nPolygon getCrossPointCS(Circle c, Segment s) {\n    Line l(s);\n    Polygon res = getCrossPointCL(c, l);\n    if(intersectCS(c, s) == 2) return res;\n    if(res.size() > 1u) {\n        if(dot(l.p1 - res[0], l.p2 - res[0]) > 0) swap(res[0], res[1]);\n        res.pop_back();\n    }\n    return res;\n}\n\nPolygon getCrossPointCC(Circle c1, Circle c2) {\n    Polygon p(2);\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    p[0] = c1.c + polar(c1.r, t + a);\n    p[1] = c1.c + polar(c1.r, t - a);\n    return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g, Point p) {\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++) {\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x ? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s) {\n    Polygon u, l;\n    if(s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size() - 1]);\n    l.push_back(s[s.size() - 2]);\n    for(int i = 2; i < (int)s.size(); i++) {\n        for(int n = u.size();\n            n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CCW_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    for(int i = s.size() - 3; i >= 0; i--) {\n        for(int n = l.size();\n            n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CCW_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(), l.end());\n    for(int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n    return l;\n}\n\nPolygon convex_hull(Polygon ps) {\n    int n = ps.size();\n    sort(ps.begin(), ps.end(), sort_y);\n    int k = 0;\n    Polygon qs(n * 2);\n    for(int i = 0; i < n; i++) {\n        while(k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < 0) k--;\n        qs[k++] = ps[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; i--) {\n        while(k > t && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) < 0) k--;\n        qs[k++] = ps[i];\n    }\n    qs.resize(k - 1);\n    return qs;\n}\n\ndouble diameter(Polygon s) {\n    Polygon p = s;\n    int n = p.size();\n    if(n == 2) return abs(p[0] - p[1]);\n    int i = 0, j = 0;\n    for(int k = 0; k < n; k++) {\n        if(p[i] < p[k]) i = k;\n        if(!(p[j] < p[k])) j = k;\n    }\n    double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {\n        res = max(res, abs(p[i] - p[j]));\n        if(cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0) {\n            i = (i + 1) % n;\n        } else {\n            j = (j + 1) % n;\n        }\n    }\n    return res;\n}\n\nbool isConvex(Polygon p) {\n    bool f = 1;\n    int n = p.size();\n    for(int i = 0; i < n; i++) {\n        int t = ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]);\n        f &= t != CCW_CLOCKWISE;\n    }\n    return f;\n}\n\ndouble area(Polygon s) {\n    double res = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        res += cross(s[i], s[(i + 1) % s.size()]) / 2.0;\n    }\n    return res;\n}\n\ndouble area(Circle c1, Circle c2) {\n    double d = abs(c1.c - c2.c);\n    if(c1.r + c2.r <= d + EPS) return 0;\n    if(d <= abs(c1.r - c2.r)) {\n        double r = min(c1.r, c2.r);\n        return PI * r * r;\n    }\n    double rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    double th = acos(rc / c1.r);\n    double ph = acos((d - rc) / c2.r);\n    return c1.r * c1.r * th + c2.r * c2.r * ph - d * c1.r * sin(th);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    for(int i = 0; i < (int)p.size(); i++) {\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if(ccw(l.p1, l.p2, a) != -1) q.push_back(a);\n        if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n            q.push_back(getCrossPointLL(Line(a, b), l));\n    }\n    return q;\n}\n\nLine bisector(Point p1, Point p2) {\n    Circle c1 = Circle(p1, abs(p1 - p2)), c2 = Circle(p2, abs(p1 - p2));\n    Polygon p = getCrossPointCC(c1, c2);\n    if(cross(p2 - p1, p[0] - p1) > 0) swap(p[0], p[1]);\n    return Line(p[0], p[1]);\n}\n\nVector translate(Vector v, double theta) {\n    Vector res;\n    res.x = cos(theta) * v.x - sin(theta) * v.y;\n    res.y = sin(theta) * v.x + cos(theta) * v.y;\n    return res;\n}\n\nvector<Line> corner(Line l1, Line l2) {\n    vector<Line> res;\n    if(isParallel(l1, l2)) {\n        double d = getDistanceLP(l1, l2.p1) / 2.0;\n        Vector v1 = l1.p2 - l1.p1;\n        v1 = v1 / v1.abs() * d;\n        Point p = l2.p1 + translate(v1, 90.0 * (PI / 180.0));\n        double d1 = getDistanceLP(l1, p);\n        double d2 = getDistanceLP(l2, p);\n        if(abs(d1 - d2) > d) {\n            p = l2.p1 + translate(v1, -90.0 * (PI / 180.0));\n        }\n        res.push_back(Line(p, p + v1));\n    } else {\n        Point p = getCrossPointLL(l1, l2);\n        Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n        v1 = v1 / v1.abs();\n        v2 = v2 / v2.abs();\n        res.push_back(Line(p, p + (v1 + v2)));\n        res.push_back(Line(p, p + translate(v1 + v2, 90.0 * (PI / 180.0))));\n    }\n    return res;\n}\n\nPolygon tangent(Circle c1, Point p2) {\n    Circle c2 = Circle(p2, sqrt(norm(c1.c - p2) - c1.r * c1.r));\n    Polygon p = getCrossPointCC(c1, c2);\n    sort(p.begin(), p.end());\n    return p;\n}\n\nvector<Line> tangent(Circle c1, Circle c2) {\n    vector<Line> ls;\n    if(c1.r < c2.r) swap(c1, c2);\n    double g = norm(c1.c - c2.c);\n    if(equals(g, 0)) return ls;\n    Point u = (c2.c - c1.c) / sqrt(g);\n    Point v = orth(u);\n    for(int s = 1; s >= -1; s -= 2) {\n        double h = (c1.r + s * c2.r) / sqrt(g);\n        if(equals(1 - h * h, 0)) {\n            ls.emplace_back(c1.c + u * c1.r, c1.c + (u + v) * c1.r);\n        } else if(1 - h * h > 0) {\n            Point uu = u * h, vv = v * sqrt(1 - h * h);\n            ls.emplace_back(c1.c + (uu + vv) * c1.r,\n                            c2.c - (uu + vv) * c2.r * s);\n            ls.emplace_back(c1.c + (uu - vv) * c1.r,\n                            c2.c - (uu - vv) * c2.r * s);\n        }\n    }\n\n    return ls;\n}\n\ndouble closest_pair(Polygon &a, int l = 0, int r = -1) {\n    if(r < 0) {\n        r = a.size();\n        sort(a.begin(), a.end(), sort_x);\n    }\n    if(r - l <= 1) return abs(a[0] - a[1]);\n    int m = (l + r) >> 1;\n    double x = a[m].x;\n    double d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, sort_y);\n\n    Polygon b;\n    for(int i = l; i < r; i++) {\n        if(fabs(a[i].x - x) >= d) continue;\n        for(int j = 0; j < (int)b.size(); j++) {\n            double dy = a[i].y - next(b.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(a[i] - *next(b.rbegin(), j)));\n        }\n        b.emplace_back(a[i]);\n    }\n    return d;\n}\n\nvector<vector<int>> segmentArrangement(vector<Segment> &ss, Polygon &ps) {\n    int n = ss.size();\n    for(int i = 0; i < n; i++) {\n        ps.emplace_back(ss[i].p1);\n        ps.emplace_back(ss[i].p2);\n        for(int j = i + 1; j < n; j++)\n            if(intersectSS(ss[i], ss[j]))\n                ps.emplace_back(getCrossPointSS(ss[i], ss[j]));\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    vector<vector<int>> G(ps.size());\n    for(int i = 0; i < n; i++) {\n        vector<pair<double, int>> ls;\n        for(int j = 0; j < (int)ps.size(); j++)\n            if(getDistanceSP(ss[i], ps[j]) < EPS)\n                ls.emplace_back(make_pair(norm(ss[i].p1 - ps[j]), j));\n\n        sort(ls.begin(), ls.end());\n        for(int j = 0; j + 1 < (int)ls.size(); j++) {\n            int a = ls[j].second, b = ls[j + 1].second;\n            G[a].emplace_back(b);\n            G[b].emplace_back(a);\n        }\n    }\n    for(auto &v : G) {\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n    }\n    return G;\n}\n\nint manhattanIntersection(vector<Segment> ss, const int INF) {\n    const int BTM = 0;\n    const int LFT = 1;\n    const int RGH = 2;\n    const int TOP = 3;\n\n    int n = ss.size();\n    vector<EndPoint> ep;\n    for(int i = 0; i < n; i++) {\n        if(ss[i].p1.y == ss[i].p2.y) {\n            if(ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n            ep.emplace_back(ss[i].p1, i, LFT);\n            ep.emplace_back(ss[i].p2, i, RGH);\n        } else {\n            if(ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n            ep.emplace_back(ss[i].p1, i, BTM);\n            ep.emplace_back(ss[i].p2, i, TOP);\n        }\n    }\n    sort(ep.begin(), ep.end());\n\n    set<int> bt;\n    bt.insert(INF);\n\n    int cnt = 0;\n    for(int i = 0; i < n * 2; i++) {\n        if(ep[i].st == TOP) {\n            bt.erase(ep[i].p.x);\n        } else if(ep[i].st == BTM) {\n            bt.emplace(ep[i].p.x);\n        } else if(ep[i].st == LFT) {\n            auto b = bt.lower_bound(ss[ep[i].seg].p1.x);\n            auto e = bt.upper_bound(ss[ep[i].seg].p2.x);\n            cnt += distance(b, e);\n        }\n    }\n\n    return cnt;\n}\n\ndouble area(Polygon ps, Circle c) {\n    if(ps.size() < 3u) return 0;\n    function<double(Circle, Point, Point)> dfs = [&](Circle c, Point a,\n                                                     Point b) {\n        Vector va = c.c - a, vb = c.c - b;\n        double f = cross(va, vb), res = 0;\n        if(equals(f, 0.0)) return res;\n        if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n        Vector d(dot(va, vb), cross(va, vb));\n        if(getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n            return c.r * c.r * atan2(d.y, d.x);\n        auto u = getCrossPointCS(c, Segment(a, b));\n        if(u.empty()) return res;\n        if(u.size() > 1u && dot(u[1] - u[0], a - u[0]) > 0) swap(u[0], u[1]);\n        u.emplace(u.begin(), a);\n        u.emplace_back(b);\n        for(int i = 1; i < (int)u.size(); i++) res += dfs(c, u[i - 1], u[i]);\n        return res;\n    };\n    double res = 0;\n    for(int i = 0; i < (int)ps.size(); i++)\n        res += dfs(c, ps[i], ps[(i + 1) % ps.size()]);\n    return res / 2;\n}\n\nsigned main() {\n    LCIN(N);\n    while(N--) {\n        DCIN(x1, y1, x2, y2, x3, y3, xk, yk, xs, ys);\n        ll cnt = 0;\n        cnt += intersectSS(Point(x1, y1), Point(x2, y2), Point(xk, yk),\n                           Point(xs, ys));\n        cnt += intersectSS(Point(x2, y2), Point(x3, y3), Point(xk, yk),\n                           Point(xs, ys));\n        cnt += intersectSS(Point(x3, y3), Point(x1, y1), Point(xk, yk),\n                           Point(xs, ys));\n        cout << (cnt == 1 ? \"OK\" : \"NG\") << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<complex>\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n  \tP a,b;\n    a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nint main(){\n\tint n; cin>>n;\n\tdouble x1,y1,x2,y2,x3,y3,xk,yk,xs,ys;\n\twhile(n--){\n\t\tcin>>x1>>y1>>x2>>y2>>x3>>y3>>xk>>yk>>xs>>ys;\n\t\tP pk(xk,yk),ps(xs,ys),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tG t;t.push_back(p1),t.push_back(p2),t.push_back(p3);\n\t\tbool f1=contains(t,pk),f2=contains(t,ps);\n\t\tcout<<(f1&&!f2||!f1&&f2?\"OK\":\"NG\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.para(l)){\n\tl.a.imag() += 1e-6;\n\tl.b.imag() += 1e-6;\n      }\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.para(l)){\n      l.a.imag() += 1e-6;\n      l.b.imag() += 1e-6;\n    }\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\n/////////////////////???Library???/////////////////////////\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a) { return Point(a * x, a * y); }\n\tPoint operator / (double a) { return Point(x / a, y / a); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x * x + y * y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\nstruct Segment { \n\tPoint p1, p2;\n\tSegment(Point p1, Point p2): p1(p1), p2(p2) {} \n};\ntypedef Segment Line;\n\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nbool isOrthogonal(Vector a, Vector b) {\n\treturn equals(dot(a, b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( a.norm() < b.norm() ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n// IN : 2, ON : 1, OUT : 0\nint contains(Polygon g, Point p)\n{\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i=0; i<n ;i++)\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] -p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n/////////////////////???Library???/////////////////////////\n\nvoid print_vi(vector<int> vi)\n{\n\trep(i, vi.size())\n\t{\n\t\tprintf(\"%d \", vi[i]);\n\t}\n}\n\nint n;\nint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\nsigned main()\n{\n\tcin >> n;\n\trep(i,n)\n\t{\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tPolygon p;\n\t\tp.push_back(Point(xp1, yp1));\n\t\tp.push_back(Point(xp2, yp2));\n\t\tp.push_back(Point(xp3, yp3));\n\t\tif (contains(p, Point(xk, yk)) != contains(p, Point(xs, ys)))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//二次元幾何ライブラリ\n#include <iostream>\n#include <complex>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define x(a) (a).real()\n#define y(a) (a).imag()\ntypedef long double D;\ntypedef bool B;\ntypedef complex<D> P;   //点\ntypedef complex<D> V;   //ベクトル\ntypedef pair<P,P>  L;   //直線\ntypedef pair<P,D>  C;   //円\ntypedef vector<P>  Pol; //多角形\n\n//変数名定義\nconst D INF = 1e100;\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ntemplate<class T> bool operator==(T a, T b){return abs(a - b )< EPS;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n\n// ベクトルaの絶対値を求める\n// D Length = abs(a);\n\n// 2点a,b間の距離を求める\n// D Distance = abs(a-b); \n\n// 内積 (Inner Product) : a・b = |a||b|cosθ\nD IP(V a, V b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (Exterior Product) : a×b = |a||b|sinθ\nD EP(V a, V b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> IP(a, b) = 0\nB IsVecular(P a1, P a2, P b1, P b2) {\n\treturn IP(a1-a2, b1-b2)==0.0;\n}\n\n// 2直線の平行判定 : a//b <=> EP(a, b) = 0\nB IsParallel(P a1, P a2, P b1, P b2) {\n\treturn EP(a1-a2, b1-b2)== 0.0;\n}\n\n\n// 点と直線の距離 (Distance of Point and Line)  //l1の構造 x座標 first<second y座標 first>second 右上 正 左下 負 一致の\nD  DPL(P p,L l){\n\tV v1=(p-l.first);\n\tV v2=(l.second-l.first);\n\treturn EP(v1,v2)/abs(v1);\n}\n\n// 三角形の領域判定 Teritory of Triangle 内部のみ\nB TT(P p1,P p2,P p3,P p){\n\tL l1,l2,l3;\n\tl1=make_pair(p2,p3);\n\tl2=make_pair(p3,p1);\n\tl3=make_pair(p1,p2);\n\n\tif(sig(DPL(p1,l1))!=sig(DPL(p,l1)))\n\t\treturn false;\n\telse if(sig(DPL(p2,l2))!=sig(DPL(p,l2)))\n\t\treturn false;\n\telse if(sig(DPL(p3,l3))!=sig(DPL(p,l3)))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n\n//変数名 = 型 代入したいもの\n//example : v1 = V(5.0,-3.0) p1=P(0.0,4.0)\nint main(void){\n\tint n;\n\tcin >>n; \n\trep(i,n){\n\t\tP point[5];\t\n\t\trep(j,5)\n\t\tcin >> point[j].real() >> point[j].imag() ;\n\t\tif (TT(point[0],point[1],point[2],point[3])==TT(point[0],point[1],point[2],point[4]))\n\t\t\tcout << \"NG\" << endl;\n\t\telse\n\t\t\tcout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n/*\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n*/\n// (B)\nenum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW) || (d2 == CW && d3 == CCW ) );\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.0143\", \"r\", stdin );\n\tint n;\n\tscanf (\"%d\", &n );\n\twhile (n-- ){\n\t\tpoint<double> tr[3], k, s;\n\t\trep (i, 3 ) scanf (\"%lf %lf\", &tr[i].x, &tr[i].y ); \n\t\tscanf (\"%lf %lf %lf %lf\", &k.x, &k.y, &s.x, &s.y );\n\t\t\n\t\tbool ok = true;\n\t\tif (   (cover (tr[0], tr[1], tr[2], k ) && cover(tr[0], tr[1], tr[2], s ) )\n\t\t\t|| (!cover (tr[0], tr[1], tr[2], k ) && !cover(tr[0], tr[1], tr[2], s ) ) ){\n\t\t\t\tok = false;\n\t\t} // end if\n\t\tif (ok ){\n\t\t\tprintf (\"OK\\n\" );\n\t\t}else{\n\t\t\tprintf (\"NG\\n\" );\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n\n#define EPS 1e-7\n\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\n\nbool contains(const polygon &plg, const point &pt){\n\tint cnt = 0;\n\tdouble y = imag(pt);\n\n\tfor(int i = 1; i < plg.size(); ++i){\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[i-1]);\n\t\tdouble tx = (dyi * real(plg[i-1]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[i-1]) < y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[i-1]) >= y){\n\t\t\tif( tx < real(pt) ) ++cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\n\nint main(){\n\tint n;\n\tint x, y;\n\tvector<point> tri(4);\n\t\n\tfor(scanf(\"%d\", &n); n--; ){\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\ttri[i] = point(x, y);\n\t\t}\n\t\ttri[3] = tri[0];\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tpoint pk(x, y);\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tpoint ps(x, y);\n\t\t\n\t\tif( contains(tri, pk) != contains(tri, ps) ){\n\t\t\tputs(\"OK\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <vector>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n\nusing namespace std;\n\nint cross_product( int x1, int y1, int x2, int y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\nint main( void )\n{\n\tint n;\n\t\n\twhile (cin >> n)\n\t{\n\t\tfor (int i=0; i < n; ++i)\n\t\t{\n\t\t\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3\n\t\t\t\t>> xk >> yk >> xs >> ys;\n\t\t\t\n\t\t\tint v1, v2, v3, v4, v5, v6;\n\t\t\n\t\t\tv1 = cross_product((x2-x1), (y2-y1), (xk-x1), (yk-y1));\n\t\t\tv2 = cross_product((x3-x2), (y3-y2), (xk-x2), (yk-y2));\n\t\t\tv3 = cross_product((x1-x3), (y1-y3), (xk-x3), (yk-y3));\n\t\t\n\t\t\tv4 = cross_product((x2-x1), (y2-y1), (xs-x1), (ys-y1));\n\t\t\tv5 = cross_product((x3-x2), (y3-y2), (xs-x2), (ys-y2));\n\t\t\tv6 = cross_product((x1-x3), (y1-y3), (xs-x3), (ys-y3));\n\t\t\n\t\t\tif (((v1 > 0) && (v2 > 0) && (v3 > 0) &&\n\t\t\t\t((v4 < 0) || (v5 < 0) || (v6 < 0))) ||\n\t\t\t\t((v4 > 0) && (v5 > 0) && (v6 > 0) &&\n\t\t\t\t((v1 < 0) || (v2 < 0) || (v3 < 0)))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n int inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=Crosspoint(pq,ks);\n    ans+=Crosspoint(qr,ks);\n    ans+=Crosspoint(rp,ks);\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\tif(i!=j && i!=k && j!=k)\n\t  if(ccw(p[i],p[j],p[k])==1){\n\t    segment temp;\n\t    temp.a=p[i];\n\t    temp.b=p[j];\n\t    seg.push_back(temp);\n\t    //seg.push_back(make_pair(p[i],p[j]));\n\t  }\n  return seg;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    seg=construct_edge(p,3);\n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef complex<double> P;\n\nint n;\ndouble x1,y1,x2,y2,x3,y3,x4,y4,x5,y5;\n\ndouble cr(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint naibu(P a,P b,P c,P p){\n\treturn cr(p-a,b-a)>0&&cr(p-b,c-b)>0&&cr(p-c,a-c)>0||cr(p-a,b-a)<0&&cr(p-b,c-b)<0&&cr(p-c,a-c)<0;\n}\n\nint main(){\n\tcin>>n;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4>>x5>>y5){\n\t\tP a=P(x1,y1),b=P(x2,y2),c=P(x3,y3),d=P(x4,y4),e=P(x5,y5);\n\t\tcout<<(naibu(a,b,c,d)^naibu(a,b,c,e)?\"OK\":\"NG\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 0143\n#include <iostream>\nusing namespace std;\n\nbool cross_p(int x1, int y1, int x2, int y2, int xp, int yp){\n\tif((x2-x1)*(yp-y1) < (y2-y1)*(xp-x1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\n\tfor(int i=0;i<n;i++){\n\t\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\t\tbool altair, vega;\n\n\t\tcin>>x1>>y1>>x2>>y2>>x3>>y3>>xk>>yk>>xs>>ys;\n\n\t\tif((cross_p(x1, y1, x2, y2, xk, yk) == cross_p(x2, y2, x3, y3, xk, yk)) && (cross_p(x2, y2, x3, y3, xk, yk) == cross_p(x3, y3, x1, y1, xk, yk)))\n\t\t\taltair = true;\n\t\telse\n\t\t\taltair = false;\n\n\t\tif((cross_p(x1, y1, x2, y2, xs, ys) == cross_p(x2, y2, x3, y3, xs, ys)) && (cross_p(x2, y2, x3, y3, xs, ys) == cross_p(x3, y3, x1, y1, xs, ys)))\n\t\t\tvega = true;\n\t\telse\n\t\t\tvega = false;\n\n\t\tif(altair != vega)\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=q.y=1000000000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t}\n     \n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x*C.y>0&&C.x+C.y<1;}main(){cin>>A.x;while(cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y){A-=C;B-=C;S-=C;G-=C;X(S)^X(G)?cout<<\"OK\\n\":cout<<\"NG\\n\";}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint hantei(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n\tdouble x,y,m,n,d;\n\tif (dx-cx!=0) m=(dy-cy)/(dx-cx);\n\tif (bx-ax!=0) n=(by-ay)/(bx-ax);\n\tif (ay==by) {\n\t\tif (cy==dy && cy==ay && ((ax>cx && ax<dx) || (ax<cx && ax>dx))) return 1;\n\t\tif (cx==dx && ((cx>ax && cx<bx) || (cx>bx && cx<ax)) && ((cy<ay && dy>ay) || (dy<ay && cy>ay))) return 1;\n        x=(ay-cy+m*cx)/m;\n        if ((x>ax && x<bx) || (x>bx && x<ax)) return 1;\n\t\treturn 0;\n\t}\n\tif (ax==bx) {\n        if (cx==dx && cx==ax && (ay>cy && ay<dy || ay<cy && ay>dy)) return 1;\n\t\tif (cy==dy && ((cy>ay && cy<by) || (cy>by && cy<ay)) && ((cx<ax && dx>ax) || (dx<ax && cx>ax))) return 1;\n        y=cy+m*(ax-cx);\n\t\tif ((y>ay && y<by) || (y>by && y<ay)) return 1;\n\t\treturn 0;\n\t}\n\tif (cy==dy) { x=(cy-ay+n*ax)/m;\tif ((x>cx && x<dx) || (x>dx && x<cx)) return 1; else return 0; }\n\tif (cx==dx) { y=ay+n*(cx-ax); cout << y;if ((y>cy && y<dy) || (y>dy && y<cy)) return 1; else return 0;}\n\tif (m==n) { d=(cy-ay)/(cx-ax); if ((d==m) && ((ax>cx && ax<dx) || (ax>dx && ax<cx))) return 1; else return 0; }\n    d=(ay-cy+m*cx-n*ax)/(m-n);\n\tif ((d>cx && d<dx) || (d>dx && d<cx)) return 1;\n\treturn 0;\n}\n\nint main() {\n\tint n,f;\n\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\tcin >> n;\n\tfor (;n>0;n--) {\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        f=hantei(xp1,yp1,xp2,yp2,xk,yk,xs,ys)+hantei(xp2,yp2,xp3,yp3,xk,yk,xs,ys)+hantei(xp1,yp1,xp3,yp3,xk,yk,xs,ys);\n\t\tif (f==1) cout << \"OK\"; else cout << \"NG\";\n\t\tcout << endl;\n\t}\nreturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\ntypedef struct POINT_tag{\n  int x, y;\n}POINT_t;\n\ntypedef struct LINE_tag{\n  POINT_t a, b;\n}LINE_t;\n\ntypedef struct TRIANGLE_tag{\n  POINT_t a, b, c;\n}TRIANGLE_t;\n\nint side(POINT_t *p, LINE_t *e){\n  POINT_t p1 = *p;\n  POINT_t p2 = e->a;\n  POINT_t p3 = e->b;\n\n  const int n = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);\n  if(n > 0) return 1;\n  else return -1;\n}\n\nint solve(POINT_t *p, TRIANGLE_t *t){\n  LINE_t ab, bc, ca;\n  ab.a = t->a; ab.b = t->b;\n  bc.a = t->b; bc.b = t->c;\n  ca.a = t->c; ca.b = t->a;\n  const int pab = side(p, &ab);\n  const int pbc = side(p, &bc);\n  const int pca = side(p, &ca);\n\n  if((0 < pab) && (0 < pbc) && (0 < pca)) return 1;\n  if((0 > pab) && (0 > pbc) && (0 > pca)) return 1;\n  return 0;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    TRIANGLE_t t;\n    POINT_t k, s;\n    scanf(\"%d%d%d%d%d%d%d%d%d%d\", &t.a.x, &t.a.y, &t.b.x, &t.b.y, &t.c.x, &t.c.y, &k.x, &k.y, &s.x, &s.y);\n    if(solve(&k, &t) != solve(&s, &t)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-12)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint x,y,x2,y2,x3,y3,xk,yk,xs,ys;\n\ndouble len(int xa, int ya,int xb,int yb){\n  return sqrt( (xa-xb)*(xa-xb) + (ya-yb)*(ya-yb) );\n}\n\ndouble flon(int xa,int ya, int xb, int yb ,int xc ,int yc){\n  double l1,l2,l3,s;\n  l1 = len(xa,ya,xb,yb);\n  l2 = len(xb,yb,xc,yc);\n  l3 = len(xc,yc,xa,ya);\n  s = (l1+l2+l3)/2;\n\n  return sqrt( s*(s-l1)*(s-l2)*(s-l3) );\n}\n\nbool interk(void){\n  if( fabs(flon(x,y,x2,y2,xk,yk) + flon(x,y,x3,y3,xk,yk) + flon(x2,y2,x3,y3,xk,yk) - flon(x,y,x2,y2,x3,y3) ) < 1e-10 )return true;\n  else return false;\n}\n\nbool inters(void){\n  if( fabs(flon(x,y,x2,y2,xs,ys) + flon(x,y,x3,y3,xs,ys) + flon(x2,y2,x3,y3,xs,ys) - flon(x,y,x2,y2,x3,y3) ) < 1e-10 )return true;\n  else return false;\n}\n\nint main(){\n  int n;\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> x >> y >> x2 >> y2 >> x3 >> y3 >> xk >> yk >> xs >> ys;\n\n    if( !interk() && inters() )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint hantei(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n\tdouble x,y,m,n,d;\n\tif (dx-cx!=0) m=(dy-cy)/(dx-cx);\n\tif (bx-ax!=0) n=(by-ay)/(bx-ax);\n\tif (ay==by) {\n\t\tif (cx==dx && ((cx>ax && cx<bx) || (cx>bx && cx<ax)) && ((cy<ay && dy>ay) || (dy<ay && cy>ay))) return 1;\n        x=(ay-cy+m*cx)/m;\n        if ((x>cx && x<dx) || (x>dx && x<cx)) return 1;\n\t\treturn 0;\n\t}\n\tif (ax==bx) {\n        if (cy==dy && ((cy>ay && cy<by) || (cy>by && cy<ay)) && ((cx<ax && dx>ax) || (dx<ax && cx>ax))) return 1;\n        y=cy+m*(ax-cx);\n\t\tif ((y>ay && y<by) || (y>by && y<ay)) return 1;\n\t\treturn 0;\n\t}\n\tif (cy==dy) { x=(cy-ay+n*ax)/n;\tif ((x>cx && x<dx) || (x>dx && x<cx)) return 1; else return 0; }\n\tif (cx==dx) { y=ay+n*(cx-ax); cout << y;if ((y>cy && y<dy) || (y>dy && y<cy)) return 1; else return 0;}\n\tif (m==n) return 0;\n    d=(ay-cy+m*cx-n*ax)/(m-n);\n\tif ((d>cx && d<dx) || (d>dx && d<cx)) return 1;\n\treturn 0;\n}\n\nint main() {\n\tint n,f;\n\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\tcin >> n;\n\tfor (;n>0;n--) {\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        f=hantei(xp1,yp1,xp2,yp2,xk,yk,xs,ys)+hantei(xp2,yp2,xp3,yp3,xk,yk,xs,ys)+hantei(xp1,yp1,xp3,yp3,xk,yk,xs,ys);\n\t\tif (f==1) cout << \"OK\"; else cout << \"NG\";\n\t\tcout << endl;\n\t}\nreturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-10)\n \nD dot(P a, P b)\n{\n    return real(conj(a) * b);\n}\n \nD cross(P a, P b)\n{\n    return imag(conj(a) * b);\n} \n \nint ccw(P p0, P p1, P p2)\n{\n    P a = p1 - p0;\n    P b = p2 - p0;\n  \n    if (cross(a,b) > EPS) return 1;\n    if (cross(a,b) < -EPS) return -1;\n    if (dot(a,b) < -EPS) return 2;\n    if (norm(a) < norm(b)) return -2;\n    return 0;\n}\n \nbool check(P p1, P p2, P p3, P p4)\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t    ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n  \nint main()\n{\n    int n;\n    P P[3], T[2];\n  \n    scanf(\"%d\", &n);\n    while (n--) {\n\tfor (int i = 0; i < 3; i++) {\n\t    scanf(\"%lf %lf\", &P[i].real(), &P[i].imag());\n\t}\n \n\tfor (int i = 0; i < 2; i++) {\n\t    scanf(\"%lf %lf\", &T[i].real(), &T[i].imag());\n\t}\n \n\tint cnt = 0; \n\tif (check(P[0], P[1], T[0], T[1])) {\n\t    cnt++;\n\t}   \n\tif (check(P[0], P[2], T[0], T[1])) {\n\t    cnt++;\n\t} \n\tif (check(P[1], P[2], T[0], T[1])) {\n\t    cnt++;\n\t} \n\tif (cnt % 2) {\n\t    puts(\"OK\");\n\t} else {\n\t    puts(\"NG\");\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return px == p.px && py == p.py; }\n\tbool operator!=(const Point& p) const { return px != p.px || py != p.py; }\n\tbool operator<(const Point& p) const { return px < p.px ? true : (px == p.px && py < p.py); }\n\tbool operator>(const Point& p) const { return px > p.px ? true : (px == p.px && py > p.py); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint n; Point a, b;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<Point> v(3);\n\t\tfor (int j = 0; j < 3; j++) cin >> v[j].px >> v[j].py;\n\t\tcin >> a.px >> a.py >> b.px >> b.py;\n\t\tif (contain(v, a) != contain(v, b)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(P a, P b){\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint main()\n{\n  int i;\n  int xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n  cin>>i;\n  for(;i--;)\n    {\n      cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n      P p1(xp1,yp1),p2(xp2,yp2),p3(xp3,yp3),k(xk,yk),s(xs,ys);\n\n      if((ccw(p1,p2,k)==ccw(p2,p3,k)&& ccw(p2,p3,k)==ccw(p3,p1,k))\n\t ^(ccw(p1,p2,s)==ccw(p2,p3,s)&& ccw(p2,p3,s)==ccw(p3,p1,s))\n\t )\n\tcout<<\"OK\"<<endl;\n      else\n\tcout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n\tint N;\n\tcin>>N;\n\tfor(;N--;)\n\t{\n\t\tPolygon P(3);\n\t\tfor(Point&p:P)cin>>p;\n\t\tP=convex_full(P);\n\t\tPoint s,t;\n\t\tcin>>s>>t;\n\t\tcout<<(contain(P,s)!=contain(P,t)?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_intersected_ls(point p1, point p2, point p3, point p4) {\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0)&&\n         (ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n  \n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌÏªÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tbool f=false;\n\tP tp=(p1+p2+p3);\n\ttp = P(tp.real()/3,tp.imag()/3);\n\tP ta=p1-tp;\n\tP tb=p2-tp;\n\tP tc=p3-tp;\n\tf = (cross(ta,tb)*cross(tb,tc)*cross(tc,ta))>0;\n\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\tif(f)\n\t\treturn (cross(a,b)*cross(b,c)*cross(c,a)>0);\n\telse\n\t\treturn (cross(a,b)*cross(b,c)*cross(c,a)<0);\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tcin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n\t\tP p1(xp1,yp1);\n\t\tP p2(xp2,yp2);\n\t\tP p3(xp3,yp3);\n\t\tP k(xk,yk);\n\t\tP s(xs,ys);\n\t\t// ¼ûÆàOp`ÌàÉ_ª éê\n\t\tif(isInTriangle(p1,p2,p3,k)&&isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t// ¼ûÆàOp`ÌOÉ_ª éê\n\t\telse if(!isInTriangle(p1,p2,p3,k)&&!isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"OK\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\ntypedef ld  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\n// 1: a,b,c??????????¨???¨?????????????????¶\n//-1: a,b,c???????¨???¨?????????????????¶\n// 2: c,a,b???????????´???????????¶\n//-2: a,b,c???????????´???????????¶\n// 0: a,c,b???????????´???????????¶\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.b - l.a) / norm(l.a - l.b);\n\treturn l.a + t * (l.b - l.a);\n}\n\n//???????±??????????????????????\nPoint reflect(const Line &l, const Point &p) {\n\tPoint pr = proj(l, p);\n\treturn pr * 2.l - p;\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\n\n\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) {\n\t\t\tif (isis_sp(s[i], p[j]))\n\t\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\t}\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\npair<vector<Point>, Graph> sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\tsort(crss.begin(), crss.end());\n\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\n\treturn make_pair(crss, segment_arrangement(s, crss));\n}\n\nGraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tconst int n = p.size(), m = c.size();\n\tGraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, 1, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tint x1, y1, x2, y2, x3, y3; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tint xk, yk, xs, ys; cin >> xk >> yk >> xs >> ys;\n\t\tPolygon poly{ Point(x1,y1),Point(x2,y2),Point(x3,y3) };\n\t\tPoint a(xk, yk);\n\t\tPoint b(xs, ys);\n\t\tint aa = is_in_Polygon(poly,a);\n\t\tint ab = is_in_Polygon(poly, b);\n\t\tif (aa == ab)cout << \"NG\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef complex<double> P;\n\nint n;\ndouble x1,Y1,x2,y2,x3,y3,x4,y4,x5,y5;\n\ndouble cr(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint naibu(P a,P b,P c,P p){\n\treturn cr(p-a,b-a)>0&&cr(p-b,c-b)>0&&cr(p-c,a-c)>0||cr(p-a,b-a)<0&&cr(p-b,c-b)<0&&cr(p-c,a-c)<0;\n}\n\nint main(){\n\tcin>>n;\n\twhile(cin>>x1>>Y1>>x2>>y2>>x3>>y3>>x4>>y4>>x5>>y5){\n\t\tP a=P(x1,Y1),b=P(x2,y2),c=P(x3,y3),d=P(x4,y4),e=P(x5,y5);\n\t\tcout<<(naibu(a,b,c,d)^naibu(a,b,c,e)?\"OK\":\"NG\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FST first\n#define SND second\n\n#define EPS (1e-5)\n\ntypedef complex<double> P;\ntypedef pair<P,P> SEG;\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isIntersectSS(SEG a, SEG b) {\n  return (cross(a.SND-a.FST, b.FST-a.FST) * cross(a.SND-a.FST, b.SND-a.FST) < EPS)\n    && (cross(b.SND-b.FST, a.FST-b.FST) * cross(b.SND-b.FST, a.SND-b.FST) < EPS);\n}\n\nint main() {\n  \n  int N; cin >> N;\n  \n  while(N--) {\n    P Wall[3];\n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      Wall[i] = P(x, y);\n    }\n    \n    double x, y;\n    cin >> x >> y; P enemy(x, y);\n    cin >> x >> y; P orihime(x, y);\n    SEG seg(enemy, orihime);\n    \n    int ok = 0;\n    for(int i=0; i<3; i++) {\n      ok += isIntersectSS(seg, SEG(Wall[i], Wall[(i+1)%3]));\n    }\n    \n    if(ok == 1) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NG\" << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint x,y,x2,y2,x3,y3,xk,yk,xs,ys;\n\ndouble len(int xa, int ya,int xb,int yb){\n  return sqrt( (xa-xb)*(xa-xb) + (ya-yb)*(ya-yb) );\n}\n\ndouble flon(int xa,int ya, int xb, int yb ,int xc ,int yc){\n  double l1,l2,l3,s;\n  l1 = len(xa,ya,xb,yb);\n  l2 = len(xb,yb,xc,yc);\n  l3 = len(xc,yc,xa,ya);\n  s = (l1+l2+l3)/2;\n\n  return sqrt( s*(s-l1)*(s-l2)*(s-l3) );\n}\n\nbool interk(void){\n  if( fabs(flon(x,y,x2,y2,xk,yk) + flon(x,y,x3,y3,xk,yk) + flon(x2,y2,x3,y3,xk,yk) - flon(x,y,x2,y2,x3,y3) ) < 1e-10 )return true;\n  else return false;\n}\n\nbool inters(void){\n  if( fabs(flon(x,y,x2,y2,xs,ys) + flon(x,y,x3,y3,xs,ys) + flon(x2,y2,x3,y3,xs,ys) - flon(x,y,x2,y2,x3,y3) ) < 1e-10 )return true;\n  else return false;\n}\n\nint main(){\n  int n;\n\n  cin >> n;\n  while(n){\n    n--;\n    cin >> x >> y >> x2 >> y2 >> x3 >> y3 >> xk >> yk >> xs >> ys;\n\n    if( interk() != inters() )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nstatic const double eps = 10e-6;\n\nclass intersect_triangle{\nprivate:\n\tdouble dst[3];\n\tdouble orig[3], dir[3];\n\tdouble vert0[3],vert1[3],vert2[3];\n\n\tdouble dot(double v1[3],double v2[3]){\n\t\treturn v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2];\n\t}\n\tvoid cross(double dest[3],double v1[3],double v2[3]){\n\t\tdest[0] = v1[1]*v2[2]-v1[2]*v2[1];\n\t\tdest[1] = v1[2]*v2[0]-v1[0]*v2[2];\n\t\tdest[2] = v1[0]*v2[1]-v1[1]*v2[0];\n\t}\n\n\tvoid sub(double dest[3],double v1[3], double v2[3]){\n\t\tdest[0] = v1[0]-v2[0];\n\t\tdest[1] = v1[1]-v2[1];\n\t\tdest[2] = v1[2]-v2[2];\n\t}\npublic:\n\tintersect_triangle(double xp1,double yp1,double xp2,double yp2,double xp3,double yp3,\n\t\tdouble xk,double yk){\n\t\tvert0[0] = xp1;\n\t\tvert0[1] = yp1;\n\t\tvert0[2] = 0;\n\n\t\tvert1[0] = xp2;\n\t\tvert1[1] = yp2;\n\t\tvert1[2] = 0;\n\n\t\tvert2[0] = xp3;\n\t\tvert2[1] = yp3;\n\t\tvert2[2] = 0;\n\n\t\torig[0] = xk;\n\t\torig[1] = yk;\n\t\torig[2] = -1;\n\n\t\tdst[0] = xk;\n\t\tdst[1] = yk;\n\t\tdst[2] = 1;\n\n\t\tdouble len = sqrt(pow(dst[0]-orig[0],2.0)+pow(dst[1]-orig[1],2.0)+pow(dst[2]-orig[2],2.0));\n\t\tdir[0] = (dst[0]-orig[0])/len;\n\t\tdir[1] = (dst[1]-orig[1])/len;\n\t\tdir[2] = (dst[2]-orig[2])/len;\n\t}\n\n\tbool is_intersect(){\n\t\tdouble edge1[3],edge2[3],tvec[3],pvec[3],qvec[3];\n\t\tdouble det,inv_det,t=0,v=0,u=0;\n\n\t\tsub(edge1,vert1,vert0);\n\t\tsub(edge2,vert2,vert0);\n\n\t\tcross(pvec,dir,edge2);\n\n\t\tdet=dot(edge1,pvec);\n\n\t\tif(det > -eps && det < eps) return false;\n\n\t\tinv_det = 1.0/det;\n\n\t\tsub(tvec,orig,vert0);\n\n\t\tu=dot(tvec,pvec)*inv_det;\n\t\tif(u < 0.0 || u > 1.0) return false;\n\n\t\tcross(qvec,tvec,edge1);\n\n\t\tv=dot(dir,qvec) * inv_det;\n\t\tif(v < 0.0 || u+v > 1.0) return false;\n\n\t\tt = dot(edge2,qvec) * inv_det;\n\n\t\treturn true;\n\n\t}\n};\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0;i<n;i++){\n\t\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n\t\t\t&xp1,&yp1,&xp2,&yp2,&xp3,&yp3,&xk,&yk,&xs,&ys);\n\t\tintersect_triangle inter_t1(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk);\n\t\tintersect_triangle inter_t2(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys);\n\t\tprintf(\"%s\\n\",(inter_t1.is_intersect() && inter_t2.is_intersect()) \n\t\t\t|| (!inter_t1.is_intersect() && !inter_t2.is_intersect())\n\t\t\t? \"NG\" : \"OK\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=(Crosspoint(pq,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(qr,ks)&&Crosspoint(ks,qr));\n    ans+=(Crosspoint(rp,ks)&&Crosspoint(ks,rp));\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\t//if (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> Poly;\n// struct Poly : public vector<Point>\n// {\n//     Poly() {}\n//     Poly(int n)\n//     {\n//         resize(n);\n//     }\n// };\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool is_on_line(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool is_on_seg(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -EPS_FOR_LIB\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -EPS_FOR_LIB)\n\t\t|| is_on_seg(seg1, seg2.first)\n\t\t|| is_on_seg(seg1, seg2.second)\n\t\t|| is_on_seg(seg2, seg1.first)\n\t\t|| is_on_seg(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"cross_point_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"cross_point_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n// 回転\nPoint rotate(const Point& p, gtype angle)\n{\n\tgtype c = cos(angle), s = sin(angle);\n\treturn Point(p.real() * c - p.imag() * s, p.real() * s + p.imag() * c);\n}\nPoint rotate(const Point& p, gtype angle, const Point& base)\n{\n\tPoint t = p - base;\n\treturn rotate(t, angle) + base;\n}\n\n// 点から直線に垂線を下ろした点\n// AOJ0081(by reflection)\nPoint projection(const Line& line, const Point& p)\n{\n\tPoint a = line.first - line.second;\n\tgtype t = dot(p - line.first, a) / norm(a);\n\treturn line.first + t * a;\n}\n\n// 線対称な点\n// AOJ0081\nPoint reflection(const Line& line, const Point& p)\n{\n\treturn p + ((gtype)2) * (projection(line, p) - p);\n}\n\n\n// 長方形\nstruct Rect\n{\n\tPoint low, high;\n\tRect(Point low, Point high)\n\t\t: low(low), high(high) { }\n\tRect() { }\n\n\tgtype x1() const { return low.real(); }\n\tgtype x2() const { return high.real(); }\n\tgtype y1() const { return low.imag(); }\n\tgtype y2() const { return high.imag(); }\n\n    Point top_left() const { return Point(x1(), y2()); }\n    Point bottom_left() const { return Point(x1(), y1()); }\n    Point bottom_right() const { return Point(x2(), y1()); }\n    Point top_right() const { return Point(x2(), y2()); }\n\n    Poly to_poly() const\n    {\n        Poly res;\n        res.push_back(top_left());\n        res.push_back(bottom_left());\n        res.push_back(bottom_right());\n        res.push_back(top_right());\n        return res;\n    }\n};\n// 境界交差はfalse\nbool intersect_rect_area(const Rect& a, const Rect& b)\n{\n\tbool x = a.low.real() < b.high.real() && a.high.real() > b.low.real();\n\tbool y = a.low.imag() < b.high.imag() && a.high.imag() > b.low.imag();\n\treturn x && y;\n}\n// allow segment\nbool intersect_rect(const Rect& a, const Rect& b)\n{\n\tbool x = !(a.low.real() > b.high.real()) && !(a.high.real() < b.low.real());\n\tbool y = !(a.low.imag() > b.high.imag()) && !(a.high.imag() < b.low.imag());\n\treturn x && y;\n}\nvector<Point> corner(const Rect& r)\n{\n\tgtype x[] = { r.low.real(), r.high.real() };\n\tgtype y[] = { r.low.imag(), r.high.imag() };\n\tvector<Point> res;\n\tfor (int i = 0; i < 2; ++i)\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t\tres.push_back(Point(x[i], y[j]));\n\treturn res;\n}\n\n\n// 凸包\n// AOJ0068\nbool allow_line(res_ccw r) { return r < 0; }\nbool strict(res_ccw r) { return r <= 0; }\nPoly convex_hull(vector<Point> ps, bool f(res_ccw) = strict)\n{\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int n = ps.size(), k = 0;\n    Poly res;\n    res.resize(2 * n);\n    for (int i = 0; i < n; ++i)\n    {\n        while (k >= 2 && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; --i)\n    {\n        while (k >= t && f(ccw(res[k - 2], res[k - 1], ps[i])))\n            --k;\n        res[k++] = ps[i];\n    }\n    res.resize(k - 1);\n    return res;\n}\n\n// 凸包判定, 反時計回り\n// AOJ0035\nbool is_convex(const Poly& p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (ccw(p[(i - 1 + p.size()) % p.size()], p[i], p[(i + 1) % p.size()]) <= clockwise)\n            return false;\n    }\n    return true;\n}\n\n// AOJ0079\ngtype area(const Poly& p)\n{\n\tgtype s = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\ts += cross(p[i], p[(i + 1) % p.size()]);\n\treturn abs(s / 2);\n}\n\n// AOJ0012\nenum res_contain{ OUT, ON, IN };\nres_contain contain_GP(const Poly& poly, const Point& p)\n{\n\tbool in = false;\n\tfor (int i = 0; i < (int)poly.size(); ++i)\n\t{\n\t\tPoint a = poly[i] - p, b = poly[(i + 1) % poly.size()] - p;\n\t\tif (a.imag() > b.imag())\n\t\t\tswap(a, b);\n\t\tif ((a.imag() <= 0 && 0 < b.imag()) && cross(a, b) < 0)\n\t\t\tin = !in;\n\t\tif (is_on_seg(Line(poly[i], poly[(i + 1) % poly.size()]), p))\n\t\t\treturn ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// 時計回り、反時計周りの両方でチェック\nres_contain contain_GP_both(const Poly& poly, const Point& p)\n{\n    res_contain res = contain_GP(poly, p);\n    if (res != OUT)\n        return res;\n    Poly g = poly;\n    reverse(all(g));\n    return contain_GP(g, p);\n}\n\n// 円\nenum res_circle_rela\n{\n    a_in_b,\n    b_in_a,\n\n    tangent,\n    intersect,\n    not_intersect,\n};\n// AOJ0023(feps = 0)\nres_circle_rela circle_rela(const Circle& a, const Circle& b)\n{\n    const gtype feps = 0;\n    gtype d = abs(a.p - b.p);\n    if (d + feps > a.r + b.r)\n        return not_intersect;\n    else\n    {\n        if (d + feps < a.r - b.r)\n            return b_in_a;\n        else if (d + feps < b.r - a.r)\n            return a_in_b;\n        else\n            return intersect;\n    }\n}\nvector<Point> ip_CC(const Circle& a, const Circle& b)\n{\n    const gtype feps = 1e-9;\n\n    Point ab = b.p - a.p;\n    Point c = a.p + ab * (a.r / (a.r + b.r));\n\n    gtype dis = abs(a.p - c);\n    if (dis > a.r + feps)\n        return vector<Point>();\n\n    gtype h = sqrt(max<gtype>(0, a.r*a.r - dis*dis));\n\n    Point u = ab * Point(0, 1) / abs(ab);\n    Point v = ab * Point(0, -1) / abs(ab);\n\n    Point p = c + u * h;\n    Point q = c + v * h;\n\n    vector<Point> res;\n    res.push_back(p);\n    if (abs(p - q) > feps)\n        res.push_back(q); // 2点で交わっている\n\n    return res;\n}\n\nbool intersect_GC(const Poly& poly, const Circle& c)\n{\n    for (int i = 0; i < (int)poly.size(); ++i)\n        if (dist_SP(Line(poly[i], poly[(i + 1) % poly.size()]), c.p) < c.r + 1e-9)\n            return true;\n    return contain_GP(poly, c.p) != OUT;\n}\n\n// AOJ0129\nbool contain_CP(const Circle& c, const Point& p)\n{\n    return abs(c.p - p) < c.r;\n}\n// 円周と線分が交わるか(円が線分を含む場合はfalse)\n// AOJ0129\nbool intersect_CS(const Circle& c, const Line& seg)\n{\n    if (contain_CP(c, seg.first) && contain_CP(c, seg.second))\n        return false;\n    return dist_SP(seg, c.p) < c.r + 1e-9;\n}\nbool intersect_SC(const Line& seg, const Circle& c)\n{\n    return intersect_CS(c, seg);\n}\n\n\n\nstring replace(const string& str, const string& from, const string& to)\n{\n    string res = str;\n    string::size_type p;\n    while ((p = res.find(from)) != string::npos)\n        res.replace(p, from.size(), to);\n    return res;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    while (n--)\n    {\n        Poly g;\n        rep(i, 3)\n        {\n            Point p;\n            cin >> p;\n            g.pb(p);\n        }\n        g = convex_hull(g);\n        assert(is_convex(g));\n\n        Point a, b;\n        cin >> a >> b;\n        cout << ((contain_GP(g, a) != OUT) ^ (contain_GP(g, b) != OUT) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=0;j<3;j++)\n\tfor(int k=0;k<3;k++)\n\t  if(i!=j && i!=k && j!=k){\n\t    if(ccw(p[i],p[j],p[k])==1){\n\t      seg[i].a=p[i];\n\t      seg[i].b=p[j];\n\t      l++;\n\t    }\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double D; \n#define EPS (1e-6)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nD add(D a,D b){\n  if(abs(a + b) < EPS * (abs(a) + abs(b))){\n    return 0;\n  }\n  return a + b;\n}\n\nstruct Point{\n  D x,y;\n\n  Point (D x = 0, D y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point(add(x,p.x) , add(y,p.y));\n  }\n  Point operator - (Point p) {\n    return Point(add(x,p.x) ,add(y,-p.y));\n  }\n  Point operator * (D a) {\n    return Point( a*x , a*y );\n  }\n  \n  D norm() {\n    return x*x+y*y;\n  }\n\n  D dot(Point p){\n    return add(x*p.x , y*p.y);\n  }\n\n  D det(Point p){\n    return add(x*p.y , -y*p.x);\n  }  \n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n\n  if(a.det(b) > EPS) return 1;\n  if(a.det(b) < -EPS) return -1;\n  if(a.dot(b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nD S(Point p1,Point p2,Point p3){\n  D a = sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));\n  D b = sqrt(pow(p1.x-p3.x,2) + pow(p1.y-p3.y,2));\n  D c = sqrt(pow(p3.x-p2.x,2) + pow(p3.y-p2.y,2));\n  D s = (a + b + c) / 2;\n\n  return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nbool check(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) < 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) < 0);\n}\n\nbool eq(D S1,D S2){\n  return equal(S1,S2);\n}\n\nint main(){\n  int n;\n  Point P[3],T[2];\n\n  cin >> n;\n  while(n--){\n    scanf(\"%lf %lf\" ,&P[0].x ,&P[0].y);\n    scanf(\"%lf %lf\" ,&P[1].x ,&P[1].y);\n    scanf(\"%lf %lf\" ,&P[2].x ,&P[2].y);\n    scanf(\"%lf %lf\" ,&T[0].x ,&T[0].y);\n    scanf(\"%lf %lf\" ,&T[1].x ,&T[1].y);\n\n    bool ok = false;\n    D S1 = S(P[0],P[1],P[2]);\n    D S2 = S(P[0],P[1],T[0])+S(P[0],P[2],T[0])+S(P[1],P[2],T[0]);\n    D S3 = S(P[0],P[1],T[1])+S(P[0],P[2],T[1])+S(P[1],P[2],T[1]);\n\n    if(eq(S1,S2) && eq(S1,S3)){\n      puts(\"NG\");\n      continue;\n    }\n\n    if(!eq(S1,S2) && !eq(S1,S3)){\n      puts(\"NG\");\n      continue;\n    }\n\n    if(check(P[0],P[1],T[0],T[1])){\n      ok = true;\n    }    \n    if(check(P[0],P[2],T[0],T[1])){\n      ok = true;\n    }  \n    if(check(P[1],P[2],T[0],T[1])){\n      ok = true;\n    }  \n\n    if(ok){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-5;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n\tdouble S = abs(p[0] - p[1]) * dist(p[0] ,p[1], p[2]);\n\t\n\trep(i, 3) S -= abs(p[i] - p[(i + 1) % 3]) * dist(p[i], p[(i + 1) % 3], x);\n\t\n\treturn abs(S) < EPS;\n}\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\t\n\twhile(n--)\n\t{\n\t\tP p[3];\n\t\tP k, s;\n\t\t\n\t\trep(i, 3) cin >> p[i].real() >> p[i].imag();\n\t\tcin >> k.real() >> k.imag() >> s.real() >> s.imag();\n\t\n\t\tif(isInTriangle(p, k) ^ isInTriangle(p, s))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x>0&C.y>0&C.x+C.y<1;}main(){for(cin>>A.x;cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y;X(S)^X(G)?cout<<\"OK\\n\":cout<<\"NG\\n\"){A-=C;B-=C;S-=C;G-=C;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    int xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n    cin >> xp1 >> yp1 >> xp2 >> yp3 >> xk >> yk >> xs >> ys;\n    P p1(xp1,yp1), p2(xp2,yp2), p3(xp3,yp3);\n    L l[3];\n    l[0] = L(p1,p2);\n    l[1] = L(p2,p3);\n    l[2] = L(p3,p1);\n    P pk(xk,yk), ps(xs,ys);\n    L ll(pk,ps);\n    int c = 0;\n    REP(i,3) {\n      if (intersectSS(l[i],ll))\n        c++;\n    }\n    if (c == 1) cout << \"OK\";\n    else cout << \"NG\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef double D;\nconst D EPS = 1e-8;\n\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\n\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\n\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n\nint ccw(P a, P b, P c) { // 重なっている点があるとうまく動かないと思われる\n  b = vec(a, b); c = vec(a, c);\n\n  // a - b - c が折れ曲がるとき\n  if(sig(outp(b, c),0.0) > 0) return +1; // 反時計回り\n  if(sig(outp(b, c),0.0) < 0) return -1; // 時計回り\n\n  // a - b - c が直線上に並ぶとき\n  // sigを使わない実装が主流っぽい？\n  if(sig(inp(b, c),0.0) < 0)   return +2; // c - a - b\n  if(sig(norm(b),norm(c)) < 0) return -2; // a - b - c\n  return 0;                               // a - c - b\n}\n\n// ON = 0, IN = 1, OUT = -1\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sig(a.y, 0.0) <= 0 && sig(b.y, 0.0) > 0 && sig(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\n\nint main() {\n  int N; cin >> N;\n  while(N--) {\n    vector<P> tri(3);\n    for(int i = 0; i < 3; ++i) {\n      cin >> tri[i].x >> tri[i].y;\n    }\n    P k, s;\n    cin >> k.x >> k.y;\n    cin >> s.x >> s.y;\n    int side = containsGP(tri, k);\n    side *= containsGP(tri, s);\n    cout << (side == -1 ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[8],y[8],a,b,c,d,p,q,det,ansx,ansy;\n        //入力を多少簡略化\n        for(int k=0;k<8;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            a = y[j]-y[j+1];  b = x[j+1]-x[j];\n            p = x[j+1]*y[j]-x[j]*y[j+1];\n            //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n            c = y[6]-y[7];  d = x[7]-x[6];\n            q = x[7]*y[6]-x[6]*y[7];\n            //係数についての行列式\n            det = a*d-c*b;\n            //det=0で解は存在しない(この問題については２線分は同一直線上にないから)\n            if(fabs(det) > 0.00001){\n                ansx = (d*p - b*q)/det;\n                ansy = (-c*p + a*q)/det;\n                //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                if((x[0] - ansx)*(x[1] - ansx) <= 0.00001 && (x[6] - ansx)*(x[7] - ansx) <= 0.00001 ) {\n                    count++;\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\ntypedef struct POINT_tag{\n  int x, y;\n}POINT_t;\n\ntypedef struct LINT_tag{\n  POINT_t a, b;\n}LINE_t;\n\ntypedef struct TRIANGLE_tag{\n  POINT_t a, b, c;\n}TRIANGLE_t;\n\nint side(POINT_t *p, LINE_t *e){\n  POINT_t p1 = *p, p2 = e->a, p3 = e->b;\n\n  const int n = p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y);\n  if(n > 0) return 1;\n  else if(n > 0) return -1;\n  else return 0;\n}\n\nint solve(POINT_t *p, TRIANGLE_t *t){\n  LINE_t ab, bc, ca;\n  ab.a = t->a; ab.b = t->b;\n  bc.a = t->b; bc.b = t->c;\n  ca.a = t->c; ca.b = t->a;\n  const int pab = side(p, &ab);\n  const int pbc = side(p, &bc);\n  const int pca = side(p, &ca);\n\n  if((0 < pab) && (0 < pbc) && (0 < pca)) return 1;\n  if((0 > pab) && (0 > pbc) && (0 > pca)) return 1;\n  return 0;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    TRIANGLE_t t;\n    POINT_t k, s;\n    scanf(\"%d%d%d%d%d%d%d%d%d%d\", &t.a.x, &t.a.y, &t.b.x, &t.b.y, &t.c.x, &t.c.y, &k.x, &k.y, &s.x, &s.y);\n    if(solve(&k, &t) != solve(&s, &t)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n#include <set>\n\n\nusing namespace std;\n\n//二次元の外積\n//回転の方向\ndouble gaiseki(double x1, double y1, double x2, double y2){\n    return x1*y2-x2*y1;\n}\n\nbool inside_outside_of_triangle(double xpa, double ypa, double xpb, double ypb, double xpc, double ypc, double x, double y){\n    double vab_x = xpa-xpb;\n    double vab_y = ypa-ypb;\n    double vbc_x = xpb-xpc;\n    double vbc_y = ypb-ypc;\n    double vca_x = xpc-xpa;\n    double vca_y = ypc-ypa;\n    double vap_x = xpa-x;\n    double vap_y = ypa-y;\n    double vbp_x = xpb-x;\n    double vbp_y = ypb-y;\n    double vcp_x = xpc-x;\n    double vcp_y = ypc-y;\n    \n    double direction_a = gaiseki(vca_x,vca_y,vap_x,vap_y);\n    double direction_b = gaiseki(vab_x,vab_y,vbp_x,vbp_y);\n    double direction_c = gaiseki(vbc_x,vbc_y,vcp_x,vcp_y);\n    \n    direction_a/=fabs(direction_a);\n    direction_b/=fabs(direction_b);\n    direction_c/=fabs(direction_c);\n    \n    if(direction_a==direction_b&&direction_b==direction_c)return true;\n    else return false;\n\n}\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n            cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n            bool in_bega = inside_outside_of_triangle(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            bool in_altair = inside_outside_of_triangle(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            if(in_bega&&!in_altair)cout<<\"OK\"<<endl;\n            else cout<<\"NG\"<<endl;\n        }\n   \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n\n#define EPSILON 1e-9\n\n\nclass vector_t {\npublic:\n  double x;\n  double y;\n  double z;\n\npublic:\n  vector_t(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {};\n\npublic:\n  double operator*(const vector_t& v) const {\n    return x * v.x + y * v.y + z * v.z;\n  };\n\n  vector_t operator^(const vector_t& v) const {\n    return vector_t(y * v.z - z * v.y,\n                    z * v.x - x * v.z,\n                    x * v.y - y * v.x);\n  };\n\npublic:\n  double length() const {\n    return sqrt(*this * *this);\n  };\n};\n\n\nclass point_t {\npublic:\n  double x;\n  double y;\n  double z;\n  double w;\n\npublic:\n  point_t(double x = 0, double y = 0, double z = 0, double w = 1) : x(x), y(y), z(z), w(w) {};\n  \npublic:\n  vector_t operator-(const point_t& p) const {\n    return vector_t(x - p.x, y - p.y, z - p.z);\n  };\n};\n\n\nclass point_triangle_intersect : public std::unary_function<point_t, bool> {\npublic:\n  point_triangle_intersect(const point_t& p1,\n                           const point_t& p2,\n                           const point_t& p3) :\n    p1_(p1), p2_(p2), p3_(p3), s_(((p2 - p1) ^ (p3 - p1)).z)\n  {\n  };\n \npublic:\n  bool operator()(const point_t& p) const {\n    double u = ((p1_ - p3_) ^ (p - p3_)).z / s_;\n    double v = ((p2_ - p1_) ^ (p - p1_)).z / s_;\n\n    return (u >= 0 && v >= 0 && u + v <= 1.0 + EPSILON);\n  };\n \nprivate:\n  point_t p1_;\n  point_t p2_;\n  point_t p3_;\n\n  double s_;\n};\n\n\nint main(int argc, char** argv)\n{\n  int n;\n\n  std::cin >> n;\n\n  for (int i = 0; i < n; i ++) {\n    point_t p1, p2, p3, k, s;\n\n    std::cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    std::cin >> k .x >> k .y >> s .x >> s .y;\n\n    if (point_triangle_intersect(p1, p2, p3)(k) ^\n        point_triangle_intersect(p1, p2, p3)(s)) {\n\n      std::cout << \"OK\" << std::endl;\n    }\n    else {\n      std::cout << \"NG\" << std::endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=(Crosspoint(pq,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(qr,ks)&&Crosspoint(ks,qr));\n    ans+=(Crosspoint(rp,ks)&&Crosspoint(ks,rp));\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps){\n  point a(p.x,p.y),b(1000000,p.y);\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<ps.size();i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<ps.size();i++)\n    if(is_intersected_ls(ps[i],ps[(i+1)%ps.size()],a,b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p)!=inside(s,p))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tP p1(xp1,yp1), p2(xp2,yp2), p3(xp3,yp3), K(xk,yk), S(xs,ys);\n\t\tTriangle t( p1 , p2, p3 );\n\t\tint a = t.is_inside(K)? 1 : 0 ;\n\t\tint b = t.is_inside(S)?\t1 : 0 ;\n\t\tcout << ((a^b)? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x=0, double y=0) : x(x), y(y) {}\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n};\n\ntypedef Point Vector;\n\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n\nPoint p1, p2, p3, k, s;\n\nbool isInTry(Point p) {\n  double c1 = cross(p2 - p1, p - p1);\n  double c2 = cross(p3 - p2, p - p2);\n  double c3 = cross(p1 - p3, p - p3);\n  return c1 * c2 > 0.0 && c2 * c3 > 0.0;\n}\n\nvoid solve() {\n  bool f1 = isInTry(k);\n  bool f2 = isInTry(s);\n  if((!f1 || !f2) && (f1 || f2)) cout << \"OK\" << endl;\n  else                           cout << \"NG\" << endl;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i) {\n    cin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y\n\t>> k.x >> k.y >> s.x >> s.y;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n// must template\ntypedef long double D;\nconst D INF = 1e12,EPS = 1e-10;\n\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nistream& operator >> (istream& is,complex<D>& p){D x,y;is >> x >> y; p=P(x,y); return is;}\n\nint sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\ntemplate<typename T> bool eq(const T& a,const T& b){return sig(abs(a-b))==0;}\nbool compX (const P& a,const P& b){return !eq(a.X,b.X)?sig(a.X,b.X)<0:sig(a.Y,b.Y)<0;}\nnamespace std{\n\tbool operator <  (const P& a,const P& b){return compX(a,b);}\n  \tbool operator == (const P& a,const P& b){return eq(a,b);}\n};\n// a×b\nD cross(const P& a,const P& b){return imag(conj(a)*b);}\n// a・b\nD dot(const P& a,const P& b) {return real(conj(a)*b);}\nint ccw(const P& a,P b,P c){\n    b -= a; c -= a;\n    if (sig(cross(b,c)) > 0)   return +1;       // counter clockwise\n    if (sig(cross(b,c)) < 0)   return -1;       // clockwise\n    if (sig(dot(b,c)) < 0)     return +2;       // c--a--b on line\n    if (sig(norm(b),norm(c))<0) return -2;       // a--b--c on line\n    return 0; //a--c--b on line (c==b,c==a)\n}\n// //must template\n\ntypedef vector<P> Poly,ConvexPoly;\nenum { OUT, ON, IN };\nint contains(const Poly& ps, const P& p) {\n  \tbool in = false;int n=ps.size();\n  \tREP(i,n){\n\t\tP a = ps[i] - p, b = ps[pmod(i+1,n)] - p;\n\t\tif(a.Y > b.Y) swap(a, b);\n\t\tif(a.Y <= 0 && 0 < b.Y)if(sig(cross(a, b)) < 0) in = !in;\n    \tif(sig(cross(a, b)) == 0 && sig(dot(a, b)) <= 0) return ON;\n  \t}\n\treturn in ? IN : OUT;\n}\n\nclass Main{\n\tpublic:\n\tvoid run(){\n\t\tint N;cin >> N;\n\t\tREP(i,N){\n\t\t\tvector<P> ps(3); REP(j,3)cin >>ps[j];\n\t\t\tP k,s;cin >> k >> s;\n\t\t\tbool ok=false;\n\t\t\tif(contains(ps,k) ^ contains(ps,s))ok=true;\n\t\t\tcout <<(ok?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcerr <<fixed<<setprecision(20);\t\n\tcout <<fixed<<setprecision(20);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx,ansy;\n        //入力を多少簡略化\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > 0.00001){\n                    ansx = (d*p - b*q)/det;\n                    ansy = (-c*p + a*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= 0.00001 && (x[3] - ansx)*(x[4] - ansx) <= 0.00001 ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > 0.00001){\n                    ansx = (d*p - b*q)/det;\n                    ansy = (-c*p + a*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= 0.00001 && (x[3] - ansx)*(x[4] - ansx) <= 0.00001 ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Vector2\n{\npublic:\n\tVector2() : x( 0 ), y( 0 ){}\n\tVector2( int _x, int _y ) : x( _x ), y( _y ){}\n\tVector2& operator=( const Vector2& v )\n\t{\n\t\tthis->x = v.x;\n\t\tthis->y = v.y;\n\t\treturn *this;\n\t}\n\tVector2 operator-( const Vector2& v )\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\tint clossProduct( const Vector2& v )\n\t{\n\t\treturn static_cast<double>( this->x ) * v.y > static_cast<double>( this->y ) * v.x\n\t\t\t? 1 : -1;\n\t}\n\n\tint x, y;\n};\n\nbool solve()\n{\n\tVector2 coodi[ 5 ];\n\tfor( int i = 0; i < 5; ++i ){\n\t\tVector2 v;\n\t\tcin >> v.x >> v.y;\n\t\tcoodi[ i ] = v;\n\t}\n\tint closs[ 2 ][ 3 ];\n\tfor( int i = 0; i < 2; ++i ){\n\t\tVector2& o = coodi[ 3 + i ];\n\t\tfor( int j = 0; j < 3; ++j ){\n\t\t\tVector2 v = coodi[ ( j + 1 ) % 3 ] - coodi[ j ];\n\t\t\tVector2 w = o - coodi[ j ];\n\t\t\tcloss[ i ][ j ] = v.clossProduct( w );\n\t\t}\n\t}\n\tfor( int i = 0; i < 2; ++i ){\n\t\tint a = closs[ i ][ 0 ] * closs[ i ][ 1 ];\n\t\tint b = closs[ i ][ 1 ] * closs[ i ][ 2 ];\n\t\tint c = closs[ i ][ 2 ] * closs[ i ][ 0 ];\n\t\tcloss[ i ][ 0 ] = a;\n\t\tcloss[ i ][ 1 ] = b;\n\t\tcloss[ i ][ 2 ] = c;\n\t}\n\tif( ( ( closs[ 0 ][ 0 ] > 0 && closs[ 0 ][ 1 ] > 0 && closs[ 0 ][ 2 ] > 0 )\n\t\t&& ( closs[ 1 ][ 0 ] < 0 || closs[ 1 ][ 1 ] < 0 || closs[ 1 ][ 2 ] < 0 ) )\n\t\t|| ( ( closs[ 0 ][ 0 ] < 0 || closs[ 0 ][ 1 ] < 0 || closs[ 0 ][ 2 ] < 0 )\n\t\t&& ( closs[ 1 ][ 0 ] > 0 && closs[ 1 ][ 1 ] > 0 && closs[ 1 ][ 2 ] > 0 ) ) ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\twhile( cin >> n ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tif( solve() ){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tint ax,bx,cx,dx,ex;\n\t\tint ay,by,cy,dy,ey;\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy,&ex,&ey);\n\t\tint count=0;\n\t\tint p=(dx-ax)*(by-ay)-(dy-ay)*(bx-ax);\n\t\tint q=(dx-bx)*(cy-by)-(dy-by)*(cx-bx);\n\t\tint r=(dx-cx)*(ay-cy)-(dy-cy)*(ax-cx);\n\t\tif(p>=0&&q>=0&&r>=0)count++;\n\t\telse if(p<=0&&q<=0&&r<=0)count++;\n\t\tp=(ex-ax)*(by-ay)-(ey-ay)*(bx-ax);\n\t\tq=(ex-bx)*(cy-by)-(ey-by)*(cx-bx);\n\t\tr=(ex-cx)*(ay-cy)-(ey-cy)*(ax-cx);\n\t\tif(p>=0&&q>=0&&r>=0)count++;\n\t\telse if(p<=0&&q<=0&&r<=0)count++;\n\t\tif(count==1)printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=q.y=2000000000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=(Crosspoint(pq,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(qr,ks)&&Crosspoint(ks,pq));\n    ans+=(Crosspoint(rp,ks)&&Crosspoint(ks,pq));\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\t//if (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=1000000;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define EPS (1e-10)\nusing namespace std;\n\nclass Point{\npublic:\n  int x, y;\n};\nclass Segment{\npublic:\n  Point p1, p2;\n};\n\ndouble norm(Point a){\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble dot(Point a, Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a, Point b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a;\n  a.x=p1.x-p0.x;\n  a.y=p1.y-p0.y;\n  Point b;\n  b.x=p2.x-p0.x;\n  b.y=p2.y-p0.y;\n  if(cross(a, b) > EPS) return 1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nmain(){\n  int n;\n  while(cin >> n){\n    for(int i=0;i<n;i++){\n      int xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n      cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n      Point a, b, c, k, s;\n      a.x=xp1;\n      a.y=yp1;\n      b.x=xp2;\n      b.y=yp2;\n      c.x=xp3;\n      c.y=yp3;\n      k.x=xk;\n      k.y=yk;\n      s.x=xs;\n      s.y=ys;\n      Segment ab, bc, ca, ks;\n      ab.p1=b;\n      ab.p2=a;\n      bc.p1=c;\n      bc.p2=b;\n      ca.p1=a;\n      ca.p2=c;\n      ks.p1=s;\n      ks.p2=k;\n      int count=0;\n      if(isIntersect(ks, ab)) count++;\n      if(isIntersect(ks, bc)) count++;\n      if(isIntersect(ks, ca)) count++;\n      if(count==1) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n\tPoint(double x=0, double y=0) : x(x), y(y) {}\n\tPoint operator-(const Point &o) const {\n\t\treturn Point(x-o.x, y-o.y);\n\t}\n};\n\ndouble cross(Point &a, Point &b) {\n\treturn (a.x * b.y - b.x * a.y);\n}\n\nbool in(Point &a, Point &b, Point &c, Point &p) {\n\tPoint ab = b-a;\n\tPoint bc = c-b;\n\tPoint ca = a-c;\n\tPoint ap = p-a;\n\tPoint bp = p-b;\n\tPoint cp = p-c;\n\tdouble cross_a = cross(ab, ap);\n\tdouble cross_b = cross(bc, bp);\n\tdouble cross_c = cross(ca, cp);\n\treturn (cross_a / abs(cross_a) == cross_b / abs(cross_b) &&\n\t\t\tcross_b / abs(cross_b) == cross_c / abs(cross_c));\n}\n\n\n\nint main() {\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tPoint v[3], altair, vega;\n\t\tfor (int i = 0; i < 3; i++) cin >> v[i].x >> v[i].y;\n\t\tcin >> altair.x >> altair.y >> vega.x >> vega.y;\n\n\t\tbool altair_in, vega_in;\n\t\taltair_in = in(v[0], v[1], v[2], altair);\n\t\tvega_in = in(v[0], v[1], v[2], vega);\n\n\t\tif (altair_in ^ vega_in) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}\n\n\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\n// 度->ラジアンの変換\n#define DEGtoRAD(X) (X*PI)/180.0\n// 円周率\nconst double PI = 2 * acos(0.0);\n// 許容誤差.問題によって変える\nconst double EPS = 1e-9;\n\nstruct point{\n    double x, y;\n    point(){ x = y = 0.0;}\n    point(double _x, double _y) : x(_x), y(_y) {}\n\n    // 不等号のオーバーロード.x座標,y座標で昇順ソート\n    bool operator < (const point other) const{\n        if(fabs(x - other.x) > EPS)\n            return x < other.x;\n        else\n            return y < other.y;\n    }\n\n    // 等号のオーバーロード.\n    bool operator == (const point other) const{\n        return fabs(x - other.x) < EPS &&\n                fabs(y - other.y) < EPS;\n    }\n};\n\n// ベクトル\nstruct vec{\n    double x, y;\n    vec(double _x, double _y) : x(_x), y(_y) {}\n};\n\n// 2つのpoint a,b をvec a->b に変換\nvec toVec(point a, point b){\n    return vec(b.x - a.x, b.y - a.y);\n}\n\n// vecの外積\ndouble cross(vec v1, vec v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n// !未確認!(特に辺上の判定が正しいかどうか怪しい)\n// point rが3つのpointからなる三角形の内部に存在するかどうかの判定\n// 三角形の内側に点があるとき、外積によるベクトルは同じ方向を向くことを利用\n// -1...内側 0...辺上 1...外側\nint inTriangle(point r, point a, point b, point c){\n    double c1 = cross(toVec(a,b), toVec(b,r));\n    double c2 = cross(toVec(b,c), toVec(c,r));\n    double c3 = cross(toVec(c,a), toVec(a,r));\n\n    if(c1 == 0 || c2 == 0 || c3 == 0)           return 0;\n    else if( (c1 > 0 && c2 > 0 && c3 > 0) || \n        (c1 < 0 && c2 < 0 && c3 < 0)        )   return -1;\n    else                                        return 1;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    double input[10];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < 10; j++){\n            cin >> input[j];\n            input[j] += 1000.0;\n        }\n\n        point p1(input[0], input[1]);\n        point p2(input[2], input[3]);\n        point p3(input[4], input[5]);\n        point k(input[6], input[7]);\n        point s(input[8], input[9]);\n\n        int kengyu = inTriangle(k, p1, p2, p3);\n        int orihime = inTriangle(s, p1, p2, p3);\n\n        if(kengyu * orihime == -1)  cout << \"OK\" << endl;\n        else                        cout << \"NG\" << endl;\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nbool isInTriangle(P p[3], P x)\n{\n\tdouble a = abs(p[0] - p[1]) * dist(p[0], p[1], x) / 2.0;\n\tdouble b = abs(p[1] - p[2]) * dist(p[1], p[2], x) / 2.0;\n\tdouble c = abs(p[2] - p[0]) * dist(p[2], p[0], x) / 2.0;\n\t\n\tdouble S = abs(p[0] - p[1]) * dist(p[0] ,p[1], p[2]) / 2.0;\n\t\n\treturn abs(a + b + c - S) < EPS;\n}\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\t\n\twhile(n--)\n\t{\n\t\tP p[3];\n\t\tP k, s;\n\t\t\n\t\trep(i, 3) cin >> p[i].real() >> p[i].imag();\n\t\tcin >> k.real() >> k.imag() >> s.real() >> s.imag();\n\t\n\t\tif(isInTriangle(p, k) ^ isInTriangle(p, s))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cmath>\n#include <cstdio>\n \nusing namespace std;\n \ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-10)\n\n\nD dot(P a,P b){\n  return real(conj(a) * b);\n}\n\nD cross(P a,P b){\n  return imag(conj(a) * b);\n} \n\nint ccw(P p0,P p1,P p2){\n  P a = p1 - p0;\n  P b = p2 - p0;\n \n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nbool check(P p1,P p2,P p3,P p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n      ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0);\n}\n \nint main(){\n  int n;\n  P P[3],T[2];\n \n  scanf(\"%d\" ,&n);\n  while(n--){\n    for(int i = 0 ; i < 3 ; i++){\n      scanf(\"%lf %lf\" ,&P[i].real() ,&P[i].imag());\n    }\n\n    for(int i = 0 ; i < 2 ; i++){\n      scanf(\"%lf %lf\" ,&T[i].real() ,&T[i].imag());\n    }\n\n    int cnt = 0; \n    if(check(P[0],P[1],T[0],T[1])){\n      cnt++;\n    }   \n    if(check(P[0],P[2],T[0],T[1])){\n      cnt++;\n    } \n    if(check(P[1],P[2],T[0],T[1])){\n      cnt++;\n    } \n \n    if(cnt % 2){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=INT_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn+EPS||t.a.y>=ymx-EPS)return 0;\n\n  int cnt1=0,cnt2=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i])){\n      cnt1++;\n      continue;\n    }\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt2++;\n  }\n  return ((cnt1/2)+cnt2)%2;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = 1e9;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** 幾何ライブラリ **/\n#include <complex>\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-11;\nconst double PI = acos(-1.0);\n\ntypedef double D;\ntypedef complex<D> P; // Point\n\nstruct L { // Line\n\tP a, b;\n\tL(){}\n\tL(P aa, P bb) : a(aa), b(bb){}\n};\n\nstruct C { // Circle\n\tP p; D r;\n\tC() {}\n\tC(P pp, D rr) : p(pp), r(rr) {}\n};\n\n// 共役複素数 conj(a);\n\n// 符号\nint sig(D a, D b=0) {\n\tif (a < b-EPS) return -1;\n\tif (a > b+EPS) return 1;\n\treturn 0;\n}\n\n// 内積\nD dot(P a, P b) { return (conj(a)*b).real(); }\n\n// 外積\nD cross(P a, P b) { return (conj(a)*b).imag(); }\n\n// 線分abに対する点cの位置\nenum STATE{LEFT=1, RIGHT=-1, BACK=2, FRONT=-2, ON=0, IN=3, OUT=-3};\nint ccw(P a, P b, P c)\n{\n\tb -= a, c -= a;\n\tD s = sig(cross(b, c));\n\tif (s) return s>0 ? LEFT : RIGHT;\n\tif (sig(dot(b, c))<0) return BACK;\n\tif (sig(abs(c), abs(b))>0) return FRONT;\n\treturn ON;\n}\n\n// 直線lに対する点pの写像\nP projection(L l, P p)\n{\n\treturn l.a + (l.b-l.a)/abs(l.b-l.a) * dot(l.b-l.a, p-l.a)/abs(l.b-l.a);\n}\n\n// 直線lに対する点pの反射\nP reflection(L l, P p)\n{\n\treturn p + (projection(l, p)-p)*P(2, 0);\n}\n\n// 直線abと点cの距離\nD dLP(L l, P c)\n{\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分abと点cの距離\nD dSP(L l, P c)\n{\n\tif (sig(dot(l.b-l.a, c-l.a))<0) return abs(c-l.a);\n\tif (sig(dot(l.a-l.b, c-l.b))<0) return abs(c-l.b);\n\treturn abs(cross(l.b-l.a, c-l.a))/abs(l.b-l.a);\n}\n\n// 線分と線分の交差判定\nbool iSS(L s, L t)\n{\n\treturn (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0)\n\t\t\t&& (ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0);\n}\n\n// 線分と線分の距離\nD dSS(L s, L t)\n{\n\tif (iSS(s, t)) return 0;\n\treturn min(min(dSP(t, s.a), dSP(t, s.b)), min(dSP(s, t.a), dSP(s, t.b)));\n}\n\n// 線分と線分の交点 (公差していることが前提)\nP cSS(L s, L t)\n{\n\tD d1 = dLP(t, s.a);\n\tD d2 = dLP(t, s.b);\n\tD tmp = d1 / (d1 + d2);\n\treturn s.a + (s.b-s.a)*tmp;\n}\n\n// 直線と直線の交差判定\nbool iLL(L s, L t)\n{\n\treturn sig(cross(s.b-s.a, t.b-t.a))!=0;\n}\n\n// 直線と直線の交点 iLLを確認してから使用\nP cLL(L s, L t)\n{\n\tP ss = s.b - s.a, tt = t.b - t.a;\n\treturn s.a + ss*cross(tt, t.a-s.a)/cross(tt, ss);\n}\n\n// 円と直線の交差判定 (交点の数を返す)\nint iCL(C c, L l)\n{\n\tint t = sig(dLP(l, c.p), c.r);\n\tif (t < 0) return 2;\n\telse if (t == 0) return 1;\n\treturn 0;\n}\n\n// 円と直線の交点を求める\nvector<P> cCL(C c, L l)\n{\n\tvector<P> res;\n\tint n = iCL(c, l);\n\t\n\tP h = projection(l, c.p);\n\tD d = abs(h-c.p);\n\t\n\tif (n == 2) {\n\t\tP x = (l.b-l.a)/abs(l.b-l.a)*sqrt(c.r*c.r - d*d);\n\t\tres.push_back(h+x);\n\t\tres.push_back(h-x);\n\t} else if (n == 1) {\n\t\tres.push_back(h);\n\t}\n\t\n\treturn res;\n}\n\n// 円と円の交点を求める (交点があることが前提)\nvector<P> cCC(C a, C b)\n{\n\tD d = abs(b.p - a.p);\n\tD rc = (d*d + a.r*a.r - b.r*b.r)/(2*d);\n\tD rs = sqrt(a.r*a.r - rc*rc);\n\tP diff = (b.p-a.p)/d;\n\t\n\tvector<P> res;\n\tres.push_back(a.p + diff*P(rc, rs));\n\tres.push_back(a.p + diff*P(rc, -rs));\n\treturn res;\n}\n\n\n// 多角形\ntypedef vector<P> G;\n\n// 面積を求める\nD area(G g)\n{\n\tD res = 0.0;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tres += cross(g[i], g[(i+1)%g.size()]);\n\t}\n\treturn abs(res)/2;\n}\n\n// 多角形gと点pの包含関係を求める\nint containsGP(G g, P p)\n{\n\tbool in=false;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(a, b, p) == ON) return ON;\n\t\t\n\t\ta -= p, b -= p;\n\t\tif (a.Y > b.Y) swap(a, b);\n\t\tif (a.Y<0 && b.Y>=0 && sig(cross(a, b))>0) in = !in;\n\t}\n\treturn in?IN:OUT;\n}\n\nbool cmp_convex_full(const P &a, const P &b)\n{\n\tif (sig(a.X, b.X) != 0) return a.X < b.X;\n\treturn a.Y < b.Y;\n}\n\n// 凸包を得る\n// 辺上を含めない場合は <= 0 にする\nG convex_hull(vector<P> ps)\n{\n\tif (ps.size()==1) return ps;\n\t\n\tint N = (int)ps.size(), k=0;\n\tsort(ps.begin(), ps.end(), cmp_convex_full);\n\tG res(2*N);\n\t\n\tfor (int i=0; i<N; i++) {\n\t\twhile (k>=2 && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\t\n\tint t = k+1;\n\tfor (int i=N-2; i>=0; i--) {\n\t\twhile (k>=t && ccw(res[k-2], res[k-1], ps[i]) == RIGHT) k--;\n\t\tres[k++] = ps[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// 凸多角形を直線で切断し、左側を残す\nG convex_cut(G g, L l)\n{\n\tG res;\n\tfor (int i=0; i<g.size(); i++) {\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif (ccw(l.a, l.b, a) != RIGHT) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) res.push_back(cLL(L(a, b), l));\n\t}\n\treturn res;\n}\n\n/** Problem0143 : Altair and Vega **/\nint main()\n{\n\tint N; cin>>N;\n\trep(i, N) {\n\t\tG g;\n\t\trep(j, 3) {\n\t\t\tD r, im; cin>>r>>im;\n\t\t\tP p(r, im);\n\t\t\tg.push_back(p);\n\t\t}\n\t\tD r, im; cin>>r>>im;\n\t\tP p1(r, im);\n\t\tcin>>r>>im;\n\t\tP p2(r, im);\n\t\t\n\t\tif ((containsGP(g, p1)==IN && containsGP(g, p2)==OUT) ||\n\t\t\t(containsGP(g, p1)==OUT && containsGP(g, p2)==IN)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct P{\n\tdouble x;\n\tdouble y;\n};\n\nint ccw(P p0, P p1, P p2)\n{\n\tdouble dx1 = p1.x-p0.x;\n\tdouble dy1 = p1.y-p0.y;\n\tdouble dx2 = p2.x-p0.x;\n\tdouble dy2 = p2.y-p0.y;\n\t\n\tif(dx1*dy2 > dy1*dx2){\n\t\treturn 1;\n\t} \n\tif(dx1*dy2 < dy1*dx2){\n\t\treturn -1;\n\t}\n\tif((dx1*dx2 < 0) || (dy1*dy2 < 0)){\n\t\treturn -1;\n\t}\n\tif((dx1*dx1+dy1*dy1)<(dx2*dx2+dy2*dy2)){\n\t\treturn 1;\n\t}\n\t\n\treturn 0;\n}\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return a.x != b.x ? a.x < b.x : a.y < b.y;\n  }\n}\n\nvector<P> convex_hull(vector<P> vec)\n{\n\tint n = vec.size(), k = 0;\n\tsort(vec.begin(), vec.end());\n\tvector<P> ch(2*n);\n\t\n\tfor(int i = 0; i < n; ch[k++] = vec[i++]){\n\t\twhile(k >= 2 && ccw(ch[k-2], ch[k-1], vec[i]) <= 0){\n\t\t\tk--;\n\t\t}\n\t}\n\t\n\tfor(int i = n-2, t = k+1; i >= 0; ch[k++] = vec[i--]){\n\t\twhile(k >= t && ccw(ch[k-2], ch[k-1], vec[i]) <= 0){\n\t\t\tk--;\n\t\t}\n\t}\n\t\n\tch.resize(k-1);\n\t\n\treturn ch;\n}\n\nbool check(vector<P> vec, P p)\n{\n\tbool f = false;\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(p.x == vec[i].x && p.y == vec[i].y){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\n\nint main()\n{\n\tint n;\n\tbool f;\n\tP pr[3], s, t;\n\t\n\twhile(cin>>n && n){\n\t\twhile(n--){\n\t\t\tcin >> pr[0].x >> pr[0].y >> pr[1].x >> pr[1].y >> pr[2].x >> pr[2].y >> s.x >> s.y >> t.x >> t.y;\n\t\t\tf = true;\n\t\t\tvector<P> vec;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tvec.push_back(pr[i]);\n\t\t\t}\n\t\t\tvec.push_back(t);\n\t\t\tvec = convex_hull(vec);\n\t\t\tif(vec.size() == 4){\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(check(vec, t)){\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvec.clear();\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tvec.push_back(pr[i]);\n\t\t\t}\n\t\t\tvec.push_back(s);\n\t\t\tvec = convex_hull(vec);\n\t\t\tif(vec.size() == 4){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t} else {\n\t\t\t\tif(check(vec, s)){\n\t\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\t} else {\n\t\t\t\t\tcout << \"NG\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\ntypedef pair<double, double> P;\nconst double eps = 1e-9;\n\ndouble Length(P p1, P p2)\n{\n\treturn(sqrt((p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second)));\n}\n\ndouble Helon(P p1, P p2, P p3)\n{\n\tdouble a = Length(p1, p2);\n\tdouble b = Length(p2, p3);\n\tdouble c = Length(p3, p1);\n\tdouble s = (a + b + c) / 2;\n\treturn(sqrt(s * (s - a) * (s - b) * (s - c)));\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tvector<P> Point(3);\n\t\tP pk, ps;\n\t\tfor(int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tcin >> Point[j].first >> Point[j].second;\n\t\t}\n\t\tcin >> pk.first >> pk.second >> ps.first >> ps.second;\n\t\tdouble S = Helon(Point[0], Point[1], Point[2]);\n\t\tdouble S1 = Helon(Point[0], Point[1], pk);\n\t\tS1 += Helon(Point[1], Point[2], pk);\n\t\tS1 += Helon(Point[2], Point[0], pk);\n\n\t\tdouble S2 = Helon(Point[0], Point[1], ps);\n\t\tS2 += Helon(Point[1], Point[2], ps);\n\t\tS2 += Helon(Point[2], Point[0], ps);\n\n\t\tif(fabs(S - S1) < eps && fabs(S - S2) >= eps || fabs(S - S1) >= eps && fabs(S - S2) < eps)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nenum { OUT, ON, IN };\nint contains(const G &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nvoid input(P &p){\n  int x, y; cin >>x >>y;\n  p = P(x, y);\n}\n\nint main() {\n  int N; cin >>N;\n  while(N--){\n    G g(3);\n    REP(i, 3) input(g[i]);\n    P a, b;\n    input(a); input(b);\n    int ac = contains(g, a), bc = contains(g, b);\n    cout <<(ac == bc ? \"NG\" : \"OK\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\n\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool in_tri(const P& p, const VP& tri){\n    return cross(tri[1]-tri[0], p-tri[0])>0 &&\n        cross(tri[2]-tri[1], p-tri[1])>0 &&\n        cross(tri[0]-tri[2], p-tri[2])>0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0; i<n; i++){\n        VP tri(3);\n        for(int j=0; j<3; j++){\n            int x,y;\n            cin >> x >> y;\n            tri[j] = P(x,y);\n        }\n        if(cross(tri[1]-tri[0], tri[2]-tri[0])<0){\n            swap(tri[1], tri[2]);\n        }\n        VP sg(2);\n        for(int j=0; j<2; j++){\n            int x,y;\n            cin >> x >> y;\n            sg[j] = P(x,y);\n        }\n        if(in_tri(sg[0], tri) != in_tri(sg[1], tri)){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n\n//時計回りに辺を構築する。\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n/*\n点と多角形の内外判定\n\nps 多角形の辺\np  点\nn  多角形の辺の数\n\n点が多角形に含まれれば1,\nそうでなければ0を返す。\n*/\nint point_contain(vector<segment> ps, point p, int n){\n  point q;\n  q.x=100000000;\n  q.y=p.y;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(ps[i].a.y==ps[i].b.y && ps[i].b.y==p.y)return 0;\n    cnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  }\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    seg=construct_edge(p,3);\n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nclass Vector{\npublic:\n\tdouble x,y;\n\n\tVector( double dx, double dy ) : x( dx ), y( dy ) {}\n\tVector(){}\n\n\tVector operator-( const Vector& lhs ){\n\t\treturn Vector( x - lhs.x, y - lhs.y );\n\t}\n\n\tVector& operator-=( const Vector& lhs ){\n\t\tx -= lhs.x;\n\t\ty -= lhs.y;\n\t\treturn *this;\n\t}\n};\n\ndouble crossProduct( const Vector& rhs, const Vector& lhs ){\n\treturn rhs.x * lhs.y - rhs.y * lhs.x;\n}\n\nbool line( Vector a, Vector b, Vector c ){\n\tb -= a;\n\tc -= a;\n\n\tdouble answer = crossProduct( b, c );\n\n\tif( answer < 0 ) return false;\n\telse if( answer > 0 ) return true;\n\n\treturn false;\n}\n\nbool inTriangle( const Vector& a, const Vector& b, const Vector& c, const Vector& point ){\n\tbool answer[3];\n\tanswer[0] = line( a, b, point );\n\tanswer[1] = line( b, c, point );\n\tanswer[2] = line( c, a, point );\n\n\tif( answer[0] == answer[1] && answer[1] == answer[2] ) return true;\n\t\n\n\treturn false;\n}\n\n\n\nint main(int argc, char const* argv[])\n{\n\tint n;\n\tVector p1,p2,p3,k,s;\n\n\tcin >> n;\n\tfor( int i = 0;i < n;i++ ){\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> k.x >> k.y >> s.x >> s.y;\n\n\t\tbool answer[2];\n\t\tanswer[0] = inTriangle( p1, p2, p3, k );\n\t\tanswer[1] = inTriangle( p1, p2, p3, s );\n\n\t\tif( answer[0] == answer[1] ) cout << \"NG\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n int inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\ndouble ab,ac,bc;\ndouble ak,bk,ck,as,bs,cs;\nbool heron(){\n    double sta;\n    double wa = 0.0;\n    double S,s;\n    bool f1=false,f2=false; \n    /*sta*/\n    s = (ab+ac+bc)*0.5;\n    S = sqrt(s * (s-ab) * (s-ac) * (s-bc));\n    sta = S;\n\n    /*wa*/\n    s = (ab+ak+bk)*0.5;\n    S = sqrt(s*(s-ab)*(s-ak)*(s-bk));\n    wa += S;\n    s = (ac+ak+ck)*0.5;\n    S = sqrt(s*(s-ac)*(s-ak)*(s-ck));\n    wa += S;\n    s = (bc+bk+ck)*0.5;\n    S = sqrt(s*(s-bc)*(s-bk)*(s-ck));\n    wa += S;\n    if(fabs(sta-wa) <= 0.01)f1 = true;\n    wa = 0.0;\n\n    s = (ab+as+bs)*0.5;\n    S = sqrt(s*(s-ab)*(s-as)*(s-bs));\n    wa += S;\n    s = (ac+as+cs)*0.5;\n    S = sqrt(s*(s-ac)*(s-as)*(s-cs));\n    wa += S;\n    s = (bc+bs+cs)*0.5;\n    S = sqrt(s*(s-bc)*(s-bs)*(s-cs));\n    wa += S;\n    if(fabs(sta-wa) <= 0.01)f2 = true;\n\n    if((f1 && f2) || (!f1 && !f2))return false;\n    else return true;\n}\nint main(){\n    int hoge;\n    scanf(\"%d\",&hoge);\n    while( hoge-- ){\n        double xa,ya,xb,yb,xc,yc,xk,yk,xs,ys;\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf\",&xa,&ya,&xb,&yb,&xc,&yc,&xk,&yk,&xs,&ys);\n        ab = sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb));\n        ac = sqrt((xa-xc)*(xa-xc) + (ya-yc)*(ya-yc));\n        bc = sqrt((xb-xc)*(xb-xc) + (yb-yc)*(yb-yc));\n        ak = sqrt((xa-xk)*(xa-xk) + (ya-yk)*(ya-yk));\n        bk = sqrt((xb-xk)*(xb-xk) + (yb-yk)*(yb-yk));\n        ck = sqrt((xc-xk)*(xc-xk) + (yc-yk)*(yc-yk));\n        as = sqrt((xa-xs)*(xa-xs) + (ya-ys)*(ya-ys));\n        bs = sqrt((xb-xs)*(xb-xs) + (yb-ys)*(yb-ys));\n        cs = sqrt((xc-xs)*(xc-xs) + (yc-ys)*(yc-ys));\n        bool f = heron();\n        (f) ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\ndouble heron(Po a,Po b,Po c){\n  double l1,l2,l3,s;\n  l1 = abs(a-b);\n  l2 = abs(b-c);\n  l3 = abs(c-a);\n  s = (l1+l2+l3)/2;\n  return sqrt(s*(s-l1)*(s-l2)*(s-l3));\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( heron(a,b,x) + heron(b,c,x) + heron(c,a,x) > heron(a,b,c) + EPS)return false;\n  else return true;\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    /*\n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    */\n    //if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct point{\n\tdouble x, y;\n};\n\nvector<point> t(3);\n\nbool isIn(point s) {\n\tpoint a, b, c;\n\ta.x = t[1].x-t[0].x; a.y = t[1].y-t[0].y;\n\tb.x = t[2].x-t[0].x; b.y = t[2].y-t[0].y;\n\tc.x = s.x-t[0].x; c.y = s.y-t[0].y;\n\tdouble c1, c2;\n\tc1 = (b.y*c.x - b.x*c.y) / (a.x*b.y - a.y*b.x);\n\tc2 = (a.y*c.x - a.x*c.y) / (a.y*b.x - a.x*b.y);\n\tif ((c1>0.0)&&(c2>0.0)&&(c1+c2<1.0)) return true;\n\treturn false;\n}\n\nint main()\n{\n\tint n, i;\n\tpoint s, g;\n\tcin>>n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin>>t[0].x>>t[0].y>>t[1].x>>t[1].y>>t[2].x>>t[2].y;\n\t\tcin>>s.x>>s.y>>g.x>>g.y;\n\t\tif (isIn(s)^isIn(g)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョテ」ツ?療」ツ?ヲティツカツウテ」ツ?療ァツョツ?\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2テヲツャツ。テ・ツ?ε」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//テ・ツ??ァツゥツ?\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//テ・ツ、ツ姪ァツゥツ?\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//テァツキツ堙・ツ按?1-p2テ、ツクツ甘」ツ?ォテァツつケqテ」ツ?古」ツ?づ」ツつ凝」ツ?凝・ツ按、テ・ツョツ?\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//テァツ崢エテァツキツ嗔1-p2テ」ツ?ィテァツ崢エテァツキツ嘔1-q2テ」ツ?ョテ、ツコツ、テァツつケ\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//テァツキツ堙・ツ按?1-p2テ」ツ?ィテァツキツ堙・ツ按?1-q2テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool exist_intersection(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//テ・ツケツウティツ。ツ?\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//テ・ツ篠淌ァツつケテ、ツクツュテ・ツソツε・ツ崢榲ィツサツ「\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ崢榲ィツサツ「\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//テ、ツコツ古ァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケテ」ツつ津ィツィツ暗ァツョツ?\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//テ、ツコツ、テァツつケテ」ツ?ェテ」ツ??\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ?\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//ティツァツ」テ」ツ?ェテ」ツ??\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tif(exist_intersection(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//テァツキツ堙・ツ按?ゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(exist_intersection(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ??ゥツδィテ」ツ?ォテァツつケpテ」ツ?古」ツ?づ」ツつ凝」ツ??\nbool contains(const vector<P> &poly,P p,double inf=INF){\n\tint cnt=0;\n\tP q(p.x+inf,p.y);\n\tfor(int i=0;i<poly.size();i++){\n\t\tif(exist_intersection(poly[i],poly[(i+1)%poly.size()],p,q))cnt++;\n\t}\n\treturn cnt&1;\n}\n\n\n//テァツつケpテ」ツつ津ゥツ?堙」ツつ凝・ツ??」ツ?ョテヲツ篠・テァツキツ?\npair<P,P> tangent_CP(double x,double y,double r,P p){\n\t//P q(x,y), m((x+p.x)/2,(y+p.y)/2);\n\tdouble d=sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y))/2;\n\treturn circle_intersection(x,y,r,(x+p.x)/2,(y+p.y)/2,d);\n}\n\n\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tvector<P> poly(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>poly[i].x>>poly[i].y;\n\t\t}\n\t\tP p,q;\n\t\tcin>>p.x>>p.y>>q.x>>q.y;\n\t\tbool a,b;\n\t\ta=contains(poly,p);\n\t\tb=contains(poly,q);\n\t\tcout<<(a&&!b||!a&&b?\"OK\":\"NG\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=9000;\n  q.y=10000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nbool eq(double x,double y){\n  double z=x-y;\n  if(z<0.000000001)return true;\n  else return false;\n}\ndouble S3( double x1, double y1, double x2,double y2, double x3, double y3 ){\n\n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);\n  sum /= 2;\n\n  return sum;\n}\nint n;\ndouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\nint check(double x,double y){\n  double a = S3(xp1,yp1,xp2,yp2,x,y);\n  double b = S3(xp2,yp2,xp3,yp3,x,y);\n  double c = S3(xp3,yp3,xp1,yp1,x,y);\n  double d = S3(xp1,yp1,xp2,yp2,xp3,yp3);\n  if(eq(a+b+c,d)){\n    return 1;\n  }else{\n    return -1;\n  }\n}\n\nint main(){\n  cin>>n;\n  while(n--){\n    cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n    if(check(xk,yk)==check(xs,ys))cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ntypedef pair<double,double>P;\n#define X first\n#define Y second\n\nP sub(P a,P b){\n\treturn P(a.X-b.X,a.Y-b.Y);\n}\n\nint chk(P a,P b,P c,P p){\n\tP ab=sub(b,a);\n\tP bp=sub(p,b);\n\tP bc=sub(c,b);\n\tP cp=sub(p,c);\n\tP ca=sub(a,c);\n\tP ap=sub(p,a);\n\tdouble c1 = ab.X * bp.Y - ab.Y * bp.X;\n\tdouble c2 = bc.X * cp.Y - bc.Y * cp.X;\n\tdouble c3 = ca.X * ap.Y - ca.Y * ap.X;\n\tif( ( c1 > 0 && c2 > 0 && c3 > 0 ) || ( c1 < 0 && c2 < 0 && c3 < 0 ) ) {\n\t\t//三角形の内側に点がある\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\t\n\tint n;cin>>n;\n\twhile(n--){\n\t\tP a,b,c,d,e;\n\t\tcin>>a.X>>a.Y>>b.X>>b.Y>>c.X>>c.Y>>d.X>>d.Y>>e.X>>e.Y;\n\t\tif(chk(a,b,c,d)+chk(a,b,c,e)==1)cout<<\"OK\\n\";\n\t\telse cout<<\"NG\\n\";\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) == ccw(p[0],p[1],o)) &&\n\t\t(ccw(p[1],p[2],p[0]) == ccw(p[1],p[2],o)) &&\n\t\t(ccw(p[2],p[0],p[1]) == ccw(p[2],p[0],o));\n}\n\n\nint main(){\n\tint n; cin>>n;\n\twhile(n--){\n\t\tP p[3],k,s;\n\t\tcin>>p[0]>>p[1]>>p[2]>>k>>s;\n\t\tcout << ((InTri(p,k) ^ InTri(p,s)) ? \"OK\" : \"NG\") << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n\ndouble EPS = 1e-9; \n\nstruct Point {\n    double x, y;\n};\n\nstruct Line {\n\tPoint s, e;\n\tLine (Point _s, Point _e) {\n\t\ts = _s; e = _e;\n\t}\n};\n\ndouble distPointLine(const Point& A, const Line& l) {\n\tdouble a = (l.s.y - l.e.y)/(l.s.x - l.e.x);\n\tdouble c = (-1)*a*l.s.x - l.s.y;\n\treturn fabs(a * A.x + A.y + c)/sqrt(a*a + 1.0);\n}\n\nenum { IN, ON, OUT };\nint PointInTri(const vector<Point>& tri, const Point& p) {\n    int cnt = 0;\n    for (int i=1; i<4; i++) {\n        Point p0 = tri[i-1], p1 = tri[i%3];\n        bool flag0x = (p.x <= p0.x), flag0y = (p.y <= p0.y);\n        bool flag1x = (p.x <= p1.x), flag1y = (p.y <= p1.y);\n        \n        Line p0top1(p0, p1);\n        if (distPointLine(p, p0top1) <= EPS) return ON;\n         \n        if (flag0y != flag1y) {\n            if ( flag1x && flag0x) {\n                cnt += flag0y ? -1 : 1;\n            } else if (p.x <= ( p0.x+(p1.x-p0.x)*(p.y-p0.y)/(p1.y-p0.y) ) ) {\n                cnt += flag0y ? -1 : 1;\n            }\n        }\n    }\n    return cnt!=0 ? IN : OUT;\n}\n \nint main() {\n    int n; cin >> n;\n     \n    vector<Point> tri(3);\n    for (int i=0; i<n; i++) {\n        cin >> tri[0].x >> tri[0].y >> tri[1].x >> tri[1].y >> tri[2].x >> tri[2].y;\n        Point p1; cin >> p1.x >> p1.y;\n        Point p2; cin >> p2.x >> p2.y;\n        bool flag1 = (PointInTri(tri, p1) == IN), flag2 = (PointInTri(tri, p2) == IN);\n        if ( flag1 != flag2 ) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep0(i,n) for(i=0;i<(n);i++)\n#define repn(i,m,n) for(int i=(m);i<=(n);i++)\n#define all(n) n.begin(),n.end()\n#define mp make_pair\n#define PUTLINE cout<<__LINE__<<endl;\n\nconst int INF = 2147483647;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return (x != a.x) ? (x < a.x) : (y < a.y); }\n\tbool operator==(const Pt &a) const { return (sig(x - a.x) == 0 && sig(y - a.y) == 0); }\n};\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(Pt a, Pt b, Pt c) { return (b - a).det(c - a); }\n\nPt proj(Pt a, Pt b) { return a * a.dot(b) / a.abs2(); }\n\nPt perp(Pt a, Pt b, Pt c) { return a + proj(b - a, c - a); }\n\nPt refl(Pt a, Pt b, Pt c) { return perp(a, b, c) * 2 - c; }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\n\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\n\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\n\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\n\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\n\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c;\n\treturn a + b * (c - a).det(d) / b.det(d);\n}\n\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\n\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\n\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\n\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\n\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\n\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\n\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn mp(a + e * x - w, a + e * x + w);\n}\n\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = perp(b, c, a);\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn mp(h - e * y, h + e * y);\n}\n/*\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).norm();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn mp(h - w, h + w);\n}\n*/\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\nint convexhull(int n, Pt p[], Pt q[]) {\n\tint m = 0, i, r;\n\tsort(p, p + n);\n\tfor (i = 0; i < n; q[m++] = p[i++]) for (; m > 1 && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\tfor (i = n - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\treturn m - 1;\n}\n\nint convexcut(int n, Pt p[], Pt a, Pt b, Pt q[]) {\n\tint m = 0, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tif (sig(tri(a, b, p[i])) >= 0) q[m++] = p[i];\n\t\tif (sig(tri(a, b, p[i])) * sig(tri(a, b, p[i + 1])) < 0) q[m++] = pLL(a, b, p[i], p[i + 1]);\n\t}\n\tq[m] = q[0];\n\treturn m;\n}\n\nint sGP(int n, Pt p[], Pt a) {\n\tint side = -1, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tPt p0 = p[i] - a, p1 = p[i + 1] - a;\n\t\tif (sig(p0.det(p1)) == 0 && sig(p0.dot(p1)) <= 0) return 0;\n\t\tif (p0.y > p1.y) swap(p0, p1);\n\t\tif (sig(p0.y) <= 0 && 0 < sig(p1.y) && sig(p0.det(p1)) > 0) side = -side;\n\t}\n\treturn side;\n}\n\nint sVP(int n, Pt p[], Pt a) {\n\tPt o = (p[0] + p[n / 2]) / 2;\n\tint lo = 0, ho = n, fl = sig(tri(o, p[lo], a));\n\tp[n] = p[0];\n\tfor (; lo + 1 < ho; ) {\n\t\tint mo = (lo + ho) / 2, fm = sig(tri(o, p[mo], a));\n\t\t(fl - fm - sig(tri(o, p[lo], p[mo])) < 0) ? (lo = mo, fl = fm) : ho = mo;\n\t}\n\treturn sig(tri(p[lo], p[ho], a));\n}\n\nint sAP(Pt a, Pt b, Pt c) {\n\treturn sig(a.det(c)) - sig(b.det(c)) - sig(a.det(b));\n}\n\ndouble quartercut(double r, double x, double y) {\n\tif (x * x + y * y >= r * r) return 0;\n\tdouble xx = sqrt(r * r - y * y), yy = sqrt(r * r - x * x);\n\treturn (r * r * (atan2(yy, x) - atan2(y, xx)) - (xx - x) * y - x * (yy - y)) / 2;\n}\n\nPt circumcenter(Pt a, Pt b, Pt c) {\n\tPt bc = c - b, ca = a - c, ab = b - a;\n\treturn (b + c - bc * Pt(0, 1) * ca.dot(ab) / ca.det(ab)) / 2;\n}\n\n\nint main() {\n\tint n=in();\n\twhile(n--){\n\t\tPt p1,p2,p3,k,s;\n\t\tcin>>p1.x>>p1.y>>p2.x>>p2.y>>p3.x>>p3.y>>k.x>>k.y>>s.x>>s.y;\n\t\tint count=0;\n\t\tif(iSS(p1,p2,k,s))++count;\n\t\tif(iSS(p2,p3,k,s))++count;\n\t\tif(iSS(p3,p1,k,s))++count;\n\t\tif(count==1)cout<<\"OK\\n\";\n\t\telse cout<<\"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble dot(point a, point b){return (a.x * b.x + a.y * b.y);}\n \ndouble cross(point a, point b){return (a.x * b.y - a.y * b.x);}\n\nint contain(vector<point>pol,point p){\n  bool in=false;\n  for(int i=0;i<pol.size();i++){\n    point a=curr(pol,i)-p,b=next(pol,i)-p;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<=0 && 0<b.y && cross(a,b)<0)in=!in;\n    if(cross(a,b)==0 && dot(a,b)<=0)return 2;\n  }\n  return in?1:0;\n}\n\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(contain(p,k)!=contain(p,s))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint pt(double px,double py,double qx,double qy,double rx,double ry,double sx,double sy){\n  if(((rx-qx)*(py-qy)-(px-qx)*(ry-qy)<=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)<=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)<=0)||\n     ((rx-qx)*(py-qy)-(px-qx)*(ry-qy)>=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)>=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)>=0))\n    return 1;\n  return 0;\n}\nint main(){\n  int h,i;\n  int n;\n  cin>>n;\n  for(h=0;h<n;h++){\n    int x[5],y[5];\n    for(i=0;i<5;i++)\n      cin>>x[i]>>y[i];\n    if(pt(x[3],y[3],x[0],y[0],x[1],y[1],x[2],y[2])^\n       pt(x[4],y[4],x[0],y[0],x[1],y[1],x[2],y[2]))\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\ntypedef complex<int> Point;\n\nint cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nbool in(Point p,Point t[])\n{\n\tint c[3];\n\trep(i,3)\n\t\tc[i]=cross(t[(i+1)%3]-t[i],p-t[i]);\n\treturn count_if(c,c+3,bind2nd(less<int>(),0))%3==0;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(tc,n){\n\t\tPoint t[3],m,w;\n\t\trep(i,3)\n\t\t\tcin>>real(t[i])>>imag(t[i]);\n\t\tcin>>real(m)>>imag(m)>>real(w)>>imag(w);\n\t\tbool inm=in(m,t);\n\t\tbool inw=in(w,t);\n\t\tputs(inm!=inw?\"OK\":\"NG\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x*C.y>0&&C.x+C.y<1;}main(){cin>>A.x;while(cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y){A-=C;B-=C;S-=C;G-=C;X(S)^X(G)?cout<<\"OK\":cout<<\"NG\";cout<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_intersected_ls(point p1, point p2, point p3, point p4) {\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0)&&\n         (ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[3],y[3];\nint isin(int px,int py){\n\tbool ok=true;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tbool plus=false;\n\t\t\tif(x[(i+1)%3]==x[(i+2)%3]){\n\t\t\t\tif(x[i]>x[(i+1)%3])plus=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a,b;\n\t\t\t\ta=(x[i]-x[(i+1)%3])*(y[(i+2)%3]-y[(i+1)%3]);\n\t\t\t\tb=(y[i]-y[(i+1)%3])*(x[(i+2)%3]-x[(i+1)%3]);\n\t\t\t\tif(a>b)plus=true;\n\t\t\t}\n\t\t\tbool pnt=false;\n\t\t\tif(x[(i+1)%3]==x[(i+2)%3]){\n\t\t\t\tif(px>x[(i+1)%3])pnt=true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint a,b;\n\t\t\t\ta=(px-x[(i+1)%3])*(y[(i+2)%3]-y[(i+1)%3]);\n\t\t\t\tb=(py-y[(i+1)%3])*(x[(i+2)%3]-x[(i+1)%3]);\n\t\t\t\tif(a>b)pnt=true;\n\t\t\t}\n\t\t\tif(pnt!=plus)ok=false;\n\t\t}\n\t\tif(ok)return 1;\n\t\telse return 0;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int u=0;u<n;u++){\n\tfor(int i=0;i<3;i++)cin>>x[i]>>y[i];\n\tint px,py,gx,gy;\n\tcin>>px>>py>>gx>>gy;\n\tif(isin(px,py)==isin(gx,gy))cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x>0&&C.y>0&&C.x+C.y<1;}main(){cin>>A.x;while(cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y){A-=C;B-=C;S-=C;G-=C;X(S)^X(G)?cout<<\"OK\":cout<<\"NG\";cout<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\t  cnt+=is_intersected_ls(p[i],p[j],k,s);\n    \n    if(cnt%2)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nstruct P{\n\tdouble x, y;\n};\n\ntypedef P Vector;\n\nstruct Triangle{\n\tP ps[3];\n};\n\nint crossProduct(Vector v1, Vector v2){\n\treturn v1.x*v2.y - v1.y*v2.x;\n}\n\nVector pToVector(P p1, P p2){\n\treturn {p1.x-p2.x, p1.y-p2.y};\n}\n\nbool triangle_contains(Triangle t, P p){\n\tint count = 0;\n\tfor(int i=0;i<3;i++){\n\t\tVector a = pToVector(t.ps[i], t.ps[(i+1)%3]),\n\t\t\tb = pToVector(p, t.ps[i]);\n\t\tif(crossProduct(a, b) > 0)count++;\n\t\telse count--;\n\t}\n\treturn (count%3 != 0);\n}\n\nint main(){\n\tint n;\n\tstd::cin >> n;\n\tfor(;n--;){\n\t\tP ps[3], k, s;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tstd::cin >> ps[i].x >> ps[i].y;\n\t\t}\n\t\tstd::cin >> k.x >> k.y >> s.x >> s.y;\n\t\tTriangle t;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tt.ps[i] = ps[i];\n\t\t}\n\t\tbool k_contains = triangle_contains(t, k),\n\t\t\ts_contains = triangle_contains(t, s);\n\t\tif(k_contains != s_contains){\n\t\t\tputs(\"OK\");\n\t\t}else{\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include<complex>\n\ntypedef complex<double> Point;\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\nint ccw(Point a, Point b, Point c){\n  b -= a; c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nenum{ OUT, ON, IN };\nint contains(Point a, Point b, Point c, Point p){\n  int A = ccw(a, b, p);\n  int B = ccw(b, c, p);\n  int C = ccw(c, a, p);\n  if(A == B && B == C && abs(A) == 1) return IN;\n  return OUT;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  while(N--){\n    Point a[3];\n    Point b[2];\n    REP(i, 3) cin >> a[i].real() >> a[i].imag();\n    REP(i, 2) cin >> b[i].real() >> b[i].imag();\n    if(abs(ccw(a[0], a[1], a[2])) == 1 && contains(a[0], a[1], a[2], b[0]) != contains(a[0], a[1], a[2], b[1])){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tG g(3);\n\t\tPIN(&g[0],3);\n\t\tP a=pin(),b=pin();\n\t\tint ha=inconvex(g,a);\n\t\tint hb=inconvex(g,b);\n\t\tif((ha&&hb)||(ha==0&&hb==0))cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=1000;\n  q.y=1000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[8],y[8],a,b,c,d,p,q,det;\n        //入力を多少簡略化\n        for(int i=0;i<8;i++) {\n            cin >> x[i] >> y[i];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            a = y[j]-y[j+1];  b = x[j+1]-x[j];\n            p = x[j+1]*y[j]-x[j]*y[j+1];\n            //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n            c = y[6]-y[7];  d = x[7]-x[6];\n            q = x[7]*y[6]-x[6]*y[7];\n            //係数についての行列式\n            det = a*d-c*b;\n            //det=0で解は存在しない(この問題については２線分は同一直線上にないから)\n            if(fabs(det) < 0.00001){\n            } else {\n                ansx = (d*p - b*q)/det;\n                ansy = (-c*p + a*q)/det;\n                //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                if((x[0] - ansx)*(x[1] - ansx) <= 0.00001 && (x[6] - ansx)*(x[7] - ansx) <= 0.00001 ) {\n                    count++;\n                }\n            }\n        }\n        if(count == 1) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long double ld;\ntypedef vector<int> vi;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nbool isin(int a,int b,int c,int d,int p,int q)\n{\n\t//printf(\"%d %d %d %d %d %d\\n\",a,b,c,d,p,q);\n\tld s,t;\n\tld A=a,B=b,C=c,D=d,P=p,Q=q;\n\tif(b==0)\n\t{\n\t\tt=Q/D;\n\t\ts=P/A-(C*Q)/(A*D);\n\t\t//cout << s << ' ' << t << endl;\n\t\tif(s>0&&t>0&&s+t<1)return true;\n\t\telse return false;\n\t}\n\tif(a==0)\n\t{\n\t\tt=P/C;\n\t\ts=Q/B-(D*Q)/(B*C);\n\t\t//cout << s << ' ' << t << endl;\n\t\tif(s>0&&t>0&&s+t<1)return true;\n\t\telse return false;\n\t}\n\tt=(P*B-A*Q)/(B*C-A*D);\n\ts=(P-C*t)/A;\n\t//cout << s << ' ' << t << endl;\n\tif(s>0&&t>0&&s+t<1)return true;\n\telse return false;\n}\nint main()\n{\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tint x1,x2,x3,y1,y2,y3,xk,yk,xs,ys;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d %d %d %d %d\",&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tint a,b,c,d,p,q,r,s;\n\t\ta=x2-x1;\n\t\tb=y2-y1;\n\t\tc=x3-x1;\n\t\td=y3-y1;\n\t\tp=xk-x1;\n\t\tq=yk-y1;\n\t\tr=xs-x1;\n\t\ts=ys-y1;\n\t\tbool orihime = isin(a,b,c,d,p,q);\n\t\tbool kengyu = isin(a,b,c,d,r,s);\n\t\tif(kengyu!=orihime)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-10)\n \nD dot(P a, P b)\n{\n    return real(conj(a) * b);\n}\n \nD cross(P a, P b)\n{\n    return imag(conj(a) * b);\n} \n \nint ccw(P p0, P p1, P p2)\n{\n    P a = p1 - p0;\n    P b = p2 - p0;\n  \n    if (cross(a,b) > EPS) return 1;\n    if (cross(a,b) < -EPS) return -1;\n    if (dot(a,b) < -EPS) return 2;\n    if (norm(a) < norm(b)) return -2;\n    return 0;\n}\n \nbool check(P p1, P p2, P p3, P p4)\n{\n    return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t    ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n  \nint main()\n{\n    int n;\n    P P[3], T[2];\n  \n    scanf(\"%d\", &n);\n    while (n--) {\n\tfor (int i = 0; i < 3; i++) {\n\t    scanf(\"%lf %lf\", &P[i].real(), &P[i].imag());\n\t}\n \n\tfor (int i = 0; i < 2; i++) {\n\t    scanf(\"%lf %lf\", &T[i].real(), &T[i].imag());\n\t}\n \n\tint cnt = 0; \n\tif (check(P[0], P[1], T[0], T[1])) {\n\t    cnt++;\n\t}   \n\tif (check(P[0], P[2], T[0], T[1])) {\n\t    cnt++;\n\t} \n\tif (check(P[1], P[2], T[0], T[1])) {\n\t    cnt++;\n\t} \n\tif (cnt % 2) {\n\t    puts(\"OK\");\n\t} else {\n\t    puts(\"NG\");\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint hantei(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n\tdouble x,y,m,n,d;\n\tif (dx-cx!=0) m=(dy-cy)/(dx-cx);\n\tif (bx-ax!=0) n=(by-ay)/(bx-ax);\n\tif (ay==by) {\n\t\tif (cx==dx && ((cx>ax && cx<bx) || (cx>bx && cx<ax)) && ((cy<ay && dy>ay) || (dy<ay && cy>ay))) return 1;\n        x=(ay-cy+m*cx)/m;\n        if ((x>cx && x<dx) || (x>dx && x<cx)) return 1;\n\t\treturn 0;\n\t}\n\tif (ax==bx) {\n        if (cy==dy && ((cy>ay && cy<by) || (cy>by && cy<ay)) && ((cx<ax && dx>ax) || (dx<ax && cx>ax))) return 1;\n        y=cy+m*(ax-cx);\n\t\tif ((y>ay && y<by) || (y>by && y<ay)) return 1;\n\t\treturn 0;\n\t}\n\tif (cy==dy) { x=(cy-ay+n*ax)/n;\tif ((x>cx && x<dx) || (x>dx && x<cx)) return 1; else return 0; }\n\tif (cx==dx) { y=ay+n*(cx-ax); if ((y>cy && y<dy) || (y>dy && y<cy)) return 1; else return 0;}\n\tif (m==n) return 0;\n    d=(ay-cy+m*cx-n*ax)/(m-n);\n\tif ((d>cx && d<dx) || (d>dx && d<cx)) return 1;\n\treturn 0;\n}\n\nint main() {\n\tint n,f;\n\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\tcin >> n;\n\tfor (;n>0;n--) {\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        f=hantei(xp1,yp1,xp2,yp2,xk,yk,xs,ys)+hantei(xp2,yp2,xp3,yp3,xk,yk,xs,ys)+hantei(xp1,yp1,xp3,yp3,xk,yk,xs,ys);\n\t\tif (f==1) cout << \"OK\"; else cout << \"NG\";\n\t\tcout << endl;\n\t}\nreturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌÏªÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tbool f=false;\n\t//P tp=(p1+p2+p3);\n\t//tp = P(tp.real()/3,tp.imag()/3);\n\t//P ta=p1-tp;\n\t//P tb=p2-tp;\n\t//P tc=p3-tp;\n\t//f = (cross(ta,tb)*cross(tb,tc)*cross(tc,ta))>0;\n\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tcin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n\t\tP p1(xp1,yp1);\n\t\tP p2(xp2,yp2);\n\t\tP p3(xp3,yp3);\n\t\tP k(xk,yk);\n\t\tP s(xs,ys);\n\t\t// ¼ûÆàOp`ÌàÉ_ª éê\n\t\tif(isInTriangle(p1,p2,p3,k)&&isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t// ¼ûÆàOp`ÌOÉ_ª éê\n\t\telse if(!isInTriangle(p1,p2,p3,k)&&!isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"OK\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        //入力を多少簡略化\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    ansy = (-c*p + a*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.para(l)){\n\tl.a.imag() += 1e-6;\n\tl.b.imag() += 1e-6;\n      }\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.para(l)){\n      l.a.imag() += 1e-6;\n      l.b.imag() += 1e-6;\n    }\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\nusing namespace std;\n\n#define x first \n#define y second \n\ntypedef pair<double,double> pdd;\n\nbool inTriangle(pdd o, pdd tri0, pdd tri1, pdd pts) {\n\tpdd a, b, c;\n\ta.x = tri0.x - o.x;\n\ta.y = tri0.y - o.y;\n\tb.x = tri1.x - o.x;\n\tb.y = tri1.y - o.y;\n\tc.x = pts.x - o.x;\n\tc.y = pts.y - o.y;\n\n\tdouble s, t;\n\tt = (c.x * a.y - c.y * a.x) / (b.x * a.y - b.y * a.x);\n\ts = (c.x * b.y - c.y * b.x) / (b.y * a.x - b.x * a.y);\n\n\tif(s >= 0 && t >= 0 && s + t <= 1)\n\t\treturn true;\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor(int t = 0; t < n; t++) {\n\t\tpdd in[5];\n\t\tfor(int i = 0; i < 5; i++) {\n\t\t\tcin >> in[i].x >> in[i].y;\n\t\t}\n\n\t\tbool flag;\n\t\tflag = inTriangle(in[0], in[1], in[2], in[3]) ^ inTriangle(in[0], in[1], in[2], in[4]);\n\t\tif(flag)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double D; \n#define EPS (1e-5)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nD add(D a,D b){\n  if(abs(a + b) < EPS * (abs(a) + abs(b))){\n    return 0;\n  }\n  return a + b;\n}\n\nstruct Point{\n  D x,y;\n\n  Point (D x = 0, D y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point(add(x,p.x) , add(y,p.y));\n  }\n  Point operator - (Point p) {\n    return Point(add(x,p.x) ,add(y,-p.y));\n  }\n  Point operator * (D a) {\n    return Point( a*x , a*y );\n  }\n  \n  D norm() {\n    return x*x+y*y;\n  }\n\n  D dot(Point p){\n    return add(x*p.x , y*p.y);\n  }\n\n  D det(Point p){\n    return add(x*p.y , -y*p.x);\n  }  \n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n\n  if(a.det(b) > EPS) return 1;\n  if(a.det(b) < -EPS) return -1;\n  if(a.dot(b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nD S(Point p1,Point p2,Point p3){\n  D a = sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));\n  D b = sqrt(pow(p1.x-p3.x,2) + pow(p1.y-p3.y,2));\n  D c = sqrt(pow(p3.x-p2.x,2) + pow(p3.y-p2.y,2));\n  D s = (a + b + c) / 2;\n\n  return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nbool check(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0);\n}\n\nbool eq(D S1,D S2){\n  return ((float)S1 == (float)S2);\n}\n\nint main(){\n  int n;\n  Point P[3],T[2];\n\n  cin >> n;\n  while(n--){\n    scanf(\"%lf %lf\" ,&P[0].x ,&P[0].y);\n    scanf(\"%lf %lf\" ,&P[1].x ,&P[1].y);\n    scanf(\"%lf %lf\" ,&P[2].x ,&P[2].y);\n    scanf(\"%lf %lf\" ,&T[0].x ,&T[0].y);\n    scanf(\"%lf %lf\" ,&T[1].x ,&T[1].y);\n\n    bool ok = false;\n    D S1 = S(P[0],P[1],P[2]);\n    D S2 = S(P[0],P[1],T[0])+S(P[0],P[2],T[0])+S(P[1],P[2],T[0]);\n    D S3 = S(P[0],P[1],T[1])+S(P[0],P[2],T[1])+S(P[1],P[2],T[1]);\n\n    if(check(P[0],P[1],T[0],T[1]) &&\n       ((eq(S1,S2) && !eq(S1,S3)) || \n\t(!eq(S1,S2) && eq(S1,S3)))){\n      ok = true;\n    }    \n    if(check(P[0],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n    if(check(P[1],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n\n    if(ok){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#define EPS 1e-10\nstruct vektor{\n\tdouble x,y;\n\tvektor(){}\n\tvektor(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tvektor operator +(vektor v){\n\t\treturn vektor(x+v.x,y+v.y);\n\t}\n\n\tvektor operator -(vektor v){\n\t\treturn vektor(x-v.x,y-v.y);\n\t}\n\tvektor operator *(double d){\n\t\treturn vektor(x*d,y*d);\n\t}\n};\n\nint n;\nvektor vek[5];\n\nbool check(){\n\tvektor v[5];\n\tfor(int i=1;i<=4;i++){\n\t\tv[i]=vek[i]-vek[0];\n\t}\n\tdouble s=(v[3].x*v[2].y-v[3].y*v[2].x)/(v[1].x*v[2].y-v[1].y*v[2].x);\n\tdouble t=(v[3].x*v[1].y-v[3].y*v[1].x)/(v[1].y*v[2].x-v[1].x*v[2].y);\n\tint data3,data4;\n\tif(s>0 && t>0 && s+t<1)data3=1;\n\telse data3=-1;\n\ts=(v[4].x*v[2].y-v[4].y*v[2].x)/(v[1].x*v[2].y-v[1].y*v[2].x);\n\tt=(v[4].x*v[1].y-v[4].y*v[1].x)/(v[1].y*v[2].x-v[1].x*v[2].y);\n\tif(s>0 && t>0 && s+t<1)data4=1;\n\telse data4=-1;\n\treturn data3*data4<0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tscanf(\"%lf %lf\",&vek[j].x,&vek[j].y);\n\t\t}\n\t\tbool flag=check();\n\t\tprintf(\"%s\\n\",flag?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\n\ndouble EPS = 1e-10;\n\n\n\n// ??????????????????????¶????????????????\ndouble add(double a,double b){\n\tif(abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\n// ????¬?????????????????§???????\nstruct P {\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y) : x(x), y(y){\n\t}\n\tP operator + (P p){\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x * d, y * d);\n\t}\n\tdouble dot(P p){\t// ??????\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\tdouble det(P p){\t// ??????\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\nint main(){\n\tint n;\n\tvector<P> p(5);\n\tcin>>n;\n\twhile(n--){\n\t\trep(i, 5) cin>>p[i].x>>p[i].y;\n\t\tbool f1 =true, f2 = true;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif((p[3]-p[i]).det(p[(i+1)%3]-p[i])>0\n\t\t\t\t!=(p[3]-p[(i+1)%3]).det(p[(i+2)%3]-p[(i+1)%3])>0){\n\t\t\t\tf1 = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(((p[4]-p[i]).det(p[(i+1)%3]-p[i])>0)\n\t\t\t\t!=((p[4]-p[(i+1)%3]).det(p[(i+2)%3]-p[(i+1)%3])>0)){\n\t\t\t\tf2 = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<(f1^f2?\"OK\":\"NG\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<cmath>\n#define int long long\n#define mod 1000000007\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nint get() { int r; cin >> r; return r; }\nvoid solve() {\n\tdouble x[5], y[5], xs, ys, xt, yt;\n\tcin >> x[1] >> y[1] >> x[2] >> y[2] >> x[0] >> y[0] >> xs >> ys >> xt >> yt;\n\tint i1 = 1, i2 = 1, a = 1, b = 2, c = 0;\n\tfor1(i, 3) {\n\t\tif (((x[a] - x[b]) * (ys - y[a]) - (y[a] - y[b]) * (xs - x[a])) * ((x[a] - x[b]) * (y[c] - y[a]) - (y[a] - y[b]) * (x[c] - x[a])) < 0)i1 = 0;\n\t\tif (((x[a] - x[b]) * (yt - y[a]) - (y[a] - y[b]) * (xt - x[a])) * ((x[a] - x[b]) * (y[c] - y[a]) - (y[a] - y[b]) * (x[c] - x[a])) < 0)i2 = 0;\n\t\ta++; b++; c++;\n\t\tif (a >= 3)a %= 3;\n\t\tif (b >= 3)b %= 3;\n\t\tif (c >= 3)c %= 3;\n\t}\n\tcout << (i1 + i2 == 1 ? \"OK\\n\" : \"NG\\n\");\n}\nsigned main() {\n\tint n; cin >> n; for1(i, n)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[j+1]) > EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[0]) > EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <vector>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n\nusing namespace std;\n\ndouble cross_product( double x1, double y1, double x2, double y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\nint main( void )\n{\n\tint n;\n\t\n\twhile (cin >> n)\n\t{\n\t\tfor (int i=0; i < n; ++i)\n\t\t{\n\t\t\tdouble x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3\n\t\t\t\t>> xk >> yk >> xs >> ys;\n\t\t\t\n\t\t\tdouble v1, v2, v3, v4, v5, v6;\n\t\t\n\t\t\tv1 = cross_product((x2-x1), (y2-y1), (xk-x1), (yk-y1));\n\t\t\tv2 = cross_product((x3-x2), (y3-y2), (xk-x2), (yk-y2));\n\t\t\tv3 = cross_product((x1-x3), (y1-y3), (xk-x3), (yk-y3));\n\t\t\n\t\t\tv4 = cross_product((x2-x1), (y2-y1), (xs-x1), (ys-y1));\n\t\t\tv5 = cross_product((x3-x2), (y3-y2), (xs-x2), (ys-y2));\n\t\t\tv6 = cross_product((x1-x3), (y1-y3), (xs-x3), (ys-y3));\n\t\t\n\t\t\tif (((v1 > 0) && (v2 > 0) && (v3 > 0) &&\n\t\t\t\t((v4 < 0) || (v5 < 0) || (v6 < 0))) ||\n\t\t\t\t((v4 > 0) && (v5 > 0) && (v6 > 0) &&\n\t\t\t\t((v1 < 0) || (v2 < 0) || (v3 < 0)))\n\t\t\t\t)\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-5)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nstruct Point{\n  int x;\n  int y;\n}typedef point;\n\nbool contain(point* p1, point* p2, point* p3, point* p);\n\nint main(void){\n  int n;\n  cin>>n;\n  int xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n  point p1,p2,p3,pk,ps;\n  bool s,k;\n  for(int i=0;i<n;i++){\n    cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n    p1.x=xp1;\n    p1.y=yp1;\n    p2.x=xp2;\n    p2.y=yp2;\n    p3.x=xp3;\n    p3.y=yp3;\n    pk.x=xk;\n    pk.y=yk;\n    ps.x=xs;\n    ps.y=ys;\n    s=contain(&p1,&p2,&p3,&ps);\n    k=contain(&p1,&p2,&p3,&pk);\n    if(s==k){\n      cout<<\"NG\"<<endl;\n    }\n    else{\n      cout<<\"OK\"<<endl;\n    }\n  }\n  return 0;\n}\n\nbool contain(point* p1, point* p2, point* p3, point* p){\n  int z1=0;\n  int z2=0;\n  z1+=(p1->x-p->x)*(p2->y-p->y)-(p2->x-p->x)*(p1->y-p->y);\n  z2+=abs((p1->x-p->x)*(p2->y-p->y)-(p2->x-p->x)*(p1->y-p->y));\n  z1+=(p2->x-p->x)*(p3->y-p->y)-(p3->x-p->x)*(p2->y-p->y);\n  z2+=abs((p2->x-p->x)*(p3->y-p->y)-(p3->x-p->x)*(p2->y-p->y));\n  z1+=(p3->x-p->x)*(p1->y-p->y)-(p1->x-p->x)*(p3->y-p->y);\n  z2+=abs((p3->x-p->x)*(p1->y-p->y)-(p1->x-p->x)*(p3->y-p->y));\n  if(abs(z1)==z2){\n    return true;\n  }\n  else{\n    return false;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nclass Point{\npublic:\n\tint x;\n\tint y;\n\n\tPoint(int x = 0, int y = 0){\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t}\n\n\tint dot(Point other){\n\t\tint d =  (*this).x*other.x + (*this).y*other.y;\n\t\treturn (*this).x*other.x + (*this).y*other.y;\n\t}\n\n\tint cross(Point other){\n\t\treturn (*this).x*other.y - (*this).y*other.x;\n\t}\n\n\tint distsq(Point other){\n\t\t//int dx = (*this).x-other.x;\n\t\t//int dy = (*this).y-other.y;\n\t\treturn ((*this).x-other.x)*((*this).x-other.x)+((*this).y-other.y)*((*this).y-other.y);\n\t}\n\n\tPoint operator+(Point other){\n\t\tPoint p;\n\t\tp.x = (*this).x + other.x;\n\t\tp.y = (*this).y + other.y;\n\t\treturn p;\n\t}\n\n\tPoint operator+=(Point other){\n\t\t(*this) = (*this)+other;\n\t\treturn (*this);\n\t}\n\n\tPoint operator-(Point other){\n\t\tPoint p;\n\t\tp.x = (*this).x - other.x;\n\t\tp.y = (*this).y - other.y;\n\t\treturn p;\n\t}\n\n\tPoint operator-=(Point other){\n\t\t(*this) = (*this)-other;\n\t\treturn (*this);\n\t}\n\n\t// cout 出力用\n   friend ostream& operator << (ostream& os, const Point& p){\n\t   os << '(' << p.x << \", \" << p.y << ')';\n\t   return os;\n   }\n\n};\n\nclass Triangle{\npublic:\n\tPoint vertex[3];\n\n\tTriangle(Point a = Point(0,0), Point b = Point(0,0), Point c = Point(0,0)){\n\t\tvertex[0] = a;\n\t\tvertex[1] = b;\n\t\tvertex[2] = c;\n\t}\n\n\tbool isInclude(Point p){\n\t\t// 三角形ABCと点Pに関し、3つの外積 AB×AP, BC×BP, CA×CPの符号が同じであれば三角形の中\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tPoint vs = vertex[(i+1)%3] - vertex[i]; // 辺のベクトル\n\t\t\tPoint vp = p - vertex[i];\t\t\t\t// 各辺の始点→点Pのベクトル\n\t\t\tcnt += (vs.cross(vp) > 0)?1:-1;\n\t\t}\n\t\tcnt = (cnt>0)?cnt:-cnt;\n\t\tif(cnt == 3) return true;\n\t\telse return false;\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\twhile(n--){\n\t\tTriangle wall;\n\t\tPoint a, b;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tcin >> wall.vertex[i].x >> wall.vertex[i].y;\n\t\t}\n\t\tcin >> a.x >> a.y >> b.x >> b.y;\n\n\t\tif(wall.isInclude(a)^wall.isInclude(b)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Point\n{\n\tPoint(int x, int y):x(x),y(y),z(0){}\n\tPoint():x(0),y(0),z(0){}\n\tint x,y,z;\n};\ninline bool isLeft( Point &p, Point &a, Point &b ){\n\treturn ( (b.x-a.x)*(p.y-a.y) - (b.y-a.y)*(p.x-a.x) ) > 0;\n}\nbool isInside( Point &p, vector<Point> &vp ){\n\tbool bCond = isLeft( p, vp[0], vp[1] );\n\tfor(unsigned int i = 1; i < vp.size(); ++i){\n\t\tif( bCond != isLeft( p, vp[i-1], vp[i] ) )\n\t\t\treturn false;\n\t}\n\treturn bCond == isLeft( p, vp[vp.size()-1], vp[0] );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int X = 0; X < n; ++X ){\n\t\tPoint A, B, C, ken, ori;\n\t\tbool  bKenInside = false, bOriInside = false;\n\t\tvector<Point> triangle;\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> ken.x >> ken.y >> ori.x >> ori.y;\n\t\ttriangle.push_back(A);triangle.push_back(B);triangle.push_back(C);\n\n\t\tbKenInside = isInside( ken, triangle );\n\t\tbOriInside = isInside( ori, triangle );\n\t\tif( bKenInside ^ bOriInside )\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// CCW 関数　a -> b -> c と進むとき、反時計回りなら 1, 直進なら 0, 時計回りなら -1\n// include : cross\nint ccw( const Point &a, const Point &b, const Point &c )\n{\n\tif ( cross( ( b - a ), ( c - a ) ) < -EPS )\n\t{\n\t\treturn -1;\n\t}\n\telse if ( EPS < cross( ( b - a ), ( c - a ) ) )\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n// 点 p が多角形 qs の内部にあるか ( Winding Number Algorithm) :TODO\n// include : ccw\nbool point_in_polygon( const Point &p, const vector<Point> &qs )\n{\n\tconst int N = qs.size();\n\t\n\tint wn = 0;\n\tfor ( int i = 0; i < N; ++i )\n\t{\n\t\tconst Point &s = qs[i], &t = qs[ ( i + 1 ) % N ];\n\t\tif ( s.imag() - EPS <= t.imag() && s.imag() - EPS < p.imag() && p.imag() + EPS < t.imag() ) // 上向きの辺\n\t\t{\n\t\t\twn += ccw( s, p, t ) == -1;\n\t\t}\n\t\telse if ( t.imag() - EPS <= s.imag() && t.imag() - EPS < p.imag() && p.imag() + EPS < s.imag() )\n\t\t{\n\t\t\twn -= ccw( t, p, s ) == -1;\n\t\t}\n\t}\n\treturn wn;\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\tREP( i, 0, n )\n\t{\n\t\tvector<Point> tri( 3 );\n\t\tREP( j, 0, 3 )\n\t\t{\n\t\t\tcin >> tri[j];\n\t\t}\n\t\tPoint s, t;\n\t\tcin >> s >> t;\n\n\t\tcout << ( point_in_polygon( s, tri ) ^ point_in_polygon( t, tri ) ? \"OK\" : \"NG\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double D; \n#define EPS (1e-10)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nD add(D a,D b){\n  if(abs(a + b) < EPS * (abs(a) + abs(b))){\n    return 0;\n  }\n  return a + b;\n}\n\nstruct Point{\n  D x,y;\n\n  Point (D x = 0, D y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point(add(x,p.x) , add(y,p.y));\n  }\n  Point operator - (Point p) {\n    return Point(add(x,p.x) ,add(y,-p.y));\n  }\n  Point operator * (D a) {\n    return Point( a*x , a*y );\n  }\n  \n  D norm() {\n    return x*x+y*y;\n  }\n\n  D dot(Point p){\n    return add(x*p.x , y*p.y);\n  }\n\n  D det(Point p){\n    return add(x*p.y , -y*p.x);\n  }  \n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n\n  if(a.det(b) > EPS) return 1;\n  if(a.det(b) < -EPS) return -1;\n  if(a.dot(b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nD S(Point p1,Point p2,Point p3){\n  D a = sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));\n  D b = sqrt(pow(p1.x-p3.x,2) + pow(p1.y-p3.y,2));\n  D c = sqrt(pow(p3.x-p2.x,2) + pow(p3.y-p2.y,2));\n  D s = (a + b + c) / 2;\n\n  return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nbool check(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0);\n}\n\nbool eq(D S1,D S2){\n  return ((float)S1 == (float)S2);\n}\n\nint main(){\n  int n;\n  Point P[3],T[2];\n\n  cin >> n;\n  while(n--){\n    scanf(\"%lf %lf\" ,&P[0].x ,&P[0].y);\n    scanf(\"%lf %lf\" ,&P[1].x ,&P[1].y);\n    scanf(\"%lf %lf\" ,&P[2].x ,&P[2].y);\n    scanf(\"%lf %lf\" ,&T[0].x ,&T[0].y);\n    scanf(\"%lf %lf\" ,&T[1].x ,&T[1].y);\n\n    bool ok = false;\n    D S1 = S(P[0],P[1],P[2]);\n    D S2 = S(P[0],P[1],T[0])+S(P[0],P[2],T[0])+S(P[1],P[2],T[0]);\n    D S3 = S(P[0],P[1],T[1])+S(P[0],P[2],T[1])+S(P[1],P[2],T[1]);\n\n    if(check(P[0],P[1],T[0],T[1]) &&\n       ((eq(S1,S2) && !eq(S1,S3)) || \n\t(!eq(S1,S2) && eq(S1,S3)))){\n      ok = true;\n    }    \n    if(check(P[0],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n    if(check(P[1],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n\n    if(ok){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[j+1]) > EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[0]) > EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[8],y[8],a,b,c,d,p,q,det;\n        //入力を多少簡略化\n        for(int k=0;k<8;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            a = y[j]-y[j+1];  b = x[j+1]-x[j];\n            p = x[j+1]*y[j]-x[j]*y[j+1];\n            //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n            c = y[6]-y[7];  d = x[7]-x[6];\n            q = x[7]*y[6]-x[6]*y[7];\n            //係数についての行列式\n            det = a*d-c*b;\n            //det=0で解は存在しない(この問題については２線分は同一直線上にないから)\n            if(fabs(det) < 0.00001){\n            } else {\n                ansx = (d*p - b*q)/det;\n                ansy = (-c*p + a*q)/det;\n                //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                if((x[0] - ansx)*(x[1] - ansx) <= 0.00001 && (x[6] - ansx)*(x[7] - ansx) <= 0.00001 ) {\n                    count++;\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n \n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n\n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n\n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n\n    // (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n    // targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& p1, const point& p2, const point& p3, const point& target)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n} // namespace geometry\n\n\nusing namespace geometry;\nusing namespace std;\n\n//-----------------------------------------------\n//\n\nclass person {\npublic:\n\tperson(const point& p) : m_p(p) {}\n\tconst point& location() const { return m_p; }\nprivate:\n\tpoint m_p;\n};\n\nclass triangle_wall {\npublic:\n\ttriangle_wall(const point points[3]) {\n\t\tstd::copy(points, points + 3, m_p);\n\t}\n\n\tbool can_isolate(const person& p1, const person& p2) const {\n\t\treturn is_inside_wall(p1.location()) != is_inside_wall(p2.location());\n\t}\nprivate:\n\tbool is_inside_wall(const point& p) const {\n\t\treturn is_inside_triangle(m_p[0], m_p[1], m_p[2], p);\n\t}\n\tpoint m_p[3];\n};\n\n//-----------------------------------------------\n//\n\nint main(void) {\n\tint n;\n\tpoint triangle[3];\n\tpoint pk, ps;\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> triangle[0] >> triangle[1] >> triangle [2] >> pk >> ps;\n\n\t\ttriangle_wall wall(triangle);\n\t\tperson kengyu(pk), shokujyo(ps);\n\n\t\tcout << (wall.can_isolate(kengyu, shokujyo) ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 0.000001\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        //入力を多少簡略化\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n\n# define INF ((int)(1<<30))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\n\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double k) { return Point(x * k, y * k); }\n\tPoint operator / (double k) { return Point(x / k, y / k); }\n\tbool operator < (const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator ==(const Point &p)const { return fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ntypedef Point Vector;\nstruct Segment\n{\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }//??????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }//??????\nbool isOrthogonal(Vector a, Vector b) { return fabs(dot(a, b)) < EPS; }//??´??????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) { return isOrthogonal(a1 - a2, b1 - b2); }\nbool isOrthogonal(Line l1, Line l2) { return fabs(dot(l1.p2 - l1.p1, l2.p2 - l2.p1)) < EPS; }\nbool isParallel(Vector a, Vector b) { return fabs(cross(a, b)) < EPS; }//?????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2) { return isParallel(a1 - a2, b1 - b2); }\nbool isParallel(Line l1, Line l2) { return fabs(cross(l1.p2 - l1.p1, l2.p2 - l2.p1)) < EPS; }\nPoint project(Line s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nbool hoge(Vector a, Vector b, Vector c, Vector p)\n{\n\tdouble cr1 = cross(b-a, p-b);\n\tdouble cr2 = cross(c-b, p-c);\n\tdouble cr3 = cross(a-c, p-a);\n\tif ((cr1 > 0 && cr2 > 0 && cr3 > 0) || (cr1 < 0 && cr2 < 0 && cr3 < 0))return false;\n\treturn true;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tVector p[3], k, s;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t}\n\t\tcin >> k.x >> k.y;\n\t\tcin >> s.x >> s.y;\n\t\tif (hoge(p[0], p[1], p[2], k) != hoge(p[0], p[1], p[2], s))cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool in_tri(const P& p, const VP& tri){\n    return dot(tri[1]-tri[0], p-tri[0])>0 &&\n        dot(tri[2]-tri[1], p-tri[1])>0 &&\n        dot(tri[0]-tri[2], p-tri[2])>0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0; i<n; i++){\n        VP tri(3);\n        for(int j=0; j<3; j++){\n            int x,y;\n            cin >> x >> y;\n            tri[j] = P(x,y);\n        }\n        VP sg(2);\n        for(int j=0; j<2; j++){\n            int x,y;\n            cin >> x >> y;\n            sg[j] = P(x,y);\n        }\n        if(in_tri(sg[0], tri) != in_tri(sg[1], tri)){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XYテ・ツコツァテヲツィツ?\n#define X real()\n#define Y imag()\n\n// * テァツつケテ」ツ?ョティツ。ツィテァツ渉セ\ntypedef complex<double> P;\n\n// * ティツィツアテ・ツョツケテ」ツ?凖」ツつ凝ィツェツ、テ・ツキツョテ篠オ\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * テ・ツ??・ツ堕ィテァツ篠?\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> テ」ツ?ョテゥツ??・ツコツ湘」ツつ津・ツョツ堙ァツセツゥテ」ツ?凖」ツつ?\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2テ、ツケツ療」ツ?凖」ツつ?\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2テァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2テ」ツ?、テ」ツ?ョテ」ツつケテ」ツつォテ」ツδゥテ」ツδシテ」ツ?古ァツュツ嘉」ツ?療」ツ??」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2テ」ツ?、テ」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?古ァツュツ嘉」ツ?療」ツ??」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * テ・ツ??ァツゥツ?(dot product) : aテ」ツδサb = |a||b|cosテ篠?\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * テ・ツ、ツ姪ァツゥツ?(cross product) : aテδ傭 = |a||b|sinテ篠?\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// テァツキツ堙・ツ按?」ツ?ョティツ。ツィテァツ渉セ\nstruct Segment{\n\t// テァツつケ a, b テ」ツつ津ァツォツッテァツつケテ」ツ?ィテ」ツ?凖」ツつ凝ァツキツ堙・ツ按?\n\tP a, b;\n\t// テ」ツつウテ」ツδウテ」ツつケテ」ツδ暗」ツδゥテ」ツつッテ」ツつソテ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n\tSegment(P a_, P b_) {\n\t\ta = a_; b = b_;\n\t}\n\t// テァツつケ p テ」ツ?古ァツキツ堙・ツ按?、ツクツ甘」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n};\n// Segment テ」ツ?ョテゥツ??・ツコツ湘」ツつ津・ツョツ堙ァツセツゥ (xテ・ツコツァテヲツィツ凖」ツ?ョテ・ツーツ湘」ツ?陛」ツ??ァツォツッテァツつケテ」ツ?ァテヲツッツ氾ィツシツ?\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// テ、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョティツ。ツィテァツ渉セ\nstruct Triangle{\nprivate:\n\t// テ、ツスツ凖・ツシツヲテ・ツョツ堙ァツ青?」ツ?凝」ツつ?3 テ」ツ?、テ」ツ?ョティツァツ津」ツ?ョティツァツ津・ツコツヲテ」ツつ津ヲツアツづ」ツつ?」ツつ?(テ・ツ??ゥツδィテ」ツ?ョテゥツ鳴「テヲツ閉ーテ」ツ?ァテ、ツスツソテァツ板ィ)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 テ」ツ?、テ」ツ?ョテゥツ?づァツつケ\n\tP a, b, c;\n    // 3 テ」ツ?、テ」ツ?ョティツセツコテ」ツ?ョテゥツ閉キテ」ツ??\n    double edgeA, edgeB, edgeC;\n    // 3 テ」ツ?、テ」ツ?ョティツァツ津」ツ?ョティツァツ津・ツコツヲ (テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウ)\n    double angleA,angleB,angleC;\n    \n    // テ」ツつウテ」ツδウテ」ツつケテ」ツδ暗」ツδゥテ」ツつッテ」ツつソテ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// テァツつケ p テ」ツ?古、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョティツセツコテ、ツクツ甘」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\t/*bool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}*/\n\t// テァツつケ p テ」ツ?古、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ」ツ?づ」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??( AOJ 0012 テ」ツ?ァテヲツ、ツ愿ィツィツシテヲツクツ暗」ツ?ソ )\n\t// テァツつケ p テ」ツ?古、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョティツセツコテ、ツクツ?or テゥツ?づァツつケテ、ツクツ?テ」ツ?ォテ」ツ?づ」ツつ凝」ツ?ィテ」ツ?催」ツ?ッティツェツ、テ・ツキツョテ」ツ?ァテヲツュツ」テ」ツ?療」ツ??ァツオツ静ヲツ楪愿」ツ?古ィツソツ氾」ツ?」テ」ツ?ヲテ」ツ?禿」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァテヲツウツィテヲツ??!!\n\tbool is_inside(P p) {\n\t\t// ティツセツコテ、ツクツ甘」ツ?ォテ」ツ?づ」ツつ凝」ツ?ィテ」ツ??\n\t\t//if( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// ティツァツ但PB + ティツァツ達PB + ティツァツ辰PA テ」ツ??360テ・ツコツヲテ」ツ?ェテ」ツつ?テァツつケ p テ」ツ?ッテ、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョテ・ツ??ゥツδィテ」ツ?ォテ」ツ?づ」ツつ?\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tP p1(xp1,yp1), p2(xp2,yp2), p3(xp3,yp3), K(xk,yk), S(xs,ys);\n\t\tTriangle t( p1 , p2, p3 );\n\t\tint a = t.is_inside(K)? 1 : 0 ;\n\t\tint b = t.is_inside(S)?\t1 : 0 ;\n\t\tcout << ((a^b)? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョテ」ツ?療」ツ?ヲティツカツウテ」ツ?療ァツョツ?\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2テヲツャツ。テ・ツ?ε」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){//テ・ツ??ァツゥツ?\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//テ・ツ、ツ姪ァツゥツ?\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p){\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//テァツキツ堙・ツ按?1-p2テ、ツクツ甘」ツ?ォテァツつケqテ」ツ?古」ツ?づ」ツつ凝」ツ?凝・ツ按、テ・ツョツ?\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//テァツ崢エテァツキツ嗔1-p2テ」ツ?ィテァツ崢エテァツキツ嘔1-q2テ」ツ?ョテ、ツコツ、テァツつケ\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//テァツキツ堙・ツ按?1-p2テ」ツ?ィテァツキツ堙・ツ按?1-q2テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool exist_intersection(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//テ・ツケツウティツ。ツ?\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//テ・ツ篠淌ァツつケテ、ツクツュテ・ツソツε・ツ崢榲ィツサツ「\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ崢榲ィツサツ「\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//テ、ツコツ古ァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケテ」ツつ津ィツィツ暗ァツョツ?\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//テ、ツコツ、テァツつケテ」ツ?ェテ」ツ??\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ?\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//ティツァツ」テ」ツ?ェテ」ツ??\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tif(exist_intersection(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//テァツキツ堙・ツ按?ゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(exist_intersection(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ??ゥツδィテ」ツ?ォテァツつケpテ」ツ?古」ツ?づ」ツつ凝」ツ??\nbool contains(vector<P> &poly,P p,double inf=INF){\n\tint f=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\tdouble d=(p-poly[i]).det(poly[i]-poly[(i+1)%poly.size()]);\n\t\tif(d<0)f|=1;\n\t\telse if(d>0)f|=2;\n\t}\n\treturn f==(f&-f);\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tvector<P> poly(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>poly[i].x>>poly[i].y;\n\t\t}\n\t\tP p,q;\n\t\tcin>>p.x>>p.y>>q.x>>q.y;\n\t\tbool a,b;\n\t\ta=contains(poly,p);\n\t\tb=contains(poly,q);\n\t\tcout<<(a&&!b||!a&&b?\"OK\":\"NG\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n\tdouble t = dot(p - l.first, l.first - l.second) / norm(l.first - l.second);\n\treturn l.first + t * (l.first - l.second);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0) return 1;\n\tif(cross(b, c) < 0) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n\treturn abs(l.first- p) + abs(l.second - p) - abs(l.first - l.second) < EPS;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) * ccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * ccw(t.first, t.second, s.second) <= 0;\n}\n\ndouble distanceSP(line s, xy_t p){\n\tconst xy_t r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s.first - p), abs(s.second - p));\n}\n\nint main(){\n\tint n;\n\tdouble xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\tline s, l[3];\n\tcin >> n;\n\trep(t, n){\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tl[0] = line(xy_t(xp1, yp1), xy_t(xp2, yp2));\n\t\tl[1] = line(xy_t(xp2, yp2), xy_t(xp3, yp3));\n\t\tl[2] = line(xy_t(xp3, yp3), xy_t(xp1, yp1));\n\t\ts = line(xy_t(xs, ys), xy_t(xk, yk));\n\t\tint cnt = 0;\n\t\trep(i, 3) if(intersectSS(l[i], s)) cnt++;\n\t\tif(cnt % 2 == 0) cout << \"NG\" << endl;\n\t\telse cout << \"OK\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0,cnt2=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i])){\n      cnt1++;\n      continue;\n    }\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt2++;\n  }\n  return ((cnt1/2)+cnt2)%2;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=Crosspoint(pq,ks);\n    ans+=Crosspoint(qr,ks);\n    ans+=Crosspoint(rp,ks);\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS && abs(B) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x>0&C.y>0&C.x+C.y<1;}main(){for(cin>>A.x;cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y;){A-=C;B-=C;S-=C;G-=C;X(S)^X(G)?cout<<\"OK\\n\":cout<<\"NG\\n\";}}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=10000000;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n  /*\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n  */\n\n  int cnt1=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  }\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n  cnt-=cnt1;\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint it(long p1x, long p1y,long p2x, long p2y,long p3x, long p3y,long p4x, long p4y){\nreturn ((p1x-p2x)*(p3y-p1y)+(p1y-p2y)*(p1x-p3x))*((p1x-p2x)*(p4y-p1y)+(p1y-p2y)*(p1x-p4x));\n}\nint main(){\nlong n,k,i,s,xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\ncin>>n;\nfor(i=0;i<n;i++){\ncin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\nk=-1;\nif(it(xp1,yp1,xp2,yp2,xk,yk,xp3,yp3)<0)k=1;\nif(it(xp2,yp2,xp3,yp3,xk,yk,xp1,yp1)<0)k=1;\nif(it(xp3,yp3,xp1,yp1,xk,yk,xp2,yp2)<0)k=1;\ns=-1;\nif(it(xp1,yp1,xp2,yp2,xs,ys,xp3,yp3)<0)s=1;\nif(it(xp2,yp2,xp3,yp3,xs,ys,xp1,yp1)<0)s=1;\nif(it(xp3,yp3,xp1,yp1,xs,ys,xp2,yp2)<0)s=1;\nif(k*s>0)cout<<\"NG\"<<endl;else cout<<\"OK\"<<endl;\n\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(i=0;i<N+1;i++){\n    ymx=max(ymx,p[i].y);\n    ymn=min(ymn,p[i].y);\n  }\n  if(lt.a.y<=ymn||lt.a.y>=ymx)return 0;\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint cross(int a, int b, int c, int d) {\n    return a * d - b * c;\n}\n\nint main() {\n    int n;\n\n    cin >> n;\n    while (n--) {\n        int xp[3], yp[3], x[2], y[2];\n        int cp[2][3];\n\n        for (int i = 0; i < 3; i++) {\n            cin >> xp[i] >> yp[i];\n        }   \n        for (int i = 0; i < 2; i++) {\n            cin >> x[i] >> y[i];\n        }\n\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 3; j++) {\n                int k = (j+1) % 3;\n                cp[i][j] = cross(xp[k]-xp[j], yp[k]-yp[j], x[i]-xp[j], y[i]-yp[j]) > 0;\n            }\n        }\n        bool judge = false;\n        if (cp[0][0] == cp[0][1] && cp[0][0] == cp[0][2]) {\n            if (cp[1][0] != cp[1][1] || cp[1][0] != cp[1][2]) {\n                judge = true;\n            }\n        }\n        else if (cp[1][0] == cp[1][1] && cp[1][0] == cp[1][2]) {\n            judge = true;\n        }\n        cout << (judge? \"OK\": \"NG\") << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\nbool contain(const polygon& p, const point& a) {\n\tconst int d1 = ccw(a, p[0], p[1]), d2 = ccw(a, p[1], p[2]), d3 = ccw(a, p[2], p[0]);\n\treturn !(d1 * d2 == -1 || d2 * d3 == -1 || d3 * d1 == -1);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile(n--) {\n\t\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\t\tscanf(\"%d %d %d %d %d %d\", &x1, &y1, &x2, &y2, &x3, &y3);\n\t\tpolygon triangle;\n\t\ttriangle.push_back(point(x1, y1));\n\t\ttriangle.push_back(point(x2, y2));\n\t\ttriangle.push_back(point(x3, y3));\n\n\t\tscanf(\"%d %d %d %d\", &xk, &yk, &xs, &ys);\n\t\tif(contain(triangle, point(xk, yk)) != contain(triangle, point(xs, ys)))\n\t\t\tputs(\"OK\");\n\t\telse\n\t\t\tputs(\"NG\");\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n int inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(const Point &cc,double rr) : c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tint n;\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tPoint a,b,c,star[2];\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf\",\n\t\t\t&a.x,&a.y,&b.x,&b.y,&c.x,&c.y,&star[0].x,&star[0].y,&star[1].x,&star[1].y);\n\t\tbool in[2];\n\t\tfor(int i=0;i<2;i++){\n\t\t\tint cnt=0;\n\t\t\tcnt+=ccw(a,b,star[i]);\n\t\t\tcnt+=ccw(b,c,star[i]);\n\t\t\tcnt+=ccw(c,a,star[i]);\n\t\t\tin[i]=(cnt==3*CCW || cnt==3*CW);\n\t\t}\n\t\tputs(in[0]==in[1]?\"NG\":\"OK\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<iomanip>\n#include<bitset>\n#include<utility>\n#include<list>\n#include<map>\n#include<set>\n#include<cstring>\n#include<sstream>\n#include<cctype>\nusing namespace std;\nconst double EPS=1e-5;\nconst double INF=1e9;\ntypedef complex<double>P;\nnamespace std{\n    bool operator<(const P& a,const P& b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n#define EQ(a,b) (fabs((a)-(b))<EPS)\n#define EQV(a,b) (EQ(real(a),real(b))&&EQ(imag(a),imag(b)))\ndouble cross(const P &a,const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n    return real(conj(a)*b);\n}\n\nstruct L:public vector<P>{\n    L(const P &a,const P &b){\n        push_back(a);push_back(b);\n    }\n    L(){}\n};\n\ntypedef vector<P>G;\n\nstruct C{\n    P p;double r;\n    C(const P &p_,double r_):p(p_),r(r_){}\n    C(){}\n};\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return 1;///counter clockwise\n    if(cross(b,c)<0)return -1;///clockwise\n    if(dot(b,c)<0)return 2;///c--a--b on line\n    if(norm(b)<norm(c))return -2;///a--b--c on line\n    return 0;\n}\nbool orthogonal(P &p,P &q){\n    return EQ(dot(p,q),0.0);\n}\nbool intersectLL(const L &l,const L &m){\n    return abs(cross(l[1]-l[0],m[1]-m[0]))>EPS||///non-parallel\n        abs(cross(l[1]-l[0],m[0]-l[0]))<EPS;///same line\n}\nbool intersectLS(const L &l,const L &s){\n    return cross(l[1]-l[0],s[0]-l[0])*///s[0] is left of l\n        cross(l[1]-l[0],s[1]-l[0])<EPS;///s[1] is right of l\n}\nbool intersectLP(const L &l,const P &p){\n    return abs(cross(l[1]-p,l[0]-p))<EPS;\n}\nbool intersectSS(const L &s,const L &t){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L &s,const P &p){\n    return abs(abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]))<EPS;\n    ///triangle inequality\n}\nP projection(const L &l,const P &p){\n    double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0]+t*(l[0]-l[1]);\n}\nP reflection(const L &l,const P &p){\n    return p+(projection(l,p)-p)*2.0;\n}\ndouble distanceLP(const L &l,const P &p){\n    return abs(p-projection(l,p));\n}\ndouble distanceLL(const L &l,const L &m){\n    return intersectLL(l,m)?0:distanceLP(l,m[1]);\n}\ndouble distanceLS(const L &l,const L &s){\n    if(intersectLS(l,s))return 0;\n    return min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L &s,const P &p){\n    const P r=projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s,const L &t){\n    if(intersectSS(s,t))return 0;\n    return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n            min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\nP crossPoint(const L &l,const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS&&abs(B)<EPS)return m[0];///same line\n    ///if(abs(A)<EPS)assert(false);\n    return m[0]+B/A*(m[1]-m[0]);\n\n}\n\nP extreme(const G &g,const L &l){\n    int k=0;\n    for(int i=1;i<g.size();i++){\n        if(dot(g[i],l[1]-l[0])>dot(g[k],l[1]-l[0]))k=i;\n    }\n    return g[k];\n}\n\nG andrewScan(G s){\n    G u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for(int i=2;i<s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=-1;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=-1;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n/*\nIN 2\nON 1\nOUT 0\n*/\nint contains(G g,P p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        P a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);\n}\n\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    while(N--){\n        G g(3);\n        P o,h;\n        double x,y;\n        for(int i=0;i<3;i++){\n            scanf(\"%lf%lf\",&x,&y);\n            g[i]=P(x,y);\n        }\n        scanf(\"%lf%lf\",&x,&y);\n        o=P(x,y);\n        scanf(\"%lf%lf\",&x,&y);\n        h=P(x,y);\n        if(contains(g,o)+contains(g,h)==2)puts(\"OK\");\n        else puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n\tdouble S = abs(cross(p[1] - p[0], p[2] - p[0]));\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], x - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\t\n\twhile(n--)\n\t{\n\t\tP p[3];\n\t\tP k, s;\n\t\t\n\t\trep(i, 3) cin >> p[i].real() >> p[i].imag();\n\t\tcin >> k.real() >> k.imag() >> s.real() >> s.imag();\n\t\n\t\tif(isInTriangle(p, k) ^ isInTriangle(p, s))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//47\n#include<iostream>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nbool in(P x,P *a){\n  bool sg[2]={};\n  for(int i=0;i<3;i++){\n    P e=a[(i+1)%3]-a[i];\n    P d=x-a[i];\n    sg[e.real()*d.imag()-e.imag()*d.real()<0]=true;\n  }\n  return sg[0]^sg[1];\n}\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    P p[5];\n    for(int i=0;i<5;i++){\n      double x,y;\n      cin>>x>>y;\n      p[i]=P(x,y);\n    }\n    cout<<(in(p[3],p)^in(p[4],p)?\"OK\":\"NG\")<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_intersected_ls(point p1, point p2, point p3, point p4) {\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<EPS)&&\n         (ccw(p3,p4,p1)*ccw(p3,p4,p2)<EPS);\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j)\n\t  cnt+=is_intersected_ls(p[i],p[j],k,s);\n    \n    if(cnt%2)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[8],y[8],a,b,c,d,p,q,det;\n        //入力を多少簡略化\n        for(int i=0;i<8;i++) {\n            printf(\"x%d =? \",i+1); scanf(\"%lf\" ,&x[i]);\n            printf(\"y%d =? \",i+1); scanf(\"%lf\" ,&y[i]);\n        }\n        rep(j,3) {\n            //(x1,y1)(x2,y2)を結ぶax+by=p の係数\n            a = y[j]-y[j+1];  b = x[j+1]-x[j];\n            p = x[j+1]*y[j]-x[j]*y[j+1];\n            //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n            c = y[6]-y[7];  d = x[7]-x[6];\n            q = x[7]*y[6]-x[6]*y[7];\n            //係数についての行列式\n            det = a*d-c*b;\n            //det=0で解は存在しない(この問題については２線分は同一直線上にないから)\n            if(fabs(det) < 0.00001){\n            } else {\n                ansx = (d*p - b*q)/det;\n                ansy = (-c*p + a*q)/det;\n                //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                if((x[0] - ansx)*(x[1] - ansx) <= 0.00001 && (x[6] - ansx)*(x[7] - ansx) <= 0.00001 ) {\n                    count++;\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint main()\n{\n  int n;\n  int a,b,c,d,e,f,sx,sy,gx,gy;\n  Point p[3];\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>p[0].x>>p[0].y>>p[1].x>>p[1].y>>p[2].x>>p[2].y;\n    cin>>sx>>sy>>gx>>gy;\n    Segment s(Point(sx,sy),Point(gx,gy));\n    int c=0;\n    for(int i=0;i<3;i++){\n      if(intersect(s,Segment(p[i],p[(i+1)%3])))c++;\n    }\n    if(c==1)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=10000000;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n  /*\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n  */\n\n  int cnt1=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  }\n  cnt1/=2;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n  cnt-=cnt1/2;\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* is_contain_in_triangle.cpp\n    点が三角形に含まれているか判定する\n\n    verified:\n        AOJ 0143\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0143\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing D = double;\n\n// P: 点,座標\nusing P = std::complex<D>;\nnamespace std {\nbool operator<(const P& a, const P& b) { return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); }\nbool operator>(const P& a, const P& b) { return real(a) != real(b) ? real(a) > real(b) : imag(a) > imag(b); }\n}  // namespace std\nD dot(const P& a, const P& b) { return real(conj(a) * b); }    // 内積\nD cross(const P& a, const P& b) { return imag(conj(a) * b); }  // 外積\nD norm(const P& a) { return dot(a, a); }\n\nconst D PI = std::acos(-1);\nconst D EPS = 1e-10;\nconst D INF = 1e12;\n\nint sgn(D a) { return (a < -EPS) ? -1 : (a > EPS) ? 1 : 0; }  // 比較\n\n/* ccw(a,b,c)\n    出力:\n    1: a-bから見てcは反時計, -1: a-bから見てcは時計\n    2: c-a-bで直線, -2: a-b-cで直線, 0: a-c-bで直線\n*/\nint ccw(const P& a, const P& b, const P& c) {\n    if (sgn(cross(b - a, c - a)) == 1) return 1;         // 1: a-bから見てcは反時計\n    if (sgn(cross(b - a, c - a)) == -1) return -1;       //-1: a-bから見てcは時計\n    if (sgn(dot(b - a, c - a)) == -1) return 2;          // 2: c-a-bで直線\n    if (sgn(norm(c - a) - norm(b - a)) == 1) return -2;  //-2: a-b-cで直線\n    return 0;                                            // 0: a-c-bで直線\n}\n\n/* is_contain_in_triangle(p, a,b,c)\n    p が 三角形abc に含まれていれば true を返す\n*/\nbool is_contain_in_triangle(const P& p, const P& a, const P& b, const P& c) {\n    int r1 = ccw(p, b, c), r2 = ccw(p, c, a), r3 = ccw(p, a, b);\n    if (r1 == r2 && r2 == r3 && (r1 == 1 || r1 == -1)) return true;\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> ans(n);\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        P p[3];\n        for (int j = 0; j < 3; j++) {\n            cin >> x >> y;\n            P tmp(x, y);\n            p[j] = tmp;\n        }\n        cin >> x >> y;\n        P k(x, y);\n        cin >> x >> y;\n        P s(x, y);\n\n        if (is_contain_in_triangle(k, p[0], p[1], p[2]) ^ is_contain_in_triangle(s, p[0], p[1], p[2])) {\n            ans[i] = 1;\n        } else {\n            ans[i] = 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (ans[i]) {\n            cout << \"OK\\n\";\n        } else {\n            cout << \"NG\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-12)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.para(l)){\n\tl.a.imag() += 1e-6;\n\tl.b.imag() += 1e-6;\n      }\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.para(l)){\n      l.a.imag() += 1e-6;\n      l.b.imag() += 1e-6;\n    }\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(i=0;i<n;++i)\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); itr++)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n\ntypedef struct{\n  int x,y;\n}Point;\n\nint det(Point p,Point q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint main(int argc, char const *argv[]) {\n  int n;\n  cin >>n;\n  for(int T=0; T<n; ++T){\n    int i;\n\n    Point p[3],v,a;\n    rep(i,3) scanf(\" %d %d\", &p[i].x, &p[i].y);\n    scanf(\" %d %d\", &a.x, &a.y);\n    scanf(\" %d %d\", &v.x, &v.y);\n\n    bool _a=false, _v=false;\n    int tmp=0;\n    rep(i,3){\n      Point t1,t2;\n      t1.x=p[(i+1)%3].x-p[i].x;\n      t1.y=p[(i+1)%3].y-p[i].y;\n      t2.x=a.x-p[i].x;\n      t2.y=a.y-p[i].y;\n\n      if(det(t1,t2)>0) ++tmp;\n      else --tmp;\n    }\n    if(tmp==3||tmp==-3) _a=true;\n\n    tmp=0;\n    rep(i,3){\n      Point t1,t2;\n      t1.x=p[(i+1)%3].x-p[i].x;\n      t1.y=p[(i+1)%3].y-p[i].y;\n      t2.x=v.x-p[i].x;\n      t2.y=v.y-p[i].y;\n\n      if(det(t1,t2)>0) ++tmp;\n      else --tmp;\n    }\n    if(tmp==3||tmp==-3) _v=true;\n\n    //cout << _a << \" \" << _v << endl;\n\n    string s=\"OK\";\n    if(_a==_v) s=\"NG\";\n    std::cout << s << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator<(const P& a, const P& b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b){ return imag(conj(a) * b); }\ndouble dot(const P& a, const P& b){ return real(conj(a) * b); }\ntypedef vector<P> G;\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\n\nint contains(const G& x, const P& y){\n  bool in_ = false;\n  rep(i, x.size()){\n    P a = curr(x, i) - y, b = next(x, i) - y;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b)){\n      if (cross(a, b) < 0) in_ = !in_;\n    }\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in_ ? IN : OUT;\n}\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\n\nint main()\n{\n  rep(i, in()){\n    G area;\n    rep(j, 3){\n      int x, y;\n      x = in();\n      y = in();\n      area.push_back(P(x, y));\n    }\n    int x, y;\n    x = in();\n    y = in();\n    P k(x, y);\n    x = in();\n    y = in();\n    P s(x, y);\n    if (contains(area, k) != contains(area, s)){\n      puts(\"OK\");\n    }\n    else {\n      puts(\"NG\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct point{\n\tdouble x;\n\tdouble y;\n};\n\nint ccw(point p0, point p1, point p2){\n\tdouble dx1 = p1.x - p0.x, dy1 = p1.y - p0.y;\n\tdouble dx2 = p2.x - p0.x, dy2 = p2.y - p0.y;\n\tif(dx1 * dy2 > dx2 * dy1){\n\t\treturn 1;\n\t}else if(dx1 * dy2 > dx2 * dy1){\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nbool in_t(point p0, point p1, point p2, point p3){\n\tif((ccw(p0, p1, p2) == -ccw(p0, p1, p3)\n\t\t&& (ccw(p0, p2, p1) == -ccw(p0, p2, p3))))\n\t\treturn true;\n\telse return false;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tpoint p1, p2, p3;\n\t\tpoint pk, ps;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y\n\t\t\t>> p3.x >> p3.y >> pk.x >> pk.y >>  ps.x >> ps.y;\n\t\tif((in_t(pk, p1, p2, p3) && !in_t(ps, p1, p2, p3)) ||\n\t\t\t(!in_t(pk, p1, p2, p3) && in_t(ps, p1, p2, p3)))\n\t\t\tcout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 点と三角形の包含関係\n//\n// verified:\n//   AOJ 0143\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0143\n//\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n\n/* Point */\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n\n// 粗\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、0：一直線上\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    return 0;\n}\n\n// 精\n// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)\n// 2：c-a-bの順に一直線上、-2：a-b-cの順に一直線上、0：a-c-bの順に一直線上\nint dccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (norm(b-a) < norm(c-a)) return -2;\n    return 0;\n}\n\n// 点と三角形の包含関係(辺上については判定していない)\nbool is_contain(Point p, Point a, Point b, Point c) {\n    int r1 = ccw(p, b, c), r2 = ccw(p, c, a), r3 = ccw(p, a, b);\n    if (r1 == 1 && r2 == 1 && r3 == 1) return true;\n    if (r1 == -1 && r2 == -1 && r3 == -1) return true;\n    return false;\n}\n\n\nint main() {\n    Point p[3], a, b;\n    int n;\n    cin >> n;\n    for (int id = 0; id < n; ++id) {\n        for (int i = 0; i < 3; ++i) cin >> p[i].x >> p[i].y;\n        cin >> a.x >> a.y >> b.x >> b.y;\n        int j1 = is_contain(a, p[0], p[1], p[2]);\n        int j2 = is_contain(b, p[0], p[1], p[2]);\n        if (j1 == j2) puts(\"NG\");\n        else puts(\"OK\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n\n//時計回りに辺を構築する。\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n/*\n点と多角形の内外判定\n\nps 多角形の辺\np  点\nn  多角形の辺の数\n\n点が多角形に含まれれば1,\nそうでなければ0を返す。\n*/\nint point_contain(vector<segment> ps, point p, int n){\n  point q;\n  q.x=100000000;\n  q.y=p.y;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    cnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  }\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    seg=construct_edge(p,3);\n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong it(long p1x, long p1y,long p2x, long p2y,long p3x, long p3y,long p4x, long p4y){\nlong k=-1,s=-1;\nif((p2x-p1x)*(p3y-p1y)<(p2y-p1y)*(p3x-p1x))k=1;\nif((p2x-p1x)*(p4y-p1y)<(p2y-p1y)*(p4x-p1x))k=1;\nreturn k*s;\n}\nint main(){\nlong n,k,i,s,xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\ncin>>n;\nfor(i=0;i<n;i++){\ncin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\nk=-1;\nif(it(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk)<0)k=1;\nif(it(xp2,yp2,xp3,yp3,xp1,yp1,xk,yk)<0)k=1;\nif(it(xp3,yp3,xp1,yp1,xp2,yp2,xk,yk)<0)k=1;\ns=-1;\nif(it(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys)<0)s=1;\nif(it(xp2,yp2,xp3,yp3,xp1,yp1,xs,ys)<0)s=1;\nif(it(xp3,yp3,xp1,yp1,xp2,yp2,xs,ys)<0)s=1;\nif(k*s>0)cout<<\"NG\"<<endl;else cout<<\"OK\"<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double D; \n#define EPS (1e-6)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nD add(D a,D b){\n  if(abs(a + b) < EPS * (abs(a) + abs(b))){\n    return 0;\n  }\n  return a + b;\n}\n\nstruct Point{\n  D x,y;\n\n  Point (D x = 0, D y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point(add(x,p.x) , add(y,p.y));\n  }\n  Point operator - (Point p) {\n    return Point(add(x,p.x) ,add(y,-p.y));\n  }\n  Point operator * (D a) {\n    return Point( a*x , a*y );\n  }\n  \n  D norm() {\n    return x*x+y*y;\n  }\n\n  D dot(Point p){\n    return add(x*p.x , y*p.y);\n  }\n\n  D det(Point p){\n    return add(x*p.y , -y*p.x);\n  }  \n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n\n  if(a.det(b) > EPS) return 1;\n  if(a.det(b) < -EPS) return -1;\n  if(a.dot(b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nD S(Point p1,Point p2,Point p3){\n  D a = sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));\n  D b = sqrt(pow(p1.x-p3.x,2) + pow(p1.y-p3.y,2));\n  D c = sqrt(pow(p3.x-p2.x,2) + pow(p3.y-p2.y,2));\n  D s = (a + b + c) / 2;\n\n  return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nbool check(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) < 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) < 0);\n}\n\nbool eq(D S1,D S2){\n  return equal(S1,S2);\n}\n\nint main(){\n  int n;\n  Point P[3],T[2];\n\n  cin >> n;\n  while(n--){\n    scanf(\"%lf %lf\" ,&P[0].x ,&P[0].y);\n    scanf(\"%lf %lf\" ,&P[1].x ,&P[1].y);\n    scanf(\"%lf %lf\" ,&P[2].x ,&P[2].y);\n    scanf(\"%lf %lf\" ,&T[0].x ,&T[0].y);\n    scanf(\"%lf %lf\" ,&T[1].x ,&T[1].y);\n\n    bool ok = false;\n    D S1 = S(P[0],P[1],P[2]);\n    D S2 = S(P[0],P[1],T[0])+S(P[0],P[2],T[0])+S(P[1],P[2],T[0]);\n    D S3 = S(P[0],P[1],T[1])+S(P[0],P[2],T[1])+S(P[1],P[2],T[1]);\n\n    if(eq(S1,S2) && eq(S1,S3)){\n      puts(\"NG\");\n      continue;\n    }\n\n    if(!eq(S1,S2) && !eq(S1,S3)){\n      puts(\"NG\");\n      continue;\n    }\n\n    if(!eq(S1,S3)){\n      puts(\"NG\");\n      continue;\n    }\n\n    if(check(P[0],P[1],T[0],T[1])){\n      ok = true;\n    }    \n    if(check(P[0],P[2],T[0],T[1])){\n      ok = true;\n    }  \n    if(check(P[1],P[2],T[0],T[1])){\n      ok = true;\n    }  \n\n    if(ok){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nint sgn(double d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\nstruct Point {\n  double x, y;\n  Point() {}\n  Point (const double& x, const double& y) : x(x), y(y) {}\n  Point& operator += (const Point& other) { x += other.x; y += other.y; return *this; }\n  Point& operator -= (const Point& other) { x -= other.x; y -= other.y; return *this; }\n  Point& operator *= (const double& factor) { x *= factor; y *= factor; return *this; }\n  Point& operator /= (const double& factor) { x /= factor; y /= factor; return *this; }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>;\nPoint operator + (const Point&lhs, const Point& rhs) { return Point(lhs.x + rhs.x, lhs.y + rhs.y); }\nPoint operator - (const Point& lhs, const Point& rhs) { return Point(lhs.x - rhs.x, lhs.y - rhs.y); }\nPoint operator * (const Point& lhs, const double& factor) { return Point(lhs.x * factor, lhs.y * factor); }\nPoint operator * (const double& factor, const Point& rhs) { return Point(factor * rhs.x, factor * rhs.y); }\nPoint operator / (const Point& lhs, const double& factor) { return Point(lhs.x / factor, lhs.y / factor); }\ndouble operator * (const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }\ndouble operator ^ (const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }\nbool operator == (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) == 0 && sgn(lhs.y - rhs.y) == 0; }\nbool operator != (const Point& lhs, const Point& rhs) { return !(lhs == rhs); }\nbool operator < (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool operator > (const Point& lhs, const Point& rhs) { return rhs < lhs; }\nbool operator <= (const Point& lhs, const Point& rhs) { return !(lhs > rhs); }\nbool operator >= (const Point& lhs, const Point& rhs) { return !(lhs < rhs); }\nistream& operator >> (istream& is, Point& point) { return is >> point.x >> point.y; }\nostream& operator << (ostream& os, Point& point) { return os << \"(\" << point.x << \",\" << point.y << \")\"; }\ndouble norm(const Point& point) { return point.x * point.x + point.y * point.y; }\ndouble abs(const Point& point) { return sqrt(norm(point)); }\ndouble arg(const Point& point) { return atan2(point.y, point.x); }\nPoint polar(const double& a, const double& r) { return Point(cos(r) * a, sin(r) * a); }\nbool sort_x(Point lhs, Point rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool sort_y(Point lhs, Point rhs) { return sgn(lhs.y - rhs.y) ? lhs.y < rhs.y : lhs.x < rhs.x; }\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contain(const Polygon& ps, const Point& p) {\n  int n = ps.size(), x = 0;\n  for (int i = 0; i < n; i++) {\n    Point a = ps[i] - p, b = ps[(i + 1) % n] - p;\n    if (sgn(a ^ b) == 0 && sgn(a * b) != 1) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (sgn(a.y) != 1 && sgn(b.y) == 1 && sgn(a ^ b) == 1) x ^= 1;\n  }\n  return x ? 2 : 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    Polygon ps(3);\n    Point k, s;\n    for (int j = 0; j < 3; j++) {\n      cin >> ps[j];\n    }\n    cin >> k >> s;\n    cout << (contain(ps, k) ^ contain(ps, s) ? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\nusing namespace std;\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {bool in = false;for (int i = 0; i < P.size(); ++i) {point a = curr(P,i) - p, b = next(P,i) - p;if (imag(a) > imag(b)) swap(a, b);if (imag(a) <= 0 && 0 < imag(b))if (cross(a, b) < 0) in = !in;if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;}return in ? IN : OUT;}\n\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n;cin >> n;\n\twhile(n--){\n\t\tP data[5];\n\t\tG v;\n\t\trep(i,3){P c; cin >> c.real() >> c.imag(); v.push_back(c);}\n\t\tP a,b;\n\t\tcin >> a.real() >> a.imag() >> b.real() >> b.imag();\n\t\tcout << ( (!!contains(v,a)) ^ (!!contains(v,b)) ?\"OK\":\"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 0\nstatic const int INF=1<<24;\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\nvector<P> tri(3);\nvector<P> aa(2);\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\nint check(P r){\n\tP a=tri[0]-tri[1],ar=r-tri[0];\n\tP b=tri[1]-tri[2],br=r-tri[1];\n\tP c=tri[2]-tri[0],cr=r-tri[2];\n\tdouble A=dot(ar,a),B=dot(br,b),C=dot(cr,c);\n\tif(A>EPS&&B>EPS&&C>EPS) return 1;\n\tif(A<-EPS&&B<-EPS&&C<-EPS) return 1;\n\treturn -1;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,3){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\ttri[j]=P(a,b);\n\t\t}\n\t\trep(j,2){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\taa[j]=P(a,b);\t\n\t\t}\n\t\tif(check(aa[0])*(check(aa[1]))<0){\n\t\t\tcout<<\"OK\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\\n\";\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nPoint Minus(Point a, Point b) { Point O; O.px = a.px - b.px; O.py = a.py - b.py; return O; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint p1, p2, p3, p4, p5;\n\t\tcin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p4.px >> p4.py >> p5.px >> p5.py;\n\t\tvector<Point>C = { p1,p2,p3 };\n\t\tbool G1 = contain(C, p4), G2 = contain(C, p5);\n\t\tif (G1 ^ G2 == true)cout << \"OK\" << endl;\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n};\n\nbool PointInTri(const vector<Point>& tri, const Point& p) {\n\tint cnt = 0;\n\tfor (int i=1; i<4; i++) {\n\t\tPoint p0 = tri[i-1], p1 = tri[i%3];\n\t\tbool flag0x = (p.x <= p0.x), flag0y = (p.y <= p0.y);\n\t\tbool flag1x = (p.x <= p1.x), flag1y = (p.y <= p1.y);\n\t\t\n\t\tif (flag0y != flag1y) {\n\t\t\tif ( (flag0x == flag1x) && flag0x) {\n\t\t\t\tcnt += flag0y ? -1 : 1;\n\t\t\t} else if (p.x <= ( p0.x+(p1.x-p0.x)*(p.y-p0.y)/(p1.y-p0.y) ) ) {\n\t\t\t\tcnt += flag0y ? -1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt!=0;\n}\n\nint main() {\n\tint n; cin >> n;\n\t\n\tvector<Point> tri(3);\n\tfor (int i=0; i<n; i++) {\n\t\tcin >> tri[0].x >> tri[0].y >> tri[1].x >> tri[1].y >> tri[2].x >> tri[2].y;\n\t\tPoint p1; cin >> p1.x >> p1.y;\n\t\tPoint p2; cin >> p2.x >> p2.y;\n\t\tbool flag1 = PointInTri(tri, p1), flag2 = PointInTri(tri, p2);\n\t\tif ( (flag1 && !flag2) || (!flag1 && flag2) ) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Point\n{\n\tPoint(int x, int y):x(x),y(y),z(0){}\n\tPoint():x(0),y(0),z(0){}\n\tint x,y,z;\n};\ninline bool isRight( Point &p, Point &a, Point &b ){\n\treturn (a.x-p.x)*(a.y-b.y) - (a.y-p.y)*(a.x-b.x) < 0;\n}\nbool isInside( Point &p, vector<Point> &vp ){\n\tfor(unsigned int i = 1; i < vp.size(); ++i){\n\t\tif( !isRight( p, vp[i-1], vp[i] ) )\n\t\t\treturn false;\n\t}\n\treturn isRight( p, vp[vp.size()-1], vp[0] );\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor(int X = 0; X < n; ++X ){\n\t\tPoint A, B, C, ken, ori;\n\t\tbool  bKenInside = false, bOriInside = false;\n\t\tvector<Point> triangle;\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> ken.x >> ken.y >> ori.x >> ori.y;\n\t\ttriangle.push_back(A);triangle.push_back(B);triangle.push_back(C);\n\n\t\tbKenInside = isInside( ken, triangle );\n\t\tbOriInside = isInside( ori, triangle );\n\t\tif( ( bKenInside && bOriInside ) ||\n\t\t\t( !bKenInside && !bOriInside ) )\n\t\t\tcout << \"NG\\n\";\n\t\telse\n\t\t\tcout << \"OK\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[j+1]) > EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[j+1]) > EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n  \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    bool operator ==(const Point &p)const{\n        return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n    bool input(){\n        if(cin>>x>>y) return true;\n        return false;\n    }\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n    bool input(){\n        if(a.input() && b.input()) return true;\n        return false;\n    }\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ntypedef Line Segment;\n \ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n    Vector v1 = b-a;\n    Vector v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n    if(dot(v1,v2)<-EPS) return +2; \n    if(v2.norm()-v1.norm()>EPS) return -2; \n    return 0; \n}\n \nPoint project(Segment s,Point p){\n    Vector v1 = s.b-s.a;\n    Vector v2 = p-s.a;\n    double r = dot(v1,v2)/v1.norm();\n    return s.a+v1*r;\n}\n \nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n \nbool intersect_ll(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ss(Segment s,Segment t,Point &p){\n    Vector a1,a2,b1,b2;\n    a1 = s.b-s.a; a2 = t.b-t.a;\n    b1 = t.a-s.a; b2 = s.a-t.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(t.a.x+a2.x*s1/(s1+s2),t.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ll(Line l,Line m,Point &p){\n    if(intersect_ll(l,m)==false) return 0; \n    if(crosspoint_ss(l,m,p)==true) return 1;\n    return -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n    if(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n        return -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n \nint contain_gp(Polygon g,Point p){\n    Line l = Line(p,Point(INF,p.y));\n    int cnt = 0, n = g.size();\n    for(int i=0;i<n;i++){\n        Vector a = g[i]-p;\n        Vector b = g[(i+1)%n]-p;\n        if(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n        if(a.y>b.y) swap(a,b);\n        if(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n    }\n    if((cnt&1)==1) return 2; \n    return 0; \n}\n \nPolygon andrewScan(Polygon s){\n    if(s.size()<=2) return s;\n    sort(s.begin(),s.end());\n    Polygon g;\n    for(int i=0;i<s.size();i++){\n        for(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    int upper_n = g.size();\n    for(int i=s.size()-2;i>=0;i--){\n        for(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    reverse(g.begin(),g.end());\n    g.pop_back();\n    return g;\n}\n\nint main(){\n\tPolygon g(3);\n\tPoint k, s;\n\tint N;\n\t\n\tcin >> N;\n\tfor(int ds = 0; ds < N; ds++){\n\t\tfor(int i = 0; i < 3; i++) g[i].input();\n\t\tk.input(); s.input();\n\t\tif( contain_gp(g, s) && !contain_gp(g, k) ) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n \nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n   \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n    segment temp;\n    temp.a=p[i];\n    temp.b=p[j];\n    seg.push_back(temp);\n      }\n    }\n  }\n \n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n  if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n    if(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n      fg=1;\n      break;\n    }\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n \nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n \n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n   \n  return 1;\n}\n \nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n \n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    seg=construct_edge(p,3);\n \n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long double ld;\ntypedef vector<int> vi;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nbool isin(int a,int b,int c,int d,int p,int q)\n{\n\t//printf(\"%d %d %d %d %d %d\\n\",a,b,c,d,p,q);\n\tld s,t;\n\tld A=a,B=b,C=c,D=d,P=p,Q=q;\n\tif(b==0)\n\t{\n\t\tt=Q/D;\n\t\ts=P/A-(C*Q)/(A*D);\n\t\t//cout << s << ' ' << t << endl;\n\t\tif(s>0&&t>0&&s+t<1)return true;\n\t\telse return false;\n\t}\n\tif(a==0)\n\t{\n\t\tt=P/C;\n\t\ts=Q/B-(D*Q)/(B*C);\n\t\t//cout << s << ' ' << t << endl;\n\t\tif(s>0&&t>0&&s+t<1)return true;\n\t\telse return false;\n\t}\n\tt=(P*B-A*Q)/(B*C-A*D);\n\ts=(P-C*t)/A;\n\t//cout << s << ' ' << t << endl;\n\tif(s>0&&t>0&&s+t<1)return true;\n\telse return false;\n}\nint main()\n{\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tint x1,x2,x3,y1,y2,y3,xk,yk,xs,ys;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tscanf(\"%d %d %d %d %d %d %d %d %d %d\",&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tint a,b,c,d,p,q,r,s;\n\t\ta=x2-x1;\n\t\tb=y2-y1;\n\t\tc=x3-x1;\n\t\td=y3-y1;\n\t\tp=xk-x1;\n\t\tq=yk-y1;\n\t\tr=xs-x1;\n\t\ts=ys-y1;\n\t\tbool orihime = isin(a,b,c,d,p,q);\n\t\tbool kengyu = isin(a,b,c,d,r,s);\n\t\tif(kengyu!=orihime)cout << \"OK\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ntypedef vector<P> G;\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n      P a = curr(g,i) - p, b = next(g,i) - p;\n      if (imag(a) > imag(b)) swap(a, b);\n      if (imag(a) <= 0 && 0 < imag(b))\n        if (cross(a, b) < 0) in = !in;\n      if (cross(a, b) == 0 && dot(a, b) <= 0) return true;\n    }\n  return in ? true : false;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int q=0; q < n; q++){\n        G g(3); P a, b;\n        double xp1,yp1,xp2,yp2,xp3,yp3, xk, yk, xs, ys;\n        cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        g[0] = P(xp1, yp1); g[1] = P(xp2, yp2); g[2] = P(xp3, yp3);\n        a = P(xk, yk); b = P(xs, ys);\n        cout << (contains(g, a) xor contains(g, b) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-3;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\nint main(void){\n  int n;\n  cin>>n;\n  while(n--){\n    vector<P> point(5);\n    REP(i,5){\n      double x,y;\n      cin>>x>>y;\n      point[i] = P(x,y);\n    }\n    double S = abs(cross(point[2]-point[0],point[1]-point[0]));\n    double par = 0;\n    bool in1,in2;\n    REP(i,3){\n      par += abs(cross(point[i]-point[3],point[(i+1)%3]-point[3]));\n    }\n    in1 = (abs(S-par)<EPS);\n    par = 0;\n    REP(i,3){\n      par += abs(cross(point[i]-point[4],point[(i+1)%3]-point[4]));\n    }\n    in2 = (abs(S-par)<EPS);\n    if((in1&&in2)||!(in1||in2)){\n      cout<<\"NG\"<<endl;\n    }else{\n      cout<<\"OK\"<<endl;\n    }\n  }\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\ntypedef double DD;\n\nconst DD INF = 1LL<<60;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    return 0;\n}\n\n\nbool is_contain(Point p, Point a, Point b, Point c) {\n    int r1 = ccw(p, b, c), r2 = ccw(p, c, a), r3 = ccw(p, a, b);\n    if (r1 == 1 && r2 == 1 && r3 == 1) return true;\n    if (r1 == -1 && r2 == -1 && r3 == -1) return true;\n    return false;\n}\n\nint main() {\n    Point p[3], a, b;\n    int n;\n    cin >> n;\n    for (int id = 0; id < n; ++id) {\n        for (int i = 0; i < 3; ++i) cin >> p[i].x >> p[i].y;\n        cin >> a.x >> a.y >> b.x >> b.y;\n        int j1 = is_contain(a, p[0], p[1], p[2]);\n        int j2 = is_contain(b, p[0], p[1], p[2]);\n        if (j1 == j2) puts(\"NG\");\n        else puts(\"OK\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\n\n//時計回りに辺を構築する。\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n/*\n点と多角形の内外判定\n\nps 多角形の辺\np  点\nn  多角形の辺の数\n\n点が多角形に含まれれば1,\nそうでなければ0を返す。\n*/\nint point_contain(vector<segment> ps, point p, int n){\n  point q;\n  q.x=100000000;\n  q.y=p.y;\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(ps[i].a.y==p.y || ps[i].b.y ==p.y)cnt+=2;\n    else cnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  }\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    seg=construct_edge(p,3);\n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\t  cnt+=is_intersected_ls(p[i],p[j],k,s);\n    \n    if(cnt%2)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  else return true;\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    /*\n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    */\n    //if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n\ntypedef double D;\nD EPS = 1e-10;\n\nstruct Point {\n\tD x, y;\n\tPoint() {}\n\tPoint (D _x, D _y) : x(_x), y(_y) {}\n};\ntypedef Point Vector;\t// typedef テ」ツ?ァテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツッツセテ・ツソツ?\n\n// operator\nPoint operator + (const Point& a, const Point& b) { return Point(a.x+b.x, a.y+b.y); }\nPoint operator - (const Point& a, const Point& b) { return Point(a.x-b.x, a.y-b.y); }\nPoint operator * (const Point& a, const Point& b) { return Point(a.x*b.x, a.y*b.y); }\nPoint operator / (const Point& a, const Point& b) { return Point(a.x/b.x, a.y/b.y); }\nbool operator < (const Point& a, const Point& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool operator > (const Point& a, const Point& b) { return b.x != a.x ? b.x < a.x : b.y < a.y; }\nbool operator == (const Point& a, const Point& b) { return fabs(a.x-b.x)<EPS && fabs(a.y-b.y)<EPS; }\n\n// テ・ツ淞コテヲツ慊ャテァツ堋?」ツ?ェテゥツ鳴「テヲツ閉ー\nD norm(const Point& a) { return sqrt(a.x*a.x + a.y*a.y); }\nD dot(const Vector& a, const Vector& b) { return a.x*b.x + a.y*b.y; }\t// テ・ツ??ァツゥツ?\nD cross(const Vector& a, const Vector& b) { return a.x*b.y - a.y*b.x; }\t// テ・ツ、ツ姪ァツゥツ?\nD dist(const Point& a, const Point& b) { return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)); } // ティツキツ敕ゥツ崢「\nbool isVertical(const Vector& a, const Vector& b) { return fabs(dot(a,b))<EPS; }\t// テ・ツ楪づァツ崢エテ・ツ按、テ・ツョツ?\nbool isParrallel(const Vector& a, const Vector& b) { return fabs(cross(a,b))<EPS; } // テ・ツケツウティツ。ツ古・ツ按、テ・ツョツ?\n\nstruct Line {\n\tPoint s, e;\n\tLine (Point _s, Point _e) {\n\t\ts = _s; e = _e;\n\t}\n};\n\nbool PointOnLine(const Point& p, const Line& l) {\n\tint minx = min(l.s.x, l.e.x), maxx = max(l.s.x, l.e.x);\n\tint miny = min(l.s.y, l.e.y), maxy = max(l.s.y, l.e.y);\n\tif ( !(minx <= p.x && p.x <= maxx && miny <= p.y && p.y <= maxy) ) return false;\n\tVector v1 = p - l.s, v2 = l.e - l.s;\n\treturn isParrallel(v1, v2);\n}\n\nenum { IN, ON, OUT };\nint PointInTri(const vector<Point>& tri, const Point& p) {\n    int cnt = 0;\n    for (int i=1; i<4; i++) {\n        Point p0 = tri[i-1], p1 = tri[i%3];\n        bool flag0x = (p.x <= p0.x), flag0y = (p.y <= p0.y);\n        bool flag1x = (p.x <= p1.x), flag1y = (p.y <= p1.y);\n        \n        Line p0top1(p0, p1);\n        if (PointOnLine(p, p0top1)) return ON;\n         \n        if (flag0y != flag1y) {\n            if ( flag1x && flag0x) {\n                cnt += flag0y ? -1 : 1;\n            } else if (p.x <= ( p0.x+(p1.x-p0.x)*(p.y-p0.y)/(p1.y-p0.y) ) ) {\n                cnt += flag0y ? -1 : 1;\n            }\n        }\n    }\n    return cnt!=0 ? IN : OUT;\n}\n \nint main() {\n    int n; cin >> n;\n     \n    vector<Point> tri(3);\n    for (int i=0; i<n; i++) {\n        cin >> tri[0].x >> tri[0].y >> tri[1].x >> tri[1].y >> tri[2].x >> tri[2].y;\n        Point p1; cin >> p1.x >> p1.y;\n        Point p2; cin >> p2.x >> p2.y;\n        bool flag1 = (PointInTri(tri, p1) == IN), flag2 = (PointInTri(tri, p2) == IN);\n        if ( flag1 != flag2 ) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n    int a;\n    scanf(\"%d\",&a);\n    while(a--){\n        int ax,bx,cx,dx,ex;\n        int ay,by,cy,dy,ey;\n        scanf(\"%d%d%d%d%d%d%d%d%d%d\",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy,&ex,&ey);\n        int count=0;\n        int p=(dx-ax)*(by-ay)-(dy-ay)*(bx-ax);\n        int q=(dx-bx)*(cy-by)-(dy-by)*(cx-bx);\n        int r=(dx-cx)*(ay-cy)-(dy-cy)*(ax-cx);\n        if(p>=0&&q>=0&&r>=0)count++;\n        else if(p<=0&&q<=0&&r<=0)count++;\n        p=(ex-ax)*(by-ay)-(ey-ay)*(bx-ax);\n        q=(ex-bx)*(cy-by)-(ey-by)*(cx-bx);\n        r=(ex-cx)*(ay-cy)-(ey-cy)*(ax-cx);\n        if(p>=0&&q>=0&&r>=0)count++;\n        else if(p<=0&&q<=0&&r<=0)count++;\n        if(count==1)printf(\"OK\\n\");\n        else printf(\"NG\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef double D; \n#define EPS (1e-10)\n#define equal(a,b) (fabs((a)-(b)) < EPS)\n\nD add(D a,D b){\n  if(abs(a + b) < EPS * (abs(a) + abs(b))){\n    return 0;\n  }\n  return a + b;\n}\n\nstruct Point{\n  D x,y;\n\n  Point (D x = 0, D y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point(add(x,p.x) , add(y,p.y));\n  }\n  Point operator - (Point p) {\n    return Point(add(x,p.x) ,add(y,-p.y));\n  }\n  Point operator * (D a) {\n    return Point( a*x , a*y );\n  }\n  \n  D norm() {\n    return x*x+y*y;\n  }\n\n  D dot(Point p){\n    return add(x*p.x , y*p.y);\n  }\n\n  D det(Point p){\n    return add(x*p.y , -y*p.x);\n  }  \n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n\n  if(a.det(b) > EPS) return 1;\n  if(a.det(b) < -EPS) return -1;\n  if(a.dot(b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nD S(Point p1,Point p2,Point p3){\n  D a = sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));\n  D b = sqrt(pow(p1.x-p3.x,2) + pow(p1.y-p3.y,2));\n  D c = sqrt(pow(p3.x-p2.x,2) + pow(p3.y-p2.y,2));\n  D s = (a + b + c) / 2;\n\n  return sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\nbool check(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) < 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) < 0);\n}\n\nbool eq(D S1,D S2){\n  return ((float)S1 == (float)S2);\n}\n\nint main(){\n  int n;\n  Point P[3],T[2];\n\n  cin >> n;\n  while(n--){\n    scanf(\"%lf %lf\" ,&P[0].x ,&P[0].y);\n    scanf(\"%lf %lf\" ,&P[1].x ,&P[1].y);\n    scanf(\"%lf %lf\" ,&P[2].x ,&P[2].y);\n    scanf(\"%lf %lf\" ,&T[0].x ,&T[0].y);\n    scanf(\"%lf %lf\" ,&T[1].x ,&T[1].y);\n\n    bool ok = false;\n    D S1 = S(P[0],P[1],P[2]);\n    D S2 = S(P[0],P[1],T[0])+S(P[0],P[2],T[0])+S(P[1],P[2],T[0]);\n    D S3 = S(P[0],P[1],T[1])+S(P[0],P[2],T[1])+S(P[1],P[2],T[1]);\n\n    if(check(P[0],P[1],T[0],T[1]) &&\n       ((eq(S1,S2) && !eq(S1,S3)) || \n\t(!eq(S1,S2) && eq(S1,S3)))){\n      ok = true;\n    }    \n    if(check(P[0],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n    if(check(P[1],P[2],T[0],T[1]) &&\n       (eq(S1,S2) && !eq(S1,S3)) ||\n       (!eq(S1,S2) && eq(S1,S3))){\n      ok = true;\n    }  \n\n    if(ok){\n      puts(\"OK\");\n    }else{\n      puts(\"NG\");\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=900000;\n  q.y=1000000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b)(fabs((a)-(b))<EPS)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct Point {\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\tPoint operator*(double a) { return Point(a*x, a*y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tdouble norm() { return x*x + y*y; }\n};\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\nstruct Segment {\n\tPoint p1, p2;\n};\ndouble cross(Point a, Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\ndouble dot(Point a, Point b) {\n\treturn a.x*b.x + a.y*b.y;\n}\nbool isPrallel(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\trep(i, n) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn x ? 2 : 0;\n}\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (cross(a, b) > EPS)return 1;\n\tif (cross(a, b) < -EPS)return -1;\n\tif (dot(a, b) < -EPS)return 2;\n\tif (a.norm() < b.norm())return -2;\n\treturn 0;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nPoint project(Segment s, Point p) {\n\tPoint base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\nbool isconvex(Polygon g) {\n\tint back = 3;\n\trep(i, g.size()) {\n\t\tint d = ccw(g[(i + g.size() - 1) % g.size()], g[i], g[(i + 1) % g.size()]);\n\t\tif (back != 3 && d != back)\n\t\t\treturn false;\n\t\telse back = d;\n\t}\n\treturn true;\n}\ndouble area(Polygon g) {\n\tdouble cnt = 0;\n\trep(i, g.size())\n\t\tcnt += g[i].x*g[(i + 1) % g.size()].y - g[(i + 1) % g.size()].x*g[i].y;\n\treturn abs(cnt) / 2;\n}\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\tdouble xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\tPoint a(xp1, yp1), b(xp2, yp2), c(xp3, yp3), k(xk, yk), s(xs, ys);\n\t\tVector AB = b - a, BP = k - b, BC = c - b, CP = k - c, CA = a - c, AP = k - a;\n\t\tbool flag = false;\n\t\tdouble c1 = cross(CA, AP), c2 = cross(BC, CP), c3 = cross(AB, BP);\n\t\tif ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0))flag = true;\n\t\tBP = s - b, CP = s - c, AP = s - a;\n\t\tc1 = cross(CA, AP), c2 = cross(BC, CP), c3 = cross(AB, BP);\n\t\tif ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0))flag ^= true;\n\t\tputs(flag ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\nint Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  for(int t=0;t<n;t++){\n    p_t p,q,r,k,s;\n    cin>>p.x>>p.y>>q.x>>q.y>>r.x>>r.y>>k.x>>k.y>>s.x>>s.y;\n    l_t pq,qr,rp,ks;\n    pq.a=p;\n    pq.b=q;\n    qr.a=q;\n    qr.b=r;\n    rp.a=r;\n    rp.b=p;\n    ks.a=k;\n    ks.b=s;\n    int ans=0;\n    ans+=Crosspoint(pq,ks);\n    ans+=Crosspoint(qr,ks);\n    ans+=Crosspoint(rp,ks);\n    if(ans==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\nint Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS) return 0;\n  if(B/A>0&&B/A<1) return 1;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\t  cnt+=is_intersected_ls(p[i],p[j],k,s);\n    \n    if(cnt%2)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\n\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool in_tri(const P& p, const VP& tri){\n    return cross(tri[1]-tri[0], p-tri[0])>0 &&\n        cross(tri[2]-tri[1], p-tri[1])>0 &&\n        cross(tri[0]-tri[2], p-tri[2])>0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i=0; i<n; i++){\n        VP tri(3);\n        for(int j=0; j<3; j++){\n            int x,y;\n            cin >> x >> y;\n            tri[j] = P(x,y);\n        }\n        VP sg(2);\n        for(int j=0; j<2; j++){\n            int x,y;\n            cin >> x >> y;\n            sg[j] = P(x,y);\n        }\n        if(in_tri(sg[0], tri) != in_tri(sg[1], tri)){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) )\n\ntypedef complex<double> p;\n\ndouble cross(p a, p b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tp point[5];\n\t\tREP(i, 5) {\n\t\t\tdouble a, b;\n\t\t\tscanf(\"%lf %lf\", &a, &b);\n\t\t\tpoint[i] = p(a, b);\n\t\t}\n\t\tint cnt[2] = {};\n\t\t\n\t\tREP(i, 3) {\n\t\t\tp v[2];\n\t\t\tv[0] = point[(i + 1) % 3] - point[i];\n\t\t\tv[1] = point[3] - point[i];\n\t\t\tif (cross(v[0], v[1]) < -EPS) cnt[0]++;\n\t\t\t\n\t\t\tv[1] = point[4] - point[i];\n\t\t\tif (cross(v[0], v[1]) < -EPS) cnt[1]++;\n\t\t}\n\t\tbool flag[2];\n\t\tREP(i, 2) flag[i] =  cnt[i] == 0;\n\t\tif (flag[0] == !flag[1]) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct point{\n\tdouble x;\n\tdouble y;\n};\n\nint ccw(point p0, point p1, point p2){\n\tdouble dx1 = p1.x - p0.x, dy1 = p1.y - p0.y;\n\tdouble dx2 = p2.x - p0.x, dy2 = p2.y - p0.y;\n\tif(dx1 * dy2 > dx2 * dy1){\n\t\treturn 1;\n\t}else if(dx1 * dy2 > dx2 * dy1){\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nbool in_t(point p0, point p1, point p2, point p3){\n\tif((ccw(p0, p1, p2) != ccw(p0, p1, p3)\n\t\t&& (ccw(p0, p2, p1) != -ccw(p0, p2, p3))))\n\t\treturn true;\n\telse return false;\n}\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tpoint p1, p2, p3;\n\t\tpoint pk, ps;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y\n\t\t\t>> p3.x >> p3.y >> pk.x >> pk.y >>  ps.x >> ps.y;\n\t\tif((in_t(pk, p1, p2, p3) && !in_t(ps, p1, p2, p3)) ||\n\t\t\t(!in_t(pk, p1, p2, p3) && in_t(ps, p1, p2, p3)))\n\t\t\tcout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint hantei(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy) {\n\tdouble y,m,n,d;\n\tif ((bx-ax==0 && dx-cx==0) || (by-ay==0 && dy-cy==0)) return 0; \n\tif (dx-cx!=0) m=(dy-cy)/(dx-cx);\n\tif (bx-ax!=0) n=(by-ay)/(bx-ax);\n\tif (ax==bx) {\n        if (cy==dy && ((cy>ay && cy<by) || (cy>by && cy<ay)) && ((cx<ax && dx>ax) || (dx<ax && cx>ax))) return 1;\n        y=cy+m*(ax-cx);\n\t\tif (((y>cy && y<dy) || (y>dy && y<cy)) && ((y>ay && y<by) || (y>by && y<ay))) return 1;\n\t\treturn 0;} \n\tif (cx==dx) {\n\t\ty=ay+n*(cx-ax);\n\t\tif (((y>cy && y<dy) || (y>dy && y<cy)) && ((y>ay && y<by) || (y>by && y<ay))) return 1;\n\t\treturn 0;}\n\td=(ay-cy+m*cx-n*ax)/(m-n);\n\tif (((d>cx && d<dx) || (d>dx && d<cx)) &&((d>ax && d<bx) || (d>bx && d<ax)))  return 1;\n\treturn 0;\n}\n\nint main() {\n\tint n,f;\n\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\tcin >> n;\n\tfor (;n>0;n--) {\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        f=hantei(xp1,yp1,xp2,yp2,xk,yk,xs,ys)+hantei(xp2,yp2,xp3,yp3,xk,yk,xs,ys)+hantei(xp1,yp1,xp3,yp3,xk,yk,xs,ys);\n\t\tif (f==1) cout << \"OK\"; else cout << \"NG\";\n\t\tcout << endl;\n\t}\nreturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Vector2D{\n    double x;\n    double y;\n};\n//???????????????(??????????????¨??????)\n#define Vertex2D Vector2D\n\n//?????????????????????(a-b)\nVector2D sub_vector( const Vector2D& a, const Vector2D& b )\n{\n    Vector2D ret;\n    ret.x = a.x - b.x;\n    ret.y = a.y - b.y;\n    return ret;\n}\n\n// ????§???¢??¨?????????????????????(2D?????´???)\n// ?????????    0:????§???¢????????´???????????????    1:????§???¢????????´???????????????\nint hittest_point_polygon_2d( Vertex2D A, Vertex2D B, Vertex2D C, Vertex2D P ) {\n\n    //??????????????¨??????????????????\n    //ABC???????§???¢????????????????????§??????????????\\...\n    \n    Vector2D AB = sub_vector(B, A);\n    Vector2D BP = sub_vector(P, B);\n\n    Vector2D BC = sub_vector(C, B);\n    Vector2D CP = sub_vector(P, C);\n\n    Vector2D CA = sub_vector(A, C);\n    Vector2D AP = sub_vector(P, A);\n\n    //??????    Z?????????????¨????????????°????????§???\n    double c1 = AB.x * BP.y - AB.y * BP.x;\n    double c2 = BC.x * CP.y - BC.y * CP.x;\n    double c3 = CA.x * AP.y - CA.y * AP.x;\n\n    if( ( c1 > 0 && c2 > 0 && c3 > 0 ) || ( c1 < 0 && c2 < 0 && c3 < 0 ) ) {\n        //????§???¢????????´???????????????\n        return 0;\n    }\n\n    //????§???¢????????´???????????????\n    return 1;\n\n}\n\nint main(){\n\t\n\tVertex2D A, B, C, P, Q;\n\t\n\tint n;\n\t\n\tcin >> n;\n\t\n\tfor(int loop = 0; loop < n; loop++){\n\t\tcin >> A.x >> A.y >> B.x >> B.y >> C.x >> C.y >> P.x >> P.y >> Q.x >> Q.y;\n\t\tif((hittest_point_polygon_2d(A, B, C, P) + hittest_point_polygon_2d(A, B, C, Q)) % 2 == 1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n \ntypedef complex<double> P;\n\ndouble triangleArea(P a, P b, P c)\n{\n    b -= a;\n    c -= a;\n    \n    return (0.5 * abs(b.imag() * c.real() - c.imag() * b.real()));\n}\n\n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n    int i;\n    double S = triangleArea(p[0], p[1], p[2]);\n    \n    rep(i, 3) S -= triangleArea(x, p[i], p[(i + 1) % 3]);\n    \n    return abs(S) < EPS;\n}\n \nint main()\n{\n    int n;\n        cin >> n;\n        \n        \n        while(n--)\n        {\n                P p[3];\n                P k, s;\n                \n                rep(i, 3) cin >> p[i].real() >> p[i].imag();\n                cin >> k.real() >> k.imag() >> s.real() >> s.imag();\n        \n                if(isInTriangle(p, k) ^ isInTriangle(p, s))\n                {\n                        cout << \"OK\" << endl;\n                }\n                else\n                {\n                        cout << \"NG\" << endl;\n                }\n        }\n}\n "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<list>\n#include<stack>\n#include<queue>\n#include<cctype>\n#include<iomanip>\n#include<functional>\n#include<numeric>\n#include<map>\n#include<set>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\ntypedef long long llong;\nclass Point {\npublic:\n\tint x, y;\n};\nint cross(Point z, Point a, Point b) {\n\ta.x -= z.x; a.y -= z.y;\n\tb.x -= z.x; b.y -= z.y;\n\treturn a.x*b.y - a.y*b.x;\n}\nbool juge(Point z, Point a, Point b, Point c) {\n\tbool g = false, h = false;\n\tif (cross(z, a, b) > 0 && cross(z, b, c) > 0 && cross(z, c, a) > 0) {\n\t\tg = true;\n\t}\n\tif (cross(z, a, b) < 0 && cross(z, b, c) < 0 && cross(z, c, a) < 0) {\n\t\th = true;\n\t}\n\treturn g || h;\n}\nint main() {\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tPoint p1, p2, p3, k, s;\n\t\tcin >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y >> k.x >> k.y >> s.x >> s.y;\n\t\tbool g = juge(k, p1, p2, p3);\n\t\tbool h = juge(s, p1, p2, p3);\n\t\tif (g^h == true)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define double long double\n\n#define MOD 1000000007LL\n#define EPS 0\nstatic const int INF=1<<24;\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\nvector<P> tri(3);\nvector<P> aa(2);\ndouble dot(rP a, rP b){\n\t// cout<<real(a)<<\" \"<<imag(a)<<\" \"<<real(b)<<\" \"<<imag(b)<<endl;\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint check(P r){\n\tP a=tri[0]-tri[1],ar=r-tri[0];\n\tP b=tri[1]-tri[2],br=r-tri[1];\n\tP c=tri[2]-tri[0],cr=r-tri[2];\n\tdouble A=dot(a,ar),B=dot(b,br),C=dot(c,cr);\n\t// cout<<A<<\" \"<<B<<\" \"<<C<<endl;\n\tif(A>EPS&&B>EPS&&C>EPS) return 1;\n\tif(A<-EPS&&B<-EPS&&C<-EPS) return 1;\n\treturn -1;\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\trep(j,3){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\ttri[j]=P(a,b);\n\t\t}\n\t\trep(j,2){\n\t\t\tdouble a,b;\n\t\t\tcin>>a>>b;\n\t\t\taa[j]=P(a,b);\t\n\t\t}\n\t\tif(check(aa[0])*check(aa[1])<0){\n\t\t\tcout<<\"OK\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\\n\";\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nclass CPoint;\ntypedef CPoint CVector2D;\nclass CSegment;\ntypedef vector <CSegment> CSegments;\ndouble GetSquare( double );\nbool Equal( double, double );\nbool LessthanEqual( double, double );\ndouble GetCrossProduct( double, double, double, double );\ndouble GetCrossProduct( CPoint, CPoint );\ndouble GetDotProduct( double, double, double, double );\ndouble GetDotProduct( CPoint, CPoint );\ndouble GetGradientFromTwoPoints( CPoint, CPoint );\nint CheckCounterClockWise( CPoint, CPoint, CPoint );\nbool Intersect( CPoint, CPoint, CPoint, CPoint );\nbool Intersect( CSegment, CSegment );\nCPoint GetCrossPoint( CSegment, CSegment );\ndouble GetLength( CPoint, CPoint );\nCPoint GetLowestY( CPoint, CPoint );\nclass CPoint {\npublic:\n    double x, y;\n    CPoint( double x, double y ): x(x), y(y) {}\n    CPoint(): x(0), y(0) {};\n    double getNorm() {\n        return x * x + y * y;\n    }\n    double getAbs() {\n        return sqrt( getNorm() );\n    }\n    CPoint operator + ( CPoint p ) {\n        return CPoint( x + p.x, y + p.y );\n    }\n    CPoint operator - ( CPoint p ) {\n        return CPoint( x - p.x, y - p.y );\n    }\n    CPoint operator * ( double k ) {\n        return CPoint( x * k, y * k );\n    }\n    bool operator < ( const CPoint& p ) const {\n        if ( x < p.x ) return true;\n        return x == p.x ? y < p.y : false;\n    }\n};\nCPoint operator * ( double k, CPoint p ) {\n    return CPoint( p.x * k, p.y * k );\n}\nostream& operator << ( ostream& os, CPoint p0 ) {\n    os << \"(\" << p0.x << \", \" << p0.y << \")\";\n    return os;\n}\nclass CSegment {\npublic:\n    CPoint a, b;\n    CSegment( int x1, int y1, int x2, int y2 ): a(CPoint( x1, y1 )), b(CPoint( x2, y2 )) {}\n    CSegment( CPoint a, CPoint b ): a(a), b(b) {}\n    CSegment() {}\n    double getGradient() {\n        return GetGradientFromTwoPoints( a, b );\n    }\n    double getLength() {\n        return GetLength( a, b );\n    }\n    double getMinX() {\n        return min( a.x, b.x );\n    }\n    double getMinY() {\n        return min( a.y, b.y );\n    }\n    double getMaxX() {\n        return max( a.x, b.x );\n    }\n    double getMaxY() {\n        return max( a.y, b.y );\n    }\n    bool operator < ( const CSegment& s ) const {\n        return b.y > s.b.y;\n    }\n    \n};\nostream& operator << ( ostream& os, CSegment s0 ) {\n    os << \"(\" << s0.a << \" - \" << s0.b << \")\";\n    return os;\n}\nclass CCircle {\npublic:\n    CPoint p;\n    int r;\n    CCircle(): p( 0, 0 ), r(0) {}\n    CCircle( int x, int y, int r ): p(x, y), r(r) {}\n    CCircle( CPoint p, int r ): p(p), r(r) {}\n};\nostream& operator << ( ostream& os, CCircle c0 ) {\n    os << \"{(\" << c0.p.x << \", \" << c0.p.y << \"), r = \" << c0.r << \")\";\n    return os;\n}\nclass CTriangle {\npublic:\n    CPoint a;\n    CPoint b;\n    CPoint c;\n    CTriangle( int x1, int y1, int x2, int y2, int x3, int y3 ):\n        a(CPoint(x1,y1)), b(CPoint(x2,y2)), c(CPoint(x3,y3)) {}\n    CTriangle( CPoint a, CPoint b, CPoint c ):\n        a(a), b(b), c(c) {}\n};\nostream& operator << ( ostream& os, CTriangle t0 ) {\n    os << \"{\" << t0.a << \", \" << t0.b << \", \" << t0.c << \"}\";\n    return os;\n}\nconst double EPS = 1e-9;\ndouble GetSquare( double x ) {\n    return x * x;\n}\nbool Equal( double a, double b ) {\n    return fabs( b - a ) < EPS;\n}\nbool LessthanEqual( double a, double b ) {\n    return a < b ? true : ( fabs( b - a ) < EPS );\n}\ndouble GetCrossProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * y2 - y1 * x2;\n}\ndouble GetCrossProduct( CPoint a, CPoint b ) {\n    return GetCrossProduct( a.x, a.y, b.x, b.y );\n}\ndouble GetDotProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * x2 + y1 * y2;\n}\ndouble GetDotProduct( CPoint a, CPoint b ) {\n    return GetDotProduct( a.x, a.y, b.x, b.y );\n}\nbool Intersect( CPoint p1, CPoint p2, CPoint p3, CPoint p4 ) {\n    bool f1 = CheckCounterClockWise( p1, p2, p3 ) * CheckCounterClockWise( p1, p2, p4 ) <= 0;\n    bool f2 = CheckCounterClockWise( p3, p4, p1 ) * CheckCounterClockWise( p3, p4, p2 ) <= 0;\n    return f1 && f2;\n}\nbool Intersect( CSegment s1, CSegment s2 ) {\n    return Intersect( s1.a, s1.b, s2.a, s2.b );\n}\nbool Contain( CTriangle a, CPoint p ) {\n    CVector2D AP = p - a.a;\n    CVector2D BP = p - a.b;\n    CVector2D CP = p - a.c;\n    CVector2D AB = a.b - a.a;\n    CVector2D BC = a.c - a.b;\n    CVector2D CA = a.a - a.c;\n    if ( GetCrossProduct( AP, AB ) < 0.0 ) return false;\n    if ( GetCrossProduct( BP, BC ) < 0.0 ) return false;\n    if ( GetCrossProduct( CP, CA ) < 0.0 ) return false;\n    return true;\n}\ndouble GetGradientFromTwoPoints( CPoint a, CPoint b ) {\n    return ( b.y - a.y ) / ( b.x - a.x );\n}\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\nint CheckCounterClockWise( CPoint p0, CPoint p1, CPoint p2 ) {\n    CVector2D a = p1 - p0;\n    CVector2D b = p2 - p0;\n    if ( GetCrossProduct( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n    if ( GetCrossProduct( a, b ) < EPS ) return CLOCKWISE;\n    if ( GetDotProduct( a, b ) < -EPS ) return ONLINE_BACK;\n    if ( a.getNorm() < b.getNorm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nCPoint GetCrossPoint( CSegment s1, CSegment s2 ) {\n    CVector2D base = s2.b - s2.a;\n    double d1 = abs( GetCrossProduct( base, s1.a - s2.a ) );\n    double d2 = abs( GetCrossProduct( base, s1.b - s2.a ) );\n    double t = d1 / ( d1 + d2 );\n    return s1.a + ( s1.b - s1.a ) * t;\n}\ndouble GetLength( CPoint a, CPoint b ) {\n    return sqrt( GetSquare( a.x - b.x ) + GetSquare( a.y - b.y ) );\n}\nCPoint GetLowestY( CPoint a, CPoint b ) {\n    if ( a.y == b.y ) return a.x < b.x ? a : b;\n    return a.y < b.y ? a : b;\n}\ndouble GetDistance( CSegment seg, CPoint p ) {\n    if ( GetDotProduct( seg.b - seg.a, p - seg.a ) < EPS ) return (p - seg.a).getAbs();\n    if ( GetDotProduct( seg.a - seg.b, p - seg.b ) < EPS ) return (p - seg.b).getAbs();\n    return fabs( GetCrossProduct( seg.b - seg.a, p - seg.a ) ) / ( seg.b - seg.a ).getAbs();\n}\nbool CheckIntersect( CSegment seg, CCircle c ) {\n    bool f1 = LessthanEqual( ( c.p - seg.a ).getAbs(), c.r );\n    bool f2 = LessthanEqual( ( c.p - seg.b ).getAbs(), c.r );\n    if ( f1 ^ f2 ) return true;\n    return LessthanEqual( GetDistance( seg, c.p ), c.r ) && ( ! f1 && ! f2 );\n}\n\n\nconst string YES = \"OK\";\nconst string NO = \"NG\";\nint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\nstring solve() {\n    CPoint A( xs, ys ), B( xk, yk );\n    CPoint P[3] = { CPoint( xp1, yp1 ), CPoint( xp2, yp2 ), CPoint( xp3, yp3 ) };\n    sort( P, P+3 );\n    \n    do {\n        CTriangle T( P[0], P[1], P[2] );\n        if ( Contain( T, A ) ^ Contain( T, B ) ) return YES;\n    } while ( next_permutation( P, P + 3 ) );\n    return NO;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for ( int i = 0; i < n; ++ i ) {\n        cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-10;\n\nstruct P {\n  double x, y;\n  P(double x = 0.0, double y = 0.0): x(x), y(y) {}\n};\n\nbool inTri(P p[3], P a) {\n  double dx[2], dy[2];\n  double area_p, area_a = 0.0;\n\n  for (int i = 0; i < 2; i++) {\n    dx[i] = p[i].x - p[2].x;\n    dy[i] = p[i].y - p[2].y;\n  }\n\n  area_p = abs(dx[0] * dy[1] - dx[1] * dy[0]) / 2.0;\n\n  for (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 2; j++) {\n      dx[j] = p[(i + j) % 3].x - a.x;\n      dy[j] = p[(i + j) % 3].y - a.y;\n    }\n\n    area_a += abs(dx[0] * dy[1] - dx[1] * dy[0]) / 2.0;\n  }\n\n  return area_a - area_p < eps;\n}\n\nint main(void) {\n  int n;\n  cin >> n;\n\n  P pp[3], pk, ps;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 3; j++) {\n      cin >> pp[j].x >> pp[j].y;\n    }\n    cin >> pk.x >> pk.y >> ps.x >> ps.y;\n\n    bool in_k = inTri(pp, pk), in_s = inTri(pp, ps);\n    if ((in_k && !in_s) || (!in_k && in_s)) {\n      cout << \"OK\\n\";\n    } else {\n      cout << \"NG\\n\";\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n\n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n\n\n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  double ymx=-100000000,ymn=100000000;\n  for(i=0;i<N+1;i++){\n    ymx=max(ymx,p[i].y);\n    ymn=min(ymn,p[i].y);\n  }\n  if(lt.a.y<=ymn||lt.a.y>=ymx)return 0;\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint sign(int n){\n\tif(n < 0) return -1;\n\tif(n > 0) return 1;\n\treturn 0;\n}\n\nfloat angle(int ax, int ay, int bx, int by, int cx, int cy){\n    //angle between ab and ac\n    float ab = atan2(by-ay,bx-ax);\n    float ac = atan2(cy-ay,cx-ax);\n    if(ab < 0)ab += 2*M_PI;\n    if(ac < 0)ac += 2*M_PI;\n    float ang = ac - ab;\n    return (fabs(ang) < M_PI ? ang : -sign(ang) * 2 * M_PI + ang) * 180 / M_PI;\n}\n\nint isPointInTriangle(vector< int > &x, vector< int > &y, int px, int py){\n\tint n = x.size();\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i < n; ++i){\n\t\tsum += angle(px, py, x[i], y[i], x[(i+1)%n], y[(i+1)%n]);\n\t}\n\t\n\treturn (sum > 350 ? 1 : -1) ;\n}\n\nint main(){\n\tint n;\n\tint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\tvector< int > x(3, 0);\n\tvector< int > y(3, 0);\n\t\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\t\t\n\t\tx[0] = xp1;\n\t\tx[1] = xp2;\n\t\tx[2] = xp3;\n\t\t\n\t\ty[0] = yp1;\n\t\ty[1] = yp2;\n\t\ty[2] = yp3;\n\t\t\n\t\tcout << (isPointInTriangle(x, y, xk, yk) * isPointInTriangle(x, y, xs, ys) < 0 ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt1=0,cnt2=0;\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(t.a,t.b,ps[i])){\n      cnt1++;\n      continue;\n    }\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt2++;\n  }\n  return ((cnt1/2)+cnt2)%2;\n}\n\nint main(void){\n  int n;\n  point p[5],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n \n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nHokudai Practice Contest 2014\nH - Altair and Vega\n\nティツァツ」テヲツウツ陛ッツシツ堙ァツつケテ」ツ?ョテ・ツ??・ツ個?・ツ按、テ・ツョツ?\nティツィツ暗ァツョツ療・ツケツセテ、ツスツ陛」ツ?ョテ・ツ閉湘ゥツ。ツ古」ツ??\nテァツつケテ」ツ?古、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ォテ・ツ??・ツ個?」ツ?陛」ツつ古」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?ァテ」ツ?催」ツつ古」ツ?ーテ」ツつ暗」ツ??」ツ??\nテ・ツ??・ツ個?・ツ按、テ・ツョツ堙」ツ?ォテ」ツ?ッテ」ツ??」ツつ催」ツ??」ツつ催」ツ?ェテヲツ鳴ケテヲツウツ陛」ツ?古」ツ?づ」ツつ凝」ツ?古」ツ??\n |テ「ツ鳴ウabc| = |テ「ツ鳴ウabx| + |テ「ツ鳴ウbcx| + |テ「ツ鳴ウcax|\nテ」ツ?古ヲツ按静」ツつ甘ァツォツ凝」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津」ツδ?」ツつァテ」ツδε」ツつッテ」ツ?凖」ツつ凝ヲツ鳴ケテヲツウツ陛」ツ?古ァツーツ。テ・ツ債佚」ツ?ァテ」ツ?づ」ツつ凝」ツ??\n\nテァツ可ステァツ可崚」ツ?ィテァツケツ氾・ツ・ツウテ」ツ?古」ツ?ィテ」ツつづ」ツ?ォテ・ツ青古」ツ?佚、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ォテ・ツ青ォテ」ツ?セテ」ツつ古」ツつ凝」ツつアテ」ツδシテ」ツつケテ」ツ?ォテヲツウツィテヲツ?湘」ツ?凖」ツつ凝」ツ??\n\nテ・ツケツセテ、ツスツ陛・ツ閉湘ゥツ。ツ古」ツ?ィテ」ツ?療」ツ?ヲテ」ツ?ッテ」ツ?凝」ツ?ェテ」ツつ甘・ツ按敕ァツュツ嘉」ツ?ョテ・ツ閉湘ゥツ。ツ古」ツ?ァテ」ツ?！CPCテ」ツ?ァテ・ツョツ淌ゥツ堋崚」ツ?ォテ・ツ?コテゥツ。ツ古」ツ?陛」ツつ古」ツつ凝・ツケツセテ、ツスツ陛」ツ?ッテヲツ閉ーテヲツョツオテゥツ崢」テ」ツ?療」ツ??」ツ??\n\nテヲツ卍づゥツ鳴禿ィツィツ暗ァツョツ療ゥツ?湘ッツシツ唹(1)\n*/\n\n#include<iostream>\n#include<complex>\nusing namespace std;\n\n//テ・ツケツセテ、ツスツ陛・ツ閉湘ゥツ。ツ古」ツ?ァテ」ツ?ッテゥツ?づァツつケテ」ツつ津ィツ。ツィテ」ツ?凖」ツ?ョテ」ツ?ォcomplexテ・ツ楪?ティツ、ツ?ァツエツ?ヲツ閉ーテ・ツ楪?テ」ツつ津ァツ板ィテ」ツ??」ツつ凝」ツ?禿」ツ?ィテ」ツ?古」ツ?ァテ」ツ?催」ツつ?\n//ティツ、ツ?ァツエツ?ヲツ閉ーテ」ツつ津」ツ??ィツ、ツ?ァツエツ?・ツケツウテゥツ敖「テ、ツクツ甘」ツ?ョテ」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ィティツヲツ凝」ツ?ェテ」ツ?療」ツ?ヲテ・ツ?ヲテァツ青?」ツ?凖」ツつ?\n//テ、ツセツソテ・ツ按ゥテ」ツ?ェテゥツ鳴「テヲツ閉ーテ」ツ?ィテ」ツ?療」ツ?ヲテ」ツ??・ツ環?ヲツクツ崚ァツョツ療」ツつ?」ツつケテ」ツつォテ」ツδゥテ」ツδシテ・ツ?催」ツ??ァツオツカテ・ツッツセテ・ツ?、ティツィツ暗ァツョツ療」ツ?ェテ」ツ?ゥテ」ツ?古・ツ按ゥテァツ板ィテ」ツ?ァテ」ツ?催」ツつ?\ntypedef complex<double> P;\nconst double EPS = 1e-9;\n\n//テ・ツ、ツ姪ァツゥツ?\ndouble cross(P x,P y){return real(x)*imag(y) - imag(x)*real(y);}\n\n//テ、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble area(P a,P b,P c){ return abs(cross(b-a,c-a)/2); }\n\n//テ、ツクツ嘉ィツァツ津・ツスツ「abcテ」ツ?ォテァツつケxテ」ツ?古・ツ青ォテ」ツ?セテ」ツつ古」ツ?ヲテ」ツ??」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津・ツ按、テ・ツョツ?\nbool inter(P a,P b,P c,P x){\n  //テヲツオツョテ・ツ仰陛・ツーツ湘ヲツ閉ーテァツつケテヲツシツ氾ァツョツ療」ツ?ァテ」ツ?ッティツェツ、テ・ツキツョテ・ツ?ヲテァツ青?」ツつ津ィツ。ツ古」ツ??\n  //テ」ツ?警 > y +EPSテ」ツ?催」ツ?ッテゥツ?堙・ツクツクテ」ツ?ョティツィツ暗ァツョツ療」ツ?ォテ」ツ?甘」ツ?妥」ツつ凝」ツ?警>yテ」ツ?催」ツ?ォテ・ツスツ禿」ツ?淌」ツつ?\n  //テ」ツ?警 > y -EPSテ」ツ?催」ツ?づ」ツつ凝」ツ??」ツ?ッテ」ツ?警 +EPS > yテ」ツ?催」ツ?ッテゥツ?堙・ツクツクテ」ツ?ョティツィツ暗ァツョツ療」ツ?ォテ」ツ?甘」ツ?妥」ツつ凝」ツ?警>=yテ」ツ?催」ツ?ォテ・ツスツ禿」ツ?淌」ツつ?\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) + EPS)return false;\n  return true;\n}\n\nint main(){\n  int n;\n  P p1,p2,p3,pk,ps;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    double x,y;\n    cin >> x >> y; p1 = P(x,y);\n    cin >> x >> y; p2 = P(x,y);\n    cin >> x >> y; p3 = P(x,y);\n    cin >> x >> y; pk = P(x,y);\n    cin >> x >> y; ps = P(x,y);\n\n    //テ、ツクツ嘉ィツァツ津・ツスツ「テ」ツ?ォテ・ツ青古ヲツ卍づ」ツ?ォテ・ツ青ォテ」ツ?セテ」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝・ツ按、テ・ツョツ?\n    if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-9\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        //入力を多少簡略化\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n#include <set>\n\n\nusing namespace std;\n\n//二次元の外積\n//回転の方向\ndouble gaiseki(double x1, double y1, double x2, double y2){\n    return x1*y2-x2*y1;\n}\n\nbool inside_outside_of_triangle(double xpa, double ypa, double xpb, double ypb, double xpc, double ypc, double x, double y){\n    double vab_x = xpa-xpb;\n    double vab_y = ypa-ypb;\n    double vbc_x = xpb-xpc;\n    double vbc_y = ypb-ypc;\n    double vca_x = xpc-xpa;\n    double vca_y = ypc-ypa;\n    double vap_x = xpa-x;\n    double vap_y = ypa-y;\n    double vbp_x = xpb-x;\n    double vbp_y = ypb-y;\n    double vcp_x = xpc-x;\n    double vcp_y = ypc-y;\n    \n    double direction_a = gaiseki(vca_x,vca_y,vap_x,vap_y);\n    double direction_b = gaiseki(vab_x,vab_y,vbp_x,vbp_y);\n    double direction_c = gaiseki(vbc_x,vbc_y,vcp_x,vcp_y);\n    \n    direction_a/=fabs(direction_a);\n    direction_b/=fabs(direction_b);\n    direction_c/=fabs(direction_c);\n    \n    if(direction_a==direction_b&&direction_b==direction_c)return true;\n    else return false;\n\n}\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int i=0; i<n; i++){\n            double xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n            cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n            bool in_bega = inside_outside_of_triangle(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n            bool in_altair = inside_outside_of_triangle(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n            if((in_bega&&!in_altair)||(!in_bega&&in_altair))cout<<\"OK\"<<endl;\n            else cout<<\"NG\"<<endl;\n        }\n   \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ndouble x[5], y[5];\n\nbool check() {\n  double xa[3], ya[3], s[3];\n  bool in[2], b[3];\n  for (int i=0; i<3; i++) {\n    xa[i] = y[(i+1)%3] - y[i];\n    ya[i] = -x[(i+1)%3] + x[i];\n    s[i] = xa[i]*x[i] + ya[i]*y[i];\n  }\n  for (int i=0; i<2; i++) {\n    for (int j=0; j<3; j++) {\n      b[j] = (xa[j]*x[i+3] + ya[j]*y[i+3] < s[j]);\n    }\n    in[i] = (b[0] == b[1] && b[1] == b[2]);\n  }\n  return (in[0] != in[1]);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i=0; i<n; i++) {\n    for (int j=0; j<5; j++) {\n      cin >> x[j] >> y[j];\n    }\n    if (check()) {\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#define EPS 1e-10\nstruct vektor{\n\tdouble x,y;\n\tvektor(){}\n\tvektor(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tdouble add(double a,double b){\n\t\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\t\treturn a+b;\n\t}\n\tvektor operator +(vektor v){\n\t\treturn vektor(x+v.x,y+v.y);\n\t}\n\n\tvektor operator -(vektor v){\n\t\treturn vektor(x-v.x,y-v.y);\n\t}\n\tvektor operator *(double d){\n\t\treturn vektor(x*d,y*d);\n\t}\n\tdouble dot(vektor v){\n\t\treturn add(x*v.x,y*v.y);\n\t}\n\tdouble det(vektor v){\n\t\treturn add(x*v.y,-y*v.x);\n\t}\n};\n\nbool on_seg(vektor p1,vektor p2,vektor q){\n\treturn fabs((p1-q).det(p2-q))==0 && (p1-q).dot(p2-q)<=0;\n}\nvektor intersection(vektor p1,vektor p2,vektor q1,vektor q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nint n;\nvektor vek[5];\n\nbool check(){\n\tvektor v[5];\n\tfor(int i=1;i<=4;i++){\n\t\tv[i]=vek[i]-vek[0];\n\t}\n\tdouble s=(v[3].x*v[2].y-v[3].y*v[2].x)/(v[1].x*v[2].y-v[1].y*v[2].x);\n\tdouble t=(v[3].x*v[1].y-v[3].y*v[1].x)/(v[1].y*v[2].x-v[1].x*v[2].y);\n\tint data3,data4;\n\tif(s>0 && t>0 && s+t<1)data3=1;\n\telse data3=-1;\n\ts=(v[4].x*v[2].y-v[4].y*v[2].x)/(v[1].x*v[2].y-v[1].y*v[2].x);\n\tt=(v[4].x*v[1].y-v[4].y*v[1].x)/(v[1].y*v[2].x-v[1].x*v[2].y);\n\tif(s>0 && t>0 && s+t<1)data4=1;\n\telse data4=-1;\n\treturn data3*data4<0;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tscanf(\"%lf %lf\",&vek[j].x,&vek[j].y);\n\t\t}\n\t\tbool flag=check();\n\t\tprintf(\"%s\\n\",flag?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ninline double cross(const P &a, const P &b) {\n    return a.real()*b.imag() - a.imag()*b.real();\n}\n\ninline int sgn(double a) {\n    return a<0 ? -1 : 1;\n}\n\nvoid solve() {\n    double x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n    cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> xk >> yk >> xs >> ys;\n    P a(x1, y1), b(x2, y2), c(x3, y3);\n    P k(xk, yk), s(xs, ys);\n    const int ca = sgn(cross(a-k, b-k)) + sgn(cross(b-k, c-k)) + sgn(cross(c-k, a-k));\n    const int cb = sgn(cross(a-s, b-s)) + sgn(cross(b-s, c-s)) + sgn(cross(c-s, a-s));\n    if((abs(ca) == 3 && abs(cb) != 3) || (abs(ca) != 3 && abs(cb) == 3)) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N;\n    while(N--) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\nstruct line: public vector< complex<double> >{\n  line(){resize(2);};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n   \nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nP reflection( L l, P p) {\n  return p + 2.0 * ( projection( l, p) - p);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n \n    cout << cross(curr(p,i),next(p,i)) << endl;\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    G triangle(3); L tline[3];\n    for(int i = 0 ; i < 3 ; i++ ){\n      cin >> triangle[i].real() >> triangle[i].imag();\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      tline[i] = L( curr( triangle, i), next( triangle, i));\n    }\n\n    L l;\n    cin >> l[0].real() >> l[0].imag();\n    cin >> l[1].real() >> l[1].imag();\n\n    bool flag = false;\n    for(int i = 0 ; i < 3 ; i++ ){\n      flag ^= intersect( l, tline[i]);\n    }\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌÏªÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (cross(a,b)*cross(b,c)*cross(c,a)>=0);\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tcin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n\t\tP p1(xp1,yp1);\n\t\tP p2(xp2,yp2);\n\t\tP p3(xp3,yp3);\n\t\tP k(xk,yk);\n\t\tP s(xs,ys);\n\t\t// ¼ûÆàOp`ÌàÉ_ª éê\n\t\tif(isInTriangle(p1,p2,p3,k)&&isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t// ¼ûÆàOp`ÌOÉ_ª éê\n\t\telse if(!isInTriangle(p1,p2,p3,k)&&!isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"OK\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/03/03 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint trian2(int x1, int y1, int x2, int y2)\n{\n\tint s2 = x1*y2-x2*y1;\n\n\tif(s2<0)\n\t\ts2 = -s2;\n\n\treturn s2;\n}\n\nbool insid(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y)\n{\n\tint s = trian2(x2-x1, y2-y1, x3-x1, y3-y1);\n\n\tint s1 = trian2(x1-x, y1-y, x2-x, y2-y);\n\tint s2 = trian2(x2-x, y2-y, x3-x, y3-y);\n\tint s3 = trian2(x3-x, y3-y, x1-x, y1-y);\n\n\tif(s==s1+s2+s3)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int i=0; i<n; i++){\n\t\tint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\t\tcin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n\n\t\tbool ink = insid(xp1, yp1, xp2, yp2, xp3, yp3, xk, yk);\n\t\tbool ins = insid(xp1, yp1, xp2, yp2, xp3, yp3, xs, ys);\n\n\t\tif(ink!=ins)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n/*\n点と多角形の内外判定\n\nps 多角形の辺\na  点\nn  多角形の辺の数\n\n点が多角形に含まれれば1,\nそうでなければ0を返す。\n*/\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=10000;\n  q.y=10000;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tsegment temp;\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  vector<segment>seg;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    seg=construct_edge(p,3);\n\n    if(point_contain(seg,k,3)!=point_contain(seg,s,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint point_contain(segment* ps, point p, int n){\n  int cnt=0;\n  point q;\n  q.x=100;\n  q.y=100;\n  for(int i=0;i<n;i++)\n\tcnt+=is_intersected_ls(ps[i].a,ps[i].b,p,q);\n  \n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n  segment seg[3];\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0,l=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j){\n\t  seg[i].a=p[i];\n\t  seg[i].b=p[j];\n\t  l++;\n\t}\n     \n\n    if(point_contain(seg,k,l)!=point_contain(seg,s,l))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n\n#define EPS 1e-3\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(P v1,P v2){\n\treturn v1.real()*v2.imag()-v1.imag()*v2.real();\n}\n\nbool che(P v1,P v2,P v3,P v){\n\tif(cross(v2-v1,v-v1)<-EPS&&cross(v3-v2,v-v2)<-EPS&&cross(v1-v3,v-v3)<-EPS)return true;\n\telse if(cross(v2-v1,v-v1)>EPS&&cross(v3-v2,v-v2)>EPS&&cross(v1-v3,v-v3)>EPS)return true;\n\treturn false;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tP v1,v2,v3;\n\t\tP k,s;\n\t\tcin>>v1.real()>>v1.imag()>>v2.real()>>v2.imag()>>v3.real()>>v3.imag()>>k.real()>>k.imag()>>s.real()>>s.imag();\n\t\t\n\t\tif(che(v1,v2,v3,k)^che(v1,v2,v3,s)==1)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nbool isIn(P p, P a, P b, P c) {\n  if(cross(b-a, p-a) < 0) return false;\n  if(cross(c-b, p-b) < 0) return false;\n  if(cross(a-c, p-c) < 0) return false;\n  return true;\n}\n\nint main() {\n  int Tc;\n  cin >> Tc;\n  while(Tc--) {\n    P a, b, c, d, e;\n    cin >> a.real() >> a.imag() >> b.real() >> b.imag()\n        >> c.real() >> c.imag() >> d.real() >> d.imag()\n        >> e.real() >> e.imag();\n    if(cross(b-a, c-a) < 0) swap(b,c);\n    bool A = isIn(d,a,b,c);\n    bool B = isIn(e,a,b,c);\n    if(A ^ B) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys;\n\nbool side(int a, int b, int c, int d, int x, int y) {\n  if (a == c)\n    return x-a > 0;\n  double p = (d - b) / (double)(c - a), q = b - p * a;\n  return y > p * x + q;\n}\n\nbool inside_triangle(int x, int y) {\n  return\n    side(xp1, yp1, xp2, yp2, x, y) == side(xp1, yp1, xp2, yp2, xp3, yp3)\n    && side(xp1, yp1, xp3, yp3, x, y) == side(xp1, yp1, xp3, yp3, xp2, yp2)\n    && side(xp3, yp3, xp2, yp2, x, y) == side(xp3, yp3, xp2, yp2, xp1, yp1);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> xp1 >> yp1 >> xp2 >> yp2 >> xp3 >> yp3 >> xk >> yk >> xs >> ys;\n    if (inside_triangle(xk, yk) ^ inside_triangle(xs, ys))\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\n/* 幾何の基本 */\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;//複素数\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);//conj::共役複素数\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\n/*int main(){\nPoint a(1,1),b(2,2);\nLine l(a,b);\n}*/\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\n//l::直線　s::線分\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定 *slide誤植\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\t//norm::絶対値の2乗\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    for(int i=0;i<n;i++){\n        ld xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n        //Tringle:(xp1,yp1)-(xp2,yp2)-(xp3,yp3) Altair:(xk,yk) Vega:(xs,ys)\n        cin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n        Point alt=Point(xk,yk),veg=Point(xs,ys);\n        vector<Point> tri;\n        tri.push_back(Point(xp1,yp1));tri.push_back(Point(xp2,yp2));tri.push_back(Point(xp3,yp3));\n        Polygon sankaku=Polygon(tri);\n        //cout<<is_in_polygon(sankaku,alt)<<\" \"<<is_in_polygon(sankaku,veg)<<endl;\n        if(is_in_polygon(sankaku,alt)!=is_in_polygon(sankaku,veg)) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <vector>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n\nusing namespace std;\n\nint cross_product( int x1, int y1, int x2, int y2 )\n{\n\treturn ((x1 * y2) - (x2 * y1));\n}\n\nint main( void )\n{\n\tint n;\n\t\n\twhile (cin >> n)\n\t{\n\t\tfor (int i=0; i < n; ++i)\n\t\t{\n\t\t\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3\n\t\t\t\t>> xk >> yk >> xs >> ys;\n\t\t\t\n\t\t\tint v1, v2, v3, v4, v5, v6;\n\t\t\n\t\t\tv1 = cross_product((x2-x1), (y2-y1), (xk-x1), (yk-y1));\n\t\t\tv2 = cross_product((x3-x2), (y3-y2), (xk-x2), (yk-y2));\n\t\t\tv3 = cross_product((x1-x3), (y1-y3), (xk-x3), (yk-y3));\n\t\t\n\t\t\tv4 = cross_product((x2-x1), (y2-y1), (xs-x1), (ys-y1));\n\t\t\tv5 = cross_product((x3-x2), (y3-y2), (xs-x2), (ys-y2));\n\t\t\tv6 = cross_product((x1-x3), (y1-y3), (xs-x3), (ys-y3));\n\t\t\tif (((v1 > 0) && (v2 > 0) && (v3 > 0) &&\n\t\t\t\t((v4 < 0) || (v5 < 0) || (v6 < 0))) ||\n\t\t\t\t((v4 > 0) && (v5 > 0) && (v6 > 0) &&\n\t\t\t\t((v1 < 0) || (v2 < 0) || (v3 < 0))) ||\n\t\t\t\t((v1 < 0) && (v2 < 0) && (v3 < 0) &&\n\t\t\t\t((v4 > 0) || (v5 > 0) || (v6 > 0))) ||\n\t\t\t\t((v4 < 0) && (v5 < 0) && (v6 < 0) &&\n\t\t\t\t((v1 > 0) || (v2 > 0) || (v3 > 0))) \n\t\t\t\t)\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n#include <complex>\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\n// 入力ストリームから実数二つをとって Point へ\nistream& operator >> ( istream &s, Point &a )\n{\n\tdouble r, i;\n\ts >> r >> i;\n\ta = Point( r, i );\n\treturn s;\n}\n\n// 外積（クロス積）\ndouble cross( const Point &a, const Point &b )\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\n// CCW 関数　a -> b -> c と進むとき、反時計回りなら 1, 直進なら 0, 時計回りなら -1\n// include : cross\nint ccw( const Point &a, const Point &b, const Point &c )\n{\n\tif ( cross( ( b - a ), ( c - a ) ) < -EPS )\n\t{\n\t\treturn -1;\n\t}\n\telse if ( EPS < cross( ( b - a ), ( c - a ) ) )\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\n\n// 点 p が多角形 qs の内部にあるか ( Winding Number Algorithm) :TODO\n// include : ccw\nbool point_in_polygon( const Point &p, const vector<Point> &qs )\n{\n\tconst int N = qs.size();\n\t\n\tint wn = 0;\n\tfor ( int i = 0; i < N; ++i )\n\t{\n\t\tconst Point &s = qs[i], &t = qs[ ( i + 1 ) % N ];\n\t\tif ( s.imag() - EPS <= t.imag() && s.imag() - EPS < p.imag() && p.imag() + EPS < t.imag() ) // 上向きの辺\n\t\t{\n\t\t\twn += ccw( s, p, t ) == -1;\n\t\t}\n\t\telse if ( t.imag() - EPS <= s.imag() && t.imag() - EPS < p.imag() && p.imag() + EPS < s.imag() )\n\t\t{\n\t\t\twn -= ccw( t, p, s ) == -1;\n\t\t}\n\t}\n\treturn wn;\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n;\n\tcin >> n;\n\tREP( i, 0, n )\n\t{\n\t\tvector<Point> tri( 3 );\n\t\tREP( j, 0, 3 )\n\t\t{\n\t\t\tcin >> tri[i];\n\t\t}\n\t\tPoint s, t;\n\t\tcin >> s >> t;\n\n\t\tcout << ( point_in_polygon( s, tri ) ^ point_in_polygon( t, tri ) ? \"OK\" : \"NG\" ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    vector<int> tmp;\n    for(int i=0;i<(int)v.size();i++){\n      if(max < v[i].real())max = v[i].real();\n      if(a.imag() == v[i].imag()){\n\ttmp.push_back(1);\n\tv[i].imag() += 1e-6;\n      }else tmp.push_back(0);\n    }\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    for(int i=0;i<(int)v.size();i++){\n      if(tmp[i])v[i].imag() -= 1e-6;\n    }\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <stack>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define rep3(var, min, max) for (ll (var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll (var) = (max) - 1; (var) + 1 > (min); --(var))\n#define Mp(a,b) make_pair((a),(b))\n#define F first\n#define S second\n#define Icin(s) ll (s);cin>>(s);\n#define Scin(s) ll (s);cin>>(s);\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst double EPS=1e-10;\ndouble add(double l, double r){\n    if(abs(l+r)<EPS*(abs(l)+abs(r))) return 0;\n    return l+r;\n}\n//l-r は add(l,-r)\n//l==r は add(l,-r)==0\nstruct Pt{\n    double x, y;\n    Pt(double xx=0, double yy=0){x=xx; y=yy;}\n    Pt& operator=(const Pt &rhs){\n        x=rhs.x; y=rhs.y; return *this;\n    }\n    Pt& operator+=(const Pt &rhs){\n        x = add(x,rhs.x); y = add(y,rhs.y); return *this;\n    }\n    Pt& operator-=(const Pt &rhs){\n        x = add(x,-rhs.x); y = add(y,-rhs.y); return *this;\n    }\n    Pt& operator*=(const double &rhs){\n        x *= rhs; y *= rhs; return *this;\n    }\n    Pt& operator/=(const double &rhs){\n        x /= rhs; y /= rhs; return *this;\n    }\n};\nPt operator+(const Pt &a){return a;}\nPt operator-(const Pt &a){return Pt(-a.x,-a.y);}\nPt operator+(const Pt &lhs, const Pt &rhs){\n    Pt ans=lhs; ans += rhs; return ans;\n}\nPt operator-(const Pt &lhs, const Pt &rhs){\n    Pt ans=lhs; ans -= rhs; return ans;\n}\nPt operator*(const Pt &lhs, const double &rhs){\n    Pt ans=lhs; ans *= rhs; return ans;\n}\nPt operator*(const double &lhs, const Pt &rhs){\n    Pt ans=rhs; ans *= lhs; return ans;\n}\nPt operator/(const Pt &lhs, const double &rhs){\n    Pt ans=lhs; ans /= rhs; return ans;\n}\nbool operator==(const Pt &lhs, const Pt &rhs){\n    return add(lhs.x,-rhs.x)==0 && add(lhs.y,-rhs.y)==0;\n}\nbool operator!=(const Pt &lhs, const Pt &rhs){return !(lhs==rhs);}\nbool operator<(const Pt &lhs, const Pt &rhs){\n    return add(lhs.x,-rhs.x)!=0 ? lhs.x<rhs.x : add(lhs.y,-rhs.y)<0;\n}\nbool operator>(const Pt &lhs, const Pt &rhs){return rhs<lhs;}\nbool operator<=(const Pt &lhs, const Pt &rhs){return !(lhs>rhs);}\nbool operator>=(const Pt &lhs, const Pt &rhs){return !(lhs<rhs);}\nistream& operator>>(istream &is, Pt &rhs){\n    double x, y;\n    is >> x >> y;\n    rhs=Pt(x,y);\n    return is;\n}\nostream& operator<<(ostream &os, const Pt &rhs){\n    os << rhs.x << \" \" << rhs.y;\n    return os;\n}\ndouble norm(const Pt &a){return add(a.x*a.x,a.y*a.y);}\ndouble abs(const Pt &a){return sqrt(norm(a));}\ndouble dot(Pt a, Pt b){return add(a.x*b.x,a.y*b.y);}\ndouble cross(Pt a, Pt b){return add(a.x*b.y,-a.y*b.x);}\nint ccw(Pt a, Pt b, Pt c) {\n    b -= a; c -= a;\n    if(cross(b, c)>0) return +2;  // counter clockwise\n    if(cross(b, c)<0) return -2;  // clockwise\n    if(dot(b, c)<0) return +1;        // c--a--b on line\n    if(norm(c)<norm(b)) return -1;    // b--c--a on line\n    return 0;                         // a--b--c on line\n}\nbool judge_cross(ld ax,ld ay,ld bx,ld by,ld cx,ld cy,ld dx,ld dy){\n    ld ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    ld tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    ld tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    ld td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n  return tc * td < 0 && ta * tb < 0;\n}\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n){\n        vector<Pt> vec(3);\n        rep(j,3)cin>>vec[j];\n        ld xk,yk,xs,ys;\n        cin>>xk>>yk>>xs>>ys;\n        int c=0;\n        if(judge_cross(vec[0].x,vec[0].y,vec[1].x,vec[1].y,xk,yk,xs,ys))c++;\n        if(judge_cross(vec[1].x,vec[1].y,vec[2].x,vec[2].y,xk,yk,xs,ys))c++;\n        if(judge_cross(vec[2].x,vec[2].y,vec[0].x,vec[0].y,xk,yk,xs,ys))c++;\n       //cout<<c<<endl;\n        if(c==0||c==2){\n            cout<<\"NG\"<<endl;\n        }else{\n            cout<<\"OK\"<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1,P a2,P b1,P b2){\n\treturn ((cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1) < EPS) &&\n\t\t\t\t\t(cross(b2-b1,a1-b1) * cross(b2-b1,a2-b1) < EPS));\n}\n\nint main(void){\n\tint n;\n\tcin>>n;\n\n\twhile(n--){\n\t\tP p[3],k,s;\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>p[i].real()>>p[i].imag();\n\t\t}\n\t\tcin>>k.real()>>k.imag();\n\t\tcin>>s.real()>>s.imag();\n\n\t\tint count = 0;\n\t\tcount += is_intersected_ls(k,s,p[0],p[1]);\n\t\tcount += is_intersected_ls(k,s,p[1],p[2]);\n\t\tcount += is_intersected_ls(k,s,p[2],p[0]);\n\n\t\tif(count == 1){\n\t\t\tcout<<\"OK\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\nif(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\nreturn a+b;\n}\n\n\n\nstruct point{\n\ndouble x, y;\n\npoint(){}\n\npoint(double x,double y) : x(x) , y(y){}\n\npoint operator + (point p){\nreturn point(add(x,p.x), add(y,p.y));\n}\n\npoint operator - (point p){\nreturn point(add(x,-p.x), add(y,-p.y));\n}\n\npoint operator * (double d){\nreturn point(x*d,y*d);\n}\n\n};\n\n\n\ndouble cross(point a, point b) {\nreturn (a.x * b.y - a.y * b.x);\n}\n\n\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\nreturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n\n}\n\n\n\nint main(void){\n\nint n;\n\npoint p[3],k,s;\n\ncin >> n;\n\nwhile(n--){\nfor(int i=0;i<3;i++)\ncin >> p[i].x >> p[i].y;\n\ncin >> k.x >> k.y >> s.x >> s.y;\n\nint cnt=0;\n\nfor(int i=0;i<3;i++)\nfor(int j=i+1;j<3;j++)\ncnt+=is_intersected_ls(p[i],p[j],k,s);\n\nif(cnt%2)cout << \"OK\" << endl;\nelse cout << \"NG\" << endl;\n}\n\nreturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace geometry\n{\t\n\ttypedef double D;\n\ttypedef complex<D> P;\n\ttypedef pair<P, P> S;\n\ttypedef S L;\n\ttypedef pair<P, D> C;\n\t\n\t#define EPS \t\t(1e-10)\n\t#define EQ(a, b) \t(abs((a) - (b)) < EPS)\n\t#define EQV(a, b) \t(EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\t\n\tinline D INPUT() { D d; scanf(\"%lf\", &d); return d; }\n\t\n\tstatic const int COUNTER_CLOCKWISE \t=  1;\n\tstatic const int CLOCKWISE\t\t\t= -1;\n\tstatic const int ONLINE_BACK\t\t=  2;\n\tstatic const int ONLINE_FRONT\t\t= -2;\n\tstatic const int ON_SEGMENT\t\t\t=  0;\n\t\n\tstatic const int IN\t\t= 2;\n\tstatic const int ON\t\t= 1;\n\tstatic const int OUT\t= 0;\n\t\n\tbool cmp(const P& a, const P& b){\n\t\tif (a.real() != b.real()) return a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n\t\n\tvoid debug(P p){\n\t\tprintf(\"x: %f, y: %f\\n\", p.real(), p.imag()); \n\t}\n\tvoid debug(C c){\n\t\tprintf(\"x: %f, y: %f, r: %f\\n\", c.first.real(), c.first.imag(), c.second);\n\t}\n\tvoid debug(S s){\n\t\tprintf(\"{\\n\");\n\t\tprintf(\"    \");\n\t\tdebug(s.first);\n\t\tprintf(\"    \");\n\t\tdebug(s.second);\n\t\tprintf(\"}\\n\");\n\t}\n\tvoid debug(vector<P> poly){\n\t\tprintf(\"{\\n\");\n\t\tfor (int i = 0; i < poly.size(); i++){\n\t\t\tprintf(\"    \");\n\t\t\tdebug(poly[i]);\n\t\t}\n\t\tprintf(\"}\\n\");\n\t}\n\t\n\tD norm(P a) { return a.real() * a.real() + a.imag() * a.imag(); }\n\t\n\tD dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\tD cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\t\n\tbool isOrthogonal(P a1, P a2, P b1, P b2) { return EQ(dot(a1 - a2, b1 - b2), 0.0); }\n\tbool isOrthogonal(L a, L b) { return isOrthogonal(a.first, a.second, b.first, b.second); }\n\tbool isParallel(P a1, P a2, P b1, P b2) { return EQ(cross(a1 - a2, b1 - b2), 0.0); }\n\tbool isParallel(L a, L b) { return isParallel(a.first, a.second, b.first, b.second); }\n\t\n\tbool isPointOnLine(P a, P b, P c) { return EQ(cross(b - a, c - a), 0.0); }\n\tbool isPointOnLine(L a, P b) { return isPointOnLine(a.first, a.second, b); }\n\tbool isPointOnSegment(P a, P b, P c) {\n\t\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t       (dot(b - a, c - a) > -EPS) &&\n\t\t\t   (dot(a - b, c - b) > -EPS);\n\t}\n\tbool isPointOnSegment(S a, P b) { return isPointOnLine(a.first, a.second, b); }\n\t\n\tint ccw(P p0, P p1, P p2){\n\t\tP a = p1 - p0;\n\t\tP b = p2 - p0;\n\t\tif (cross(a, b) > EPS) \treturn COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS)\treturn ONLINE_BACK;\n\t\tif (norm(a) < norm(b))\treturn ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\tbool intersect(P p1, P p2, P p3, P p4){\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t       ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\tbool intersect(S s1, S s2){\n\t\treturn intersect(s1.first, s1.second, s2.first, s2.second);\n\t}\n\t\n\tD distanceLP(P a, P b, P c) { return abs(cross(b - a, c - a)) / abs(b - a); }\n\tD distanceLP(L a, P b) { return distanceLP(a.first, a.second, b); }\n\tD distanceSP(P a, P b, P c) {\n\t\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\t\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\tD distanceSP(S a, P b) { return distanceSP(a.first, a.second, b); }\n\tD distanceCS(C c, S s){\n\t\treturn distanceSP(s, c.first) - c.second;\n\t}\n\t\n\tbool intersectCL(C c, L l){\n\t\treturn c.second - distanceLP(l, c.first) > -EPS;\n\t}\n\tbool intersectCS(C c, S s){\n\t\tif (EQ(c.second - abs(c.first - s.first), 0.0) ||\n\t\t\tEQ(c.second - abs(c.first - s.second), 0.0)) return true;\n\t\tif (c.second - distanceSP(s, c.first) > -EPS){\n\t\t\treturn (c.second - abs(c.first - s.first) < EPS ||\n\t\t\t\t    c.second - abs(c.first - s.second) < EPS);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tP project(S s, P p){\n\t\tP base = s.second - s.first;\n\t\tD r = dot(p - s.first, base) / norm(base);\n\t\treturn s.first + base * r;\n\t}\n\tP reflect(S s, P p){\n\t\treturn p + (project(s, p) - p) * (D)2.0;\n\t}\n\t\n\tP crossPoint(S s1, S s2){\n\t\tP base = s2.second - s2.first;\n\t\tD d1 = abs(cross(base, s1.first - s2.first));\n\t\tD d2 = abs(cross(base, s1.second - s2.first));\n\t\tD t = d1 / (d1 + d2);\n\t\treturn s1.first + (s1.second - s1.first) * t;\n\t}\n\t\n\tD area(vector<P> poly){\n\t\tif (poly.size() < 3) return 0.0;\n\t\tD res = 0.0;\n\t\tfor (int i = 1; i < poly.size() - 1; i++){\n\t\t\tP v1 = poly[i] - poly[0];\n\t\t\tP v2 = poly[i + 1] - poly[0];\n\t\t\tres += abs(cross(v1, v2)) / 2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpair<P, P> crossPoints(C c, L l){\n\t\tP pr = project(l, c.first);\n\t\tP e = (l.second - l.first) / abs(l.second- l.first);\n\t\tD base = sqrt(c.second * c.second - norm(pr - c.first));\n\t\treturn make_pair(pr + e * base, pr - e * base);\n\t}\n\t\n\tbool intersect(C c1, C c2){\n\t\treturn abs(c1.first - c2.first) - c1.second - c2.second < EPS;\n\t}\n\t\n\tpair<P, P> crossPoints(C c1, C c2){\n\t\tD d = abs(c1.first - c2.first);\n\t\tD a = acos((c1.second * c1.second + d * d - c2.second * c2.second) / (2 * c2.second * d));\n\t\tD t = arg(c2.first - c1.first);\n\t\treturn make_pair(c1.first + polar(c1.second, t + a), c1.first + polar(c1.second, t - a));\n\t}\n\t\n\tint contains(vector<P> g, P p){\n\t\tint n = g.size();\n\t\tbool x = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) x = !x;\n\t\t}\n\t\treturn (x ? IN : OUT);\n\t}\n\t\n\tvector<P> convexHull(vector<P> s){\n\t\tif (s.size() < 3) return s;\n\t\tvector<P> u, l;\n\t\tsort(s.begin(), s.end(), cmp);\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE/* && ccw(u[n - 2], u[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE/* && ccw(l[n - 2], l[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\treturn l;\n\t}\n}\n\nusing namespace geometry;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tvector<P> poly;\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tpoly.push_back(P(INPUT(), INPUT()));\n\t\t}\n\t\tvector<P> p;\n\t\tfor (int j = 0; j < 2; j++){\n\t\t\tp.push_back(P(INPUT(), INPUT()));\n\t\t}\n\t\tif (contains(poly, p[0]) + contains(poly, p[1]) == 2) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\n#define SAME_SIGN( a , b ) ( a * b > 0 ? true : false )\n\nnamespace geometry{\n\n#define EPS 1E-10\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t\ttriangle(){}\n\t\ttriangle( point a , point b , point c ):a(a),b(b),c(c){}\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\tpoint p(p1);\n\t\tp += p2;\n\t\treturn p;\n\t}\n\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\tpoint p(p1);\n\t\tp -= p2;\n\t\treturn p;\n\t}\n\tpoint operator * ( const point& p1 , double factor ){\n\t\tpoint p(p1);\n\t\tp *= factor;\n\t\treturn p;\n\t}\n\tpoint operator * ( double factor , const point& p1 ){\n\t\tpoint p(p1);\n\t\tp *= factor;\n\t\treturn p;\n\t}\n\tpoint operator / ( const point& p1 , double factor ){\n\t\tpoint p(p1);\n\t\tp /= factor;\n\t\treturn p;\n\t}\n\tstd::istream& operator >> ( std::istream& s , point& p ){\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 ){\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o ){\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - ob.x * oa.y;\n\t}\n}\n\nusing namespace geometry;\nusing namespace std;\n\ntypedef triangle wall;\nclass field;\n\nclass player{\npublic:\n\texplicit player( const field& field );\n\tbool is_inside( const wall& wall ) const;\n\tbool can_see( const player& target ) const;\n\tvoid move( const point& new_location );\n\tconst point& get_location() const;\nprivate:\n\tconst field& m_field;\n\tpoint m_loc;\n};\n\nclass field{\npublic:\n\tvoid place( const wall& w );\n\twall get_wall() const;\nprivate:\n\twall m_wall;\n};\n\nplayer::player( const field& field ):m_field(field){}\n\nbool player::is_inside( const wall& wall ) const{\n\tif(\n\tSAME_SIGN( get_cross_product( wall.a , wall.b , m_loc ) , get_cross_product( wall.b , wall.c , m_loc ) ) &&\n\tSAME_SIGN( get_cross_product( wall.b , wall.c , m_loc ) , get_cross_product( wall.c , wall.a , m_loc ) )\n\t){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool player::can_see( const player& target ) const{\n\tif( this->is_inside( m_field.get_wall() ) && target.is_inside( m_field.get_wall() ) ){\n\t\treturn true;\n\t}\n\telse if( this->is_inside( m_field.get_wall() ) != target.is_inside( m_field.get_wall() ) ){\n\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\nvoid player::move( const point& new_location ){\n\tm_loc = new_location;\n}\n\nconst point& player::get_location() const{\n\treturn m_loc;\n}\n\nvoid field::place( const wall& wall ){\n\tm_wall = wall;\n}\n\nwall field::get_wall() const{\n\treturn m_wall;\n}\n\nint main(void)\n{\n\tint n;\n\n\tcin >> n;\n\n\tfor( int i = 0 ; i < n ; i++ ){\n\t\tfield f;\n\t\tplayer ori(f);\n\t\tplayer hiko(f);\n\n\t\tpoint p1, p2, p3, pk, ps;\n\n\t\tcin >> p1 >> p2 >> p3 >> pk >> ps;\n\n\t\thiko.move(pk);\n\t\tori.move(ps);\n\t\twall w( p1 , p2 , p3 );\n\t\tf.place(w);\n\n\t\tcout << (hiko.can_see(ori) ? \"NG\":\"OK\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-10\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[j+1]) > EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS && fabs(ansx - x[j]) > EPS && fabs(ansx - x[0]) > EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator==(const Point &p)const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n\n\t//Vector????????¢\n\tPoint rotate(double rad) { return Point(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point(1, 1)) :p1(p1), p2(p2) {}\n\tVector vec() { return p2 - p1; }\n};\nusing Line = Segment;\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance_LP(s, p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance_SP(s1, s2.p1), get_distance_SP(s1, s2.p2)),\n\t\tmin(get_distance_SP(s2, s1.p1), get_distance_SP(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance_LP(l, c.c) <= c.r; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point getCrossPointLL(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\nsigned main() {\n\tint n; cin >> n;\n\trep(i, 0, n) {\n\t\tPoint p1, p2, p3, k, s; cin >> p1 >> p2 >> p3 >> k >> s;\n\t\tPolygon T = { p1,p2,p3 };\n\t\tif (contains(T, k) != contains(T, s))cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,int> P;\n\nstatic const double eps = 10e-6;\n\nclass intersect_triangle{\nprivate:\n\tdouble dst[3];\n\tdouble orig[3], dir[3];\n\tdouble vert0[3],vert1[3],vert2[3];\n\n\tdouble dot(double v1[3],double v2[3]){\n\t\treturn v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2];\n\t}\n\tvoid cross(double dest[3],double v1[3],double v2[3]){\n\t\tdest[0] = v1[1]*v2[2]-v1[2]*v2[1];\n\t\tdest[1] = v1[2]*v2[0]-v1[0]*v2[2];\n\t\tdest[2] = v1[0]*v2[1]-v1[1]*v2[0];\n\t}\n\n\tvoid sub(double dest[3],double v1[3], double v2[3]){\n\t\tdest[0] = v1[0]-v2[0];\n\t\tdest[1] = v1[1]-v2[1];\n\t\tdest[2] = v1[2]-v2[2];\n\t}\npublic:\n\tintersect_triangle(double xp1,double yp1,double xp2,double yp2,double xp3,double yp3,\n\t\tdouble xk,double yk){\n\t\tvert0[0] = xp1;\n\t\tvert0[1] = yp1;\n\t\tvert0[2] = 0;\n\n\t\tvert1[0] = xp2;\n\t\tvert1[1] = yp2;\n\t\tvert1[2] = 0;\n\n\t\tvert2[0] = xp3;\n\t\tvert2[1] = yp3;\n\t\tvert2[2] = 0;\n\n\t\torig[0] = xk;\n\t\torig[1] = yk;\n\t\torig[2] = -1;\n\n\t\tdst[0] = xk;\n\t\tdst[1] = yk;\n\t\tdst[2] = 1;\n\n\t\tdouble len = sqrt(pow(dst[0]-orig[0],2.0)+pow(dst[1]-orig[1],2.0)+pow(dst[2]-orig[2],2.0));\n\t\tdir[0] = (dst[0]-orig[0])/len;\n\t\tdir[1] = (dst[1]-orig[1])/len;\n\t\tdir[2] = (dst[2]-orig[2])/len;\n\t}\n\n\tbool is_intersect(){\n\t\tdouble edge1[3],edge2[3],tvec[3],pvec[3],qvec[3];\n\t\tdouble det,inv_det,t=0,v=0,u=0;\n\n\t\tsub(edge1,vert1,vert0);\n\t\tsub(edge2,vert2,vert0);\n\n\t\tcross(pvec,dir,edge2);\n\n\t\tdet=dot(edge1,pvec);\n\n\t\tif(det > -eps && det < eps) return false;\n\n\t\tinv_det = 1.0/det;\n\n\t\tsub(tvec,orig,vert0);\n\n\t\tu=dot(tvec,pvec)*inv_det;\n\t\tif(u < 0.0 || u > 1.0) return false;\n\n\t\tcross(qvec,tvec,edge1);\n\n\t\tv=dot(dir,qvec) * inv_det;\n\t\tif(v < 0.0 || u+v > 1.0) return false;\n\n\t\tt = dot(edge2,qvec) * inv_det;\n\n\t\treturn true;\n\n\t}\n};\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0;i<n;i++){\n\t\tdouble xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n\t\t\t&xp1,&yp1,&xp2,&yp2,&xp3,&yp3,&xk,&yk,&xs,&ys);\n\t\tintersect_triangle inter_t1(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk);\n\t\tintersect_triangle inter_t2(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys);\n\t\tprintf(\"%s\\n\",(inter_t1.is_intersect() && inter_t2.is_intersect()) \n\t\t\t|| (!inter_t1.is_intersect() && !inter_t2.is_intersect())\n\t\t\t? \"NG\" : \"OK\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return dot(*this);\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n};\n\n//交差しているとき１を返す\nint intersect(Point a,Point b,Point c,Point d)\n{\n\tif(c.between(a,b) || d.between(a,b) || a.between(c,d) || b.between(c,d))\n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn (c.area(a,b) * d.area(a,b) < 0 && a.area(c,d) * b.area(c,d) < 0);\n\t}\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Point> p;\n\tPoint k,s;\n\n\trep(i,n)\n\t{\t\n\t\tp.clear();\n\t\trep(j,3)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tPoint temp(x,y);\n\t\t\tp.push_back(temp);\n\t\t}\n\n\t\tint kx,ky,sx,sy;\n\t\tcin >> kx >> ky >> sx >> sy;\n\n\t\tk = Point(kx,ky);\n\t\ts = Point(sx,sy);\n\t\t\n\t\tint cnt = 0;\n\t\t\n\t\tif(intersect(k,s,p[0],p[1]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\n\t\tif(intersect(k,s,p[1],p[2]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\n\t\tif(intersect(k,s,p[0],p[2]))\n\t\t{\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tif(cnt == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<complex>\ntypedef std::complex<double>P;\ndouble C(P a,P b){return a.real()*b.imag()-a.imag()*b.real();}\nint F(P p,P a,P b,P c)\n{\n\tdouble x=C(b-a,p-a),y=C(c-b,p-b),z=C(a-c,p-c);\n\treturn x>0&&y>0&&z>0||x<0&&y<0&&z<0;\n}\nint main()\n{\n\tP p[5];\n\tint n,i,x,y;\n\tfor(scanf(\"%d\",&n);n--;)\n\t{\n\t\tfor(i=0;i<5;++i)scanf(\"%d%d\",&x,&y),p[i]=P(x,y);\n\t\tputs((F(p[3],p[0],p[1],p[2])^F(p[4],p[0],p[1],p[2]))?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) )\n\ntypedef complex<double> p;\n\ndouble cross(p a, p b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tp point[5];\n\t\tREP(i, 5) {\n\t\t\tdouble a, b;\n\t\t\tscanf(\"%lf %lf\", &a, &b);\n\t\t\tpoint[i] = p(a, b);\n\t\t}\n\t\tint cnt[2] = {};\n\t\t\n\t\tREP(i, 3) {\n\t\t\tp v[2];\n\t\t\tv[0] = point[(i + 1) % 3] - point[i];\n\t\t\tv[1] = point[3] - point[i];\n\t\t\tif (cross(v[0], v[1]) < -EPS) cnt[0]++;\n\t\t\t\n\t\t\tv[1] = point[4] - point[i];\n\t\t\tif (cross(v[0], v[1]) < -EPS) cnt[1]++;\n\t\t}\n\t\tbool flag[2];\n\t\tREP(i, 2) flag[i] = cnt[i] == 0 || cnt[i] == 3;\n\t\tif (flag[0] == !flag[1]) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool line(int x1, int y1, int x2, int y2, int x, int y){\n    return (x2 - x1) * (y - y1) > (y2 - y1) * (x - x1);\n}\n\nbool triangle(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y){\n    return  line(x1, y1, x2, y2, x, y) == line(x1, y1, x2, y2, x3, y3) &&\n            line(x2, y2, x3, y3, x, y) == line(x2, y2, x3, y3, x1, y1) &&\n            line(x3, y3, x1, y1, x, y) == line(x3, y3, x1, y1, x2, y2);\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i){\n        int x1, y1, x2, y2, x3, y3, ax, ay, bx, by;\n        scanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &ax, &ay, &bx, &by);\n        if(triangle(x1, y1, x2, y2, x3, y3, ax, ay) != triangle(x1, y1, x2, y2, x3, y3, bx, by)){\n            printf(\"OK\\n\");\n        }\n        else{\n            printf(\"NG\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n//#include <fstream>\t// require freopen\n#include <complex>\n\nusing namespace std;\n\ntypedef complex <double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\n// OÏ (cross product) : a~b = |a||b|sinÆ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.altair6vega\", \"r\", stdin );\n\tint n;\n\tint i, j;\n\tvector <bool> res;\n\n\tcin >> n;\n\n\tfor (i = 0; i < n; ++i){\n\t\tdouble x1, y1, x2, y2, x3, y3;\n\t\n\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\tP a(x1, y1), b(x2, y2), c(x3, y3 );\n\n\t\tvector <P> p(2);\n\t\tfor (j = 0; j < 2; ++j ){\n\t\t\tcin >> p[j].real() >> p[j].imag();\n\t\t} // end for\n\n\t\tvector <bool> in (2, false );\n\n\t\tfor (j = 0; j < 2; ++j ){\t\n\t\t\tif (  ( cross (p[j] - a, p[j] - b ) > 0. && cross (p[j] - b, p[j] - c ) > 0. && cross (p[j] - c , p[j] - a ) > 0. )\n\t\t\t||    ( cross (p[j] - a, p[j] - b ) < 0. && cross (p[j] - b, p[j] - c ) < 0. && cross (p[j] - c , p[j] - a ) < 0. ) ) {\n\t\t\t\tin[j] = true;\n\t\t\t}else{\n\t\t\t\tin[j] = false;\n\t\t\t} // end if\n\t\t} // end for\n\t\tif (in[0] ^ in[1] ){\n\t\t\tres.push_back (true );\n\t\t}else{\n\t\t\tres.push_back (false );\n\t\t} // end if\n\t} // end for\n\n\tfor (i = 0; i < n; ++i){\n\t\tif (res[i] ){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t} // end if\n\t} // end for\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& a, const Point& b, const Point& point)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& a, const Point& b, const Point& point)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point* triangle, const Point& point)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& a, const Point& b, const Point& c, const Point& point)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(t, point);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tPoint p[5];\n\t\tfor (int i = 0; i < 5; ++i)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tp[i] = Point(a, b);\n\t\t}\n\n\t\tif (is_in_triangle(p, p[3]) != is_in_triangle(p, p[4]))\n\t\t\tputs(\"OK\");\n\t\telse\n\t\t\tputs(\"NG\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Point\n{\n  int x;\n  int y;\n};\n\n//-----------------------Line Class\nclass Line\n{\npublic:\n  Line(Point a, Point b);\n  double GetSlope();\n  double GetIntercept();\n  Point GetPointA();\n  Point GetPointB();\n  bool CrossLine(Line line2);\nprivate:\n  Point m_pointA,m_pointB;\n  bool m_x1_x2;         //x1=x2 ?\n  double m_slope;       //傾き\n  double m_intercept;   //y切片\n};\n\nLine::Line(Point a, Point b)\n{\n  m_pointA = a;\n  m_pointB = b;\n\n  if ( m_pointA.x == m_pointB.x )\n  {\n    m_x1_x2 = true;\n  }\n  else\n  {\n    m_x1_x2 = false;\n    m_slope = ( m_pointB.y - m_pointA.y) / (double)( m_pointB.x - m_pointA.x );\n    m_intercept = m_pointA.y - m_pointA.x * m_slope;\n  }\n}\n\ndouble Line::GetSlope()\n{\n  return m_slope;\n}\n\ndouble Line::GetIntercept()\n{\n  return m_intercept;\n}\n\nPoint Line::GetPointA()\n{\n  return m_pointA;\n}\n\nPoint Line::GetPointB()\n{\n  return m_pointB;\n}\n\nbool Line::CrossLine(Line line2)\n{\n  if ( m_slope == line2.GetSlope() )    //傾きが同じならば\n  {\n    return false;\n  }\n  double cross_x = ( m_intercept - line2.GetIntercept() ) / ( m_slope - line2.GetSlope() );\n  bool line1_in;\n  bool line2_in;\n  if ( m_pointA.x == m_pointB.x )   //self\n  {\n    line1_in = true;\n  }\n  else if ( (m_pointA.x < cross_x && cross_x < m_pointB.x) || \n            (m_pointB.x < cross_x && cross_x < m_pointA.x) )\n  {\n    line1_in = true;\n  }\n  else\n  {\n    line1_in = false;\n  }\n\n  if ( line2.GetPointA().x == line2.GetPointB().x )   //引数line2\n  {\n    line2_in = true;\n  }\n  else if ( (line2.GetPointA().x < cross_x && cross_x < line2.GetPointB().x) || \n            (line2.GetPointB().x < cross_x && cross_x < line2.GetPointA().x) )\n  {\n    line2_in = true;\n  }\n  else\n  {\n    line2_in = false;\n  }\n\n  return line1_in && line2_in;\n}\n\n//--------------------------Triangle Class\nclass Triangle\n{\npublic:\n  Triangle(Point point1, Point point2, Point point3);\n  bool OnePointIn( Point point1, Point point2);\nprivate:\n  Point m_point1, m_point2, m_point3;\n};\n\nTriangle::Triangle(Point point1, Point point2, Point point3)\n{\n  m_point1 = point1;\n  m_point2 = point2;\n  m_point3 = point3;\n}\n\nbool Triangle::OnePointIn( Point point1, Point point2 )\n{\n  Line love(point1, point2);\n  Line trg1(m_point1, m_point2);\n  Line trg2(m_point1, m_point3);\n  Line trg3(m_point2, m_point3);\n  int cross_num = 0;\n  if ( love.CrossLine(trg1) )\n  {\n    cross_num++;\n  }\n  if ( love.CrossLine(trg2) )\n  {\n    cross_num++;\n  }\n  if ( love.CrossLine(trg3) )\n  {\n    cross_num++;\n  }\n  if ( cross_num == 1 )\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n  }\n}\n\n//----------------------------main関数\nint main()\n{\n  int n;    //  データセットの個数\n  cin >> n;\n  for (int dataset=0; dataset<n; dataset++)\n  {\n    Point trg[3];\n    for (int i=0; i<3; i++)\n    {\n      cin >> trg[i].x >> trg[i].y;\n    }\n    Triangle triangle( trg[0], trg[1], trg[2] );\n    Point kengyu;\n    Point shukujo;\n    cin >> kengyu.x >> kengyu.y >> shukujo.x >> shukujo.y;\n    if ( triangle.OnePointIn( kengyu, shukujo ) )\n    {\n      cout << \"OK\" << endl;\n    }\n    else\n    {\n      cout << \"NG\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(lli i=0;i<(lli)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n#define F first\n#define S second\n\n#define EPS 1e-9\n\ndouble f(pii a,pii b,pii c){\n    pii p1,p2;\n    p1=pii( a.F-b.F , a.S-b.S );\n    p2=pii( a.F-c.F , a.S-c.S );\n    \n    return p1.F*p2.S-p1.S*p2.F;\n}\n\n\nint main(){\n    int n;\n    cin>>n;\n    rep(hoge,n){\n        pii p1,p2,p3,k,s;\n        cin>>p1.F>>p1.S>>p2.F>>p2.S>>p3.F>>p3.S>>k.F>>k.S>>s.F>>s.S;\n        \n        \n        double a=f(p1,p2,k);\n        double b=f(p2,p3,k);\n        double c=f(p3,p1,k);\n        \n        bool x;\n        \n        if( (a>=0&&b>=0&&c>=0) || (a<0+EPS&&b<0+EPS&&c<0+EPS) )x=true;\n        else x=false;\n\n    \n        a=f(p1,p2,s);\n        b=f(p2,p3,s);\n        c=f(p3,p1,s);\n        \n        bool y;\n        \n        if( (a>=0&&b>=0&&c>=0) || (a<0+EPS&&b<0+EPS&&c<0+EPS) )y=true;\n        else y=false;\n        if(x==y)cout<<\"NG\"<<endl;\n        else cout<<\"OK\"<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\nusing namespace std;\n#define EPS 1e-8\n#define INF 1000000\n  \nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x=_x; y=_y;\n    }\n    Point operator +(const Point p)const{\n        return Point(x+p.x,y+p.y);\n    }\n    Point operator -(const Point p)const{\n        return Point(x-p.x,y-p.y);\n    }\n    Point operator *(const double d)const{\n        return Point(x*d,y*d);\n    }\n    bool operator <(const Point &p)const{\n        if(x==p.x) return y<p.y;\n        return x<p.x;\n    }\n    bool operator ==(const Point &p)const{\n        return abs(x-p.x)<EPS && abs(y-p.y)<EPS;\n    }\n    double norm(){\n        return x*x+y*y;\n    }\n    bool input(){\n        if(cin>>x>>y) return true;\n        return false;\n    }\n};\n \nstruct Line{\n    Point a,b;\n    Line(){}\n    Line(Point _a,Point _b){\n        a=_a; b=_b;\n    }\n    bool input(){\n        if(a.input() && b.input()) return true;\n        return false;\n    }\n};\n \nstruct Circle{\n    Point c;\n    double r;\n    Circle(){}\n    Circle(Point _c,double _r){\n        c=_c; r=_r;\n    }\n};\n \ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ntypedef Line Segment;\n \ndouble dot(Point p,Point q){\n    return p.x*q.x+p.y*q.y;\n}\n \ndouble cross(Point p,Point q){\n    return p.x*q.y-q.x*p.y;\n}\n \nint ccw(Point a,Point b,Point c){ \n    Vector v1 = b-a;\n    Vector v2 = c-a;\n    if(cross(v1,v2)>EPS) return +1; \n    if(cross(v1,v2)<-EPS) return -1; \n    if(dot(v1,v2)<-EPS) return +2; \n    if(v2.norm()-v1.norm()>EPS) return -2; \n    return 0; \n}\n \nPoint project(Segment s,Point p){\n    Vector v1 = s.b-s.a;\n    Vector v2 = p-s.a;\n    double r = dot(v1,v2)/v1.norm();\n    return s.a+v1*r;\n}\n \nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n \nbool intersect_ll(Line l,Line m){\n    return ccw(l.a,l.b,m.a)*ccw(l.a,l.b,m.b)<=0 && ccw(m.a,m.b,l.a)*ccw(m.a,m.b,l.b)<=0;\n}\n \nbool crosspoint_ss(Segment s,Segment t,Point &p){\n    Vector a1,a2,b1,b2;\n    a1 = s.b-s.a; a2 = t.b-t.a;\n    b1 = t.a-s.a; b2 = s.a-t.b;\n    double s1,s2;\n    s1 = cross(a1,b1)/2; s2 = cross(a1,b2)/2;\n    if(s1+s2<EPS) return false; \n    p = Point(t.a.x+a2.x*s1/(s1+s2),t.a.y+a2.y*s1/(s1+s2));\n    return true;\n}\n \nint crosspoint_ll(Line l,Line m,Point &p){\n    if(intersect_ll(l,m)==false) return 0; \n    if(crosspoint_ss(l,m,p)==true) return 1;\n    return -1; \n}\n \nint crosspoint_cc(Circle c1,Circle c2,Point &p1,Point &p2){\n    double d,a,t;\n    d = sqrt((c2.c-c1.c).norm());\n    if(abs(c1.c.x-c2.c.x)<EPS && abs(c1.c.y-c2.c.y)<EPS && abs(c1.r-c2.r)<EPS)\n        return -1; \n    if(d<abs(c1.r-c2.r) || c1.r+c2.r<d) return 0; \n    a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    t = atan2(c2.c.y-c1.c.y,c2.c.x-c1.c.x);\n    p1 = Point(c1.c.x+c1.r*cos(t+a),c1.c.y+c1.r*sin(t+a));\n    p2 = Point(c1.c.x+c1.r*cos(t-a),c1.c.y+c1.r*sin(t-a));\n    if(abs(p1.x-p2.x)<EPS && abs(p1.y-p2.y)<EPS) return 1; \n    return 2; \n}\n \nint contain_gp(Polygon g,Point p){\n    Line l = Line(p,Point(INF,p.y));\n    int cnt = 0, n = g.size();\n    for(int i=0;i<n;i++){\n        Vector a = g[i]-p;\n        Vector b = g[(i+1)%n]-p;\n        if(ccw(g[i],g[(i+1)%n],p)==0) return 1; \n        if(a.y>b.y) swap(a,b);\n        if(a.y<=EPS && EPS<b.y && cross(a,b)>EPS) cnt++;\n    }\n    if((cnt&1)==1) return 2; \n    return 0; \n}\n \nPolygon andrewScan(Polygon s){\n    if(s.size()<=2) return s;\n    sort(s.begin(),s.end());\n    Polygon g;\n    for(int i=0;i<s.size();i++){\n        for(int n=g.size(); n>=2 && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    int upper_n = g.size();\n    for(int i=s.size()-2;i>=0;i--){\n        for(int n=g.size(); n>upper_n && ccw(g[n-2],g[n-1],s[i])!=-1; n--){\n            g.pop_back();\n        }\n        g.push_back(s[i]);\n    }\n    reverse(g.begin(),g.end());\n    g.pop_back();\n    return g;\n}\n\nint main(){\n\tPolygon g(3);\n\tPoint k, s;\n\tint N;\n\t\n\tcin >> N;\n\tfor(int ds = 0; ds < N; ds++){\n\t\tfor(int i = 0; i < 3; i++) g[i].input();\n\t\tk.input(); s.input();\n\t\tif( contain_gp(g, s) != contain_gp(g, k) ) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (cross(a,b)*cross(b,c)*cross(c,a)<0);\n}\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tint xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\n\t\tcin>>xp1>>yp1>>xp2>>yp2>>xp3>>yp3>>xk>>yk>>xs>>ys;\n\t\tP p1(xp1,yp1);\n\t\tP p2(xp2,yp2);\n\t\tP p3(xp3,yp3);\n\t\tP k(xk,yk);\n\t\tP s(xs,ys);\n\t\t// ¼ûÆàOp`ÌàÉ_ª éê\n\t\tif(isInTriangle(p1,p2,p3,k)&&isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t// ¼ûÆàOp`ÌOÉ_ª éê\n\t\telse if(!isInTriangle(p1,p2,p3,k)&&!isInTriangle(p1,p2,p3,s)){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"OK\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint main(void){\n  int n;\n  point p[3],k,s;\n\n  cin >> n;\n  while(n--){\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n    \n    cin >> k.x >> k.y >> s.x >> s.y;\n    int cnt=0;\n    for(int i=0;i<3;i++)\n      for(int j=i+1;j<3;j++)\n\tif(i!=j)\n\t  cnt+=is_intersected_ls(p[i],p[j],k,s);\n    \n    if(cnt%2)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Vector2\n{\npublic:\n\tVector2() : x( 0 ), y( 0 ){}\n\tVector2( int _x, int _y ) : x( _x ), y( _y ){}\n\tVector2& operator=( const Vector2& v )\n\t{\n\t\tthis->x = v.x;\n\t\tthis->y = v.y;\n\t\treturn *this;\n\t}\n\tVector2 operator-( const Vector2& v )\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\tint clossProduct( const Vector2& v )\n\t{\n\t\treturn this->x * v.y - this->y * v.x;\n\t}\n\n\tint x, y;\n};\n\nbool solve()\n{\n\tVector2 coodi[ 5 ];\n\tfor( int i = 0; i < 5; ++i ){\n\t\tVector2 v;\n\t\tcin >> v.x >> v.y;\n\t\tcoodi[ i ] = v;\n\t}\n\tint closs[ 2 ][ 3 ];\n\tfor( int i = 0; i < 2; ++i ){\n\t\tVector2& o = coodi[ 3 + i ];\n\t\tfor( int j = 0; j < 3; ++j ){\n\t\t\tVector2 v = coodi[ ( j + 1 ) % 3 ] - coodi[ j ];\n\t\t\tVector2 w = o - coodi[ j ];\n\t\t\tcloss[ i ][ j ] = v.clossProduct( w );\n\t\t}\n\t}\n\tfor( int i = 0; i < 2; ++i ){\n\t\tint a = closs[ i ][ 0 ] * closs[ i ][ 1 ];\n\t\tint b = closs[ i ][ 1 ] * closs[ i ][ 2 ];\n\t\tint c = closs[ i ][ 2 ] * closs[ i ][ 0 ];\n\t\tcloss[ i ][ 0 ] = a;\n\t\tcloss[ i ][ 1 ] = b;\n\t\tcloss[ i ][ 2 ] = c;\n\t}\n\tif( ( ( closs[ 0 ][ 0 ] > 0 && closs[ 0 ][ 1 ] > 0 && closs[ 0 ][ 2 ] > 0 )\n\t\t&& ( closs[ 1 ][ 0 ] < 0 || closs[ 1 ][ 1 ] < 0 || closs[ 1 ][ 2 ] < 0 ) )\n\t\t|| ( ( closs[ 0 ][ 0 ] < 0 || closs[ 0 ][ 1 ] < 0 || closs[ 0 ][ 2 ] < 0 )\n\t\t&& ( closs[ 1 ][ 0 ] > 0 && closs[ 1 ][ 1 ] > 0 && closs[ 1 ][ 2 ] > 0 ) ) ){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n;\n\twhile( cin >> n ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tif( solve() ){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n#define EPS 1e-10\n\ndouble add(double a,double b)\n{\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\ntypedef struct Vec{\n\tdouble x,y;\n\tVec(){}\n\tVec( double x,double y):x(x),y(y){}\n\tVec operator +(Vec v){return Vec(add(x,v.x),add(y,v.y));}\n\tVec operator -(Vec v){return Vec(add(x,-v.x),add(y,-v.y));}\n\tVec operator *(double d){return Vec(x*d,y*d);}\n\tdouble dot(Vec v){return add(x*v.x,y*v.y);}\n\tdouble det(Vec v){return add(x*v.y,-y*v.x);}\n}V;\n\n\nbool on_seg(Vec p1,Vec p2,Vec q)\n{\n\treturn (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;\n}\n\nVec intersection(Vec p1,Vec p2,Vec q1,Vec q2)\n{\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nVec A,B;\nint N,p=1,c=0;\nVec pos[3];\n\nvoid check(Vec f,Vec e)\n{\n\tif((B-A).det(e-f)!=0)\n\t{\n\t\tVec r=intersection(A,B,f,e);\n\t\tif(on_seg(A,B,r)&&on_seg(f,e,r))\n\t\t{\n\t\t\tc++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(;N--;)\n\t{\n\t\tc=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tscanf(\"%lf%lf\",&pos[i].x,&pos[i].y);\n\t\tscanf(\"%lf%lf\",&A.x,&A.y);\n\t\tscanf(\"%lf%lf\",&B.x,&B.y);\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcheck(pos[i],pos[(i+1)%3]);\n\t\tputs(c==1?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;struct P{float x,y;int operator-=(P&a){x-=a.x;y-=a.y;}};P A,B,C,S,G;int X(P S){C.x=(B.y*S.x-B.x*S.y)/(A.x*B.y-A.y*B.x);C.y=(A.y*S.x-A.x*S.y)/(A.y*B.x-A.x*B.y);return C.x>0&&C.y>0&&C.x+C.y<1;}main(){cin>>A.x;while(cin>>A.x>>A.y>>B.x>>B.y>>C.x>>C.y>>S.x>>S.y>>G.x>>G.y){A-=C;B-=C;S-=C;G-=C;X(S)^X(G)?cout<<\"OK\\n\":cout<<\"NG\\n\";}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<complex>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst double eps = 1e-8;\nconst double inf = 1e12;\n\ntypedef complex<double> P; //Point\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct L {  //Line\n  P s,t;\nL(const P a,const P b) : s(a), t(b) {;}\n};\n\ndouble cross(const P &a, const P &b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b) {\n  return real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if( cross(b, c) > 0 ) return +1; // counter clockwise\n  if( cross(b, c) < 0 ) return -1; // clockwise\n  if( dot(b, c) < 0 ) return +2;   // c--a--b on line\n  if( norm(b) < norm(c) ) return -2; // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s.s,s.t,t.s) * ccw(s.s,s.t,t.t) <= 0 &&\n        ccw(t.s,t.t,s.s) * ccw(t.s,t.t,s.t) <= 0;\n}\n\nint main() {\n    int n,x,y;\n    cin>>n;\n    while(n--) {\n        P tri[3];\n        for(int i=0; i<3; ++i) {\n            cin>>x>>y;\n            tri[i] = P(x,y);\n        }\n        cin>>x>>y;\n        P f(x,y);\n        cin>>x>>y;\n        P m(x,y);\n        L fm(f,m);\n        vector<L> tril;\n        for(int i=0; i<3; ++i) tril.push_back(L(tri[i],tri[(i+1)%3]));\n\n        int cc = 0;\n        for(int i=0; i<3; ++i)\n            if(intersectSS(fm, tril[i])) cc++;\n\n        if(cc%2) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n  \n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint main(void){\n  int n;\n  point k,s,in;\n  vector<point>p; \n\n  cin >> n;\n  while(n--){\n    p.clear();\n    for(int i=0;i<3;i++){\n      cin >> in.x >> in.y;\n      p.push_back(in);\n    }     \n\n    cin >> k.x >> k.y >> s.x >> s.y;\n\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct Point { long double px, py; };\nPoint Minus(Point a, Point b) { Point O; O.px = a.px - b.px; O.py = a.py - b.py; return O; }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint p1, p2, p3, p4, p5;\n\t\tcin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p4.px >> p4.py >> p5.px >> p5.py;\n\t\tvector<Point>C = { p1,p2,p3 };\n\t\tbool G1 = contain(C, p4), G2 = contain(C, p5);\n\t\tif (G1 ^ G2 == true)cout << \"OK\" << endl;\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-5)\n\nstruct Seg {\n  P s, t;\n  Seg(P s, P t) : s(s), t(t) {}\n};\n\ndouble cross(P a, P b) {\n  return (a.real()*b.imag() - a.imag()*b.real());\n}\n\nbool isIntersectedSS(Seg a, Seg b) {\n  return ( cross(a.t-a.s, b.s-a.s) * cross(a.t-a.s, b.t-a.s) < EPS )\n      && ( cross(b.t-b.s, a.s-b.s) * cross(b.t-b.s, a.t-b.s) < EPS );\n}\n\nint main() {\n  int n; cin >> n;\n  for(int I=0; I<n; I++) {\n    int x, y;\n    cin >> x >> y; P pt1(x, y);\n    cin >> x >> y; P pt2(x, y);\n    cin >> x >> y; P pt3(x, y);\n    cin >> x >> y; P pk(x, y);\n    cin >> x >> y; P ps(x, y);\n    \n    int ok = 0;\n    ok += isIntersectedSS(Seg(pt1, pt2), Seg(pk, ps));\n    ok += isIntersectedSS(Seg(pt2, pt3), Seg(pk, ps));\n    ok += isIntersectedSS(Seg(pt3, pt1), Seg(pk, ps));\n    \n    if(ok%2) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\n// _ªOp`ÌÉ é©\nbool isInTriangle(P p[3], P x)\n{\n\tdouble S = cross(p[1] - p[0], p[2] - p[0]);\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], x - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\t\n\twhile(n--)\n\t{\n\t\tP p[3];\n\t\tP k, s;\n\t\t\n\t\trep(i, 3) cin >> p[i].real() >> p[i].imag();\n\t\tcin >> k.real() >> k.imag() >> s.real() >> s.imag();\n\t\n\t\tif(isInTriangle(p, k) ^ isInTriangle(p, s))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nint main(){\n\tint n;\n\tcin>>n;\n\trp(n){\n\t\tG g(3);\n\t\tPIN(&g[0],3);\n\t\tP a=pin(),b=pin();\n\t\tint ha=inconvex(g,a);\n\t\tint hb=inconvex(g,b);\n\t\tif((ha&&hb)||(ha==0&&hb==0))cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Point {\npublic:\n\tint x, y;\n};\n\nPoint PointData[5];\n\n\nint isExistTriangle(const Point& p) {\n\n\tint r1 = (PointData[1].x - PointData[0].x) * (p.y - PointData[0].y) - (p.x - PointData[0].x) * (PointData[1].y - PointData[0].y);\n\tint r2 = (PointData[2].x - PointData[1].x) * (p.y - PointData[1].y) - (p.x - PointData[1].x) * (PointData[2].y - PointData[1].y);\n\tint r3 = (PointData[0].x - PointData[2].x) * (p.y - PointData[2].y) - (p.x - PointData[2].x) * (PointData[0].y - PointData[2].y);\n\n\tif (r1 > 0 && r2 > 0 && r3 > 0) {\n\t\treturn 1;\n\t}\n\tif (r1 < 0 && r2 < 0 && r3 < 0) {\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\tint n, flag1, flag2;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tcin >> PointData[j].x >> PointData[j].y;\n\t\t}\n\t\t\n\t\tflag1 = isExistTriangle(PointData[3]);\n\t\tflag2 = isExistTriangle(PointData[4]);\n\t\t//cout << flag1 << ends << flag2 << endl;\n\t\tif (flag1*flag2 == 1) {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n//CCW??¨///////////////////////////////////\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n/////////////////////////////////////////\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n  }\n};\n/*class Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};*/\ntypedef Point vect;\nstruct seg{Point p1,p2;};\n//????????´?????????????????????\ndouble norm(Point p){return p.x*p.x+p.y*p.y;}\n//??¶??????\ndouble abs(Point p){return sqrt(norm(p));}\n//??????\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n//?????? \ndouble cross(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n//??´?????????????????¨?????\\?????????????????????\nbool C90(seg s1,seg s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//????????????????????¨?????\\??????????????????????????????????????????\nbool C0(seg s1,seg s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n//?°???± ????????????or??¢?????£?????????\nPoint project(seg s,Point p){\n  Point base = s.p2-s.p1;\n  double r=dot(p-s.p1,base) / norm(base);\n  return s.p1+base*r;\n}\n//????°????????????????????????????\nPoint reflection(seg s,Point p){\n  return  p+(project(s,p)-p)*2.0;\n}\n//2???????????¢   \ndouble getDistancePP(Point a,Point b){\n  return abs(a-b);\n}\n//??´??????????????¢(????°?)\ndouble getDistanceLP(seg l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n//?????????????????¢\ndouble getDistanceSP(seg s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n//????¨?????????????????¨??????????\nint CCW(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-EPS)return CLOCKWISE;\n  if(dot(a,b)<-EPS)return ONLINE_BACK;\n  if(norm(a)<norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n//??????????????????\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return(CCW(p1,p2,p3)*CCW(p1,p2,p4)<=0&&CCW(p3,p4,p1)*CCW(p3,p4,p2)<=0);\n}\nbool intersect(seg s1,seg s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n//2??????????§???¢?????\\??????????????????...????????????????????????\nbool squareintersect(seg s1,seg s2){\n  if(s1.p2.x<s2.p1.x||s2.p2.x<s1.p1.x)return 0;\n  if(s1.p2.y<s2.p1.y||s2.p2.y<s1.p1.y)return 0;\n  return 1;\n}\n//??????????????¢\ndouble getDistance(seg s1,seg s2){\n  if(intersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n    min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n//????????????\nPoint getCrossPoint(seg s1,seg s2){\n  Point base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n//????´???°2D//////////////////////\ntypedef complex<double> comp;\ntypedef vector<comp> cvec;\n//????´???????\ndouble dot(comp a,comp b){return real(b*conj(a));}\n//????´???????\ndouble cross(comp a,comp b){return imag(b*conj(a));}\ndouble Area(cvec &a){\n  double b=0;int n=a.size();\n  for(int i=0;i<n;i++)\n    b+=cross(a[i],a[(i+1==n?0:i+1)]);\n  return abs(b/2.0);\n}\n////how to use(exp)/////////////////////\n//  double a,b; cvec t; cin>>n;       //\n// while(n--){                        //\n//    cin>>a>>b;                      //\n//    t.push_back(comp(a,b));         //\n//  }printf(\"%.11f\\n\",Area(t));       //\n////////////////////////////////////////\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    seg a,b,c,d;\n    Point a1,a2,a3;\n    cin>>a1.x>>a1.y>>a2.x>>a2.y>>a3.x>>a3.y;\n    a.p1=a1;a.p2=a2;\n    b.p1=a2;b.p2=a3;\n    c.p1=a3;c.p2=a1;\n    cin>>d.p1.x>>d.p1.y>>d.p2.x>>d.p2.y;\n    int sum=0;\n    if(intersect(a,d))sum++;\n    if(intersect(b,d))sum++;\n    if(intersect(c,d))sum++;\n    if(!sum||sum==2)cout<<\"NG\"<<endl;\n    else cout<<\"OK\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\n#define EPS (1e-6)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\ntypedef complex<double> Po;\n\nPo unit(Po p){return p / abs(p);}\n  \nPo normal(Po p,int m){\n  Po x;\n  if(!m)x = p * Po(0,1);\n  else x = p * Po(0,-1);\n  return x;\n}\n\ndouble dot(Po x,Po y){return x.real()*y.real() + x.imag()*y.imag();}\n\ndouble cross(Po x,Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a,Po b,Po c){\n  return abs(cross(b-a,c-a)/2);\n}\n\nbool inter(Po a,Po b,Po c,Po x){\n  if( area(a,b,x) + area(b,c,x) + area(c,a,x) > area(a,b,c) +EPS)return false;\n  else return true;\n}\n\ndouble heron(double a,double b,double c){\n  double s = (a+b+c)/2;\n  return sqrt(s*(s-a)*(s-b)*(s-c));\n}\n\nclass line{\n public:\n  Po a,b;\n\n  void set(Po x,Po y){\n    a = x;\n    b = y;\n  }\n\n  bool orth(line l){\n    return EQ( dot(a-b,l.a-l.b),0.0);\n  }\n\n  bool para(line l){\n    return EQ( cross(a-b,l.a-l.b),0.0);\n  }\n\n  bool on_line(Po x){\n    return EQ( cross(b-a,x-a),0.0);\n  }\n\n  double line_dis(Po x){\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  Po line_cp(line l){\n    return a + (b-a)*cross(l.b-l.a,l.a-a) /cross(l.b-l.a,b-a);\n  }\n\n  bool on_seg(Po x){\n    return (abs(a-x) + abs(x-b) < abs(a-b) + EPS);\n  }\n\n  double seg_dis(Po x){\n    if(dot(b-a,x-a)<EPS)return abs(x-a);\n    if(dot(a-b,x-b)<EPS)return abs(x-b);\n    return abs(cross(b-a,x-a))/abs(b-a);\n  }\n\n  int is_cross(line l){\n    return (cross(b-a,l.a-a) * cross(b-a,l.b-a)<EPS) && (cross(l.b-l.a,a-l.a) * cross(l.b-l.a,b-l.a) < EPS);\n  }\n\n  Po seg_cp(line l){\n    double d = abs(cross(l.b-l.a,a-l.a));\n    return a + (b-a)*( d / (d * abs(cross(l.b-l.a,b-l.a))));\n  }\n};\n\nclass polygon{\n public:\n  vector<Po> v;\n  int o;\n\n  void set(void){\n    v.clear();\n  }\n\n  void Vadd(Po a){\n    if(!v.size())o = 0;\n    else if(a.imag() < v[o].imag())o = v.size();\n    v.push_back(a);\n  }\n\n  void sort(void){\n    vector<double> seta;\n    Po ot;\n    ot.real() = 1.0;\n    ot.imag() = 0.0;\n    swap(v[0],v[o]);\n    o = 0;\n    for(int i=1;i<(int)v.size();i++){\n      seta.push_back(dot(ot,v[i]-v[0]) / (abs(ot)*abs(v[i]-v[0])) );\n    } \n    for(int i=1;i<(int)v.size()-1;i++){\n      for(int j=i+1;j<(int)v.size();j++){\n\tif(seta[i-1] < seta[j-1]){\n\t  swap(seta[i-1],seta[j-1]);\n\t  swap(v[i],v[j]);\n\t}\n      }\n    }\n  }\n\n  bool inter(Po a){\n    int c = 0;\n    double max = 0;\n    Po b;\n    line l,s;\n    for(int i=0;i<(int)v.size();i++)if(max < v[i].real())max = v[i].real();\n    b.real() = max+1;\n    b.imag() = a.imag();\n    s.set(a,b);\n    for(int i=0;i<(int)v.size()-1;i++){\n      l.set(v[i],v[i+1]);\n      if(s.is_cross(l))c++;\n    }\n    l.set(v[(int)v.size()-1],v[0]);\n    if(s.is_cross(l))c++;\n    if(c%2)return true;\n    else return false;\n  }\n};\n\nint main(){\n  int n;\n  Po p1,p2,p3,pk,ps;\n  polygon tri;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> p1.real() >> p1.imag();\n    cin >> p2.real() >> p2.imag();\n    cin >> p3.real() >> p3.imag();\n    cin >> pk.real() >> pk.imag();\n    cin >> ps.real() >> ps.imag();\n    \n    tri.set();\n    tri.Vadd(p1);\n    tri.Vadd(p2);\n    tri.Vadd(p3);\n    tri.sort();\n    \n    if(tri.inter(pk) != tri.inter(ps))cout << \"OK\" << endl;\n    //if(inter(p1,p2,p3,pk) != inter(p1,p2,p3,ps) )cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n double vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return (vec_abs(a-c) + vec_abs(c-b) < vec_abs(a-b) + EPS);\n}\n\nint inside(point p, point* ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps[n]=ps[0];\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  double xmx=-DBL_MAX,xmn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    xmx=max(xmx,ps[i].x);\n    xmn=min(xmn,ps[i].x);\n  }\n  if(t.a.x<=xmn||t.a.x>=xmx)return 0;\n\n  int cnt=0;\n  for(int i=0;i<n;i++){\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n  }\n\n  return cnt%2;\n}\n\nint main(void){\n  int n;\n  point p[4],k,s;\n \n  cin >> n;\n  while(n--){\n\n    for(int i=0;i<3;i++)\n      cin >> p[i].x >> p[i].y;\n     \n    cin >> k.x >> k.y >> s.x >> s.y;\n    if(inside(k,p,3)!=inside(s,p,3))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n     \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tP p[5];\n\t\trep(j, 5)\n\t\t\tscanf(\"%lf%lf\", &p[j].real(), &p[j].imag());\n\t\t\n\t\tbool ok = true;\n\t\trep(j, 2){\n\t\t\tint ans;\n\t\t\trep(k, 3){\n\t\t\t\tint tmp = ccw(p[k], p[(k+1)%3], p[3+j]);\n\t\t\t\tif(!k)\n\t\t\t\t\tans = tmp;\n\t\t\t\telse if(ans*tmp < 0){\n\t\t\t\t\tok = !ok;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tputs(ok ? \"NG\" : \"OK\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n};\n\n/***************************************************************************************************/\n// _ªÊ½p`Ìà(ÓãàÜÞ)É é©²×é\n// cp : Ê½p`\n// p  : _\n/***************************************************************************************************/\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        int a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < 0)\n            ret1 = false;\n        if(a > 0)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        vector<Point> cp(3);\n        Point a, b;\n        for(int i=0; i<3; ++i)\n            cin >> cp[i].x >> cp[i].y;\n        cin >> a.x >> a.y >> b.x >> b.y;\n\n        if(convexContain(cp, a) ^ convexContain(cp, b))\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint n,loc1,loc2;\n\tdouble x1,x2,x3,y1,y2,y3,xp,yp,xq,yq;\n\tdouble calc1,calc2,calc3,calc4,calc5,calc6;\n\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",&x1,&y1,&x2,&y2,&x3,&y3,&xp,&yp,&xq,&yq);\n\n\t\tcalc1 = (x2-x1)*(yp-y1)-(y2-y1)*(xp-x1);\n\t\tcalc2 = (x3-x2)*(yp-y2)-(y3-y2)*(xp-x2);\n\t\tcalc3 = (x1-x3)*(yp-y3)-(y1-y3)*(xp-x3);\n\n\t\tcalc4 = (x2-x1)*(yq-y1)-(y2-y1)*(xq-x1);\n\t\tcalc5 = (x3-x2)*(yq-y2)-(y3-y2)*(xq-x2);\n\t\tcalc6 = (x1-x3)*(yq-y3)-(y1-y3)*(xq-x3);\n\n\t\tif((calc1>0&&calc2>0&&calc3>0) || (calc1<0&&calc2<0&&calc3<0)){\n\t\t\tloc1 = 0;\n\t\t}else{\n\t\t\tloc1 = 1;\n\t\t}\n\n\t\tif((calc4>0&&calc5>0&&calc6>0) || (calc4<0&&calc5<0&&calc6<0)){\n\t\t\tloc2 = 0;\n\t\t}else{\n\t\t\tloc2 = 1;\n\t\t}\n\n\t\tif(loc1 == loc2)printf(\"NG\\n\");\n\t\telse{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\n#define EPS 1e-5\nusing namespace std;\n\nint main(void){\n    int n;\n    cin >> n;\n    rep(i,n) {\n        int count = 0;\n        double x[5],y[5],a,b,c,d,p,q,det,ansx;\n        for(int k=0;k<5;k++) {\n            cin >> x[k] >> y[k];\n        }\n        rep(j,3) {\n            if(j != 2) {\n                a = y[j]-y[j+1];  b = x[j+1]-x[j];\n                p = x[j+1]*y[j]-x[j]*y[j+1];\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    //ansxがどちらの線分のx座標範囲にも含まれるかを判定\n                    if((x[j] - ansx)*(x[j+1] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            } else {\n                a = y[j]-y[0];  b = x[0]-x[j];\n                p = x[0]*y[j]-x[j]*y[0];\n                //(x3,y3)(x4,y4)を結ぶcx+dy=q の係数\n                c = y[3]-y[4];  d = x[4]-x[3];\n                q = x[4]*y[3]-x[3]*y[4];\n                //係数についての行列式\n                det = a*d-c*b;\n                //det=0で解は存在しない(この問題については２線分は同一直線上にないから\n                if(fabs(det) > EPS){\n                    ansx = (d*p - b*q)/det;\n                    if((x[j] - ansx)*(x[0] - ansx) <= EPS && (x[3] - ansx)*(x[4] - ansx) <= EPS ) {\n                        count++;\n                    }\n                }\n            }\n        }\n        if(count == 1) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Test.HUnit\n\nmain :: IO ()\n-- main = runTestTT (TestList tests) >> return ()\nmain = do\n  n <- getl toInt\n  xs <- rgetl n $ split toDbl\n  mapM_ putStrLn $ map solve xs\n\nsolve :: [Double] -> String\nsolve [xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys]\n  | inside (p1,p2,p3) pk `xor` inside (p1,p2,p3) ps = \"OK\"\n  | otherwise = \"NG\"\n  where\n    p1 = Point xp1 yp1\n    p2 = Point xp2 yp2\n    p3 = Point xp3 yp3\n    pk = Point xk yk\n    ps = Point xs ys\n\ninside :: (Point, Point, Point) -> Point -> Bool\ninside (p1, p2, p3) p = all (> 0) [c1,c2,c3] || all (< 0) [c1,c2,c3]\n  where\n    c1 = cross (toVect p1 p2) (toVect p1 p)\n    c2 = cross (toVect p2 p3) (toVect p2 p)\n    c3 = cross (toVect p3 p1) (toVect p3 p)\n\nxor :: Bool -> Bool -> Bool\nxor x y | x == True && y == False = True\n        | x == False && y == True = True\n        | otherwise = False\n    \ntoInt :: String -> Int\ntoInt s = read s\n\ntoDbl :: String -> Double\ntoDbl s = read s\n\nsplit :: (String -> a) -> String -> [a]\nsplit f = map f . words\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine\n\nrgetl :: Int -> (String -> a) -> IO [a]\nrgetl n f = map f <$> replicateM n getLine\n\n\ndata Point = Point {xop :: Double, yop :: Double} deriving Show\ndata Vect = Vect {xov :: Double, yov :: Double} deriving Show\n\ncross :: Vect -> Vect -> Double\ncross v1 v2 = xov v1 * yov v2 - yov v1 * xov v2\n\ntoVect :: Point -> Point -> Vect\ntoVect p1 p2 = Vect (xop p2 - xop p1) (yop p2 - yop p1)\n\n\ntests :: [Test]\ntests = [\n  \"test1\" ~: True ~=? inside ((Point 10 1),(Point 10 10),(Point 1 10)) (Point 9 9),\n  \"test2\" ~: False ~=? inside ((Point 10 1),(Point 10 10),(Point 1 10)) (Point 1 1),\n  \"test3\" ~: \"OK\" ~=? solve [10, 1, 10, 10, 1, 10, 9, 9, 1, 1],\n  \"test3\" ~: \"NG\" ~=? solve [10, 1, 10, 10, 1, 10, 9, 9, 8, 8]\n  ]"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\nimport qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\nimport Data.Array.IArray\n--import Data.Array.Unboxed\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n \nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nmodifyArray :: (Ix i, MArray a e m) => a i e -> i -> (e -> e) -> m ()\nmodifyArray arr ix f = readArray arr ix >>= writeArray arr ix . f\ndictCompare :: [a -> a -> Ordering] -> a -> a -> Ordering\ndictCompare [] _ _ = EQ\ndictCompare (f:fs) x y = let c = f x y in if c==EQ then dictCompare fs x y else c\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\n-- end of templete\n\ntype Point = (Int, Int)\ntype Line = (Point, Point)\n\nf :: Line -> Point -> Int\nf ((x1,y1),(x2,y2)) (x,y) = signum $ a*x + b*y + c\n  where\n    a = y2 - y1\n    b = x1 - x2\n    c = x2*y1 - x1*y2\n\ninner :: Point -> Point -> Point -> Point -> Bool\ninner t1 t2 t3 p = f1 p == f1 t1 && f2 p == f2 t2 && f3 p == f3 t3\n  where\n    f1 = f (t2,t3)\n    f2 = f (t3,t1)\n    f3 = f (t1,t2)\n\njudge xs = func pk /= func ps\n  where\n    [p1,p2,p3,pk,ps] = map (apply2 (,)) $ splitRec 2 xs\n    func = inner p1 p2 p3\n\nmain = do\n    n <- getInt\n    replicateM n $ do\n        getInts >>= putStrLn . cond \"OK\" \"NG\" . judge\n    return ()\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\tint x3,int y3,int x4,int y4) {\n\tdouble kaA,seA,kaB,seB,x,y,uex,uey,sitax,sitay;\n\tif(x1==x3 && y1==y3)return 1;\n\tif(x1==x4 && y1==y4)return 1;\n\tif(x2==x3 && y2==y3)return 1;\n\tif(x2==x4 && y2==y4)return 1;\n\tif(x1!=x2 && x3!=x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\tif(kaA==kaB) {\n\t\t\tif(seA==seB) {\n\t\t\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\t\t\tif((x3>=sitax && x3<=uex) || (x4>=sitax && x4<=uex))return 1;\n\t\t\t\treturn 0;\n\t\t\t} else return 0;\n\t\t}\n\t\tx=(double)(seB-seA)/(double)(kaA-kaB);\n\t\ty=kaA*x+seA;\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y1!=y2) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(y3!=y4) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t}\n\tif(x1==x2 && x3!=x4) {\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\ty=kaB*x1+seB;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y<sitay || y>uey || x1<sitax || x1>uex)return 0;\n\t}\n\tif(x1!=x2 && x3==x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\ty=kaA*x3+seA;\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y<sitay || y>uey || x3<sitax || x3>uex)return 0;\n\t}\n\tif(x1==x2 && x3==x4) {\n\t\tif(x1!=x3)return 0;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y3>y4){uex=y3;sitax=y4;} else {uex=y4;sitax=y3;}\n\t\tif(sitax>uey)return 0;\n\t\tif(uex>sitay)return 0;\n\t}\n\treturn 1;\n}\n\nint main(void) {\n\tint datanum,datamax;\n\tint isok;\n\tint x1,y1,x2,y2,x3,y3,xk,yk,xs,ys;\n\tscanf(\"%d\",&datamax);\n\tfor(datanum=0;datanum<datamax;datanum++) {\n\t\tscanf(\"%d %d %d %d %d %d %d %d\",\n\t\t\t&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tisok=0;\n\t\tif(cross(x1,y1,x2,y2,xk,yk,xs,ys))isok=1;\n\t\tif(cross(x2,y2,x3,y3,xk,yk,xs,ys))isok=1;\n\t\tif(cross(x3,y3,x1,y1,xk,yk,xs,ys))isok=1;\n\t\tputs(isok?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint x1,y1,x2,y2,x3,y3,xk,yk,xs,ys,n;\n\nint isin(double x1,double y1,double x2,double y2,double x3,double y3,double xp,double yp){\n\n\tdouble ax,ay,bx,by,cx,cy,a,b;\n\n\tax=x2-x1; ay=y2-y1;\n\tbx=x3-x1; by=y3-y1;\n\tcx=xp-x1; cy=yp-y1;\n\n\tif(by!=0){\n\t\ta=(cx*by-cy*bx)/(ax*by-ay*bx);\n\t\tb=(cy-a*ay)/by;\n\t}\n\telse{\n\t\ta=cy/ay;\n\t\tb=(cx-a*ax)/bx;\n\t}\n\n\tif(a>=0 && b>=0 && a+b<=1)return 1; else return 0;\n}\n\nint main(){\n\tfor(scanf(\"%d\",&n);n>0;n--){\n\t\tscanf(\"%d %d %d %d %d %d %d %d %d %d\",&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tif(isin(x1,y1,x2,y2,x3,y3,xk,yk)!=isin(x1,y1,x2,y2,x3,y3,xs,ys))printf(\"OK\\n\"); else printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\tint x3,int y3,int x4,int y4) {\n\tdouble kaA,seA,kaB,seB,x,y,uex,uey,sitax,sitay;\n\tif(x1==x3 && y1==y3)return 1;\n\tif(x1==x4 && y1==y4)return 1;\n\tif(x2==x3 && y2==y3)return 1;\n\tif(x2==x4 && y2==y4)return 1;\n\tif(x1!=x2 && x3!=x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\tif(kaA==kaB) {\n\t\t\tif(seA==seB) {\n\t\t\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\t\t\tif((x3>=sitax && x3<=uex) || (x4>=sitax && x4<=uex))return 1;\n\t\t\t\treturn 0;\n\t\t\t} else return 0;\n\t\t}\n\t\tx=(double)(seB-seA)/(double)(kaA-kaB);\n\t\ty=kaA*x+seA;\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y1!=y2) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(y3!=y4) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t}\n\tif(x1==x2 && x3!=x4) {\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\ty=kaB*x1+seB;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y<sitay || y>uey || x1<sitax || x1>uex)return 0;\n\t}\n\tif(x1!=x2 && x3==x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\ty=kaA*x3+seA;\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y<sitay || y>uey || x3<sitax || x3>uex)return 0;\n\t}\n\tif(x1==x2 && x3==x4) {\n\t\tif(x1!=x3)return 0;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y3>y4){uex=y3;sitax=y4;} else {uex=y4;sitax=y3;}\n\t\tif(sitax>uey)return 0;\n\t\tif(uex>sitay)return 0;\n\t}\n\treturn 1;\n}\n\nint main(void) {\n\tint datanum,datamax;\n\tint isok;\n\tint x1,y1,x2,y2,x3,y3,xk,yk,xs,ys;\n\tscanf(\"%d\",&datamax);\n\tfor(datanum=0;datanum<datamax;datanum++) {\n\t\tscanf(\"%d %d %d %d %d %d %d %d %d %d\",\n\t\t\t&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tisok=0;\n\t\tif(cross(x1,y1,x2,y2,xk,yk,xs,ys))isok=1;\n\t\tif(cross(x2,y2,x3,y3,xk,yk,xs,ys))isok=1;\n\t\tif(cross(x3,y3,x1,y1,xk,yk,xs,ys))isok=1;\n\t\tputs(isok?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\tif (sb == 0 || sa == 0) while (1);  \t\t // xb,yb in line\n\treturn (sa * sb > 0);            // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs((kin & 1) ^ (sin & 1) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int x[5],y[5],n,ax,ay,bx,by,i,j;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<5;i++)scanf(\"%d %d\",&x[i],&y[i]);\n    int f[2]={0};\n    for(i=0;i<2;i++){\n      for(j=0;j<3;j++){\n\tax=x[(j+1)%3]-x[j];\n\tay=y[(j+1)&3]-y[j];\n\tbx=x[i+3]-x[j];\n\tby=y[i+3]-y[j];\n\tif(ax*by>ay*bx)f[i]++;\n      }\n      f[i]%=3;\n    }\n    if(f[0]+f[1]==0||f[0]*f[1])printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ndouble a(double A,double a,double B,double b,double x,double y)\n{\n    if(A!=B){\n        return ((a-b)/(A-B))*(x-A)+a-y;\n    } else {\n        return x-A;\n    }\n}\n\nint main(void)\n{\n    double x1,y1,x2,y2,x3,y3,xp,yp,xs,ys;\n    int i,j,n;\n\n    for(scanf(\"%d\",&n);n>0;n--){\n\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf\",&x1,&y1,&x2,&y2,&x3,&y3,&xp,&yp,&xs,&ys);\n\n        if((a(x1,y1,x2,y2,xp,yp)*a(x1,y1,x2,y2,x3,y3)<0)||(a(x3,y3,x2,y2,xp,yp)*a(x3,y3,x2,y2,x1,y1)<0)||(a(x1,y1,x3,y3,xp,yp)*a(x1,y1,x3,y3,x2,y2)<0)){\n            if((a(x1,y1,x2,y2,xs,ys)*a(x1,y1,x2,y2,x3,y3)<0)||(a(x3,y3,x2,y2,xs,ys)*a(x3,y3,x2,y2,x1,y1)<0)||(a(x1,y1,x3,y3,xs,ys)*a(x1,y1,x3,y3,x2,y2)<0)){\n                puts(\"NG\");\n            } else {\n                puts(\"OK\");\n            }\n        } else {\n            if((a(x1,y1,x2,y2,xs,ys)*a(x1,y1,x2,y2,x3,y3)<0)||(a(x3,y3,x2,y2,xs,ys)*a(x3,y3,x2,y2,x1,y1)<0)||(a(x1,y1,x3,y3,xs,ys)*a(x1,y1,x3,y3,x2,y2)<0)){\n                puts(\"OK\");\n            } else {\n                puts(\"NG\");\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint judge(int x[],int y[],int p[]){\n  int a,b,c;\n  a=((p[0]-x[0])*(p[1]-y[1])-(p[1]-y[0])*(p[0]-x[1])>0)?1:-1;\n  b=((p[0]-x[1])*(p[1]-y[2])-(p[1]-y[1])*(p[0]-x[2])>0)?1:-1;\n  c=((p[0]-x[2])*(p[1]-y[0])-(p[1]-y[2])*(p[0]-x[0])>0)?1:-1;\n  if(a==b&&b==c)\n    return 1;\n  else\n    return 0;\n}\nint main(void){\n  int x[3],y[3],p[2][2],i,j,fk,fs,n;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<3;i++)\n      scanf(\"%d %d\",&x[i],&y[i]);\n    for(i=0;i<2;i++)\n      for(j=0;j<2;j++)\n\tscanf(\"%d\",&p[i][j]);\n    fk=judge(x,y,p[0]);\n    fs=judge(x,y,p[1]);\n    if(fk==fs)\n      puts(\"NG\");\n    else\n      puts(\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tlong long sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\tif (sb == 0 || sa == 0) while (1);  \t\t // xb,yb in line\n\treturn (sa * sb > 0);            // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs((kin & 1) ^ (sin & 1) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define F(p,n,m)(p*(f-d)*(n-e)>p*(m-d)*(g-e)&&p*(d-h)*(n-i)>p*(m-h)*(e-i))\nmain(z){float d,e,f,g,h,i,m,n,M,N,p,q;for(scanf(\"%d\",&z);z--;puts((F(p,n,m)^F(q,N,M))?\"OK\":\"NG\"))scanf(\"%f%f%f%f%f%f%f%f%f%f\",&d,&e,&f,&g,&h,&i,&m,&n,&M,&N),p=(h-f)*(n-g)-(m-f)*(i-g),q=(h-f)*(N-g)-(M-f)*(i-g);}"
  },
  {
    "language": "C",
    "code": "// AOJ 0143 Altair and Vega\n// 2017.8.8 bal4u@uu\n// 2017.11.1 retry\n\n#include <stdio.h>\n\nchar buf[102], *p;\nint getint()\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++;\n\t\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\treturn -n;\n\t}\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tlong long sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0 || sa == 0) while (1);  \t\t\t\t// xb,yb in line\n\treturn (sa > 0 && sb > 0 || sa < 0 && sb < 0);      // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tfgets(p=buf, 10, stdin); n = getint();\n\twhile (n-- > 0) {\n\t\tfgets(p=buf, 100, stdin);\n\t\tx1 = getint(), p++, y1 = getint(), p++;\n\t\tx2 = getint(), p++, y2 = getint(), p++;\n\t\tx3 = getint(), p++, y3 = getint(), p++;\n\t\txk = getint(), p++, yk = getint(), p++;\n\t\txs = getint(), p++, ys = getint();\n\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs((kin ^ sin) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\ninner(xp1,yp1,xp2,yp2,xp3,yp3,x0,y0){\n\tint o1,o2,o3;\n\txp1-=x0,yp1-=y0;\n\txp2-=x0,yp2-=y0;\n\txp3-=x0,yp3-=y0;\n\to1=xp1*yp2-yp1*xp2;\n\to2=xp2*yp3-yp2*xp3;\n\to3=xp3*yp1-yp3*xp1;\n\treturn o1*o2>0&&o2*o3>0;\n}\nmain(){\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d%d%d%d%d%d%d%d%d%d\",&xp1,&yp1,&xp2,&yp2,&xp3,&yp3,&xk,&yk,&xs,&ys);){\n\t\tputs(inner(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk)^inner(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int x[5],y[5],n,ax,ay,bx,by,i,j;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<5;i++)scanf(\"%d %d\",&x[i],&y[i]);\n    int f[2]={0};\n    for(i=0;i<2;i++){\n      for(j=0;j<3;j++){\n\tax=x[(j+1)%3]-x[j];\n\tay=y[(j+1)%3]-y[j];\n\tbx=x[i+3]-x[j];\n\tby=y[i+3]-y[j];\n\tif(ax*by>ay*bx)f[i]++;\n      }\n      f[i]%=3;\n    }\n    if(f[0]+f[1]==0||f[0]*f[1])printf(\"NG\\n\");\n    else printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cross(int x1,int y1,int x2,int y2,\n\tint x3,int y3,int x4,int y4) {\n\tdouble kaA,seA,kaB,seB,x,y,uex,uey,sitax,sitay;\n\tif(x1==x3 && y1==y3)return 1;\n\tif(x1==x4 && y1==y4)return 1;\n\tif(x2==x3 && y2==y3)return 1;\n\tif(x2==x4 && y2==y4)return 1;\n\tif(x1!=x2 && x3!=x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\tif(kaA==kaB) {\n\t\t\tif(seA==seB) {\n\t\t\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\t\t\tif((x3>=sitax && x3<=uex) || (x4>=sitax && x4<=uex))return 1;\n\t\t\t\treturn 0;\n\t\t\t} else return 0;\n\t\t}\n\t\tx=(double)(seB-seA)/(double)(kaA-kaB);\n\t\ty=kaA*x+seA;\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y1!=y2) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(y3!=y4) {\n\t\t\tif(x<sitax || x>uex || y<sitay || y>uey)return 0;\n\t\t} else {\n\t\t\tif(x<sitax || x>uex)return 0;\n\t\t}\n\t}\n\tif(x1==x2 && x3!=x4) {\n\t\tkaB=(double)(y4-y3)/(double)(x4-x3);\n\t\tseB=y3-x3*kaB;\n\t\ty=kaB*x1+seB;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(x3>x4){uex=x3;sitax=x4;} else {uex=x4;sitax=x3;}\n\t\tif(y<sitay || y>uey || x1<sitax || x1>uex)return 0;\n\t}\n\tif(x1!=x2 && x3==x4) {\n\t\tkaA=(double)(y2-y1)/(double)(x2-x1);\n\t\tseA=y1-x1*kaA;\n\t\ty=kaA*x3+seA;\n\t\tif(y3>y4){uey=y3;sitay=y4;} else {uey=y4;sitay=y3;}\n\t\tif(x1>x2){uex=x1;sitax=x2;} else {uex=x2;sitax=x1;}\n\t\tif(y<sitay || y>uey || x3<sitax || x3>uex)return 0;\n\t}\n\tif(x1==x2 && x3==x4) {\n\t\tif(x1!=x3)return 0;\n\t\tif(y1>y2){uey=y1;sitay=y2;} else {uey=y2;sitay=y1;}\n\t\tif(y3>y4){uex=y3;sitax=y4;} else {uex=y4;sitax=y3;}\n\t\tif(sitax>uey)return 0;\n\t\tif(uex>sitay)return 0;\n\t}\n\treturn 1;\n}\n\nint main(void) {\n\tint datanum,datamax;\n\tint crossnum;\n\tint x1,y1,x2,y2,x3,y3,xk,yk,xs,ys;\n\tscanf(\"%d\",&datamax);\n\tfor(datanum=0;datanum<datamax;datanum++) {\n\t\tscanf(\"%d %d %d %d %d %d %d %d %d %d\",\n\t\t\t&x1,&y1,&x2,&y2,&x3,&y3,&xk,&yk,&xs,&ys);\n\t\tcrossnum=0;\n\t\tif(cross(x1,y1,x2,y2,xk,yk,xs,ys))crossnum++;\n\t\tif(cross(x2,y2,x3,y3,xk,yk,xs,ys))crossnum++;\n\t\tif(cross(x3,y3,x1,y1,xk,yk,xs,ys))crossnum++;\n\t\tputs(crossnum==1?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(z){float d,e,f,g,h,i,m,n,M,N,p,q;for(scanf(\"%d\",&z);z--;puts(((p*(f-d)*(n-e)>p*(m-d)*(g-e)&&p*(d-h)*(n-i)>p*(m-h)*(e-i))^(q*(f-d)*(N-e)>q*(M-d)*(g-e)&&q*(d-h)*(N-i)>q*(M-h)*(e-i)))?\"OK\":\"NG\"))scanf(\"%f%f%f%f%f%f%f%f%f%f\",&d,&e,&f,&g,&h,&i,&m,&n,&M,&N),p=(h-f)*(n-g)-(m-f)*(i-g),q=(h-f)*(N-g)-(M-f)*(i-g);}"
  },
  {
    "language": "C",
    "code": "#define F(p,n,m)(p*(f-d)*(n-e)>p*(m-d)*(g-e)&&p*(d-h)*(n-i)>p*(m-h)*(e-i))\n#define G(p,n,m),p=(h-f)*(n-g)-(m-f)*(i-g)\nmain(z){float d,e,f,g,h,i,m,n,M,N,p,q;for(scanf(\"%d\",&z);z--;puts((F(p,n,m)^F(q,N,M))?\"OK\":\"NG\"))scanf(\"%f%f%f%f%f%f%f%f%f%f\",&d,&e,&f,&g,&h,&i,&m,&n,&M,&N)G(p,n,m)G(q,N,M);}"
  },
  {
    "language": "C",
    "code": "a,b,c,d,e,f,v,w,s,t;I(x,y){float o,p,q;a-=x,b-=y;c-=x,d-=y;e-=x,f-=y;o=1.*a*d-1.*b*c;p=1.*c*f-1.*d*e;q=1.*e*b-1.*f*a;return o*p>0&&p*q>0;}main(i){scanf(\"%*d\");for(;~scanf(\"%d%d%d%d%d%d%d%d%d%d\",&a,&b,&c,&d,&e,&f,&v,&w,&s,&t);){i=I(v,w);puts(i^I(s-v,t-w)?\"OK\":\"NG\");}}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0143\nTitle Altair and Vega\n@kankichi573\n*/\n#include <stdio.h>\n#include <float.h>\n\nint N;\nint xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\nint a[2][2];\nint b[2];\ndouble result[2];\n\nvoid renritu_solve()\n{\n        int det;\n        \n        det=a[0][0]*a[1][1]-a[1][0]*a[0][1];\n        result[0]=(double)(a[1][1]*b[0]-a[0][1]*b[1]);\n        result[1]=(double)(-a[1][0]*b[0]+a[0][0]*b[1]);\n        result[0] /= ((double)det);\n        result[1] /= ((double)det);\n\n}\n//\nmain()\n{\n        int i,n,r1,r2;\n\n\n        while(EOF!=scanf(\"%d \",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                {\n                        scanf(\"%d %d %d %d %d %d %d %d %d %d\",\n                              &xp1,&yp1,&xp2,&yp2,&xp3,&yp3,&xk,&yk,&xs,&ys);\n                                \n                        a[0][0]=xp2-xp1;\n                        a[0][1]=xp3-xp1;\n                        a[1][0]=yp2-yp1;\n                        a[1][1]=yp3-yp1;\n\n                        b[0]=xk-xp1;\n                        b[1]=yk-yp1;\n                        renritu_solve();\n                        \n                        r1=((result[0]>0.0) && (result[1]>0.0) && (result[0]+result[1]<1.0))?1:0;\n                        b[0]=xs-xp1;\n                        b[1]=ys-yp1;\n                        renritu_solve();\n                        \n                        r2=((result[0]>0.0) && (result[1]>0.0) && (result[0]+result[1]<1.0))?1:0;\n                        \n                        printf(\"%s\\n\",(r1+r2==1)?\"OK\":\"NG\");\n                }        \n        }\n\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 1 Problem 0143\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n\tdouble x1;\n\tdouble y1;\n\tdouble x2;\n\tdouble y2;\n} LINE;\n\nint cross(LINE *l1, LINE *l2)\n{\n\tdouble ta, tb, tc, td;\n\n\tta = (l2->x1 - l2->x2) * (l1->y1 - l2->y1) + (l2->y1 - l2->y2) * (l2->x1 - l1->x1);\n\ttb = (l2->x1 - l2->x2) * (l1->y2 - l2->y1) + (l2->y1 - l2->y2) * (l2->x1 - l1->x2);\n\ttc = (l1->x1 - l1->x2) * (l2->y1 - l1->y1) + (l1->y1 - l1->y2) * (l1->x1 - l2->x1);\n\ttd = (l1->x1 - l1->x2) * (l2->y2 - l1->y1) + (l1->y1 - l1->y2) * (l1->x1 - l2->x2);\n\n\tif ((ta * tb <= 0) && (tc * td <= 0)){\n\t\treturn (1);    // cross\n\t}\n\treturn (0); // no cross\n}\n\nint main(void)\n{\n    int n;\n    int xp1, yp1, xp2, yp2, xp3, yp3;\n    int xk, yk, xs, ys;\n    int i;\n    double xp, yp;\n    LINE p1, p2, p3, k, s;\n    int flag_in_k, flag_in_s;\n    \n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++){\n        scanf(\"%d%d%d%d%d%d\", &xp1, &yp1, &xp2, &yp2, &xp3, &yp3);\n        scanf(\"%d%d%d%d\", &xk, &yk, &xs, &ys);\n    \n        xp = (xp1 + xp2 + xp3) / 3.0;\n        yp = (yp1 + yp2 + yp3) / 3.0;\n    \n        p1.x1 = xp1;\n        p1.y1 = yp1;\n        p1.x2 = xp2;\n        p1.y2 = yp2;\n        \n        p2.x1 = xp2;\n        p2.y1 = yp2;\n        p2.x2 = xp3;\n        p2.y2 = yp3;\n    \n        p3.x1 = xp3;\n        p3.y1 = yp3;\n        p3.x2 = xp1;\n        p3.y2 = yp1;\n\n        k.x1 = xk;\n        k.y1 = yk;\n        k.x2 = xp;\n        k.y2 = yp;\n\n        s.x1 = xs;\n        s.y1 = ys;\n        s.x2 = xp;\n        s.y2 = yp;\n\n        flag_in_k = 0;\n        if (cross(&p1, &k) + cross(&p2, &k) + cross(&p3, &k) == 0){\n            flag_in_k = 1;\n        }\n        \n        flag_in_s = 0;\n        if (cross(&p1, &s) + cross(&p2, &s) + cross(&p3, &s) == 0){\n            flag_in_s = 1;\n        }\n\n        if (flag_in_k != flag_in_s){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define SQ(a) ((a) * (a))\n#define EPS 1e-2\ntypedef struct {\n\tdouble x;\n\tdouble y;\n} POINT;\n\ndouble area(double a, double b, double c)\n{\n\tdouble s;\n\ts = (a + b + c) / 2;\n\treturn(sqrt(s * (s - a) * (s - b) * (s - c)));\n}\n\nint main(void)\n{\n    int n;\n\tPOINT a, b, c, p, k;\n\tdouble ab, bc, ca, ap, bp, cp, ak, bk, ck;\n    \n    scanf(\"%d\", &n);\n    \n\twhile (n--){\n        scanf(\"%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y, &c.x, &c.y, &p.x, &p.y, &k.x, &k.y);\n\t\tab = sqrt(SQ(a.x - b.x) + SQ(a.y - b.y));\n\t\tbc = sqrt(SQ(b.x - c.x) + SQ(b.y - c.y));\n\t\tca = sqrt(SQ(c.x - a.x) + SQ(c.y - a.y));\n\t\tap = sqrt(SQ(a.x - p.x) + SQ(a.y - p.y));\n\t\tbp = sqrt(SQ(b.x - p.x) + SQ(b.y - p.y));\n\t\tcp = sqrt(SQ(c.x - p.x) + SQ(c.y - p.y));\n\t\tak = sqrt(SQ(a.x - k.x) + SQ(a.y - k.y));\n\t\tbk = sqrt(SQ(b.x - k.x) + SQ(b.y - k.y));\n\t\tck = sqrt(SQ(c.x - k.x) + SQ(c.y - k.y));\n        \n\t\tif ((fabs(area(ab ,bc ,ca) - area(ap, bp, ab) - area(ap, cp, ca) - area(bp, cp, bc)) < EPS && fabs(area(ab ,bc ,ca) - area(ak, bk, ab) - area(ak, ck, ca) - area(bk, ck, bc)) < EPS) || (fabs(area(ab ,bc ,ca) - area(ap, bp, ab) - area(ap, cp, ca) - area(bp, cp, bc)) > EPS && fabs(area(ab ,bc ,ca) - area(ak, bk, ab) - area(ak, ck, ca) - area(bk, ck, bc)) > EPS)){\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys;\ninner(xp1,yp1,xp2,yp2,xp3,yp3,x0,y0){\n\tdouble o1,o2,o3;\n\txp1-=x0,yp1-=y0;\n\txp2-=x0,yp2-=y0;\n\txp3-=x0,yp3-=y0;\n\to1=(double)xp1*yp2-(double)yp1*xp2;\n\to2=(double)xp2*yp3-(double)yp2*xp3;\n\to3=(double)xp3*yp1-(double)yp3*xp1;\n\treturn o1*o2>0&&o2*o3>0;\n}\nmain(){\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d%d%d%d%d%d%d%d%d%d\",&xp1,&yp1,&xp2,&yp2,&xp3,&yp3,&xk,&yk,&xs,&ys);){\n\t\tputs(inner(xp1,yp1,xp2,yp2,xp3,yp3,xk,yk)^inner(xp1,yp1,xp2,yp2,xp3,yp3,xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "a,b,c,d,e,f,v,w,s,t;float p,u=1;I(x,y){a-=x,b-=y;c-=x,d-=y;e-=x,f-=y;p=u*c*f-u*d*e;return(u*a*d-u*b*c)*p>0&p*(u*e*b-u*f*a)>0;}main(i){for(;~scanf(\"%*d%d%d%d%d%d%d%d%d%d%d\"+!!p*3,&a,&b,&c,&d,&e,&f,&v,&w,&s,&t);puts(i^I(s-v,t-w)?\"OK\":\"NG\"))i=I(v,w);}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0143   Altair and Vega\n// 2017.8.8\n\n#include <stdio.h>\n\nint atSameSide(int x1, int y1, int x2, int y2, int xa, int ya, int xb, int yb)\n{\n\tint sa, sb;\n\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n//\tif (sb == 0) return 0;  \t\t // xb,yb in line\n\treturn (sa * sb >= 0);           // xa,ya xb,yb at same side\n}\n\nint main()\n{\n\tint n;\n\tint x1, y1, x2, y2, x3, y3, xk, yk, xs, ys;\n\tint kin, sin;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tscanf(\"%d%d%d%d%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &x3, &y3, &xk, &yk, &xs, &ys);\n\t\tkin = atSameSide(x1, y1, x2, y2, x3, y3, xk, yk) &&\n\t\t\t  atSameSide(x2, y2, x3, y3, x1, y1, xk, yk) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xk, yk);\n\t\tsin = atSameSide(x1, y1, x2, y2, x3, y3, xs, ys) &&\n\t\t  \t  atSameSide(x2, y2, x3, y3, x1, y1, xs, ys) &&\n\t\t\t  atSameSide(x3, y3, x1, y1, x2, y2, xs, ys);\n\t\tputs(kin ^ sin ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "a,b,c,d,e,f,v,w,s,t;float p,u=1;I(x,y){a-=x,b-=y;c-=x,d-=y;e-=x,f-=y;p=u*c*f-u*d*e;return (u*a*d-u*b*c)*p>0&p*(u*e*b-u*f*a)>0;}main(i){for(;~scanf(\"%*d%d%d%d%d%d%d%d%d%d%d\"+!!p*3,&a,&b,&c,&d,&e,&f,&v,&w,&s,&t);puts(i^I(s-v,t-w)?\"OK\":\"G\"))i=I(v,w);}"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.sqrt\n\nfun main(args:Array<String>):Unit {\n    repeat(readLine()!!.trim().toInt()){\n        val arg = readLine()!!.trim().split(' ').map(String::toInt)\n        val points = Array(5){\n            val (x, y) = arg.drop(it * 2).take(2)\n            Point(x, y)\n        }\n        val (a, b, c, d, e) = points\n        val edge = Edge(d, e)\n        val ta = Edge(a, b)\n        val tb = Edge(b, c)\n        val tc = Edge(c, a)\n        println(if (listOf(ta, tb, tc).count{edge.isCross(it)} == 1) \"OK\" else \"NG\")\n    }\n}\ndata class Vector(val x:Int, val y:Int){\n    fun cross(that:Vector):Int = x * that.y - y * that.x\n    fun sin(that:Vector):Double = cross(that) / length / that.length\n    val length:Double\n        get() = sqrt(x.toDouble() * x + y * y)\n    constructor(from:Point, to:Point):this(to.x - from.x, to.y - from.y)\n}\ndata class Point(val x:Int, val y:Int)\ndata class Edge(val from:Point, val to:Point){\n    fun isCross(that:Edge):Boolean {\n        val eVec = Vector(from, to)\n        val ffVec = Vector(from, that.from)\n        val ftVec = Vector(from, that.to)\n        val tVec = Vector(that.from, that.to)\n        val tffVec = Vector(that.from, from)\n        val tftVec = Vector(that.from, to)\n        return eVec.sin(ffVec) * eVec.sin(ftVec) <= 0 && tVec.sin(tffVec) * tVec.sin(tftVec) <= 0\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Altair and Vega\npublic class Main {\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\tPoint[] p = new Point[3];\n\t\t\tfor(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint p1 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint p2 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tboolean in1 = false;\n\t\t\tboolean in2 = false;\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tboolean right2 = true;\n\t\t\tboolean left2 = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tPoint base = sub(p[(i+1)%3], p[i]);\n\t\t\t\tPoint bec = sub(p1, p[i]);\n\t\t\t\tPoint bec2 = sub(p2, p[i]);\n\t\t\t\tif(extp(base, bec)<0) left = false;\n\t\t\t\telse right = false;\n\t\t\t\tif(extp(base, bec2)<0) left2 = false;\n\t\t\t\telse right2 = false;\n\t\t\t}\n\t\t\tin1 = left|right;\n\t\t\tin2 = left2|right2;\n\t\t\tSystem.out.println(in1!=in2?\"OK\":\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tfinal double EPS=1e-6;\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tdouble x,y;\n\t\tdouble norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\tVector(double x,double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\t\n\tVector sub(Vector a,Vector b){\n\t\treturn new Vector(a.x-b.x,a.y-b.y);\n\t}\n\t\n\tdouble ip(Vector a,Vector b){\n\t\treturn a.x*b.x+a.y*b.y;\n\t}\n\t\n\tdouble theta(Vector a,Vector b,Vector c){\n\t\tVector v=sub(a,b),u=sub(c,b);\n\t\treturn Math.acos(ip(v,u)/v.norm()/u.norm());\n\t}\n\n\tboolean inTriangle(Vector[] triangle,Vector p){\n\t\tdouble angle=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tangle+=theta(triangle[i],p,triangle[(i+1)%3]);\n\t\t}\n\t\treturn Math.abs(angle-Math.PI*2)<EPS;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tint n=ni();\n\t\t\n\t\tfor(int a=0;a<n;++a){\n\t\t\tVector[] triangle=new Vector[3];\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ttriangle[i]=new Vector(ni(),ni());\n\t\t\t}\n\t\t\tVector k=new Vector(ni(),ni()),s=new Vector(ni(),ni());\n\t\t\tSystem.out.println(inTriangle(triangle,k)^inTriangle(triangle,s)?\"OK\":\"NG\");\n\t\t}\n\t\tsc.close();\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Polygon;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\twhile (n-- > 0) {\n\t\t\tPolygon polygon = new Polygon();\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tpolygon.addPoint(x, y);\n\t\t\t}\n\t\t\tPoint2D.Double[] points = new Point2D.Double[2];\n\t\t\tboolean[] b = new boolean[2];\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tpoints[i] = new Point2D.Double(scanner.nextDouble(),\n\t\t\t\t\t\tscanner.nextDouble());\n\t\t\t\tb[i] = polygon.contains(points[i]);\n\t\t\t}\n\t\t\tSystem.out.println(b[0] ^ b[1] ? \"OK\" : \"NG\");\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tPolygon poly = new Polygon();\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tpoly.addPoint(x, y);\n\t\t\t}\n\t\t\tboolean k = poly.contains(sc.nextInt(), sc.nextInt());\n\t\t\tboolean s = poly.contains(sc.nextInt(), sc.nextInt());\n\t\t\tSystem.out.println(k ^ s ? \"OK\" : \"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n \n    /**\n     * @param args\n     */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = parseNum();\n\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tsolve(parsePos());\n\t\t}\n\t}\n\n\tprivate static void solve(int[][] pos) {\n\t\tif (isInner(pos[0], pos[1], pos[2], pos[3]) != isInner(pos[0], pos[1], pos[2], pos[4])) {\n\t\t\tSystem.out.println(\"OK\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t}\n\n\tprivate static boolean isInner(int[] ia, int[] ib, int[] ic, int[] ip) {\n        int\tn1 = getCrossSign(ia, ib, ip);\n        int\tn2 = getCrossSign(ib, ic, ip);\n        int\tn3 = getCrossSign(ic, ia, ip);\n\n        return ((n1 == n2) && (n2 == n3));\n\t}\n \n\tprivate static int getCrossSign(int[] ia, int[] ib, int[] ip) {\n\t\tint[]    iab = { ib[0] - ia[0], ib[1] - ia[1] };\n\t\tint[]    iap = { ip[0] - ia[0], ip[1] - ia[1] };\n\t\treturn ( getCross(iab, iap) >= 0 ) ? 1 : -1;\n\t}\n \n\tprivate static double getCross(int[] iab, int[] iap) {\n\t\treturn iab[0] * iap[1] - iab[1] * iap[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static int[][] parsePos() {\n\t\tint[][]\tpos = null;\n\t\tString\tstr = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tString[]\tlns = str.split(\" \");\n\n\t\t\tpos = new int[5][2];\n\t\t\tfor (int i = 0; i < pos.length; i++) {\n\t\t\t\tpos[i][0] = Integer.parseInt(lns[i*2]);\n\t\t\t\tpos[i][1] = Integer.parseInt(lns[i*2+1]);\n\t\t\t}\n\t\t}\n \n\t\treturn pos;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tparam = 0;\n\t\tString\tstrin = null;\n\n\t\tif ((strin = parseStdin()) != null) {\n\t\t\tparam = Integer.parseInt(strin);\n\t\t}\n \n\t\treturn param;\n\t}\n\n\tprivate static String parseStdin() {\n        String  stdin = null;\n        \n        try {\n        \tString  tmp = br.readLine();\n        \tif (tmp != null) {\n            \tif (!tmp.isEmpty()) {\n            \t\tstdin = tmp;\n            \t}\n        \t}\n        }\n        catch (IOException e) {}\n \n        return stdin;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] x = new int[5];\n\t\t\tint[] y = new int[5];\n\t\t\tLine2D.Double[] s = new Line2D.Double[4];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tx[j] = sc.nextInt();\n\t\t\t\t\ty[j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\ts[0] = new Line2D.Double(x[0],y[0],x[1],y[1]);\n\t\t\t\ts[1] = new Line2D.Double(x[1],y[1],x[2],y[2]);\n\t\t\t\ts[2] = new Line2D.Double(x[2],y[2],x[0],y[0]);\n\t\t\t\ts[3] = new Line2D.Double(x[3],y[3],x[4],y[4]);\n\t\t\t\t\n\t\t\t\tint ans = 1;\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(s[j].intersectsLine(s[3])==false) ans = -ans;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ans==1) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tPoint2D[] points = new Point2D[3];\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tpoints[j] = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tPoint2D start = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\tPoint2D end = new Point2D(sc.nextInt(), sc.nextInt());\n\t\t\t\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tint next = j + 1 >= 3 ? 0 : j + 1;\n\t\t\t\t\n\t\t\t\tif(Point2D.intersect_s(points[j], points[next], start, end)){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count % 2 == 0 ? \"NG\" : \"OK\");\n\t\t}\n\n\t}\n\n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-10;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y * y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int n, i, j, xk, yk, xs, ys;\n    int[] x, y;\n\n    n = sc.nextInt();\n    x = new int[4]; y = new int[4];\n    for(i = 0;i < n;i++){\n      for(j = 0;j < 3;j++){\n        x[j] = sc.nextInt(); y[j] = sc.nextInt();\n      }\n      x[3] = x[0]; y[3] = y[0];\n      xk = sc.nextInt(); yk = sc.nextInt();\n      xs = sc.nextInt(); ys = sc.nextInt();\n      if(solve(x, y, xk, yk) + solve(x, y, xs, ys) == 2)out.println(\"OK\");\n      else out.println(\"NG\");\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n\n  private static int solve(int[] x, int[] y, int x0, int y0){\n    int i, j, countr, n;\n    int ax, ay, bx, by, tmp;\n\n    countr = 0; n = 3;\n\n    for(j = 0;j < n;j++){\n      if((x[j] - x0) * (y[j + 1] - y0) - (y[j] - y0) * (x[j + 1] - x0) == 0){\n        if((x[j] - x0) * (x[j + 1] - x0) <= 0\n        && (y[j] - y0) * (y[j + 1] - y0) <= 0)break;\n        else if(x0 < x[j + 1] && x0 < x[j] && y0 == y[j] && y0 == y[j + 1])\n          if((y[(j - 1 + n) % n] - y0) * (y[(j + 2) % n] - y0) > 0)countr++;\n      }\n\n      if((y[j] - y0) * (y[j + 1] - y0) <= 0 && y0 != y[j + 1]){\n        ax = x[j]; ay = y[j];\n        bx = x[j + 1]; by = y[j + 1];\n\n        if(ay > by){\n          tmp = ay; ay = by; by = tmp;\n          tmp = ax; ax = bx; bx = tmp;\n        }\n        if((ax - x0) * (by - y0) - (bx - x0) * (ay - y0) > 0){\n          countr++;\n          if((y[(j - 1 + n) % n] - y0) * (y[j + 1] - y0) > 0 && y[j] == y0){\n            countr++;\n          }\n        }\n      }\n    }\n\n    if(j < n)return 1;\n    else{\n      if(countr % 2 == 1)return 2;\n      else return 0;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Altair and Vega\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\tPoint[] p = new Point[3];\n\t\t\tfor(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint p1 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint p2 = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tboolean in1 = false;\n\t\t\tboolean in2 = false;\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tboolean right2 = true;\n\t\t\tboolean left2 = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tPoint base = sub(p[(i+1)%3], p[i]);\n\t\t\t\tPoint bec = sub(p1, p[i]);\n\t\t\t\tPoint bec2 = sub(p2, p[i]);\n\t\t\t\tif(extp(base, bec)<0) left = false;\n\t\t\t\telse right = false;\n\t\t\t\tif(extp(base, bec2)<0) left2 = false;\n\t\t\t\telse right2 = false;\n\t\t\t}\n\t\t\tin1 = left|right;\n\t\t\tin2 = left2|right2;\n\t\t\tSystem.out.println(in1!=in2?\"OK\":\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static int f(Pos a1, Pos a2, Pos x, Pos y) {\n\t\tPos da = new Pos(a2.x - a1.x, a2.y - a1.y);\n\t\tPos dx = new Pos(x.x - a1.x, x.y - a1.y);\n\t\tPos dy = new Pos(y.x - a1.x, y.y - a1.y);\n\n\t\tint kx = da.x * dx.y - da.y * dx.x;\n\t\tint ky = da.x * dy.y - da.y * dy.x;\n\n\t\treturn kx * ky;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos pos[] = new Pos[5];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tpos[j] = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\n\t\t\tboolean flag[] = {true, true};\n\t\t\tfor (int j = 3; j <= 4; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tif (f(pos[k], pos[(k + 1) % 3], pos[(k + 2) % 3], pos[j]) <= 0) {\n\t\t\t\t\t\tflag[j - 3] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag[0] != flag[1]) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Polygon;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n \n    /**\n     * @param args\n     */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tnum = parseNum();\n\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tsolve(parsePos());\n\t\t}\n\t}\n\n\tprivate static void solve(int[][] pos) {\n\t\tPolygon\ttri = new Polygon();\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\ttri.addPoint(pos[i][0], pos[i][1]);\n\t\t}\n\n\t\tif (tri.contains(pos[3][0], pos[3][1]) != tri.contains(pos[4][0], pos[4][1])) {\n\t\t\tSystem.out.println(\"OK\");\n\t\t} else {\n\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t}\n\n\tprivate static int[][] parsePos() {\n\t\tint[][]\tpos = null;\n\t\tString\tstr = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tString[]\tlns = str.split(\" \");\n\n\t\t\tpos = new int[5][2];\n\t\t\tfor (int i = 0; i < pos.length; i++) {\n\t\t\t\tpos[i][0] = Integer.parseInt(lns[i*2]);\n\t\t\t\tpos[i][1] = Integer.parseInt(lns[i*2+1]);\n\t\t\t}\n\t\t}\n \n\t\treturn pos;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tparam = 0;\n\t\tString\tstrin = null;\n\n\t\tif ((strin = parseStdin()) != null) {\n\t\t\tparam = Integer.parseInt(strin);\n\t\t}\n \n\t\treturn param;\n\t}\n\n\tprivate static String parseStdin() {\n        String  stdin = null;\n        \n        try {\n        \tString  tmp = br.readLine();\n        \tif (tmp != null) {\n            \tif (!tmp.isEmpty()) {\n            \t\tstdin = tmp;\n            \t}\n        \t}\n        }\n        catch (IOException e) {}\n \n        return stdin;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-9;\n\n\tint n;\n\tP ps1, ps2, ps3;\n\tP k, s;\n\n\tvoid run() {\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xp1 = sc.nextInt();\n\t\t\tint yp1 = sc.nextInt();\n\t\t\tint xp2 = sc.nextInt();\n\t\t\tint yp2 = sc.nextInt();\n\t\t\tint xp3 = sc.nextInt();\n\t\t\tint yp3 = sc.nextInt();\n\t\t\tint xk = sc.nextInt();\n\t\t\tint yk = sc.nextInt();\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tps1 = new P(xp1, yp1);\n\t\t\tps2 = new P(xp2, yp2);\n\t\t\tps3 = new P(xp3, yp3);\n\t\t\tk = new P(xk, yk);\n\t\t\ts = new P(xs, ys);\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tif (crsSS(k, s, ps1, ps2) ^ crsSS(k, s, ps2, ps3)\n\t\t\t\t^ crsSS(k, s, ps3, ps1)) {\n\t\t\tprintln(\"OK\");\n\t\t} else {\n\t\t\tprintln(\"NG\");\n\t\t}\n\t}\n\n\tboolean crsSS(P p1, P p2, P q1, P q2) {\n\t\tif (max(p1.x, p2.x) + EPS < min(q1.x, q2.x))\n\t\t\treturn false;\n\t\tif (max(q1.x, q2.x) + EPS < min(p1.x, p2.x))\n\t\t\treturn false;\n\t\tif (max(p1.y, p2.y) + EPS < min(q1.y, q2.y))\n\t\t\treturn false;\n\t\tif (max(q1.y, q2.y) + EPS < min(p1.y, p2.y))\n\t\t\treturn false;\n\t\treturn signum(p2.sub(p1).det(q1.sub(p1)))\n\t\t\t\t* signum(p2.sub(p1).det(q2.sub(p1))) < EPS\n\t\t\t\t&& signum(q2.sub(q1).det(p1.sub(q1)))\n\t\t\t\t\t\t* signum(q2.sub(q1).det(p2.sub(q1))) < EPS;\n\t}\n\n\tclass P {\n\t\tdouble x, y;\n\n\t\tP() {\n\t\t\tthis(0, 0);\n\t\t}\n\n\t\tP(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tP add(P p) {\n\t\t\treturn new P(x + p.x, y + p.y);\n\t\t}\n\n\t\tP sub(P p) {\n\t\t\treturn new P(x - p.x, y - p.y);\n\t\t}\n\n\t\tP mul(double m) {\n\t\t\treturn new P(x * m, y * m);\n\t\t}\n\n\t\tP div(double d) {\n\t\t\treturn new P(x / d, y / d);\n\t\t}\n\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(abs2());\n\t\t}\n\n\t\tdouble abs2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tdouble arg() {\n\t\t\treturn Math.atan2(y, x);\n\t\t}\n\n\t\t// inner product\n\t\tdouble dot(P p) {\n\t\t\treturn x * p.x + y * p.y;\n\t\t}\n\n\t\t// outer product\n\t\tdouble det(P p) {\n\t\t\treturn x * p.y - y * p.x;\n\t\t}\n\n\t\tP rot90() {\n\t\t\treturn new P(-y, x);\n\t\t}\n\n\t\t// conjugation\n\t\tP conj() {\n\t\t\treturn new P(x, -y);\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\twhile (n-- > 0) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[5];\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tpoints[i] = new Point2D.Double(scanner.nextDouble(),\n\t\t\t\t\t\tscanner.nextDouble());\n\t\t\t}\n\t\t\tPath2D.Double path = new Path2D.Double();\n\t\t\tpath.moveTo(points[0].x, points[0].y);\n\t\t\tpath.lineTo(points[1].x, points[1].y);\n\t\t\tpath.lineTo(points[2].x, points[2].y);\n\t\t\tif ((path.contains(points[3]) && path.contains(points[4]))\n\t\t\t\t\t|| !path.contains(points[3]) && !path.contains(points[4])) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass line {\n\t\tdouble x1, x2;\n\t\tdouble y1, y2;\n\n\t\tline(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.y2 = y2;\n\t\t}\n\n\t\tline(line a) {\n\t\t\tx1 = a.x1;\n\t\t\tx2 = a.x2;\n\t\t\ty1 = a.y1;\n\t\t\ty2 = a.y2;\n\t\t}\n\n\t\tvoid shift(double x, double y) {\n\t\t\tx1 -= x;\n\t\t\tx2 -= x;\n\t\t\ty1 -= y;\n\t\t\ty2 -= y;\n\t\t}\n\n\t\tvoid rot(double x, double y) {\n\t\t\tline t = new line(this);\n\n\t\t\ty1 = t.x1 * y - t.y1 * x;\n\n\t\t\ty2 = t.x2 * y - t.y2 * x;\n\t\t}\n\n\t\tboolean cross(line tar) {\n\t\t\tline t = new line(this);\n\t\t\tline r = new line(tar);\n\n\t\t\tr.shift(t.x1, t.y1);\n\t\t\tt.shift(t.x1, t.y1);\n\n\t\t\tr.rot(t.x2, t.y2);\n\t\t\tif (r.y1 * r.y2 < 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tint n = sc.nextInt();\n\t\tfor (int z = 0; z < n; z++) {\n\t\t\tint x[] = new int[5];\n\t\t\tint y[] = new int[5];\n\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tline[] tri = new line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint j = i % 3;\n\t\t\t\tint k = (i + 1) % 3;\n\t\t\t\ttri[i] = new line(x[j], y[j], x[k], y[k]);\n\t\t\t}\n\t\t\tline tar = new line(x[3], y[3], x[4], y[4]);\n\n\t\t\tint cross = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (tri[i].cross(tar)) {\n\t\t\t\t\tif (tar.cross(tri[i])) {\n\t\t\t\t\t\tcross++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\n\t\t\t\t\t(cross == 1 ? \"OK\" : \"NG\"));\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.*;\npublic class Main {\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint [][] tri = new int [4][2];\n\t\t\tfor(int j=0; j < 3; j++){\n\t\t\t\ttri[j][0] = sc.nextInt();\n\t\t\t\ttri[j][1] = sc.nextInt();\n\t\t\t}\n\t\t\ttri[3][0] = tri[0][0];\n\t\t\ttri[3][1] = tri[0][1];\n\t\t\tint manX = sc.nextInt();\n\t\t\tint manY = sc.nextInt();\n\t\t\tint womanX = sc.nextInt();\n\t\t\tint womanY = sc.nextInt();\n\t\t\tLine2D.Double mAndw = new Line2D.Double(manX, manY, womanX, womanY);\n\t\t\tint intersectCount = 0;\n\t\t\tfor(int j=0; j < 3; j++){\n\t\t\t\tLine2D.Double triLine = new Line2D.Double(tri[j][0], tri[j][1], tri[j+1][0], tri[j+1][1]);\n\t\t\t\tboolean result = mAndw.intersectsLine(triLine);\n\t\t\t\tif(result)\n\t\t\t\t\tintersectCount++;\n\t\t\t}\n\t\t\tif((intersectCount & 1) == 0)\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tint n = in.nextInt();\n\t\tfor(int i=0;i<n;i++)new AOJ0143().doIt();\n\t\t\n\t}\n\tclass AOJ0143{\n\t\tvoid doIt(){\n\t\t\tPoint2D ps[] = new Point2D[3];\n\t\t\tfor(int i=0;i<3;i++)ps[i] = new Point2D.Double(in.nextInt(),in.nextInt());;\n\t\t\tPoint2D a = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tPoint2D b = new Point2D.Double(in.nextInt(),in.nextInt());\n\t\t\tint c = contains(ps, a);\n\t\t\tint d = contains(ps, b);\n//\t\t\tSystem.out.println(c+\" \"+d);\n\t\t\tif(c==d)System.out.println(\"NG\");\n\t\t\telse System.out.println(\"OK\");\n\t\t}\n\t\tPoint2D sub(Point2D p1,Point2D p2){\n\t\t\treturn new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n\t\t}\n\t\tdouble cross(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getY()-p1.getY()*p2.getX();\n\t\t}\n\t\tdouble dot(Point2D p1,Point2D p2){\n\t\t\treturn p1.getX()*p2.getX()+p1.getY()*p2.getY();\n\t\t}\n\t\tprivate int contains(Point2D[] plist,Point2D p) {\n\t\t\tboolean isin = false;\n\t\t\tint n = plist.length;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint2D a = sub(plist[i], p);\n\t\t\t\tPoint2D b = sub(plist[(i+1) % n], p);\n\t\t\t\tif(a.getY() > b.getY()){\n\t\t\t\t\tPoint2D temp = (Point2D) a.clone();\n\t\t\t\t\ta = b;\n\t\t\t\t\tb = temp;\n\t\t\t\t}\n\t\t\t\tif(a.getY() <= 0 && 0 < b.getY()){\n\t\t\t\t\tif(cross(a,b) < 0) isin = ! isin;\n\t\t\t\t}\n\t\t\t\tif(cross(a,b) == 0 && dot(a, b) <= 0) return 0;\n\t\t\t}\n\t\t\treturn isin ? 1 : -1;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tstatic class P implements Comparable<P> {\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\treturn x != o.x ? Double.compare(x, o.x) : Double.compare(y, o.y);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t\tpublic double abs() {return sqrt(x * x + y * y); }\n\t\tpublic double abs2() {return (x * x + y * y); }\n\t\tpublic double arg() { return atan2(y, x); } // (-pi 〜 pi)\n\t\tpublic double dist(P o) {return this.sub(o).abs(); }\n\t\tpublic P mul(double k) {return new P(x * k, y * k);}\n\t\tpublic P div(double k) {return new P(x / k, y / k);}\n\t\tpublic P add(P o) {return new P(x + o.x, y + o.y);}\n\t\tpublic P sub(P o) {return new P(x - o.x, y - o.y);}\n\t\tpublic P mul(P o) {return new P(x * o.x - y * o.y,  x * o.y + y * o.x); }\n\t\tpublic P div(P o) {return new P(x * o.x + y * o.y, -x * o.y + y * o.x).div(o.abs2()); }\n\t\tpublic double dot(P o) {return x * o.x + y * o.y;} // a b sin(t)\n\t\tpublic double det(P o) {return x * o.y - y * o.x;} // a b cos(t)\n\t\tpublic P normal() { return this.div(this.abs()); }\n\t\tpublic P rot90() { return new P(-y, x); }\n\t\tpublic static P polar(double d, double rad) {return new P(d * Math.cos(rad), d * Math.sin(rad));}\n\t}\n\n\tint signum(double x) {\n\t\tif (x < 0) return -1;\n\t\tif (x > 0) return +1;\n\t\treturn 0;\n\t}\n\tfinal int OUT = 0;\n\tfinal int IN = 1;\n\tfinal int ON = 2;\n\tint containTP(P a, P b, P c, P p) {\n\t\tb = b.sub(a); c = c.sub(a); p = p.sub(a);\n\t\tdouble det = b.det(c);\n\t\tint sd = signum(det);\n\t\tif (sd == 0) return OUT;\n\t\tdouble s = p.det(c);\n\t\tdouble t = b.det(p);\n\t\tif (sd == -1) {det = -det; s = -s; t = -t;}\n\t\treturn (0 <= s && s <= det && 0 <= t && t <= det && s + t <= det) ? IN : OUT;\n\t}\n\n\tvoid solve() {\n\t\tP[] ps = new P[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tps[i] = new P(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\tP s = new P(sc.nextDouble(), sc.nextDouble());\n\t\tP t = new P(sc.nextDouble(), sc.nextDouble());\n\n\t\tint r1 = containTP(ps[0], ps[1], ps[2], s);\n\t\tint r2 = containTP(ps[0], ps[1], ps[2], t);\n\t\tout.println(r1 != r2 ? \"OK\":\"NG\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsc.nextInt();\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\t//多角形の包含関係\n    int contains(Point2D[] plist,Point2D p){\n   \tboolean isin = false;\n   \tint n = plist.length;\n   \tfor(int i = 0;i < n;i++){\n   \t\tPoint2D a = sub(plist[i],p);\n   \t\tPoint2D b = sub(plist[(i+1) % n ], p);\n   \t\tif(a.getY() > b.getY()){\n   \t\t\tPoint2D temp = (Point2D) a.clone();a = b;\n   \t\t\tb = temp;\n   \t\t}\n   \t\tif(a.getY() <= 0 && 0 < b.getY()){\n   \t\t\tif(cross(a,b) < 0) isin =! isin;\n   \t\t}\n   \t\tif(cross(a,b) == 0 && dot(a,b) <= 0)return 0;\n   \t}\n   \treturn isin ? 1 : -1;\n    }\n    //点と点の差\n    Point2D sub(Point2D p1,Point2D p2){\n   \t return new Point2D.Double(p1.getX()-p2.getX(),p1.getY()-p2.getY());\n    }\n    //内積\n    double dot(Point2D p1,Point2D p2){\n   \t return p1.getX()*p2.getX()+p1.getY()*p2.getY();\n    }\n    //外積\n    double cross(Point2D p1,Point2D p2){\n   \t return p1.getX()*p2.getY()-p1.getY()*p2.getX();\n    }\n\tvoid doIt() { \n\t\tint n = sc.nextInt();\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < 3;i++){\n\t\t\t\tPoint2D xy[] = new Point2D.Double [3];\n\t\t\t\tfor(int j = 0;i < 3;i++){\n\t\t\t\t\txy[i] = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\t}\n\t\t\t\tPoint2D xyk = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\tPoint2D xys = new Point2D.Double(sc.nextDouble(),sc.nextDouble());\n\t\t\t\tif(contains(xy,xyk) == contains(xy,xys)){\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n     }\n    public static void main(String[] args) {\n    \t// TODO Auto-generated method stub\n    \tnew Main().doIt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\tdouble xp1=in.nextDouble(),yp1=in.nextDouble();\n\t\t\tdouble xp2=in.nextDouble(),yp2=in.nextDouble();\n\t\t\tdouble xp3=in.nextDouble(),yp3=in.nextDouble();\n\t\t\tdouble xk=in.nextDouble(),yk=in.nextDouble();//enemy\n\t\t\tdouble xs=in.nextDouble(),ys=in.nextDouble();//me\n\t\t\tint kabe=0;\n\t\t\tif(!(judge(xp1,yp1,xp2,yp2,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp1,yp1,xp2,yp2)>0))//壁と交差する\n\t\t\t\tkabe++;\n\t\t\tif(!(judge(xp2,yp2,xp3,yp3,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp2,yp2,xp3,yp3)>0))\n\t\t\t\tkabe++;\n\t\t\tif(!(judge(xp3,yp3,xp1,yp1,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp3,yp3,xp1,yp1)>0))\n\t\t\t\tkabe++;\n\t\t\tSystem.out.println(kabe==1 ? \"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic double judge(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)\n\t{\n\t\tdouble tc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\tdouble td=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\treturn tc*td;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\t\n\t\twhile((line = in.readLine()) != null){\n\t\t\tint size = Integer.parseInt(line);\n\t\t\tfor(int i=0; i<size; i++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] tmp = line.split(\" \");\n\t\t\t\tint[] pts = new int[tmp.length];\n\t\t\t\tfor(int j=0; j<tmp.length; j++){\n\t\t\t\t\tpts[j] = Integer.parseInt(tmp[j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPoint p1 = new Point(pts[0], pts[1]);\n\t\t\t\tPoint p2 = new Point(pts[2], pts[3]);\n\t\t\t\tPoint p3 = new Point(pts[4], pts[5]);\n\t\t\t\tPoint pk = new Point(pts[6], pts[7]);\n\t\t\t\tPoint ps = new Point(pts[8], pts[9]);\n\t\t\t\tPoint vk1 = new Point(p1.x - pk.x, p1.y - pk.y);\n\t\t\t\tPoint vk2 = new Point(p2.x - pk.x, p2.y - pk.y);\n\t\t\t\tPoint vk3 = new Point(p3.x - pk.x, p3.y - pk.y);\n\t\t\t\tPoint vs1 = new Point(p1.x - ps.x, p1.y - ps.y);\n\t\t\t\tPoint vs2 = new Point(p2.x - ps.x, p2.y - ps.y);\n\t\t\t\tPoint vs3 = new Point(p3.x - ps.x, p3.y - ps.y);\n\t\t\t\tint k12 = Point.outer(vk1, vk2);\n\t\t\t\tint k23 = Point.outer(vk2, vk3);\n\t\t\t\tint k31 = Point.outer(vk3, vk1);\n\t\t\t\tint s12 = Point.outer(vs1, vs2);\n\t\t\t\tint s23 = Point.outer(vs2, vs3);\n\t\t\t\tint s31 = Point.outer(vs3, vs1);\n\t\t\t\t\n\t\t\t\tboolean bk = k12 == k23 && k23 == k31;\n\t\t\t\tboolean bs = s12 == s23 && s23 == s31;\n\t\t\t\tif(bk != bs){\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic static int outer(Point p1, Point p2){\n\t\treturn sign(p1.x * p2.y - p2.x * p1.y);\n\t}\n\t\n\tprivate static int sign(int a){\n\t\tif(a>0) return 1;\n\t\telse if(a==0) return 0;\n\t\telse return -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\tdouble xp1=in.nextDouble(),yp1=in.nextDouble();\n\t\t\tdouble xp2=in.nextDouble(),yp2=in.nextDouble();\n\t\t\tdouble xp3=in.nextDouble(),yp3=in.nextDouble();\n\t\t\tdouble xk=in.nextDouble(),yk=in.nextDouble();//enemy\n\t\t\tdouble xs=in.nextDouble(),ys=in.nextDouble();//me\n\t\t\tint kabe=0;\n\t\t\tif(judge(xp1,yp1,xp2,yp2,xk,yk,xs,ys))//壁と交差する\n\t\t\t\tkabe++;\n\t\t\tif(judge(xp2,yp2,xp3,yp3,xk,yk,xs,ys))\n\t\t\t\tkabe++;\n\t\t\tif(judge(xp3,yp3,xp1,yp1,xk,yk,xs,ys))\n\t\t\t\tkabe++;\n\t\t\tSystem.out.println(kabe==1 ? \"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic boolean judge(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)\n\t{\n\t\tdouble jc1=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\tdouble jd1=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\tdouble jc2=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\tdouble jd2=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\treturn jc1*jd1<0 && jc2*jd2<0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\tdouble xp1=in.nextDouble(),yp1=in.nextDouble();\n\t\t\tdouble xp2=in.nextDouble(),yp2=in.nextDouble();\n\t\t\tdouble xp3=in.nextDouble(),yp3=in.nextDouble();\n\t\t\tdouble xk=in.nextDouble(),yk=in.nextDouble();\n\t\t\tdouble xs=in.nextDouble(),ys=in.nextDouble();\n\t\t\tint k=0;\n\t\t\tif(judge(xp1,yp1,xp2,yp2,xk,yk,xs,ys))//壁と交差する\n\t\t\t\tk++;\n\t\t\tif(judge(xp2,yp2,xp3,yp3,xk,yk,xs,ys))\n\t\t\t\tk++;\n\t\t\tif(judge(xp3,yp3,xp1,yp1,xk,yk,xs,ys))\n\t\t\t\tk++;\n\t\t\tSystem.out.println(kabe==1 ? \"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic boolean judge(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)\n\t{\n\t\tdouble jc1=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\tdouble jd1=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\tdouble jc2=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\tdouble jd2=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\treturn jc1*jd1<0 && jc2*jd2<0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tstatic Pos vector(Pos a1, Pos a2) {\n\t\t\treturn new Pos(a2.x - a1.x, a2.y - a1.y);\n\t\t}\n\n\t\tstatic int check(Pos a, Pos t, Pos x) {\n\t\t\tint cross1 = a.x * t.y - a.y * t.x;\n\t\t\tint cross2 = a.x * x.y - a.y * x.x;\n\n\t\t\treturn cross1 * cross2;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos p[] = new Pos[3];\n\t\tPos x[] = new Pos[2];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tp[j] = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tx[j] = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\n\t\t\tboolean flag[] = {true, true};\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\tPos v1 = Pos.vector(p[k], p[(k + 1) % 3]);\n\t\t\t\t\tPos v2 = Pos.vector(p[k], p[(k + 2) % 3]);\n\t\t\t\t\tPos v3 = Pos.vector(p[k], x[j]);\n\t\t\t\t\tif (Pos.check(v1, v2, v3) <= 0) {\n\t\t\t\t\t\tflag[j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (flag[0] != flag[1]) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while (n-- > 0) {\n            double[] l = new double[10];\n            for (int i = 0; i < 10; i++) {\n                l[i] = sc.nextDouble();\n            }\n            int[] count = new int[3];\n            for (int i = 0; i < 4; i += 2) {\n                for (int j = 0; j < 6; j += 2) {\n                    if (ex(l[6 + i], l[7 + i], l[j], l[j + 1], l[(j + 2) % 6], l[(j + 3) % 6]) > 0) {\n                        count[i / 2]++;\n                    }\n                }\n                if (count[i / 2] % 3 == 0) {\n                    count[2]++;\n                }\n            }\n            System.out.println(count[2] == 1 ? \"OK\" : \"NG\");\n        }\n    }\n\n    static double ex(double... l) {\n        return (l[2] - l[0]) * (l[5] - l[1]) - (l[4] - l[0]) * (l[3] - l[1]);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tdouble x, y;\n\n\t\tPos(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tstatic Pos vector(Pos a, Pos b) {\n\t\t\treturn new Pos(b.x - a.x, b.y - a.y);\n\t\t}\n\n\t\tstatic double cross(Pos a, Pos b) {\n\t\t\treturn a.x * b.y - a.y * b.x;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos p[] = new Pos[3];\n\t\tPos x;\n\t\tPos y;\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tp[j] = new Pos(sc.nextDouble(), sc.nextDouble());\n\t\t\t}\n\t\t\tx = new Pos(sc.nextDouble(), sc.nextDouble());\n\t\t\ty = new Pos(sc.nextDouble(), sc.nextDouble());\n\n\t\t\tboolean in1 = true;\n\t\t\tboolean in2 = true;\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tPos v1 = Pos.vector(p[j], p[(j + 1) % 3]);\n\t\t\t\tPos v2 = Pos.vector(p[j], p[(j + 2) % 3]);\n\t\t\t\tPos v3 = Pos.vector(p[j], x);\n\t\t\t\tdouble cross1 = Pos.cross(v1, v2);\n\t\t\t\tdouble cross2 = Pos.cross(v1, v3);\n\t\t\t\tif (cross1 * cross2 <= 0.0) {\n\t\t\t\t\tin1 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tPos v1 = Pos.vector(p[j], p[(j + 1) % 3]);\n\t\t\t\tPos v2 = Pos.vector(p[j], p[(j + 2) % 3]);\n\t\t\t\tPos v3 = Pos.vector(p[j], y);\n\t\t\t\tdouble cross1 = Pos.cross(v1, v2);\n\t\t\t\tdouble cross2 = Pos.cross(v1, v3);\n\t\t\t\tif (cross1 * cross2 <= 0) {\n\t\t\t\t\tin2 = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (in1 != in2) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Pos {\n\t\tint x, y;\n\n\t\tPos(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tstatic Pos vector(Pos a1, Pos a2) {\n\t\t\treturn new Pos(a2.x - a1.x, a2.y - a1.y);\n\t\t}\n\n\t\tstatic int cross(Pos a, Pos b) {\n\t\t\treturn a.x * b.y - a.y * b.x;\n\t\t}\n\n\t\tstatic int check(Pos a, Pos t, Pos x) {\n\t\t\tint cross1 = cross(a, t);\n\t\t\tint cross2 = cross(a, x);\n\n\t\t\treturn cross1 * cross2;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tPos p[] = new Pos[3];\n\t\tPos x;\n\t\tPos y;\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tp[j] = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\t}\n\t\t\tx = new Pos(sc.nextInt(), sc.nextInt());\n\t\t\ty = new Pos(sc.nextInt(), sc.nextInt());\n\n\t\t\tboolean in1 = true;\n\t\t\tboolean in2 = true;\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tPos v1 = Pos.vector(p[j], p[(j + 1) % 3]);\n\t\t\t\tPos v2 = Pos.vector(p[j], p[(j + 2) % 3]);\n\t\t\t\tPos v3 = Pos.vector(p[j], x);\n\t\t\t\tPos v4 = Pos.vector(p[j], y);\n\t\t\t\tif (Pos.check(v1, v2, v3) <= 0) {\n\t\t\t\t\tin1 = false;\n\t\t\t\t}\n\t\t\t\tif (Pos.check(v1, v2, v4) <= 0) {\n\t\t\t\t\tin2 = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (in1 != in2) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic double sign(Point a, Point b, Point c){\n\t//\twriter.println((a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x));\n\t\treturn Math.signum((a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x));\n\t}\n\tpublic String judge(Triangle tr, Point p, Point q){\n\t\tdouble x = Math.abs(sign(tr.a, tr.b, p) + sign(tr.b, tr.c, p) + sign(tr.c, tr.a, p));\n\t\tdouble y = Math.abs(sign(tr.a, tr.b, q) + sign(tr.b, tr.c, q) + sign(tr.c, tr.a, q));\n\t\treturn (x != y) ? \"OK\" : \"NG\";\n\t}\t\t\n\tpublic  void solve() throws IOException{\n\t\tint n = nextInt();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt(), t = nextInt(), u = nextInt();\n\t\t\tTriangle tr = new Triangle(p, q, r, s, t, u);\n\t\t\tint a = nextInt(), b = nextInt();\n\t\t\tPoint alt = new Point(a, b);\n\t\t\tint c = nextInt(), d = nextInt();\n\t\t\tPoint vega = new Point(c, d);\n\t\t\twriter.println(judge(tr, alt, vega));\n\t\t}\n\t\twriter.flush();\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Point {\n\tint x;\n\tint y;\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Triangle {\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tpublic Triangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\tdouble xp1=in.nextDouble(),yp1=in.nextDouble();\n\t\t\tdouble xp2=in.nextDouble(),yp2=in.nextDouble();\n\t\t\tdouble xp3=in.nextDouble(),yp3=in.nextDouble();\n\t\t\tdouble xk=in.nextDouble(),yk=in.nextDouble();//enemy\n\t\t\tdouble xs=in.nextDouble(),ys=in.nextDouble();//me\n\t\t\tint kabe=0;\n\t\t\t\n\t\t\tif(judge(xp1,yp1,xp2,yp2,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp1,yp1,xp2,yp2)>0)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tkabe++;\n\t\t\tif(judge(xp2,yp2,xp3,yp3,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp2,yp2,xp3,yp3)>0)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tkabe++;\n\t\t\tif(judge(xp3,yp3,xp1,yp1,xk,yk,xs,ys)>0||judge(xk,yk,xs,ys,xp3,yp3,xp1,yp1)>0)\n\t\t\t\t;\n\t\t\telse\n\t\t\t\tkabe++;\n\t\t\tSystem.out.println(kabe==1 ? \"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic double judge(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)\n\t{\n\t\tdouble tc=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\tdouble td=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\treturn tc*td;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\tdouble xp1=in.nextDouble(),yp1=in.nextDouble();\n\t\t\tdouble xp2=in.nextDouble(),yp2=in.nextDouble();\n\t\t\tdouble xp3=in.nextDouble(),yp3=in.nextDouble();\n\t\t\tdouble xk=in.nextDouble(),yk=in.nextDouble();\n\t\t\tdouble xs=in.nextDouble(),ys=in.nextDouble();\n\t\t\tint k=0;\n\t\t\tif(judge(xp1,yp1,xp2,yp2,xk,yk,xs,ys))//壁と交差する\n\t\t\t\tk++;\n\t\t\tif(judge(xp2,yp2,xp3,yp3,xk,yk,xs,ys))\n\t\t\t\tk++;\n\t\t\tif(judge(xp3,yp3,xp1,yp1,xk,yk,xs,ys))\n\t\t\t\tk++;\n\t\t\tSystem.out.println(k==1 ? \"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic boolean judge(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)\n\t{\n\t\tdouble jc1=(x1-x2)*(y3-y1)+(y1-y2)*(x1-x3);\n\t\tdouble jd1=(x1-x2)*(y4-y1)+(y1-y2)*(x1-x4);\n\t\tdouble jc2=(x3-x4)*(y1-y3)+(y3-y4)*(x3-x1);\n\t\tdouble jd2=(x3-x4)*(y2-y3)+(y3-y4)*(x3-x2);\n\t\treturn jc1*jd1<0 && jc2*jd2<0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tVector2D A = new Vector2D(sc.nextInt(),sc.nextInt());\n\t\t\tVector2D B = new Vector2D(sc.nextInt(),sc.nextInt());\n\t\t\tVector2D C = new Vector2D(sc.nextInt(),sc.nextInt());\n\t\t\tVector2D K = new Vector2D(sc.nextInt(),sc.nextInt());\n\t\t\tVector2D S = new Vector2D(sc.nextInt(),sc.nextInt());\n\t\t\tboolean KB = hittestPointPolygon2D(A, B, C, K);\n\t\t\tboolean SB = hittestPointPolygon2D(A, B, C, S);\n\t\t\tboolean ans = false;\n\t\t\tif(KB && SB) {\n\t\t\t\tans = false;\n\t\t\t}\n\t\t\telse if(KB || SB) {\n\t\t\t\tans = true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println((ans)?\"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic class Vector2D {\n\t\tint x;\n\t\tint y;\n\t\tVector2D(int a, int b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\t\tVector2D() {\n\t\t\tx = 0;\n\t\t\ty = 0;\n\t\t}\n\t}\n\t\n\tstatic Vector2D sub_vector(Vector2D a, Vector2D b) {\n\t\tVector2D ret = new Vector2D();\n\t\tret.x = a.x - b.x;\n\t\tret.y = a.y - b.y;\n\t\treturn ret;\n\t}\n\t\n\tstatic boolean hittestPointPolygon2D(Vector2D A, Vector2D B, Vector2D C, Vector2D P) {\n\t\tVector2D AB = sub_vector(B, A);\n\t    Vector2D BP = sub_vector(P, B);\n\n\t    Vector2D BC = sub_vector(C, B);\n\t    Vector2D CP = sub_vector(P, C);\n\n\t    Vector2D CA = sub_vector(A, C);\n\t    Vector2D AP = sub_vector(P, A);\n\n\t    int c1 = AB.x * BP.y - AB.y * BP.x;\n\t    int c2 = BC.x * CP.y - BC.y * CP.x;\n\t    int c3 = CA.x * AP.y - CA.y * AP.x;\n\n\t    if( ( c1 > 0 && c2 > 0 && c3 > 0 ) || ( c1 < 0 && c2 < 0 && c3 < 0 ) ) {\n\t        return true;\n\t    }\n\n\t    return false;\n\t}\n\t\n\t\n\t\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            long[] x = new long[3];\n            long[] y = new long[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = long.Parse(st[i * 2]);\n                y[i] = long.Parse(st[i * 2 + 1]);\n            }\n\n            long[] tx = new long[2];\n            long[] ty = new long[2];\n            tx[0] = long.Parse(st[3 * 2]);\n            ty[0] = long.Parse(st[3 * 2 + 1]);\n            tx[1] = long.Parse(st[4 * 2]);\n            ty[1] = long.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    long x1 = x[i] - tx[j];\n                    long x2 = x[(i + 1) % 3] - tx[j];\n                    long y1 = y[i] - ty[j];\n                    long y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            Console.WriteLine(flag[0] + \" \" + flag[1]);\n            long r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib;\n\nnamespace _0143\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            for (int k = 0 ; k < n ; k++)\n            {\n                double[] items = ReadDoubleAr();\n                Vector a = new Vector(items[0], items[1]);\n                Vector b = new Vector(items[2], items[3]);\n                Vector c = new Vector(items[4], items[5]);\n                Vector pk = new Vector(items[6], items[7]);\n                Vector ps = new Vector(items[8], items[9]);\n\n                double ck1 = Vector.CrossProduct(b - a, pk - b);\n                double ck2 = Vector.CrossProduct(c - b, pk - c);\n                double ck3 = Vector.CrossProduct(a - c, pk - a);\n\n                double cs1 = Vector.CrossProduct(b - a, ps - b);\n                double cs2 = Vector.CrossProduct(c - b, ps - c);\n                double cs3 = Vector.CrossProduct(a - c, ps - a);\n\n                bool isInnerK;\n                bool isInnerS;\n\n                isInnerK = ((ck1 > 0 && ck2 > 0 && ck3 > 0) || (ck1 < 0 && ck2 < 0 && ck3 < 0)) ? true : false;\n                isInnerS = ((cs1 > 0 && cs2 > 0 && cs3 > 0) || (cs1 < 0 && cs2 < 0 && cs3 < 0)) ? true : false;\n\n                Console.WriteLine(isInnerK ^ isInnerS ? \"OK\" : \"NG\");\n\n            }\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n        static string WriteAr(int[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(double[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n        static string WriteAr(long[] array, string sep = \" \") { return String.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n    }\n\n}\n\nnamespace CompProgLib\n{\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            while (n-- > 0)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n                Point c = new Point(input[4], input[5]);\n                Point k = new Point(input[6], input[7]);\n                Point s = new Point(input[8], input[9]);\n\n                if (CheckPoint(a, b, c, k) ^ CheckPoint(a, b, c, s)) sb.AppendLine(\"OK\");\n                else sb.AppendLine(\"NG\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool CheckPoint(Point a, Point b, Point c, Point p)\n        {\n            double v1 = (b - a).Cross(p - b);\n            double v2 = (c - b).Cross(p - c);\n            double v3 = (a - c).Cross(p - a);\n\n            if (v1 > 0 && v2 > 0 && v3 > 0) return true;\n            if (v1 < 0 && v2 < 0 && v3 < 0) return true;\n            return false;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            int[] x = new int[3];\n            int[] y = new int[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = int.Parse(st[i * 2]);\n                y[i] = int.Parse(st[i * 2 + 1]);\n            }\n\n            int[] tx = new int[2];\n            int[] ty = new int[2];\n            tx[0] = int.Parse(st[3 * 2]);\n            ty[0] = int.Parse(st[3 * 2 + 1]);\n            tx[1] = int.Parse(st[4 * 2]);\n            ty[1] = int.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    int x1 = x[i] - tx[j];\n                    int x2 = x[(i + 1) % 3] - tx[j];\n                    int y1 = y[i] - ty[j];\n                    int y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            //Console.WriteLine(flag[0] + \" \" + flag[1]);\n            int r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            int n = int.Parse(Console.ReadLine());\n\n            while (n-- > 0)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point a = new Point(input[0], input[1]);\n                Point b = new Point(input[2], input[3]);\n                Point c = new Point(input[4], input[5]);\n                Point k = new Point(input[6], input[7]);\n                Point s = new Point(input[8], input[9]);\n\n                if (CheckPoint(a, b, c, k) ^ CheckPoint(a, b, c, s)) sb.AppendLine(\"OK\");\n                else sb.AppendLine(\"NG\");\n            }\n            Console.Write(sb);\n        }\n\n        static bool CheckPoint(Point a, Point b, Point c, Point p)\n        {\n            double v1 = (b - a).Cross(p - b);\n            double v2 = (c - b).Cross(p - c);\n            double v3 = (a - c).Cross(p - a);\n\n            if (v1 > 0 && v2 > 0 && v3 > 0) return true;\n            if (v1 < 0 && v2 < 0 && v3 < 0) return true;\n            return false;\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    int N;\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            int[] x = new int[3];\n            int[] y = new int[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = int.Parse(st[i * 2]);\n                y[i] = int.Parse(st[i * 2 + 1]);\n            }\n\n            int[] tx = new int[2];\n            int[] ty = new int[2];\n            tx[0] = int.Parse(st[3 * 2]);\n            ty[0] = int.Parse(st[3 * 2 + 1]);\n            tx[1] = int.Parse(st[4 * 2]);\n            ty[1] = int.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    int x1 = x[i] - tx[j];\n                    int x2 = x[(i + 1) % 3] - tx[j];\n                    int y1 = y[i] - ty[j];\n                    int y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            Console.WriteLine(flag[0] + \" \" + flag[1]);\n            int r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n\n    int getnum(int a)\n    {\n        a %= N;\n        if (a < 0) a += N;\n        return Math.Min(a, N - a);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            int[] x = new int[3];\n            int[] y = new int[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = int.Parse(st[i * 2]);\n                y[i] = int.Parse(st[i * 2 + 1]);\n            }\n\n            int[] tx = new int[2];\n            int[] ty = new int[2];\n            tx[0] = int.Parse(st[3 * 2]);\n            ty[0] = int.Parse(st[3 * 2 + 1]);\n            tx[1] = int.Parse(st[4 * 2]);\n            ty[1] = int.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    int x1 = x[i] - tx[j];\n                    int x2 = x[(i + 1) % 3] - tx[j];\n                    int y1 = y[i] - ty[j];\n                    int y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            Console.WriteLine(flag[0] + \" \" + flag[1]);\n            int r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            int[] x = new int[3];\n            int[] y = new int[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = int.Parse(st[i * 2]);\n                y[i] = int.Parse(st[i * 2 + 1]);\n            }\n\n            int[] tx = new int[2];\n            int[] ty = new int[2];\n            tx[0] = int.Parse(st[3 * 2]);\n            ty[0] = int.Parse(st[3 * 2 + 1]);\n            tx[1] = int.Parse(st[4 * 2]);\n            ty[1] = int.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    int x1 = x[i] - tx[j];\n                    int x2 = x[(i + 1) % 3] - tx[j];\n                    int y1 = y[i] - ty[j];\n                    int y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            Console.WriteLine(flag[0] + \" \" + flag[1]);\n            int r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n\n    int getnum(int a)\n    {\n        a %= N;\n        if (a < 0) a += N;\n        return Math.Min(a, N - a);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n    void run()\n    {\n        int T = int.Parse(Console.ReadLine());\n        for (int test = 0; test < T; test++)\n        {\n            string[] st = Console.ReadLine().Split(' ');\n            long[] x = new long[3];\n            long[] y = new long[3];\n            for (int i = 0; i < 3; i++)\n            {\n                x[i] = long.Parse(st[i * 2]);\n                y[i] = long.Parse(st[i * 2 + 1]);\n            }\n\n            long[] tx = new long[2];\n            long[] ty = new long[2];\n            tx[0] = long.Parse(st[3 * 2]);\n            ty[0] = long.Parse(st[3 * 2 + 1]);\n            tx[1] = long.Parse(st[4 * 2]);\n            ty[1] = long.Parse(st[4 * 2 + 1]);\n\n            int[] flag = new int[2];\n            for (int i = 0; i < 3; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    long x1 = x[i] - tx[j];\n                    long x2 = x[(i + 1) % 3] - tx[j];\n                    long y1 = y[i] - ty[j];\n                    long y2 = y[(i + 1) % 3] - ty[j];\n                    if (x1 * y2 > x2 * y1) flag[j] |= 1 << i;\n                }\n            }\n\n            long r = 0;\n            for (int j = 0; j < 2; j++)\n            {\n                if (flag[j] % 7 == 0) r++;\n            }\n            if (r % 2 == 0) Console.WriteLine(\"NG\");\n            else Console.WriteLine(\"OK\");\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "// const\nvar COUNTER_CLOCKWISE = 1;\nvar CLOCKWISE = - 1;\nvar ONLINE_BACK = 2;\nvar ONLINE_FRONT =  -2;\nvar ON_SEGMENT = 0;\n\n// Vector2d\nvar Vector2D = class Vector2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nVector2D.prototype.Init = function(x,y){\n\tthis.x = x;\n\tthis.y = y;\n}\n\n/*\n * v: Vector2D\n */\nfunction rotateVector90(v){\n\tvar r = new Vector2D();\n\tr.x = -v.y;\n\tr.y = v.x;\n\treturn r;\n}\n\n/*\n * get degree to radian return radian\n */\nfunction getDegreeToRadian(degree){\n\tvar pi = 3.14159265358979323846;\n\treturn degree * pi / 180;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVector(vec,degree){\n\tvar radian = getDegreeToRadian(degree);\n\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\n/*\n * vec:Vector2D return Vector2D\n */\nfunction getRotateVectorFromRad(vec,radian){\n\tvar sin = Math.sin(radian);\n\tvar cos = Math.cos(radian);\n\n\tvar r = new Vector2D();\n\tr.x = vec.x * cos - vec.y * sin;\n\tr.y = vec.x * sin + vec.y * cos;\n\n\treturn r;\n}\n\nfunction isEqualVectors(a,b){\n\treturn equalFloats(a.x - b.x,0) && equalFloats(a.y - b.y,0);\n}\n\n/**\n * vec:Vector2D\n * \n * return unitVector\n */\nfunction getUnitVector(vec){\n\tvar length = getVectorLength2D(vec);\n\tif(length > 0){\n\t\treturn getDivideVector(vec,length);\n\t}\n\treturn vec;\n}\n\n/**\n * return vector length\n * \n * vec:Vector2D\n */\nfunction getVectorLength2D(vec){\n\treturn Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n}\n\nfunction getNorm(vec){\n\treturn vec.x * vec.x + vec.y * vec.y;\n}\n\nfunction getDivideVector(vec2D,length){\n    var vec = new Vector2D();\n\tvec.x = vec2D.x / length;\n\tvec.y = vec2D.y / length;\n\treturn vec;\n}\n\nfunction equalFloats(a,b){\n\tvar threshold = 1 / 8192;\n\treturn Math.abs(a - b) < threshold;\n}\n\nfunction isParallelVector(vectorA,vectorB){\n\tvar na = rotateVector90(vectorA);\n\treturn equalFloats(0,dotProduct2D(na,vectorB));\n}\n\nfunction isVerticalVector(vectorA,vectorB){\n\treturn equalFloats(0,dotProduct2D(vectorA,vectorB));\n}\n\nfunction subtractVector(vecA,vecB){\n\tvar vec = new Vector2D();\n\tvec.x = vecA.x - vecB.x;\n\tvec.y = vecA.y - vecB.y;\n\treturn vec;\n}\n\nfunction dotProduct2D(vecA,vecB){\n    var dot = vecA.x * vecB.x + vecA.y * vecB.y;\n\treturn vecA.x * vecB.x + vecA.y * vecB.y;\n}\n\n/**\n * 外積\n * \n * @param vecA\n * @param vecB\n * @returns\n */\nfunction getCross(vecA,vecB){\n\treturn vecA.x * vecB.y - vecA.y * vecB.x;\n}\n\n/**\n * line segment\n * \n * point1:Vector2D point2:Vector2D\n */\nvar LineSegment2D = class LineSegment2D {\n\tconstructor(point1,point2){\n\t\tthis.point1 = point1;\n\t\tthis.point2 = point2;\n\t}\n}\n\nLineSegment2D.prototype.Init = function(point1,point2){\n\tthis.point1 = point1;\n\tthis.point2 = point2;\n}\n\nfunction onOneSide(axis,segment){\n\tvar d1 = new Vector2D();\n\td1 = subtractVector(segment.point1,axis.base);\n\n\tvar d2 = new Vector2D();\n\td2 = subtractVector(segment.point2,axis.base);\n\n\tvar n = new Vector2D();\n\tn = rotateVector90(axis.direction);\n\n\t// 同じ方向だということを返す\n\treturn dotProduct2D(n,d1) * dotProduct2D(n,d2) > 0;\n}\n\nfunction overLapping(minA,maxA,minB,maxB){\n\treturn minB <= maxA && minA <= maxB;\n}\n\nfunction isSegmentsCollide(segment1,segment2){\n\t// 線分の方向をチェックするためのベクトル\n\tvar axisA = new Line();\n\tvar axisB = new Line();\n\n\t// 線分1のベクトルに対して、線分2が片側にあるかチェック\n\taxisA.base = segment1.point1;\n\taxisA.direction = subtractVector(segment1.point2,segment1.point1);\n\n\tif(onOneSide(axisA,segment2)){\n\t\treturn false;\n\t}\n\n\t// 同じく\n\taxisB.base = segment2.point1;\n\taxisB.direction = subtractVector(segment2.point2,segment2.point1);\n\n\tif(onOneSide(axisB,segment1)){\n\t\treturn false;\n\t}\n\n\t// 同じベクトルをもつケース\n\tif(isParallelVector(axisA.direction,axisB.direction)){\n\t\tvar rangeA = getProjectSegment(segment1,axisA.direction);\n\t\tvar rangeB = getProjectSegment(segment2,axisA.direction);\n\n\t\t// 重なっているか\n\t\treturn isOverLappingRanges(rangeA,rangeB);\n\t}\n\telse{\n\t\treturn true;\n\t}\n}\n\n/*\n * Line Object\n */\nfunction Line(){\n\t// vector2D\n\tthis.base;\n\t// vector2D\n\tthis.direction\n}\n\nLine.prototype.Init = function(base,direction,color){\n\tthis.base = base;\n\tthis.direction = direction;\n}\n\n/**\n * Range\n */\nvar Range = class Range {\n\tconstructor(min,max){\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t}\n}\n\nfunction getMaxMinRange(range1,range2){\n\tvar range = new Range();\n\trange.min = range1.min < range2.min ? range1.min : range2.min;\n\trange.max = range1.max < range2.max ? range2.max : range1.max;\n\treturn range;\n}\n\nfunction getSortRange(range){\n\tvar sorted = new Range(range.min,range.max);\n\tif(range.min > range.max){\n\t\tsorted.min = range.max;\n\t\tsorted.max = range.min;\n\t}\n\treturn sorted;\n}\n\nfunction getNegateVector(vector){\n\tvector.x = -vector.x;\n\tvector.y = -vector.y;\n\treturn vector;\n}\n\nfunction addVector(vecA,vecB){\n\treturn new Vector2D(vecA.x + vecB.x,vecA.y + vecB.y);\n}\n\n/**\n * segment:segment onto:Vector2D\n * \n * return Range\n */\nfunction getProjectSegment(segment,onto){\n\tvar ontoUnitVec = getUnitVector(onto);\n\n\tvar range = new Range();\n\trange.min = dotProduct2D(ontoUnitVec,segment.point1);\n\trange.max = dotProduct2D(ontoUnitVec,segment.point2);\n\n\trange = getSortRange(range);\n\treturn range;\n}\n\nfunction isOverLappingRanges(range1,range2){\n\treturn overLapping(range1.min,range1.max,range2.min,range2.max);\n}\n\nfunction projectVector(project,onto){\n\tvar d = dotProduct2D(onto,onto);\n\tif(0 < d){\n\t    var dp = dotProduct2D(project,onto);\n\t    return multiplyVector(onto,dp / d);\n\t}\n\treturn onto;\n}\n\n/**\n * point class\n */\nvar Point2D = class Point2D {\n\tconstructor(x,y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n}\n\nfunction addPoint(point1,point2){\n\treturn new Point2D(point1.x + point2.x,point1.y + point2.y);\n}\n\nfunction subtractPoint(point1,point2){\n\treturn new Point2D(point1.x - point2.x,point1.y - point2.y);\n}\n\nfunction multiplyPoint(point,scalar){\n\treturn new Point2D(point.x * scalar,point.y * scalar);\n}\n\n/**\n * segment : LineSegment2D\n * point : Point\n */\nfunction getProjectPoint(segment,point){\n\tvar vec1 = new Vector2D(segment.point2.x - segment.point1.x,segment.point2.y - segment.point1.y);\n\tvar vec2 = new Vector2D(point.x - segment.point1.x,point.y - segment.point1.y);\n\tvar rate = dotProduct2D(vec2,vec1) / getNorm(vec1);\n\tvar vec3 = multiplyVector(vec1,rate);\n\tvar project = new Point2D(segment.point1.x + vec3.x,segment.point1.y + vec3.y);\n\treturn project; \n}\n\nfunction getReflectionPoint(segment,point){\n\tvar projection = getProjectPoint(segment,point);\n\t// pから射影点までのベクトル\n\tvar vec = subtractPoint(projection,point);\n\t// 2倍したものが射影点になる\n\tvar refrectionPoint = multiplyPoint(vec,2);\n\t// 始点を足す\n\treturn addPoint(refrectionPoint,point);\n}\n\n/**\n * \n * @param segment1\n * @param segment2\n * @returns point\n */\nfunction getCrossPoint(segment1,segment2){\n\t// 基準となる線を決める\n\tvar baseVector = new Vector2D(segment2.point2.x - segment2.point1.x,segment2.point2.y - segment2.point1.y);\n\tvar d1Vec = new Vector2D(segment1.point1.x - segment2.point1.x,segment1.point1.y - segment2.point1.y);\n\tvar d2Vec = new Vector2D(segment1.point2.x - segment2.point1.x,segment1.point2.y - segment2.point1.y);\n\tvar d1 = Math.abs(getCross(baseVector,d1Vec));\n\tvar d2 = Math.abs(getCross(baseVector,d2Vec));\n\tvar t = d1 / (d1 + d2);\n\tvar x = segment1.point1.x + (segment1.point2.x - segment1.point1.x) * t;\n\tvar y = segment1.point1.y + (segment1.point2.y - segment1.point1.y) * t;\n\treturn new Point2D(x,y);\n}\n\nfunction multiplyVector(vec,scalar){\n\tvar temp = new Vector2D();\n\ttemp.x = vec.x * scalar;\n\ttemp.y = vec.y * scalar;\n\treturn temp;\n}\n\nfunction clampOnRange(x,min,max){\n\tif(x < min){\n\t\treturn min;\n\t}else if(x > max){\n\t\treturn max;\n\t}else{\n\t\treturn x;\n\t}\n}\n\n/**\n * 直線と点との距離\n */\nfunction getDistanceLinePoint(line,point){\n\tvar vec1 = new Vector2D(line.point2.x - line.point1.x,line.point2.y - line.point1.y);\n\tvar vec2 = new Vector2D(point.x - line.point1.x,point.y - line.point1.y);\n\treturn Math.abs(getCross(vec1,vec2) / getVectorLength2D(vec1)); \n}\n\n/**\n * 線分と点との距離を求める\n */\nfunction getDistanceSegmentPoint(segment,point){    \n\t// ベクトルp2 - p1とベクトルp - p1がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p1の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point2,segment.point1),subtractPoint(point,segment.point1)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point1));\n\t}\n\t// ベクトルp1 - p2とベクトルp - p2がなす角θが90どより大きい場合(-90より小さい場合)\n\t// dは点pと点p2の距離になる\n\tif(dotProduct2D(subtractPoint(segment.point1,segment.point2),subtractPoint(point,segment.point2)) < 0){\n\t\treturn getVectorLength2D(subtractPoint(point,segment.point2));\n\t}\n\t// それ以外はdは点pと直線p1p2の距離になる\n\treturn getDistanceLinePoint(segment,point);\n}\n\n/**\n * 線分と線分との距離を求める\n */\nfunction getSegmentDistance(segment1,segment2){\n\t// 交差していた場合距離は0になる\n\tif(isSegmentsCollide(segment1,segment2)){\n\t\treturn 0;\n\t}\n\treturn Math.min(Math.min(getDistanceSegmentPoint(segment1,segment2.point1),getDistanceSegmentPoint(segment1,segment2.point2)),\n\t\t\tMath.min(getDistanceSegmentPoint(segment2,segment1.point1),getDistanceSegmentPoint(segment2,segment1.point2)));\n}\n\nfunction ccw(point1,point2,point3){\n    var vec1 = new Vector2D(point2.x - point1.x,point2.y - point1.y);\n    var vec2 = new Vector2D(point3.x - point1.x,point3.y - point1.y);\n    var cross = getCross(vec1,vec2);\n\n    if(cross > Number.EPSILON){\n        return COUNTER_CLOCKWISE;\n    }\n    if(cross < -Number.EPSILON){\n        return CLOCKWISE;\n    }\n    if(dotProduct2D(vec1,vec2) < -Number.EPSILON){\n        return ONLINE_BACK;\n    }\n    if(getVectorLength2D(vec1) < getVectorLength2D(vec2)){\n        return ONLINE_FRONT;\n    }\n    return ON_SEGMENT;\n}\n\n/**\n * アンドリューでconvex hollを返す \n*/\nfunction getConvexHoll(points){\n    if(points.length < 3){\n        return points;\n    }\n    \n    // xを基準に昇順にソート、数値が同じものはyが小さいもの基準にソート \n    points.sort((a, b) => (a.x > b.x) ? 1 : (a.x == b.x) ? ((a.y > b.y) ? 1 : -1) : -1);\n    // xを小さいほうから2つ\n    var u = [];\n    u.push(points[0]);\n    u.push(points[1]);\n    // xを大きい方から2つ\n    var l = [];\n    l.push(points[points.length - 1]);\n    l.push(points[points.length - 2]);\n    \n    // 上部の生成\n    for(var i = 2;i < points.length;++i){\n    \t// 対象が半時計なら削除する\n        for(var j = u.length;j >= 2 && ccw(u[j - 2],u[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            u.pop();\n        }\n        u.push(points[i]);\n    }\n    // 下部の生成\n    for(var i = points.length - 3;i >= 0;--i){\n    \t// 対象が半時計なら削除する\n        for(var j = l.length;j >= 2 && ccw(l[j - 2],l[j - 1],points[i]) == COUNTER_CLOCKWISE;--j){\n            l.pop();;\n        }\n        l.push(points[i]);\n    }\n    // 時計回りに凸包の点の列を生成\n    l.reverse();\n    for(var i = u.length - 2;i >= 1;--i){\n        l.push(u[i]);\n    }\n    return l;\n}\n\nfunction getConvexDiameter(points){\n\t// 対心点(p,q)を取る(y軸で最小・最大のもの)\n    var is = 0;\n    var js = 0;\n    for(var i = 1; i < points.length; i++){\n      if(points[i].y > points[is].y) is = i;\n      if(points[i].y < points[js].y) js = i;\n    }\n    var distance = getNorm(subtractVector(points[is],points[js]));\n    var maxi = is,i = js,maxj = js,j = js;\n    do {\n        // 対心点の中で最長距離のものを探す\n      if(getCross(subtractVector(points[(i + 1) % points.length],points[i]),subtractVector(points[(j + 1) % points.length],points[j])) >= 0){\n        j = (j + 1) % points.length;\n      } else {\n        i = (i + 1) % points.length;\n      }\n      if(getNorm(subtractVector(points[i],points[j])) > distance){\n        distance = getNorm(subtractVector(points[i],points[j]));\n        maxi = i;\n        maxj = j;\n      }\n    }  while (i != is || j != js);\n    return distance;\n}\n\n/**\n * 点で構成される多角形の2d面積を返す\n * \n */\nfunction getArea(points){\n    var area = 0;\n    for(var i = 0;i < points.length;++i){\n        area += getCross(points[i],points[(i + 1) % points.length]);\n    }\n    return area / 2;\n}\n\nfunction getConvexCut(points,point1,point2){\n    // 切り取られた多角形\n    var convex = [];\n    \n\tfor(var i = 0; i < points.length;++i){\n\t\tvar nowPoint = points[i];\n\t\tvar nextPoint = points[(i + 1) % points.length];\n\t\tvar nowPointCcw = ccw(point1,point2,nowPoint);\n\t\tif(nowPointCcw != CLOCKWISE){\n\t\t    convex.push(nowPoint);\n\t\t}\n\t\tif(nowPointCcw * ccw(point1,point2,nextPoint) == CLOCKWISE){\n\t\t    // 交点を求める\n\t\t  var crossPoint = getCrossPointFromPoints(point1,point2,nowPoint,nextPoint);\n\t\t  convex.push(crossPoint);\n\t\t}\n\t}\n\treturn convex;\n}\n\nfunction getPointDistance(point1,point2){\n\tvar x = point1.x - point2.x;\n\tvar y = point1.y - point2.y;\n\treturn Math.sqrt(x * x + y * y);\n}\n\nfunction closestPair(points,n){\n\tif (n == 1)  return Number.MAX_SAFE_INTEGER;\n\tvar d = Number.MAX_SAFE_INTEGER;\n\tvar m = Math.floor(n / 2);\n\td = Math.min(closestPair(points, m),closestPair(points.slice(m),n - m));\n    var mx = points[m].x;\n\tvar arr = [];\n    \n\tfor (var i = m;i >= 0;--i){\n\t    var x = Math.abs(points[i].x - mx);\n\t\tif (x > d){\n\t\t    break;\n\t\t}\n\t\telse{\n\t\t    arr.push(points[i]);\n\t\t}\n\t}\n\tfor (var i = m + 1; i < n; ++i){\n\t\tif (Math.abs(points[i].x - mx) > d){\n\t\t    break;\n\t\t}\t\n\t\telse{\n            arr.push(points[i]);  \n\t\t} \n\t}\n\tarr.sort((a, b) => (a.y > b.y) ? 1 : -1);\n\n\tfor(var i = 0;i < arr.length;++i){\n\t\tfor (var j = i + 1;j < arr.length && Math.abs(arr[j].y - arr[i].y) < d;++j){\n\t\t    var tmp = getPointDistance(arr[i],arr[j]);\n\t\t\tif (tmp < d) d = tmp;\n\t\t}\n\t}\n\treturn d;\n}\n\n/**\n * 2d円を表すクラス\n * \n */\nvar Circle2D = class Circle2D {\n\tconstructor(x,y,r){\n\t\tthis.center = new Point2D(x,y);\n\t\tthis.r = r;\n\t}\n}\n\n/**\n * 円と直線の交点を返す\n * \n */\nfunction getCircleLineCrossPoints(line,circle){\n\tvar d = getDistanceLinePoint(line,circle.center);\n\t// 交点がない場合\n\tif(d > circle.r){\n\t    console.log(\"return\")\n\t\treturn;\n\t}\n\t// 円の中心から直線への射影点\n\tvar pr = getProjectPoint(line,circle.center);\n\t// 交点が一つ\n\tif(equalFloats(d,circle.r)){\n        // 射影点が交点になる\n\t\treturn pr;\n\t}\n\t// 交点が2つ\n\telse{\n\t    // 直線の単位ベクトルを求める\n\t    var unit = getUnitVector(new Vector2D(line.point1.x - line.point2.x,line.point1.y - line.point2.y));\n\t    // 射影点から交点までの長さを求める\n\t    var length = Math.sqrt((circle.r * circle.r) - getNorm(subtractVector(pr,circle.center)));\n\t    var crossPoints = [];\n\t    crossPoints[0] = addPoint(pr,multiplyVector(unit,length));\n\t    crossPoints[1] = subtractVector(pr,multiplyVector(unit,length));\n        return crossPoints;\n\t}\n}\n\n/**\n * 極点を返す\n * \n*/\nfunction getPolar(a,r){\n    return new Point2D(Math.cos(r) * a,Math.sin(r) * a);\n}\n\n/*\n * 円と円との交点を求める \n */\nfunction getCircleCircleCrossPoints(circle1,circle2){\n    var crossPoints = [];\n    // 円の中心との距離\n    var d = getPointDistance(circle1.center,circle2.center);\n    var rDis = circle1.r + circle2.r;\n    // 交点がない\n    if(d > rDis){\n        return;\n    }\n    // 交点が一つ\n    else if(equalFloats(d == rDis)){\n        // 点と点のベクトルを求める\n        var vec = new Vector2D(circle2.center.x - circle1.center.x,circle2.center.y - circle1.center.y);\n        // 単位ベクトル\n        var unit = getUnitVector(vec);\n        var point = multiplyVector(unit,d);\n        crossPoints[0] = crossPoints[1] = point;\n    }\n    else{\n        // 中心点1から中心点2の線分と交点との角度aを余弦を使って求める\n        var a = Math.acos((circle1.r * circle1.r + d * d - circle2.r * circle2.r) / (2 * circle1.r * d));\n        // 中心点1を通るy = 0の直線とaとの差分の角度をtとする\n        var vec = subtractVector(circle2.center,circle1.center);\n        var t = Math.atan2(vec.y,vec.x);\n        \n        crossPoints[0] = addPoint(circle1.center,getPolar(circle1.r,t + a));\n        crossPoints[1] = addPoint(circle1.center,getPolar(circle1.r,t - a));\n    }\n    return crossPoints;\n}\n\n/**\n * 円と点との接戦の交点を求める\n */\nfunction getTangentsFromPoint(circle,point){\n  var base = subtractPoint(point,circle.center);\n  var baseLength = getVectorLength2D(base);\n  var radian = Math.acos(circle.r / baseLength);\n  var vec1 = getDivideVector(base,baseLength);\n  vec1 = multiplyVector(vec1,circle.r);\n  var points = [];\n  points[0] = addPoint(circle.center,getRotateVectorFromRad(vec1,radian));\n  points[1] = addPoint(circle.center,getRotateVectorFromRad(vec1,-radian));\n  return points;\n}\n\nfunction get3PointCross(point1,point2,point3){\n    var vec1 = new Vector2D(point2.x - point1.x,point2.y - point1.y);\n    var vec2 = new Vector2D(point3.x - point1.x,point3.y - point1.y);\n    var cross = getCross(vec1,vec2);\n    return cross;\n}\n\nfunction inTriangle(p1,p2,p3,p){\n    let ccw1 = get3PointCross(p1,p2,p);\n    let ccw2 = get3PointCross(p2,p3,p);\n    let ccw3 = get3PointCross(p3,p1,p);\n    \n    if(ccw1 > 0 && ccw2 > 0 && ccw3 > 0 || ccw1 < 0 && ccw2 < 0 && ccw3 < 0){\n        return true;\n    }\n    return false;\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nlet arr = (input.trim()).split(\"\\n\");\narr.shift()\n\nfor(var i = 0;i < arr.length;++i){\n    let ans = \"NG\"\n    var numbers = arr[i].split(\" \").map(Number);\n    var p1 = new Point2D(numbers[0],numbers[1]);\n    var p2 = new Point2D(numbers[2],numbers[3]);\n    var p3 = new Point2D(numbers[4],numbers[5]);\n    var p4  = new Point2D(numbers[6],numbers[7]);\n    var p5  = new Point2D(numbers[8],numbers[9]);\n    // 三角形のある点の対辺がその点と対象の点と同じ位置にある場合\n    if(inTriangle(p1,p2,p3,p4) ^ inTriangle(p1,p2,p3,p5)){\n        ans = \"OK\"\n    }\n    console.log(ans);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "\ndef oprd(t0, t1, p)\n  x0 = t1[0] - t0[0]\n  y0 = t1[1] - t0[1]\n  x1 = p[0] - t0[0]\n  y1 = p[1] - t0[1]\n  x0 * y1 - x1 * y0\nend\n\ndef inside?(tps, pt)\n  d0 = oprd(tps[0, 2], tps[2, 2], pt)\n  d1 = oprd(tps[2, 2], tps[4, 2], pt)\n  d2 = oprd(tps[4, 2], tps[0, 2], pt)\n\n  (d0 > 0 && d1 > 0 && d2 > 0) ||(d0 < 0 && d1 < 0 && d2 < 0)\nend\n\n### main\n\nn = gets.strip.to_i\n\nn.times.each do\n  tps = gets.strip.split(' ').map{|s| s.to_i}\n\n  ap = tps[6, 2]\n  bp = tps[8, 2]\n  tps = tps[0, 6]\n\n  a_in = inside?(tps, ap)\n  b_in = inside?(tps, bp)\n\n  puts (a_in && ! b_in || ! a_in && b_in) ? \"OK\" : \"NG\"\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\n$<.gets.to_i.times do\n  given = $<.gets.split.map(&:to_r).each_slice(2).map {|x, y| Vector[x, y]}\n  p1, p2, p3, k, s = given\n  calc = ->(r) { Matrix.columns([p2 - p1, p3 - p1]).lup.solve(r - p1).to_a }\n  s1, t1 = calc.(k)\n  s2, t2 = calc.(s)\n  f1 = s1 + t1 < 1 && s1 > 0 && t1 > 0\n  f2 = s2 + t2 < 1 && s2 > 0 && t2 > 0\n  puts f1 ^ f2 ? \"OK\" : \"NG\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def z a,b,c,d;a*d-b*c>0;end\ngets.to_i.times{a,b,c,d,e,f,g,h,i,j=gets.split.map &:to_i\nputs (z(a-c,b-d,a-g,b-h)==(k=z c-e,d-f,c-g,d-h)&&k==z(e-a,f-b,e-g,f-h))^(z(a-c,b-d,a-i,b-j)==(l=z c-e,d-f,c-i,d-j)&&l==z(e-a,f-b,e-i,f-j))?:OK:\"NG\"}"
  },
  {
    "language": "Ruby",
    "code": "def z a,b,c,d\na*d-b*c>0\nend\ndef x a,b,c,d,e,f,s,t\nz(a-c,b-d,a-s,b-t)==(k=z c-e,d-f,c-s,d-t)&&k==z(e-a,f-b,e-s,f-t)\nend\ngets.to_i.times{*a,g,h,i,j=gets.split.map &:to_i\nputs x(*a,g,h)^x(*a,i,j)?:OK:\"NG\"}"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x=x\n    @y=y\n  end\n\nend\n\n# 1次関数(2点標準形)\ndef linear(p1, p2)\n  lambda { |p| (p2.y-p1.y)*(p.x-p1.x)-(p2.x-p1.x)*(p.y-p1.y) }\nend\n\n# 包含判定\ndef inner?(p, polygon)\n  a=linear(polygon[0], polygon[1]).call(p)\n  b=linear(polygon[1], polygon[2]).call(p)\n  c=linear(polygon[2], polygon[0]).call(p)\n\n  if a<0&&b<0&&c<0\n    return true\n  end\n\n  if a>0&&b>0&&c>0\n    return true\n  end\n\n  false\n\nend\n\ngets.to_i.times do\n\n  ps = gets.split.map(&:to_f)\n\n  p1=Point.new(ps[0], ps[1])\n  p2=Point.new(ps[2], ps[3])\n  p3=Point.new(ps[4], ps[5])\n  poly=[p1, p2, p3]\n\n  pa=Point.new(ps[6], ps[7]) # altair\n  pv=Point.new(ps[8], ps[9]) # vega\n\n  if inner?(pv, poly)\n    unless inner?(pa, poly)\n      puts :OK\n      next\n    end\n  else\n    if inner?(pa, poly)\n      puts :OK\n      next\n    end\n  end\n\n  puts :NG\n\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x=x\n    @y=y\n  end\nend\n\n# 1次関数(2点標準形)\ndef linear(p1, p2)\n  lambda { |p| (p2.y-p1.y)*(p.x-p1.x)-(p2.x-p1.x)*(p.y-p1.y) }\nend\n\n# 包含判定\ndef inner?(p, poly)\n\n  temp=poly+[poly[0]]\n\n  a=linear(temp[0], temp[1]).call(p)\n  1.upto(temp.size-2) do |i|\n    b=a\n    a=linear(temp[i], temp[i+1]).call(p)\n    if ((a<0&&b<0)|| (a>0&&b>0))\n      next\n    else\n      return false\n    end\n  end\n  true\nend\n\ngets.to_i.times do\n\n  ps = gets.split.map(&:to_f)\n\n  p1=Point.new(ps[0], ps[1])\n  p2=Point.new(ps[2], ps[3])\n  p3=Point.new(ps[4], ps[5])\n  poly=[p1, p2, p3]\n\n  pa=Point.new(ps[6], ps[7]) # altair\n  pv=Point.new(ps[8], ps[9]) # vega\n\n  if inner?(pv, poly)\n    unless inner?(pa, poly)\n      puts :OK\n      next\n    end\n  else\n    if inner?(pa, poly)\n      puts :OK\n      next\n    end\n  end\n\n  puts :NG\n\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n\ndef check(ax, ay, bx, by, cx, cy, dx, dy)\n    ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n    return (tc * td <= 0 && ta * tb <= 0) ? 1 : 0\nend\n\nn.times do\n    x1,y1,x2,y2,x3,y3,xk,yk,xs,ys=gets.chomp.split(\" \").map(&:to_i)\n    if (check(x1,y1,x2,y2,xk,yk,xs,ys) + check(x2,y2,x3,y3,xk,yk,xs,ys) + check(x3,y3,x1,y1,xk,yk,xs,ys)).odd?\n        puts \"OK\"\n    else\n        puts \"NG\"\n    end\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x=x\n    @y=y\n  end\nend\n\n# 1次関数(2点標準形)\ndef linear(p1, p2)\n  lambda { |p| (p2.y-p1.y)*(p.x-p1.x)-(p2.x-p1.x)*(p.y-p1.y) }\nend\n\n# 包含判定\ndef inner?(p, poly)\n\n  temp=poly+[poly[0]]\n\n  a=linear(temp[0], temp[1]).call(p)\n  1.upto(temp.size-2) do |i|\n    b=a\n    a=linear(temp[i], temp[i+1]).call(p)\n    if ((a<0&&b<0)|| (a>0&&b>0))\n      next\n    else\n      return false\n    end\n  end\n  true\nend\n\ngets.to_i.times do\n\n  ps = gets.split.map(&:to_i)\n\n  p1=Point.new(ps[0], ps[1])\n  p2=Point.new(ps[2], ps[3])\n  p3=Point.new(ps[4], ps[5])\n  poly=[p1, p2, p3]\n\n  pa=Point.new(ps[6], ps[7]) # altair\n  pv=Point.new(ps[8], ps[9]) # vega\n\n  if inner?(pv, poly)\n    unless inner?(pa, poly)\n      puts :OK\n      next\n    end\n  else\n    if inner?(pa, poly)\n      puts :OK\n      next\n    end\n  end\n\n  puts :NG\n\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x=x\n    @y=y\n  end\n\nend\n\n# 1次関数(2点標準形)\ndef linear(p1, p2)\n  lambda { |p| (p2.y-p1.y)*(p.x-p1.x)-(p2.x-p1.x)*(p.y-p1.y) }\nend\n\n# 包含判定\ndef inner?(p, polygon)\n  a=linear(polygon[0], polygon[1]).call(p)\n  b=linear(polygon[1], polygon[2]).call(p)\n  c=linear(polygon[2], polygon[0]).call(p)\n\n  if a<0&&b<0&&c<0\n    return true\n  end\n\n  if a>0&&b>0&&c>0\n    return true\n  end\n\n  false\n\nend\n\ngets.to_i.times do\n\n  ps = gets.split.map(&:to_f)\n\n  p1=Point.new(ps[0], ps[1])\n  p2=Point.new(ps[2], ps[3])\n  p3=Point.new(ps[4], ps[5])\n  pt=[p1, p2, p3]\n\n  pa=Point.new(ps[6], ps[7]) # altair\n  pv=Point.new(ps[8], ps[9]) # vega\n\n  unless inner?(pv, pt)\n    puts :NG\n    next\n  end\n\n  if inner?(pa, pt)\n    puts :NG\n    next\n  end\n\n  puts :OK\n\nend"
  },
  {
    "language": "Ruby",
    "code": "def x a,b,c,d,e,f,s,t\n((a-c)*(b-t)-(a-s)*(b-d)>0)==(k=(c-e)*(d-t)-(c-s)*(d-f)>0)&&k==(e-a)*(f-t)-(e-s)*(f-b)>0\nend\ngets.to_i.times{*a,g,h,i,j=gets.split.map &:to_i\nputs x(*a,g,h)^x(*a,i,j)?:OK:\"NG\"}"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x=x\n    @y=y\n  end\nend\n\n# 1次関数(2点標準形)\ndef linear(p1, p2)\n  lambda { |p| (p2.y-p1.y)*(p.x-p1.x)-(p2.x-p1.x)*(p.y-p1.y) }\nend\n\n# 包含判定\ndef inner?(p, poly)\n\n  temp=poly+[poly[0]]\n\n  a=linear(temp[0], temp[1]).call(p)\n  1.upto(temp.size-2) do |i|\n    b=a\n    a=linear(temp[i], temp[i+1]).call(p)\n    if (a*b<0)\n      return false\n    end\n  end\n  true\nend\n\ngets.to_i.times do\n\n  ps = gets.split.map(&:to_f)\n\n  p1=Point.new(ps[0], ps[1])\n  p2=Point.new(ps[2], ps[3])\n  p3=Point.new(ps[4], ps[5])\n  poly=[p1, p2, p3]\n\n  pa=Point.new(ps[6], ps[7]) # altair\n  pv=Point.new(ps[8], ps[9]) # vega\n\n  if inner?(pv, poly)\n    unless inner?(pa, poly)\n      puts :OK\n      next\n    end\n  else\n    if inner?(pa, poly)\n      puts :OK\n      next\n    end\n  end\n\n  puts :NG\n\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc main() {\n\tscanner.Scan()\n\tn, _ := strconv.Atoi(scanner.Text())\n\tfor i := 0; i < n; i++ {\n\t\tscanner.Scan()\n\t\tinput := strings.Split(scanner.Text(), \" \")\n\t\tbuf := make([]float64, len(input))\n\t\tfor j := range buf {\n\t\t\tbuf[j], _ = strconv.ParseFloat(input[j], 64)\n\t\t}\n\t\tp1 := complex(buf[0], buf[1])\n\t\tp2 := complex(buf[2], buf[3])\n\t\tp3 := complex(buf[4], buf[5])\n\t\tpk := complex(buf[6], buf[7])\n\t\tps := complex(buf[8], buf[9])\n\t\tkin := isAtSameSide(p3, pk, []complex128{p1, p2}) &&\n\t\t\tisAtSameSide(p1, pk, []complex128{p2, p3}) &&\n\t\t\tisAtSameSide(p2, pk, []complex128{p3, p1})\n\t\tsin := isAtSameSide(p3, ps, []complex128{p1, p2}) &&\n\t\t\tisAtSameSide(p1, ps, []complex128{p2, p3}) &&\n\t\t\tisAtSameSide(p2, ps, []complex128{p3, p1})\n\t\tif (kin || sin) && !(kin && sin) {\n\t\t\tfmt.Println(\"OK\")\n\t\t} else {\n\t\t\tfmt.Println(\"NG\")\n\t\t}\n\t}\n}\n\nfunc isAtSameSide(a, b complex128, line []complex128) bool {\n\tsa := (real(line[1]) - real(line[0]))*(imag(a)-imag(line[0]))+\n\t\t(imag(line[1])-imag(line[0]))*(real(line[0])-real(a))\n\tsb := (real(line[1]) - real(line[0]))*(imag(b)-imag(line[0]))+\n\t\t(imag(line[1])-imag(line[0]))*(real(line[0])-real(b))\n\treturn (sa > 0 && sb > 0) || (sa < 0 && sb < 0)\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.math;\n\nconst double EPS = 1e-10;\ndouble[3] xp, yp;\n\nvoid main(){\n\tint n;\n\tdouble xk, yk, xs, ys;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\treadf(\"%s %s %s %s %s %s %s %s\\n\", &xp[0], &yp[0], &xp[1], &yp[1], &xp[2], &yp[2], &xk, &yk, &xs, &ys);\n\t\tif (inTriangle(xk, yk) + inTriangle(xs, ys) == 0) writeln(\"OK\");\n\t\telse writeln(\"NG\");\n\t}\n}\n\n// true -> 1, false -> -1\nint inTriangle(double x, double y){\n\tdouble a, b, c, z, pa, pb, pc, Sa, Sb, Sc, Sp, S;\n\ta = dist(xp[1], yp[1], xp[2], yp[2]);\n\tb = dist(xp[2], yp[2], xp[0], yp[0]);\n\tc = dist(xp[0], yp[0], xp[1], yp[1]);\n\tS = heron(a, b, c);\n\n\tpa = dist(x, y, xp[0], yp[0]);\n\tpb = dist(x, y, xp[1], yp[1]);\n\tpc = dist(x, y, xp[2], yp[2]);\n\tSa = heron(a, pb, pc);\n\tSb = heron(pa, b, pc);\n\tSc = heron(pa, pb, c);\n\tSp = Sa + Sb + Sc;\n\tif (abs(Sp-S) < EPS) return 1;\n\telse return -1;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble heron(double a,double b,double c){\n\tdouble z = (a + b + c) / 2.0;\n\treturn sqrt(z*(z-a)*(z-b)*(z-c));\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.math;\n\nalias Tuple!(real, \"x\", real, \"y\") Point;\nalias Point Vector;\n\nvoid main(){\n\tint n;\n\treadf(\"%d\\n\", &n);\n\tfor(int i=0;i<n;i++){\n\t\tstring s = readln();\n\t\tstring[] ss = s.split();\n\t\tPoint[5] p;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tp[j].x = ss[2*j].to!(real);\n\t\t\tp[j].y = ss[2*j+1].to!(real);\n\t\t}\n\n\t\tVector[3] v;\n\t\tint res[2];\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tv[j].x = p[j].x-p[3+k].x;\n\t\t\t\tv[j].y = p[j].y-p[3+k].y;\n\t\t\t}\n\t\t\treal[3] cp;\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tcp[j] = v[j].x*v[(j+1)%3].y-v[j].y*v[(j+1)%3].x;\n\t\t\t}\n\t\t\tres[k] = (cp[0]<0) + (cp[1]<0) + (cp[2]<0)%3 == 0;\n\t\t}\n\t\tif(res[0] == 0 && res[1] == 1)writeln(\"OK\");\n\t\telse writeln(\"NG\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.typecons;\nimport std.string;\nimport std.conv;\nimport std.math;\n\nalias Tuple!(real, \"x\", real, \"y\") Point;\nalias Point Vector;\n\nvoid main(){\n\tint n;\n\treadf(\"%d\\n\", &n);\n\tfor(int i=0;i<n;i++){\n\t\tstring s = readln();\n\t\tstring[] ss = s.split();\n\t\tPoint[5] p;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tp[j].x = ss[2*j].to!(real);\n\t\t\tp[j].y = ss[2*j+1].to!(real);\n\t\t}\n\n\t\tVector[3] v;\n\t\tint res[2];\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tv[j].x = p[j].x-p[3+k].x;\n\t\t\t\tv[j].y = p[j].y-p[3+k].y;\n\t\t\t}\n\t\t\treal[3] cp;\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tcp[j] = v[j].x*v[(j+1)%3].y-v[j].y*v[(j+1)%3].x;\n\t\t\t}\n\t\t\tres[k] = ((cp[0]<0) + (cp[1]<0) + (cp[2]<0))%3 == 0;\n\t\t}\n\t\tif(res[0] == 0 && res[1] == 1)writeln(\"OK\");\n\t\telse writeln(\"NG\");\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.math;\n\ndouble[3] xp, yp;\n\nvoid main(){\n\tint n;\n\tdouble xk, yk, xs, ys;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\treadf(\"%s %s %s %s %s %s %s %s\\n\", &xp[0], &yp[0], &xp[1], &yp[1], &xp[2], &yp[2], &xk, &yk, &xs, &ys);\n\t\tif (inTriangle(xk, yk) + inTriangle(xs, ys) == 0) writeln(\"OK\");\n\t\telse writeln(\"NG\");\n\t}\n}\n\n// true -> 1, false -> -1\nint inTriangle(double x, double y){\n\tint a, b, c;\n\ta = outerProduct(xp[0], yp[0], xp[1], yp[1], x, y);\n\tb = outerProduct(xp[1], yp[1], xp[2], yp[2], x, y);\n\tc = outerProduct(xp[2], yp[2], xp[0], yp[0], x, y);\n\tif (abs(a+b+c) == 3) return 1;\n\telse return -1;\n}\n\n// return sign of AB x AP\nint outerProduct(double ax, double ay, double bx, double by, double px, double py){\n\tdouble abx, aby, apx, apy;\n\tabx = bx - ax;\n\taby = by - ay;\n\tapx = px - ax;\n\tapy = py - ay;\n\tif (abx*apy - apx*aby > 0) return 1;\n\telse return -1;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nbool isInside(long xp1, long yp1, long xp2, long yp2, long xp3, long yp3, long x, long y) {\n    xp1 -= x;\n    xp2 -= x;\n    xp3 -= x;\n    yp1 -= y;\n    yp2 -= y;\n    yp3 -= y;\n    auto s1 = xp1*yp2 - xp2*yp1;\n    auto s2 = xp2*yp3 - xp3*yp2;\n    auto s3 = xp3*yp1 - xp1*yp3;\n    return s1*s2 > 0 && s2*s3 > 0 && s3*s1 > 0;\n}\n\nvoid main(){\n    auto n = readLong();\n    foreach(i; iota(n)) {\n        auto line = readLongs();\n        writeln(isInside(line[0], line[1], line[2], line[3], line[4], line[5], line[6], line[7])\n            ^ isInside(line[0], line[1], line[2], line[3], line[4], line[5], line[8], line[9]) ?\n            \"OK\": \"NG\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.math;\n\nconst double EPS = 1e-10;\ndouble[3] xp, yp;\n\nvoid main(){\n\tint n;\n\tdouble xk, yk, xs, ys;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\treadf(\"%s %s %s %s %s %s %s %s\\n\", &xp[0], &yp[0], &xp[1], &yp[1], &xp[2], &yp[2], &xk, &yk, &xs, &ys);\n\t\tif (inTriangle(xk, yk) + inTriangle(xs, ys) == 0) writeln(\"OK\");\n\t\telse writeln(\"NG\");\n\t}\n}\n\n// true -> 1, false -> -1\nint inTriangle(double x, double y){\n\tdouble a, b, c, z, pa, pb, pc, Sa, Sb, Sc, Sp, S;\n\ta = dist(xp[1], yp[1], xp[2], yp[2]);\n\tb = dist(xp[2], yp[2], xp[0], yp[0]);\n\tc = dist(xp[0], yp[0], xp[1], yp[1]);\n\tS = heron(a, b, c);\n\n\tpa = dist(x, y, xp[0], yp[0]);\n\tpb = dist(x, y, xp[1], yp[1]);\n\tpc = dist(x, y, xp[2], yp[2]);\n\tSa = heron(a, pb, pc);\n\tSb = heron(pa, b, pc);\n\tSc = heron(pa, pb, c);\n\tSp = Sa + Sb + Sc;\n\tif (fabs(Sp-S) < EPS) return 1; // TODO\n\telse return -1;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble heron(double a,double b,double c){\n\tdouble z = (a + b + c) / 2;\n\treturn sqrt(z*(z-a)*(z-b)*(z-c));\n}"
  },
  {
    "language": "Python",
    "code": "def sign(p1, p2, p3):\n    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\n\ndef check(triangle, pt):\n    v1 = [triangle[0], triangle[1]]\n    v2 = [triangle[2], triangle[3]]\n    v3 = [triangle[4], triangle[5]]\n\n    b1 = sign(pt, v1, v2)\n    if b1 > 0:\n        flag1 = 1\n    else:\n        flag1 = 0\n\n    b2 = sign(pt, v2, v3)\n    if b2 > 0:\n        flag2 = 1\n    else:\n        flag2 = 0\n\n    b3 = sign(pt, v3, v1)\n    if b3 > 0:\n        flag3 = 1\n    else:\n        flag3 = 0\n\n    return ((flag1 == flag2) and (flag2 == flag3))\n\n\nn = int(input())\n\nfor _ in range(n):\n    query = list(map(int, input().split()))\n    triangle = query[0:6]\n    hikoboshi = query[6:8]\n    orihime = query[8:10]\n\n    check1 = check(triangle, hikoboshi)\n    check2 = check(triangle, orihime)\n    if check1 == check2:\n        print(\"NG\")\n    else:\n        print(\"OK\")\n"
  },
  {
    "language": "Python",
    "code": "from collections import namedtuple\nVector=namedtuple(\"Vector\",\"x y\")\n\ndef square(a,b,c):\n    return abs((a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y))\n\nn=input()\nfor i in range(n):\n    xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys=map(int,raw_input().split())\n    A=Vector(x=xp1, y=yp1)\n    B=Vector(x=xp2, y=yp2)\n    C=Vector(x=xp3, y=yp3)\n    K=Vector(x=xk, y=yk)\n    S=Vector(x=xs, y=ys)\n    ABC=square(A,B,C)\n    ABCK=square(A,B,K)+square(A,K,C)+square(K,B,C)\n    ABCS=square(A,B,S)+square(A,S,C)+square(S,B,C)\n    print \"NG\" if (ABC==ABCK)==(ABC==ABCS) else\t\"OK\""
  },
  {
    "language": "Python",
    "code": "from operator import sub,mul\ndef cross(a,b):\n    return a[0]*b[1] - a[1]*b[0]\n\ndef func(a,b):#\n    return [map(sub,aa,bb) for aa,bb in zip(a,b)]\n\ndef check(a):\n    return all(map(lambda x:x<0,a)) or all(map(lambda x:x>0,a))\n\nfor _ in xrange(input()):\n    line = map(int,raw_input().split())\n    tmp = zip(line[:6:2],line[1:6:2])\n    v = func(tmp[1:]+[tmp[0]],tmp)\n    m = func([line[6:8]]*3,tmp)\n    f = func([line[8:]]*3,tmp) \n    if check(map(cross,m,v)) != check(map(cross,f,v)):\n        print \"OK\"\n    else:\n        print \"NG\""
  },
  {
    "language": "Python",
    "code": "from operator import sub,mul\ndef cross(a,b):\n    return a[0]*b[1] - a[1]*b[0]\n\ndef func(a,b):##\n    return [map(sub,aa,bb) for aa,bb in zip(a,b)]\n\nfor _ in xrange(input()):\n    line = map(int,raw_input().split())\n    tmp = zip(line[:6:2],line[1:6:2])\n    v = func(tmp,tmp[1:]+[tmp[0]])\n    f = func(tmp,[line[6:8]]*3)\n    m = func(tmp,[line[8:]]*3)    \n    if reduce(mul,map(cross,v,f)) * reduce(mul,map(cross,v,m)) < 0:\n        print \"OK\"\n    else:\n        print \"NG\""
  },
  {
    "language": "Python",
    "code": "def side(a, b, c):\n  return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x):\n  return (side(p0, p1, x)==side(p1, p2, x)==side(p2, p0, x))\n\nfor _ in [0]*input():\n  P = map(int, raw_input().split())\n  p0 = P[0:2]\n  p1 = P[2:4]\n  p2 = P[4:6]\n  print ['NG','OK'][isIn(P[6:8])!=isIn(P[8:])]"
  },
  {
    "language": "Python",
    "code": "from operator import sub,mul\ndef cross(a,b):\n    return a[0]*b[1] - a[1]*b[0]\n\ndef func(a,b):#\n    return [map(sub,aa,bb) for aa,bb in zip(a,b)]\n\ndef check(a):\n    return all(map(lambda x:x<0,a)) or all(map(lambda x:x>0,a))\n\nfor _ in xrange(input()):\n    line = map(int,raw_input().split())\n    tmp = zip(line[:6:2],line[1:6:2])\n    v = func(tmp[1:]+[tmp[0]],tmp)\n    m = func([line[6:8]]*3,tmp)\n    f = func([line[8:]]*3,tmp) \n    if check(map(cross,m,v)) != check(map(cross,f,v)):\n        print \"OK\"\n    else:\n        print \"NA\""
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef crossP(a, b, c, d):\n    e = b - a\n    f = c - d\n    g = c - a\n    A = np.matrix([[e.real,f.real],[e.imag, f.imag]])\n    B = np.matrix([[g.real],[g.imag]])\n    try:\n        C = np.linalg.solve(A, B)\n    except:\n        return(-9999+(-9999)*1j)\n    return(C[0,0]+C[1,0]*1j)\n\ndef rangeP(st):\n    return((0.0<=st.real<=1.0) and (0.0<=st.imag<=1.0))\n\nif __name__ == '__main__':\n\tn = int(input().strip())\n\tfor i in range(n):\n\t    [xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys] = map(int, input().strip().split())\n\t    a = xp1+yp1*1j\n\t    b = xp2+yp2*1j\n\t    c = xp3+yp3*1j\n\t    k = xk+yk*1j\n\t    s = xs+ys*1j\n\t    shut = 0\n\t    if rangeP(crossP(a,b,k,s)):\n\t        shut += 1\n\t    if rangeP(crossP(b,c,k,s)):\n\t        shut += 1\n\t    if rangeP(crossP(c,a,k,s)):\n\t        shut += 1\n\t    if shut == 1:\n\t        print(\"OK\")\n\t    else:\n\t        print(\"NG\")"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0143\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom math import sqrt, atan2, acos, sin, cos\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(self.x / other, self.y / other)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return sqrt(self.norm())\n\n    def ccw(self, p0, p1):\n        # ??????2???(p0, p1)?????????????????????????????????????????¢????????????\n        a = Vector(p1 - p0)\n        b = Vector(self - p0)\n        if Vector.cross(a, b) > Point.epsilon:\n            return 1 # 'COUNTER_CLOCKWISE'\n        elif Vector.cross(a, b) < -Point.epsilon:\n            return -1 # 'CLOCKWISE'\n        elif Vector.dot(a, b) < -Point.epsilon:\n            return 2 # 'ONLINE_BACK'\n        elif a.norm() < b.norm():\n            return -2 # 'ONLINE_FRONT'\n        else:\n            return 0 # 'ON_SEGMENT'\n\n    def project(self, s):\n        # ??????(Point)????????????s??????????????????????????????????????§?¨?(?°???±)????±???????\n        base = Vector(s.p2 - s.p1)\n        a = Vector(self - s.p1)\n        r = Vector.dot(a, base)\n        r /= base.norm()\n        return s.p1 + base * r\n\n    def reflect(self, s):\n        # ??????s???????§°?????¨?????????????????¨???????§°??????????????§?¨?(????°?)????±???????\n        proj = self.project(s)\n        return self + (proj - self)*2\n\n    def distance(self, s):\n        # ????????¨??????s????????¢????¨??????????\n        if Vector.dot(s.p2-s.p1, self-s.p1) < 0.0:\n            return abs(self - s.p1)\n        if Vector.dot(s.p1-s.p2, self-s.p2) < 0.0:\n            return abs(self - s.p2)\n        return abs(Vector.cross(s.p2-s.p1, self-s.p1) / abs(s.p2-s.p1))\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(self.x / other, self.y / other)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return abs(Vector.dot(a, b)) < Vector.epsilon\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return abs(Vector.cross(a, b)) < Vector.epsilon\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    def intersect(self, s):\n        # ????????¨??????????????????????????????????????????????????????\n        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)\n        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)\n        return ans1 <= 0 and ans2 <= 0\n\n    def cross_point(self, s):\n        # ????????¨??????????????????????????????????????§?¨?????±???????\n        base = s.p2 - s.p1\n        d1 = abs(Vector.cross(base, self.p1-s.p1))\n        d2 = abs(Vector.cross(base, self.p2-s.p1))\n        t = d1 / (d1 + d2)\n        return self.p1 + (self.p2 - self.p1) * t\n\n    def distance(self, s):\n        # ????????¨?????????????????????????????¢????±???????\n        if self.intersect(s):\n            return 0.0\n        d1 = s.p1.distance(self)\n        d2 = s.p2.distance(self)\n        d3 = self.p1.distance(s)\n        d4 = self.p2.distance(s)\n        return min(d1, d2, d3, d4)\n\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, x, y=Point(), r=1.0):\n        if isinstance(x, Point):\n            self.c = x\n            self.r = y\n        elif isinstance(x, tuple):\n            self.c = Point(x[0], x[1])\n            self.r = r\n\n    def cross_points(self, s):\n        if isinstance(s, Segment):\n            pr = self.c.project(s)\n            e = (s.p2 - s.p1) / abs(s.p2 - s.p1)\n            base = sqrt(self.r * self.r - (pr - self.c).norm())\n            return pr + e * base, pr - e * base\n        elif isinstance(s, Cirle):\n            c2 = s\n            d = abs(self.c - c2.c)\n            a = acos((self.r * self.r + d * d - c2.r * c2.r) / (2 * self.r * d))\n            t = atan2(c2.c.y - self.c.y, c2.c.x - self.c.x)\n            temp1 = Point(cos(t+a)*self.r, sin(t+a)*self.r)\n            temp2 = Point(cos(t-a)*self.r, sin(t-a)*self.r)\n            return self.c + temp1, self.c + temp2\n\nclass Triangle(object):\n    def __init__(self, p1, p2, p3):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n\n    def length(self):\n        # 3????????????\n        l1 = hypot(self.p1.x-self.p2.x, self.p1.y-self.p2.y)\n        l2 = hypot(self.p2.x-self.p3.x, self.p2.y-self.p3.y)\n        l3 = hypot(self.p3.x-self.p1.x, self.p3.y-self.p1.y)\n        return l1, l2, l3\n\n    def area(self):\n        # ????§???¢?????¢???\n        a, b, c = self.length()\n        z = (a+b+c) / 2.0\n        return sqrt(z * (z-a)*(z-b)*(z-c))\n\n    def is_inside(self, p):\n        # ???p?????????????§???¢????????´?????????????????????\n        t1 = p.ccw(self.p1, self.p2)\n        t2 = p.ccw(self.p2, self.p3)\n        t3 = p.ccw(self.p3, self.p1)\n        if (t1 < 0 and t2 < 0 and t3 < 0) or (t1 > 0 and t2 > 0 and t3 > 0):\n            return True\n        else:\n            return False\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys = map(int, input().split())\n        t = Triangle(Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3))\n        pk = Point(xk, yk)\n        ps = Point(xs, ys)\n        result_k = t.is_inside(pk)\n        result_s = t.is_inside(ps)\n        if result_k != result_s:\n            print('OK')\n        else:\n            print('NG')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def side(a, b, c):\n  return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isInner(x): return (side(p0, p1, x)==side(p1, p2, x)==side(p2, p0, x))\n\nfor _ in [0]*input():\n  P = map(int, raw_input().split())\n  p0 = P[0:2]\n  p1 = P[2:4]\n  p2 = P[4:6]\n  x1 = P[6:8]\n  x2 = P[8:]\n  print ['NG','OK'][isInner(x1)!=isInner(x2)]"
  },
  {
    "language": "Python",
    "code": "# AOJ 0143 Altair and Vega\n# Python3 2018.6.18 bal4u\n\n# a, b, はラインの同一側にあるか\ndef is_atSameSide(a, b, line):\n\tsa = (line[1].real-line[0].real)*(a.imag-line[0].imag) \\\n\t\t + (line[1].imag-line[0].imag)*(line[0].real-a.real);\n\tsb = (line[1].real-line[0].real)*(b.imag-line[0].imag) \\\n\t\t + (line[1].imag-line[0].imag)*(line[0].real-b.real);\n\treturn (sa > 0 and sb > 0) or (sa < 0 and sb < 0)    # a, b at same side\n\nfor i in range(int(input())):\n\tbuf = list(map(int, input().split()))\n\tp1 = complex(buf[0], buf[1])\n\tp2 = complex(buf[2], buf[3])\n\tp3 = complex(buf[4], buf[5])\n\tpk = complex(buf[6], buf[7])\n\tps = complex(buf[8], buf[9])\n\n\tkin = is_atSameSide(p3, pk, [p1, p2]) & \\\n\t\t  is_atSameSide(p1, pk, [p2, p3]) & \\\n\t\t  is_atSameSide(p2, pk, [p3, p1])\n\tsin = is_atSameSide(p3, ps, [p1, p2]) & \\\n\t\t  is_atSameSide(p1, ps, [p2, p3]) & \\\n\t\t  is_atSameSide(p2, ps, [p3, p1])\n\tprint(\"OK\" if kin ^ sin else \"NG\")\n"
  },
  {
    "language": "Python",
    "code": "def isin(x,y):\n    if S(x1,y1,x2,y2,x,y)+S(x1,y1,x3,y3,x,y)+S(x3,y3,x2,y2,x,y)-S(x1,y1,x2,y2,x3,y3) != 0:\n        return False\n    else:\n        return True\n\ndef S(x1,y1,x2,y2,x3,y3):\n    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\n\nfor roop in range(int(raw_input())):\n    x1,y1,x2,y2,x3,y3,xk,yk,xs,ys = map(int,raw_input().split())\n    print \"OK\" if isin(xk,yk) != isin(xs,ys) else \"NG\""
  },
  {
    "language": "Python",
    "code": "class Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    @staticmethod\n    def cross_product(point1, point2):\n        return point1.x * point2.y - point1.y * point2.x\n\n\nclass Triangle:\n    def __init__(self, x1, y1, x2, y2, x3, y3):\n        self.point1 = Vector(x1, y1)\n        self.point2 = Vector(x2, y2)\n        self.point3 = Vector(x3, y3)\n\n    def is_contain(self, point):\n        line1 = point - self.point1\n        line2 = self.point2 - self.point1\n        direct1 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point2\n        line2 = self.point3 - self.point2\n        direct2 = Vector.cross_product(line1, line2)\n\n        line1 = point - self.point3\n        line2 = self.point1 - self.point3\n        direct3 = Vector.cross_product(line1, line2)\n\n        if 0 < direct1 and 0 < direct2 and 0 < direct3:\n            return 1\n        elif direct1 < 0 and direct2 < 0 and direct3 < 0:\n            return 1\n        else:\n            return -1\n\n\nfor _ in range(int(input())):\n    data = [int(item) for item in input().split(\" \")]\n\n    triangle = Triangle(data[0], data[1], data[2], data[3], data[4], data[5])\n    altair_point = Vector(data[6], data[7])\n    vega_point = Vector(data[8], data[9])\n\n    is_contain1 = triangle.is_contain(altair_point)\n    is_contain2 = triangle.is_contain(vega_point)\n    result = is_contain1 * is_contain2\n\n    if result == -1:\n        print(\"OK\")\n    else:\n        print(\"NG\")\n\n"
  },
  {
    "language": "Python",
    "code": "EPS=1e-10\ndef crossP(aa,bb,cc,dd):\n    a = (bb-aa).real\n    b = (cc-dd).real\n    c = (bb-aa).imag\n    d = (cc-dd).imag\n    e = (cc-aa).real\n    f = (cc-aa).imag\n    det = a*d - b*c\n    if abs(det) <EPS:\n        return(-9999+(-9999)*1j)\n    x = (d*e-b*f)/det\n    y = (-c*e+a*f)/det\n    return(x+y*1j)\n\ndef rangeP(st):\n    return((0.0<=st.real<=1.0) and (0.0<=st.imag<=1.0))\n\nif __name__ == '__main__':\n\tn = int(input().strip())\n\tfor i in range(n):\n\t    [xp1,yp1,xp2,yp2,xp3,yp3,xk,yk,xs,ys] = map(int, input().strip().split())\n\t    a = xp1+yp1*1j\n\t    b = xp2+yp2*1j\n\t    c = xp3+yp3*1j\n\t    k = xk+yk*1j\n\t    s = xs+ys*1j\n\t    shut = 0\n\t    if rangeP(crossP(a,b,k,s)):\n\t        shut += 1\n\t    if rangeP(crossP(b,c,k,s)):\n\t        shut += 1\n\t    if rangeP(crossP(c,a,k,s)):\n\t        shut += 1\n\t    if shut == 1:\n\t        print(\"OK\")\n\t    else:\n\t        print(\"NG\")"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0143\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\nfrom math import sqrt, atan2, acos, sin, cos\n\n\nclass Point(object):\n    epsilon = 1e-10\n\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Point(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Point(self.x / other, self.y / other)\n\n    def __lt__(self, other):\n        if self.x == other.x:\n            return self.y < other.y\n        else:\n            return self.x < other.x\n\n    def __eq__(self, other):\n        from math import fabs\n        if fabs(self.x - other.x) < Point.epsilon and fabs(self.y - other.y) < Point.epsilon:\n            return True\n        else:\n            return False\n\n    def norm(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return sqrt(self.norm())\n\n    def ccw(self, p0, p1):\n        # ??????2???(p0, p1)?????????????????????????????????????????¢????????????\n        a = Vector(p1 - p0)\n        b = Vector(self - p0)\n        if Vector.cross(a, b) > Point.epsilon:\n            return 1 # 'COUNTER_CLOCKWISE'\n        elif Vector.cross(a, b) < -Point.epsilon:\n            return -1 # 'CLOCKWISE'\n        elif Vector.dot(a, b) < -Point.epsilon:\n            return 2 # 'ONLINE_BACK'\n        elif a.norm() < b.norm():\n            return -2 # 'ONLINE_FRONT'\n        else:\n            return 0 # 'ON_SEGMENT'\n\n    def project(self, s):\n        # ??????(Point)????????????s??????????????????????????????????????§?¨?(?°???±)????±???????\n        base = Vector(s.p2 - s.p1)\n        a = Vector(self - s.p1)\n        r = Vector.dot(a, base)\n        r /= base.norm()\n        return s.p1 + base * r\n\n    def reflect(self, s):\n        # ??????s???????§°?????¨?????????????????¨???????§°??????????????§?¨?(????°?)????±???????\n        proj = self.project(s)\n        return self + (proj - self)*2\n\n    def distance(self, s):\n        # ????????¨??????s????????¢????¨??????????\n        if Vector.dot(s.p2-s.p1, self-s.p1) < 0.0:\n            return abs(self - s.p1)\n        if Vector.dot(s.p1-s.p2, self-s.p2) < 0.0:\n            return abs(self - s.p2)\n        return abs(Vector.cross(s.p2-s.p1, self-s.p1) / abs(s.p2-s.p1))\n\n\nclass Vector(Point):\n    def __init__(self, x=0.0, y=0.0):\n        if isinstance(x, tuple):\n            self.x = x[0]\n            self.y = x[1]\n        elif isinstance(x, Point):\n            self.x = x.x\n            self.y = x.y\n        else:\n            self.x = x\n            self.y = y\n\n    # ????????????\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vector(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, other):\n        return Vector(other * self.x, other * self.y)\n\n    def __truediv__(self, other):\n        return Vector(self.x / other, self.y / other)\n\n    @classmethod\n    def dot(cls, a, b):\n        return a.x * b.x + a.y * b.y\n\n    @classmethod\n    def cross(cls, a, b):\n        return a.x * b.y - a.y * b.x\n\n    @classmethod\n    def is_orthogonal(cls, a, b):\n        return abs(Vector.dot(a, b)) < Vector.epsilon\n\n    @classmethod\n    def is_parallel(cls, a, b):\n        return abs(Vector.cross(a, b)) < Vector.epsilon\n\n\nclass Segment(object):\n    def __init__(self, p1=Point(), p2=Point()):\n        if isinstance(p1, Point):\n            self.p1 = p1\n            self.p2 = p2\n        elif isinstance(p1, tuple):\n            self.p1 = Point(p1[0], p1[1])\n            self.p2 = Point(p2[0], p2[1])\n\n    def intersect(self, s):\n        # ????????¨??????????????????????????????????????????????????????\n        ans1 = s.p1.ccw(self.p1, self.p2) * s.p2.ccw(self.p1, self.p2)\n        ans2 = self.p1.ccw(s.p1, s.p2) * self.p2.ccw(s.p1, s.p2)\n        return ans1 <= 0 and ans2 <= 0\n\n    def cross_point(self, s):\n        # ????????¨??????????????????????????????????????§?¨?????±???????\n        base = s.p2 - s.p1\n        d1 = abs(Vector.cross(base, self.p1-s.p1))\n        d2 = abs(Vector.cross(base, self.p2-s.p1))\n        t = d1 / (d1 + d2)\n        return self.p1 + (self.p2 - self.p1) * t\n\n    def distance(self, s):\n        # ????????¨?????????????????????????????¢????±???????\n        if self.intersect(s):\n            return 0.0\n        d1 = s.p1.distance(self)\n        d2 = s.p2.distance(self)\n        d3 = self.p1.distance(s)\n        d4 = self.p2.distance(s)\n        return min(d1, d2, d3, d4)\n\n\n    @classmethod\n    def is_orthogonal(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_orthogonal(a, b)\n\n    @classmethod\n    def is_parallel(cls, s1, s2):\n        a = Vector(s1.p2 - s1.p1)\n        b = Vector(s2.p2 - s2.p1)\n        return Vector.is_parallel(a, b)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Cirle(object):\n    def __init__(self, x, y=Point(), r=1.0):\n        if isinstance(x, Point):\n            self.c = x\n            self.r = y\n        elif isinstance(x, tuple):\n            self.c = Point(x[0], x[1])\n            self.r = r\n\n    def cross_points(self, s):\n        if isinstance(s, Segment):\n            pr = self.c.project(s)\n            e = (s.p2 - s.p1) / abs(s.p2 - s.p1)\n            base = sqrt(self.r * self.r - (pr - self.c).norm())\n            return pr + e * base, pr - e * base\n        elif isinstance(s, Cirle):\n            c2 = s\n            d = abs(self.c - c2.c)\n            a = acos((self.r * self.r + d * d - c2.r * c2.r) / (2 * self.r * d))\n            t = atan2(c2.c.y - self.c.y, c2.c.x - self.c.x)\n            temp1 = Point(cos(t+a)*self.r, sin(t+a)*self.r)\n            temp2 = Point(cos(t-a)*self.r, sin(t-a)*self.r)\n            return self.c + temp1, self.c + temp2\n\nclass Triangle(object):\n    def __init__(self, p1, p2, p3):\n        self.p1 = p1\n        self.p2 = p2\n        self.p3 = p3\n\n    def length(self):\n        # 3????????????\n        l1 = hypot(self.p1.x-self.p2.x, self.p1.y-self.p2.y)\n        l2 = hypot(self.p2.x-self.p3.x, self.p2.y-self.p3.y)\n        l3 = hypot(self.p3.x-self.p1.x, self.p3.y-self.p1.y)\n        return l1, l2, l3\n\n    def area(self):\n        # ????§???¢?????¢???\n        a, b, c = self.length()\n        z = (a+b+c) / 2.0\n        return sqrt(z * (z-a)*(z-b)*(z-c))\n\n    def is_inside(self, p):\n        # ???p?????????????§???¢????????´?????????????????????\n        t1 = p.ccw(self.p1, self.p2)\n        t2 = p.ccw(self.p2, self.p3)\n        t3 = p.ccw(self.p3, self.p1)\n        if (t1 < 0 and t2 < 0 and t3 < 0) or t1 > 0 and t2 > 0 and t3 > 0:\n            return True\n        else:\n            return False\n\n\ndef main(args):\n    n = int(input())\n    for _ in range(n):\n        xp1, yp1, xp2, yp2, xp3, yp3, xk, yk, xs, ys = map(int, input().split())\n        t = Triangle(Point(xp1, yp1), Point(xp2, yp2), Point(xp3, yp3))\n        pk = Point(xk, yk)\n        ps = Point(xs, ys)\n        result_k = t.is_inside(pk)\n        result_s = t.is_inside(ps)\n        if result_k != result_s:\n            print('OK')\n        else:\n            print('NG')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def isin(x,y):\n    if S(x1,y1,x2,y2,x,y)+S(x1,y1,x3,y3,x,y)+S(x3,y3,x2,y2,x,y)-S(x1,y1,x2,y2,x3,y3) != 0:\n        return False\n    else:\n        return True\n\ndef S(x1,y1,x2,y2,x3,y3):\n    return abs(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))\n\nfor roop in range(int(raw_input())):\n    x1,y1,x2,y2,x3,y3,xk,yk,xs,ys = map(int,raw_input().split())\n    print \"OK\" if isin(xk,yk) != isin(xs,ys) else \"NO\""
  },
  {
    "language": "Python",
    "code": "from operator import sub,mul\ndef cross(a,b):\n    return a[0]*b[1] - a[1]*b[0]\n\ndef func(a,b):#\n    return [map(sub,aa,bb) for aa,bb in zip(a,b)]\n\nfor _ in xrange(input()):\n    line = map(int,raw_input().split())\n    tmp = zip(line[:6:2],line[1:6:2])\n    v = func(tmp[1:]+[tmp[0]],tmp)\n    m = func([line[6:8]]*3,tmp)\n    f = func([line[8:]]*3,tmp) \n    if len(filter(lambda x:x<0,map(cross,v,m))) == \\\n            len(filter(lambda x:x<0,map(cross,v,f))):\n        print \"NG\"\n    else:\n        print \"OK\""
  },
  {
    "language": "Python",
    "code": "from operator import sub,mul\ndef cross(a,b):\n    return a[0]*b[1] - a[1]*b[0]\n\ndef func(a,b):#\n    return [map(sub,aa,bb) for aa,bb in zip(a,b)]\n\nfor _ in xrange(input()):\n    line = map(int,raw_input().split())\n    tmp = zip(line[:6:2],line[1:6:2])\n    v = func(tmp[1:]+[tmp[0]],tmp)\n    m = func([line[6:8]]*3,tmp)\n    f = func([line[8:]]*3,tmp) \n    if reduce(mul,map(cross,v,f)) * reduce(mul,map(cross,v,m)) < 0:\n        print \"OK\"\n    else:\n        print \"NG\""
  },
  {
    "language": "Python",
    "code": "def out_p(bx, by, x0, y0, x1, y1):\n    a, b = x0-bx, y0-by\n    c, d = x1-bx, y1-by\n    return a*d - b*c\ndef sgn(x):\n    return -1 if x<0 else 1\nn = input()\nxp = [0] * 3; yp = [0] * 3;\nxk, yk, xs, ys = [0]*4\nfor i in xrange(n):\n    xp[0], yp[0], xp[1], yp[1], xp[2], yp[2], xk, yk, xs, ys = map(int, raw_input().split())\n    rk = [0]*3\n    for i in xrange(3):\n        rk[i] = sgn(out_p(xp[i], yp[i], xp[i-2], yp[i-2], xk, yk))\n    k_in = (rk[0] == rk[1] == rk[2])\n    rs = [0]*3\n    for i in xrange(3):\n        rs[i] = sgn(out_p(xp[i], yp[i], xp[i-2], yp[i-2], xs, ys))\n    s_in = (rs[0] == rs[1] == rs[2])\n    print \"OK\" if k_in ^ s_in else \"NG\""
  }
]