[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nvoid koch_curve(int depth, double x1, double y1, double x2, double y2) {\n    if (depth == 0) {\n        printf(\"%.0f %.0f\\n\", x1, y1);\n        return;\n    }\n\n    double dx = (x2 - x1) / 3.0;\n    double dy = (y2 - y1) / 3.0;\n\n    double x3 = x1 + dx;\n    double y3 = y1 + dy;\n\n    double x4 = x1 + 2 * dx;\n    double y4 = y1 + 2 * dy;\n\n    double angle = atan2(y2 - y1, x2 - x1) - M_PI / 3;\n    double len = sqrt(dx * dx + dy * dy);\n\n    double x5 = x3 + len * cos(angle);\n    double y5 = y3 + len * sin(angle);\n\n    koch_curve(depth - 1, x1, y1, x3, y3);\n    koch_curve(depth - 1, x3, y3, x5, y5);\n    koch_curve(depth - 1, x5, y5, x4, y4);\n    koch_curve(depth - 1, x4, y4, x2, y2);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    koch_curve(n, 0, 0, 100, 0);\n    printf(\"100 0\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 22:11:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\nvoid koch(int n, Point p1, Point p2) {\n    if (n == 0) {\n        printf(\"%.8f %.8f\\n\", p2.x, p2.y);\n        return;\n    }\n\n    Point s, t, u;\n    double th = M_PI * 60.0 / 180.0;\n\n    s.x = (2.0 * p1.x + p2.x) / 3.0;\n    s.y = (2.0 * p1.y + p2.y) / 3.0;\n    t.x = (p1.x + 2.0 * p2.x) / 3.0;\n    t.y = (p1.y + 2.0 * p2.y) / 3.0;\n    u.x = (t.x - s.x) * cos(th) - (t.y - s.y) * sin(th) + s.x;\n    u.y = (t.x - s.x) * sin(th) + (t.y - s.y) * cos(th) + s.y;\n\n    koch(n - 1, p1, s);\n    koch(n - 1, s, u);\n    koch(n - 1, u, t);\n    koch(n - 1, t, p2);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Point p1 = {0.0, 0.0};\n    Point p2 = {100.0, 0.0};\n\n    printf(\"%.8f %.8f\\n\", p1.x, p1.y);\n    koch(n, p1, p2);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nvoid koch(int n, Point p1, Point p2, vector<Point>& points) {\n    if (n == 0) {\n        points.push_back(p1);\n        return;\n    }\n    \n    Point s, t, u;\n    double angle = M_PI / 3.0;\n    \n    s.x = (2 * p1.x + p2.x) / 3;\n    s.y = (2 * p1.y + p2.y) / 3;\n    t.x = (p1.x + 2 * p2.x) / 3;\n    t.y = (p1.y + 2 * p2.y) / 3;\n    u.x = (t.x - s.x) * cos(angle) - (t.y - s.y) * sin(angle) + s.x;\n    u.y = (t.x - s.x) * sin(angle) + (t.y - s.y) * cos(angle) + s.y;\n    \n    koch(n - 1, p1, s, points);\n    koch(n - 1, s, u, points);\n    koch(n - 1, u, t, points);\n    koch(n - 1, t, p2, points);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    Point p1 = {0.0, 0.0};\n    Point p2 = {100.0, 0.0};\n    vector<Point> points;\n    \n    koch(n, p1, p2, points);\n    points.push_back(p2);\n    \n    for (const auto& p : points) {\n        cout << fixed << setprecision(8) << p.x << \" \" << p.y << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.*;\nimport javax.swing.*;\n\npublic class KochCurve extends JFrame {\n    private int depth;\n\n    public KochCurve(int depth) {\n        this.depth = depth;\n        setTitle(\"Koch Curve\");\n        setSize(800, 600);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n    }\n\n    private void drawKoch(Graphics g, int depth, double x1, double y1, double x2, double y2) {\n        if (depth == 0) {\n            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n            return;\n        }\n\n        double deltaX = x2 - x1;\n        double deltaY = y2 - y1;\n\n        double xA = x1 + deltaX / 3;\n        double yA = y1 + deltaY / 3;\n\n        double xB = x1 + deltaX / 2 - deltaY * Math.sqrt(3) / 6;\n        double yB = y1 + deltaY / 2 + deltaX * Math.sqrt(3) / 6;\n\n        double xC = x1 + 2 * deltaX / 3;\n        double yC = y1 + 2 * deltaY / 3;\n\n        drawKoch(g, depth - 1, x1, y1, xA, yA);\n        drawKoch(g, depth - 1, xA, yA, xB, yB);\n        drawKoch(g, depth - 1, xB, yB, xC, yC);\n        drawKoch(g, depth - 1, xC, yC, x2, y2);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        drawKoch(g, depth, 100, 300, 700, 300);\n    }\n\n    public static void main(String[] args) {\n        int n = Integer.parseInt(args[0]);\n        SwingUtilities.invokeLater(() -> {\n            KochCurve koch = new KochCurve(n);\n            koch.setVisible(true);\n        });\n    }\n}",
    "timestamp": "2025-08-05 22:13:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.*;\nimport javax.swing.*;\n\npublic class KochCurve extends JPanel {\n    private int depth;\n\n    public KochCurve(int depth) {\n        this.depth = depth;\n        setPreferredSize(new Dimension(600, 400));\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2d = (Graphics2D) g;\n        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        \n        int x1 = 50, y1 = 250;\n        int x2 = 550, y2 = 250;\n        drawKochCurve(g2d, depth, x1, y1, x2, y2);\n    }\n\n    private void drawKochCurve(Graphics2D g, int depth, int x1, int y1, int x2, int y2) {\n        if (depth == 0) {\n            g.drawLine(x1, y1, x2, y2);\n            return;\n        }\n\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n\n        int x3 = x1 + dx / 3;\n        int y3 = y1 + dy / 3;\n\n        int x4 = x1 + dx * 2 / 3;\n        int y4 = y1 + dy * 2 / 3;\n\n        double angle = Math.PI / 3;\n        int x = (int) (x3 + (x4 - x3) * Math.cos(angle) - (y4 - y3) * Math.sin(angle));\n        int y = (int) (y3 + (x4 - x3) * Math.sin(angle) + (y4 - y3) * Math.cos(angle));\n\n        drawKochCurve(g, depth - 1, x1, y1, x3, y3);\n        drawKochCurve(g, depth - 1, x3, y3, x, y);\n        drawKochCurve(g, depth - 1, x, y, x4, y4);\n        drawKochCurve(g, depth - 1, x4, y4, x2, y2);\n    }\n\n    public static void main(String[] args) {\n        int depth = 4;\n        JFrame frame = new JFrame(\"Koch Curve\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.add(new KochCurve(depth));\n        frame.pack();\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n}",
    "timestamp": "2025-08-05 22:13:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nvoid drawKochCurve(std::vector<Point>& points, int depth, Point p1, Point p2) {\n    if (depth == 0) {\n        points.push_back(p1);\n        points.push_back(p2);\n        return;\n    }\n\n    double dx = p2.x - p1.x;\n    double dy = p2.y - p1.y;\n    double length = std::sqrt(dx * dx + dy * dy);\n    double angle = std::atan2(dy, dx);\n\n    Point s(p1.x + dx / 3, p1.y + dy / 3);\n    Point t(p1.x + 2 * dx / 3, p1.y + 2 * dy / 3);\n    Point u(\n        s.x + std::cos(angle + M_PI / 3) * length / 3,\n        s.y + std::sin(angle + M_PI / 3) * length / 3\n    );\n\n    drawKochCurve(points, depth - 1, p1, s);\n    drawKochCurve(points, depth - 1, s, u);\n    drawKochCurve(points, depth - 1, u, t);\n    drawKochCurve(points, depth - 1, t, p2);\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector<Point> points;\n    Point start(0, 0), end(100, 0);\n    drawKochCurve(points, n, start, end);\n\n    for (const auto& point : points) {\n        std::cout << point.x << \" \" << point.y << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import turtle\nimport math\n\ndef draw_koch_segment(t, p1, p2, depth):\n    if depth == 0:\n        t.penup()\n        t.goto(p1)\n        t.pendown()\n        t.goto(p2)\n    else:\n        x1, y1 = p1\n        x2, y2 = p2\n        # Calculate new points\n        dx = x2 - x1\n        dy = y2 - y1\n        s = (x1 + dx / 3, y1 + dy / 3)\n        t = (x1 + 2 * dx / 3, y1 + 2 * dy / 3)\n        \n        length = math.sqrt((dx / 3) ** 2 + (dy / 3) ** 2)\n        angle = math.atan2(dy, dx) - math.pi / 3\n        \n        u = (s[0] + length * math.cos(angle), s[1] + length * math.sin(angle))\n        \n        # Recursively draw the four segments\n        draw_koch_segment(t, p1, s, depth - 1)\n        draw_koch_segment(t, s, u, depth - 1)\n        draw_koch_segment(t, u, t, depth - 1)\n        draw_koch_segment(t, t, p2, depth - 1)\n\ndef koch_curve(n):\n    screen = turtle.Screen()\n    t = turtle.Turtle()\n    t.speed(0)\n    \n    start = (0, 0)\n    end = (100, 0)\n    \n    draw_koch_segment(t, start, end, n)\n    \n    screen.mainloop()\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the depth of the Koch curve: \"))\n    koch_curve(n)",
    "timestamp": "2025-08-13 09:28:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.geom.Line2D;\n\npublic class KochCurve extends JPanel {\n\n    private static final int PANEL_WIDTH = 800;\n    private static final int PANEL_HEIGHT = 400;\n    private static final double START_X = 100;\n    private static final double START_Y = 200;\n    private static final double END_X = 700;\n    private static final double END_Y = 200;\n\n    private final int depth;\n\n    public KochCurve(int depth) {\n        this.depth = depth;\n    }\n\n    private void drawKochCurve(Graphics2D g, double x1, double y1, double x2, double y2, int depth) {\n        if (depth == 0) {\n            g.draw(new Line2D.Double(x1, y1, x2, y2));\n        } else {\n            double deltaX = x2 - x1;\n            double deltaY = y2 - y1;\n            \n            double sx = x1 + deltaX / 3;\n            double sy = y1 + deltaY / 3;\n\n            double tx = x1 + 2 * deltaX / 3;\n            double ty = y1 + 2 * deltaY / 3;\n\n            double uX = sx + (tx - sx) * Math.cos(Math.PI / 3) - (ty - sy) * Math.sin(Math.PI / 3);\n            double uY = sy + (tx - sx) * Math.sin(Math.PI / 3) + (ty - sy) * Math.cos(Math.PI / 3);\n\n            drawKochCurve(g, x1, y1, sx, sy, depth - 1);\n            drawKochCurve(g, sx, sy, uX, uY, depth - 1);\n            drawKochCurve(g, uX, uY, tx, ty, depth - 1);\n            drawKochCurve(g, tx, ty, x2, y2, depth - 1);\n        }\n    }\n\n    @Override\n    protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        drawKochCurve(g2, START_X, START_Y, END_X, END_Y, depth);\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(PANEL_WIDTH, PANEL_HEIGHT);\n    }\n\n    public static void main(String[] args) {\n        int n = Integer.parseInt(JOptionPane.showInputDialog(\"Enter the depth of the Koch curve:\"));\n        JFrame frame = new JFrame(\"Koch Curve\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.add(new KochCurve(n));\n        frame.pack();\n        frame.setLocationRelativeTo(null);\n        frame.setVisible(true);\n    }\n}",
    "timestamp": "2025-08-13 09:28:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nvoid draw_line(Point p1, Point p2) {\n    printf(\"Line from (%.2f, %.2f) to (%.2f, %.2f)\\n\", p1.x, p1.y, p2.x, p2.y);\n}\n\nvoid koch_curve(Point p1, Point p2, int depth) {\n    if (depth == 0) {\n        draw_line(p1, p2);\n    } else {\n        double dx = (p2.x - p1.x) / 3.0;\n        double dy = (p2.y - p1.y) / 3.0;\n        \n        Point s = {p1.x + dx, p1.y + dy};\n        Point t = {p1.x + 2 * dx, p1.y + 2 * dy};\n        \n        Point u = {s.x + (t.x - s.x) / 2 - sqrt(3) * (t.y - s.y) / 2,\n                   s.y + (t.y - s.y) / 2 + sqrt(3) * (t.x - s.x) / 2};\n        \n        koch_curve(p1, s, depth - 1);\n        koch_curve(s, u, depth - 1);\n        koch_curve(u, t, depth - 1);\n        koch_curve(t, p2, depth - 1);\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Enter the depth n: \");\n    scanf(\"%d\", &n);\n    \n    Point p1 = {0.0, 0.0};\n    Point p2 = {100.0, 0.0};\n    \n    koch_curve(p1, p2, n);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 09:28:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import turtle\nimport math\n\ndef koch_curve(t, order, size):\n    if order == 0:\n        t.forward(size)\n    else:\n        angle = 60\n        for turn in [1, -2, 1]:\n            koch_curve(t, order-1, size/3)\n            t.left(angle * turn)\n\ndef main():\n    n = int(input(\"Enter the order of Koch curve: \"))\n    \n    window = turtle.Screen()\n    window.setup(800, 600)\n    window.title(\"Koch Curve\")\n    \n    t = turtle.Turtle()\n    t.speed(0)\n    t.penup()\n    t.goto(-100, 0)\n    t.pendown()\n    \n    koch_curve(t, n, 200)\n    \n    window.exitonclick()\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:28:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import turtle\n\ndef koch_curve(t, length, depth):\n    if depth == 0:\n        t.forward(length)\n    else:\n        koch_curve(t, length / 3, depth - 1)\n        t.left(60)\n        koch_curve(t, length / 3, depth - 1)\n        t.right(120)\n        koch_curve(t, length / 3, depth - 1)\n        t.left(60)\n        koch_curve(t, length / 3, depth - 1)\n\ndef main():\n    n = int(input())\n    t = turtle.Turtle()\n    screen = turtle.Screen()\n    t.speed(0)\n    t.penup()\n    t.goto(-150, 0)\n    t.pendown()\n    koch_curve(t, 300, n)\n    screen.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:28:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nstruct Point {\n    double x, y;\n};\n\nvoid drawKochCurve(Point p1, Point p2, int depth) {\n    if (depth == 0) {\n        std::cout << p1.x << \" \" << p1.y << \" \" << p2.x << \" \" << p2.y << std::endl;\n    } else {\n        double oneThird = 1.0 / 3.0;\n        Point s = {p1.x + oneThird * (p2.x - p1.x), p1.y + oneThird * (p2.y - p1.y)};\n        Point t = {p1.x + 2 * oneThird * (p2.x - p1.x), p1.y + 2 * oneThird * (p2.y - p1.y)};\n        \n        double angle = M_PI / 3;\n        Point u = {s.x + cos(angle) * (t.x - s.x) - sin(angle) * (t.y - s.y),\n                   s.y + sin(angle) * (t.x - s.x) + cos(angle) * (t.y - s.y)};\n        \n        drawKochCurve(p1, s, depth - 1);\n        drawKochCurve(s, u, depth - 1);\n        drawKochCurve(u, t, depth - 1);\n        drawKochCurve(t, p2, depth - 1);\n    }\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    Point p1 = {0.0, 0.0};\n    Point p2 = {100.0, 0.0};\n\n    drawKochCurve(p1, p2, n);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:51:40"
  }
]