[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint visited[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N];\nint N, K;\n\nvoid addEdge(int u, int v) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = graph[u];\n    graph[u] = newNode;\n}\n\nint findFarthestNode(int start, int* maxDistance) {\n    memset(visited, 0, sizeof(visited));\n    memset(depth, 0, sizeof(depth));\n    \n    int queue[MAX_N];\n    int front = 0, rear = 0;\n    queue[rear++] = start;\n    visited[start] = 1;\n    *maxDistance = 0;\n    int farthestNode = start;\n    \n    while (front < rear) {\n        int current = queue[front++];\n        \n        for (Node* neighbor = graph[current]; neighbor; neighbor = neighbor->next) {\n            int v = neighbor->vertex;\n            if (!visited[v]) {\n                visited[v] = 1;\n                depth[v] = depth[current] + 1;\n                queue[rear++] = v;\n                \n                if (depth[v] > *maxDistance) {\n                    *maxDistance = depth[v];\n                    farthestNode = v;\n                }\n            }\n        }\n    }\n    \n    return farthestNode;\n}\n\nint findDiameter() {\n    int maxDistance1 = 0, maxDistance2 = 0;\n    int node1 = findFarthestNode(1, &maxDistance1);\n    int node2 = findFarthestNode(node1, &maxDistance2);\n    \n    return maxDistance2;\n}\n\nint minimumVertexRemoval() {\n    int diameter = findDiameter();\n    \n    if (diameter <= K) return 0;\n    \n    int result = (diameter + K - 1) / K;\n    return result;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    \n    for (int i = 1; i < N; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n    \n    printf(\"%d\\n\", minimumVertexRemoval());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 2005\n\nint N, K;\nint adj[MAX_N][MAX_N];\nint adj_size[MAX_N];\nint depth[MAX_N];\nint parent[MAX_N];\nint marked[MAX_N];\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    for (int i = 0; i < adj_size[u]; ++i) {\n        int v = adj[u][i];\n        if (v != p) {\n            depth[v] = depth[u] + 1;\n            dfs(v, u);\n        }\n    }\n}\n\nint find_furthest(int start) {\n    memset(depth, 0, sizeof(depth));\n    dfs(start, -1);\n    int furthest = start;\n    for (int i = 1; i <= N; ++i) {\n        if (depth[i] > depth[furthest]) {\n            furthest = i;\n        }\n    }\n    return furthest;\n}\n\nvoid mark_path(int u, int v) {\n    while (u != v) {\n        if (depth[u] < depth[v]) {\n            marked[v] = 1;\n            v = parent[v];\n        } else {\n            marked[u] = 1;\n            u = parent[u];\n        }\n    }\n    marked[u] = 1;\n}\n\nint count_marked_children(int u, int p) {\n    int count = 0;\n    for (int i = 0; i < adj_size[u]; ++i) {\n        int v = adj[u][i];\n        if (v != p && marked[v]) {\n            count += 1 + count_marked_children(v, u);\n        }\n    }\n    return count;\n}\n\nint solve() {\n    if (N == 1) return 0;\n    int u = find_furthest(1);\n    int v = find_furthest(u);\n    int diameter = depth[v];\n    if (diameter <= K) return 0;\n\n    memset(marked, 0, sizeof(marked));\n    mark_path(u, v);\n\n    int center = -1;\n    for (int i = 1; i <= N; ++i) {\n        if (marked[i]) {\n            int max_depth = 0;\n            for (int j = 1; j <= N; ++j) {\n                if (marked[j]) {\n                    memset(depth, 0, sizeof(depth));\n                    dfs(j, -1);\n                    int current_max = 0;\n                    for (int k = 1; k <= N; ++k) {\n                        if (marked[k] && depth[k] > current_max) {\n                            current_max = depth[k];\n                        }\n                    }\n                    if (current_max > max_depth) {\n                        max_depth = current_max;\n                    }\n                }\n            }\n            if (max_depth <= K / 2) {\n                center = i;\n                break;\n            }\n        }\n    }\n\n    if (center == -1) {\n        for (int i = 1; i <= N; ++i) {\n            if (marked[i]) {\n                center = i;\n                break;\n            }\n        }\n    }\n\n    memset(marked, 0, sizeof(marked));\n    marked[center] = 1;\n    for (int i = 0; i < adj_size[center]; ++i) {\n        int child = adj[center][i];\n        if (depth[child] < depth[center]) {\n            continue;\n        }\n        marked[child] = 1;\n    }\n\n    int total_marked = 1 + count_marked_children(center, -1);\n    return N - total_marked;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adj[u][adj_size[u]++] = v;\n        adj[v][adj_size[v]++] = u;\n    }\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> depth;\nint N, K;\n\nvoid dfs(int u, int parent) {\n    depth[u] = 0;\n    int max1 = -1, max2 = -1;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs(v, u);\n        if (depth[v] > max1) {\n            max2 = max1;\n            max1 = depth[v];\n        } else if (depth[v] > max2) {\n            max2 = depth[v];\n        }\n    }\n    if (max1 != -1) depth[u] = max1 + 1;\n    if (max2 != -1 && max1 + max2 + 2 > K) {\n        depth[u] = max2;\n        N--;\n    }\n}\n\nint main() {\n    cin >> N >> K;\n    adj.resize(N);\n    depth.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    int res = 0;\n    for (int i = 0; i < N; ++i) {\n        if (adj[i].size() == 1) {\n            dfs(i, -1);\n            break;\n        }\n    }\n    cout << N - res - 1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static List<Integer>[] tree;\n    static int K;\n    static int result = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        K = scanner.nextInt();\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            tree[u].add(v);\n            tree[v].add(u);\n        }\n\n        int minRemovals = Integer.MAX_VALUE;\n        for (int root = 1; root <= N; root++) {\n            result = 0;\n            dfs(root, -1);\n            if (result < minRemovals) {\n                minRemovals = result;\n            }\n        }\n        System.out.println(minRemovals);\n    }\n\n    private static int dfs(int node, int parent) {\n        int maxDepth = 0;\n        PriorityQueue<Integer> depths = new PriorityQueue<>(Collections.reverseOrder());\n        for (int child : tree[node]) {\n            if (child != parent) {\n                int depth = dfs(child, node) + 1;\n                depths.add(depth);\n            }\n        }\n\n        if (depths.isEmpty()) {\n            return 0;\n        }\n\n        maxDepth = depths.poll();\n        while (!depths.isEmpty()) {\n            int current = depths.poll();\n            if (maxDepth + current > K) {\n                result++;\n            } else {\n                depths.add(current);\n                break;\n            }\n        }\n\n        return maxDepth;\n    }\n}",
    "timestamp": "2025-08-05 23:38:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private List<List<Integer>> graph;\n    private int N, K;\n\n    public int minimumVertexRemoval(int N, int K, int[][] edges) {\n        graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0] - 1).add(edge[1] - 1);\n            graph.get(edge[1] - 1).add(edge[0] - 1);\n        }\n        \n        int minRemoval = N;\n        for (int root = 0; root < N; root++) {\n            minRemoval = Math.min(minRemoval, calculateMinRemoval(root));\n        }\n        \n        return minRemoval;\n    }\n    \n    private int calculateMinRemoval(int root) {\n        int[] depths = new int[N];\n        dfs(root, -1, depths, 0);\n        \n        int longestPath = findLongestPath(depths);\n        if (longestPath <= K) return 0;\n        \n        int[] removalCount = new int[N];\n        return findMinRemoval(root, -1, longestPath, removalCount);\n    }\n    \n    private void dfs(int node, int parent, int[] depths, int depth) {\n        depths[node] = depth;\n        for (int neighbor : graph.get(node)) {\n            if (neighbor != parent) {\n                dfs(neighbor, node, depths, depth + 1);\n            }\n        }\n    }\n    \n    private int findLongestPath(int[] depths) {\n        int maxDepth = 0;\n        for (int depth : depths) {\n            maxDepth = Math.max(maxDepth, depth);\n        }\n        return maxDepth * 2;\n    }\n    \n    private int findMinRemoval(int node, int parent, int longestPath, int[] removalCount) {\n        List<Integer> childrenRemoval = new ArrayList<>();\n        int maxSubtreeDepth = 0;\n        \n        for (int child : graph.get(node)) {\n            if (child != parent) {\n                int subtreeResult = findMinRemoval(child, node, longestPath, removalCount);\n                childrenRemoval.add(subtreeResult);\n                maxSubtreeDepth = Math.max(maxSubtreeDepth, removalCount[child]);\n            }\n        }\n        \n        if (maxSubtreeDepth * 2 <= longestPath) {\n            removalCount[node] = maxSubtreeDepth + 1;\n            return 0;\n        }\n        \n        Collections.sort(childrenRemoval);\n        int totalRemoval = 0;\n        int currentPathLength = 0;\n        \n        for (int removal : childrenRemoval) {\n            if (currentPathLength * 2 + 2 > longestPath) {\n                totalRemoval += removal + 1;\n            } else {\n                currentPathLength++;\n                totalRemoval += removal;\n            }\n        }\n        \n        return totalRemoval;\n    }\n}",
    "timestamp": "2025-08-05 23:38:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> graph[MAXN];\nint dist[MAXN];\nbool removed[MAXN];\n\npair<int, int> bfs(int start, int n) {\n    memset(dist, -1, sizeof(dist));\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    int maxDist = 0, furthestNode = start;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        for (int neighbor : graph[curr]) {\n            if (dist[neighbor] == -1 && !removed[neighbor]) {\n                dist[neighbor] = dist[curr] + 1;\n                q.push(neighbor);\n\n                if (dist[neighbor] > maxDist) {\n                    maxDist = dist[neighbor];\n                    furthestNode = neighbor;\n                }\n            }\n        }\n    }\n\n    return {furthestNode, maxDist};\n}\n\nint getDiameter(int n) {\n    auto [furthest1, _] = bfs(1, n);\n    auto [furthest2, diameter] = bfs(furthest1, n);\n    return diameter;\n}\n\nint minimumVerticesRemoval(int n, int k) {\n    int removedCount = 0;\n\n    while (getDiameter(n) > k) {\n        int diameter = getDiameter(n);\n        int furthest1 = bfs(1, n).first;\n        auto [furthest2, _] = bfs(furthest1, n);\n\n        int curr = furthest2;\n        int steps = diameter / 2;\n\n        while (steps--) {\n            for (int neighbor : graph[curr]) {\n                if (dist[neighbor] == dist[curr] - 1 && !removed[neighbor]) {\n                    curr = neighbor;\n                    break;\n                }\n            }\n        }\n\n        removed[curr] = true;\n        removedCount++;\n    }\n\n    return removedCount;\n}",
    "timestamp": "2025-08-05 23:38:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def tree_diameter(tree, n):\n    def bfs(start):\n        dist = [-1] * n\n        dist[start] = 0\n        queue = [start]\n        max_dist = (0, start)\n        for node in queue:\n            for neighbor in tree[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + 1\n                    queue.append(neighbor)\n                    if dist[neighbor] > max_dist[0]:\n                        max_dist = (dist[neighbor], neighbor)\n        return max_dist\n    \n    initial_node = 0\n    farest_node = bfs(initial_node)[1]\n    diameter_length = bfs(farest_node)[0]\n    return diameter_length\n\ndef min_removals_to_good_tree(n, k, edges):\n    if n <= 1 or k >= n - 1:\n        return 0\n        \n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n        \n    def dfs(node, parent):\n        depths = []\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            depths.append(dfs(neighbor, node) + 1)\n        if not depths:\n            return 0\n        depths.sort(reverse=True)\n        if len(depths) >= 2 and depths[0] + depths[1] > k:\n            cut_subtrees[0] += 1\n            return -1\n        return depths[0]\n    \n    cut_subtrees = [0]\n    dfs(0, -1)\n    \n    if tree_diameter(tree, n) <= k:\n        return 0\n        \n    return cut_subtrees[0]\n\n# Example Input:\nN = 7\nK = 3\nedges = [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)]\n\n# Example Usage:\nresult = min_removals_to_good_tree(N, K, edges)\nprint(result)  # Output will depend on the input given",
    "timestamp": "2025-08-13 16:28:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class GoodTree {\n    static List<Integer>[] adj;\n    static int N, K;\n    static int[] dist;\n\n    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        K = scanner.nextInt();\n        \n        adj = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        \n        scanner.close();\n\n        int minRemove = binarySearch(0, N, K);\n        System.out.println(minRemove);\n    }\n    \n    static int binarySearch(int low, int high, int K) {\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (canReduceDiameter(mid, K)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    \n    static boolean canReduceDiameter(int removeLimit, int K) {\n        dist = new int[N];\n        if (dfs(0, -1, removeLimit) <= K) return true;\n        return false;\n    }\n    \n    static int dfs(int u, int parent, int removeLimit) {\n        int max1 = 0, max2 = 0, subTreeSize = 1;\n        \n        for (int v : adj[u]) {\n            if (v == parent) continue;\n            int subtreeDist = dfs(v, u, removeLimit) + 1;\n            subTreeSize += subtreeDist;\n            \n            if (subtreeDist > max1) {\n                max2 = max1;\n                max1 = subtreeDist;\n            } else if (subtreeDist > max2) {\n                max2 = subtreeDist;\n            }\n        }\n        \n        if (max1 + max2 <= removeLimit) return subTreeSize - 1;\n        if (max1 <= removeLimit / 2) return -1; // prune the search\n        return Math.min(removeLimit, subTreeSize);\n    }\n}",
    "timestamp": "2025-08-13 16:29:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N];\nint edge_count;\nint N, K;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nint queue[MAX_N], dist[MAX_N];\n\nvoid bfs(int start, int *farthest_node, int *max_dist) {\n    int front = 0, rear = 0;\n    memset(dist, -1, sizeof(dist));\n    \n    dist[start] = 0;\n    queue[rear++] = start;\n    \n    *farthest_node = start;\n    *max_dist = 0;\n    \n    while (front < rear) {\n        int node = queue[front++];\n        if (dist[node] > *max_dist) {\n            *max_dist = dist[node];\n            *farthest_node = node;\n        }\n        for (int i = head[node]; i != -1; i = edges[i].next) {\n            int to = edges[i].to;\n            if (dist[to] == -1) {\n                dist[to] = dist[node] + 1;\n                queue[rear++] = to;\n            }\n        }\n    }\n}\n\nint calculate_diameter() {\n    int farthest_node, max_dist;\n    bfs(0, &farthest_node, &max_dist);\n    bfs(farthest_node, &farthest_node, &max_dist);\n    return max_dist;\n}\n\nint solve() {\n    if (calculate_diameter() <= K) return 0;\n\n    int left = 1, right = N - 1, answer = N - 1;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = head[i]; j != -1; j = edges[j].next) {\n                int backup = head[i];\n                head[i] = edges[j].next;\n                \n                if (calculate_diameter() <= K) {\n                    answer = mid;\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n                head[i] = backup;\n            }\n        }\n    }\n    \n    return answer;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &K);\n    \n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        --u; --v;\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    \n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-13 16:29:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> height, subtreeSize;\nint N, K;\n\nvoid dfs(int node, int parent) {\n    height[node] = 0;\n    subtreeSize[node] = 1;\n    for (int neighbor : tree[node]) {\n        if (neighbor == parent) continue;\n        dfs(neighbor, node);\n        subtreeSize[node] += subtreeSize[neighbor];\n        height[node] = max(height[node], height[neighbor] + 1);\n    }\n}\n\nint findMaxHeightNode(int start) {\n    queue<int> q;\n    q.push(start);\n    vector<int> dist(N, -1);\n    dist[start] = 0;\n\n    int farthestNode = start;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : tree[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n                if (dist[neighbor] > dist[farthestNode]) {\n                    farthestNode = neighbor;\n                }\n            }\n        }\n    }\n    \n    return farthestNode;\n}\n\nint diameter() {\n    int farthestNode = findMaxHeightNode(0);\n    int opposite = findMaxHeightNode(farthestNode);\n    \n    queue<int> q;\n    q.push(farthestNode);\n    vector<int> dist(N, -1);\n    dist[farthestNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : tree[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return dist[opposite];\n}\n\nint minimalRemoval() {\n    if (diameter() <= K) return 0;\n\n    int best = N;\n    for (int root = 0; root < N; ++root) {\n        dfs(root, -1);\n        if (height[root] <= K / 2) continue;\n        \n        vector<int> toCheck;\n        for (int neighbor : tree[root]) {\n            if (height[neighbor] + 1 == height[root]) {\n                toCheck.push_back(subtreeSize[neighbor]);\n            }\n        }\n        \n        sort(toCheck.begin(), toCheck.end(), greater<int>());\n        \n        int toRemove = 0, accum = 0;\n        for (int size : toCheck) {\n            accum += size;\n            ++toRemove;\n            if (height[root] - accum <= K / 2) {\n                break;\n            }\n        }\n        best = min(best, toRemove);\n    }\n    return best;\n}\n\nint main() {\n    cin >> N >> K;\n    tree.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n\n    height.resize(N);\n    subtreeSize.resize(N);\n\n    cout << minimalRemoval() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:29:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef build_graph(N, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    return graph\n\ndef find_farthest_node(graph, start):\n    N = len(graph)\n    dist = [-1] * (N + 1)\n    dist[start] = 0\n    queue = deque([start])\n    max_dist = 0\n    max_node = start\n\n    while queue:\n        curr = queue.popleft()\n        for neighbor in graph[curr]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[curr] + 1\n                queue.append(neighbor)\n                if dist[neighbor] > max_dist:\n                    max_dist = dist[neighbor]\n                    max_node = neighbor\n\n    return max_node, max_dist\n\ndef calculate_diameter(graph):\n    first_end, _ = find_farthest_node(graph, 1)\n    second_end, diameter = find_farthest_node(graph, first_end)\n    return diameter\n\ndef min_vertices_to_remove(N, K, edges):\n    graph = build_graph(N, edges)\n    \n    if calculate_diameter(graph) <= K:\n        return 0\n    \n    min_removed = float('inf')\n    \n    for remove_node in range(1, N + 1):\n        reduced_graph = defaultdict(list)\n        for u, v in graph.items():\n            if u != remove_node:\n                reduced_graph[u] = [neighbor for neighbor in v if neighbor != remove_node]\n        \n        if calculate_diameter(reduced_graph) <= K:\n            min_removed = min(min_removed, 1)\n    \n    if min_removed != float('inf'):\n        return min_removed\n    \n    return -1",
    "timestamp": "2025-08-13 16:30:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, K = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    min_removal = N  # Initialize with worst case\n    \n    if K % 2 == 0:\n        radius = K // 2\n        for center in range(N):\n            q = deque()\n            visited = [False] * N\n            q.append((center, 0))\n            visited[center] = True\n            count = 0\n            while q:\n                node, dist = q.popleft()\n                if dist > radius:\n                    continue\n                count += 1\n                for neighbor in adj[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        q.append((neighbor, dist + 1))\n            min_removal = min(min_removal, N - count)\n    else:\n        radius = K // 2\n        for u in range(N):\n            for v in adj[u]:\n                if v > u:  # To avoid duplicate processing of edges\n                    q = deque()\n                    visited = [False] * N\n                    q.append((u, 0))\n                    q.append((v, 0))\n                    visited[u] = True\n                    visited[v] = True\n                    count = 0\n                    while q:\n                        node, dist = q.popleft()\n                        if dist > radius:\n                            continue\n                        count += 1\n                        for neighbor in adj[node]:\n                            if not visited[neighbor]:\n                                visited[neighbor] = True\n                                q.append((neighbor, dist + 1))\n                    min_removal = min(min_removal, N - count)\n    \n    print(min_removal)\n\nsolve()",
    "timestamp": "2025-08-13 16:30:17"
  }
]