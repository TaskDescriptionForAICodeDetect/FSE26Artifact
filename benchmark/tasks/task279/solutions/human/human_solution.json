[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\ntypedef tuple<int, int, int> tiii;\nconst int INF = 1000000000;\n\nstruct Random {\n\tint a, b, C, M;\n\tRandom(int A, int B) : a(A), b(B), C(~(1 << 31)), M((1 << 16) - 1) { }\n\tint operator()(){\n\t\ta = 36969 * (a & M) + (a >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint m, n, A, B;\n\t\tcin >> m >> n >> A >> B;\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0){ break; }\n\t\tn += m;\n\t\tvector<tiii> p(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tRandom random(A, B);\n\t\tfor(int i = m; i < n; ++i){\n\t\t\tconst int x = random();\n\t\t\tconst int y = random();\n\t\t\tconst int z = random();\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tvector< map<int, int> > vm(n + 1);\n\t\tfor(auto &v : vm){ v.insert(make_pair(-INF, INF)); }\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < n; ){\n\t\t\tconst int x = get<0>(p[i]);\n\t\t\tvector<tiii> t;\n\t\t\twhile(i < n && get<0>(p[i]) == x){\n\t\t\t\tconst int y = get<1>(p[i]);\n\t\t\t\tconst int z = get<2>(p[i]);\n\t\t\t\tint l = 0, r = n;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tconst int c = l + (r - l) / 2;\n\t\t\t\t\tauto it = vm[c].lower_bound(y);\n\t\t\t\t\tif((--it)->second >= z){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = c + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.emplace_back(l, y, z);\n\t\t\t\tanswer = max(answer, l + 1);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tfor(const auto &e : t){\n\t\t\t\tconst int k = get<0>(e);\n\t\t\t\tconst int y = get<1>(e);\n\t\t\t\tconst int z = get<2>(e);\n\t\t\t\tauto it = vm[k].upper_bound(y);\n\t\t\t\t--it;\n\t\t\t\tif(it->second <= z){ continue; }\n\t\t\t\tif(it->first < y){ ++it; }\n\t\t\t\twhile(it != vm[k].end()){\n\t\t\t\t\tif(it->second < z){ break; }\n\t\t\t\t\tvm[k].erase(it++);\n\t\t\t\t}\n\t\t\t\tvm[k].insert(make_pair(y, z));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) delete lch, rch;\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) delete lch, rch;\n\t\tdelete st;\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[500000];\nint anss[500010];\nmap<pair<int, int>, int> calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced[make_pair(1e+9, 1e+9)] = 0;\n        calced[make_pair(-1e+9, -1e+9)] = 0;\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n);\n        // int sqn = 10000;\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced[make_pair(ps[pos][1], ps[pos][2])] = anss[pos];\n            }\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker,\"/STACK:102400000,102400000\")\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LL, int> PLI;\ntypedef pair<LD, LD> PDD;\n#define MP make_pair\n#define PB push_back\n#define sz(x) ((int)(x).size())\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define forIt(mp,it) for(__typeof(mp.begin()) it = mp.begin();it!=mp.end();it++)\nconst double PI = acos(-1.0);\n\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define lowbit(u) (u&(-u))\n\nusing namespace std;\n\nint m,n,A,B,C,M;\n\nstruct Chain{\n\tint x,y,z,idx;\n\tbool operator<(const Chain& c) const{\n\t\tif(x==c.x){\n\t\t\tif(y==c.y) return z>c.z;\n\t\t\telse return y>c.y;\n\t\t}\n\t\treturn x<c.x;\n\t}\n} p[300005],pa[300005],pb[300005];\n\nint cmp1(const Chain& c1,const Chain& c2){\n\treturn c1.y<c2.y;\n}\n\nint r(){\n\tA = 36969*(A&M)+(A>>16);\n\tB = 18000*(B&M)+(B>>16);\n\treturn (C&(A<<16)+B)%1000000;\n}\n\nint mx[1000005];\n\nvoid add(int u,int v){\n\tfor(int i = u;i<=1000000;i+=lowbit(i)) mx[i] = max(mx[i],v);\n}\n\nint query(int u){\n\tint ans = 0;\n\tfor(int i = u;i;i-=lowbit(i)) ans = max(ans,mx[i]);\n\treturn ans;\n}\n\nvoid rm(int u){\n\tfor(int i = u;i<=1000000;i+=lowbit(i)) mx[i] = 0;\n}\n\nint ret[300005];\n\nint solve(int l,int r){\n\tif(l==r) return 1;\n\tint mid = (l+r)>>1;\n\tint ans = solve(l,mid);\n\tint c1 = 0,c2 = 0;\n\tfor(int i = l;i<=mid;i++) pa[c1++] = p[i];\n\tfor(int i = mid+1;i<=r;i++) pb[c2++] = p[i];\n\tsort(pa,pa+c1,cmp1);\n\tsort(pb,pb+c2,cmp1);\n\tint j = 0;\n\tfor(int i = 0;i<c2;i++){\n\t\tfor(;j<c1;j++){\n\t\t\tif(pb[i].y<=pa[j].y) break;\n\t\t\tadd(pa[j].z,ret[pa[j].idx]);\n\t\t}\n\t\tret[pb[i].idx] = max(ret[pb[i].idx],query(pb[i].z-1)+1);\n\t\tans = max(ans,ret[pb[i].idx]);\n\t}\n\tfor(int j = 0;j<c1;j++) rm(pa[j].z);\n\tans = max(ans,solve(mid+1,r));\n\treturn ans;\n}\n\nint main(void){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"/Users/mac/Desktop/data.in\",\"r\",stdin);\n#endif\n\tC = ~(1<<31),M = (1<<16)-1;\n\twhile(scanf(\"%d %d %d %d\",&m,&n,&A,&B),m+n+A+B){\n\t\tfor(int i = 0;i<m;i++) scanf(\"%d %d %d\",&p[i].x,&p[i].y,&p[i].z);\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tp[i+m].x = r();\n\t\t\tp[i+m].y = r();\n\t\t\tp[i+m].z = r();\n\t\t}\n\t\tn+=m;\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tp[i].idx = i,ret[i] = 1,p[i].z++;\n\t\t}\n\t\tsort(p,p+n);\n\t\tint ans = solve(0,n-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10, inf = 1e9;\n\nstruct Node {\n    PII e;\n    Node *ls, *rs;\n    int dim, cur, sub;\n} pool[MAXN], *cnt;\n\nstruct Point {\n    int x, y, z;\n    Point() {}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} P[MAXN];\n\nmap<int, int> best[MAXN];\nint dp[MAXN], ret;\n\nint r(int &a, int &b) {\n    static const int C = ~(1 << 31), M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const map<int, int> &mp, int x, int y) {\n    auto it = mp.lower_bound(x);\n    return it != mp.begin() && (-- it)->second < y;\n}\n\nint query(int x, int y) {\n    int left = 0, right = ret;\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(best[mid], x, y)) left = mid;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nvoid update(map<int, int> &mp, int x, int y) {\n    auto it = mp.upper_bound(x);\n    if (it != mp.begin() && (-- it)->second <= y) return;\n    it = mp.lower_bound(x);\n    while (it != mp.end() && it->second >= y) mp.erase(it ++);\n    mp[x] = y;\n}\n\nint main() {\n    int N, M, A, B;\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &P[i].x, &P[i].y, &P[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            P[i].x = r(A, B);\n            P[i].y = r(A, B);\n            P[i].z = r(A, B);\n        }\n        for (int i = 0; i <= N; ++ i) best[i].clear();\n        sort(P, P + N);\n        ret = 0;\n        for (int i = 0, j; i < N;) {\n            for (j = i; j < N && P[i].x == P[j].x; ++ j) dp[j] = query(P[i].y, P[i].z) + 1;\n            for (; i < j; ++ i) {\n                update(best[dp[i]], P[i].y, P[i].z);\n                ret = max(ret, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\ntypedef long long ll;\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n\n// must template\ntypedef ll D;\nconst D INF = 1LL<<58,EPS = 1;\n\ntypedef tuple<D,D,D> P;\n\nistream& operator >> (istream& is,P& p){D x,y,z;is >> x >> y>>z; p=P(x,y,z); return is;}\n\nint sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\nbool eq(D a,D b){return sig(a-b)==0;}\nbool eq(const P& a,const P& b){\n\treturn sig(get<0>(a)-get<0>(b))==0\n\t&& sig(get<1>(a)-get<1>(b))==0\n\t&& sig(get<2>(a)-get<2>(b))==0;\n}\nbool compX (const P& a,const P& b){\n\treturn !eq(get<0>(a),get<0>(b))?sig(get<0>(a),get<0>(b))<0:\n\t\t!eq(get<1>(a),get<1>(b))?sig(get<1>(a),get<1>(b))<0:\n\t\tsig(get<2>(a),get<2>(b))<0;\n}\n\n// //must template\n\n\nvector<int> dp;\n\n// 挿入 O(logn) 検索 O(logn)\n// [lx,rx)×[ly,ry) 範囲内の点を返す．\n// (x座標の探索とy座標の探索を交互に行う．)\n// kd tree\n// ! no check\nstruct kdtree {\n\tstruct node {\n\t\tP p;int i;\n\t\tnode *l, *r;\n\t\tnode(const P &p,int i): p(p),i(i), l(NULL), r(NULL) { }\n\t} *root;\n\tkdtree() : root(NULL) { }\n\n\tbool compare(int d,const P&p,const P& q){\n\t\tif(d==0) return get<0>(p) < get<0>(q);\n\t\tif(d==1) return get<1>(p) < get<1>(q);\n\t\tif(d==2) return get<2>(p) < get<2>(q);\n\t\tassert(false);\n\t}\n\tvoid insert(const P &p,int i) {root = insert(root, 0, p,i);}\n\tnode *insert(node *t, int d, const P &p,int i) {\n\t\tif (t == NULL) return new node(p,i);\n\t\tif (compare(d,p,t->p)) t->l = insert(t->l,(d+1)%3, p,i);\n\t\telse                   t->r = insert(t->r,(d+1)%3, p,i);\n\t\treturn t;\n\t}\n\tvoid search(const P &ld, const P &ru,int& out) { search(root, 0, ld, ru, out);}\n\tvoid search(node *t,int d, const P &ld, const P &ru,int& out) {\n\t\tif (t == NULL) return;\n\t\tconst P &p = t->p;\n\t\tif(IN(get<0>(ld),get<0>(p),get<0>(ru)) && IN(get<1>(ld),get<1>(p),get<1>(ru)) && IN(get<2>(ld),get<2>(p),get<2>(ru))){\n\t\t\tif(out==-1 || dp[t->i]>dp[out])out=t->i;\n\t\t}\n\t\tif (!compare(d,p,ld)) search(t->l,(d+1)%3, ld, ru, out);\n\t\tif (!compare(d,ru,p)) search(t->r,(d+1)%3, ld, ru, out);\n\t}\n};\n\nint m,n,A,B;\n\nint a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nint main() {\n\twhile(true){\n\t\tcin >> m >> n >> A >> B;if(m+n==0)break;\n\t\tvector<P> ps(m+n);\n\t\tREP(i,m)cin >> ps[i];\n\t\ta=A;b=B;\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tD x=r(),y=r(),z=r();\n\t\t\tps[i]=P(x,y,z);\n\t\t}\n\t\tsort(ALL(ps),compX);\n\t\t// REP(i,m+n)cout << ps[i]<<endl;\n\n\t\tdp=vector<int>(m+n,1);\n\t\tkdtree kd;\n\t\tREP(i,m+n)kd.insert(ps[i],i);\n\t\tREP(i,m+n){\n\t\t\tint j=-1;kd.search(P(0,0,0),ps[i],j);\n\t\t\tif(j!=-1)dp[i]=max(dp[i],dp[j]+1);\n\t\t}\n\t\tcout << *max_element(ALL(dp)) <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define fi first\n#define se second\n\nconst int INF = 1 << 28;\n\ntypedef pair<int, int> pr;\ntypedef tuple<int, int, int> tp;\n\nint a_, b_, C_ = ~(1<<31), M_ = (1<<16)-1;\nint r_() {\n  a_ = 36969 * (a_ & M_) + (a_ >> 16);\n  b_ = 18000 * (b_ & M_) + (b_ >> 16);\n  return (C_ & ((a_ << 16) + b_)) % 1000000;\n}\n\nvector<tp> ps;\n\nint solve()\n{\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\tsort(begin(ps), end(ps));\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\t\n\tvector<set<pr>> sts(ps.size() + 10);\n\tfor (auto &st : sts){\n\t\tst.insert(pr(-INF, INF));\n\t\tst.insert(pr(INF, -INF));\n\t}\n\t\n\tint res = 0;\n\trep(i, ps.size()){\n\t\tint x, y, z;\n\t\ttie(x, y, z) = ps[i];\n\t\tint l = 0, r = ps.size();\n\t\twhile (l + 1 < r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tauto it = --sts[m].upper_bound(pr(y, z));\n\t\t\tif (it->se <= z) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\twhile (true){\n\t\t\tauto it = sts[r].lower_bound(pr(y, z));\n\t\t\tif (it->se < z) break;\n\t\t\tsts[r].erase(it);\n\t\t}\n\t\tsts[r].insert(pr(y, z));\n\t\tres = max(res, r);\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n >> a_ >> b_, m + n){\n\t\tps.clear();\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\trep(i, n){\n\t\t\tint x = r_(), y = r_(), z = r_();\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10, inf = 1e9;\n\nstruct Tuple {\n    int x, y, z;\n    Tuple() {}\n    Tuple(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Tuple &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} P[MAXN];\n\nstruct Point {\n    int x, y;\n    Point() {}\n    Point(int _x, int _y) : x(_x), y(_y) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y);\n    }\n};\n\nset<Point> best[MAXN];\nint dp[MAXN], ret;\n\nint r(int &a, int &b) {\n    static const int C = ~(1u << 31), M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const set<Point> &S, int x, int y) {\n    auto it = S.lower_bound(Point(x, y));\n    return it != S.begin() && (-- it)->y < y;\n}\n\nint query(int x, int y) {\n    int left = 0, right = ret;\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(best[mid], x, y)) left = mid;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nvoid update(set<Point> &S, int x, int y) {\n    auto it = S.lower_bound(Point(x, y));\n    if (it != S.begin() && (-- it)->y <= y) return;\n    S.insert(Point(x, y)); it = S.upper_bound(Point(x, y));\n    for (; it != S.end() && it->y >= y; ) S.erase(it ++);\n}\n\nint main() {\n    int N, M, A, B;\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &P[i].x, &P[i].y, &P[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            P[i].x = r(A, B);\n            P[i].y = r(A, B);\n            P[i].z = r(A, B);\n        }\n        for (int i = 0; i <= N; ++ i) best[i].clear();\n        sort(P, P + N);\n        ret = 0;\n        for (int i = 0, j; i < N;) {\n            for (j = i; j < N && P[i].x == P[j].x; ++ j) dp[j] = query(P[j].y, P[j].z) + 1;\n            for (; i < j; ++ i) {\n                update(best[dp[i]], P[i].y, P[i].z);\n                ret = max(ret, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nusing T = pair<int, int>;\nconst T id = T(INT_MAX, 0);\nT op(const T& l, const T& r) {\n\treturn make_pair(min(l.first, r.first), max(l.second, r.second));\n}\n\nstruct node {\n\tT val, all;\n\tnode *ch[2];\n\tint dep, size;\n\tnode(T v, node* l = nullptr, node* r = nullptr) : val(v), all(v), dep(1), size(1) {\n\t\tch[0] = l; ch[1] = r;\n\t}\n};\n\nint depth(node *t) { return t ? t->dep : 0; }\nint count(node *t) { return t ? t->size : 0; }\nT que(node *t) { return t ? t->all : id; }\n\nnode *update(node *t) {\n\tt->dep = max(depth(t->ch[0]), depth(t->ch[1])) + 1;\n\tt->all = op(que(t->ch[0]), op(t->val, que(t->ch[1])));\n\tt->size = count(t->ch[0]) + count(t->ch[1]) + 1;\n\treturn t;\n}\n\nnode *rotate(node *t, int b) {\n\tnode *s = t->ch[1 - b];\n\tt->ch[1 - b] = s->ch[b];\n\ts->ch[b] = t;\n\tt = update(t);\n\ts = update(s);\n\treturn s;\n}\n\nnode *fix(node *t) {\n\tif (t == nullptr) return t;\n\tif (depth(t->ch[0]) - depth(t->ch[1]) == 2) {\n\t\tif (depth(t->ch[0]->ch[1]) > depth(t->ch[0]->ch[0])) {\n\t\t\tt->ch[0] = rotate(t->ch[0], 0);\n\t\t}\n\t\tt = rotate(t, 1);\n\t}\n\telse if (depth(t->ch[0]) - depth(t->ch[1]) == -2) {\n\t\tif (depth(t->ch[1]->ch[0]) > depth(t->ch[1]->ch[1])) {\n\t\t\tt->ch[1] = rotate(t->ch[1], 1);\n\t\t}\n\t\tt = rotate(t, 0);\n\t}\n\treturn t;\n}\n\nnode *insert(node *t, int k, int x, int val) {\n\tif (!t) return new node(T(x, val));\n\tint c = count(t->ch[0]), b = (k > c);\n\tt->ch[b] = insert(t->ch[b], k - (b ? (c + 1) : 0), x, val);\n\tupdate(t);\n\treturn fix(t);\n}\n\nnode *find(node *t, int k) {\n\tif (t == nullptr) return t;\n\tint c = count(t->ch[0]);\n\treturn k < c ? find(t->ch[0], k) : k == c ? t : find(t->ch[1], k - (c + 1));\n}\n\nnode *erase(node *);\n\nnode *erase(node *t, int k) {\n\tif (t == nullptr) return nullptr;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = erase(t->ch[0], k);\n\t\tt = update(t);\n\t}\n\telse if (k > c) {\n\t\tt->ch[1] = erase(t->ch[1], k - (c + 1));\n\t\tt = update(t);\n\t}\n\telse {\n\t\tt = erase(t);\n\t}\n\treturn fix(t);\n}\n\nnode *erase(node *t) {\n\tif (t == nullptr) return nullptr;\n\tif (t->ch[0] == nullptr && t->ch[1] == nullptr) {\n\t\tdelete t;\n\t\treturn nullptr;\n\t}\n\tif (t->ch[0] == nullptr || t->ch[1] == nullptr) {\n\t\tnode *res = t->ch[t->ch[0] == nullptr];\n\t\tdelete t;\n\t\treturn res;\n\t}\n\tnode *res = new node(find(t->ch[1], 0)->val, t->ch[0], erase(t->ch[1], 0));\n\tdelete t;\n\treturn fix(update(res));\n}\n\nT find(node *t, int l, int r) {\n\tif (!t) return id;\n\tif (r < 0 || l >= count(t)) return id;\n\tif (l <= 0 && r >= t->size) return t->all;\n\tint c = count(t->ch[0]);\n\treturn op(!t->ch[0] ? id : find(t->ch[0], l, r), op(l <= c && c < r ? t->val : id, t->ch[1] == nullptr ? id : find(t->ch[1], l - (c + 1), r - (c + 1))));\n}\n\nnode *update_val(node *t, int k, int x, int val) {\n\tif (!t) return t;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = update_val(t->ch[0], k, x, val);\n\t}\n\telse if (k == c) {\n\t\tt->val.first = x;\n\t\tt->val.second = val;\n\t}\n\telse {\n\t\tt->ch[1] = find(t->ch[1], k - (c + 1));\n\t}\n\treturn update(t);\n}\n\nint count_lower(node *t, int v) {\n\tif (t == nullptr) return 0;\n\tif (t->val.first < v) return count(t->ch[0]) + 1 + count_lower(t->ch[1], v);\n\tif (t->val.first == v) return count(t->ch[0]);\n\treturn count_lower(t->ch[0], v);\n}\n\nvoid del(node *t) {\n\tif (t->ch[0]) del(t->ch[0]);\n\tif (t->ch[1]) del(t->ch[1]);\n\tdelete t;\n}\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nnode *segs[MAX * 2];\n\nnode* update(node* p, int x, int val) {\n\tint pos = count_lower(p, x);\n\tbool ok = false;\n\tif (p && pos < p->size) {\n\t\tauto t = find(p, pos);\n\t\tif (t->val.first == x) {\n\t\t\tok = true;\n\t\t\tp = update_val(p, pos, x, val);\n\t\t}\n\t}\n\tif (!ok) {\n\t\tp = insert(p, pos, x, val);\n\t}\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) --r, res = max(res, find(segs[r], 0, count_lower(segs[r], y)).second);\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) {\n\t\tdel(segs[p]);\n\t\tsegs[p] = nullptr;\n\t}\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxn], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\nclass DynamicRMQ{\n\tstruct Node{\n\t\tint height;\n\t\tNode *left,*right;\n\t\tint size;\n\t\tint val,sub;\n\t\t\n\t\tNode(int k,int v)\n\t\t\t:height(1),left(0),right(0),size(1),val(v),sub(v){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *insert(int k,int v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tint si=left?left->size:0;\n\t\t\tif(k <= si){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else {//key < k\n\t\t\t\tright = right->insert(k-si-1,v);\n\t\t\t}\n\t\t\treturn balance();\n\t\t}\n\n\t\tNode *erase(int k){\n\t\t\tif(!this)return NULL;\n\t\t\tint si=left?left->size:0;\n\t\t\tif(k==si){\n\t\t\t\tNode *le=left,*ri=right;\n\t\t\t\tleft=right=NULL;\n\t\t\t\tdelete this;\n\t\t\t\tif(!le){\n\t\t\t\t\treturn ri;\n\t\t\t\t}\n\t\t\t\tif(!ri){\n\t\t\t\t\treturn le;\n\t\t\t\t}\n\t\t\t\tNode *t;\n\t\t\t\tle = le->erase_max(&t);\n\t\t\t\tt->left = le;\n\t\t\t\tt->right = ri;\n\t\t\t\treturn t->balance();\n\t\t\t}\n\t\t\tif(k < si){\n\t\t\t\tleft = left->erase(k);\n\t\t\t}else if(si < k){\n\t\t\t\tright = right->erase(k-si-1);\n\t\t\t}\n\t\t\treturn balance();\n\t\t}\n\t\tint query(int a,int b,int l,int r)const{\n\t\t\tif(!this || r<a || b<l)return nil;\n\t\t\tif(a<=l && r<=b)return sub;\n\t\t\tint si=left?left->size:0;\n\t\t\tint res=a<=l+si&&l+si<b?val:nil;\n\t\t\tres = func(res,left->query(a,b,l,l+si));\n\t\t\tres = func(res,right->query(a,b,l+si+1,r));\n\t\t\treturn res;\n\t\t}\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_size();\n\t\t\tupdate_value();\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t\tvoid update_size(){\n\t\t\tif(!this)return;\n\t\t\tsize = 1 + (left?left->size:0) + (right?right->size:0);\n\t\t}\n\t\tvoid update_value(){\n\t\t\tif(!this)return;\n\t\t\tsub = val;\n\t\t\tif(left)sub=func(sub,left->sub);\n\t\t\tif(right)sub=func(sub,right->sub);\n\t\t}\n\t\tNode* erase_max(Node **maxnode){\n\t\t\tif(right){\n\t\t\t\tright = right->erase_max(maxnode);\n\t\t\t\treturn balance();\n\t\t\t}else{\n\t\t\t\t*maxnode=this;\n\t\t\t\treturn left;\n\t\t\t}\n\t\t}\n\t} *root;\npublic:\n\tDynamicRMQ():root(0){}\n\t~DynamicRMQ(){if(root)delete root;}\n\tvoid insert(int k,int v){\n\t\troot=root->insert(k,v);\n\t}\n\tvoid erase(int k){\n\t\troot=root->erase(k);\n\t}\n\tvoid set(int k,int v){\n\t\troot=root->erase(k);\n\t\troot=root->insert(k,v);\n\t}\t\n\tint query(int a,int b)const{//半開区間[a,b)\n\t\treturn root->query(a,b,0,root->size);\n\t}\n};\n\n\n\n\nclass Nothing{};\n\ntemplate<class Key,class Val=Nothing>\nclass MultiAVLTree{\n\tstruct Node{\n\t\tint height;\n\t\tKey key;\n\t\tVal value;\n\t\tNode *left,*right;\n\t\tint size;\n\t\tNode(const Key& k,const Val& v)\n\t\t\t:height(1),key(k),value(v),left(0),right(0),size(1){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *insert(const Key &k,const Val &v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tif(k <= key){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->insert(k,v);\n\t\t\t}else return this;\n\t\t\treturn balance();\n\t\t}\n\t\tNode *find(const Key& k){\n\t\t\treturn !this?NULL:k==key?\n\t\t\t\tthis:k<key?left->find(k):right->find(k);\n\t\t}\n\t\tNode *erase(const Key &k){\n\t\t\tif(!this)return NULL;\n\t\t\tif(k==key){\n\t\t\t\tNode *le=left,*ri=right;\n\t\t\t\tleft=right=NULL;\n\t\t\t\tdelete this;\n\t\t\t\tif(!le)return ri;\n\t\t\t\tif(!ri)return le;\n\t\t\t\tNode *t;\n\t\t\t\tle = le->erase_max(&t);\n\t\t\t\tt->left = le;\n\t\t\t\tt->right = ri;\n\t\t\t\treturn t->balance();\n\t\t\t}\n\t\t\tif(k < key){\n\t\t\t\tleft = left->erase(k);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->erase(k);\n\t\t\t}else return this;\n\t\t\treturn balance();\n\t\t}\n\t\tNode *nth_element(int n){\n\t\t\tif(size<=n)return NULL;\n\t\t\tNode *t=this;\n\t\t\twhile((t->left?t->left->size:0)!=n){\n\t\t\t\tif(t->left && n<=t->left->size){\n\t\t\t\t\tt=t->left;\n\t\t\t\t}else {\n\t\t\t\t\tif(t->left)n-=t->left->size;\n\t\t\t\t\tn--;\n\t\t\t\t\tt=t->right;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\n\t\t}\n\t\tint rank_lt(const Key& k)const{\n\t\t\tif(!this)return 0;\n\t\t\tif(k<=key){\n\t\t\t\treturn left->rank_lt(k);\n\t\t\t}else{\n\t\t\t\treturn 1 + (left?left->size:0) + right->rank_lt(k);\n\t\t\t}\n\t\t}\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_size();\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t\tvoid update_size(){\n\t\t\tif(!this)return;\n\t\t\tsize = 1 + (left?left->size:0) + (right?right->size:0);\n\t\t}\n\t\tNode* erase_max(Node **maxnode){\n\t\t\tif(right){\n\t\t\t\tright = right->erase_max(maxnode);\n\t\t\t\treturn balance();\n\t\t\t}else{\n\t\t\t\t*maxnode=this;\n\t\t\t\treturn left;\n\t\t\t}\n\t\t}\n\t} *root;\npublic:\n\tMultiAVLTree():root(0){}\n\t~MultiAVLTree(){if(root)delete root;}\n\tvoid insert(const Key& k,const Val& v=Nothing()){\n\t\troot=root->insert(k,v);\n\t}\n\tVal* find(const Key& k){\n\t\tNode *p=root->find(k);\n\t\tif(p)return &p->value;\n\t\treturn NULL;\n\t}\n\tvoid erase(const Key& k){\n\t\troot=root->erase(k);\n\t}\n\tKey nth_element(int n)const{\n\t\treturn root->nth_element(n)->key;\n\t}\n\tint rank_lt(const Key& k)const{//k未満の個数\n\t\treturn root->rank_lt(k);\n\t}\n\tint size()const{\n\t\treturn root?root->size:0;\n\t}\n\tint height()const{\n\t\treturn root?root->height:0;\n\t}\n};\n\n\n\n\n\n\ninline int popCount(unsigned long long x){\n#ifdef __GNUC__\n\treturn __builtin_popcountll(x);\n#else \n\tx = (x>>1 & 0x5555555555555555ULL)+(x & 0x5555555555555555ULL);\n\tx = (x>>2 & 0x3333333333333333ULL)+(x & 0x3333333333333333ULL);\n\tx = (x>>4 & 0x0f0f0f0f0f0f0f0fULL)+(x & 0x0f0f0f0f0f0f0f0fULL);\n\tx = (x>>8 & 0x00ff00ff00ff00ffULL)+(x & 0x00ff00ff00ff00ffULL);\n\tx = (x>>16& 0x0000ffff0000ffffULL)+(x & 0x0000ffff0000ffffULL);\n\treturn ((x>>32)+(x & 0xffffffff));\n#endif\n}\n\n\nclass DynamicBitVector{\n\tstruct Node{\n\t\tint height;\n\t\tNode *left,*right;\n\t\tint rank,len;\n\t\tint sumlen;\n\t\tunsigned long long val;\n\t\t\n\t\tNode(int val)\n\t\t\t:height(1),left(0),right(0),rank(!!val),len(1),sumlen(1),val(val){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\t\tpair<bool,Node*> insert(int k,int v){\n\t\t\tif(!this)return make_pair(true,new Node(v));\n\t\t\tint si=(left?left->sumlen:0);\n\t\t\tif(k < si){\n\t\t\t\tpair<bool,Node*> t=left->insert(k,v);\n\t\t\t\tleft=t.second;\n\t\t\t\tif(t.first)t.second=balance();\n\t\t\t\telse t.second=this,rank+=v,sumlen++;\n\t\t\t\treturn make_pair(t.first,t.second);\n\t\t\t}else if(k-si<=len && !(k-si==len&&len==8*sizeof(long long)) ){\n\t\t\t\tk-=si;\n\t\t\t\tif(len<8*sizeof(long long)){\n\t\t\t\t\tval= (~((1ULL<<k)-1)&val)<<1 | (unsigned long long)v<<k | (((1ULL<<k)-1)&val);\n\t\t\t\t\trank+=v;\n\t\t\t\t\tlen++;\n\t\t\t\t\tsumlen++;\n\t\t\t\t\treturn make_pair(false,this);\n\t\t\t\t}else{\n\t\t\t\t\tint a=val>>(8*sizeof(long long)-1);\n\t\t\t\t\tval= (~((1ULL<<k)-1)&val)<<1 | (unsigned long long)v<<k | (((1ULL<<k)-1)&val);\n\t\t\t\t\trank+=v;\n\t\t\t\t\tsumlen++;\n\t\t\t\t\tpair<bool,Node*> t=right->insert(0,a);\n\t\t\t\t\tright=t.second;\n\t\t\t\t\tif(t.first)t.second=balance();\n\t\t\t\t\telse t.second=this;\n\t\t\t\t\treturn make_pair(t.first,t.second);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tpair<bool,Node*> t=right->insert(k-si-len,v);\n\t\t\t\tright=t.second;\n\t\t\t\tif(t.first)t.second=balance();\n\t\t\t\telse t.second=this,rank+=v,sumlen++;\n\t\t\t\treturn make_pair(t.first,t.second);\n\t\t\t}\n\t\t}\n\t\tint access(int k)const{\n\t\t\tint si=(left?left->sumlen:0);\n\t\t\treturn k<si?left->access(k):\n\t\t\t\tk<si+len?(val>>k-si&1):right->access(k-si-len);\n\t\t}\n\t\tpair<bool,Node*> erase(int k){\n\t\t\tif(!this)return make_pair(false,(Node*)NULL);\n\t\t\tint si=(left?left->sumlen:0);\n\t\t\tif(k<si){\n\t\t\t\tpair<bool,Node*> t=left->erase(k);\n\t\t\t\tleft=t.second;\n\t\t\t\tif(t.first)t.second=balance();\n\t\t\t\telse {\n\t\t\t\t\tt.second=this;\n\t\t\t\t\tupdate_rank();\n\t\t\t\t\tsumlen--;\n\t\t\t\t}\n\t\t\t\treturn make_pair(t.first,t.second);\n\t\t\t}else if(k<si+len){\n\t\t\t\tk-=si;\n\t\t\t\tif(1<len){\n\t\t\t\t\trank-=val>>k&1;\n\t\t\t\t\t//val= (~((1ULL<<k+1)-1)&val)>>1 | (((1ULL<<k)-1)&val);  //g++ -> segmentation falut\n\t\t\t\t\tif(k+1<64)val= (~((1ULL<<k+1)-1)&val)>>1 | (((1ULL<<k)-1)&val);\n\t\t\t\t\telse val= (((1ULL<<k)-1)&val);\n\t\t\t\t\tlen--;\n\t\t\t\t\tsumlen--;\n\t\t\t\t\treturn make_pair(false,this);\n\t\t\t\t}else{\n\t\t\t\t\tNode *le=left,*ri=right;\n\t\t\t\t\tleft=right=NULL;\n\t\t\t\t\tdelete this;\n\t\t\t\t\tif(!le)return make_pair(true,ri);\n\t\t\t\t\tif(!ri)return make_pair(true,le);\n\t\t\t\t\tNode *t;\n\t\t\t\t\tle = le->erase_max(&t);\n\t\t\t\t\tt->left = le;\n\t\t\t\t\tt->right = ri;\n\t\t\t\t\treturn  make_pair(true,t->balance());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tpair<bool,Node*> t=right->erase(k-si-len);\n\t\t\t\tright=t.second;\n\t\t\t\tif(t.first)t.second=balance();\n\t\t\t\telse {\n\t\t\t\t\tt.second=this;\n\t\t\t\t\tupdate_rank();\n\t\t\t\t\tsumlen--;\n\t\t\t\t}\n\t\t\t\treturn make_pair(t.first,t.second);\n\t\t\t}\n\t\t}\n\t\tint rank_lt(int k)const{\n\t\t\tif(!this)return 0;\n\t\t\tint si=(left?left->sumlen:0);\n\t\t\tif(k<si){\n\t\t\t\treturn left->rank_lt(k);\n\t\t\t}else if(k<si+len){\n\t\t\t\treturn (left?left->rank:0) + popCount(((1ULL<<k-si)-1)&val);\n\t\t\t}else{\n\t\t\t\treturn (left?left->rank:0) + popCount(val) + right->rank_lt(k-si-len);\n\t\t\t}\n\t\t}\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_rank();\n\t\t\tupdate_sumlen();\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t\tvoid update_rank(){\n\t\t\tif(!this)return;\n\t\t\trank = popCount(val) + (left?left->rank:0) + (right?right->rank:0);\n\t\t}\n\t\tvoid update_sumlen(){\n\t\t\tif(!this)return;\n\t\t\tsumlen = len + (left?left->sumlen:0) + (right?right->sumlen:0);\n\t\t}\n\t\tNode* erase_max(Node **maxnode){\n\t\t\tif(right){\n\t\t\t\tright = right->erase_max(maxnode);\n\t\t\t\treturn balance();\n\t\t\t}else{\n\t\t\t\t*maxnode=this;\n\t\t\t\treturn left;\n\t\t\t}\n\t\t}\n\t} *root;\npublic:\n\tDynamicBitVector():root(0){}\n\t~DynamicBitVector(){if(root)delete root;}\n\tvoid insert(int k,int v){\n\t\troot=root->insert(k,v).second;\n\t}\n\tvoid erase(int k){\n\t\troot=root->erase(k).second;\t\n\t}\n\tint access(int n)const{\n\t\treturn root->access(n);\n\t}\n\tint size()const{\n\t\treturn root?root->sumlen:0;\n\t}\n\tint rank(int k)const{//[0,k)の1の個数\n\t\treturn root->rank_lt(k);\n\t}\n\tint rank()const{\n\t\treturn root?root->rank:0;\n\t}\n};\n\n\n\n\n\n\nclass Dynamic2DRMQ{\n\tstatic const int BITLEN = 20;//ceil(log(MAX_Y))\n\tint len;\n\tDynamicBitVector bv[BITLEN];\n\tDynamicRMQ segtree[BITLEN],level0;\n\tMultiAVLTree<int> setx;\n\tMultiAVLTree<pair<int,int> > setxy;\n\n\tvoid _insert(int k,int y,int c){\n\t\tfor(int i=BITLEN-1;i>=0;i--){\n\t\t\tint sum = bv[i].rank(k);\n\t\t\tint prev=k;\n\t\t\tsegtree[i].insert(k,c);\n\t\t\tif(y&1<<i){\n\t\t\t\tk = len-bv[i].rank() + sum;\n\t\t\t\tbv[i].insert(prev,1);\n\t\t\t}else{\n\t\t\t\tk = k-sum;\n\t\t\t\tbv[i].insert(prev,0);\t\n\t\t\t}\n\t\t}\n\t\tlevel0.insert(k,c);\n\t}\n\tvoid _erase(int k){\n\t\tfor(int i=BITLEN-1;i>=0;i--){\n\t\t\tint prev=k;\n\t\t\tsegtree[i].erase(k);\n\t\t\tif(bv[i].access(k)){\n\t\t\t\tk = len-bv[i].rank()+bv[i].rank(k);\n\t\t\t}else{\n\t\t\t\tk = k-bv[i].rank(k);\n\t\t\t}\n\t\t\tbv[i].erase(prev);\n\t\t}\n\t\tlevel0.erase(k);\n\t}\n\tint query(int xs,int xe,int ys,int ye,int i,int bits)const{\n\t\tif(xs==xe)return nil;\n\t\tif((bits|(1<<i+1)-1)<ys || ye<=bits)return nil;\n\t\tif(i==-1)\n\t\t\treturn level0.query(xs,xe);\n\t\tif(ys<=bits && (bits|(1<<i+1)-1)<ye)\n\t\t\treturn segtree[i].query(xs,xe);\n\t\tint ssum = bv[i].rank(xs);\n\t\tint esum = bv[i].rank(xe);\n\t\tint r0 = len-bv[i].rank();\n\t\treturn func(query(xs-ssum,xe-esum,ys,ye,i-1,bits)\n\t\t\t,query(r0+ssum,r0+esum,ys,ye,i-1,bits|1<<i));\n\t}\npublic:\n\tint size()const{\n\t\treturn len;\n\t}\n\tDynamic2DRMQ():len(0){}\n\tvoid insert(int x,int y,int val){\n\t\t_insert(setxy.rank_lt(make_pair(x,y)),y,val);\n\t\tsetx.insert(x);\n\t\tsetxy.insert(make_pair(x,y));\n\t\tlen++;\n\t}\n\tvoid erase(int x,int y){\n\t\t_erase(setxy.rank_lt(make_pair(x,y)));\n\t\tsetx.erase(x);\n\t\tsetxy.erase(make_pair(x,y));\n\t\tlen--;\n\t}\n\tint query(int xs,int xe,int ys,int ye)const{//[xs,xe),[ys,ye)\n\t\treturn query(setx.rank_lt(xs),setx.rank_lt(xe),ys,ye,BITLEN-1,0);\n\t}\n};\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ rmq2d;\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(0,v[i].second.first,0,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(x) int((x).size())\n#define mkt make_tuple\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef tuple< int, int, int > Data;\nconst int kSize = 300010;\nconst int kMax = 1 << 20;\n\nint M, N, A, B;\nData T[kSize];\n\nmap< int, int > tree[kMax];\nint mxy;\n\nvoid read();\nvoid solve();\n\ninline int low_bit(int i) { return i & (-i); }\n\nint query(int y, int z) {\n  if (y == 0 || z == 0)\n    return 0;\n\n  int i = y, ret = 0;\n  while (i > 0) {\n    auto &tr = tree[i - 1];\n    auto itr = tr.upper_bound(z - 1);\n    if (itr != tr.begin())\n      ret = max(ret, (--itr)->sc);\n    i -= low_bit(i);\n  }\n\n  return ret;\n}\n\nvoid update(int y, int z, int v) {\n  for (int i = y + 1; i < mxy + 10; i += low_bit(i)) {\n    auto &tr = tree[i - 1];\n    auto itr = tr.lower_bound(z), iitr = itr;\n    bool is_ins = false;\n\n    if (tr.count(z) > 0) {\n      if (tr[z] < v)\n        tr[z] = v, iitr = tr.find(z), is_ins = true;\n    }\n    else if (itr == tr.begin())\n      tr[z] = v, iitr = tr.find(z), is_ins = true;\n    else {\n      if ((--itr)->sc < v)\n        tr[z] = v, iitr = tr.find(z), is_ins = true;\n    }\n\n    if (is_ins) {\n      ++iitr;\n      while (iitr != tr.end()) {\n        if (iitr->sc > v)\n          break;\n        auto tmp = iitr;\n        ++iitr, tr.erase(tmp);\n      }\n    }\n  }\n}\n\nint main() {\n  while (scanf(\" %d %d %d %d\", &M, &N, &A, &B), M + N)\n    read(), solve();\n\n  return 0;\n}\n\nvoid read() {\n  int x, y, z;\n  int a = A, b = B, c = ~(1 << 31), m = (1 << 16) - 1;\n  auto r = [&] () {\n    a = 36969 * (a & m) + (a >> 16);\n    b = 18000 * (b & m) + (b >> 16);\n    return (c & ((a << 16) + b)) % 1000000;\n  };\n\n  mxy = 0;\n  for (int i = 0; i < M; ++i) {\n    scanf(\" %d %d %d\", &x, &y, &z), mxy = max(mxy, y);\n    T[i] = mkt(x, y, z);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    x = r(), y = r(), z = r(), mxy = max(mxy, y);\n    T[i + M] = mkt(x, y, z);\n  }\n}\n\nvoid solve() {\n  static int f[kSize];\n\n  sort(&T[0], &T[M + N]);\n\n  for (int i = 0; i < mxy + 10; ++i)\n    tree[i].clear();\n\n  fill(&f[0], &f[M + N], 0);\n  for (int i = 0, j = 0; i < M + N; i = j) {\n    j = i + 1;\n    while (j < M + N && get< 0 >(T[i]) == get< 0 >(T[j]))\n      ++j;\n\n    for (int k = i; k < j; ++k) {\n      int y = get< 1 >(T[k]), z = get< 2 >(T[k]);\n      f[k] = query(y, z) + 1;\n    }\n\n    for (int k = i; k < j; ++k) {\n      int y = get< 1 >(T[k]), z = get< 2 >(T[k]);\n      update(y, z, f[k]);\n    }\n  }\n\n  cout << *max_element(&f[0], &f[M + N]) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 30;\nint A, B;\ninline int gen()\n{\n    static int a = A;\n    static int b = B;\n    constexpr int C = ~(1 << 31);\n    constexpr int M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\n\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, INF});\n    vector<P> er;\n    for (; lower != st.end() and lower->second > v.second; lower++) {\n        er.push_back(*lower);\n    }\n    st.insert(v);\n    for (const P& e : er) {\n        st.erase(e);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <cmath>\n#include <set>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int INF = 1<<28;\nstruct Tree {\n    //using D = P;\n    typedef P D;\n    struct Node;\n    //using NP = Node*;\n    typedef Node* NP;\n    static Node last_d;\n    static NP last;\n    struct Node {\n        NP l, r;\n        int sz;\n        D v;\n        int mn;\n        Node(D v) :l(last), r(last), sz(1), v(v), mn(v.second) {}\n        Node(NP l, NP r, int sz = 0) :l(l), r(r), sz(sz) {}\n        void push() {\n\n        }\n        NP update() {\n            sz = 1+l->sz+r->sz;\n            mn = v.second;\n            if (l->sz) {\n                mn = min(mn, l->mn);\n            }\n            if (r->sz) {\n                mn = min(mn, r->mn);\n            }\n            return this;\n        }\n        int lb(D a) {\n            if (!sz) return 0;\n            if (a <= v) return l->lb(a);\n            return l->sz + 1 + r->lb(a);\n        }\n        int ub(D a) {\n            if (!sz) return 0;\n            if (v <= a) return l->sz + 1 + r->ub(a);\n            return l->ub(a);\n        }\n        int get(int a, int b) {\n            if (!sz || b <= 0 || sz <= a) return INF;\n            if (a <= 0 && sz <= b) return mn;\n            int res = INF;\n            res = min(res, l->get(a, b));\n            if (a <= l->sz && l->sz < b) res = min(res, v.second);\n            res = min(res, r->get(a - l->sz - 1, b - l->sz - 1));\n            return res;\n        }\n    } *n;\n\n    static uint xor128(){\n        static uint x=123456789,y=362436069,z=521288629,w=88675123;\n        uint t;\n        t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n    }\n    static NP merge(NP l, NP r) {\n        if (!l->sz) return r;\n        if (!r->sz) return l; \n        l->push(); r->push();\n        if (xor128() % (l->sz + r->sz) < l->sz) {\n            l->r = merge(l->r, r);\n            return l->update();\n        } else {\n            r->l = merge(l, r->l);\n            return r->update();\n        }\n    }\n    static pair<NP, NP> split(NP x, int k) {\n        if (!x->sz) return {last, last};\n        x->push();\n        if (k <= x->l->sz) {\n            auto y = split(x->l, k);\n            x->l = y.second;\n            y.second = x->update();\n            return y;\n        } else {\n            auto y = split(x->r, k- x->l->sz -1);\n            x->r = y.first;\n            y.first = x->update();\n            return y;\n        }\n    }\n\n    Tree() : n(last) {}\n    Tree(NP n) : n(n) {}\n    int sz() {\n        return n->sz;\n    }\n    void merge(Tree r) {\n        n = merge(n, r.n);\n    }\n    Tree split(int k) {\n        auto u = split(n, k);\n        n = u.first;\n        return Tree(u.second);\n    }\n    void insert(D v) {\n        auto u = split(n, lb(v));\n        n = merge(merge(u.first, new Node(v)), u.second);\n    }\n    int get(int l, int r) {\n        return n->get(l, r);\n    }\n    int lb(D v) {\n        return n->lb(v);\n    }\n    int ub(D v) {\n        return n->ub(v);\n    }\n};\nTree::Node Tree::last_d = Tree::Node(NULL, NULL, 0);\nTree::NP Tree::last = &last_d;\n\nconst int MN = 303000;\nint n;\nint x[MN], y[MN], z[MN];\nP d[MN];\nT buff[MN];\nTree g[MN];\n\nint solve() {\n    for (int i = 0; i < n; i++) {\n        buff[i] = T(x[i], -y[i], -z[i]);\n    }\n    sort(buff, buff+n);\n    for (int i = 0; i < n; i++) {\n        int a, b, c;\n        tie(a,b,c) = buff[i];\n        d[i] = P(-b, -c);\n    }\n    for (int i = 0; i <= n; i++) {\n        g[i] = Tree();\n    }\n    g[0].insert(P(-1, -1));\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int l = 0, r = i+1;\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (g[md].get(0, g[md].lb(P(d[i].first, -INF))) < d[i].second) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        g[r].insert(d[i]);\n        res = max(res, r);\n    }\n    return res;\n}\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n    while (true) {\n        int m;\n        cin >> n >> m >> a >> b;\n        if (!n && !m) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        for (int i = n; i < n+m; i++) {\n            x[i] = r(); y[i] = r(); z[i] = r();\n        }\n        n += m;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n \nint n;\n \nstruct tup{\n    int x, y, z;\n}a[300005];\n \nmap<int,int> mp[300005];\nint dp[300005];\n \nbool input(){\n    int m, nn, A, B;\n    scanf(\"%d %d %d %d\",&m,&nn,&A,&B);\n    if(m + nn + A + B == 0) return 0;\n    n = m + nn;\n    for(int i=1; i<=m; i++){\n        scanf(\"%d %d %d\",&a[i].x,&a[i].y,&a[i].z);\n    }\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    for(int i=m+1; i<=n; i++){\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].x = (C & ((a << 16) + b)) % 1000000;\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].y = (C & ((a << 16) + b)) % 1000000;\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].z = (C & ((a << 16) + b)) % 1000000;\n    }\n    for(int i=0; i<=n; i++){\n        mp[i].clear();\n    }\n    return 1;\n}\n \nbool trial(int m, int y, int z){\n    auto it = mp[m].lower_bound(y);\n    if(it == mp[m].begin()) return 0;\n    it--;\n    return (z > it->second);\n}\n \n\nvoid add(int x, int y, int z){\n\tauto it = mp[x].lower_bound(y);\n\tauto it2 = mp[x].upper_bound(y);\n\tif(it2 != mp[x].begin()){\n\t\tit2--;\n\t\tif(it2->second <= z) return;\n\t}\n\twhile(it != mp[x].end() && it->second >= z){\n\t\tmp[x].erase(it);\n\t\tit = mp[x].lower_bound(y);\n\t}\n\tmp[x].insert(make_pair(y, z));\n}\n\nvoid solve(){\n    sort(a + 1, a + n + 1, [&](const tup &a, const tup &b){\n        return a.x < b.x;\n    });\n    mp[0].insert(make_pair(-1, -1));\n    for(int i=1; i<=n;){\n        int e = i;\n        while(e <= n && a[e].x == a[i].x) e++;\n        for(int j=i; j<e; j++){\n            int s = 0, e = i;\n            while(s != e){\n                int m = (s+e+1) / 2;\n                if(trial(m, a[j].y, a[j].z)) s = m;\n                else e = m-1;\n            }\n            dp[j] = s + 1;\n        }\n        for(int j=i; j<e; j++){\n            add(dp[j], a[j].y, a[j].z);\n        }\n        i = e;\n    }\n    printf(\"%d\\n\",*max_element(dp+1,dp+n+1));\n}\n \nint main(){\n    while(input()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      auto it=dp[k].lower_bound(p);\n      if(it!=dp[k].begin()) --it;\n      if(it==dp[k].end()) return 0;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\t//cout<<it->first<<\" *** \"<<it->second<<endl;\t\n\t//cout<<uk->first<<\" *+* \"<<uk->second<<endl;\n\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n    };\n\n    auto print=[&](set<P> sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * こうするとN+M個の点それぞれについて、高々log(座標の上限)個のノードが作られるので、メモリ使用量はO((N+M) log MOD)となる。\n *\n * オーダーは O((N+M) log MOD×(N+M))。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n\n        ~Node() {}\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(4000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(1000000);\n    map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 1000000, 0, 1000000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nusing T = pair<int, int>;\nconst T id = T(INT_MAX, 0);\nT op(const T& l, const T& r) {\n\treturn make_pair(min(l.first, r.first), max(l.second, r.second));\n}\n\nstruct node {\n\tT val, all;\n\tnode *ch[2];\n\tint dep, size;\n\tnode() {}\n};\n\nint it = 0;\nconst int pmax = 5e6;\n\nnode pool[pmax];\n\nnode *new_node(T v, node *l = nullptr, node *r = nullptr) {\n\tassert(it < pmax);\n\tpool[it].val = v;\n\tpool[it].all = v;\n\tpool[it].dep = 1;\n\tpool[it].size = 1;\n\tpool[it].ch[0] = l;\n\tpool[it].ch[1] = r;\n\treturn pool + it++;\n}\n\nint depth(node *t) { return t ? t->dep : 0; }\nint count(node *t) { return t ? t->size : 0; }\nT que(node *t) { return t ? t->all : id; }\n\nnode *update(node *t) {\n\tt->dep = max(depth(t->ch[0]), depth(t->ch[1])) + 1;\n\tt->all = op(que(t->ch[0]), op(t->val, que(t->ch[1])));\n\tt->size = count(t->ch[0]) + count(t->ch[1]) + 1;\n\treturn t;\n}\n\nnode *rotate(node *t, int b) {\n\tnode *s = t->ch[1 - b];\n\tt->ch[1 - b] = s->ch[b];\n\ts->ch[b] = t;\n\tt = update(t);\n\ts = update(s);\n\treturn s;\n}\n\nnode *fix(node *t) {\n\tif (t == nullptr) return t;\n\tif (depth(t->ch[0]) - depth(t->ch[1]) == 2) {\n\t\tif (depth(t->ch[0]->ch[1]) > depth(t->ch[0]->ch[0])) {\n\t\t\tt->ch[0] = rotate(t->ch[0], 0);\n\t\t}\n\t\tt = rotate(t, 1);\n\t}\n\telse if (depth(t->ch[0]) - depth(t->ch[1]) == -2) {\n\t\tif (depth(t->ch[1]->ch[0]) > depth(t->ch[1]->ch[1])) {\n\t\t\tt->ch[1] = rotate(t->ch[1], 1);\n\t\t}\n\t\tt = rotate(t, 0);\n\t}\n\treturn t;\n}\n\nnode *insert(node *t, int k, int x, int val) {\n\tif (!t) return new_node(T(x, val));\n\tint c = count(t->ch[0]), b = (k > c);\n\tt->ch[b] = insert(t->ch[b], k - (b ? (c + 1) : 0), x, val);\n\tupdate(t);\n\treturn fix(t);\n}\n\nnode *find(node *t, int k) {\n\tif (t == nullptr) return t;\n\tint c = count(t->ch[0]);\n\treturn k < c ? find(t->ch[0], k) : k == c ? t : find(t->ch[1], k - (c + 1));\n}\n\nnode *erase(node *);\n\nnode *erase(node *t, int k) {\n\tif (t == nullptr) return nullptr;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = erase(t->ch[0], k);\n\t\tt = update(t);\n\t}\n\telse if (k > c) {\n\t\tt->ch[1] = erase(t->ch[1], k - (c + 1));\n\t\tt = update(t);\n\t}\n\telse {\n\t\tt = erase(t);\n\t}\n\treturn fix(t);\n}\n\nnode *erase(node *t) {\n\tif (t == nullptr) return nullptr;\n\tif (t->ch[0] == nullptr && t->ch[1] == nullptr) {\n\t\treturn nullptr;\n\t}\n\tif (t->ch[0] == nullptr || t->ch[1] == nullptr) {\n\t\tnode *res = t->ch[t->ch[0] == nullptr];\n\t\treturn res;\n\t}\n\tnode *res = new_node(find(t->ch[1], 0)->val, t->ch[0], erase(t->ch[1], 0));\n\treturn fix(update(res));\n}\n\nT find(node *t, int l, int r) {\n\tif (!t) return id;\n\tif (r < 0 || l >= count(t)) return id;\n\tif (l <= 0 && r >= t->size) return t->all;\n\tint c = count(t->ch[0]);\n\treturn op(!t->ch[0] ? id : find(t->ch[0], l, r), op(l <= c && c < r ? t->val : id, t->ch[1] == nullptr ? id : find(t->ch[1], l - (c + 1), r - (c + 1))));\n}\n\nnode *update_val(node *t, int k, int x, int val) {\n\tif (!t) return t;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = update_val(t->ch[0], k, x, val);\n\t}\n\telse if (k == c) {\n\t\tt->val.first = x;\n\t\tt->val.second = val;\n\t}\n\telse {\n\t\tt->ch[1] = find(t->ch[1], k - (c + 1));\n\t}\n\treturn update(t);\n}\n\nint count_lower(node *t, int v) {\n\tif (t == nullptr) return 0;\n\tif (t->val.first < v) return count(t->ch[0]) + 1 + count_lower(t->ch[1], v);\n\tif (t->val.first == v) return count(t->ch[0]);\n\treturn count_lower(t->ch[0], v);\n}\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nnode *segs[MAX * 2];\n\nnode* update(node* p, int x, int val) {\n\tint pos = count_lower(p, x);\n\tbool ok = false;\n\tif (p && pos < p->size) {\n\t\tauto t = find(p, pos);\n\t\tif (t->val.first == x) {\n\t\t\tok = true;\n\t\t\tp = update_val(p, pos, x, val);\n\t\t}\n\t}\n\tif (!ok) {\n\t\tp = insert(p, pos, x, val);\n\t}\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) --r, res = max(res, find(segs[r], 0, count_lower(segs[r], y)).second);\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxn], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y < b.y;\n    return a.z < b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Generator{\n    int a, b, C, M;\n    Generator(int A, int B){\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    }\n    int generate() {\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nconst int INF = 100000000;\ntypedef pair<int, int> Point;\n\nvoid insert(int x, int y, set<Point>& s){\n    const Point np(x, y);\n    auto itr = s.lower_bound(np);\n    if((--itr)->second <= y) return ;\n    itr++;\n    vector<Point> removes;\n    while(itr->second >= y){\n        removes.push_back(*itr);\n        itr++;\n    }\n    for(Point p : removes){\n        s.erase(p);\n    }\n    s.insert(np);\n    /*\n    for(auto p : s){\n        printf(\"(%d, %d) \", p.first, p.second);\n    }\n    cout << endl;\n    */\n}\n\nint main(){\n    int M, N, A, B;\n    const int MAX = 1000000;\n    while(cin >> M >> N >> A >> B && (M + N) != 0){\n        vector<vector<Point>> rect(MAX);\n        for(int i = 0; i < M; i++){\n            int x;\n            Point p;\n            cin >> x >> p.first >> p.second;\n            rect[x].push_back(p);\n        }\n        Generator gen(A, B);\n        for(int i = 0; i < N; i++){\n            Point p;\n            int x = gen.generate();\n            p.first = gen.generate();\n            p.second = gen.generate();\n            rect[x].push_back(p);\n        }\n\n        vector<set<Point>> sets(MAX + 1);\n        for(auto& s : sets){\n            s.insert(Point(INF, -1));\n            s.insert(Point(-1, INF));\n        }\n\n        int answer = 0;\n        for(vector<Point> points : rect){\n            vector<pair<int, Point>> querys;\n            for(Point p : points){\n                int x = p.first, y = p.second;\n                int l = -1, r = MAX;\n                while(r - l > 1){\n                    int c = (l + r) / 2;\n                    auto itr = sets[c].lower_bound(Point(x, -INF));\n                    if((--itr)->second < y){\n                        l = c;\n                    }else{\n                        r = c;\n                    }\n                }\n                querys.emplace_back(r, p);\n                answer = max(answer, r + 1);\n            }\n            for(auto query : querys){\n                int k = query.first;\n                Point p = query.second;\n                //printf(\"%d (%d, %d)\\n\", k, p.first, p.second);\n                insert(p.first, p.second, sets[k]);\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\ntypedef tuple<int, int, int> tiii;\n\nstruct Random {\n\tint a, b, C, M;\n\tRandom(int A, int B) : a(A), b(B), C(~(1 << 31)), M((1 << 16) - 1) { }\n\tint operator()(){\n\t\ta = 36969 * (a & M) + (a >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint m, n, A, B;\n\t\tcin >> m >> n >> A >> B;\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0){ break; }\n\t\tn += m;\n\t\tvector<tiii> p(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tRandom random(A, B);\n\t\tfor(int i = m; i < n; ++i){\n\t\t\tconst int x = random();\n\t\t\tconst int y = random();\n\t\t\tconst int z = random();\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tvector< map<int, int> > vm(n + 1);\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < n; ){\n\t\t\tconst int x = get<0>(p[i]);\n\t\t\tvector<tiii> t;\n\t\t\twhile(i < n && get<0>(p[i]) == x){\n\t\t\t\tconst int y = get<1>(p[i]);\n\t\t\t\tconst int z = get<2>(p[i]);\n\t\t\t\tint l = 0, r = n;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tconst int c = l + (r - l) / 2;\n\t\t\t\t\tauto it = vm[c].lower_bound(y);\n\t\t\t\t\tif(it == vm[c].begin()){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else if((--it)->second >= z){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = c + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.emplace_back(l, y, z);\n\t\t\t\tanswer = max(answer, l + 1);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tfor(const auto &e : t){\n\t\t\t\tconst int k = get<0>(e);\n\t\t\t\tconst int y = get<1>(e);\n\t\t\t\tconst int z = get<2>(e);\n\t\t\t\tauto it = vm[k].lower_bound(y);\n\t\t\t\tif(it != vm[k].end() && it->first == y && it->second < z){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile(it != vm[k].end()){\n\t\t\t\t\tif(it->second < z){ break; }\n\t\t\t\t\tvm[k].erase(it++);\n\t\t\t\t}\n\t\t\t\tvm[k].insert(make_pair(y, z));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint LT,RT,LB,RB;\n\tint val;\n\tnode(){\n\t\tLT=RT=LB=RB=-1;\n\t\tval=0;\n\t}\n\tnode(int a,int b,int c,int d,int e){\n\t\tLT=a;\n\t\tRT=b;\n\t\tLB=c;\n\t\tRB=d;\n\t\tval=e;\n\t}\n};\nnode pool[8000000];\nint ind;\nint Ret;\nint nowret=0;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int t){\n\tif(d<a||b<c)return 0;\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d&&g<=e&&f<=h)return pool[t].val;\n\tif(nowret>pool[t].val)return 0;\n\tint ret=0;\n\tif(~pool[t].LT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,e,(e+f)/2,g,h,pool[t].LT));\n\t}\n\tif(~pool[t].RT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,(e+f)/2+1,f,g,h,pool[t].RT));\n\t}\n\tif(~pool[t].LB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,e,(e+f)/2,g,h,pool[t].LB));\n\t}\n\tif(~pool[t].RB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,(e+f)/2+1,f,g,h,pool[t].RB));\n\t}\n\treturn ret;\n}\nvoid update(int row,int col,int C){\n\tint now=0;\n\tint a=0;\n\tint b=1048575;\n\tint c=0;\n\tint d=1048575;\n\twhile(1){\n\t\tpool[now].val=max(pool[now].val,C);\n\t\tif(a==b)break;\n\t\tint M=(a+b)/2;\n\t\tint N=(c+d)/2;\n\t\tif(row<=M&&col<=N){//LT\n\t\t\tb=M;\n\t\t\td=N;\n\t\t\tif(~pool[now].LT){\n\t\t\t\tnow=pool[now].LT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row<=M&&col>N){//RT\n\t\t\tb=M;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RT){\n\t\t\t\tnow=pool[now].RT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col<=N){//LB\n\t\t\ta=M+1;\n\t\t\td=N;\n\t\t\tif(~pool[now].LB){\n\t\t\t\tnow=pool[now].LB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col>N){//RB\n\t\t\ta=M+1;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RB){\n\t\t\t\tnow=pool[now].RB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\t\n\t}\n}\npair<int,pair<int,int> >dat[400000];\nint x[400000];\nint y[400000];\nint z[400000];\nint Q[400000];\nint wolfa,wolfb,wolfC=~(1<<31),wolfM=(1<<16)-1;\nint r(){\n\twolfa=36969*(wolfa&wolfM)+(wolfa>>16);\n\twolfb=18000*(wolfb&wolfM)+(wolfb>>16);\n\treturn (wolfC&((wolfa<<16)+wolfb))%1000000;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,z+i);\n\t\t\tdat[i]=make_pair(x[i],make_pair(-y[i],-z[i]));\n\t\t}\n\t\twolfa=c;\n\t\twolfb=d;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint X=r();\n\t\t\tint Y=r();\n\t\t\tint Z=r();\n\t\t\tdat[i+a]=make_pair(X,make_pair(-Y,-Z));\n\t\t}\n\t\tint n=a+b;\n\t\tstd::sort(dat,dat+n);\n\t\t//for(int i=0;i<ind;i++)pool[i]=node();\n\t\tpool[0]=node();\n\t\tind=1;\n\t\tRet=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//int X=dat[i].second.first;\n\t\t\t//int Y=;\n\t\t\tnowret=0;\n\t\t\tint P=max(nowret,query(0,1048575,0,-dat[i].second.first-1,0,1048575,0,-dat[i].second.second-1,0))+1;\n\t\t\tRet=max(Ret,P);\n\t\t\tQ[i]=P;\n\t\t\tupdate(-dat[i].second.first,-dat[i].second.second,P);\n\t\t//\tif(i<n-1&&dat[i].first!=dat[i+1].first){\n\t\t\t//\tfor(int j=i;j>=0;j--){\n\t\t\t\t//\tif(dat[j].first!=dat[i].first)break;\n\t\t\t//\t\tupdate(-dat[j].second.first,-dat[j].second.second,Q[j]);\n\t\t\t//\t}\n\t\t//\t}\n\t\t}\n\t\tprintf(\"%d\\n\",Ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[500000];\nint anss[500010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        // calced[make_pair(1e+9, 1e+9)] = 0;\n        // calced[make_pair(-1e+9, -1e+9)] = 0;\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n);\n        if (sqn < 1) { sqn = 1; }\n        // int sqn = 10000;\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                // calced[make_pair(ps[pos][1], ps[pos][2])] = anss[pos];\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1000000 + 100;\n\nstruct Node{\n\tint x, y, z;\n\tvoid read(){\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t}\n\tvoid print(){\n\t\tprintf(\"(%d, %d, %d)\\n\", x, y, z);\n\t}\n};\n\nbool operator <(const Node &a, const Node &b){\n\tif (a.x < b.x) return true;\n\telse if (a.x > b.x) return false;\n\treturn a.y > b.y;\n}\n\nbool ok = false;\n\nint n, m;\nint a, b, C, M;\nNode v[N];\n\nint ans[N];\nint id[N];\nint tmp[N];\n\nint tot;\nint t[N];\nint cnt[N];\n\n\nbool cmp(const int &a, const int &b){\n\treturn v[a] < v[b];\n}\n\nvoid insert(int x, int val){\n\tfor (; x < N; x += x & -x){\n\t\tif (cnt[x] != tot){\n\t\t\tcnt[x] = tot;\n\t\t\tt[x] = 0;\n\t\t}\n\t\tt[x] = max(t[x], val);\n\t}\n}\n\nint ask(int x){\n\tint ret = 0;\n\tfor(; x > 0; x -= x & -x){\n\t\tif (cnt[x] != tot){\n\t\t\tcnt[x] = tot;\n\t\t\tt[x] = 0;\n\t\t}\n\t\tret = max(ret, t[x]);\n\t}\n\treturn ret;\n}\n\nint r(){\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid base_sort(int l, int r){\n\tint mid = (l + r) >> 1;\n\tint p1 = l, p2 = mid;\n\tint pos = l;\n\twhile(p1 < mid && p2 < r){\n\t\tif (v[id[p1]].y < v[id[p2]].y){\n\t\t\ttmp[pos++] = id[p1++];\n\t\t}\n\t\telse{\n\t\t\ttmp[pos++] = id[p2++];\n\t\t}\n\t}\n\twhile(p1 < mid){\n\t\ttmp[pos++] = id[p1++];\n\t}\n\twhile(p2 < r){\n\t\ttmp[pos++] = id[p2++];\n\t}\n}\n\nvoid calc(int a[], int n, int b[], int m){\n\ttot++;\n\tint p1 = 0, p2 = 0;\n\twhile(p1 < n && p2 < m){\n\t\tif (v[a[p1]].y < v[b[p2]].y){\n\t\t\tinsert(v[a[p1]].z, ans[a[p1]]);\n\t\t\tp1++;\n\t\t}\n\t\telse{\n\t\t\tans[b[p2]] = max(ans[b[p2]], 1 + ask(v[b[p2]].z - 1));\n\t\t\tp2++;\n\t\t}\n\t}\n\twhile(p2 < m){\n\t\tans[b[p2]] = max(ans[b[p2]], 1 + ask(v[b[p2]].z - 1));\n\t\tp2++;\n\t}\n}\n\nvoid work(int l, int r, bool flag){\n\tif (l + 1 == r) return;\n\tint mid = (l + r) >> 1;\n\tsort(id + l, id + r, cmp);\n\twork(l, mid, flag == true);\n\twork(mid, r, false);\n\tbase_sort(l, r);\n\tif (flag){\n\t\tcalc(id + l, mid - l, id + mid, r - mid);\n\t}\n\tif (flag){\n\t\tsort(id + mid, id + r, cmp);\n\t\twork(mid, r, flag == true);\n\t}\n\tbase_sort(l, r);\n\tfor(int i = l; i < r; i++){\n\t\tid[i] = tmp[i];\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < m; i++){\n\t\tint x, y, z;\n\t\tv[i].read();\n\t}\n\tC = ~(1 << 31), M = (1 << 16) - 1;\n\tfor(int i = m; i < m + n; i++){\n\t\tv[i].x = r();\n\t\tv[i].y = r();\n\t\tv[i].z = r();\n\t}\n\tn = m + n;\n\tfor(int i = 0; i < n; i++){\n\t\tv[i].x += 1;\n\t\tv[i].y += 1;\n\t\tv[i].z += 1;\n\t}\n\tsort(v, v + n);\n\tfor(int i = 0; i < n; i++){\n\t\tid[i] = i;\n\t\tans[i] = 1;\n\t}\n}\n\nvoid solve(){\n\twork(0, n, true);\n\tint ret = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tret = max(ret, ans[i]);\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n\nint main(){\n\ttot = 0;\n\twhile(~scanf(\"%d%d%d%d\", &m, &n, &a, &b)){\n\t\tif (!n && !m && !a && !b) break;\n\t\tinit();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * また、点数に比べて座標が大きいので、座標圧縮するとオーダーが減らせる。\n * こうするとN+M個の点それぞれについて、高々(log(N+M))^2個のノードが作られるので、メモリ使用量はO((N+M) (log N+M)^2)となる。\n *\n * オーダーは O((N+M) (log (N+M))^2)。\n */\n#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(6000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        assert(xr <= size && yr <= size);\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        assert(xr <= size && yr <= size);\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nnamespace std {\ntemplate<>\nstruct hash<pair<int,int>> {\n    bool operator ()(const pair<int,int> &p) const {\n        return p.first * 300000 + p.second;\n    }\n};\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<int> coords;\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n        coords.push_back(x);\n        coords.push_back(y);\n        coords.push_back(z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n        coords.push_back(x);\n        coords.push_back(y);\n        coords.push_back(z);\n    }\n    {\n        sort(begin(coords), end(coords));\n        coords.erase(unique(begin(coords), end(coords)), end(coords));\n        vector<int> dict(coords.back()+1);\n        int cnt = 0;\n        for(const auto &e : coords) {\n            dict[e] = cnt++;\n        }\n        for(auto &p : ps) {\n            int x, y, z;\n            tie(x, y, z) = p;\n            p = make_tuple(dict[x], dict[y], dict[z]);\n        }\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(coords.size());\n    unordered_map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 300000, 0, 300000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b;\nconstexpr int C = ~(1 << 31);\nconstexpr int M = (1 << 16) - 1;\n\nint r() {\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct point {\n    int y, z;\n\n    point(int y_, int z_) : y(y_), z(z_) {}\n    bool operator<(point const& p) const {\n        return y < p.y;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n\n    int m, n;\n    while(cin >> m >> n >> a >> b, n + m) {\n        vector<tuple<int, int, int>> ps(n + m);\n        for(int i = 0; i < m; ++i) {\n            int x, y, z; cin >> x >> y >> z;\n            ps[i] = make_tuple(x, -y, -z);\n        }\n        for(int i = m; i < n + m; ++i) {\n            const int x = r(), y = r(), z = r();\n            ps[i] = make_tuple(x, -y, -z);\n        }\n        sort(begin(ps), end(ps));\n        vector<point> ps2;\n        for(int i = 0; i < n + m; ++i) {\n            ps2.emplace_back(-get<1>(ps[i]), -get<2>(ps[i]));\n        }\n\n        int ans = 0;\n        vector<set<point>> dp(n + m + 1);\n        dp[0].emplace(0, 0);\n        for(auto const& p : ps2) {\n            auto check = [&] (int i) {\n                auto it = dp[i].lower_bound(p);\n                if(it == dp[i].begin()) return false;\n                it = prev(it);\n                return p.y > it->y && p.z > it->z;\n            };\n            int lb = 0, ub = n + m;\n            while(ub - lb > 1) {\n                const int mid = (ub + lb) >> 1;\n                (check(mid) ? lb : ub) = mid;\n            }\n            auto it = dp[ub].lower_bound(p);\n            while(it != dp[ub].end() && it->z >= p.z) {\n                it = dp[ub].erase(it);\n            }\n            if(it == dp[ub].begin() || prev(it)->z > p.z) {\n                dp[ub].insert(p);\n            }\n            ans = max(ans, ub);\n        }\n\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN], RANGE;\n\nbool cmp_x(const int &a, const int &b) {\n    if (x[a] != x[b]) return x[a] < x[b];\n    else if (y[a] != y[b]) return y[a] < y[b];\n    else return z[a] < z[b];\n}\n\nmap<int, int> bit[MAXC];\n\nint answer(int idx, int th) {\n    map<int, int>::iterator it = bit[idx].lower_bound(th);\n    if (it != bit[idx].begin()) return (--it)->second;\n    else return NO_VALUE;\n}\n\nint query(int idx, int th) {\n    int res = NO_VALUE;\n    while (idx > 0) {\n        res = max(res, answer(idx, th));\n        idx &= idx-1;\n    }\n    return res;\n}\n\nvoid update(int idx, int th, int v) {\n    map<int,int>::iterator it1, it2;\n    while (idx < RANGE) {\n        it1 = it2 = bit[idx].upper_bound(th);\n        while (it2 != bit[idx].end() && it2->second <= v) it2++;\n        bit[idx].erase(it1, it2);\n    \n        it1 = bit[idx].upper_bound(th);\n        if (it1 == bit[idx].begin() || (--it1)->second < v) bit[idx][th] = v;\n        idx += idx&(-idx);\n    }\n}\n\nint main() {\n    int m, n, i, j, N;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        RANGE = 0;\n        for (i=0; i<N; i++) { ox[i] = i; y[i] += 1; RANGE = max(RANGE, y[i]+1); }\n        sort(ox, ox+N, cmp_x);\n\n        for (i=0; i<RANGE; i++) bit[i].clear();\n\n        i = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[ox[j]] = max(1, query(y[ox[j]]-1, z[ox[j]])+1);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[ox[i]]);\n        } while (i < N);\n        printf(\"%d\\n\", query(RANGE-1, MAXC));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\ntypedef set<P>::iterator se_it;\n\nset<P> se[300300];\n\nint xs[300300],ys[300300],zs[300300];\nPP pps[300300];\nint N;\n\nbool check(P p,int id){\n\tset<P> &se=::se[id];\n\tint x=p.first,y=p.second;\n\tif(se.size()==0) return false;\n\tse_it it=se.lower_bound(P(x,-2));\n\tif(it==se.begin()) return false;\n\tit--;\n\tint py=it->second;\n\tif(py<y) return true;\n\treturn false;\n}\n\nvoid ins(P p,int id){\n\tset<P> &se=::se[id];\n\tint x=p.first,y=p.second;\n\tse_it it=se.lower_bound(P(x,-2));\n\tif(it==se.end()){\n\t\tse.insert(p);\n\t\treturn;\n\t}\n\tif(it->first==x&&it->second<y){\n\t\treturn;\n\t}\n\twhile(true){\n\t\tif(it==se.end()||it->second<y) break;\n\t\tse.erase(it++);\n\t}\n\tse.insert(p);\n}\n\nvoid put(P p){\n\tint lb=0,ub=N+1;\n\twhile(ub-lb>1){\n\t\tint mid=(ub+lb)/2;\n\t\tbool flg=check(p,mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tins(p,lb+1);\n}\n\nint A,B;\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint m,n;\n\nvoid init(){\n\tscanf(\"%d%d%d%d\",&m,&n,&A,&B);\n\tif(m+n==0) exit(0);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",xs+i,ys+i,zs+i);\n\t}\n\ta=A,b=B;\n\tfor(int i=0;i<n;i++){\n\t\txs[i+m]=r();\n\t\tys[i+m]=r();\n\t\tzs[i+m]=r();\n\t}\n\tN=m+n;\n\tfor(int i=0;i<=N;i++){\n\t\tse[i].clear();\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tpps[i]=PP(zs[i],P(-xs[i],-ys[i]));\n\t}\n\tsort(pps,pps+N);\n}\n\nint solve(){\n\tse[0].insert(P(-1,-1));\n\tfor(int i=0;i<N;i++){\n\t\tP p=pps[i].second;\n\t\tp.first*=-1;\n\t\tp.second*=-1;\n\t\tput(p);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++) if(se[i].size()>0) ans=i;\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tint ans=solve();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto print=[&](const set<P> &sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](const set<P> &sp){\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      auto it=dp[k].lower_bound(p);\n      if(it!=dp[k].begin()) --it;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n      \n      veri(dp[k]);\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      //veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(type l, type r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\nusing namespace std;\n\n\n\nnamespace _RMQ{\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\nclass SparseSegtree{\n\tstruct Node{\n\t\tint height;\n\t\tint key;\n\t\tint value, rangev;\n\n\t\tNode *left,*right;\n\t\tNode(int k,int v)\n\t\t\t:height(1),key(k),value(v),rangev(v),left(0),right(0){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\n\t\t/*int query(int a,int b,int l,int r)const{\n\t\t\tif(!this||r<=a||b<=l)return nil;\n\t\t\tif(a<=l&&r<=b)return rangev;\n\t\t\tint res=func(left->query(a,b,l,key),right->query(a,b,key+1,r));\n\t\t\tif(a<=key&&key<b)res=func(res,value);\n\t\t\treturn res;\n\t\t}*/\n\t\tint query(int a,int b,int l,int r)const{\n\t\t\tif(a<=l&&r<=b)return rangev;\n\t\t\tint res=nil;\n\t\t\tif(a<=key&&key<b)res=value;\n\t\t\tif(left && a<key)res=func(res,left->query(a,b,l,key));\n\t\t\tif(right && key+1<b)res=func(res,right->query(a,b,key+1,r));\n\t\t\treturn res;\n\t\t}\n\t\tNode *insert(int k,int v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tif(k < key){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->insert(k,v);\n\t\t\t}else{\n\t\t\t\tvalue=func(value,v);\n\t\t\t\trangev=func(rangev,v);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn balance();\n\t\t}\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_value();\n\t\t}\n\t\tvoid update_value(){\n\t\t\trangev=value;\n\t\t\tif(left)rangev=func(rangev,left->rangev);\n\t\t\tif(right)rangev=func(rangev,right->rangev);\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t} *root;\n\n\tint max_key;\npublic:\n\tSparseSegtree():root(0),max_key(-1){}\n\t~SparseSegtree(){if(root)delete root;}\n\tvoid insert(int k,int v){\n\t\tmax_key=max(max_key,k);\n\t\troot=root->insert(k,v);\n\t}\n\tint query(int a,int b)const{//[a,b)\n\t\tif(!root)return nil;\n\t\treturn root->query(a,b,0,max_key+1);\n\t}\n\tbool empty()const{\n\t\treturn !root;\n\t}\n};\n\n};\n\n\n\n//insert only\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<_RMQ::SparseSegtree> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1){}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tbit[x].insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ys,int ye)const{//[0,xe)*[ys,ye)\n\t\tint res=_RMQ::nil;\n\t\twhile(0<xe){\n\t\t\tres=_RMQ::func(res,bit[xe].query(ys,ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(1000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,0,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nvector<Pint> p;\n   \nvoid init(int m_){\n    m0=1;\n    while(m0<m_) m0*=2;\n    for(int i=0; i<2*m0-1; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    for(int j=0; j<=v1[i].size(); j++){\n      v[i].push_back(0);\n    }\n  }\n}\n   \nvoid update(int k, int i, int a){\n   while(i<=v[k].size()){\n\t   v[k][i]=max(v[k][i], a);\n\t   i+=(i&(-i));\n   }\n}\n  \nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n    if(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0+1, a);\n  }\n  if(r-l>1){\n    if(l<=y && y<(l+r)/2){\n        update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    }else{\n        update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n    }\n  }\n}\n  \nint find(int k, int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts=max(s, v[k][i]);\n\t\ti-=(i&(-i));\n\t}\n\treturn s;\n}\n  \nint find0(int y, int z, int k, int l, int r){\n    if(r<=0 || y<=l) return 0;\n    if(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n        return find(k, i);\n    }else{\n        int vl=find0(y, z, k*2+1, l, (l+r)/2);\n        int vr=find0(y, z, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n  \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      scanf(\"%d %d %d %d\", &m, &n, &A, &B);\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      int ind[300000];\n      for(int i=0; i<p.size(); i++) ind[i]=i;\n      sort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n      int ct=-1, pr=-1;\n      for(int i=0; i<p.size(); i++){\n          if(pr!=p[ind[i]].second.first){\n              pr=p[ind[i]].second.first;\n              ct++;\n              p[ind[i]].second.first=ct;\n          }else{\n              p[ind[i]].second.first=ct;\n          }\n      }\n      init(ct+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      printf(\"%d\\n\", find0(ct+1, 1000000, 0, 0, m0));\n      p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint LT,RT,LB,RB;\n\tint val;\n\tnode(){\n\t\tLT=RT=LB=RB=-1;\n\t\tval=0;\n\t}\n\tnode(int a,int b,int c,int d,int e){\n\t\tLT=a;\n\t\tRT=b;\n\t\tLB=c;\n\t\tRB=d;\n\t\tval=e;\n\t}\n};\nnode pool[8000000];\nint ind;\nint Ret;\nint nowret=0;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int t){\n\tif(d<a||b<c)return 0;\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d&&g<=e&&f<=h)return pool[t].val;\n\tif(nowret>pool[t].val)return 0;\n\tint ret=0;\n\tif(~pool[t].LT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,e,(e+f)/2,g,h,pool[t].LT));\n\t}\n\tif(~pool[t].RT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,(e+f)/2+1,f,g,h,pool[t].RT));\n\t}\n\tif(~pool[t].LB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,e,(e+f)/2,g,h,pool[t].LB));\n\t}\n\tif(~pool[t].RB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,(e+f)/2+1,f,g,h,pool[t].RB));\n\t}\n\treturn ret;\n}\nvoid update(int row,int col,int C){\n\tint now=0;\n\tint a=0;\n\tint b=1048575;\n\tint c=0;\n\tint d=1048575;\n\twhile(1){\n\t\tpool[now].val=max(pool[now].val,C);\n\t\tif(a==b)break;\n\t\tint M=(a+b)/2;\n\t\tint N=(c+d)/2;\n\t\tif(row<=M&&col<=N){//LT\n\t\t\tb=M;\n\t\t\td=N;\n\t\t\tif(~pool[now].LT){\n\t\t\t\tnow=pool[now].LT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row<=M&&col>N){//RT\n\t\t\tb=M;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RT){\n\t\t\t\tnow=pool[now].RT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col<=N){//LB\n\t\t\ta=M+1;\n\t\t\td=N;\n\t\t\tif(~pool[now].LB){\n\t\t\t\tnow=pool[now].LB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col>N){//RB\n\t\t\ta=M+1;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RB){\n\t\t\t\tnow=pool[now].RB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\t\n\t}\n}\npair<int,pair<int,int> >dat[400000];\nint x[400000];\nint y[400000];\nint z[400000];\nint Q[400000];\nint wolfa,wolfb,wolfC=~(1<<31),wolfM=(1<<16)-1;\nint r(){\n\twolfa=36969*(wolfa&wolfM)+(wolfa>>16);\n\twolfb=18000*(wolfb&wolfM)+(wolfb>>16);\n\treturn (wolfC&((wolfa<<16)+wolfb))%1000000;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,z+i);\n\t\t\tdat[i]=make_pair(x[i],make_pair(-y[i],-z[i]));\n\t\t}\n\t\twolfa=c;\n\t\twolfb=d;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint X=r();\n\t\t\tint Y=r();\n\t\t\tint Z=r();\n\t\t\tdat[i+a]=make_pair(X,make_pair(-Y,-Z));\n\t\t}\n\t\tint n=a+b;\n\t\tstd::sort(dat,dat+n);\n\t\t//for(int i=0;i<ind;i++)pool[i]=node();\n\t\tpool[0]=node();\n\t\tind=1;\n\t\tRet=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//int X=dat[i].second.first;\n\t\t\t//int Y=;\n\t\t\tnowret=0;\n\t\t\tint P=max(nowret,query(0,1048575,0,-dat[i].second.first-1,0,1048575,0,-dat[i].second.second-1,0))+1;\n\t\t\tRet=max(Ret,P);\n\t\t\tQ[i]=P;\n\t\t\tupdate(-dat[i].second.first,-dat[i].second.second,P);\n\t\t//\tif(i<n-1&&dat[i].first!=dat[i+1].first){\n\t\t\t//\tfor(int j=i;j>=0;j--){\n\t\t\t\t//\tif(dat[j].first!=dat[i].first)break;\n\t\t\t//\t\tupdate(-dat[j].second.first,-dat[j].second.second,Q[j]);\n\t\t\t//\t}\n\t\t//\t}\n\t\t}\n\t\tprintf(\"%d\\n\",Ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct bit {\n\tvector<int> a;\n\tbit(int N = 0) : a(N + 1) {}\n\tint get(int i) {\n\t\tint val = 0;\n\t\tfor (; i; i -= i & -i) val = max(val, a[i]);\n\t\treturn val;\n\t}\n\tvoid set(int i, int val) {\n\t\tfor (i++; i < a.size(); i += i & -i) a[i] = max(a[i], val);\n\t}\n};\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) { delete lch; delete rch; }\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tbit bt;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tbt = bit(X.size()); // new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) { delete lch; delete rch; }\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn bt.get(r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tbt.set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxn], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y < b.y;\n    return a.z < b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m + A + B)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z, g[i] = 1;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r(), g[i] = 1;\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode() {}\n};\n\nconst int MAX = 1 << 19;\n\nint it;\nconst int pmax = 2e7;\n\nnode pool[pmax];\n\nnode *segs[MAX * 2];\n\nnode *new_node(int val) {\n\tassert(it < pmax);\n\tpool[it].val = val;\n\tpool[it].l = pool[it].r = nullptr;\n\treturn pool + it++;\n}\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new_node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\ninline int r(int &a, int &b) {\n\tstatic constexpr int C = ~(1 << 31);\n\tstatic constexpr int M = (1 << 16) - 1;\n\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(int y, int z, const map<int, int> &contour) {\n\tconst auto it = contour.upper_bound(y);\n\treturn it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n\tsort(points.begin(), points.end());\n\n\tint max_count = 0;\n\tint prev_x = x(points.front());\n\tvector<tuple<int, int, int>> buf;\n\tvector<map<int, int>> maps{{{1, -1}}};\n\tbuf.reserve(points.size());\n\tmaps.reserve(points.size());\n\n\tfor(const auto &p : points) {\n\t\tconst int x = x(p);\n\t\tconst int y = -y(p);\n\t\tconst int z = z(p);\n\n\t\tif(prev_x != x) {\n\t\t\tmaps.resize(max_count + 1);\n\t\t\tprev_x = x;\n\n\t\t\tfor(const auto &e : buf) {\n\t\t\t\tint k, ty, tz;\n\t\t\t\ttie(k, ty, tz) = e;\n\n\t\t\t\tauto &target = maps[k];\n\t\t\t\tauto it = target.lower_bound(ty);\n\n\t\t\t\tif(it == target.end() || it->second > tz) {\n\t\t\t\t\ttarget[ty] = tz;\n\t\t\t\t\tit = target.find(ty);\n\n\t\t\t\t\twhile(it != target.begin()) {\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tif(tz > it->second) break;\n\t\t\t\t\t\tit = target.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.clear();\n\t\t}\n\n\t\tint low = 0;\n\t\tint high = maps.size();\n\n\t\twhile(low + 1 < high) {\n\t\t\tconst int mid = (low + high) / 2;\n\t\t\tif(check(y, z, maps[mid])) {\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\tif(low == max_count) ++max_count;\n\t\tbuf.emplace_back(high, y, z);\n\t}\n\n\treturn max_count;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int m, n, a, b; cin >> m >> n >> a >> b && a;) {\n\t\tvector<point> points;\n\t\tpoints.reserve(n + m);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tpoints.emplace_back(x, y, z);\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int x = r(a, b);\n\t\t\tconst int y = r(a, b);\n\t\t\tconst int z = r(a, b);\n\t\t\tpoints.emplace_back(x, y, z);\n\t\t}\n\n\t\tcout << solve(points) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n  bool operator == (const Point& rhs) const {\n    return x==rhs.x && y==rhs.y && z==rhs.z;\n  }\n  bool operator < (const Point& rhs) const {\n    if(x != rhs.x) return x < rhs.x;\n    if(y != rhs.y) return y > rhs.y;\n    return z > rhs.z;\n  }\n};\n\nusing Pi = pair<int, int>;\n\nint main() {\n  int m, n, A, B;\n  while(cin >> m >> n >> A >> B, m+n) {\n    a = A, b = B;\n\n    int N = n+m;\n    vector<Point> pts(N);\n    for(int i = 0; i < m; ++i) {\n      cin >> pts[i].x >> pts[i].y >> pts[i].z;\n    }\n    for(int i = m; i < N; ++i) {\n      pts[i].x = r();\n      pts[i].y = r();\n      pts[i].z = r();\n    }\n    sort(pts.begin(), pts.end());\n\n    vector<set<Pi> > dp(N+1);\n    int ans = 1;\n    for(int i = 0; i < N; ++i) {\n      Pi p = Pi(pts[i].y, pts[i].z);\n      int lb = 0, ub = ans+1;\n      while(lb+1 < ub) {\n\tint mb = (lb+ub)/2;\n\tauto it = dp[mb].lower_bound(Pi(p.first, -1));\n\tif(it != dp[mb].begin() && (--it)->second < p.second) lb = mb;\n\telse ub = mb;\n      }\n      ans = max(ans, ub);\n      {\n\tauto it = dp[ub].lower_bound(Pi(p.first, -1));\n        if(it != dp[ub].end() && it->second >= p.second) {\n\t  dp[ub].erase(it);\n\t}\n      }\n      if(dp[ub].empty()) {\n\tdp[ub].insert(p);\n      } else {\n\tauto it = dp[ub].lower_bound(p);\n\tif(it == dp[ub].begin() || (--it != dp[ub].end() && (it->first != p.first || it->second > p.second))) {\n\t  dp[ub].insert(p);\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nusing T = pair<int, int>;\nconst T id = T(INT_MAX, 0);\nT op(const T& l, const T& r) {\n\treturn make_pair(min(l.first, r.first), max(l.second, r.second));\n}\n\nstruct node {\n\tT val, all;\n\tnode *ch[2];\n\tint dep, size;\n\tnode() {}\n};\n\nint it = 0;\nconst int pmax = 6e6;\n\nnode pool[pmax];\n\nnode *new_node(T v, node *l = nullptr, node *r = nullptr) {\n\tassert(it < pmax);\n\tpool[it].val = v;\n\tpool[it].all = v;\n\tpool[it].dep = 1;\n\tpool[it].size = 1;\n\tpool[it].ch[0] = l;\n\tpool[it].ch[1] = r;\n\treturn pool + it++;\n}\n\nint depth(node *t) { return t ? t->dep : 0; }\nint count(node *t) { return t ? t->size : 0; }\nT que(node *t) { return t ? t->all : id; }\n\nnode *update(node *t) {\n\tt->dep = max(depth(t->ch[0]), depth(t->ch[1])) + 1;\n\tt->all = op(que(t->ch[0]), op(t->val, que(t->ch[1])));\n\tt->size = count(t->ch[0]) + count(t->ch[1]) + 1;\n\treturn t;\n}\n\nnode *rotate(node *t, int b) {\n\tnode *s = t->ch[1 - b];\n\tt->ch[1 - b] = s->ch[b];\n\ts->ch[b] = t;\n\tt = update(t);\n\ts = update(s);\n\treturn s;\n}\n\nnode *fix(node *t) {\n\tif (t == nullptr) return t;\n\tif (depth(t->ch[0]) - depth(t->ch[1]) == 2) {\n\t\tif (depth(t->ch[0]->ch[1]) > depth(t->ch[0]->ch[0])) {\n\t\t\tt->ch[0] = rotate(t->ch[0], 0);\n\t\t}\n\t\tt = rotate(t, 1);\n\t}\n\telse if (depth(t->ch[0]) - depth(t->ch[1]) == -2) {\n\t\tif (depth(t->ch[1]->ch[0]) > depth(t->ch[1]->ch[1])) {\n\t\t\tt->ch[1] = rotate(t->ch[1], 1);\n\t\t}\n\t\tt = rotate(t, 0);\n\t}\n\treturn t;\n}\n\nnode *insert(node *t, int k, int x, int val) {\n\tif (!t) return new_node(T(x, val));\n\tint c = count(t->ch[0]), b = (k > c);\n\tt->ch[b] = insert(t->ch[b], k - (b ? (c + 1) : 0), x, val);\n\tupdate(t);\n\treturn fix(t);\n}\n\nnode *find(node *t, int k) {\n\tif (t == nullptr) return t;\n\tint c = count(t->ch[0]);\n\treturn k < c ? find(t->ch[0], k) : k == c ? t : find(t->ch[1], k - (c + 1));\n}\n\nnode *erase(node *);\n\nnode *erase(node *t, int k) {\n\tif (t == nullptr) return nullptr;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = erase(t->ch[0], k);\n\t\tt = update(t);\n\t}\n\telse if (k > c) {\n\t\tt->ch[1] = erase(t->ch[1], k - (c + 1));\n\t\tt = update(t);\n\t}\n\telse {\n\t\tt = erase(t);\n\t}\n\treturn fix(t);\n}\n\nnode *erase(node *t) {\n\tif (t == nullptr) return nullptr;\n\tif (t->ch[0] == nullptr && t->ch[1] == nullptr) {\n\t\treturn nullptr;\n\t}\n\tif (t->ch[0] == nullptr || t->ch[1] == nullptr) {\n\t\tnode *res = t->ch[t->ch[0] == nullptr];\n\t\treturn res;\n\t}\n\tnode *res = new_node(find(t->ch[1], 0)->val, t->ch[0], erase(t->ch[1], 0));\n\treturn fix(update(res));\n}\n\nT find(node *t, int l, int r) {\n\tif (!t) return id;\n\tif (r < 0 || l >= count(t)) return id;\n\tif (l <= 0 && r >= t->size) return t->all;\n\tint c = count(t->ch[0]);\n\treturn op(!t->ch[0] ? id : find(t->ch[0], l, r), op(l <= c && c < r ? t->val : id, t->ch[1] == nullptr ? id : find(t->ch[1], l - (c + 1), r - (c + 1))));\n}\n\nnode *update_val(node *t, int k, int x, int val) {\n\tif (!t) return t;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = update_val(t->ch[0], k, x, val);\n\t}\n\telse if (k == c) {\n\t\tt->val.first = x;\n\t\tt->val.second = val;\n\t}\n\telse {\n\t\tt->ch[1] = find(t->ch[1], k - (c + 1));\n\t}\n\treturn update(t);\n}\n\nint count_lower(node *t, int v) {\n\tif (t == nullptr) return 0;\n\tif (t->val.first < v) return count(t->ch[0]) + 1 + count_lower(t->ch[1], v);\n\tif (t->val.first == v) return count(t->ch[0]);\n\treturn count_lower(t->ch[0], v);\n}\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nnode *segs[MAX * 2];\n\nnode* update(node* p, int x, int val) {\n\tint pos = count_lower(p, x);\n\tbool ok = false;\n\tif (p && pos < p->size) {\n\t\tauto t = find(p, pos);\n\t\tif (t->val.first == x) {\n\t\t\tok = true;\n\t\t\tp = update_val(p, pos, x, val);\n\t\t}\n\t}\n\tif (!ok) {\n\t\tp = insert(p, pos, x, val);\n\t}\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) --r, res = max(res, find(segs[r], 0, count_lower(segs[r], y)).second);\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN], used[MAXC], stack[MAXN], ymap[MAXC], Y;\n\nbool cmp_x(const int &a, const int &b) { return x[a] < x[b]; }\n\nmap<int, int> bit[MAXC];\n\nint answer(int idx, int th) {\n    map<int, int>::iterator it = bit[idx].lower_bound(th);\n    if (it != bit[idx].begin()) return (--it)->second;\n    else return NO_VALUE;\n}\n\nint query(int idx, int th) {\n    int res = NO_VALUE;\n    while (idx > 0) {\n        res = max(res, answer(idx, th));\n        idx &= idx-1;\n    }\n    return res;\n}\n\nvoid update(int idx, int th, int v) {\n    map<int,int>::iterator it1, it2;\n    while (idx < Y) {\n        it1 = it2 = bit[idx].upper_bound(th);\n        while (it2 != bit[idx].end() && it2->second <= v) it2++;\n        bit[idx].erase(it1, it2);\n    \n        it1 = bit[idx].upper_bound(th);\n        if (it1 == bit[idx].begin() || (--it1)->second < v) bit[idx][th] = v;\n        idx += idx&(-idx);\n    }\n}\n\nint main() {\n    int m, n, i, j, N, t = 1, STACK;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        Y = 0;\n        for (i=0; i<N; i++) {\n            ox[i] = i;\n            if (used[y[i]] < t) { used[y[i]] = t; stack[Y++] = y[i]; }\n        }\n        sort(ox, ox+N, cmp_x);\n        sort(stack, stack+Y);\n        for (i=0; i<Y; i++) ymap[stack[i]] = i+1;\n        for (i=0; i<N; i++) y[i] = ymap[y[i]];\n        t++; Y++;\n\n        for (i=0; i<Y; i++) bit[i].clear();\n\n        i = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[ox[j]] = max(1, query(y[ox[j]]-1, z[ox[j]])+1);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[ox[i]]);\n        } while (i < N);\n        printf(\"%d\\n\", query(Y-1, MAXC));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * こうするとN+M個の点それぞれについて、高々log(座標の上限)個のノードが作られるので、メモリ使用量はO((N+M) log MOD)となる。\n *\n * オーダーは O((N+M) log MOD×(N+M))。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        //assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n\n        ~Node() {}\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(4000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        //assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(1000000);\n    map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 1000000, 0, 1000000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * こうするとN+M個の点それぞれについて、高々log(座標の上限)個のノードが作られるので、メモリ使用量はO((N+M) log MOD)となる。\n *\n * オーダーは O((N+M) log MOD×(N+M))。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n\n        ~Node() {}\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(4000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) < thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(1000000);\n    map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 1000000, 0, 1000000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\ntemplate<typename T,typename U> T pmod(T x,U M){return (x%M+M)%M;}\n\ntypedef long long ll;\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n\n// must template\ntypedef ll D;\nconst D INF = 1LL<<58,EPS = 1;\n\ntypedef tuple<D,D,D> P;\n\nistream& operator >> (istream& is,P& p){D x,y,z;is >> x >> y>>z; p=P(x,y,z); return is;}\n\nint sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n\nbool eq(D a,D b){return sig(a-b)==0;}\nbool eq(const P& a,const P& b){\n\treturn sig(get<0>(a)-get<0>(b))==0\n\t&& sig(get<1>(a)-get<1>(b))==0\n\t&& sig(get<2>(a)-get<2>(b))==0;\n}\nbool compX (const P& a,const P& b){\n\treturn !eq(get<0>(a),get<0>(b))?sig(get<0>(a),get<0>(b))<0:\n\t\t!eq(get<1>(a),get<1>(b))?sig(get<1>(a),get<1>(b))<0:\n\t\tsig(get<2>(a),get<2>(b))<0;\n}\n\n// //must template\n\n\nvector<int> dp;\n\n// 挿入 O(logn) 検索 O(logn)\n// [lx,rx)×[ly,ry) 範囲内の点を返す．\n// (x座標の探索とy座標の探索を交互に行う．)\n// kd tree\n// ! no check\nstruct kdtree {\n\tstruct node {\n\t\tP p;int i;\n\t\tnode *l, *r;\n\t\tnode(const P &p,int i): p(p),i(i), l(NULL), r(NULL) { }\n\t} *root;\n\tkdtree() : root(NULL) { }\n\n\tbool compare(int d,const P&p,const P& q){\n\t\tif(d==0) return get<0>(p) < get<0>(q);\n\t\tif(d==1) return get<1>(p) < get<1>(q);\n\t\tif(d==2) return get<2>(p) < get<2>(q);\n\t\tassert(false);\n\t}\n\tvoid insert(const P &p,int i) {root = insert(root, 0, p,i);}\n\tnode *insert(node *t, int d, const P &p,int i) {\n\t\tif (t == NULL) return new node(p,i);\n\t\tif (compare(d,p,t->p)) t->l = insert(t->l, !d, p,i);\n\t\telse                   t->r = insert(t->r, !d, p,i);\n\t\treturn t;\n\t}\n\tvoid search(const P &ld, const P &ru,int& out) { search(root, 0, ld, ru, out);}\n\tvoid search(node *t,int d, const P &ld, const P &ru,int& out) {\n\t\tif (t == NULL) return;\n\t\tconst P &p = t->p;\n\t\tif(IN(get<0>(ld),get<0>(p),get<0>(ru)) && IN(get<1>(ld),get<1>(p),get<1>(ru)) && IN(get<2>(ld),get<2>(p),get<2>(ru))){\n\t\t\tif(out==-1 || dp[t->i]>dp[out])out=t->i;\n\t\t}\n\t\tif (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n\t\tif (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n\t}\n};\n\nint m,n,A,B;\n\nint a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nint main() {\n\twhile(true){\n\t\tcin >> m >> n >> A >> B;if(m+n==0)break;\n\t\tvector<P> ps(m+n);\n\t\tREP(i,m)cin >> ps[i];\n\t\ta=A;b=B;\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tD x=r(),y=r(),z=r();\n\t\t\tps[i]=P(x,y,z);\n\t\t}\n\t\tsort(ALL(ps),compX);\n\t\t// REP(i,m+n)cout << ps[i]<<endl;\n\n\t\tdp=vector<int>(m+n,1);\n\t\tkdtree kd;\n\t\tREP(i,m+n)kd.insert(ps[i],i);\n\t\tREP(i,m+n){\n\t\t\tint j=-1;kd.search(P(0,0,0),ps[i],j);\n\t\t\tif(j!=-1)dp[i]=max(dp[i],dp[j]+1);\n\t\t}\n\t\tcout << *max_element(ALL(dp)) <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * また、点数に比べて座標が大きいので、座標圧縮するとオーダーが減らせる。\n * こうするとN+M個の点それぞれについて、高々(log(N+M))^2個のノードが作られるので、メモリ使用量はO((N+M) (log N+M)^2)となる。\n *\n * オーダーは O((N+M) (log (N+M))^2)。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(3000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nnamespace std {\ntemplate<>\nstruct hash<pair<int,int>> {\n    bool operator ()(const pair<int,int> &p) const {\n        return p.first * 300000 + p.second;\n    }\n};\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<int> coords;\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n        coords.push_back(x);\n        coords.push_back(y);\n        coords.push_back(z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n        coords.push_back(x);\n        coords.push_back(y);\n        coords.push_back(z);\n    }\n    {\n        sort(begin(coords), end(coords));\n        coords.erase(unique(begin(coords), end(coords)), end(coords));\n        vector<int> dict(coords.back()+1);\n        int cnt = 0;\n        for(const auto &e : coords) {\n            dict[e] = cnt++;\n        }\n        for(auto &p : ps) {\n            int x, y, z;\n            tie(x, y, z) = p;\n            p = make_tuple(dict[x], dict[y], dict[z]);\n        }\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(300000);\n    unordered_map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 300000, 0, 300000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n\n\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<stdlib.h>\n#include<set>\n#include<ctime>\n#include<cmath>\n#define eps 1e-8\n#define ex 2.7182818284590452354\n#define pi acos(-1.0)\n#define inf 0x3fffffff\n#define DC(n) printf(\"Case #%d:\",++n)\n#define SD(n) scanf(\"%d\",&n)\n#define SS(str) scanf(\"%s\",str)\n#define SDB(n) scanf(\"%lf\",&n)\n#define ll __int64\n#define mm 1000000007\n#define mmax  100010\nusing namespace std;\n\nint a, b, C , M = (1<<16)-1;\nint r()\n{\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\n\n\nstruct point\n{\n    int x,y,z;\n    int id;\n}p[1000010];\n\n\nint dp[1000010];\nstruct node\n{\n    int l,r;\n    int max_n;\n    int mid()\n    {\n        return (l+r)>>1;\n    }\n}T[4*1000010];\n\nbool cmpx(point x,point y)\n{\n    if(x.x==y.x)\n    {\n        if(x.y==y.x)\n            return x.z<y.z;\n        return x.y<y.y;\n    }\n    return x.x<y.x;\n}\nbool cmpy(point x,point y)\n{\n    return x.y<y.y;\n}\n\nbool cmpid(point x ,point  y)\n{\n    return x.id<y.id;\n}\nvoid build(int id,int l,int r)\n{\n    T[id].l=l,T[id].r=r;\n    T[id].max_n=0;\n    if(l==r)\n        return ;\n    int mid=T[id].mid();\n    build(id<<1,l,mid);\n    build(id<<1|1,mid+1,r);\n}\n\nint query(int id,int l,int r)\n{\n    if(l<=T[id].l&&T[id].r<=r)\n        return T[id].max_n;\n    int mid=T[id].mid();\n    int ans=0;\n    if(mid>=l)\n        ans=max(ans,query(id<<1,l,r));\n    if(mid<r)\n        ans=max(ans,query(id<<1|1,l,r));\n    return ans;\n}\n\nvoid updata(int id,int pos,int val)\n{\n    if(T[id].l==T[id].r)\n    {\n        T[id].max_n=val;\n        return ;\n    }\n    int mid=T[id].mid();\n    if(mid>=pos)\n        updata(id<<1,pos,val);\n    else\n        updata(id<<1|1,pos,val);\n    T[id].max_n=max(T[id<<1].max_n,T[id<<1|1].max_n);\n}\nvoid solve(int l,int r)\n{\n    //cout<<l<<\" \"<<r<<endl;\n    if(l==r)\n        return ;\n    if(p[l].x==p[r].x)\n        return ;\n    int mid=(l+r)>>1;\n    while(mid>l&&mid<r&&p[mid].x==p[mid+1].x)\n        mid--;\n    solve(l,mid);\n    sort(p+l,p+r+1,cmpy);\n//    if(l==1&&r==3)\n//    {\n//        for(int i=1;i<=3;i++)\n//        {\n//            cout<<p[i].x<<\" \"<<p[i].y<<\" \"<<p[i].z<<\" \"<<p[i].id<<endl;\n//        }\n//    }\n    for(int i=l;i<=r;i++)\n    {\n        int en=i;\n        while(en<=r&&p[en].y==p[i].y)\n            en++;\n        for(int j=i;j<en;j++)\n        {\n            if(p[j].id>mid&&p[j].z>1)\n            {\n                int tmp=query(1,1,p[j].z-1);\n                dp[ p[j].id ]=max(dp[ p[j].id ],tmp+1);\n            }\n        }\n        for(int j=i;j<en;j++)\n        {\n            if(p[j].id<=mid)\n            {\n                int tmp=query(1,p[j].z,p[j].z);\n                if(dp[ p[j].id ]>tmp)\n                    updata(1,p[j].z,dp[ p[j].id ]);\n            }\n        }\n        i=en;\n        i--;\n    }\n    for(int i=l;i<=r;i++)\n    {\n        if(p[i].id<=mid)\n            updata(1,p[i].z,0);\n    }\n    sort(p+l,p+r+1,cmpid);\n//    if(l==1&&r==3)\n//    {\n//        for(int i=l;i<=r;i++)\n//        {\n//            cout<<dp[i]<<\" \";\n//        }\n//        cout<<endl;\n//    }\n//    if(l==1&&r==6)\n//    {\n//        for(int i=l;i<=r;i++)\n//        {\n//            cout<<dp[i]<<\" \";\n//        }\n//        cout<<endl;\n//    }\n//    cout<<l<<\"--->\"<<r<<\"  \";\n//    for(int i=l;i<=r;i++)\n//    {\n//        printf(\"%d \",dp[i]);\n//    }\n//    cout<<endl;\n    solve(mid+1,r);\n\n}\n\nint main()\n{\n\n    int m,n,A,B;\n    //freopen(\"in.txt\",\"r\",stdin);\n    while(scanf(\"%d %d %d %d\",&m,&n,&A,&B)!=EOF)\n    {\n        if(m+n+A+B==0)\n            break;\n        for(int i=1;i<=m+n;i++)\n            dp[i]=1;\n        a=A,b=B,C = ~(1<<31), M= (1<<16)-1;\n        for(int i=1;i<=m;i++)\n            scanf(\"%d %d %d\",&p[i].x,&p[i].y,&p[i].z);\n        for(int i=m+1;i<=m+n;i++)\n        {\n            p[i].x=r();\n            p[i].y=r();\n            p[i].z=r();\n        }\n        sort(p+1,p+m+n+1,cmpx);\n        for(int i=1;i<=m+n;i++)\n        {\n            p[i].x++;\n            p[i].y++;\n            p[i].z++;\n            p[i].id=i;\n            //cout<<p[i].x<<\" \"<<p[i].y<<\" \"<<p[i].z<<endl;\n        }\n        build(1,1,1000001);\n        solve(1,m+n);\n        int ans=0;\n        for(int i=1;i<=m+n;i++)\n            ans=max(ans,dp[i]);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : i > j; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? y[py[clx]] : 1 << 30), vr = (crx != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 300005\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n \nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n \nint x[MAX],y[MAX],z[MAX];\nset< P > t[MAX];\n \n \nvoid insert(set<P> &s,P p){\n  set<P> :: iterator it;\n  while(1){\n    it=s.upper_bound(p);\n    if(it==s.end())break;\n \n    if( p.first <= it->first &&\n        p.second <= it->second ){\n      s.erase(it);\n    }else{\n      break;\n    }\n  }\n  s.insert(p);\n}\n \nbool check(set<P> &s,P p){\n  set<P> :: iterator it;\n  it=s.upper_bound(p);\n  int cc=0;\n  while(it!=s.begin()){\n    cc++;\n    if(cc>3)break;\n \n    it--;\n    if(it->first < p.first)\n      if(it->second < p.second)\n        return true;\n  }\n  return false;\n}\n \nint calc(P p){\n  int left=0,right=m+n,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(t[mid],p))left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n \n \nvector<P> G[1000005];\n \nint solve(){\n  int ans=1;\n \n  for(int i=0;i<=m+n;i++){\n    t[i].clear();\n  }\n  t[0].insert(P(-1,-1));\n  set<int> st;\n \n  for(int i=0;i<m+n;i++){\n    st.insert( z[i] );\n    G[ z[i] ].push_back( P(x[i],y[i]) );\n  }\n \n  for( int i : st ){\n    vector<int> v( G[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      v[j]=calc(G[i][j]);\n      ans=max(ans,v[j]);\n    }\n    for(int j=0;j<(int)G[i].size();j++){\n      if(check( t[ v[j] ] , G[i][j])==false)\n        insert(t[ v[j] ],G[i][j]);\n    }\n    G[i].clear();    \n  }\n  /*\n  for(int i=0;i<=ans;i++){\n    cout<<i<<\" :\"<<endl;\n    for(P p:t[i]){\n      cout<<p.first<<' '<<p.second<<endl;\n    }\n    cout<<endl;\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  return ans;\n}\n \nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n \n    a=A,b=B;\n     \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n \n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n \n \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\nusing namespace std;\n\n\n\nnamespace _RMQ{\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\nclass SparseSegtree{\n\tstruct Node{\n\t\tchar height;\n\t\tpair<int,int>  key;\n\t\tint value, rangev;\n\n\t\tNode *left,*right;\n\t\tNode(pair<int,int> k,int v)\n\t\t\t:height(1),key(k),value(v),rangev(v),left(0),right(0){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\n\t\tint query(int a,int b,int l,int r)const{\n\t\t\tif(!this||r<=a||b<=l)return nil;\n\t\t\tif(a<=l&&r<=b)return rangev;\n\t\t\tint res=func(left->query(a,b,l,key.first+1),right->query(a,b,key.first,r));\n\t\t\tif(a<=key.first&&key.first<b)res=func(res,value);\n\t\t\treturn res;\n\t\t}\n\t\tNode *insert(pair<int,int> k,int v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tif(k < key){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else{\n\t\t\t\tright = right->insert(k,v);\n\t\t\t}\n\t\t\treturn balance();\n\t\t}\n\t\tNode *erase(pair<int,int> k){\n\t\t\tif(!this)return NULL;\n\t\t\tif(k==key){\n\t\t\t\tNode *le=left,*ri=right;\n\t\t\t\tleft=right=NULL;\n\t\t\t\tdelete this;\n\t\t\t\tif(!le)return ri;\n\t\t\t\tif(!ri)return le;\n\t\t\t\tNode *t;\n\t\t\t\tle = le->erase_max(&t);\n\t\t\t\tt->left = le;\n\t\t\t\tt->right = ri;\n\t\t\t\treturn t->balance();\n\t\t\t}\n\t\t\tif(k < key){\n\t\t\t\tleft = left->erase(k);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->erase(k);\n\t\t\t}else return this;\n\t\t\treturn balance();\n\t\t}\n\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_value();\n\t\t}\n\t\tvoid update_value(){\n\t\t\trangev=value;\n\t\t\tif(left)rangev=func(rangev,left->rangev);\n\t\t\tif(right)rangev=func(rangev,right->rangev);\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t\tNode* erase_max(Node **maxnode){\n\t\t\tif(right){\n\t\t\t\tright = right->erase_max(maxnode);\n\t\t\t\treturn balance();\n\t\t\t}else{\n\t\t\t\t*maxnode=this;\n\t\t\t\treturn left;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tint calc_max_key()const{\n\t\tNode *p=root;\n\t\tif(!p)return -1;\n\t\twhile(p->right)p=p->right;\n\t\treturn p->key.first;\n\t}\n\tint max_key;\npublic:\n\tSparseSegtree():root(0),max_key(-1){}\n\t~SparseSegtree(){if(root)delete root;}\n\tvoid insert(pair<int,int> k,int v){\n\t\tmax_key=max(max_key,k.first);\n\t\troot=root->insert(k,v);\n\t}\n\tvoid erase(pair<int,int> k){\n\t\troot=root->erase(k);\n\t\tif(k.first==max_key)max_key=calc_max_key();\n\t}\n\tint query(int a,int b)const{//[a,b)\n\t\treturn root->query(a,b,0,max_key+1);\n\t}\n\tbool empty()const{\n\t\treturn root;\n\t}\n\tint height()const{\n\t\treturn root?root->height:0;\n\t}\n};\n\n};\n\n\ntemplate<int XSIZE=1<<20>\nclass Dynamic2DRMQ{\n\tstruct Node{\n\t\t_RMQ::SparseSegtree rmq;\n\t\tNode *left,*right;\n\t\tNode():left(0),right(0){}\n\t\t~Node(){\n\t\t\tdelete left;\n\t\t\tdelete right;\n\t\t}\n\t\tint query(int a,int b,int l,int r,int ys,int ye)const{\n\t\t\tif(!this||r<=a||b<=l)return _RMQ::nil;\n\t\t\tif(a<=l&&r<=b)return rmq.query(ys,ye);\n\t\t\treturn _RMQ::func(left->query(a,b,l,(l+r)/2,ys,ye),right->query(a,b,(l+r)/2,r,ys,ye));\n\t\t}\n\t\tvoid insert(int x,int y,int v,int l,int r){\n\t\t\trmq.insert(make_pair(y,x),v);\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tif(!left)left=new Node();\n\t\t\t\tleft->insert(x,y,v,l,(l+r)/2);\n\t\t\t}else{\n\t\t\t\tif(!right)right=new Node();\n\t\t\t\tright->insert(x,y,v,(l+r)/2,r);\n\t\t\t}\n\t\t}\n\t\tvoid erase(int x,int y,int l,int r){\n\t\t\trmq.erase(make_pair(y,x));\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tleft->erase(x,y,l,(l+r)/2);\n\t\t\t\tif(left->rmq.empty()){\n\t\t\t\t\tdelete left;\n\t\t\t\t\tleft=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tright->erase(x,y,(l+r)/2,r);\n\t\t\t\tif(right->empty()){\n\t\t\t\t\tdelete right;\n\t\t\t\t\tright=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tNode *root;\npublic:\n\tDynamic2DRMQ():root(new Node()){}\n\t~Dynamic2DRMQ(){delete root;}\n\tvoid insert(int x,int y,int v){\n\t\troot->insert(x,y,v,0,XSIZE);\n\t}\n\tvoid erase(int x,int y){\n\t\troot->erase(x,y,0,XSIZE);\n\t}\n\tint query(int xs,int xe,int ys,int ye){//[xs,xe)*[ys,ye)\n\t\treturn root->query(xs,xe,0,XSIZE,ys,ye);\n\t}\n};\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ<> rmq2d;\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(0,v[i].second.first,0,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxe], g[maxn], ct[maxe];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n  bool operator == (const Point& rhs) const {\n    return x==rhs.x && y==rhs.y && z==rhs.z;\n  }\n  bool operator < (const Point& rhs) const {\n    if(x != rhs.x) return x < rhs.x;\n    if(y != rhs.y) return y > rhs.y;\n    return z > rhs.z;\n  }\n};\n\nusing Pi = pair<int, int>;\n\nint main() {\n  int m, n, A, B;\n  while(cin >> m >> n >> A >> B, m+n) {\n    a = A, b = B;\n\n    int N = n+m;\n    vector<Point> pts(N);\n    for(int i = 0; i < m; ++i) {\n      cin >> pts[i].x >> pts[i].y >> pts[i].z;\n    }\n    for(int i = m; i < N; ++i) {\n      pts[i].x = r();\n      pts[i].y = r();\n      pts[i].z = r();\n    }\n    sort(pts.begin(), pts.end());\n\n    vector<set<Pi> > dp(N+1);\n    int ans = 1;\n    for(int i = 0; i < N; ++i) {\n      Pi p = Pi(pts[i].y, pts[i].z);\n      int lb = 0, ub = ans+1;\n      while(lb+1 < ub) {\n\tint mb = (lb+ub)/2;\n\tauto it = dp[mb].lower_bound(Pi(p.first, -1));\n\tif(it != dp[mb].begin() && (--it)->second < p.second) lb = mb;\n\telse ub = mb;\n      }\n      ans = max(ans, ub);\n      {\n\tauto it = dp[ub].lower_bound(Pi(p.first, -1));\n        if(it != dp[ub].end() && it->second >= p.second) {\n\t  dp[ub].erase(it);\n\t}\n      }\n      if(dp[ub].empty()) {\n\tdp[ub].insert(p);\n      } else {\n\tauto it = dp[ub].lower_bound(Pi(p.first, -1));\n\tif(it == dp[ub].begin() || (--it != dp[ub].end() && (it->first != p.first || it->second > p.second))) {\n\t  dp[ub].insert(p);\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\nconst int id = 0;\n\nint op(int l, int r) {\n\treturn max(l, r);\n}\n\nstruct node {\n\tint pos, val, all;\n\tnode *lch, *rch;\n\tnode() {}\n\tnode(int p, int v)\n\t\t: pos(p), val(v), all(v), lch(nullptr), rch(nullptr) {}\n\tvoid *operator new(size_t) {\n\t\tstatic const int pmax = 6e6;\n\t\tstatic node pool[pmax];\n\t\treturn pool + it++;\n\t}\n};\n\nvoid update_up(node* t) {\n\tt->all = op(op((t->lch ? t->lch->all : id), t->val), (t->rch ? t->rch->all : id));\n}\n\nnode *update(node* t, int p, int val, int lb = 0, int ub = MAX) {\n\tif (!t) return new node(p, val);\n\tif (t->pos == p) {\n\t\tt->val = val;\n\t\tupdate_up(t);\n\t\treturn t;\n\t}\n\tint m = (lb + ub) >> 1;\n\tif (p < m) {\n\t\tif (t->pos < p) {\n\t\t\tswap(t->pos, p);\n\t\t\tswap(t->val, val);\n\t\t\tupdate_up(t);\n\t\t}\n\t\tt->lch = update(t->lch, p, val, lb, m);\n\t}\n\telse {\n\t\tif (t->pos > p) {\n\t\t\tswap(t->pos, p);\n\t\t\tswap(t->val, val);\n\t\t\tupdate_up(t);\n\t\t}\n\t\tt->rch = update(t->rch, p, val, m, ub);\n\t}\n\tupdate_up(t);\n\treturn t;\n}\n\nint find(node* t, int l, int r, int lb = 0, int ub = MAX) {\n\tif (!t || r <= lb || ub <= l) return id;\n\tif (l <= lb && ub <= r) return t->all;\n\tint m = (lb + ub) >> 1;\n\tint val = l <= t->pos && t->pos < r ? t->val : id;\n\treturn op(op(find(t->lch, l, r, lb, m), val), find(t->rch, l, r, m, ub));\n}\n\nnode* segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, find(segs[--r], 0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nclass HappySequence{\npublic:\n\tmap<int,int> seq;\n\tHappySequence(){ int inf = 1e9; seq[-inf] = -inf; }\n\tbool insert(int key,int val){\n\t\tif( (--seq.upper_bound(key))->second >= val ) return false;\n\t\tseq[key] = val;\n\t\tauto it = ++seq.find(key);\n\t\twhile( it != seq.end() && (*it).second <= val ) seq.erase(it++);\n\t\treturn true;\n\t}\n};\n\nHappySequence seg[1000100];\n\nvoid ins(int y,int z,int v){\n\tfor(int i = y ; i < 1000100 ; i += i & -i ) seg[i].insert(z,v);\n}\nint get(int y,int z){\n\tint v = 0;\n\tfor(int i = y ; i > 0 ; i -= i & -i ){\n\t\tv = max(v,(--seg[i].seq.lower_bound(z))->second);\n\t}\n\treturn v;\n}\n\nint main(){\n\tint n,m,A,B;\n\twhile( cin >> m >> n >> A >> B && n+m ){\t\n\t\ta = A;\n\t\tb = B;\n\t\tvector< array<int,3> > ps;\n\t\tvector<int> uy;\n\t\tfor(int i = 0 ; i < m ; i++){\t\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tsort(uy.begin(),uy.end());\n\t\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\t\tfor(int i = 0 ; i <= uy.size() ; i++) seg[i] = HappySequence();\n\t\tsort(ps.begin(),ps.end(),[&](array<int,3> a,array<int,3> b){\n\t\t\tif( a[0] != b[0] ) return a[0] < b[0];\n\t\t\treturn make_pair(a[1],a[2]) > make_pair(b[1],b[2]);\n\t\t});\n\t\tint ans = 0;\n\t\tfor( auto p : ps ){\n\t\t\tp[1] = lower_bound(uy.begin(),uy.end(),p[1]) - uy.begin() + 1;\n\t\t\tint mx = get(p[1]-1,p[2]) + 1;\n\t\t\tans = max(ans,mx);\n\t\t\tins(p[1],p[2],mx);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define srep(i, s, t) for (int i = (int)(s); i < (int)(t); ++i)\n#define each(a, b) for (auto&(a) : (b))\n#define all(v) (v).begin(), (v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)), v.erase(unique(all(v)), v.end())\n#define cmx(x, y) x = max(x, y)\n#define cmn(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define spair(p) cout << #p << \": \" << p.fi << \" \" << p.se << endl\n#define sar(a, n)                          \\\n    cout << #a << \":\";                     \\\n    rep(kbrni, n) cout << \" \" << a[kbrni]; \\\n    cout << endl\n#define svec(v)                                   \\\n    cout << #v << \":\";                            \\\n    rep(kbrni, v.size()) cout << \" \" << v[kbrni]; \\\n    cout << endl\n#define svecp(v)                                                              \\\n    cout << #v << \":\";                                                        \\\n    each(kbrni, v) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n#define sset(s)                          \\\n    cout << #s << \":\";                   \\\n    each(kbrni, s) cout << \" \" << kbrni; \\\n    cout << endl\n#define smap(m)                                                               \\\n    cout << #m << \":\";                                                        \\\n    each(kbrni, m) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nll A, B;\nint C = ~(1 << 31), M = (1 << 16) - 1;\n\nll r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000001];\n\nbool contain(int cri, P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi - 1, nw.se));\n    if (it != st[cri].begin()) {\n        --it;\n        return it->se < nw.se;\n    } else {\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int n, m;\n        cin >> m >> n >> A >> B;\n        rep(i, n + m + 1)\n        {\n            st[i].clear();\n        }\n        rep(i, 1000000)\n        {\n            v[i].clear();\n        }\n        if (n == 0 && m == 0 && A == 0 && B == 0) {\n            break;\n        }\n        rep(i, m)\n        {\n            int s, t, u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t, u));\n        }\n        rep(i, n)\n        {\n            v[r()].pb(P(r(), r()));\n        }\n        int mx = -1;\n        rep(i, 1000001)\n        {\n            if (len(v[i])) {\n                sort(all(v[i]), [&](const P& p, const P& q) {\n                    return (p.fi == q.fi) ? (p.se > q.se) : (p.fi > q.fi);\n                });\n                each(it, v[i])\n                {\n                    int l = -1, r = mx + 1;\n                    while (r - l > 1) {\n                        int mid = (l + r) / 2;\n                        if (contain(mid, it)) {\n                            l = mid;\n                        } else {\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if (it2 != st[r].begin()) {\n                        --it2;\n                        if (it2->se <= it.se) {\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while (1) {\n                        if (it2 != st[r].end()) {\n                            if (it2->se >= it.se) {\n                                it2 = st[r].erase(it2);\n                            } else {\n                                cmx(mx, r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        } else {\n                            cmx(mx, r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx + 1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n  \nvoid init(int m_){\n    m0=1;\n    while(m0<m_) m0*=2;\n    for(int i=0; i<2*m0-1; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      v[i].push_back(0);\n    }\n  }\n}\n  \nvoid update(int k, int i, int a){\n    i+=(m[k]-1);\n    v[k][i]=a;\n    while(i>0){\n        i=(i-1)/2;\n        v[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n    }\n}\n \nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n    if(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n \nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n \nint find0(int y, int z, int k, int l, int r){\n    if(r<=0 || y<=l) return 0;\n    if(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n        return find(k, i, 0, 0, m[k]);\n    }else{\n        int vl=find0(y, z, k*2+1, l, (l+r)/2);\n        int vr=find0(y, z, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n\t  set<int> st;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n\t\tst.insert(x); st.insert(y); st.insert(z);\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n\t\tst.insert(x); st.insert(y); st.insert(z);\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n\t  map<int, int> mp;\n\t  int ct=0;\n\t  for(auto x:st){\n\t\t  mp[x]=ct;\n\t\t  ct++;\n\t  }\n\t  for(int i=0; i<p.size(); i++){\n\t\t  p[i].first=mp[p[i].first];\n\t\t  p[i].second.first=mp[p[i].second.first];\n\t\t  p[i].second.second=mp[p[i].second.second];\n\t  }\n      init(ct);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(ct+1, ct+1, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[500000];\nint anss[500010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        // calced[make_pair(1e+9, 1e+9)] = 0;\n        // calced[make_pair(-1e+9, -1e+9)] = 0;\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 2;\n        // int sqn = 10000;\n        if (sqn < 1) { sqn = 1; }\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                // calced[make_pair(ps[pos][1], ps[pos][2])] = anss[pos];\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.5;\n        // int sqn = 10000;\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            vector<pair<int, int> > should_remove;\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            vector<pair<pair<int, int>, int> > ncalced;\n            auto it = should_remove.begin();\n            REP(i, calced.size()) {\n                if (it != should_remove.end() && calced[i].first == *it) {\n                    it++;\n                    continue;\n                }\n                ncalced.push_back(calced[i]);\n            }\n            calced = ncalced;\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n#include <climits>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i][0] = x;\n\t\t\tv[i][1] = -y;\n\t\t\tv[i][2] = -z;\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tv[i][0] = rnd(a, b);\n\t\t\tv[i][1] = -rnd(a, b);\n\t\t\tv[i][2] = -rnd(a, b);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mp = mps[mid - 1];\n\t\t\t\tauto it = mp.upper_bound(y);\n\t\t\t\tif(it != mp.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint &t = mps[left].emplace(y, INT_MIN).first->second;\n\t\t\tt = max(t, z);\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint LT,RT,LB,RB;\n\tint val;\n\tnode(){\n\t\tLT=RT=LB=RB=-1;\n\t\tval=0;\n\t}\n\tnode(int a,int b,int c,int d,int e){\n\t\tLT=a;\n\t\tRT=b;\n\t\tLB=c;\n\t\tRB=d;\n\t\tval=e;\n\t}\n};\nnode pool[8000000];\nint ind;\nint Ret;\nint nowret=0;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int t){\n\tif(d<a||b<c)return 0;\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d&&g<=e&&f<=h)return pool[t].val;\n\tif(nowret>pool[t].val)return 0;\n\tint ret=0;\n\tif(~pool[t].LT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,e,(e+f)/2,g,h,pool[t].LT));\n\t}\n\tif(~pool[t].RT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,(e+f)/2+1,f,g,h,pool[t].RT));\n\t}\n\tif(~pool[t].LB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,e,(e+f)/2,g,h,pool[t].LB));\n\t}\n\tif(~pool[t].RB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,(e+f)/2+1,f,g,h,pool[t].RB));\n\t}\n\treturn ret;\n}\ninline void update(int row,int col,int C){\n\tint now=0;\n\tint a=0;\n\tint b=1048575;\n\tint c=0;\n\tint d=1048575;\n\twhile(1){\n\t\tpool[now].val=max(pool[now].val,C);\n\t\tif(a==b)break;\n\t\tint M=(a+b)/2;\n\t\tint N=(c+d)/2;\n\t\tif(row<=M&&col<=N){//LT\n\t\t\tb=M;\n\t\t\td=N;\n\t\t\tif(~pool[now].LT){\n\t\t\t\tnow=pool[now].LT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row<=M&&col>N){//RT\n\t\t\tb=M;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RT){\n\t\t\t\tnow=pool[now].RT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col<=N){//LB\n\t\t\ta=M+1;\n\t\t\td=N;\n\t\t\tif(~pool[now].LB){\n\t\t\t\tnow=pool[now].LB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col>N){//RB\n\t\t\ta=M+1;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RB){\n\t\t\t\tnow=pool[now].RB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\t\n\t}\n}\npair<int,pair<int,int> >dat[400000];\nint x[400000];\nint y[400000];\nint z[400000];\nint Q[400000];\nint wolfa,wolfb,wolfC=~(1<<31),wolfM=(1<<16)-1;\nint r(){\n\twolfa=36969*(wolfa&wolfM)+(wolfa>>16);\n\twolfb=18000*(wolfb&wolfM)+(wolfb>>16);\n\treturn (wolfC&((wolfa<<16)+wolfb))%1000000;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,z+i);\n\t\t\tdat[i]=make_pair(x[i],make_pair(-y[i],-z[i]));\n\t\t}\n\t\twolfa=c;\n\t\twolfb=d;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint X=r();\n\t\t\tint Y=r();\n\t\t\tint Z=r();\n\t\t\tdat[i+a]=make_pair(X,make_pair(-Y,-Z));\n\t\t}\n\t\tint n=a+b;\n\t\tstd::sort(dat,dat+n);\n\t\tpool[0]=node();\n\t\tind=1;\n\t\tRet=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnowret=0;\n\t\t\tint P=max(nowret,query(0,1048575,0,-dat[i].second.first-1,0,1048575,0,-dat[i].second.second-1,0))+1;\n\t\t\tRet=max(Ret,P);\n\t\t\tQ[i]=P;\n\t\t\tupdate(-dat[i].second.first,-dat[i].second.second,P);\n\t\t}\n\t\tprintf(\"%d\\n\",Ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(type l, type r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tvoid change(node*& t, int p, T val, int lb, int ub) {\n\t\tif (!t) {\n\t\t\tt = new node(p, val);\n\t\t\treturn;\n\t\t}\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tchange(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tchange(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\tchange(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <cmath>\n#include <set>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int INF = 1<<28;\nstruct Tree {\n    using D = P;\n    struct Node;\n    using NP = Node*;\n    static Node last_d;\n    static NP last;\n    struct Node {\n        NP l, r;\n        int sz;\n        D v;\n        int mn;\n        Node(D v) :l(last), r(last), sz(1), v(v), mn(v.second) {}\n        Node(NP l, NP r, int sz = 0) :l(l), r(r), sz(sz) {}\n        void push() {\n\n        }\n        NP update() {\n            sz = 1+l->sz+r->sz;\n            mn = v.second;\n            if (l->sz) {\n                mn = min(mn, l->v.second);\n            }\n            if (r->sz) {\n                mn = min(mn, r->v.second);\n            }\n            return this;\n        }\n        int lb(D a) {\n            if (!sz) return 0;\n            if (a <= v) return l->lb(a);\n            return l->sz + 1 + r->lb(a);\n        }\n        int ub(D a) {\n            if (!sz) return 0;\n            if (v <= a) return l->sz + 1 + r->ub(a);\n            return l->ub(a);\n        }\n        int get(int a, int b) {\n            if (!sz || b <= 0 || sz <= a) return INF;\n            if (a <= 0 && sz <= b) return mn;\n            int res = INF;\n            res = min(res, l->get(a, b));\n            if (a <= l->sz && l->sz < b) res = min(res, v.second);\n            res = min(res, r->get(a - l->sz - 1, b - l->sz - 1));\n            return res;\n        }\n    } *n;\n\n    static uint xor128(){\n        static uint x=123456789,y=362436069,z=521288629,w=88675123;\n        uint t;\n        t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n    }\n    static NP merge(NP l, NP r) {\n        if (!l->sz) return r;\n        if (!r->sz) return l; \n        l->push(); r->push();\n        if (xor128() % (l->sz + r->sz) < l->sz) {\n            l->r = merge(l->r, r);\n            return l->update();\n        } else {\n            r->l = merge(l, r->l);\n            return r->update();\n        }\n    }\n    static pair<NP, NP> split(NP x, int k) {\n        if (!x->sz) return {last, last};\n        x->push();\n        if (k <= x->l->sz) {\n            auto y = split(x->l, k);\n            x->l = y.second;\n            y.second = x->update();\n            return y;\n        } else {\n            auto y = split(x->r, k- x->l->sz -1);\n            x->r = y.first;\n            y.first = x->update();\n            return y;\n        }\n    }\n\n    Tree() : n(last) {}\n    Tree(NP n) : n(n) {}\n    int sz() {\n        return n->sz;\n    }\n    void merge(Tree r) {\n        n = merge(n, r.n);\n    }\n    Tree split(int k) {\n        auto u = split(n, k);\n        n = u.first;\n        return Tree(u.second);\n    }\n    void insert(D v) {\n        auto u = split(n, lb(v));\n        n = merge(merge(u.first, new Node(v)), u.second);\n    }\n    int get(int l, int r) {\n        return n->get(l, r);\n    }\n    int lb(D v) {\n        return n->lb(v);\n    }\n    int ub(D v) {\n        return n->ub(v);\n    }\n};\nTree::Node Tree::last_d = Tree::Node(NULL, NULL, 0);\nTree::NP Tree::last = &last_d;\n\nconst int MN = 303000;\nint n;\nint x[MN], y[MN], z[MN];\nP d[MN];\nT buff[MN];\nTree g[MN];\n\nint solve() {\n    for (int i = 0; i < n; i++) {\n        buff[i] = T(x[i], -y[i], z[i]);\n    }\n    sort(buff, buff+n);\n    for (int i = 0; i < n; i++) {\n        int a, b, c;\n        tie(a,b,c) = buff[i];\n        d[i] = P(-b, c);\n        //printf(\"%d %d\\n\", d[i].first, d[i].second);\n    }\n    for (int i = 0; i <= n; i++) {\n        g[i] = Tree();\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        tie(a, b) = d[i];\n        int l = 0, r = i+1;\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (g[md].get(0, g[md].lb(P(a, 0))) < b) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        g[r].insert(d[i]);\n        res = max(res, r);\n    }\n    return res;\n}\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n    while (true) {\n        int m;\n        cin >> n >> m >> a >> b;\n        if (!n && !m) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        for (int i = n; i < n+m; i++) {\n            x[i] = r(); y[i] = r(); z[i] = r();\n        }\n        n += m;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 1000010\n#define INF (1000000050)\n\ntypedef set< pair<int,int> >::iterator It;\nint nextscore[MAX_N];\nset< pair<int,int> > seg[MAX_N];\n\nvoid add(int x,int y,int score){\n\t//cout << x << \",\" << y << \",\" << score << endl;\n\twhile(x<MAX_N){\n\t\tIt it1 = --seg[x].lower_bound(make_pair(y+1,-INF));\n\t\tIt it2 = seg[x].lower_bound(make_pair(y+1,-INF));\n\t\t\n\t\tif( it1->first <= y && it1->second >= score ){\n\t\t\tx += x & -x;\n\t\t\tcontinue;\n\t\t}\n\t\twhile( it2->first != INF && it2->second <= score ){\n\t\t\tseg[x].erase(it2++);\n\t\t}\n\t\tseg[x].insert(make_pair(y,score));\n\t\tx += x & -x;\n\t}\n}\nint get(int x,int y){\n\t//cout << \"(\" << x << \",\" << y << \")\" << endl;\n\tint maximum = 0;\n\twhile(x>0){\n\t\tIt it = --seg[x].lower_bound(make_pair(y+1,-INF));\n\t\t\n\t\t\n\t\t/*\n\t\tIt\t it = seg[x].begin();\n\t\twhile( it != seg[x].end() ){\n\t\t\tif( it->first <= y ){\n\t\t\t\tmaximum = max(maximum,it->second);\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\t*/\n\t\t//cout << \" (\" << it->first << \",\" << it->second << \")\" << endl;\n\t\tmaximum = max(maximum,it->second);\n\t\tx -= x & -x;\n\t}\n\treturn maximum;\n}\n\n\nint aa, bb, C = ~(1<<31), M = (1<<16)-1;\n\nint r() {\n\taa = 36969 * (aa & M) + (aa >> 16);\n\tbb = 18000 * (bb & M) + (bb >> 16);\n\treturn (C & ((aa << 16) + bb)) % 1000000;\n}\n\nvector< pair<int, pair<int,int> >  > inp;\n\nint main(){\n\tfor(int i = 0 ; i < MAX_N ; i++){\n\t\tseg[i].insert(make_pair(INF,INF));\n\t\tseg[i].insert(make_pair(-INF,0));\n\t}\n\tint m,n;\n\twhile(\tcin >> m >> n >> aa >> bb && m+n ){\n\t\tinp.clear();\n\t\tfor(int i = 0 ; i < MAX_N ; i++){\n\t\t\tif( seg[i].size() != 2 ){\n\t\t\t\tseg[i].clear();\n\t\t\t\tseg[i].insert(make_pair(INF,INF));\n\t\t\t\tseg[i].insert(make_pair(-INF,0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> ux;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta++;\n\t\t\tb++;\n\t\t\tc++;\n\t\t\tinp.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint a,b,c;\n\t\t\ta=r()+1;\n\t\t\tb=r()+1;\n\t\t\tc=r()+1;\n\t\t\tinp.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tsort(inp.begin(),inp.end());\n\t\tint res = 0;\n\t\tfor(int i = 0 ; i < inp.size() ; ){\n\t\t\t\n\t\t\tint j = i;\n\t\t\twhile( j < inp.size() && inp[i].first == inp[j].first ) j++;\n\t\t\tfor(int k = i ; k < j ; k++){\n\t\t\t\tint a = inp[k].second.first;\n\t\t\t\tint b = inp[k].second.second;\n\t\t\t\tnextscore[k] = get(a-1,b-1) + 1;\n\t\t\t\tres = max( res , nextscore[k] );\n\t\t\t\t//cout << k << \": \" << inp[k].first << \" \" << inp[k].second.first << \" \" << inp[k].second.second << \" \" <<  get(a-1,b-1) <<  endl;\n\t\t\t}\n\t\t\tfor(int k = i ; k < j ; k++){\n\t\t\t\tint a = inp[k].second.first;\n\t\t\t\tint b = inp[k].second.second;\n\t\t\t\tadd(a,b,nextscore[k]);\n\t\t\t}\n\t\t\ti = j;\n\t\t}\n\t\tcout << res << endl;\n\t\t//return 0;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n#include <cassert>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 2e6;\n\nstruct sad{\n    int x,y,z;\n    int pos;\n    void print()\n    {\n        printf(\"(%d,%d,%d)\\n\",x,y,z);\n    }\n}P[maxn],tmp[maxn];\n\nint n,m,A,B;\n\nint a , b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint dp[maxn];\n\nstruct cmpx\n{\n    bool operator () (const sad & a,const sad & b) const\n    {\n        return a.x < b.x;\n    }\n};\n\nstruct cmpy\n{\n    bool operator () (const sad & a,const sad & b) const\n    {\n        return a.y < b.y;\n    }\n};\n\n\nint get(int x,int *rs)\n{\n    int ret  = 0;\n    while(x)\n    {\n        ret = max( ret , rs[x] );\n        x -= x & -x;\n    }\n    return ret;\n}\n\nvoid upp(int x,int p,int *rs)\n{\n    //debug(x);\n    while(x<maxn)\n    {\n        rs[x] = max( rs[x] , p );\n        x += x & -x;\n    }\n}\n\nvoid cl(int x,int *rs)\n{\n    //debug(x);\n    while(x<maxn)\n    {\n        rs[x] = 0;\n        x += x & -x;\n    }\n}\n\nint rs[maxn];\nint rss[maxn];\n\nvoid CDQ(int l,int r)\n{\n    if(l==r) return ;\n    int m = l + r >> 1;\n    CDQ(l,m);\n    int midx = P[m].x;\n    //printf(\"l %d r %d\\n\",l,r);\n    //debug(midx);\n    for(int i=l;i<=r;i++)\n        tmp[i] = P[i];\n    sort(P+l,P+r+1,cmpy());\n    for(int i=l;i<=r;i++){\n\n        //P[i].print();\n    }\n    for(int i=l;i<=r;)\n    {\n        //debug(i);\n        int j;\n        for(j = i ; j <= r && P[j].y == P[i].y ; j++) if( P[j].pos > m )\n        {\n            //debug(j);\n            dp[ P[j].pos ] = max( get( P[j].z - 1 , rs ) + 1 , dp[ P[j].pos ] );\n            //printf(\"%d %d>\",get( P[j].z - 1 , rs ),j); P[j].print();\n            if( P[j].x > midx )\n            {\n                //printf(\"%d )\",j); P[j].print();\n                dp[ P[j].pos ] = max( get( P[j].z - 1 , rss ) + 1 , dp[ P[j].pos ] );\n            }\n        }\n        for(j = i ; j <= r && P[j].y == P[i].y ; j++) if( P[j].pos <= m )\n        {\n            if( P[j].x < midx )\n                upp( P[j].z , dp[ P[j].pos ] , rs );\n            else upp( P[j].z , dp[ P[j].pos ] , rss );\n        }\n        i = j;\n    }\n    for(int i=l;i<=r;i++)\n    {\n        cl( P[i].y , rs );\n        cl( P[i].y , rss );\n    }\n    for(int i=l;i<=r;i++)\n        P[i] = tmp[i];\n    for(int i=l;i<=r;i++){\n        //printf(\"%d \",dp[i]);\n        //P[i].print();\n    }\n    //printf(\"\\n\");\n    CDQ(m+1,r);\n}\n\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d%d%d\",&m,&n,&A,&B))\n    {\n        //printf(\"n %d\\n\",n);\n        if( n == 0 && m == 0 && A == 0 && B == 0 ) break;\n        a = A;\n        b = B;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%d\",&P[i].x,&P[i].y,&P[i].z);\n            //P[i].print();\n        }\n        for(int i=m;i<m+n;i++)\n        {\n            P[i].x = r();\n            P[i].y = r();\n            P[i].z = r();\n            //P[i].print();\n        }\n        n+=m;\n       // for(int i=0;i<n;i++){\n      //      P[i].print();\n      //  }\n        sort(P,P+n,cmpx());\n        for(int i=0;i<n;i++){\n            P[i].pos = i;\n            P[i].x++;\n            P[i].y++;\n            P[i].z++;\n            dp[i] = 1;\n        }\n        clr(rs,0);\n        clr(rss,0);\n        //debug('d');\n        CDQ(0,n-1);\n        //debug('d');\n        int ans = 0;\n        for(int i=0;i<n;i++)\n            ans = max( ans , dp[i] );\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct bit {\n\tint N;\n\tvector<int> a;\n\tbit(int _N = 0) : N(_N), a(N + 1) {}\n\tint get(int i) {\n\t\tint val = 0;\n\t\tfor (; i; i -= i & -i) val = max(val, a[i]);\n\t\treturn val;\n\t}\n\tvoid set(int i, int val) {\n\t\tfor (i++; i < N; i += i & -i) a[i] = max(a[i], val);\n\t}\n};\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) { delete lch; delete rch; }\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tbit bt;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tbt = bit(X.size()); // new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) { delete lch; delete rch; }\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn bt.get(r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tbt.set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n  \nstruct Node {\n  int Value;\n  int Data;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int RMQ;\n  \n  Node(int V, int T):Value(V), Data(T), SubTreeSize(1), RMQ(T) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\n\ninline int Sum(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> RMQ);\n}\ninline Node *Update(Node *t)\n{\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  t -> RMQ = max(Sum(t -> Lch), max(Sum(t -> Rch), t -> Data));\n  return(t);\n}\n  \ninline Node *MakeRoot(int value, int T)\n{\n  return(new Node(value, T));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value, int T)\n{\n  Node *p = MakeRoot(value, T);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  if(root == (Node *)NULL) return(0);\n  if(Value < root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n  \nNode *Insert(Node *root, int Value, int T)\n{\n  return(Insert(root, Lower_Bound(root, Value), Value, T));\n}\n\nstruct MatrixSegmentTree\n{\n  vector< Node* > node;\n  int sz;\n  \n  MatrixSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    node.resize(2 * sz - 1);\n    for(int i = 0; i < 2 * sz - 1; i++) {\n      node[i] = (Node *)NULL;\n    }\n  }\n  \n  int MatrixMax(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return(0);\n    } else if(a <= l && r <= b) {\n      auto p = Split(node[k], Lower_Bound(node[k], x - 1));\n      int maximum = Sum(p.first);\n      node[k] = Merge(p.first, p.second);\n      return(maximum);\n    } else {\n      int LL = MatrixMax(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      int RR = MatrixMax(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      return(max(LL, RR));\n    }\n  }\n  \n  int MatrixMax(int a, int b)\n  {\n    return(MatrixMax(0, a, b, 0, 0, sz));\n  }\n  \n  void PointUpdate(int k, int b, int val)\n  {\n    k += sz - 1;\n    node[k] = Insert(node[k], b, val);\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      node[k] = Insert(node[k], b, val);\n    }\n  }\n};\n\ninline int r(int& a, int& b)\n{\n  int C = ~(1<<31), M = (1<<16)-1;\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main()\n{\n  \n  int n, m, a, b;\n  while(scanf(\"%d %d %d %d\", &m, &n, &a, &b), m+n) {\n    \n    vector< tuple< int, int, int > > g;\n    vector< int > nums;\n    for(int i = 0; i < m; i++) {\n      int x, y, z;\n      scanf(\"%d %d %d\", &x, &y, &z);\n      g.emplace_back(x, y, z);\n    }\n    for(int i = m; i < m + n; i++) {\n      g.emplace_back(r(a, b), r(a, b), r(a, b));\n    }\n    n += m;\n    \n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      nums.push_back(yy);\n    }\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      yy = lower_bound(begin(nums), end(nums), yy) - begin(nums);\n      g[i] = make_tuple(xx, -yy, -zz);\n    }\n    sort(g.begin(), g.end());\n    \n    // O(n log^2 n)\n    MatrixSegmentTree tree(nums.size());\n    int ret = 0;\n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      yy *= -1; zz *= -1;\n      int get = tree.MatrixMax(yy, zz) + 1;\n      ret = max(ret, get);\n      tree.PointUpdate(yy, zz, get);\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint A, B, C = ~(1<<31), Ma = (1<<16)-1;\nint r() {\n  A = 36969 * (A & Ma) + (A >> 16);\n  B = 18000 * (B & Ma) + (B >> 16);\n  return (C & ((A << 16) + B)) % 1000000;\n}\n\nll M,N;\nll x[300001],y[300001],z[300001];\nll ord[300001],Y[300001],Z[300001];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin>>M>>N>>A>>B;\n    if(M+N==0)break;\n    rep(i,M){\n      cin>>x[i]>>y[i]>>z[i];\n      ord[i]=i;\n    }\n    rep(i,N){\n      x[i+M]=r(); y[i+M]=r(); z[i+M]=r(); ord[i+M]=i+M;\n    }\n    N+=M;\n    sort(ord,ord+N,[](const ll& a,const ll& b){\n      if(x[a]==x[b]&&y[a]==y[b])return z[a] > z[b];\n      else if(x[a]==x[b])return y[a] > y[b];\n      else return x[a] < x[b];\n    });\n    rep(i,N){\n      Y[i]=y[ord[i]];\n      Z[i]=z[ord[i]];\n    }\n\n    vector<set<P> > st(N,set<P>());\n    ll res=1;\n    st[0].insert(P(Y[0],Z[0]));\n    repl(i,1,N){\n      ll lb=-1,ub=res;\n      while(ub-lb>1){\n        ll m=(lb+ub)/2;\n        auto it=st[m].lower_bound(P(Y[i],-1));\n        if(it!=st[m].begin()&&(--it)->se<Z[i])lb=m;\n        else ub=m;\n      }\n\n      maxch(res,ub+1);\n\n      auto it=st[ub].lower_bound(P(Y[i],-1));\n      while(it!=st[ub].end()&&it->se>=Z[i])it=st[ub].erase(it);\n\n      it=st[ub].lower_bound(P(Y[i],-1));\n      if(st[ub].size()==0)st[ub].insert(P(Y[i],Z[i]));\n      else if(it->fi!=Y[i]){\n        st[ub].insert(P(Y[i],Z[i]));\n      }\n    }\n    cout<<res<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint a,b,c=~(1<<31),M=(1<<16)-1;\n\nint r(){\n    a=36969*(a&M)+(a>>16);\n    b=18000*(b&M)+(b>>16);\n    return (c&((a<<16)+b))%1000000;\n}\n\nset<pair<int,int>> st[303030];\nint main(){\n    int m,n;\n    while(cin>>m>>n>>a>>b,m+n!=0){\n        int l=m+n;\n        int x[l],y[l],z[l];\n        rep(i,m)cin>>x[i]>>y[i]>>z[i];\n        rep(i,n){\n            x[i+m]=r();\n            y[i+m]=r();\n            z[i+m]=r();\n        }\n        vector<int> ord(l);\n        rep(i,l)ord[i]=i;\n        sort(ord.begin(),ord.end(),[&](int s,int t){return x[s]==x[t] ? y[s]>y[t] : x[s]<x[t];});\n        rep(i,303030){\n            if(st[i].size()==2)continue;\n            st[i].clear();\n            st[i].insert({inf,-inf});\n            st[i].insert({-inf,inf});\n        }\n        int ans=0;\n        for(auto i:ord){\n            int left=0,right=ans+1;\n            while(right-left>1){\n                int mid=(left+right)/2;\n                auto itr=--st[mid].lower_bound({y[i],-1});\n                if(itr->second<z[i])left=mid;\n                else right=mid;\n            }\n            int ret=left+1;\n            ans=max(ret,ans);\n            auto itr=--st[ret].lower_bound({y[i],inf});\n            if(z[i]>=itr->second)continue;\n            if(itr->first<y[i])itr++;\n            while(itr->second>=z[i])itr=st[ret].erase(itr);\n            st[ret].insert({y[i],z[i]});\n        }\n        cout<<ans<<endl;\n    } \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing ll = long long;\n\nint a,b;\n// const int C = ~(1<<31);\nconst int C = (1<<30) + ((1<<30) - 1);\nconst int M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nusing pii = pair<int,int>;\n\npair<int,pii> points[325252];\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tscanf(\"%d%d%d%d\",&n,&m,&a,&b);\n\t\tif(n+m+a+b==0)break;\n\t\tREP(i,n){\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx++; y++; z++;\n\t\t\tpoints[i] = make_pair(x,pii(y,z));\n\t\t}\n\t\tREP(i,m){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tx++; y++; z++;\n\t\t\tpoints[i+n] = make_pair(x,pii(y,z));\n\t\t}\n\t\tn += m;\n\t\tsort(points, points+n, [&](pair<int,pii> a, pair<int,pii> b){\n\t\t\tif(a.first != b.first)return a.first < b.first;\n\t\t\treturn a.second > b.second;\n\t\t});\n\t\tconst int N = 1000025;\n\t\tstd::unordered_map<int,std::map<int,int>> bit;\n\t\tauto add = [&](int y, int z, int v){\n\t\t\tfor(; y<N; y+=y&-y){\n\t\t\t\t// add to y\n\t\t\t\tif(bit.count(y)==0){\n\t\t\t\t\tbit[y] = std::map<int,int>();\n\t\t\t\t\tbit[y][-1] = -252521;\n\t\t\t\t}\n\t\t\t\tstd::map<int,int> &mp = bit[y];\n\t\t\t\tauto it = mp.upper_bound(z); it--;\n\t\t\t\tif(it->second >= v)continue;\n\t\t\t\tmp[z] = v;\n\t\t\t\tit = mp.upper_bound(z);\n\t\t\t\twhile(it != mp.end() && it->second <= v){\n\t\t\t\t\tmp.erase(it++);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tauto query = [&](int y, int z){\n\t\t\tint ans = 0;\n\t\t\tfor(; y>0; y-=y&-y){\n\t\t\t\t// get from y\n\t\t\t\tif(bit.count(y)==0)continue;\n\t\t\t\tstd::map<int,int> &mp = bit[y];\n\t\t\t\tauto it = mp.upper_bound(z); it--;\n\t\t\t\tans = max(ans, it->second);\n\t\t\t}\n\t\t\treturn ans;\n\t\t};\n\t\tint ans = 0;\n\t\tREP(i,n){\n\t\t\tint x = points[i].first;\n\t\t\tint y = points[i].second.first;\n\t\t\tint z = points[i].second.second;\n\t\t\tint v = query(y-1, z-1) + 1;\n\t\t\tans = max(ans, v);\n\t\t\tadd(y,z,v);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode() {}\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it;\nconst int pmax = 6e7;\n\nnode pool[pmax];\n\nnode *segs[MAX * 2];\n\nnode *new_node(int val) {\n\tassert(it < pmax);\n\tpool[it].val = val;\n\tpool[it].l = pool[it].r = nullptr;\n\treturn pool + it++;\n}\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new_node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nint main() {\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, x));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, x));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int x, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, x))-v1[k].begin();\n  if(i<v1[k].size()){\n    update(k, i, a);\n  }\n  if(r-l>1){\n    update0(x, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(x, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      //vector<Pint> p;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        //p[x].push_back({y, z});\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        //p[x].push_back({y, z});\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      //for(int x=0; x<mx+1; x++){\n      //  if(p[x].empty()) continue;\n      //  sort(p[x].begin(), p[x].end());\n      //  p[x].erase(unique(p[x].begin(), p[x].end()), p[x].end());\n      //}\n      init(mx+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(x, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          \n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(x, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(mx+1, mx+1, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n  bool operator == (const Point& rhs) const {\n    return x==rhs.x && y==rhs.y && z==rhs.z;\n  }\n  bool operator < (const Point& rhs) const {\n    if(x != rhs.x) return x < rhs.x;\n    if(y != rhs.y) return y > rhs.y;\n    return z > rhs.z;\n  }\n};\n\nstruct Point2D {\n  int y, z;\n  Point2D(){}\n  Point2D(int y, int z):y(y), z(z){}\n  bool operator == (const Point2D& rhs) const {\n    return y==rhs.y;\n  }\n  bool operator < (const Point2D& rhs) const {\n    return y < rhs.y;\n  }\n};\n\n\nint main() {\n  int m, n, A, B;\n  while(cin >> m >> n >> A >> B, m+n) {\n    a = A, b = B;\n\n    int N = n+m;\n    vector<Point> pts(N);\n    for(int i = 0; i < m; ++i) {\n      cin >> pts[i].x >> pts[i].y >> pts[i].z;\n    }\n    for(int i = m; i < N; ++i) {\n      pts[i].x = r();\n      pts[i].y = r();\n      pts[i].z = r();\n    }\n    sort(pts.begin(), pts.end());\n\n    vector<set<Point2D> > dp(N+1);\n    int ans = 1;\n    for(int i = 0; i < N; ++i) {\n      Point2D p = Point2D(pts[i].y, pts[i].z);\n      int lb = 0, ub = ans+1;\n      while(lb+1 < ub) {\n\tint mb = (lb+ub)/2;\n\tauto it = dp[mb].lower_bound(p);\n\tif(it != dp[mb].begin() && (--it)->z < p.z) lb = mb;\n\telse ub = mb;\n      }\n      ans = max(ans, ub);\n      if(!dp[ub].empty()) {\n\tauto it = dp[ub].lower_bound(p);\n\twhile(it != dp[ub].end() && it->z >= p.z) {\n\t  it = dp[ub].erase(it);\n\t}\n      }\n      if(dp[ub].empty()) {\n\tdp[ub].insert(p);\n      } else {\n\tauto it = dp[ub].lower_bound(p);\n\tif(it == dp[ub].begin() || (--it != dp[ub].end() && (it->y != p.y || it->z > p.z))) {\n\t  dp[ub].insert(p);\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode() {}\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it;\nconst int pmax = 8.7e7;\n\nnode pool[pmax];\n\nnode *segs[MAX * 2];\n\nnode *new_node(int val) {\n\tassert(it < pmax);\n\tpool[it].val = val;\n\tpool[it].l = pool[it].r = nullptr;\n\treturn pool + it++;\n}\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new_node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <cmath>\n#include <set>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int INF = 1<<28;\nstruct Tree {\n    //using D = P;\n    typedef P D;\n    struct Node;\n    //using NP = Node*;\n    typedef Node* NP;\n    static Node last_d;\n    static NP last;\n    struct Node {\n        NP l, r;\n        int sz;\n        D v;\n        int mn;\n        Node(D v) :l(last), r(last), sz(1), v(v), mn(v.second) {}\n        Node(NP l, NP r, int sz = 0) :l(l), r(r), sz(sz) {}\n        void push() {\n\n        }\n        NP update() {\n            sz = 1+l->sz+r->sz;\n            mn = v.second;\n            if (l->sz) {\n                mn = min(mn, l->v.second);\n            }\n            if (r->sz) {\n                mn = min(mn, r->v.second);\n            }\n            return this;\n        }\n        int lb(D a) {\n            if (!sz) return 0;\n            if (a <= v) return l->lb(a);\n            return l->sz + 1 + r->lb(a);\n        }\n        int ub(D a) {\n            if (!sz) return 0;\n            if (v <= a) return l->sz + 1 + r->ub(a);\n            return l->ub(a);\n        }\n        int get(int a, int b) {\n            if (!sz || b <= 0 || sz <= a) return INF;\n            if (a <= 0 && sz <= b) return mn;\n            int res = INF;\n            res = min(res, l->get(a, b));\n            if (a <= l->sz && l->sz < b) res = min(res, v.second);\n            res = min(res, r->get(a - l->sz - 1, b - l->sz - 1));\n            return res;\n        }\n    } *n;\n\n    static uint xor128(){\n        static uint x=123456789,y=362436069,z=521288629,w=88675123;\n        uint t;\n        t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n    }\n    static NP merge(NP l, NP r) {\n        if (!l->sz) return r;\n        if (!r->sz) return l; \n        l->push(); r->push();\n        if (xor128() % (l->sz + r->sz) < l->sz) {\n            l->r = merge(l->r, r);\n            return l->update();\n        } else {\n            r->l = merge(l, r->l);\n            return r->update();\n        }\n    }\n    static pair<NP, NP> split(NP x, int k) {\n        if (!x->sz) return {last, last};\n        x->push();\n        if (k <= x->l->sz) {\n            auto y = split(x->l, k);\n            x->l = y.second;\n            y.second = x->update();\n            return y;\n        } else {\n            auto y = split(x->r, k- x->l->sz -1);\n            x->r = y.first;\n            y.first = x->update();\n            return y;\n        }\n    }\n\n    Tree() : n(last) {}\n    Tree(NP n) : n(n) {}\n    int sz() {\n        return n->sz;\n    }\n    void merge(Tree r) {\n        n = merge(n, r.n);\n    }\n    Tree split(int k) {\n        auto u = split(n, k);\n        n = u.first;\n        return Tree(u.second);\n    }\n    void insert(D v) {\n        auto u = split(n, lb(v));\n        n = merge(merge(u.first, new Node(v)), u.second);\n    }\n    int get(int l, int r) {\n        return n->get(l, r);\n    }\n    int lb(D v) {\n        return n->lb(v);\n    }\n    int ub(D v) {\n        return n->ub(v);\n    }\n};\nTree::Node Tree::last_d = Tree::Node(NULL, NULL, 0);\nTree::NP Tree::last = &last_d;\n\nconst int MN = 303000;\nint n;\nint x[MN], y[MN], z[MN];\nP d[MN];\nT buff[MN];\nTree g[MN];\n\nint solve() {\n    for (int i = 0; i < n; i++) {\n        buff[i] = T(x[i], -y[i], z[i]);\n    }\n    sort(buff, buff+n);\n    for (int i = 0; i < n; i++) {\n        int a, b, c;\n        tie(a,b,c) = buff[i];\n        d[i] = P(-b, c);\n        //printf(\"%d %d\\n\", d[i].first, d[i].second);\n    }\n    for (int i = 0; i <= n; i++) {\n        g[i] = Tree();\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        tie(a, b) = d[i];\n        int l = 0, r = i+1;\n        while (r-l > 1) {\n            int md = (l+r)/2;\n            if (g[md].get(0, g[md].lb(P(a, 0))) < b) {\n                l = md;\n            } else {\n                r = md;\n            }\n        }\n        g[r].insert(d[i]);\n        res = max(res, r);\n    }\n    return res;\n}\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n    while (true) {\n        int m;\n        cin >> n >> m >> a >> b;\n        if (!n && !m) break;\n        for (int i = 0; i < n; i++) {\n            cin >> x[i] >> y[i] >> z[i];\n        }\n        for (int i = n; i < n+m; i++) {\n            x[i] = r(); y[i] = r(); z[i] = r();\n        }\n        n += m;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint a,b,c=~(1<<31),M=(1<<16)-1;\n\nint r(){\n    a=36969*(a&M)+(a>>16);\n    b=18000*(b&M)+(a>>16);\n    return (c&((a<<16)+b))%1000000;\n}\n\nset<pair<int,int>> st[303030];\nint main(){\n    int m,n;\n    while(cin>>m>>n>>a>>b,m+n!=0){\n        int l=m+n;\n        int x[l],y[l],z[l];\n        rep(i,m)cin>>x[i]>>y[i]>>z[i];\n        rep(i,n){\n            x[i+m]=r();\n            y[i+m]=r();\n            z[i+m]=r();\n        }\n        vector<int> ord(l);\n        rep(i,l)ord[i]=i;\n        sort(ord.begin(),ord.end(),[&](int s,int t){return x[s]==x[t] ? y[s]>y[t] : x[s]<x[t];});\n        rep(i,303030){\n            if(st[i].size()==2)continue;\n            st[i].clear();\n            st[i].insert({inf,-inf});\n            st[i].insert({-inf,inf});\n        }\n        int ans=0;\n        for(auto i:ord){\n            int left=0,right=ans+1;\n            while(right-left>1){\n                int mid=(left+right)/2;\n                auto itr=--st[mid].lower_bound({y[i],0});\n                if(itr->second<z[i])left=mid;\n                else right=mid;\n            }\n            int ret=left+1;\n            ans=max(ret,ans);\n            auto itr=--st[ret].upper_bound({y[i],0});\n            if(z[i]>=itr->second)continue;\n            itr++;\n            while(itr->second>=z[i])itr=st[ret].erase(itr);\n            st[ret].insert({y[i],z[i]});\n        }\n        cout<<ans<<endl;\n    } \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!(M + N)) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n  \nstruct Node {\n  int Value;\n  int Data;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int RMQ;\n  \n  Node(int V, int T):Value(V), Data(T), SubTreeSize(1), RMQ(T) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\n\ninline int Sum(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> RMQ);\n}\ninline Node *Update(Node *t)\n{\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  t -> RMQ = max(Sum(t -> Lch), max(Sum(t -> Rch), t -> Data));\n  return(t);\n}\n  \ninline Node *MakeRoot(int value, int T)\n{\n  return(new Node(value, T));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value, int T)\n{\n  Node *p = MakeRoot(value, T);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  if(root == (Node *)NULL) return(0);\n  if(Value < root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n  \nNode *Insert(Node *root, int Value, int T)\n{\n  return(Insert(root, Lower_Bound(root, Value), Value, T));\n}\n\nstruct MatrixSegmentTree\n{\n  vector< Node* > node;\n  int sz;\n  \n  MatrixSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    node.resize(2 * sz - 1);\n    for(int i = 0; i < 2 * sz - 1; i++) {\n      node[i] = (Node *)NULL;\n    }\n  }\n  \n  int MatrixMax(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return(0);\n    } else if(a <= l && r <= b) {\n      auto p = Split(node[k], Lower_Bound(node[k], x - 1));\n      int maximum = Sum(p.first);\n      node[k] = Merge(p.first, p.second);\n      return(maximum);\n    } else {\n      int LL = MatrixMax(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      int RR = MatrixMax(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      return(max(LL, RR));\n    }\n  }\n  \n  int MatrixMax(int a, int b)\n  {\n    return(MatrixMax(0, a, b, 0, 0, sz));\n  }\n  \n  void PointUpdate(int k, int b, int val)\n  {\n    k += sz - 1;\n    node[k] = Insert(node[k], b, val);\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      node[k] = Insert(node[k], b, val);\n    }\n  }\n};\n\ninline int r(int& a, int& b)\n{\n  int C = ~(1<<31), M = (1<<16)-1;\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main()\n{\n  \n  int n, m, a, b;\n  while(scanf(\"%d %d %d %d\", &m, &n, &a, &b), m+n) {\n    \n    vector< tuple< int, int, int > > g;\n    for(int i = 0; i < m; i++) {\n      int x, y, z;\n      scanf(\"%d %d %d\", &x, &y, &z);\n      g.emplace_back(x, -y, -z);\n    }\n    for(int i = m; i < m + n; i++) {\n      g.emplace_back(r(a, b), -r(a, b), -r(a, b));\n    }\n    n += m;\n    sort(g.begin(), g.end());\n    \n    // O(n log^2 n)\n    MatrixSegmentTree tree(1000000);\n    int ret = 0;\n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      yy *= -1; zz *= -1;\n      int get = tree.MatrixMax(yy, zz) + 1;\n      ret = max(ret, get);\n      tree.PointUpdate(yy, zz, get);\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 28;\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, -INF});\n    for (; lower != st.end() and lower->second >= v.second; lower++) {\n        st.erase(lower);\n    }\n    st.insert(v);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N, A, B;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto gen = [&]() {\n            static int a = A;\n            static int b = B;\n            constexpr int C = ~(1 << 31);\n            constexpr int M = (1 << 16) - 1;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            return (C & ((a << 16) + b)) % 1000000;\n        };\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.5;\n        // int sqn = 1;\n        // int sqn = 10000;\n        sqn = max(sqn, 1);\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            while (offset + M < n && ps[offset + M - 1][0] == ps[offset + M][0]) { M++; }\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            vector<pair<int, int> > should_removed;\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\nnext:;\n            }\n            if (should_removed.size() > 1) {\n                vector<pair<pair<int, int>, int> > ncalced;\n                auto it = should_removed.begin();\n                REP(i, calced.size()) {\n                    if (it != should_removed.end() && calced[i].first == *it) {\n                        it++;\n                        continue;\n                    }\n                    ncalced.push_back(calced[i]);\n                }\n                swap(calced, ncalced);\n            }\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][0] == ps[pos][0]) { break; }\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += M;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto print=[&](const set<P> &sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](const set<P> &sp){\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      veri(dp[k]);\n      auto it=dp[k].lower_bound(p);\n      if(it!=dp[k].begin()) --it;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      veri(dp[k]);\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n      \n      veri(dp[k]);\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      //veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[500000];\nmap<pair<int, int>, int> anss;\nmap<pair<int, int>, int > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        anss.clear();\n        calced.clear();\n        calced[make_pair(1e+9, 1e+9)] = -1;\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n);\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<int, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(ps[pos][1], ps[pos][2]));\n                anss[make_pair(ps[pos][1], ps[pos][2])] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                while (nsit != ns.end() && nsit->first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[make_pair(nsit->first, nsit->second)] = v;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                ts[-it->first.second] = it->second;\n            }\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int npos = offset + j;\n                    if (ps[npos][1] < ps[pos][1] && ps[npos][2] < ps[pos][2]) {\n                        anss[make_pair(ps[pos][1], ps[pos][2])] = max(\n                                anss[make_pair(ps[pos][1], ps[pos][2])],\n                                anss[make_pair(ps[npos][1], ps[npos][2])] + 1\n                                );\n                    }\n                }\n                calced[make_pair(ps[pos][1], ps[pos][2])] = max(\n                        calced[make_pair(ps[pos][1], ps[pos][2])],\n                        anss[make_pair(ps[pos][1], ps[pos][2])]\n                        );\n            }\n\n            // remove obstacle values\n            nsit = ns.begin();\n            map<pair<int, int>, int> ncalced;\n            map<int, int> obstacle;\n            FORIT(it, calced) {\n                while (nsit != ns.end() && nsit->first <= it->first.first) {\n                    int v = anss[*nsit];\n                    if (!obstacle.count(v)) { obstacle[v] = nsit->second; }\n                    else { obstacle[v] = min(obstacle[v], nsit->second); }\n                    nsit++;\n                }\n                if (obstacle.count(it->second) && obstacle[it->second] < it->first.second) {\n                    continue;\n                }\n                ncalced[it->first] = it->second;\n            }\n            offset += sqn;\n            calced = ncalced;\n        }\n        int ans = 0;\n        FORIT(it, anss) { ans = max(ans, it->second); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define srep(i, s, t) for (int i = (int)(s); i < (int)(t); ++i)\n#define each(a, b) for (auto&(a) : (b))\n#define all(v) (v).begin(), (v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)), v.erase(unique(all(v)), v.end())\n#define cmx(x, y) x = max(x, y)\n#define cmn(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define spair(p) cout << #p << \": \" << p.fi << \" \" << p.se << endl\n#define sar(a, n)                          \\\n    cout << #a << \":\";                     \\\n    rep(kbrni, n) cout << \" \" << a[kbrni]; \\\n    cout << endl\n#define svec(v)                                   \\\n    cout << #v << \":\";                            \\\n    rep(kbrni, v.size()) cout << \" \" << v[kbrni]; \\\n    cout << endl\n#define svecp(v)                                                              \\\n    cout << #v << \":\";                                                        \\\n    each(kbrni, v) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n#define sset(s)                          \\\n    cout << #s << \":\";                   \\\n    each(kbrni, s) cout << \" \" << kbrni; \\\n    cout << endl\n#define smap(m)                                                               \\\n    cout << #m << \":\";                                                        \\\n    each(kbrni, m) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint A, B, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri, P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi - 1, nw.se));\n    if (it != st[cri].begin()) {\n        --it;\n        return it->se < nw.se;\n    } else {\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int n, m;\n        cin >> m >> n >> A >> B;\n        rep(i, n + m + 1)\n        {\n            st[i].clear();\n        }\n        rep(i, 1000000)\n        {\n            v[i].clear();\n        }\n        if (n == 0 && m == 0 && A == 0 && B == 0) {\n            break;\n        }\n        rep(i, m)\n        {\n            int s, t, u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t, u));\n        }\n        rep(i, n)\n        {\n            v[r()].pb(P(r(), r()));\n        }\n        int mx = -1;\n        rep(i, 1000000)\n        {\n            if (len(v[i])) {\n                sort(all(v[i]), [&](const P& p, const P& q) {\n                    return (p.fi == q.fi) ? (p.se > q.se) : (p.fi > q.fi);\n                });\n                each(it, v[i])\n                {\n                    int l = -1, r = mx + 1;\n                    while (r - l > 1) {\n                        int mid = (l + r) / 2;\n                        if (contain(mid, it)) {\n                            l = mid;\n                        } else {\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if (it2 != st[r].begin()) {\n                        --it2;\n                        if (it2->se <= it.se) {\n                            continue;\n                        }\n                        // if (it2->se == it.se or it2->fi == it.fi) {\n                        //     continue;\n                        // }\n                        ++it2;\n                    }\n                    while (1) {\n                        if (it2 != st[r].end()) {\n                            if (it2->se >= it.se) {\n                                it2 = st[r].erase(it2);\n                            } else {\n                                cmx(mx, r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        } else {\n                            cmx(mx, r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx + 1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint M,N,A,B,C,a,b,mod;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector< set<P> > ss;\nset<P>::iterator it;\nvector<PP> vc;\nint ran(){\n\ta=36969*(a&mod)+(a>>16);\n\tb=18000*(b&mod)+(b>>16);\n\treturn (C&((a<<16)+b))%1000000;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N>>A>>B;\n\t\tif(M+N==0) break;\n\t\tss.clear();\n\t\tvc.clear();\n\t\ta=A,b=B,C=~(1<<31),mod=(1<<16)-1;\n\t\trep(i,M){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tvc.pb(PP(x,P(-y,-z)));\n\t\t}\n\t\trep(i,N){\n\t\t\tint x=ran(),y=ran(),z=ran();\n\t\t\tvc.pb(PP(x,P(-y,-z)));\n\t\t}\n\t\tsort(all(vc));\n\t\tN=M+N;\n\t\trep(i,N) vc[i].sc.fs*=-1,vc[i].sc.sc*=-1;\n\t\tset<P> be;\n\t\tbe.insert(P(-2,-2));\n\t\tss.pb(be);\n\t\tint mx=0;\n\t\trep(i,N){\n\t\t\tint y=vc[i].sc.fs,z=vc[i].sc.sc;\n\t\t\tint ub=mx+1,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tit=ss[m].upper_bound(P(y-1,z-1));\n\t\t\t\tif(it==ss[m].begin()){\n\t\t\t\t\tub=m;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit--;\n//\t\t\t\tprintf(\"m=%d, koko;%d,%d\\n\",m,it->fs,it->sc);\n\t\t\t\tif(it->sc<z) lb=m;\n\t\t\t\telse ub=m;\n\t\t\t}\n\t\t\tif(lb==-1) continue;\n\t\t\tint m=lb+1;\n//\t\t\tprintf(\"m=%d\\n\",m);\n\t\t\tif(m>mx){\n\t\t\t\tset<P> be;\n\t\t\t\tbe.insert(P(y,z));\n\t\t\t\tss.pb(be);\n\t\t\t\tmx++;\n\t\t\t}else{\n\t\t\t\tit=ss[m].lower_bound(P(y,z));\n\t\t\t\twhile(it!=ss[m].end()){\n\t\t\t\t\tif(it->sc<z) break;\n//\t\t\t\t\tprintf(\"erase=(%d,%d)\\n\",it->fs,it->sc);\n\t\t\t\t\tit=ss[m].erase(it);\n\t\t\t\t}\n\t\t\t\tbool ok=true;\n\t\t\t\tit=ss[m].upper_bound(P(y,-1919));\n\t\t\t\tif(it!=ss[m].end()&&it->fs==y&&it->sc<z) ok=false;\n\t\t\t\tif(it!=ss[m].begin()){\n\t\t\t\t\tit--;\n\t\t\t\t\tif(it->sc==z) ok=false;\n\t\t\t\t}\n\t\t\t\tif(ok) ss[m].insert(P(y,z));\n\t\t\t}\n/*\t\t\tprintf(\"i=%d,  y,z=(%d,%d)     mx=%d\\n\",i,y,z,mx);\n\t\t\tcout<<\"ss[1]\";\n\t\t\tfor(auto s:ss[1]) cout<<\"(\"<<s.fs<<\",\"<<s.sc<<\") \";\n\t\t\tputs(\"\");\n\t\t\tif(ss.size()>2){\n\t\t\t\tcout<<\"ss[2]\";\n\t\t\t\tfor(auto s:ss[2]) cout<<\"(\"<<s.fs<<\",\"<<s.sc<<\") \";\n\t\t\t\tputs(\"\");\n\t\t\t}*/\n\t\t}\n\t\tcout<<mx<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN], N, BEST;\n\nbool cmp_x(const int &a, const int &b) { return x[a] < x[b]; }\n\nmap<int, int> best[MAXN];\n\nint query(int cury, int curz) {\n    int s = 0, e = N, mid;\n    while (e-s > 1) {\n        mid = (s+e)/2;\n        map<int, int>::iterator it = best[mid].lower_bound(cury);\n        if (it != best[mid].begin() && (--it)->second < curz) s = mid;\n        else e = mid;\n    }\n    return s+1;\n}\n\nvoid update(int cury, int curz, int v) {\n    map<int, int>::iterator it1, it2;\n\n    BEST = max(BEST, v);\n\n    it1 = it2 = best[v].lower_bound(cury);\n    while (it2 != best[v].end() && it2->second >= curz) it2++;\n    best[v].erase(it1, it2);\n\n    it1 = best[v].upper_bound(cury);\n    if (it1 == best[v].begin() || (--it1)->second > curz) best[v][cury] = curz;\n}\n\nint main() {\n    int m, n, i, j;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        for (i=0; i<N; i++) ox[i] = i;\n        sort(ox, ox+N, cmp_x);\n\n        for (i=1; i<=N; i++) best[i].clear();\n\n        i = BEST = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[j] = query(y[ox[j]], z[ox[j]]);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[i]);\n        } while (i < N);\n        printf(\"%d\\n\", BEST);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN];\n\nbool cmp_x(const int &a, const int &b) {\n    if (x[a] != x[b]) return x[a] < x[b];\n    else if (y[a] != y[b]) return y[a] < y[b];\n    else return z[a] < z[b];\n}\n\nmap<int, int> bit[MAXC];\n\nint answer(int idx, int th) {\n    map<int, int>::iterator it = bit[idx].lower_bound(th);\n    if (it != bit[idx].begin()) return (--it)->second;\n    else return NO_VALUE;\n}\n\nint query(int idx, int th) {\n    int res = NO_VALUE;\n    while (idx > 0) {\n        res = max(res, answer(idx, th));\n        idx &= idx-1;\n    }\n    return res;\n}\n\nvoid update(int idx, int th, int v) {\n    map<int,int>::iterator it1, it2;\n    while (idx < MAXC) {\n        it1 = it2 = bit[idx].upper_bound(th);\n        while (it2 != bit[idx].end() && it2->second <= v) it2++;\n        bit[idx].erase(it1, it2);\n    \n        it1 = bit[idx].upper_bound(th);\n        if (it1 == bit[idx].begin() || (--it1)->second < v) bit[idx][th] = v;\n        idx += idx&(-idx);\n    }\n}\n\nint main() {\n    int m, n, i, j, N;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        for (i=0; i<N; i++) { ox[i] = i; y[i] += 1; }\n        sort(ox, ox+N, cmp_x);\n\n        for (i=0; i<MAXC; i++) bit[i].clear();\n\n        i = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[ox[j]] = max(1, query(y[ox[j]]-1, z[ox[j]])+1);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[ox[i]]);\n        } while (i < N);\n        printf(\"%d\\n\", query(MAXC-1, MAXC));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto print=[&](const set<P> &sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](const set<P> &sp){\n      return;\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      veri(dp[k]);\n      auto it=dp[k].lower_bound(P(p.first,-1));\n      if(it!=dp[k].begin()) --it;\n      //if(it!=dp[k].begin()&&it->first>=p.first) --it;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      veri(dp[k]);\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n      \n      veri(dp[k]);\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      //veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(Int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void out(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void out(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);out<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';out<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T *a,int n){REP(i,n){if(i)cout<<',';cout<<a[i];}cout<<endl;}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>void output(T t){if(t<0)t=-t,putchar(45);static int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;putchar(c[--k]^48));}\ntemplate<class S,class ...T>void output(S a,T...t){output(a);putchar(' ');output(t...);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());t=10*t+c-48);t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nstruct P {\n  int x, y, v;\n  bool operator<(const P &rhs) const {\n    return x!=rhs.x ? x<rhs.x : y<rhs.y;\n  }\n};\n\nstruct RangeTree {\n  struct SegTree {\n    vector<int> pos;\n    vector<int> dat;\n    int n;\n    SegTree() : n(0) {}\n    SegTree(int y, int v) : pos(1,y), dat(1,v), n(1) { }\n    SegTree(const SegTree &a, const SegTree &b) {\n      int n1 = a.pos.size(), n2 = b.pos.size();\n      for (n=1;n<n1+n2; n*=2);\n      pos.resize(n1+n2);\n      dat.assign(2*n-1,0);\n      int c1=0,c2=0;\n      for (int i=0;i<n1+n2;++i) {\n        if (c1<n1&&c2<n2&&a.pos[c1]<b.pos[c2] || c2==n2) {\n          dat[i+n-1] = a.dat[c1+a.n-1];\n          pos[i] = a.pos[c1++];          \n        } else {\n          dat[i+n-1] = b.dat[c2+b.n-1];\n          pos[i] = b.pos[c2++];\n        }\n      }\n      for (int i=n-2; i>=0; --i)\n        dat[i] = max(dat[i*2+1], dat[i*2+2]);\n    }\n    void change(int y, int a) {\n      int k = lower_bound(ALL(pos),y)-pos.begin();\n      k += n - 1;\n      dat[k] = a;\n      while(k>0) {\n        k = k-1>>1;\n        dat[k] = max(dat[k*2+1], dat[k*2+2]);\n      }\n    }\n    int query() {\n      return query(0,pos.size(),0,0,n);\n    }\n    int query(int yl, int yr) {\n      int a = lower_bound(ALL(pos), yl) - pos.begin();\n      int b = upper_bound(ALL(pos), yr) - pos.begin();\n      return query(a,b,0,0,n);\n    }\n    int query(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return 0;\n      if (a <= l && r <= b) return dat[k];\n      return max(query(a, b, k*2+1, l, (l+r)/2),\n                 query(a, b, k*2+2, (l+r)/2, r));      \n    }\n  };\n  vector<SegTree> segs;\n  int n;\n  vector<pii> pos;\n  RangeTree(vector<P> v) {\n    sort(ALL(v));\n    pos.resize(v.size());\n    REP(i,v.size()) pos[i] = pii(v[i].x,v[i].y); \n    for (n=1; n<v.size(); n*=2);\n    segs.assign(2*n-1,SegTree());\n    REP(i,v.size()) segs[i+n-1] = SegTree(v[i].y,v[i].v);\n    for (int i=n-2; i>=0; --i)\n      segs[i] = SegTree(segs[i*2+1], segs[i*2+2]);\n  }\n  void change(int x, int y, int a) {\n    int k = lower_bound(ALL(pos),pii(x,y)) - pos.begin();\n    k += n - 1;\n    segs[k].change(y,a);\n    while(k>0) {\n      k = k-1>>1;\n      segs[k].change(y, max(segs[k*2+1].query(), segs[k*2+2].query()));\n    }\n  }\n  int query(int xl, int yl, int xr, int yr) {\n    int a = lower_bound(ALL(pos), pii(xl,-INF)) - pos.begin();\n    int b = upper_bound(ALL(pos), pii(xr,INF)) - pos.begin();\n    return query(a,b,0,0,n,yl,yr);\n  }\n  int query(int a, int b, int k, int l, int r, int yl, int yr) {\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return segs[k].query(yl,yr);\n    return max(query(a, b, k*2+1, l, (l+r)/2, yl, yr),\n               query(a, b, k*2+2, (l+r)/2, r, yl, yr));\n  }\n};\n\nnamespace RND {\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n}\nstruct Pt {\n  int x,y,z;\n  void in() {\n    scanf(\"%d%d%d\",&x,&y,&z);\n  }\n  bool operator<(const Pt &rhs) const {\n    return z < rhs.z;\n  }\n} pt[1000000];\n\nint main() {\n  int m,n,A,B;\n  while(input(m,n,A,B),n||m) {\n    RND::a = A;\n    RND::b = B;\n    REP(i,m) {\n      pt[i].in();\n    }\n    REP(i,n) {\n      int x=RND::r();\n      int y=RND::r();\n      int z=RND::r();\n      pt[m+i] = Pt{x,y,z};\n    }\n    sort(pt,pt+m+n);\n    vector<P> v(m+n);\n    REP(i,m+n) v[i] = P{pt[i].x,pt[i].y,0};\n    RangeTree rt(v);\n    int ans = 0;\n    REP(i,m+n) {\n      int t = rt.query(0,0,pt[i].x,pt[i].y) + 1;\n      chmax(ans, t);\n      rt.change(pt[i].x,pt[i].y,t);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i] = {x, -y, -z};\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tx = rnd(a, b);\n\t\t\ty = rnd(a, b);\n\t\t\tz = rnd(a, b);\n\t\t\tv[i] = {x, -y, -z};\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mp = mps[mid - 1];\n\t\t\t\tauto it = mp.upper_bound(y);\n\t\t\t\tif(it != mp.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmps[left][y] = z;\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nbool check(int y, int z, const map<int, int> &contour) {\n  const auto it = contour.upper_bound(y);\n  return it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  int prev_x = x(points.front());\n  vector<tuple<int, int, int>> buf;\n  vector<map<int, int>> maps{{{1, -1}}};\n  maps.reserve(points.size());\n\n  for(const auto &p : points) {\n    const int x = x(p);\n    const int y = -y(p);\n    const int z = z(p);\n\n    if(prev_x != x) {\n      maps.resize(max_count + 1);\n      prev_x = x;\n      for(const auto &e : buf) {\n\tint k, ty, tz;\n\ttie(k, ty, tz) = e;\n\n\tauto &target = maps[k];\n\n\tif(!target.count(ty) || tz < target[ty]) {\n\t  target[ty] = tz;\n\n\t  auto it = target.find(ty);\n\n\t  while(it != target.begin()) {\n\t    --it;\n\t    if(tz > it->second) break;\n\t    it = target.erase(it);\n\t  }\n\t}\n      }\n      buf.clear();\n    }\n\n    int low = 0;\n    int high = maps.size();\n\n    while(low + 1 < high) {\n      const int mid = (low + high) / 2;\n      if(check(y, z, maps[mid])) {\n\tlow = mid;\n      }\n      else {\n\thigh = mid;\n      }\n    }\n\n    if(low == max_count) ++max_count;\n    buf.emplace_back(high, y, z);\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int> mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int>::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it!=mp.end()&&it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\n\t\t\ts=it;\n\t\t\t++s;\n\t\t}else if(it!=mp.begin()){\n\t\t\ts=it;\n\t\t\tif((--it)->second>=v)return;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}else{\n\t\t\ts=it;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}\n\t\te=s;\n\t\twhile(e!=mp.end()&&e->second<=v)++e;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int>::const_iterator it;\n\t\tit=mp.lower_bound(xe);\n\t\tif(it==mp.begin())return nil;\n\t\treturn (--it)->second;\n\t}\n};\n\n\n\n\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<SparseRMQ> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1){}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tbit[x].insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ye)const{//[0,xe)*[0,ye)\n\t\tint res=nil;\n\t\twhile(0<xe){\n\t\t\tres=func(res,bit[xe].max(ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(2000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\ntypedef tuple<int, int, int> tiii;\n\nstruct Random {\n\tint a, b, C, M;\n\tRandom(int A, int B) : a(A), b(B), C(~(1 << 31)), M((1 << 16) - 1) { }\n\tint operator()(){\n\t\ta = 36969 * (a & M) + (a >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint m, n, A, B;\n\t\tcin >> m >> n >> A >> B;\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0){ break; }\n\t\tn += m;\n\t\tvector<tiii> p(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tRandom random(A, B);\n\t\tfor(int i = m; i < n; ++i){\n\t\t\tconst int x = random();\n\t\t\tconst int y = random();\n\t\t\tconst int z = random();\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tvector< map<int, int> > vm(n + 1);\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < n; ){\n\t\t\tconst int x = get<0>(p[i]);\n\t\t\tvector<tiii> t;\n\t\t\twhile(i < n && get<0>(p[i]) == x){\n\t\t\t\tconst int y = get<1>(p[i]);\n\t\t\t\tconst int z = get<2>(p[i]);\n\t\t\t\tint l = 0, r = n + 1;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tconst int c = l + (r - l) / 2;\n\t\t\t\t\tauto it = vm[c].lower_bound(y);\n\t\t\t\t\tif(it == vm[c].begin()){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else if((--it)->second >= z){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = c + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.emplace_back(l, y, z);\n\t\t\t\tanswer = max(answer, l + 1);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tfor(const auto &e : t){\n\t\t\t\tconst int k = get<0>(e);\n\t\t\t\tconst int y = get<1>(e);\n\t\t\t\tconst int z = get<2>(e);\n\t\t\t\tauto it = vm[k].lower_bound(y);\n\t\t\t\tif(it->first == y && it->second < z){ continue; }\n\t\t\t\twhile(it != vm[k].end()){\n\t\t\t\t\tif(it->second < z){ break; }\n\t\t\t\t\tvm[k].erase(it++);\n\t\t\t\t}\n\t\t\t\tvm[k].insert(make_pair(y, z));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode() {}\n};\n\nconst int MAX = 1 << 19;\n\nint it;\nconst int pmax = 1e7;\n\nnode pool[pmax];\n\nnode *segs[MAX * 2];\n\nnode *new_node(int val) {\n\tassert(it < pmax);\n\tpool[it].val = val;\n\tpool[it].l = pool[it].r = nullptr;\n\treturn pool + it++;\n}\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new_node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint a,b,C,M;\n\nint r(){\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri,P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi-1,nw.se));\n    if(it != st[cri].begin()){\n        --it;\n        return (*it).se < nw.se;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,A,B;\n        cin >> m >> n >> A >> B;\n        rep(i,n+m+1){\n            st[i].clear();\n        }\n        rep(i,1000000){\n            v[i].clear();\n        }\n        if(n == 0 && m == 0 && A == 0 && B == 0){\n            break;\n        }\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n        rep(i,m){\n            int s,t,u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t,u));\n        }\n        rep(i,n){\n            v[r()].pb(P(r(),r()));\n        }\n        int mx = 0;\n        rep(i,1000000){\n            if(len(v[i])){\n                sort(all(v[i]),[&](const P& p,const P& q){\n                    return (p.fi==q.fi)?(p.se>q.se):(p.fi>q.fi);\n                });\n                each(it,v[i]){\n                    int l = -1,r = mx+1;\n                    while(r-l>1){\n                        int mid = (l+r)/2;\n                        if(contain(mid,it)){\n                            l = mid;\n                        }else{\n                            r = mid;\n                        }\n                    }\n                    while(1){\n                        auto it2 = st[r].lower_bound(it);\n                        if(it2 != st[r].end()){\n                            if((*it2).se >= it.se){\n                                // cout << \"erase \" << r << \" \";\n                                // spair((*it2));\n                                st[r].erase(it2);\n                            }else{\n                                // cout << \"insert \" << r << \" \";\n                                // spair(it);\n                                cmx(mx,r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        }else{\n                            // cout << \"insert \" << r << \" \";\n                            // spair(it);\n                            cmx(mx,r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        rrep(i,n+m+1){\n            if(len(st[i])){\n                cout << i+1 << \"\\n\";\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <tuple>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\ntuple<int, int, int> data[300000];\nint n, m;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nconst int base = (1 << 20);\n\nint dp[300000];\nset<pair<int, int>> ansList[300001];\n\nbool isPossible(int ind, int v) {\n\tif(ansList[v].size() == 0) return false;\n\n\tint x, y, z;\n\ttie(x, y, z) = data[ind];\n\n\tauto it = lower_bound(ansList[v].begin(), ansList[v].end(), make_pair(y, -1));\n\tif(it != ansList[v].begin()) {\n\t\tit--;\n\t\treturn (*it).second < z;\n\t}\n\n\treturn false;\n}\n\nint main(void) {\n\twhile(scanf(\"%d %d %d %d\", &m, &n, &a, &b), (n + m) > 0) {\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\t\tdata[i] = make_tuple(x, y, z);\n\t\t}\n\n\t\tfor(int i = m; i < n + m; i++) {\n\t\t\tint x = r(), y = r(), z = r();\n\t\t\tdata[i] = make_tuple(x, y, z);\n\t\t}\n\n\t\tn += m;\n\t\tsort(data, data + n);\n\n\t\tint ans = 0;\n\n\t\tfor(int i = 0; i <= n; i++) ansList[i].clear();\n\n\t\tfor(int i = 0; i < n; ) {\n\t\t\tint s = i, e = i;\n\t\t\twhile(e < n and get<0>(data[e]) == get<0>(data[s])) e++;\n\t\t\ti = e;\n\n\t\t\tfor(int j = s; j < e; j++) {\n\t\t\t\tdp[j] = 1;\n\n\t\t\t\tint start = 1, end = n;\n\t\t\t\twhile(start < end) {\n\t\t\t\t\tint mid = (start + end) / 2;\n\t\t\t\t\tif(isPossible(j, mid)) dp[j] = start = mid + 1;\n\t\t\t\t\telse end = mid;\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, dp[j]);\n\t\t\t}\n\n\t\t\tfor(int j = s; j < e; j++) {\n\t\t\t\tint x, y, z;\n\t\t\t\ttie(x, y, z) = data[j];\n\t\t\t\tauto nv = make_pair(y, z);\n\n\t\t\t\tif(ansList[dp[j]].size() > 0) {\n\t\t\t\t\tauto it = lower_bound(ansList[dp[j]].begin(), ansList[dp[j]].end(), make_pair(y + 1, -1));\n\t\t\t\t\tif(it != ansList[dp[j]].begin()) {\n\t\t\t\t\t\tit--;\n\t\t\t\t\t\tif(it->second <= z) continue;\n\t\t\t\t\t\tif(it->first < y) it++;\n\t\t\t\t\t}\n\t\t\t\t\twhile(it != ansList[dp[j]].end() and (*it).second >= z) ansList[dp[j]].erase(it++);\n\t\t\t\t}\n\t\t\t\tansList[dp[j]].insert(nv);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[1209], qy[1209], t[1209][1209], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n) * 0.72 + 1;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) { delete lch; delete rch; }\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) { delete lch; delete rch; }\n\t\tdelete st;\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MN 300005\nint A, B, C, M;\nint rand() {\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nstruct data { int x, y, z, k; } d[MN];\nint dyn[MN], Y;\ninline bool cmp(data a, data b) {\n\tif (a.x != b.x) return a.x < b.x;\n\tif (a.y != b.y) return a.y < b.y;\n\treturn a.z < b.z;\n}\nint ym[4*MN], yd[4*MN];\nmap <int, int> r[MN];\nmap<int,int>::iterator it, it2;\nvoid upd(int x, int y, int v) {\n\twhile (x < Y) {\n\t\tit = it2 = r[x].upper_bound(y);\n\t\twhile (it2 != r[x].end() && it2->second <= v) it2++;\n\t\tr[x].erase(it, it2);\n\t\tit = r[x].upper_bound(y);\n\t\tif (it == r[x].begin() || (--it)->second < v) r[x][y] = v;\n\t\tx += x&(-x);\n\t}\n}\nint ret, val;\nint f(int x, int y) {\n\tret = -1;\n\twhile (x > 0) {\n\t\tit = r[x].lower_bound(y);\n\t\tif (it != r[x].begin()) val = (--it)->second;\n\t\telse val = -1;\n\t\tif (ret < val) ret = val;\n\t\tx &= x-1;\n\t}\n\treturn ret;\n}\nint main() {\n\tint i, j;\n\tint m, n, N;\n\twhile (scanf(\"%d%d%d%d\",&m,&n,&A,&B),m||n||A||B) {\n\t\tN = m+n; Y = 0;\n\t\tC = ~(1<<31); M = (1<<16)-1;\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d%d\",&d[i].x,&d[i].y,&d[i].z);\n\t\tfor (i = m; i < m+n; i++) d[i].x = rand(), d[i].y = rand(), d[i].z = rand();\n\t\tym[0] = -1;\n\t\tfor (i = 0; i < N; i++) d[i].k = i, ym[++Y] = d[i].y;\n\t\tsort(d, d+N, cmp);\n\t\tsort(ym+1, ym+Y+1);\n\t\tY = 0;\n\t\tfor (i = 1; i <= N; i++) if (ym[i] != ym[i-1]) yd[ym[i]] = ++Y;\n\t\tfor (i = 0; i < N; i++) d[i].y = yd[d[i].y];\n\t\tY++;\n\t\tfor (i = 0; i < Y; i++) r[i].clear();\n\t\ti = 0;\n\t\tdo {\n\t\t\tfor (j = i; j < N && d[i].x == d[j].x; j++) dyn[d[j].k] = max(1, f(d[j].y-1, d[j].z)+1);\n\t\t\tfor (; i < j; i++) upd(d[i].y, d[i].z, dyn[d[i].k]);\n\t\t} while (i < N);\n\t\tprintf(\"%d\\n\",f(Y-1, 3*MN));\n\t\tm = n = A = B = 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode(int val_) : val(val_), l(nullptr), r(nullptr) {}\n};\n\nconst int MAX = 1 << 19;\n\nnode *segs[MAX * 2];\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) {\n\t\tdelete segs[p];\n\t\tsegs[p] = nullptr;\n\t}\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.8e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nll a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(10000), x[i] = dc(10000), w[i] = dc(10000);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * また、点数に比べて座標が大きいので、座標圧縮するとオーダーが減らせる。\n * こうするとN+M個の点それぞれについて、高々(log(N+M))^2個のノードが作られるので、メモリ使用量はO((N+M) (log N+M)^2)となる。\n *\n * オーダーは O((N+M) (log (N+M))^2)。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(3000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    map<int,int> dict;\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n        dict[x] = 0;\n        dict[y] = 0;\n        dict[z] = 0;\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n        dict[x] = 0;\n        dict[y] = 0;\n        dict[z] = 0;\n    }\n    {\n        int cnt = 0;\n        for(auto &e : dict) {\n            e.second = cnt++;\n        }\n        for(auto &p : ps) {\n            int x, y, z;\n            tie(x, y, z) = p;\n            p = make_tuple(dict[x], dict[y], dict[z]);\n        }\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(300000);\n    map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 300000, 0, 300000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[500000];\nint anss[500010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        // calced[make_pair(1e+9, 1e+9)] = 0;\n        // calced[make_pair(-1e+9, -1e+9)] = 0;\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 3.5;\n        // int sqn = 10000;\n        if (sqn < 1) { sqn = 1; }\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                // calced[make_pair(ps[pos][1], ps[pos][2])] = anss[pos];\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n#include <utility>\n#include <climits>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i][0] = x;\n\t\t\tv[i][1] = -y;\n\t\t\tv[i][2] = -z;\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tv[i][0] = rnd(a, b);\n\t\t\tv[i][1] = -rnd(a, b);\n\t\t\tv[i][2] = -rnd(a, b);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(size_t i = 1; i < mps.size(); ++i){\n\t\t\tmps[i][INT_MIN] = INT_MAX;\n\t\t}\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mpm = mps[mid - 1];\n\t\t\t\tauto it = mpm.upper_bound(y);\n\t\t\t\tif(it != mpm.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tauto &mpl = mps[left];\n\t\t\tfor(auto it = mpl.upper_bound(y); ; ){\n\t\t\t\t--it;\n\t\t\t\tif(it->second > z){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit = mpl.erase(it);\n\t\t\t}\n\t\t\t\n\t\t\tint &t = mpl.insert(make_pair(y, z)).first->second;\n\t\t\tt = max(t, z);\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e8;\n\n\nstruct plane {\n\n\tset<pair<int, int> > xs, ys;\n\n\tvoid init()\n\t{\n\t\txs.insert({-inf, +inf});\n\t\tys.insert({+inf, -inf});\n\n\t\txs.insert({+inf, -inf});\n\t\tys.insert({-inf, +inf});\n\t}\n\n\tvoid print_all()\n\t{\n\t\tprintf(\"pt:\");\n\t\tfor(auto pt : xs)\n\t\t\tprintf(\" (%d, %d)\", pt.first, pt.second);\n\t\tprintf(\"\\n\");\n\t}\n\n\tvoid add_point(int x, int y)\n\t{\n\t\t// assert is_conflicted(x, y) == false;\n\n\t\tauto l_pt1 = xs.lower_bound({x, y});\n\t\tauto r_pt2 = ys.lower_bound({y, x});\n\t\tauto r_pt1 = xs.lower_bound({r_pt2->second, r_pt2->first});\n\t\tauto l_pt2 = ys.lower_bound({l_pt1->second, l_pt1->first});\n\t\tbool can_put = false;\n\t\tbool can_del = false;\n\n\t\tif(*l_pt1 <= *r_pt1) {\n\t\t\tcan_put = true;\n\t\t\tcan_del = true;\n\t\t} else {\n\t\t\tauto r_next_pt1 = r_pt1;\n\t\t\t++r_next_pt1;\n\t\t\tif(l_pt1 == r_next_pt1 && x < l_pt1->first && y < r_pt1->second)\n\t\t\t\tcan_put = true;\n\t\t}\n\n\t\tif(can_del) {\n\t\t\txs.erase(l_pt1, ++r_pt1);\n\t\t\tys.erase(r_pt2, ++l_pt2);\n\t\t}\n\n\t\tif(can_put) {\n\t\t\txs.insert({x, y});\n\t\t\tys.insert({y, x});\n\t\t}\n\t}\n\n\tbool is_conflicted(int x, int y)\n\t{\n\t\tauto r_next = xs.lower_bound({x, -inf});\n\t\tauto r = --r_next;\n\t\treturn r->second < y;\n\t}\n\n\tint size()\n\t{\n\t\t// assert xs.size() == ys.size();\n\t\treturn xs.size();\n\t}\n};\n\nstruct point3 {\n\tint x, y, z;\n\tbool operator<(const point3 &rhs) const\n\t{\n\t\tif(x != rhs.x)\n\t\t\treturn x < rhs.x;\n\t\tif(y != rhs.y)\n\t\t\treturn y > rhs.y;\n\t\treturn z > rhs.z;\n\t}\n};\n\nint generate_rand(int A, int B, bool init) {\n\tstatic int a, b;\n\tif(init) {\n\t\ta = A;\n\t\tb = B;\n\t}\n\tconst int C = ~(1<<31), M = (1<<16)-1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tint m, n, a, b;\n\t\tvector<point3> pts;\n\t\tvector<plane> box;\n\n\t\tscanf(\"%d%d%d%d\", &m, &n, &a, &b);\n\t\tif(n + m == 0)\n\t\t\tbreak;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tpts.push_back({x, y, z});\n\t\t}\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x = generate_rand(a, b, i == 0);\n\t\t\tint y = generate_rand(a, b, false);\n\t\t\tint z = generate_rand(a, b, false);\n\t\t\tpts.push_back({x, y, z});\n\t\t}\n\t\tsort(pts.begin(), pts.end());\n\n\t\tbox.push_back(plane());\n\t\tbox[0].init();\n\t\tbox[0].add_point(-1, -1);\n\n\t\tfor(auto pt : pts) {\n\n\t\t\t//printf(\"[%d %d %d]\\n\", pt.x, pt.y, pt.z);\n\n\t\t\tif(box[box.size() - 1].is_conflicted(pt.y, pt.z)) {\n\t\t\t\tbox.push_back(plane());\n\t\t\t\tbox[box.size() - 1].init();\n\t\t\t\tbox[box.size() - 1].add_point(pt.y, pt.z);\n\t\t\t\t//printf(\"added: %d(new)\\n\", box.size() - 1);\n\t\t\t\t//box[box.size() - 1].print_all();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint lb = 0, ub = box.size() - 1;\n\n\t\t\twhile(ub - lb > 1) {\n\n\t\t\t\tint mid = (lb + ub) / 2;\n\n\t\t\t\t//printf(\"check: %d\\n\", mid);\n\t\t\t\t//box[mid].print_all();\n\n\t\t\t\tif(box[mid].is_conflicted(pt.y, pt.z))\n\t\t\t\t\tlb = mid;\n\t\t\t\telse\n\t\t\t\t\tub = mid;\n\t\t\t}\n\n\t\t\tbox[ub].add_point(pt.y, pt.z);\n\t\t\t//printf(\"added: %d\\n\", ub);\n\t\t\t//box[ub].print_all();\n\t\t}\n\n\t\tint ans = box.size() - 1;\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; --i)\n#define srep(i, s, t) for (int i = (int)(s); i < (int)(t); ++i)\n#define each(a, b) for (auto&(a) : (b))\n#define all(v) (v).begin(), (v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)), v.erase(unique(all(v)), v.end())\n#define cmx(x, y) x = max(x, y)\n#define cmn(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define spair(p) cout << #p << \": \" << p.fi << \" \" << p.se << endl\n#define sar(a, n)                          \\\n    cout << #a << \":\";                     \\\n    rep(kbrni, n) cout << \" \" << a[kbrni]; \\\n    cout << endl\n#define svec(v)                                   \\\n    cout << #v << \":\";                            \\\n    rep(kbrni, v.size()) cout << \" \" << v[kbrni]; \\\n    cout << endl\n#define svecp(v)                                                              \\\n    cout << #v << \":\";                                                        \\\n    each(kbrni, v) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n#define sset(s)                          \\\n    cout << #s << \":\";                   \\\n    each(kbrni, s) cout << \" \" << kbrni; \\\n    cout << endl\n#define smap(m)                                                               \\\n    cout << #m << \":\";                                                        \\\n    each(kbrni, m) cout << \" {\" << kbrni.first << \":\" << kbrni.second << \"}\"; \\\n    cout << endl\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint A, B, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri, P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi - 1, nw.se));\n    if (it != st[cri].begin()) {\n        --it;\n        return it->se < nw.se;\n    } else {\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (1) {\n        int n, m;\n        cin >> m >> n >> A >> B;\n        rep(i, n + m + 1)\n        {\n            st[i].clear();\n        }\n        rep(i, 1000000)\n        {\n            v[i].clear();\n        }\n        if (n == 0 && m == 0 && A == 0 && B == 0) {\n            break;\n        }\n        rep(i, m)\n        {\n            int s, t, u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t, u));\n        }\n        rep(i, n)\n        {\n            v[r()].pb(P(r(), r()));\n        }\n        int mx = -1;\n        rep(i, 1000000)\n        {\n            if (len(v[i])) {\n                sort(all(v[i]), [&](const P& p, const P& q) {\n                    return (p.fi == q.fi) ? (p.se > q.se) : (p.fi > q.fi);\n                });\n                each(it, v[i])\n                {\n                    int l = -1, r = m + n + 1;\n                    while (r - l > 1) {\n                        int mid = (l + r) / 2;\n                        if (contain(mid, it)) {\n                            l = mid;\n                        } else {\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if (it2 != st[r].begin()) {\n                        --it2;\n                        if (it2->se == it.se or it2->fi == it.fi) {\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while (1) {\n                        if (it2 != st[r].end()) {\n                            if (it2->se >= it.se) {\n                                it2 = st[r].erase(it2);\n                            } else {\n                                cmx(mx, r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        } else {\n                            cmx(mx, r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx + 1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      \n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      init(mx+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(mx+1, mx+1, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxn], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m + A + B)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z, g[i] = 1;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r(), g[i] = 1;\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define fi first\n#define se second\n\nconst int INF = 1 << 28;\n\ntypedef pair<int, int> pr;\ntypedef tuple<int, int, int> tp;\n\nint a_, b_, C_ = ~(1<<31), M_ = (1<<16)-1;\nint r_() {\n  a_ = 36969 * (a_ & M_) + (a_ >> 16);\n  b_ = 18000 * (b_ & M_) + (b_ >> 16);\n  return (C_ & ((a_ << 16) + b_)) % 1000000;\n}\n\nvector<tp> ps;\n\nint solve()\n{\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\tsort(begin(ps), end(ps));\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\t\n\tvector<set<pr>> sts(ps.size() + 10);\n\tfor (auto &st : sts){\n\t\tst.emplace(-INF, INF);\n\t\tst.emplace(INF, -INF);\n\t}\n\tsts[0].emplace(0, 0);\n\t\n\tint res = 0;\n\trep(i, ps.size()){\n\t\tint x, y, z;\n\t\ttie(x, y, z) = ps[i];\n\t\tint l = 0, r = ps.size();\n\t\twhile (l + 1 < r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tauto it = --sts[m].upper_bound(pr(y, z));\n\t\t\tif (it->se <= z) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\twhile (true){\n\t\t\tauto it = sts[r].lower_bound(pr(y, z));\n\t\t\tif (it->se < z) break;\n\t\t\tsts[r].erase(it);\n\t\t}\n\t\tsts[r].emplace(y, z);\n\t\tres = max(res, r);\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n >> a_ >> b_, m + n){\n\t\tps.clear();\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\trep(i, n){\n\t\t\tint x = r_(), y = r_(), z = r_();\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n) * 1.2;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree(int n_ = MAX) : n(n_ << 1), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\nint MAX2;\n\nvector<dynamic_segment_tree<rmq>> segs;\n\nvoid update(int px, int py, int val) {\n\tpx += MAX2;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX2, r = MAX2 + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX2) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tsegs.reserve(MAX * 2);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tint yma = *max_element(y.begin(), y.end()) + 1;\n\t\tint zma = *max_element(z.begin(), z.end()) + 1;\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tMAX2 = 1;\n\t\tint sz = 1;\n\t\twhile (MAX2 < yma) MAX2 <<= 1;\n\t\twhile (sz < zma) sz <<= 1;\n\t\tsegs.clear();\n\t\tfor (int i = 0; i < MAX2 * 2; i++) {\n\t\t\tsegs.emplace_back(sz);\n\t\t}\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint M,N,A,B;\n\nint a,b,c=~(1<<31),m=(1<<16)-1;\nint r() {\n  a = 36969 * (a & m) + (a >> 16);\n  b = 18000 * (b & m) + (b >> 16);\n  return (c & ((a << 16) + b)) % 1000000;\n}\n\nmap<int,int>lis[333333];\n\nvoid solve(){\n    vector<tuple<int,int,int>>ps;\n    rep(i,M){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        ps.pb(make_tuple(x,y,z));\n    }\n    a=A;b=B;\n    rep(i,N){\n        int x,y,z;\n        x=r();y=r();z=r();\n        ps.pb(make_tuple(x,y,z));\n    }\n\n    N+=M;\n    rep(i,N)get<1>(ps[i])*=-1;\n    sort(all(ps));\n    rep(i,N)get<1>(ps[i])*=-1;\n\n    rep(i,N+1)lis[i].clear();\n\n    /*\n    vector<int>latte;\n    rep(i,N){\n        latte.pb(get<0>(ps[i]));\n        latte.pb(get<1>(ps[i]));\n        latte.pb(get<2>(ps[i]));\n    }\n    sort(all(latte));latte.erase(unique(all(latte)),latte.end());\n    rep(i,N){\n        get<0>(ps[i])=lower_bound(all(latte),get<0>(ps[i]))-latte.begin();\n        get<1>(ps[i])=lower_bound(all(latte),get<1>(ps[i]))-latte.begin();\n        get<2>(ps[i])=lower_bound(all(latte),get<2>(ps[i]))-latte.begin();\n    }\n    rep(i,N){\n        cout<<get<0>(ps[i])<<\" \"<<get<1>(ps[i])<<\" \"<<get<2>(ps[i])<<endl;\n    }*/\n\n    for(auto &w:ps){\n        int x=get<1>(w),y=get<2>(w);\n        //cout<<\" in \"<<x<<\" \"<<y<<endl;\n        int lb=0,ub=N;\n        while(ub-lb>1){\n            int mid=(ub+lb)/2;\n            if([&](){\n                auto it=lis[mid].lower_bound(x);\n                if(it==lis[mid].begin())return false;\n                it--;\n                return it->se<y;\n            }())lb=mid;\n            else ub=mid;\n        }\n\n        if(lis[ub].find(x)!=lis[ub].end())chmin(lis[ub][x],y);\n        else lis[ub][x]=y;\n\n        while(true){\n            auto it=lis[ub].upper_bound(x);\n            if(it==lis[ub].end())break;\n            if(it->se<=y)break;\n            lis[ub].erase(it);\n        }\n        /*\n        for(int j=0;j<=N;j++){\n            if(lis[j].size()==0)continue;\n            cout<<j<<\"-------\"<<endl;\n            for(auto &z:lis[j])cout<<\"(\"<<z.fi<<\",\"<<z.se<<\")\"<<\" \";cout<<endl;\n        }*/\n    }\n\n    int ans=0;\n    rep(i,N+1)if(lis[i].size())ans=i;\n    printf(\"%d\\n\",ans);\n}\nsigned main(){\n    while(scanf(\"%d%d%d%d\",&M,&N,&A,&B),M||N||A||B)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing std::sort;\nusing std::fill;\nusing std::max;\nusing std::unique;\nusing std::lower_bound;\nconst int N = 330010;\nstruct point {\n    int x,y,z;\n    int id;\n    bool operator < (const point& b) const {\n        if(x == b.x) {\n            if(y == b.y) return z > b.z;\n            else return y > b.y;\n        }\n        return x < b.x;\n    }\n    inline void in() {\n        scanf(\"%d%d%d\",&x,&y,&z);\n    }\n}p[N],g[N];\nint num[N];\nint f[N];\ninline int cmpy(point a,point b){\n    return  a.y < b.y;\n}\nstruct BIT{\n    int n;\n    int c[N];\n    inline void init(int n) {\n        this->n = n;\n    }\n    inline void insert(int x, int add) {\n        for(; x <= n; x += x & -x) if(add > c[x]) c[x] = add;\n    }\n    inline int ask(int x) {\n        int ret = 0;\n        for(; x > 0; x -= x & -x) if(c[x] > ret) ret = c[x];\n        return ret;\n    }\n    inline void clear(int x) {\n        for(; x <= n; x += x & -x) c[x] = 0;\n    }\n}ta;\nvoid update(int l1, int r1, int l2, int r2) {\n    sort(g + l1, g + r1 + 1, cmpy);\n    sort(g + l2, g + r2 + 1, cmpy);\n    int pt = l1;\n    for(int i = l2; i <= r2; i++) {\n        while(pt <= r1 && g[pt].y < g[i].y){\n            ta.insert(g[pt].z, f[g[pt].id]);\n            pt++;\n        }\n        int opt=ta.ask(g[i].z - 1);\n        if(opt + 1 > f[g[i].id]) {\n            f[g[i].id] = opt + 1;\n        }\n    }\n    for(int i = l1; i <= r1; i++) ta.clear(g[i].z);\n}\nvoid solve(int l,int r)\n{\n    if(l == r) {    \n        if(1 > f[p[l].id]) f[p[l].id] = 1;\n        return ; \n    }\n    int mid = (l + r) >> 1;\n    solve(l,mid);\n    for(int i = l; i <= r; i++)    g[i] = p[i];\n    if(p[mid].x != p[mid + 1].x) {\n        //蟾ヲ蜿ウ蛹コ髣エ驛ス謖臥?y謗貞コ擾シ亥キヲ蛹コ髣エ逧з蟾イ扈丈ソ晁ッ∝ー丈コ主承蛹コ髣エ逧з莠?シ?        update(l, mid, mid + 1, r);\n    } else {\n        int leftp = mid;\n        while(leftp >= l && p[leftp].x == p[mid].x) leftp--;\n        int rightp = mid + 1;\n        while(rightp <= r && p[rightp].x == p[mid].x) rightp++;\n        if(leftp < l && rightp > r) { \n            // do nothing\n        } else if(leftp < l) {\n            update(l, mid, rightp, r);\n        } else if(rightp > r){\n            update(l, leftp, mid + 1, r);\n        } else {\n            update(l, leftp, mid + 1, r);\n            for(int i = l; i <= r; i++) g[i] = p[i];\n            update(leftp + 1, mid, rightp, r);\n        }\n    }\n    solve(mid+1,r);\n}\n\nint M, a, b, C;\nint main()\n{\n    int t,m,nn,A,B;\n    while(scanf(\"%d%d%d%d\",&m,&nn,&A,&B) && (m + nn + A + B))\n    {\n        a = A; b = B;\n        C = ~(1 << 31);\n        M = (1 << 16) - 1;\n        for(int i = 1; i <= m; i++) {\n            p[i].in();\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        for(int i = m + 1; i <= m + nn; i++) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int x = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int y = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int z = (C & ((a << 16) + b)) % 1000000;\n            p[i].x = x;\n            p[i].y = y;\n            p[i].z = z;\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        int n = m + nn;\n        sort(num+1,num+n+1);\n        int tot = unique(num+1,num+n+1) - num - 1; \n        for(int i = 1; i <= n; i++) p[i].z = lower_bound(num+1,num+tot+1,p[i].z) - num;\n        ta.init(n);\n        sort(p+1,p+n+1); \n        fill(f, f + n + 1, 1);\n        solve(1, n);\n        int ret = 1;\n        for(int i = 1; i <= n; i++) ret = max(ret, f[i]);\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) delete lch, rch;\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) delete lch, rch;\n\t\tdelete st;\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!(M + N)) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n\nusing namespace std;\nconst int MOD = 1000000007; // check!!!\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\nint m,n,A,B;\n\nstruct P{\n\tint x,y,z;\n\tP(){}\n\tP(int x,int y,int z) : x(x),y(y),z(z) {}\n\tbool operator< (const P& l) const {\n\t\tif(x != l.x) return x < l.x;\n\t\tif(y != l.y) return y > l.y;\n\t\treturn z > l.z;\n\t}\n};\n\nint r(){\n\tconst int C = ~(1<<31);\n\tconst int M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\nbool C(map<int,P>& polyline,const P& p){\n\tmap<int,P>::iterator it = polyline.lower_bound(p.y);\n\tif(it == polyline.begin()) return true;\n\tit--;\n\treturn it->second.z >= p.z;\n}\n\nvoid insert_polyline(vector<map<int,P> >& polyline,const P& p){\n\tint l = -1,r = sz(polyline);\n\twhile(r - l != 1){\n\t\tint md = (l + r) / 2;\n\t\tbool ok = C(polyline[md],p);\n\t\tif(ok) r = md;\n\t\telse l = md;\n\t}\n\tif(sz(polyline) == r){\n\t\tpolyline.push_back(map<int,P>());\n\t}\n\t\n\tpolyline[r][p.y] = p;\n\tmap<int,P>::iterator it = polyline[r].find(p.y);\n\t++it;\n\twhile(true){\n\t\tif(it == polyline[r].end()) break;\n\t\tauto nxt = it; ++nxt;\n\t\tif(it->second.z >= p.z){\n\t\t\tpolyline[r].erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tit = nxt;\n\t}\n}\n\nint main(){\n\t\n\twhile(cin>>m>>n>>A>>B,m||n||A||B){\n\t\tvector<P> v;\n\t\tFOR(i,m){\n\t\t\tint x,y,z; cin>>x>>y>>z;\n\t\t\tv.emplace_back(x,y,z);\n\t\t}\n\t\tFOR(i,n){\n\t\t\tv.emplace_back(r(),r(),r());\n\t\t}\n\t\t\n\t\tsort(v.begin(),v.end());\n\t\t\n\t\tvector<map<int,P> > polyline;\n\t\tFOR(i,sz(v)){\n\t\t\tinsert_polyline(polyline,v[i]);\n\t\t}\n\n\t\tcout << sz(polyline) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <time.h>\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef map<int,int> ::iterator aauto;\n\nint n;\n\nstruct tup{\n\tint x, y, z;\n}a[300005];\n\ntime_t st;\nbool input(){\n\tint pn, m, aa, b;\n\tscanf(\"%d %d %d %d\",&pn,&m,&aa,&b);\n\tif(pn + m == 0) return 0;\n\tfor(int i=1; i<=pn; i++){\n\t\tscanf(\"%d %d %d\",&a[i].x,&a[i].y,&a[i].z);\n\t}\n\tn = pn;\n\tint M = 65535, C = ~(1<<31);\n\twhile(m--){\n\t\tn++;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].x = (C & ((aa << 16) + b)) % 1000000;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].y = (C & ((aa << 16) + b)) % 1000000;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].z = (C & ((aa << 16) + b)) % 1000000;\n\t}\n\treturn 1;\n}\n\nvector<int> vy, vz;\n\nstruct idx{\n\tmap<int,int> mp[1050000];\n\tint lim;\n\tvoid init(int n){\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t\tfor(int i=1; i<=lim + n; i++){\n\t\t\tmp[i].clear();\n\t\t}\n\t}\n\tint qr(int x, int p){\n\t\taauto t = mp[x].upper_bound(p);\n\t\tif(t != mp[x].begin()){\n\t\t\treturn (--t)->second;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid manip(int x, pi t){\n\t\taauto it = mp[x].upper_bound(t.first);\n\t\tif(it != mp[x].begin() && (--it)->second >= t.second){\n\t\t\treturn;\n\t\t}\n\t\tmp[x][t.first] = t.second;\n\t\tit = mp[x].upper_bound(t.first);\n\t\twhile(it != mp[x].end()){\n\t\t\tif(it->second <= t.second){\n\t\t\t\taauto bak = it;\n\t\t\t\tbak++;\n\t\t\t\tmp[x].erase(it);\n\t\t\t\tit = bak;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tvoid add(int x, int v, int w){\n\t\tx += lim;\n\t\tmanip(x, pi(v, w));\n\t\twhile(x > 1){\n\t\t\tx >>= 1;\n\t\t\tmanip(x, pi(v, w));\n\t\t}\n\t}\n\tint q(int s, int e, int x){\n\t\ts += lim;\n\t\te += lim;\n\t\tint ret = 0;\n\t\twhile(s < e && s > 15){\n\t\t\tif(s%2 == 1) ret = max(ret, qr(s++, x));\n\t\t\tif(e%2 == 0) ret = max(ret, qr(e--, x));\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tfor(int i=s; i<=e; i++){\n\t\t\tret = max(ret, qr(i, x));\n\t\t}\n\t\treturn ret;\n\t}\n}idx;\n\nint dp[300005];\n\nbool cmp(const tup &a, const tup &b){\n\tif(a.x != b.x) return a.x < b.x;\n\tif(a.y != b.y) return a.y < b.y;\n\treturn a.z < b.z;\n}\n\nvoid solve(){\n\tsort(a+1,a+n+1,cmp);\n\tvy.clear();\n\tvz.clear();\n\tfor(int i=1; i<=n; i++){\n\t\tvy.push_back(a[i].y);\n\t\tvz.push_back(a[i].z);\n\t}\n\tsort(vy.begin(), vy.end());\n\tsort(vz.begin(), vz.end());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tvz.resize(unique(vz.begin(), vz.end()) - vz.begin());\n\tfor(int i=1; i<=n; i++){\n\t\ta[i].y = (int)(lower_bound(vy.begin(), vy.end(), a[i].y) - vy.begin());\n\t\ta[i].z = (int)(lower_bound(vz.begin(), vz.end(), a[i].z) - vz.begin());\n\t}\n\tidx.init(n);\n\tfor(int i=1; i<=n;){\n\t\tint e = i;\n\t\twhile(e <= n && a[e].x == a[i].x) e++;\n\t\tfor(int j=i; j<e; j++){\n\t\t\tdp[j] = idx.q(0, a[j].y - 1, a[j].z - 1)  + 1;\n\t\t}\n\t\tfor(int j=i; j<e; j++){\n\t\t\tidx.add(a[j].y, a[j].z, dp[j]);\n\t\t}\n\t\ti = e;\n\t}\n\tprintf(\"%d\\n\",*max_element(dp+1,dp+n+1));\n}\n\nint main(){\n\twhile(input()){\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n  \nvoid init(int m_){\n    m0=1;\n    while(m0<m_) m0*=2;\n    for(int i=0; i<2*m0-1; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      v[i].push_back(0);\n    }\n  }\n}\n  \nvoid update(int k, int i, int a){\n    i+=(m[k]-1);\n    v[k][i]=a;\n    while(i>0){\n        i=(i-1)/2;\n        v[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n    }\n}\n \nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n    if(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n \nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n \nint find0(int y, int z, int k, int l, int r){\n    if(r<=0 || y<=l) return 0;\n    if(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n        return find(k, i, 0, 0, m[k]);\n    }else{\n        int vl=find0(y, z, k*2+1, l, (l+r)/2);\n        int vr=find0(y, z, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n\t  set<int> st;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n\t\tst.insert(y);\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n\t\tst.insert(y);\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n\t  map<int, int> mp;\n\t  int ct=0;\n\t  for(auto x:st){\n\t\t  mp[x]=ct;\n\t\t  ct++;\n\t  }\n\t  for(int i=0; i<p.size(); i++){\n\t\t  p[i].second.first=mp[p[i].second.first];\n\t  }\n      init(ct);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(ct+1, 1000000, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  C = ~(1<<31);\n  M = (1<<16)-1;\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<19);\n    dp[0].insert(make_tuple(-1,-1));\n    auto p = equal_range(begin(v),end(v),make_tuple(-1,0,0));\n    REP(i,1000000) {\n      vector<tuple<int,int,int>> add;\n      while(p.second != end(v) && get<0>(*p.second) <= i) ++p.second;\n      for(;p.first != p.second; ++p.first) {\n        int y,z;\n        tie(ignore,y,z) = *p.first;\n        int k=1<<18;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          auto pitr = prev(itr);\n          if (get<0>(*pitr) <= y || get<1>(*pitr) <= z) continue;\n        }\n        while(itr != end(dp[j]) && get<0>(*itr) >= z)\n          itr = dp[j].erase(itr);\n        add.emplace_back(j,y,z);\n      }\n      for(auto t:add){\n        int j,y,z;\n        tie(j,y,z) = t;\n      }\n      sort(begin(add),end(add));\n      auto q = equal_range(begin(add),end(add),make_tuple(0,0,0));\n      while(q.second != end(add)) {\n        while(q.second != end(add) &&\n            get<0>(*q.second) == get<0>(*q.first)) ++q.second;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*q.first);\n        for(; q.first != q.second; ++q.first) {\n          int y,z;\n          tie(ignore,y,z) = *q.first;\n          if (tp.empty() || (get<0>(tp.back()) != y && get<1>(tp.back()) > z))\n            tp.emplace_back(y,z);\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n    }\n    REP(i,1<<19) {\n      if(dp[i].empty()) {\n        cout << (i - 1) << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, M, A, B, C = ~(1 << 31), D = 65535, lim = 1000001, x[300009], y[300009], z[300009], p[300009];\nvector<int> cp[1000009], bit[1000009];\nint func() {\n\tA = 36969 * (A & D) + (A >> 16);\n\tB = 18000 * (B & D) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nvoid assign(int px, int py, int val) {\n\tfor (int i = px + 1; i <= lim; i += i & (-i)) {\n\t\tint ptr = lower_bound(cp[i].begin(), cp[i].end(), py) - cp[i].begin();\n\t\tfor (int j = ptr + 1; j <= cp[i].size(); j += j & (-j)) {\n\t\t\tbit[i][j - 1] = max(bit[i][j - 1], val);\n\t\t}\n\t}\n}\nint query(int px, int py) {\n\tint ret = 0;\n\tfor (int i = px; i >= 1; i -= i & (-i)) {\n\t\tint ptr = lower_bound(cp[i].begin(), cp[i].end(), py) - cp[i].begin();\n\t\tfor (int j = ptr; j >= 1; j -= j & (-j)) {\n\t\t\tret = max(ret, bit[i][j - 1]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d%d\", &N, &M, &A, &B), N + M) {\n\t\tfor (int i = 0; i < N; ++i) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\tfor (int i = 0; i < M; ++i) x[N] = func(), y[N] = func(), z[N] = func(), ++N;\n\t\tfor (int i = 0; i < N; ++i) p[i] = i;\n\t\tsort(p, p + N, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i <= lim; i++) cp[i].clear();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = x[p[i]] + 1; j <= lim; j += j & (-j)) {\n\t\t\t\tcp[j].push_back(y[p[i]]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= lim; i++) {\n\t\t\tsort(cp[i].begin(), cp[i].end());\n\t\t\tcp[i].erase(unique(cp[i].begin(), cp[i].end()), cp[i].end());\n\t\t\tbit[i] = vector<int>(cp[i].size(), 0);\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint res = query(x[p[i]], y[p[i]]);\n\t\t\tassign(x[p[i]], y[p[i]], res + 1);\n\t\t\tret = max(ret, res + 1);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 3.5;\n        // int sqn = 10000;\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            vector<pair<int, int> > should_remove;\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            vector<pair<pair<int, int>, int> > ncalced;\n            auto it = should_remove.begin();\n            REP(i, calced.size()) {\n                if (it != should_remove.end() && calced[i].first == *it) {\n                    it++;\n                    continue;\n                }\n                ncalced.push_back(calced[i]);\n            }\n            calced = ncalced;\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing std::sort;\nusing std::fill;\nusing std::max;\nusing std::unique;\nusing std::lower_bound;\nconst int N = 330010;\nstruct point {\n    int x,y,z;\n    int id;\n    bool operator < (const point& b) const {\n        if(x == b.x) {\n            if(y == b.y) return z > b.z;\n            else return y > b.y;\n        }\n        return x < b.x;\n    }\n    inline void in() {\n        scanf(\"%d%d%d\",&x,&y,&z);\n    }\n}p[N],g[N];\nint num[N];\nint f[N];\ninline int cmpy(point a,point b){\n    return  a.y < b.y;\n}\nstruct BIT{\n    int n;\n    int c[N];\n    inline void init(int n) {\n        this->n = n;\n    }\n    inline void insert(int x, int add) {\n        for(; x <= n; x += x & -x) if(add > c[x]) c[x] = add;\n    }\n    inline int ask(int x) {\n        int ret = 0;\n        for(; x > 0; x -= x & -x) if(c[x] > ret) ret = c[x];\n        return ret;\n    }\n    inline void clear(int x) {\n        for(; x <= n; x += x & -x) c[x] = 0;\n    }\n}ta;\nvoid update(int l1, int r1, int l2, int r2) {\n    sort(g + l1, g + r1 + 1, cmpy);\n    sort(g + l2, g + r2 + 1, cmpy);\n    int pt = l1;\n    for(int i = l2; i <= r2; i++) {\n        while(pt <= r1 && g[pt].y < g[i].y){\n            ta.insert(g[pt].z, f[g[pt].id]);\n            pt++;\n        }\n        int opt=ta.ask(g[i].z - 1);\n        if(opt + 1 > f[g[i].id]) {\n            f[g[i].id] = opt + 1;\n        }\n    }\n    for(int i = l1; i <= r1; i++) ta.clear(g[i].z);\n}\nvoid solve(int l,int r)\n{\n    if(l == r) {    \n        if(1 > f[p[l].id]) f[p[l].id] = 1;\n        return ; \n    }\n    int mid = (l + r) >> 1;\n    solve(l,mid);\n    for(int i = l; i <= r; i++)    g[i] = p[i];\n    if(p[mid].x != p[mid + 1].x) {\n        //蟾ヲ蜿ウ蛹コ髣エ驛ス謖臥?y謗貞コ?蟾ヲ蛹コ髣エ逧з蟾イ扈丈ソ晁ッ∝ー丈コ主承蛹コ髣エ逧з莠?\n        update(l, mid, mid + 1, r);\n    } else {\n        int leftp = mid;\n        while(leftp >= l && p[leftp].x == p[mid].x) leftp--;\n        int rightp = mid + 1;\n        while(rightp <= r && p[rightp].x == p[mid].x) rightp++;\n        if(leftp < l && rightp > r) { \n        } else if(leftp < l) {\n            update(l, mid, rightp, r);\n        } else if(rightp > r){\n            update(l, leftp, mid + 1, r);\n        } else {\n            update(l, leftp, mid + 1, r);\n            for(int i = l; i <= r; i++) g[i] = p[i];\n            update(leftp + 1, mid, rightp, r);\n        }\n    }\n    solve(mid+1,r);\n}\n\nint M, a, b, C;\nint main()\n{\n    int t,m,nn,A,B;\n    while(scanf(\"%d%d%d%d\",&m,&nn,&A,&B) && (m + nn + A + B))\n    {\n        a = A; b = B;\n        C = ~(1 << 31);\n        M = (1 << 16) - 1;\n        for(int i = 1; i <= m; i++) {\n            p[i].in();\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        for(int i = m + 1; i <= m + nn; i++) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int x = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int y = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int z = (C & ((a << 16) + b)) % 1000000;\n            p[i].x = x;\n            p[i].y = y;\n            p[i].z = z;\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        int n = m + nn;\n        sort(num+1,num+n+1);\n        int tot = unique(num+1,num+n+1) - num - 1; \n        for(int i = 1; i <= n; i++) p[i].z = lower_bound(num+1,num+tot+1,p[i].z) - num;\n        ta.init(n);\n        sort(p+1,p+n+1); \n        fill(f, f + n + 1, 1);\n        solve(1, n);\n        int ret = 1;\n        for(int i = 1; i <= n; i++) ret = max(ret, f[i]);\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xor128(void)\n{ \n  static int x = 123456789;\n  static int y = 362436069;\n  static int z = 521288629;\n  static int w = 88675123; \n  int t;\n   \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n}\n  \nstruct Node {\n  int Value;\n  int Data;\n  int SubTreeSize;\n  Node *Lch, *Rch;\n  int RMQ;\n  \n  Node(int V, int T):Value(V), Data(T), SubTreeSize(1), RMQ(T) {\n    Lch = (Node *)NULL;\n    Rch = (Node *)NULL;\n  };\n};\ninline int Count(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> SubTreeSize);\n}\n\ninline int Sum(Node *t)\n{\n  if(t == (Node *)NULL) return(0);\n  else return(t -> RMQ);\n}\ninline Node *Update(Node *t)\n{\n  t -> SubTreeSize = Count(t -> Lch) + Count(t -> Rch) + 1;\n  t -> RMQ = max(Sum(t -> Lch), max(Sum(t -> Rch), t -> Data));\n  return(t);\n}\n  \ninline Node *MakeRoot(int value, int T)\n{\n  return(new Node(value, T));\n}\n  \nNode *Merge(Node *l, Node *r)\n{\n  if(l == (Node *)NULL) return(r);\n  if(r == (Node *)NULL) return(l);\n  int Left  = l -> SubTreeSize;\n  int Right = r -> SubTreeSize;\n  if(xor128() % (Left + Right) < Left) {\n    l -> Rch = Merge(l -> Rch, r);\n    return(Update(l));\n  } else {\n    r -> Lch = Merge(l, r -> Lch);\n    return(Update(r));\n  }\n}\n    \npair< Node*, Node* > Split(Node *t, int k) // [0, k), [k, n)\n{\n  if(t == (Node *)NULL) return(make_pair((Node *)NULL, (Node *)NULL));\n  if(k <= Count(t -> Lch)) {\n    pair< Node *, Node *> s = Split(t -> Lch, k);\n    t -> Lch = s.second;\n    return(make_pair(s.first, Update(t)));\n  } else {\n    pair< Node *, Node *> s = Split(t -> Rch, k - Count(t -> Lch) - 1);\n    t -> Rch = s.first;\n    return(make_pair(Update(t), s.second));\n  }\n}\n  \nNode *Insert(Node *root, int pos, int value, int T)\n{\n  Node *p = MakeRoot(value, T);\n  pair< Node *, Node *> s = Split(root, pos);\n  return(Merge(Merge(s.first, p), s.second));\n}\n\nint Lower_Bound(Node *root, int Value)\n{\n  if(root == (Node *)NULL) return(0);\n  if(Value < root -> Value) return(Lower_Bound(root -> Lch, Value));\n  return(Lower_Bound(root -> Rch, Value) + Count(root -> Lch) + 1);\n}\n  \nNode *Insert(Node *root, int Value, int T)\n{\n  return(Insert(root, Lower_Bound(root, Value), Value, T));\n}\n\nstruct MatrixSegmentTree\n{\n  vector< Node* > node;\n  int sz;\n  \n  MatrixSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    node.resize(2 * sz - 1);\n    for(int i = 0; i < 2 * sz - 1; i++) {\n      node[i] = (Node *)NULL;\n    }\n  }\n  \n  int MatrixMax(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) {\n      return(0);\n    } else if(a <= l && r <= b) {\n      auto p = Split(node[k], Lower_Bound(node[k], x - 1));\n      int maximum = Sum(p.first);\n      node[k] = Merge(p.first, p.second);\n      return(maximum);\n    } else {\n      int LL = MatrixMax(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n      int RR = MatrixMax(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n      return(max(LL, RR));\n    }\n  }\n  \n  int MatrixMax(int a, int b)\n  {\n    return(MatrixMax(0, a, b, 0, 0, sz));\n  }\n  \n  void PointUpdate(int k, int b, int val)\n  {\n    k += sz - 1;\n    node[k] = Insert(node[k], b, val);\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      node[k] = Insert(node[k], b, val);\n    }\n  }\n};\n\ninline int r(int& a, int& b)\n{\n  int C = ~(1<<31), M = (1<<16)-1;\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main()\n{\n  \n  int n, m, a, b;\n  while(scanf(\"%d %d %d %d\", &m, &n, &a, &b), m+n) {\n    \n    vector< tuple< int, int, int > > g;\n    vector< int > nums;\n    for(int i = 0; i < m; i++) {\n      int x, y, z;\n      scanf(\"%d %d %d\", &x, &y, &z);\n      g.emplace_back(x, y, z);\n    }\n    for(int i = m; i < m + n; i++) {\n      g.emplace_back(r(a, b), r(a, b), r(a, b));\n    }\n    n += m;\n    \n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      nums.push_back(yy);\n    }\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      yy = lower_bound(begin(nums), end(nums), yy) - begin(nums);\n      g[i] = make_tuple(xx, -yy, -zz);\n    }\n    sort(g.begin(), g.end());\n    \n    // O(n log^2 n)\n    MatrixSegmentTree tree(nums.size());\n    int ret = 0;\n    for(int i = 0; i < g.size(); i++) {\n      int xx, yy, zz;\n      tie(xx, yy, zz) = g[i];\n      yy *= -1; zz *= -1;\n      int get = tree.MatrixMax(yy, zz) + 1;\n      ret = max(ret, get);\n      tree.PointUpdate(yy, zz, get);\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MN 1000005\nint A, B, C, M;\nint rand() {\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nstruct data { int x, y, z, k; } d[MN];\nint dyn[MN], Y;\ninline bool cmp(data a, data b) {\n\tif (a.x != b.x) return a.x < b.x;\n\tif (a.y != b.y) return a.y < b.y;\n\treturn a.z < b.z;\n}\nint ym[MN], yd[MN];\nmap <int, int> r[MN];\nmap<int,int>::iterator it, it2;\nvoid upd(int x, int y, int v) {\n\twhile (x < Y) {\n\t\tit = it2 = r[x].upper_bound(y);\n\t\twhile (it2 != r[x].end() && it2->second <= v) it2++;\n\t\tr[x].erase(it, it2);\n\t\tit = r[x].upper_bound(y);\n\t\tif (it == r[x].begin() || (--it)->second < v) r[x][y] = v;\n\t\tx += x&(-x);\n\t}\n}\nint ret, val;\nint f(int x, int y) {\n\tret = -1;\n\twhile (x > 0) {\n\t\tit = r[x].lower_bound(y);\n\t\tif (it != r[x].begin()) val = (--it)->second;\n\t\telse val = -1;\n\t\tif (ret < val) ret = val;\n\t\tx &= x-1;\n\t}\n\treturn ret;\n}\nint main() {\n\tint i, j;\n\tint m, n, N;\n\twhile (scanf(\"%d%d%d%d\",&m,&n,&A,&B),m||n||A||B) {\n\t\tN = m+n; Y = 0;\n\t\tC = ~(1<<31); M = (1<<16)-1;\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d%d\",&d[i].x,&d[i].y,&d[i].z);\n\t\tfor (i = m; i < m+n; i++) d[i].x = rand(), d[i].y = rand(), d[i].z = rand();\n\t\tym[0] = -1;\n\t\tfor (i = 0; i < N; i++) d[i].k = i, ym[++Y] = d[i].y;\n\t\tsort(d, d+N, cmp);\n\t\tsort(ym+1, ym+Y+1);\n\t\tY = 0;\n\t\tfor (i = 1; i <= N; i++) if (ym[i] != ym[i-1]) yd[ym[i]] = ++Y;\n\t\tfor (i = 0; i < N; i++) d[i].y = yd[d[i].y];\n\t\tY+=2;\n\t\tfor (i = 0; i < Y; i++) r[i].clear();\n\t\ti = 0;\n\t\tdo {\n\t\t\tfor (j = i; j < N && d[i].x == d[j].x; j++) dyn[d[j].k] = max(1, f(d[j].y-1, d[j].z)+1);\n\t\t\tfor (; i < j; i++) upd(d[i].y, d[i].z, dyn[d[i].k]);\n\t\t} while (i < N);\n\t\tprintf(\"%d\\n\",f(Y-1, 3*MN));\n\t\tm = n = A = B = 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Generator{\n    int a, b, C, M;\n    Generator(int A, int B){\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    }\n    int generate() {\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nconst int INF = 100000000;\ntypedef pair<int, int> Point;\n\nvoid query(int x, int y, set<Point>& s, map<Point, int>& score){\n    //printf(\"(%d, %d)\\n\", x, y);\n    const Point np(x, y);\n    auto itr = s.lower_bound(Point(x + 1, -INF));\n    Point R = *itr;\n    if(R.second >= y){\n        vector<Point> removes;\n        while(itr->second >= y){\n            removes.push_back(*itr);\n            itr++;\n        }\n        int maximum = 0;\n        for(Point p : removes){\n            maximum = max(maximum, score[p]);\n            s.erase(p);\n            score.erase(p);\n        }\n        score[np] = maximum;\n        s.insert(np);\n    }else{\n        vector<Point> removes;\n        itr--;\n        while(itr->second < y){\n            removes.push_back(*itr);\n            itr--;\n        }\n        Point L = *itr;\n        if(x > L.first && y > R.second){\n            int maximum = 0;\n            for(Point p : removes){\n                maximum = max(maximum, score[p]);\n                s.erase(p);\n                score.erase(p);\n            }\n            score[np] = maximum + 1;\n            s.insert(np);\n        }\n    }\n    /*\n    for(auto p : s){\n        printf(\"(%d, %d) \", p.first, p.second);\n    }\n    cout << endl;\n    for(auto mp : score){\n        Point p = mp.first;\n        printf(\"(%d, %d -> %d) \", p.first, p.second, mp.second);\n    }\n    cout << endl;\n    */\n}\n\nint main(){\n    int M, N, A, B;\n    const int MAX = 1000000;\n    while(cin >> M >> N >> A >> B && (M + N) != 0){\n        vector<vector<Point>> rect(MAX);\n        for(int i = 0; i < M; i++){\n            int x;\n            Point p;\n            cin >> x >> p.first >> p.second;\n            rect[x].push_back(p);\n        }\n        Generator gen(A, B);\n        for(int i = 0; i < N; i++){\n            Point p;\n            int x = gen.generate();\n            p.first = gen.generate();\n            p.second = gen.generate();\n            rect[x].push_back(p);\n        }\n\n        set<Point> s;\n        map<Point, int> score;\n        s.insert(Point(INF, -1));\n        s.insert(Point(-1, INF));\n        for(Point p : s) score[p] = 0;\n        for(vector<Point> points : rect){\n            sort(points.begin(), points.end(), greater<Point>());\n            for(Point p : points){\n                query(p.first, p.second, s, score);\n            }\n        }\n        int answer = 0;\n        for(auto mp : score){\n            answer = max(answer, mp.second);\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nclass HappySequence{\npublic:\n\tmap<int,int> seq;\n\tHappySequence(){ int inf = 1e9; seq[-inf] = -inf; }\n\tbool insert(int key,int val){\n\t\tif( (--seq.upper_bound(key))->second >= val ) return false;\n\t\tseq[key] = val;\n\t\tauto it = ++seq.find(key);\n\t\twhile( it != seq.end() ){\n\t\t\tif( (*it).second <= val ) seq.erase(it++);\n\t\t\telse it++;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nHappySequence seg[1000100];\n\nvoid ins(int y,int z,int v){\n\tfor(int i = y ; i < 1000100 ; i += i & -i ) seg[i].insert(z,v);\n}\nint get(int y,int z){\n\tint v = 0;\n\tfor(int i = y ; i > 0 ; i -= i & -i ){\n\t\tv = max(v,(--seg[i].seq.lower_bound(z))->second);\n\t}\n\treturn v;\n}\n\nint main(){\n\tint n,m,A,B;\n\twhile( cin >> m >> n >> A >> B && n+m ){\t\n\t\ta = A;\n\t\tb = B;\n\t\tvector< array<int,3> > ps;\n\t\tvector<int> uy;\n\t\tfor(int i = 0 ; i < m ; i++){\t\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tsort(uy.begin(),uy.end());\n\t\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\t\tfor(int i = 0 ; i <= uy.size() ; i++) seg[i] = HappySequence();\n\t\tsort(ps.begin(),ps.end(),[&](array<int,3> a,array<int,3> b){\n\t\t\tif( a[0] != b[0] ) return a[0] < b[0];\n\t\t\treturn make_pair(a[1],a[2]) > make_pair(b[1],b[2]);\n\t\t});\n\t\tint ans = 0;\n\t\tfor( auto p : ps ){\n\t\t\tp[1] = lower_bound(uy.begin(),uy.end(),p[1]) - uy.begin() + 1;\n\t\t\tint mx = get(p[1]-1,p[2]) + 1;\n\t\t\tans = max(ans,mx);\n\t\t\tins(p[1],p[2],mx);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = _val;\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nint main() {\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nusing T = pair<int, int>;\nconst T id = T(INT_MAX, 0);\nT op(const T& l, const T& r) {\n\treturn make_pair(min(l.first, r.first), max(l.second, r.second));\n}\n\nstruct node {\n\tT val, all;\n\tnode *ch[2];\n\tint dep, size;\n\tnode() {}\n};\n\nint it = 0;\nconst int pmax = 1e7;\n\nnode pool[pmax];\n\nnode *new_node(T v, node *l = nullptr, node *r = nullptr) {\n\tassert(it < pmax);\n\tpool[it].val = v;\n\tpool[it].all = v;\n\tpool[it].dep = 1;\n\tpool[it].size = 1;\n\tpool[it].ch[0] = l;\n\tpool[it].ch[1] = r;\n\treturn pool + it++;\n}\n\nint depth(node *t) { return t ? t->dep : 0; }\nint count(node *t) { return t ? t->size : 0; }\nT que(node *t) { return t ? t->all : id; }\n\nnode *update(node *t) {\n\tt->dep = max(depth(t->ch[0]), depth(t->ch[1])) + 1;\n\tt->all = op(que(t->ch[0]), op(t->val, que(t->ch[1])));\n\tt->size = count(t->ch[0]) + count(t->ch[1]) + 1;\n\treturn t;\n}\n\nnode *rotate(node *t, int b) {\n\tnode *s = t->ch[1 - b];\n\tt->ch[1 - b] = s->ch[b];\n\ts->ch[b] = t;\n\tt = update(t);\n\ts = update(s);\n\treturn s;\n}\n\nnode *fix(node *t) {\n\tif (t == nullptr) return t;\n\tif (depth(t->ch[0]) - depth(t->ch[1]) == 2) {\n\t\tif (depth(t->ch[0]->ch[1]) > depth(t->ch[0]->ch[0])) {\n\t\t\tt->ch[0] = rotate(t->ch[0], 0);\n\t\t}\n\t\tt = rotate(t, 1);\n\t}\n\telse if (depth(t->ch[0]) - depth(t->ch[1]) == -2) {\n\t\tif (depth(t->ch[1]->ch[0]) > depth(t->ch[1]->ch[1])) {\n\t\t\tt->ch[1] = rotate(t->ch[1], 1);\n\t\t}\n\t\tt = rotate(t, 0);\n\t}\n\treturn t;\n}\n\nnode *insert(node *t, int k, int x, int val) {\n\tif (!t) return new_node(T(x, val));\n\tint c = count(t->ch[0]), b = (k > c);\n\tt->ch[b] = insert(t->ch[b], k - (b ? (c + 1) : 0), x, val);\n\tupdate(t);\n\treturn fix(t);\n}\n\nnode *find(node *t, int k) {\n\tif (t == nullptr) return t;\n\tint c = count(t->ch[0]);\n\treturn k < c ? find(t->ch[0], k) : k == c ? t : find(t->ch[1], k - (c + 1));\n}\n\nnode *erase(node *);\n\nnode *erase(node *t, int k) {\n\tif (t == nullptr) return nullptr;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = erase(t->ch[0], k);\n\t\tt = update(t);\n\t}\n\telse if (k > c) {\n\t\tt->ch[1] = erase(t->ch[1], k - (c + 1));\n\t\tt = update(t);\n\t}\n\telse {\n\t\tt = erase(t);\n\t}\n\treturn fix(t);\n}\n\nnode *erase(node *t) {\n\tif (t == nullptr) return nullptr;\n\tif (t->ch[0] == nullptr && t->ch[1] == nullptr) {\n\t\treturn nullptr;\n\t}\n\tif (t->ch[0] == nullptr || t->ch[1] == nullptr) {\n\t\tnode *res = t->ch[t->ch[0] == nullptr];\n\t\treturn res;\n\t}\n\tnode *res = new_node(find(t->ch[1], 0)->val, t->ch[0], erase(t->ch[1], 0));\n\treturn fix(update(res));\n}\n\nT find(node *t, int l, int r) {\n\tif (!t) return id;\n\tif (r < 0 || l >= count(t)) return id;\n\tif (l <= 0 && r >= t->size) return t->all;\n\tint c = count(t->ch[0]);\n\treturn op(!t->ch[0] ? id : find(t->ch[0], l, r), op(l <= c && c < r ? t->val : id, t->ch[1] == nullptr ? id : find(t->ch[1], l - (c + 1), r - (c + 1))));\n}\n\nnode *update_val(node *t, int k, int x, int val) {\n\tif (!t) return t;\n\tint c = count(t->ch[0]);\n\tif (k < c) {\n\t\tt->ch[0] = update_val(t->ch[0], k, x, val);\n\t}\n\telse if (k == c) {\n\t\tt->val.first = x;\n\t\tt->val.second = val;\n\t}\n\telse {\n\t\tt->ch[1] = find(t->ch[1], k - (c + 1));\n\t}\n\treturn update(t);\n}\n\nint count_lower(node *t, int v) {\n\tif (t == nullptr) return 0;\n\tif (t->val.first < v) return count(t->ch[0]) + 1 + count_lower(t->ch[1], v);\n\tif (t->val.first == v) return count(t->ch[0]);\n\treturn count_lower(t->ch[0], v);\n}\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nnode *segs[MAX * 2];\n\nnode* update(node* p, int x, int val) {\n\tint pos = count_lower(p, x);\n\tbool ok = false;\n\tif (p && pos < p->size) {\n\t\tauto t = find(p, pos);\n\t\tif (t->val.first == x) {\n\t\t\tok = true;\n\t\t\tp = update_val(p, pos, x, val);\n\t\t}\n\t}\n\tif (!ok) {\n\t\tp = insert(p, pos, x, val);\n\t}\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) --r, res = max(res, find(segs[r], 0, count_lower(segs[r], y)).second);\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Generator{\n    int a, b, C, M;\n    Generator(int A, int B){\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    }\n    int generate() {\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nconst int INF = 100000000;\ntypedef pair<int, int> Point;\n\nvoid insert(int x, int y, set<Point>& s){\n    const Point np(x, y);\n    auto itr = s.lower_bound(np);\n    if((--itr)->second <= y) return ;\n    itr++;\n    vector<Point> removes;\n    while(itr->second >= y){\n        removes.push_back(*itr);\n        itr++;\n    }\n    for(Point p : removes){\n        s.erase(p);\n    }\n    s.insert(np);\n    /*\n    for(auto p : s){\n        printf(\"(%d, %d) \", p.first, p.second);\n    }\n    cout << endl;\n    */\n}\n\nint main(){\n    int M, N, A, B;\n    const int MAX = 1000000;\n    while(cin >> M >> N >> A >> B && (M + N) != 0){\n        vector<vector<Point>> rect(MAX);\n        for(int i = 0; i < M; i++){\n            int x;\n            Point p;\n            cin >> x >> p.first >> p.second;\n            rect[x].push_back(p);\n        }\n        Generator gen(A, B);\n        for(int i = 0; i < N; i++){\n            Point p;\n            int x = gen.generate();\n            p.first = gen.generate();\n            p.second = gen.generate();\n            rect[x].push_back(p);\n        }\n\n        vector<set<Point>> sets(N + M + 1);\n        for(auto& s : sets){\n            s.insert(Point(INF, -1));\n            s.insert(Point(-1, INF));\n        }\n\n        int answer = 0;\n        for(const vector<Point>& points : rect){\n            vector<pair<int, Point>> querys;\n            for(const Point& p : points){\n                int x = p.first, y = p.second;\n                int l = -1, r = answer + 1;\n                while(r - l > 1){\n                    int c = (l + r) / 2;\n                    auto itr = sets[c].lower_bound(Point(x, -INF));\n                    if((--itr)->second < y){\n                        l = c;\n                    }else{\n                        r = c;\n                    }\n                }\n                querys.emplace_back(r, p);\n                answer = max(answer, r + 1);\n            }\n            for(const auto& query : querys){\n                int k = query.first;\n                Point p = query.second;\n                //printf(\"%d (%d, %d)\\n\", k, p.first, p.second);\n                insert(p.first, p.second, sets[k]);\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[1209], qy[1209], t[1209][1209], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n) / 2 + 1;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1000005\ntypedef unordered_map< int ,int > vec;\ntypedef unordered_map< int , vec > mat;\n\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n\nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n\nint x[MAX],y[MAX],z[MAX];\n\n\nint query(vec &t,int x){\n  int res=0;\n  while(x>0){\n    if(t.count(x)>0){\n      res=max(res,t[x]);\n    }\n    x-=(x&-x);\n  }\n  return res;\n}\n\nint query(mat &T,int y,int x){\n  int res=0;\n  while(y>0){\n    if(T.count(y)>0){\n      res=max(res,query(T[y],x));\n    }\n    y-=(y&-y);\n  }\n  return res;\n}\n\nvoid update(vec &t,int x,int value){\n  while(x<MAX){\n    t[x]=max(t[x],value);\n    x+=(x&-x);\n  }\n}\n\nvoid update(mat &T,int y,int x,int value){\n  while(y<MAX){\n    update(T[y],x,value);\n    y+=(y&-y);\n  }\n}\n\n\nvector<int> G[MAX];\nint g[MAX];\n\nint solve(){\n  mat T;\n\n  for(int i=0;i<m+n;i++){\n    x[i]+=2,y[i]+=2,z[i]+=2;\n    G[ z[i] ].push_back(x[i]);\n    G[ z[i] ].push_back(y[i]);\n  }\n  for(int i=0;i<MAX;i++){\n    \n    for(int j=0;j<(int)G[i].size();j+=2){\n      int px=G[i][j];\n      int py=G[i][j+1];\n      g[j]=query(T,px-1,py-1)+1;\n    }\n    for(int j=0;j<(int)G[i].size();j+=2){\n      int px=G[i][j];\n      int py=G[i][j+1];\n      update(T,px,py,g[j]);\n    }\n\n    G[i].clear();\n  }\n  \n  return query(T,MAX-1,MAX-1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n\n    a=A,b=B;\n    \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n\n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct bit {\n\tint N;\n\tvector<int> a;\n\tbit(int _N = 0) : N(_N), a(_N + 1) {}\n\tint get(int i) {\n\t\tint val = 0;\n\t\tfor (; i; i -= i & -i) val = max(val, a[i]);\n\t\treturn val;\n\t}\n\tvoid set(int i, int val) {\n\t\tfor (i++; i < N; i += i & -i) a[i] = max(a[i], val);\n\t}\n};\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) { delete lch; delete rch; }\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tbit bt;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tbt = bit(X.size()); // new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) { delete lch; delete rch; }\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn bt.get(r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tbt.set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri,P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi-1,nw.se));\n    if(it != st[cri].begin()){\n        --it;\n        return it->se < nw.se;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,A,B;\n        cin >> m >> n >> A >> B;\n        a = A, b = B;\n        rep(i,n+m+1){\n            st[i].clear();\n        }\n        rep(i,1000000){\n            v[i].clear();\n        }\n        if(n == 0 && m == 0 && A == 0 && B == 0){\n            break;\n        }\n        rep(i,m){\n            int s,t,u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t,u));\n        }\n        rep(i,n){\n            int xx = r();\n            int yy = r();\n            int zz = r();\n            v[xx].pb(P(yy,zz));\n        }\n        int mx = -1;\n        rep(i,1000000){\n            if(len(v[i])){\n                sort(all(v[i]),[&](const P& p,const P& q){\n                    return (p.fi==q.fi)?(p.se>q.se):(p.fi>q.fi);\n                });\n                each(it,v[i]){\n                    int l = -1,r = mx+1;\n                    while(r-l>1){\n                        int mid = (l+r)/2;\n                        if(contain(mid,it)){\n                            l = mid;\n                        }else{\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if(it2 != st[r].begin()){\n                        --it2;\n                        if(it2->se <= it.se){\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while(1){\n                        if(it2 != st[r].end()){\n                            if(it2->se >= it.se){\n                                it2 = st[r].erase(it2);\n                            }else{\n                                cmx(mx,r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        }else{\n                            cmx(mx,r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx+1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10, inf = 1e9;\n\nstruct Node {\n    PII e;\n    Node *ls, *rs;\n    int dim, cur, sub;\n} pool[MAXN], *cnt;\n\nstruct Point {\n    int x, y, z;\n    Point() {}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} Triple[MAXN];\n\nPII P[MAXN];\nint N, M, A, B;\n\nint r() {\n    int C = ~(1 << 31), M = (1 << 16) - 1;\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\ninline bool cmpX(const PII &a, const PII &b) {\n    return a.first < b.first || (a.first == b.first && a.second < b.second);\n}\n\ninline bool cmpY(const PII &a, const PII &b) {\n    return a.second < b.second || (a.second == b.second && a.first < b.first);\n}\n\nNode *build(PII P[], int l, int r, int dim) {\n    if (l >= r) return NULL;\n    Node *rt = cnt ++; rt->dim = dim;\n    int mid = (l + r) >> 1;\n    nth_element(P + l, P + mid, P + r, dim ? cmpY : cmpX);\n    rt->e = P[mid];\n    rt->cur = rt->sub = 0;\n    rt->ls = build(P, l, mid, dim ^ 1);;\n    rt->rs = build(P, mid + 1, r, dim ^ 1);\n    return rt;\n}\n\nvoid modify(Node *rt, const PII &e, int value) {\n    rt->sub = max(rt->sub, value);\n    if (e == rt->e) {\n        rt->cur = max(rt->cur, value);\n        return;\n    }\n    bool o = rt->dim ? cmpY(e, rt->e) : cmpX(e, rt->e);\n    if (o) modify(rt->ls, e, value);\n    else modify(rt->rs, e, value);\n}\n\nint ret;\nvoid get(Node *rt, const PII &e, int maxx = inf, int maxy = inf) {\n    if (!rt) return;\n    if (maxx < e.first && maxy < e.second) ret = max(ret, rt->sub);\n    else {\n        if (rt->e.first < e.first && rt->e.second < e.second) ret = max(ret, rt->cur);\n        if (rt->dim) {\n            if (rt->e.second < e.second) get(rt->rs, e, maxx, maxy);\n            get(rt->ls, e, maxx, min(maxy, rt->e.second));\n        }\n        else {\n            if (rt->e.first < e.first) get(rt->rs, e, maxx, maxy);\n            get(rt->ls, e, min(maxx, rt->e.first), maxy);\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &Triple[i].x, &Triple[i].y, &Triple[i].z);\n            P[i] = PII(Triple[i].y, Triple[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            Triple[i].x = r();\n            Triple[i].y = r();\n            Triple[i].z = r();\n            P[i] = PII(Triple[i].y, Triple[i].z);\n        }\n        sort(P, P + N);\n        M = unique(P, P + N) - P;\n        cnt = pool;\n        Node *root = build(P, 0, M, 0);\n        sort(Triple, Triple + N);\n        for (int i = 0; i < N; ++ i) {\n            ret = 0;\n            get(root, PII(Triple[i].y, Triple[i].z));\n            modify(root, PII(Triple[i].y, Triple[i].z), ret + 1);\n        }\n        printf(\"%d\\n\", root->sub);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxn], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m + A + B)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z, g[i] = 1;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r(), g[i] = 1;\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * また、点数に比べて座標が大きいので、座標圧縮するとオーダーが減らせる。\n * こうするとN+M個の点それぞれについて、高々(log(N+M))^2個のノードが作られるので、メモリ使用量はO((N+M) (log N+M)^2)となる。\n *\n * オーダーは O((N+M) (log (N+M))^2)。\n */\n#define NDEBUG\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n    };\n\n    Node root;\n    int xs, ys;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int xs, int ys) : xs(xs), ys(ys), allocator_(3000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        assert(xr <= xs && yr <= ys);\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, xs, 0, ys, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        assert(xr <= xs && yr <= ys);\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, xs, 0, ys, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nnamespace std {\ntemplate<>\nstruct hash<pair<int,int>> {\n    bool operator ()(const pair<int,int> &p) const {\n        return p.first * 300000 + p.second;\n    }\n};\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    vector<int> ys, zs;\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n        ys.push_back(y);\n        zs.push_back(z);\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n        ys.push_back(y);\n        zs.push_back(z);\n    }\n    {\n        sort(begin(ys), end(ys));\n        ys.erase(unique(begin(ys), end(ys)), end(ys));\n        sort(begin(zs), end(zs));\n        zs.erase(unique(begin(zs), end(zs)), end(zs));\n        vector<int> dicty(ys.back()+1);\n        vector<int> dictz(zs.back()+1);\n        int cnt = 0;\n        for(const auto &e : ys) {\n            dicty[e] = cnt++;\n        }\n        cnt = 0;\n        for(const auto &e : zs) {\n            dictz[e] = cnt++;\n        }\n        for(auto &p : ps) {\n            int x, y, z;\n            tie(x, y, z) = p;\n            p = make_tuple(x, dicty[y], dictz[z]);\n        }\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(ys.size(), zs.size());\n    unordered_map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, seg.xs, 0, seg.ys) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ld INF = 1e+30;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\n//3D BIT\n//[x,∞)×[y,∞)×[z,∞)に含まれる点の個数を数える\nstruct BIT {\nprivate:\n\tvector<int> node; int n;\npublic:\n\tint f(int a, int b) {\n\t\treturn max(a, b);\n\t}\n\tvoid init(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//[0,a)\n\tint query(int a) {\n\t\tint ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret = f(ret, node[i]);\n\t\treturn ret;\n\t}\n\tvoid update(int a, int b) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] = f(node[i], b);\n\t}\n};\nstruct BIT2 {\nprivate:\n\tvector<BIT> node; int sz;\n\tvector<vector<int>> vy;\npublic:\n\tint f(int a, int b) {\n\t\treturn max(a, b);\n\t}\n\tvoid init(int n) {\n\t\tsz = n; node.resize(n);\n\t\tvy.resize(n);\n\t}\n\t//先読み。\n\tvoid add(int x, int y) {\n\t\tfor (int i = x; i < sz; i |= i + 1) {\n\t\t\tvy[i].push_back(y);\n\t\t}\n\t}\n\t//先読みの反映。\n\tvoid complete() {\n\t\trep(i, sz) {\n\t\t\tsort(vy[i].begin(), vy[i].end());\n\t\t\tvector<int> cop = vy[i];\n\t\t\tvy[i].erase(unique(vy[i].begin(), vy[i].end()), vy[i].end());\n\t\t\tint siz = vy[i].size();\n\t\t\tnode[i].init(siz);\n\t\t}\n\t}\n\tint query(int x, int y) {\n\t\tint ret = 0;\n\t\tfor (int i = x - 1; i >= 0; i = (i&(i + 1)) - 1) {\n\t\t\tint idy = lower_bound(vy[i].begin(), vy[i].end(), y) - vy[i].begin();\n\t\t\tret =f(ret, node[i].query(idy));\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid update(int x, int y,int k) {\n\t\tfor (int i = x; i < sz; i |= i + 1) {\n\t\t\tint idy = lower_bound(vy[i].begin(), vy[i].end(), y) - vy[i].begin();\n\t\t\tnode[i].update(idy, k);\n\t\t}\n\t}\n};\n\nint A, B;\nint a, b, c,M;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (c & ((a << 16) + b)) % 1000000;\n}\n\nstruct triple {\n\tint x, y, z;\n\tbool operator<(const triple &t)const {\n\t\tif (x != t.x)return x < t.x;\n\t\tif (y != t.y)return y > t.y;\n\t\treturn z > t.z;\n\t}\n};\nvoid solve() {\n\tint n, m;\n\twhile (cin >> m >> n >> A >> B, A) {\n\t\ta = A, b = B, c = ~(1 << 31), M = (1 << 16) - 1;\n\t\tvector<triple> v;\n\t\tvector<int> vy;\n\t\trep(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tv.push_back({ x,y,z });\n\t\t\tvy.push_back(y);\n\t\t}\n\t\trep(i, n) {\n\t\t\tint x = r(); int  y = r();int z = r();\n\t\t\tv.push_back({ x,y,z });\n\t\t\tvy.push_back(y);\n\t\t}\n\t\tsort(vy.begin(), vy.end());\n\t\tvy.erase(unique(vy.begin(), vy.end()), vy.end());\n\t\tint len = vy.size();\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tBIT2 b; b.init(len);\n\t\trep(i, v.size()) {\n\t\t\tint idy = lower_bound(vy.begin(), vy.end(), v[i].y) - vy.begin();\n\t\t\tb.add(idy, v[i].z);\n\t\t}\n\t\tb.complete();\n\t\trep(i, v.size()) {\n\t\t\tint idy = lower_bound(vy.begin(), vy.end(), v[i].y) - vy.begin();\n\t\t\tint z = b.query(idy, v[i].z); z++;\n\t\t\tans = max(ans, z);\n\t\t\tb.update(idy, v[i].z, z);\n\t\t\t//cout << z << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nvector<P> v1[300001];\nvector<int> v[300001];\nvector<Pint> p;\nint ct;\nvoid init(){\n    for(int i=1; i<=ct; i++){\n        v[i].clear(); v1[i].clear();\n\t\tvector<int>().swap(v[i]);\n\t\tvector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y;\n      while(i0<=ct){\n        v1[i0].push_back(P(z, i));\n        i0+=(i0&(-i0));\n      }\n  }\n  for(int i=1; i<=ct; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    for(int j=0; j<=v1[i].size(); j++){\n      v[i].push_back(0);\n    }\n  }\n}\n     \nvoid update(int k, int i, int a){\n   while(i<=v1[k].size()){\n       v[k][i]=max(v[k][i], a);\n       i+=(i&(-i));\n   }\n}\n    \nvoid update0(int i, int y, int z, int a){\n    int k=y;\n    while(k<=ct){\n        int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n        update(k, i0+1, a);\n        k+=(k&(-k));\n    }\n}\n    \nint find(int k, int i){\n    int s=0;\n    while(i>0){\n        s=max(s, v[k][i]);\n        i-=(i&(-i));\n    }\n    return s;\n}\n    \nint find0(int y, int z){\n    int s=0;\n    int k=y-1;\n    while(k>0){\n        if(!v1[k].empty()){\n            int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n            if(i!=0) s=max(s, find(k, i));\n        }\n        k-=(k&(-k));\n    }\n    return s;\n}\n    \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      scanf(\"%d %d %d %d\", &m, &n, &A, &B);\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      int ind[300000];\n      for(int i=0; i<p.size(); i++) ind[i]=i;\n      sort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n      int pr=-1;\n      ct=0;\n      for(int i=0; i<p.size(); i++){\n          if(pr!=p[ind[i]].second.first){\n              pr=p[ind[i]].second.first;\n              ct++;\n              p[ind[i]].second.first=ct;\n          }else{\n              p[ind[i]].second.first=ct;\n          }\n      }\n      init();\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n      }\n      printf(\"%d\\n\", find0(ct+1, 1000000));\n      p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto check=[&](Int k,P p)->Int{\n      auto it=dp[k].lower_bound(p);\n      if(it!=dp[k].begin()) --it;\n      if(it==dp[k].end()) return 0;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\t//cout<<it->first<<\" *** \"<<it->second<<endl;\t\n\t//cout<<uk->first<<\" *+* \"<<uk->second<<endl;\n\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n    };\n\n    auto print=[&](set<P> sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](set<P> sp){\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nconst int IINF = INT_MAX;\n\nstruct Point3d {\n  int x,y,z;\n  bool operator < ( const Point3d &p ) const {\n    if( z != p.z ) return z < p.z;\n    if( y != p.y ) return y > p.y;\n    return x > p.x;\n  }\n};\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nconst int MAX = 300010;\nPoint3d ps[MAX];\n\n\n\nint m,n,A,B;\nset<ii> dp[MAX];\n\nbool check(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second < v.second ){\n    if( (*it).first < v.first ) return true;\n    --it;\n  }\n  return false;\n}\n\nvoid update(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  --it;\n  if( (*it).second <= v.second ) return;\n  ++it;\n  while( (*it).second >= v.second ) dp[index].erase(it++);\n  dp[index].insert(v);\n}\n\nint LIS2D(vector<ii> &vec) {\n  rep(i,(int)vec.size()+1) {\n    dp[i].clear();\n    dp[i].insert(ii(-1,IINF));\n    dp[i].insert(ii(IINF,-1));\n  }\n  dp[0].insert(ii(-1,-1));\n  int maxi = 0;\n  rep(i,(int)vec.size()){\n    int low = 0, hig = i+1;\n    while( hig - low ) {\n      int mid = ( low + hig ) / 2;\n      if( check(mid,vec[i]) ) low = mid + 1;\n      else                    hig = mid;\n    }\n    maxi = max(maxi,low);\n    update(low,vec[i]);\n  }\n  return maxi + 1;\n}\n\nvoid compute(){\n\n  sort(ps,ps+m+n);\n  vector<ii> vec;\n  rep(i,n+m) vec.push_back(ii(ps[i].y,ps[i].x));\n  \n  printf(\"%d\\n\",LIS2D(vec));\n\n}\n\nint main(){\n  while( scanf(\"%d %d %d %d\",&m,&n,&A,&B), m|n|A|B ){\n    a = A, b = B;\n    rep(i,m) scanf(\"%d %d %d\",&ps[i].x,&ps[i].y,&ps[i].z);\n    rep(i,n) {\n      ps[m+i].x = r();\n      ps[m+i].y = r();\n      ps[m+i].z = r();\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<map>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int,greater<int> > mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int,greater<int> >::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it==mp.end()){\n\t\t\tit=mp.insert(it,make_pair(x,v));\n\t\t}else if(it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\t\t\t\n\t\t}else{\n\t\t\tif(v<=it->second)return;\n\t\t\tit=mp.insert(it,make_pair(x,v));\n\t\t}\n\t\ts=e=it;\n\t\twhile(s!=mp.begin()&&s->second<=v)\n\t\t\tit=s--;\n\t\tif(s->second>v)s=it;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int,greater<int> >::const_iterator it;\n\t\tit=mp.upper_bound(xe);\n\t\tif(it==mp.end())return nil;\n\t\treturn it->second;\n\t}\n};\n\n\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<SparseRMQ*> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1,(SparseRMQ*)NULL){}\n\t~Dynamic2DRMQ_BIT(){\n\t\tfor(int i=0;i<(int)bit.size();i++)\n\t\t\tif(bit[i])delete bit[i];\n\t}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tif(!bit[x])bit[x]=new SparseRMQ();\n\t\t\tbit[x]->insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ye)const{//[0,xe)*[0,ye)\n\t\tint res=nil;\n\t\twhile(0<xe){\n\t\t\tif(bit[xe])res=func(res,bit[xe]->max(ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(2000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 28;\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\ninline bool shouldInsert(set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return true;\n    } else {\n        upper--;\n        return upper->second > v.second;\n    }\n}\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, -INF});\n    for (; lower != st.end() and lower->second >= v.second; lower++) {\n        st.erase(lower);\n    }\n    st.insert(v);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N, A, B;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto gen = [&]() {\n            static int a = A;\n            static int b = B;\n            constexpr int C = ~(1 << 31);\n            constexpr int M = (1 << 16) - 1;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            return (C & ((a << 16) + b)) % 1000000;\n        };\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            if (shouldInsert(tail[sup], p[i].second)) {\n                insertAndErase(tail[sup], p[i].second);\n            }\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    C = ~(1<<31);\n    M = (1<<16)-1;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<20);\n    dp[0].insert(make_tuple(-1,-1));\n    auto vitr = begin(v), veitr = begin(v);\n    while(veitr != end(v)) {\n      vector<tuple<int,int,int>> add;\n      vector<tuple<int,int,int>> er;\n      while(veitr != end(v)\n          && get<0>(*veitr) == get<0>(*vitr)) ++veitr;\n      for(; vitr != veitr; ++vitr) {\n        int y,z;\n        tie(ignore,y,z) = *vitr;\n        int k=1<<19;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,z));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<0>(*itr) <= y && get<1>(*itr) <= z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          int py,pz;\n          tie(py, pz) = *prev(itr);\n          if (py >= y || pz <= z) continue;\n        }\n        while(itr != end(dp[j])\n            && (get<0>(*itr) <= y || get<1>(*itr) >= z)) {\n          er.emplace_back(j,get<0>(*itr),get<1>(*itr));\n          ++itr;\n        }\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(add),end(add));\n      add.erase(unique(begin(add),end(add)),end(add));\n      auto itr = begin(add), eitr = begin(add);\n      while(eitr != end(add)) {\n        while(eitr != end(add) &&\n            get<0>(*eitr) == get<0>(*itr)) ++eitr;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*itr);\n        for(; itr != eitr; ++itr) {\n          int y,z;\n          tie(ignore,y,z) = *itr;\n          //cout<<j<<' '<<y<<' '<<z<<endl;\n          if (tp.empty() || (get<0>(tp.back()) < y && get<1>(tp.back()) > z)) {\n            tp.emplace_back(y,z);\n          }\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n      sort(begin(er),end(er));\n      er.erase(unique(begin(er),end(er)),end(er));\n      for (auto s:er) {\n        int j,y,z;\n        tie(j,y,z) = s;\n        dp[j].erase(make_tuple(y,z));\n      }\n    }\n    int maxl = 0;\n    REP(i,1<<20) {\n      if(!dp[i].empty()) {\n        maxl = i;\n      }\n    }\n    cout<<maxl<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n\nconst int inf = (int)1e8;\n\n\nstruct plane {\n\n\tset<pair<int, int> > xs, ys;\n\n\tvoid init()\n\t{\n\t\txs.insert({-inf, +inf});\n\t\tys.insert({+inf, -inf});\n\n\t\txs.insert({+inf, -inf});\n\t\tys.insert({-inf, +inf});\n\t}\n\n\tvoid print_all()\n\t{\n\t\tprintf(\"pt:\");\n\t\tfor(auto pt : xs)\n\t\t\tprintf(\" (%d, %d)\", pt.first, pt.second);\n\t\tprintf(\"\\n\");\n\t}\n\n\tvoid add_point(int x, int y)\n\t{\n\t\t// assert is_conflicted(x, y) == false;\n\n\t\tauto l_pt1 = xs.lower_bound({x, y});\n\t\tauto r_pt2 = ys.lower_bound({y, x});\n\t\tauto r_pt1 = xs.lower_bound({r_pt2->second, r_pt2->first});\n\t\tauto l_pt2 = ys.lower_bound({l_pt1->second, l_pt1->first});\n\t\tbool can_put = false;\n\t\tbool can_del = false;\n\n\t\tif(*l_pt1 <= *r_pt1) {\n\t\t\tcan_put = true;\n\t\t\tcan_del = true;\n\t\t} else {\n\t\t\tauto r_next_pt1 = r_pt1;\n\t\t\t++r_next_pt1;\n\t\t\tif(l_pt1 == r_next_pt1 && x < l_pt1->first && y < r_pt1->second)\n\t\t\t\tcan_put = true;\n\t\t}\n\n\t\tif(can_del) {\n\t\t\txs.erase(l_pt1, ++r_pt1);\n\t\t\tys.erase(r_pt2, ++l_pt2);\n\t\t}\n\n\t\tif(can_put) {\n\t\t\txs.insert({x, y});\n\t\t\tys.insert({y, x});\n\t\t}\n\t}\n\n\tbool is_conflicted(int x, int y)\n\t{\n\t\tauto r_next = xs.lower_bound({x, -inf});\n\t\tauto r = --r_next;\n\t\treturn r->second < y;\n\t}\n\n\tint size()\n\t{\n\t\t// assert xs.size() == ys.size();\n\t\treturn xs.size();\n\t}\n};\n\nstruct point3 {\n\tint x, y, z;\n\tbool operator<(const point3 &rhs) const\n\t{\n\t\tif(x != rhs.x)\n\t\t\treturn x < rhs.x;\n\t\tif(y != rhs.y)\n\t\t\treturn y > rhs.y;\n\t\treturn z > rhs.z;\n\t}\n};\n\nint generate_rand(int A, int B) {\n\tstatic int a = A, b = B;\n\tconst int C = ~(1<<31), M = (1<<16)-1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tint m, n, a, b;\n\t\tvector<point3> pts;\n\t\tvector<plane> box;\n\n\t\tscanf(\"%d%d%d%d\", &m, &n, &a, &b);\n\t\tif(n + m == 0)\n\t\t\tbreak;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tpts.push_back({x, y, z});\n\t\t}\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint x = generate_rand(a, b);\n\t\t\tint y = generate_rand(a, b);\n\t\t\tint z = generate_rand(a, b);\n\t\t\tpts.push_back({x, y, z});\n\t\t}\n\t\tsort(pts.begin(), pts.end());\n\n\t\tbox.push_back(plane());\n\t\tbox[0].init();\n\t\tbox[0].add_point(-1, -1);\n\n\t\tfor(auto pt : pts) {\n\n\t\t\t//printf(\"[%d %d %d]\\n\", pt.x, pt.y, pt.z);\n\n\t\t\tif(box[box.size() - 1].is_conflicted(pt.y, pt.z)) {\n\t\t\t\tbox.push_back(plane());\n\t\t\t\tbox[box.size() - 1].init();\n\t\t\t\tbox[box.size() - 1].add_point(pt.y, pt.z);\n\t\t\t\t//printf(\"added: %d(new)\\n\", box.size() - 1);\n\t\t\t\t//box[box.size() - 1].print_all();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint lb = 0, ub = box.size() - 1;\n\n\t\t\twhile(ub - lb > 1) {\n\n\t\t\t\tint mid = (lb + ub) / 2;\n\n\t\t\t\t//printf(\"check: %d\\n\", mid);\n\t\t\t\t//box[mid].print_all();\n\n\t\t\t\tif(box[mid].is_conflicted(pt.y, pt.z))\n\t\t\t\t\tlb = mid;\n\t\t\t\telse\n\t\t\t\t\tub = mid;\n\t\t\t}\n\n\t\t\tbox[ub].add_point(pt.y, pt.z);\n\t\t\t//printf(\"added: %d\\n\", ub);\n\t\t\t//box[ub].print_all();\n\t\t}\n\n\t\tint ans = box.size() - 1;\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nbool check(int y, int z, const map<int, int> &contour) {\n  const auto it = contour.upper_bound(y);\n  return it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  int prev_x = x(points.front());\n  vector<tuple<int, int, int>> buf;\n  vector<map<int, int>> maps{{{1, -1}}};\n  buf.reserve(points.size());\n  maps.reserve(points.size());\n\n  for(const auto &p : points) {\n    const int x = x(p);\n    const int y = -y(p);\n    const int z = z(p);\n\n    if(prev_x != x) {\n      maps.resize(max_count + 1);\n      prev_x = x;\n      for(const auto &e : buf) {\n\tint k, ty, tz;\n\ttie(k, ty, tz) = e;\n\n\tauto &target = maps[k];\n\tauto it = target.lower_bound(ty);\n\n\tif(it == target.end() || it->second > tz) {\n\t  target[ty] = tz;\n\t  it = target.find(ty);\n\n\t  while(it != target.begin()) {\n\t    --it;\n\t    if(tz > it->second) break;\n\t    it = target.erase(it);\n\t  }\n\t}\n      }\n      buf.clear();\n    }\n\n    int low = 0;\n    int high = maps.size();\n\n    while(low + 1 < high) {\n      const int mid = (low + high) / 2;\n      if(check(y, z, maps[mid])) {\n\tlow = mid;\n      }\n      else {\n\thigh = mid;\n      }\n    }\n\n    if(low == max_count) ++max_count;\n    buf.emplace_back(high, y, z);\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nconst int IINF = INT_MAX;\n\nstruct Point3d {\n  int x,y,z;\n  bool operator < ( const Point3d &p ) const {\n    if( z != p.z ) return z < p.z;\n    if( y != p.y ) return y > p.y;\n    return x > p.x;\n  }\n};\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\n\nconst int MAX = 300010;\nint m,n,A,B;\nPoint3d ps[MAX];\nset<ii> dp[MAX];\n\nbool check(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second < v.second ){\n    if( (*it).first < v.first ) return true;\n    --it;\n  }\n  return false;\n}\n\nvoid update(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  --it;\n  if( (*it).second <= v.second ) return;\n  ++it;\n  while( (*it).second >= v.second ){\n    dp[index].erase(it++);\n  }\n  dp[index].insert(v);\n}\n\nvoid compute(){\n  rep(i,m+n+1) {\n    dp[i].clear();\n    dp[i].insert(ii(-1,IINF));\n    dp[i].insert(ii(IINF,-1));\n  }\n  dp[0].insert(ii(-1,-1));\n\n  sort(ps,ps+m+n);\n  vector<ii> vec;\n  rep(i,n+m) vec.push_back(ii(ps[i].y,ps[i].x));\n\n  //rep(i,n+m) cout << ps[i].x << \",\" << ps[i].y << \",\" << ps[i].z << endl;\n\n  int maxi = 0;\n  rep(i,n+m){\n    int low = 0, hig = n+m;\n    while( hig - low ) {\n      int mid = ( low + hig ) / 2;\n      if( check(mid,vec[i]) ) low = mid + 1;\n      else                    hig = mid;\n    }\n    maxi = max(maxi,low);\n    update(low,vec[i]);\n  }\n  printf(\"%d\\n\",maxi+1);\n}\n\nint main(){\n  while( scanf(\"%d %d %d %d\",&m,&n,&A,&B), m|n|A|B ){\n    a = A, b = B;\n    rep(i,m) scanf(\"%d %d %d\",&ps[i].x,&ps[i].y,&ps[i].z);\n    rep(i,n) {\n      ps[m+i].x = r();\n      ps[m+i].y = r();\n      ps[m+i].z = r();\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint a,b,c=~(1<<31),M=(1<<16)-1;\n\nint r(){\n    a=36969*(a&M)+(a>>16);\n    b=18000*(b&M)+(a>>16);\n    return (c&((a<<16)+b))%1000000;\n}\n\nset<pair<int,int>> st[303030];\nint main(){\n    int m,n;\n    while(cin>>m>>n>>a>>b,m+n!=0){\n        int l=m+n;\n        int x[l],y[l],z[l];\n        rep(i,m)cin>>x[i]>>y[i]>>z[i];\n        rep(i,n){\n            x[i+m]=r();\n            y[i+m]=r();\n            z[i+m]=r();\n        }\n        vector<int> ord(l);\n        rep(i,l)ord[i]=i;\n        sort(ord.begin(),ord.end(),[&](int s,int t){return x[s]==x[t] ? y[s]>y[t] : x[s]<x[t];});\n        rep(i,303030){\n            if(st[i].size()==2)continue;\n            st[i].clear();\n            st[i].insert({inf,-inf});\n            st[i].insert({-inf,inf});\n        }\n        int ans=0;\n        for(auto i:ord){\n            int left=0,right=ans+1;\n            while(right-left>1){\n                int mid=(left+right)/2;\n                auto itr=--st[mid].lower_bound({y[i],-1});\n                if(itr->second<z[i])left=mid;\n                else right=mid;\n            }\n            int ret=left+1;\n            ans=max(ret,ans);\n            auto itr=--st[ret].lower_bound({y[i],inf});\n            if(z[i]>=itr->second)continue;\n            if(itr->first<y[i])itr++;\n            while(itr->second>=z[i])itr=st[ret].erase(itr);\n            st[ret].insert({y[i],z[i]});\n        }\n        cout<<ans<<endl;\n    } \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Generator{\n    int a, b, C, M;\n    Generator(int A, int B){\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    }\n    int generate() {\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nconst int INF = 100000000;\ntypedef pair<int, int> Point;\n\nvoid query(int x, int y, set<Point>& s, map<Point, int>& score){\n    //printf(\"(%d, %d)\\n\", x, y);\n    const Point np(x, y);\n    auto itr = s.lower_bound(Point(x + 1, -INF));\n    Point R = *itr;\n    if(R.second >= y){\n        vector<Point> removes;\n        while(itr->second >= y){\n            removes.push_back(*itr);\n            itr++;\n        }\n        int maximum = 0;\n        for(Point p : removes){\n            maximum = max(maximum, score[p]);\n            s.erase(p);\n            score.erase(p);\n        }\n        score[np] = maximum;\n        s.insert(np);\n    }else{\n        vector<Point> removes;\n        itr--;\n        while(itr->second < y){\n            removes.push_back(*itr);\n            itr--;\n        }\n        Point L = *itr;\n        if(x > L.first && y > R.second){\n            int maximum = 0;\n            for(Point p : removes){\n                maximum = max(maximum, score[p]);\n                s.erase(p);\n                score.erase(p);\n            }\n            score[np] = maximum + 1;\n            s.insert(np);\n        }\n    }\n    /*\n    for(auto p : s){\n        printf(\"(%d, %d) \", p.first, p.second);\n    }\n    cout << endl;\n    for(auto mp : score){\n        Point p = mp.first;\n        printf(\"(%d, %d -> %d) \", p.first, p.second, mp.second);\n    }\n    cout << endl;\n    */\n}\n\nint main(){\n    int M, N, A, B;\n    const int MAX = 1000000;\n    while(cin >> M >> N >> A >> B && (M + N) != 0){\n        vector<vector<Point>> rect(MAX);\n        for(int i = 0; i < M; i++){\n            int x;\n            Point p;\n            cin >> x >> p.first >> p.second;\n            rect[x].push_back(p);\n        }\n        Generator gen(A, B);\n        for(int i = 0; i < N; i++){\n            Point p;\n            int x = gen.generate();\n            p.first = gen.generate();\n            p.second = gen.generate();\n            rect[x].push_back(p);\n        }\n\n        set<Point> s;\n        map<Point, int> score;\n        s.insert(Point(INF, -1));\n        s.insert(Point(-1, INF));\n        for(Point p : s) score[p] = 0;\n        for(vector<Point> points : rect){\n            sort(points.begin(), points.end(), greater<Point>());\n            for(Point p : points){\n                query(p.first, p.second, s, score);\n            }\n        }\n        int answer = 0;\n        for(auto mp : score){\n            answer = max(answer, mp.second);\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\ntypedef long long LL;\n#define MAXN 300010\nint A, B, C = ~(1<<31), M = (1<<16)-1;\nint myRand() {\n  A = 36969 * (A & M) + (A >> 16);\n  B = 18000 * (B & M) + (B >> 16);\n  return (C & ((A << 16) + B)) % 1000000;\n}\nint N, zn, z[MAXN], f[MAXN], max[MAXN];\nstruct V {\n\tint x, y, z;\n\tbool operator < (const V &t) const {\n\t\tif(x != t.x) {\n\t\t\treturn x < t.x;\n\t\t}\n\t\tif(y != t.y) {\n\t\t\treturn y > t.y;\n\t\t}\n\t\treturn z > t.z;\n\t}\n}v[MAXN];\nstruct T {\n\tint id, x, y, z;\n\tbool operator < (const T &t) const {\n\t\tif(y != t.y) {\n\t\t\treturn y < t.y;\n\t\t}\n\t\tif(x != t.x) {\n\t\t\treturn x > t.x;\n\t\t}\n\t\treturn z > t.z;\n\t}\n}t[MAXN];\nint query(int x) {\n\tint ans = 0;\n\tfor(int i = x; i > 0; i -= i & -i) {\n\t\tans = std::max(ans, max[i]);\n\t}\n\treturn ans;\n}\nvoid update(int x, int v) {\n\tfor(int i = x; i <= zn; i += i & -i) {\n\t\tmax[i] = std::max(max[i], v);\n\t}\n}\nvoid clear(int x) {\n\tfor(int i = x; i <= zn; i += i & -i) {\n\t\tmax[i] = 0;\n\t}\n}\nvoid cdq(int x, int y) {\n\tif(x == y) {\n\t\treturn ;\n\t}\n\tint mid = (x + y) >> 1;\n\tcdq(x, mid);\n\tfor(int i = x; i <= y; i ++) {\n\t\tt[i].id = i;\n\t\tt[i].x = v[i].x, t[i].y = v[i].y, t[i].z = v[i].z;\n\t}\n\tstd::sort(t + x, t + y + 1);\n\tfor(int i = x; i <= y; i ++) {\n\t\tif(t[i].id <= mid) {\n\t\t\tupdate(t[i].z, f[t[i].id]);\n\t\t} else {\n\t\t\tf[t[i].id] = std::max(f[t[i].id], query(t[i].z - 1) + 1);\n\t\t}\n\t}\n\tfor(int i = x; i <= y; i ++) {\n\t\tif(t[i].id <= mid) {\n\t\t\tclear(t[i].z);\n\t\t}\n\t}\n\tcdq(mid + 1, y);\n}\nint main() {\n\t//freopen(\"test.in\", \"rb\", stdin);\n\tint m;\n\twhile(scanf(\"%d%d%d%d\", &N, &m, &A, &B), N + m > 0) {\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tscanf(\"%d%d%d\", &v[i].x, &v[i].y, &v[i].z);\n\t\t}\n\t\tfor(int i = 0; i < m; i ++) {\n\t\t\tv[N].x = myRand();\n\t\t\tv[N].y = myRand();\n\t\t\tv[N].z = myRand();\n\t\t\t++ N;\n\t\t}\n\t\tstd::sort(v, v + N);\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tz[i] = v[i].z;\n\t\t}\n\t\tstd::sort(z, z + N);\n\t\tzn = std::unique(z, z + N) - z;\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tv[i].z = std::lower_bound(z, z + zn, v[i].z) - z + 1;\n\t\t}\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tf[i] = 1;\n\t\t}\n\t\tcdq(0, N - 1);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tans = std::max(ans, f[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    C = ~(1<<31);\n    M = (1<<16)-1;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<20);\n    dp[0].insert(make_tuple(-1,-1));\n    auto vitr = begin(v), veitr = begin(v);\n    while(veitr != end(v)) {\n      vector<tuple<int,int,int>> add;\n      vector<tuple<int,int,int>> er;\n      while(veitr != end(v)\n          && get<0>(*veitr) == get<0>(*vitr)) ++veitr;\n      for(; vitr != veitr; ++vitr) {\n        int y,z;\n        tie(ignore,y,z) = *vitr;\n        int k=1<<19;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          int py,pz;\n          tie(py, pz) = *prev(itr);\n          if (py == y || pz == z) continue;\n        }\n        while(itr != end(dp[j])\n            && (get<0>(*itr) == y || get<1>(*itr) >= z)) {\n          er.emplace_back(j,get<0>(*itr),get<1>(*itr));\n          ++itr;\n        }\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(er),end(er));\n      er.erase(unique(begin(er),end(er)),end(er));\n      for (auto s:er) {\n        int j,y,z;\n        tie(j,y,z) = s;\n        dp[j].erase(make_tuple(y,z));\n      }\n      sort(begin(add),end(add));\n      add.erase(unique(begin(add),end(add)),end(add));\n      auto itr = begin(add), eitr = begin(add);\n      while(eitr != end(add)) {\n        while(eitr != end(add) &&\n            get<0>(*eitr) == get<0>(*itr)) ++eitr;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*itr);\n        for(; itr != eitr; ++itr) {\n          int y,z;\n          tie(ignore,y,z) = *itr;\n          //cout<<j<<' '<<y<<' '<<z<<endl;\n          if (tp.empty() || (get<0>(tp.back()) < y && get<1>(tp.back()) > z)) {\n            tp.emplace_back(y,z);\n          }\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n    }\n    int maxl = 0;\n    REP(i,1<<20) {\n      if(!dp[i].empty()) {\n        maxl = i;\n      }\n    }\n    cout<<maxl<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nclass segtree{\npublic:\n\tint N;\n\tvector<int> dp;\n\tsegtree(){}\n\n\tvoid init(int n_){\n\t\tN=n_;\n\t\tdp.clear();\n\t\tdp.resize(N+1,0);\n\t}\n\tvoid update(int k,int v){\n\t\tk++;\n\t\twhile(k<=N){\n\t\t\tdp[k]=max(dp[k],v);\n\t\t\tk+=k&-k;\n\t\t}\n\t}\n\n\tint query(int b){\n\t\tint res=0;\n\t\twhile(b>0){\n\t\t\tres=max(res,dp[b]);\n\t\t\t//printf(\"%d %d %d\\n\",b,N,res);\n\t\t\tb-=b&-b;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nclass segtree2D{\npublic:\n\tint N;\n\tsegtree seg[1<<20];\n\tvector<int> id[1<<20];\n\tsegtree2D(){}\n\n\tvoid setN(int n_){\n\t\tN=1;\n\t\twhile(N<n_){\n\t\t\tN*=2;\n\t\t}\n\t\tfor(int i=0;i<N*2;i++){\n\t\t\tid[i].clear();\n\t\t}\n\t}\n\n\tvoid init(){\n\t\tfor(int i=0;i<N*2;i++){\n\t\t\tsort(id[i].begin(),id[i].end());\n\t\t\tid[i].erase(unique(id[i].begin(),id[i].end()),id[i].end());\n\t\t\tseg[i].init(id[i].size());\n\t\t}\n\t}\n\n\tvoid insertnode(int y,int z){\n\t\ty+=N-1;\n\t\tid[y].push_back(z);\n\t\twhile(y>0){\n\t\t\ty=(y-1)/2;\n\t\t\tid[y].push_back(z);\n\t\t}\n\t}\t\n\tvoid update(int y,int z,int v){\n\t\ty+=N-1;\n\t\tint pos=lower_bound(id[y].begin(),id[y].end(),z)-id[y].begin();\n\t\tseg[y].update(pos,v);\n\t\twhile(y>0){\n\t\t\ty=(y-1)/2;\n\t\t\tint pos=lower_bound(id[y].begin(),id[y].end(),z)-id[y].begin();\n\t\t\tseg[y].update(pos,v);\n\t\t}\n\t}\n\n\tint query(int b,int b2,int k,int l,int r){\n\t\tif(id[k].size()==0)return 0;\n\t\tif(b<=l)return 0;\n\t\tif(r<=b){\n\t\t\tint v=lower_bound(id[k].begin(),id[k].end(),b2)-id[k].begin();\n\t\t\tif(v==0)return 0;\n\t\t\treturn seg[k].query(v);\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(b,b2,k*2+1,l,mid);\n\t\tint vr=query(b,b2,k*2+2,mid,r);\n\t\treturn max(vl,vr);\n\t}\n\n\tint query(int b,int b2){\n\t\treturn query(b,b2,0,0,N);\n\t}\n};\n\nint m,n,a,b;\nint C=~(1<<31),M=(1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\n\nsegtree2D seg;\nint x[300005],y[300005],z[300005];\n\nvector<P> vec[300005];\n\nvector<int> xi;\nvector<int> yi;\nvector<int> zi;\n\nvoid solve(){\n\tfor(int i=0;i<xi.size();i++){\n\t\tvec[i].clear();\n\t}\n\txi.clear();\n\tyi.clear();\n\tzi.clear();\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&x[i],&y[i],&z[i]);\n\t\txi.push_back(x[i]);\n\t\tyi.push_back(y[i]);\n\t\tzi.push_back(z[i]);\t\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tx[m+i]=r();\n\t\ty[m+i]=r();\n\t\tz[m+i]=r();\n\t\txi.push_back(x[m+i]);\n\t\tyi.push_back(y[m+i]);\n\t\tzi.push_back(z[m+i]);\n\t}\n\tsort(xi.begin(),xi.end());\n\txi.erase(unique(xi.begin(),xi.end()),xi.end());\n\tsort(yi.begin(),yi.end());\n\tyi.erase(unique(yi.begin(),yi.end()),yi.end());\n\tsort(zi.begin(),zi.end());\n\tzi.erase(unique(zi.begin(),zi.end()),zi.end());\n\tseg.setN(yi.size());\n\tfor(int i=0;i<n+m;i++){\n\t\tx[i]=lower_bound(xi.begin(),xi.end(),x[i])-xi.begin();\n\t\ty[i]=lower_bound(yi.begin(),yi.end(),y[i])-yi.begin();\n\t\tz[i]=lower_bound(zi.begin(),zi.end(),z[i])-zi.begin();\n\t\tvec[x[i]].push_back(P(y[i],z[i]));\n\t\tseg.insertnode(y[i],z[i]);\n\t}\n\tseg.init();\n\tfor(int i=0;i<xi.size();i++){\n\t\tsort(vec[i].begin(),vec[i].end());\n\t\treverse(vec[i].begin(),vec[i].end());\n\t\tfor(int j=0;j<vec[i].size();j++){\n\t\t\tP p=vec[i][j];\n\t\t\tint v=seg.query(p.first,p.second);\n\t\t\t//printf(\"%d %d %d %d\\n\",i,p.first,p.second,v);\n\t\t\tseg.update(p.first,p.second,v+1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",seg.query(yi.size(),zi.size()));\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d\",&m,&n,&a,&b);\n\t\t//printf(\"%d %d %d %d\\n\",m,n,a,b);\n\t\tif(m==0 && n==0 && a==0 && b==0)break;\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_x,int arg_y,int arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else if(y != arg.y){\n\t\t\treturn y > arg.y;\n\t\t}else{\n\t\t\treturn z > arg.z;\n\t\t}\n\t}\n\tint x,y,z;\n};\n\nstruct Data{\n\tData(int arg_y,int arg_z){\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn y < arg.y;\n\t}\n\tint y,z;\n};\n\nint m,n,A,B;\nvector<Info> V;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid func(){\n\n\tV.clear();\n\ta = A;\n\tb = B;\n\n\tint tmp_x,tmp_y,tmp_z;\n\n\tfor(int loop = 0; loop < m; loop++){\n\n\t\tscanf(\"%d %d %d\",&tmp_x,&tmp_y,&tmp_z);\n\t\tV.push_back(Info(tmp_x,tmp_y,tmp_z));\n\t}\n\n\tfor(int loop = 0; loop < n; loop++){\n\n\t\ttmp_x = r();\n\t\ttmp_y = r();\n\t\ttmp_z = r();\n\n\t\tV.push_back(Info(tmp_x,tmp_y,tmp_z));\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tvector<set<Data>> SET(m+n);\n\n\tSET[0].insert(Data(V[0].y,V[0].z));\n\n\tint max_group = 0;\n\tint left,right,mid,next_group;\n\n\tfor(int i = 1; i < m+n; i++){\n\n\t\tleft = 0,right = max_group,mid = (left+right)/2;\n\t\tnext_group = 0;\n\n\t\twhile(left <= right){\n\n\t\t\tauto at = SET[mid].lower_bound(Data(V[i].y, V[i].z));\n\n\t\t\tif(at != SET[mid].begin() && (--at)->z < V[i].z){\n\n\t\t\t\tnext_group = mid+1;\n\t\t\t\tleft = mid+1;\n\n\t\t\t}else{\n\n\t\t\t\tright = mid-1;\n\t\t\t}\n\t\t\tmid = (left+right)/2;\n\t\t}\n\n\t\tif(max_group < next_group){\n\n\t\t\tmax_group = next_group;\n\t\t\tSET[next_group].insert(Data(V[i].y,V[i].z));\n\n\t\t}else{\n\n\t\t\tauto at = SET[next_group].lower_bound(Data(V[i].y, V[i].z));\n\t\t\twhile (at != SET[next_group].end() && at->z >= V[i].z){\n\t\t\t\tat = SET[next_group].erase(at);\n\t\t\t}\n\n\t\t\tif(SET[next_group].size() == 0){\n\n\t\t\t\tSET[next_group].insert(Data(V[i].y,V[i].z));\n\n\t\t\t}else{\n\n\t\t\t\tat = SET[next_group].lower_bound(Data(V[i].y, V[i].z));\n\t\t\t\tif(at == SET[next_group].begin() || (--at)->z != V[i].z){\n\t\t\t\t\tSET[next_group].insert(Data(V[i].y,V[i].z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_group+1);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d\",&m,&n,&A,&B);\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define fi first\n#define se second\n\nconst int INF = 1 << 28;\n\ntypedef pair<int, int> pr;\ntypedef tuple<int, int, int> tp;\n\nint a_, b_, C_ = ~(1<<31), M_ = (1<<16)-1;\nint r_() {\n  a_ = 36969 * (a_ & M_) + (a_ >> 16);\n  b_ = 18000 * (b_ & M_) + (b_ >> 16);\n  return (C_ & ((a_ << 16) + b_)) % 1000000;\n}\n\nvector<tp> ps;\n\nint solve()\n{\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\tsort(begin(ps), end(ps));\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\t\n\tvector<set<pr>> sts(ps.size() + 10);\n\tfor (auto &st : sts){\n\t\tst.insert(pr(-INF, INF));\n\t\tst.insert(pr(INF, -INF));\n\t}\n\t\n\tint res = 0;\n\trep(i, ps.size()){\n\t\tint x, y, z;\n\t\ttie(x, y, z) = ps[i];\n\t\tint l = 0, r = ps.size();\n\t\twhile (l + 1 < r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tauto it = --sts[m].lower_bound(pr(y, -INF));\n\t\t\tif (it->se < z) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\tif (z <= (--sts[r].lower_bound(pr(y, z)))->se){\n\t\t\twhile (true){\n\t\t\t\tauto it = sts[r].lower_bound(pr(y, z));\n\t\t\t\tif (it->se < z) break;\n\t\t\t\tsts[r].erase(it);\n\t\t\t}\n\t\t\tsts[r].insert(pr(y, z));\n\t\t}\n\t\tres = max(res, r);\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n >> a_ >> b_, m + n){\n\t\tps.clear();\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\trep(i, n){\n\t\t\tint x = r_();\n\t\t\tint y = r_();\n\t\t\tint z = r_();\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nvector<P> v1[300001];\nvector<int> v[300001];\nvector<Pint> p;\nint ct;\nvoid init(){\n\tfor(int i=1; i<=ct; i++){\n\t\tv[i].clear(); v1[i].clear();\n\t\tvector<int>().swap(v[i]);\n\t\tvector<P>().swap(v1[i]);\n\t}\n\tfor(int i=0; i<p.size(); i++){\n\t\tint x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n\t\tint i0=y+1;\n\t\twhile(i0<=ct){\n\t\t\tv1[i0].push_back(P(z, i));\n\t\t\ti0+=(i0&(-i0));\n\t\t}\n\t}\n\tfor(int i=1; i<=ct; i++){\n\t\tif(v1[i].empty()) continue;\n\t\tsort(v1[i].begin(), v1[i].end());\n\t\tfor(int j=0; j<=v1[i].size(); j++){\n\t\t\tv[i].push_back(0);\n\t\t}\n\t}\n}\n    \nvoid update(int k, int i, int a){\n\twhile(i<=v[k].size()){\n\t\tv[k][i]=max(v[k][i], a);\n\t\ti+=(i&(-i));\n\t}\n}\n   \nvoid update0(int i, int y, int z, int a){\n\tint k=y+1;\n\twhile(k<=ct){\n\t\tint i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n\t\tupdate(k, i0+1, a);\n\t\tk+=(k&(-k));\n\t}\n}\n   \nint find(int k, int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts=max(s, v[k][i]);\n\t\ti-=(i&(-i));\n\t}\n\treturn s;\n}\n   \nint find0(int y, int z){\n\tint s=0;\n\tint k=y;\n\twhile(k>0){\n\t\tif(!v1[k].empty()){\n\t\t\tint i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n\t\t\tif(i!=0) s=max(s, find(k, i));\n\t\t}\n\t\tk-=(k&(-k));\n\t}\n\treturn s;\n}\n   \nint main()\n{\n\twhile(1){\n\t\tint m, n, A, B;\n\t\tscanf(\"%d %d %d %d\", &m, &n, &A, &B);\n\t\tif(m==0 && n==0 && A==0 && B==0) return 0;\n\t\ta=A, b=B, C=~(1<<31), M=(1<<16)-1;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tp.push_back(Pint(x, P(y, z)));\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x=r();\n\t\t\tint y=r();\n\t\t\tint z=r();\n\t\t\tp.push_back(Pint(x, P(y, z)));\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tp.erase(unique(p.begin(), p.end()), p.end());\n\t\tint ind[300000];\n\t\tfor(int i=0; i<p.size(); i++) ind[i]=i;\n\t\tsort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n\t\tint pr=-1;\n\t\tct=-1;\n\t\tfor(int i=0; i<p.size(); i++){\n\t\t\tif(pr!=p[ind[i]].second.first){\n\t\t\t\tpr=p[ind[i]].second.first;\n\t\t\t\tct++;\n\t\t\t\tp[ind[i]].second.first=ct;\n\t\t\t}else{\n\t\t\t\tp[ind[i]].second.first=ct;\n\t\t\t}\n\t\t}\n\t\tinit();\n\t\tvector<PP> mxv;\n\t\tint xp=-1;\n\t\tfor(int i=0; i<p.size(); i++){\n\t\t\tint x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n\t\t\tif(xp==x){\n\t\t\t\tmxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n\t\t\t}else{\n\t\t\t\tfor(auto t:mxv){\n\t\t\t\t\tupdate0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n\t\t\t\t}\n\t\t\t\tmxv.clear();\n\t\t\t\txp=x;\n\t\t\t\tmxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n\t\t\t}\n\t\t}\n\t\tfor(auto t:mxv){\n\t\t\tupdate0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n\t\t}\n\t\tprintf(\"%d\\n\", find0(ct+1, 1000000));\n\t\tp.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n  \nvoid init(int m_){\n    m0=1;\n    while(m0<m_) m0*=2;\n    for(int i=0; i<2*m0-1; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n  \nvoid update(int k, int i, int a){\n    i+=(m[k]-1);\n    v[k][i]=a;\n    while(i>0){\n        i=(i-1)/2;\n        v[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n    }\n}\n \nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n    if(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n \nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n \nint find0(int y, int z, int k, int l, int r){\n    if(r<=0 || y<=l) return 0;\n    if(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n        return find(k, i, 0, 0, m[k]);\n    }else{\n        int vl=find0(y, z, k*2+1, l, (l+r)/2);\n        int vr=find0(y, z, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      scanf(\"%d %d %d %d\", &m, &n, &A, &B);\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n\t  int ind[300000];\n\t  for(int i=0; i<p.size(); i++) ind[i]=i;\n\t  sort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n\t  int ct=-1, pr=-1;\n\t  for(int i=0; i<p.size(); i++){\n\t\t  if(pr!=p[ind[i]].second.first){\n\t\t\t  pr=p[ind[i]].second.first;\n\t\t\t  ct++;\n\t\t\t  p[ind[i]].second.first=ct;\n\t\t  }else{\n\t\t\t  p[ind[i]].second.first=ct;\n\t\t  }\n\t  }\n      init(ct+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      printf(\"%d\\n\", find0(ct+1, 1000000, 0, 0, m0));\n      p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nll a, b, C = ~(1LL<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(10000), x[i] = dc(10000), w[i] = dc(10000);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 3e5 + 5;\nconst int N = 1e6;\n\nint C = ~(1 << 31), M = (1 << 16) - 1;\nint n, m, ans, A, B, timer;\nint c[N << 2], t[N << 2], pos[N + 5];\nstruct node\n{\n    int x, y, z, id, ans, o;\n    void print()\n    {\n        printf(\"%d %d %d %d %d\\n\", x, y, z, id, ans);\n    }\n}a[maxn], tmp[maxn];\n\nint maker()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nbool cmp(node a, node b)\n{\n    if(a.x != b.x)\n        return a.x < b.x;\n    if(a.y != b.y)\n        return a.y < b.y;\n    return a.z < b.z;\n}\n\nbool cmpy(node a, node b)\n{\n    if(a.y != b.y)\n        return a.y < b.y;\n    return a.id > b.id;\n}\n\nvoid update(int x, int val)\n{\n    x++;\n    for(int i = pos[x]; i; i >>= 1)\n    {\n        if(t[i] == timer)\n            c[i] = max(c[i], val);\n        else\n        {\n            t[i] = timer;\n            c[i] = val;\n        }\n    }\n}\n\nint query(int x)\n{\n    x++;\n    int l = 1, r = N, k = 1, res = 0;\n    while(l < r)\n    {\n        int mid = (l + r) >> 1;\n        if(x < mid)\n        {\n            r = mid;\n            k <<= 1;\n        }\n        else\n        {\n\t    if(t[k << 1] == timer)\n\t\tres = max(res, c[k << 1]);\n\t    if(x == mid)\n\t\tbreak;\n            l = mid + 1;\n            k = k << 1 ^ 1;\n        }\n    }\n    return res;\n}\n\nvoid solve(int l, int r)\n{\n    if(l == r)\n        return;\n    int mid = (l + r) >> 1;\n    solve(l, mid);\n    timer++;\n    for(int i = l; i <= r; i++)\n    {\n        tmp[i] = a[i];\n        tmp[i].o = (i > mid);\n    }\n    sort(tmp + l, tmp + r + 1, cmpy);\n    for(int i = l; i <= r; i++)\n    {\n        if(tmp[i].id <= mid)\n        {\n            /*if(l == 1 && r == 3)\n            {\n                //printf(\"%d %d\\n\", tmp[i].z, tmp[i].ans);\n\t\t}*/\n            update(tmp[i].z, tmp[i].ans);\n        }\n        else\n        {\n/*            if(l == 1 && r == 3)\n            {\n                //printf(\"%d %d!\\n\", tmp[i].z - 1, query(tmp[i].z - 1));\n                //    a[tmp[i].id].print();\n\t\t}*/\n            a[tmp[i].id].ans = max(a[tmp[i].id].ans, query(tmp[i].z - 1) + 1);\n        }\n    }\n    solve(mid + 1, r);\n}\n\nvoid build(int k, int l, int r)\n{\n    if(l == r)\n    {\n        pos[l] = k;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(k << 1, l, mid);\n    build(k << 1 ^ 1, mid + 1, r);\n}\n\nint main()\n{\n    build(1, 1, N);\n    while(scanf(\"%d%d%d%d\", &m, &n, &A, &B) && m + n != 0)\n    {\n        ans = 0;\n        for(int i = 1; i <= m; i++)\n        {\n            scanf(\"%d%d%d\", &a[i].x, &a[i].y, &a[i].z);\n            a[i].ans = 1;\n        }\n        for(int i = m + 1; i <= m + n; i++)\n        {\n            a[i].x = maker();\n            a[i].y = maker();\n            a[i].z = maker();\n            a[i].ans = 1;\n        }\n        n = n + m;\n        sort(a + 1, a + 1 + n, cmp);\n        for(int i = 1; i <= n; i++)\n            a[i].id = i;\n        solve(1, n);\n        for(int i = 1; i <= n; i++)\n            ans = max(ans, a[i].ans);\n//        for(int i = 1; i <= n; i++)\n//            a[i].print();\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nstruct RMQ {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\ntemplate <typename M>\nclass node {\n\tusing T = typename M::type;\npublic:\n\tT val;\n\tnode<M> *l, *r;\n\tnode(T val_) : val(val_), l(nullptr), r(nullptr) {}\n};\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tconst ll n;\n\tnode<M> *root;\n\tT value(node<M> *t) {\n\t\treturn t ? t->val : M::id();\n\t}\n\tT sub(ll l, ll r, node<M>* p, ll lb, ll ub) {\n\t\tif (!p || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return p->val;\n\t\tll c = (lb + ub) / 2;\n\t\treturn M::op(sub(l, r, p->l, lb, c), sub(l, r, p->r, c, ub));\n\t}\n\tnode<M> *suc(ll p, node<M>* t, ll lb, ll ub, T val) {\n\t\tif (!t) t = new node<M>(M::id());\n\t\tif (lb + 1 == ub) {\n\t\t\tt->val = val;\n\t\t\treturn t;\n\t\t}\n\t\tll c = (lb + ub) / 2;\n\t\tif (p < c) t->l = suc(p, t->l, lb, c, val);\n\t\telse t->r = suc(p, t->r, c, ub, val);\n\t\tt->val = M::op(value(t->l), value(t->r));\n\t\treturn t;\n\t}\npublic:\n\tdynamic_segment_tree(ll n_) :\n\t\tn(1 << (int)ceil(log2(n_))), root(nullptr) {}\n\tvoid update(ll p, T val) {\n\t\troot = suc(p, root, 0, n, val);\n\t}\n\tT find(ll l, ll r) {\n\t\treturn sub(l, r + 1, root, 0, n);\n\t}\n};\n\ntemplate <typename M>\nclass node2 {\n\tusing T = typename M::type;\npublic:\n\tdynamic_segment_tree<M> val;\n\tnode2<M> *l, *r;\n\tnode2(ll size) : val(size), l(nullptr), r(nullptr) {}\n};\n\ntemplate <typename M>\nclass dynamic_segment_tree2 {\n\tusing T = typename M::type;\n\tconst ll h, w;\n\tnode2<M> *root;\n\tT value(node2<M> *t, ll p) {\n\t\treturn t ? t->val.find(p, p) : M::id();\n\t}\n\tT sub(ll li, ll lj, ll ri, ll rj, node2<M>* p, ll lb, ll ub) {\n\t\tif (!p || ub <= li || ri <= lb) return M::id();\n\t\tif (li <= lb && ub <= ri) return p->val.find(lj, rj);\n\t\tll c = (lb + ub) / 2;\n\t\treturn M::op(sub(li, lj, ri, rj, p->l, lb, c), sub(li, lj, ri, rj, p->r, c, ub));\n\t}\n\tnode2<M> *suc(ll pi, ll pj, node2<M>* t, ll lb, ll ub, T val) {\n\t\tif (!t) t = new node2<M>(w);\n\t\tif (lb + 1 == ub) {\n\t\t\tt->val.update(pj, val);\n\t\t\treturn t;\n\t\t}\n\t\tll c = (lb + ub) / 2;\n\t\tif (pi < c) t->l = suc(pi, pj, t->l, lb, c, val);\n\t\telse t->r = suc(pi, pj, t->r, c, ub, val);\n\t\tt->val.update(pj, M::op(value(t->l, pj), value(t->r, pj)));\n\t\treturn t;\n\t}\npublic:\n\tdynamic_segment_tree2(ll h_, ll w_) :\n\t\th(1ll << (ll)ceil(log2(h_))), w(w_), root(nullptr) {}\n\tvoid update(ll pi, ll pj, T val) {\n\t\troot = suc(pi, pj, root, 0, h, val);\n\t}\n\tT find(ll li, ll lj, ll ri, ll rj) {\n\t\treturn sub(li, lj, ri + 1, rj, root, 0, h);\n\t}\n};\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tdynamic_segment_tree2<RMQ> st(*max_element(y.begin(), y.end()) + 1, *max_element(z.begin(), z.end()) + 1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = st.find(0, 0, y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tst.update(y[i], z[i], val);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n*   Copyright (C) 2015 All rights reserved.\n*   \n*   filename: 1341.cpp\n*   author: doublehh\n*   e-mail: sserdoublehh@foxmail.com\n*   create time: 2015-03-11\n*   last modified: 2015-03-11 23:11:23\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 4e5;\nstruct Point\n{\n\tint x, y, z, f;\n};\nint n, m;\nPoint pt[maxn];\nint c[maxn];\nint z[maxn];\n\nbool cmpxY(const Point &p1, const Point &p2)\n{ return p1.x < p2.x || (p1.x == p2.x && p1.y > p2.y); }\nbool cmpyID(int a, int b)\n{ return pt[a].y < pt[b].y || (pt[a].y == pt[b].y && a > b); }\n\n#define lowbit(p) (p&-p)\nvoid update(int p, int x)\n{\n\tfor (; p <= m; p += lowbit(p))\n\t\tc[p] = max(c[p], x);\n}\nint query(int p)\n{\n\tint ret = 0;\n\tfor (; p; p -= lowbit(p))\n\t\tret = max(ret, c[p]);\n\treturn ret;\n}\nvoid cls(int p)\n{\n\tfor (; p <= m; p += lowbit(p))\n\t\tc[p] = 0;\n}\n\nint id[maxn];\nvoid rec(int l, int r)\n{\n\tif (r - l == 1)\n\t\treturn;\n\n\tint m = (l + r) >> 1;\n\trec(l, m);\n\n\tfor (int i = l; i < r; i++)\n\t\tid[i] = i;\n\tsort(id + l, id + r, cmpyID);\n\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif (id[i] < m) update(pt[id[i]].z, pt[id[i]].f);\n\t\telse pt[id[i]].f = max(pt[id[i]].f, query(pt[id[i]].z - 1) + 1);\n\t}\n\tfor (int i = l; i < m; i++) cls(pt[i].z);\n\n\trec(m, r);\n}\nint a, b, C = ~(1<<31);\nint M = (1<<16) - 1;\nint r()\n{\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid init()\n{\n\tn += m;\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(\"%d %d %d\", &pt[i].x, &pt[i].y, &pt[i].z);\n\tfor (int i = m; i < n; i++)\n\t\tpt[i].x = r(), pt[i].y = r(), pt[i].z = r();\n}\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tpt[i].f = 1;\n\t\tz[i] = pt[i].z;\n\t}\n\n\tsort(pt, pt + n, cmpxY);\n\tsort(z, z + n);\n\tm = unique(z, z + n) - z;\n\tfor (int i = 0; i < n; i++)\n\t\tpt[i].z = lower_bound(z, z + m, pt[i].z) - z + 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tc[i] = 0;\n\n\trec(0, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans = max(ans, pt[i].f);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\twhile (~scanf(\"%d %d %d %d\", &m, &n, &a, &b) && m + n + a + b)\n\t{\n\t\tinit();\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int> mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int>::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it!=mp.end()&&it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\n\t\t\ts=it;\n\t\t\t++s;\n\t\t}else if(it!=mp.begin()){\n\t\t\ts=it;\n\t\t\tif((--it)->second>=v)return;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}else{\n\t\t\ts=it;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}\n\t\te=s;\n\t\twhile(e!=mp.end()&&e->second<=v)++e;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int>::const_iterator it;\n\t\tit=mp.lower_bound(xe);\n\t\tif(it==mp.begin())return nil;\n\t\treturn (--it)->second;\n\t}\n};\n\n\n\n\ntemplate<int XSIZE=1<<20>\nclass Dynamic2DRMQ{\n\tstruct Node{\n\t\tSparseRMQ rmq;\n\t\tNode *left,*right;\n\t\tNode():left(0),right(0){}\n\t\t~Node(){\n\t\t\tdelete left;\n\t\t\tdelete right;\n\t\t}\n\t\tint query(int b,int l,int r,int ye)const{\n\t\t\tif(!this||b<=l)return nil;\n\t\t\tif(r<=b)return rmq.max(ye);\n\t\t\treturn func(left->query(b,l,(l+r)/2,ye),right->query(b,(l+r)/2,r,ye));\n\t\t}\n\t\tvoid insert(int x,int y,int v,int l,int r){\n\t\t\trmq.insert(y,v);\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tif(!left)left=new Node();\n\t\t\t\tleft->insert(x,y,v,l,(l+r)/2);\n\t\t\t}else{\n\t\t\t\tif(!right)right=new Node();\n\t\t\t\tright->insert(x,y,v,(l+r)/2,r);\n\t\t\t}\n\t\t}\n\t};\n\tNode *root;\npublic:\n\tDynamic2DRMQ():root(new Node()){}\n\t~Dynamic2DRMQ(){delete root;}\n\tvoid insert(int x,int y,int v){\n\t\troot->insert(x,y,v,0,XSIZE);\n\t}\n\tint query(int xe,int ye){//[0,xe)*[0,ye)\n\t\treturn root->query(xe,0,XSIZE,ye);\n\t}\n};\n\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ<> rmq2d;\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = _val;\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nint main() {\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  C = ~(1<<31);\n  M = (1<<16)-1;\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<19);\n    dp[0].insert(make_tuple(-1,-1));\n    auto p = equal_range(begin(v),end(v),make_tuple(-1,0,0));\n    REP(i,1000000) {\n      vector<tuple<int,int,int>> add;\n      while(p.second != end(v) && get<0>(*p.second) <= i) ++p.second;\n      for(;p.first != p.second; ++p.first) {\n        int y,z;\n        tie(ignore,y,z) = *p.first;\n        int k=1<<18;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          auto pitr = prev(itr);\n          if (get<0>(*pitr) <= y || get<1>(*pitr) <= z) continue;\n        }\n        while(itr != end(dp[j]) && get<1>(*itr) >= z)\n          itr = dp[j].erase(itr);\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(add),end(add));\n      auto q = equal_range(begin(add),end(add),make_tuple(0,0,0));\n      while(q.second != end(add)) {\n        while(q.second != end(add) &&\n            get<0>(*q.second) == get<0>(*q.first)) ++q.second;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*q.first);\n        for(; q.first != q.second; ++q.first) {\n          int y,z;\n          tie(ignore,y,z) = *q.first;\n          if (tp.empty() || (get<0>(tp.back()) != y && get<1>(tp.back()) > z))\n            tp.emplace_back(y,z);\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n    }\n    REP(i,1<<19) {\n      if(dp[i].empty()) {\n        cout << (i - 1) << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n//typedef pair<P, int> Pint;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<P> p[1000000];\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int x=0; x<m_; x++){\n    for(auto p0:p[x]){\n      int y=p0.first, z=p0.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, x));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, x));\n      }\n    }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int x, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, x))-v1[k].begin();\n  if(i<v1[k].size()){\n    update(k, i, a);\n  }\n  if(r-l>1){\n    update0(x, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(x, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      for(int x=0; x<1000000; x++){\n        p[x].clear();\n        vector<P>().swap(p[x]);\n      }\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p[x].push_back({y, z});\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p[x].push_back({y, z});\n      }\n      for(int x=0; x<1000000; x++){\n        if(p[x].empty()) continue;\n        sort(p[x].begin(), p[x].end());\n        p[x].erase(unique(p[x].begin(), p[x].end()), p[x].end());\n      }\n      init(1000000);\n      for(int x=0; x<1000000; x++){\n        if(p[x].empty()) continue;\n        vector<int> mx;\n        for(auto p0:p[x]){\n          mx.push_back(find0(p0.first, p0.second, 0, 0, m0));\n        }\n        for(int i=0; i<mx.size(); i++){\n          update0(x, p[x][i].first, p[x][i].second, mx[i]+1, 0, 0, m0);\n        }\n      }\n      cout<<find0(1000000, 1000000, 0, 0, m0)<<endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nbool check(int y, int z, const map<int, int> &contour) {\n  const auto it = contour.upper_bound(y);\n  return it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  int prev_x = x(points.front());\n  vector<tuple<int, int, int>> buf;\n  vector<map<int, int>> maps{{{1, -1}}};\n  buf.reserve(points.size());\n  maps.reserve(points.size());\n\n  for(const auto &p : points) {\n    const int x = x(p);\n    const int y = -y(p);\n    const int z = z(p);\n\n    if(prev_x != x) {\n      maps.resize(max_count + 1);\n      prev_x = x;\n      for(const auto &e : buf) {\n\tint k, ty, tz;\n\ttie(k, ty, tz) = e;\n\n\tauto &target = maps[k];\n\tauto it = target.find(ty);\n\n\tif(it == target.end() || it->second > tz) {\n\t  target[ty] = tz;\n\t  it = target.find(ty);\n\n\t  while(it != target.begin()) {\n\t    --it;\n\t    if(tz > it->second) break;\n\t    it = target.erase(it);\n\t  }\n\t}\n      }\n      buf.clear();\n    }\n\n    int low = 0;\n    int high = maps.size();\n\n    while(low + 1 < high) {\n      const int mid = (low + high) / 2;\n      if(check(y, z, maps[mid])) {\n\tlow = mid;\n      }\n      else {\n\thigh = mid;\n      }\n    }\n\n    if(low == max_count) ++max_count;\n    buf.emplace_back(high, y, z);\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\ninline int r(int &a, int &b) {\n\tstatic constexpr int C = ~(1 << 31);\n\tstatic constexpr int M = (1 << 16) - 1;\n\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(int y, int z, const map<int, int> &contour) {\n\tconst auto it = contour.upper_bound(y);\n\treturn it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n\tsort(points.begin(), points.end());\n\n\tint max_count = 0;\n\tint prev_x = x(points.front());\n\tvector<tuple<int, int, int>> buf;\n\tvector<map<int, int>> maps{{{1, -1}}};\n\tbuf.reserve(points.size());\n\tmaps.reserve(points.size());\n\n\tfor(const auto &p : points) {\n\t\tconst int x = x(p);\n\t\tconst int y = -y(p);\n\t\tconst int z = z(p);\n\n\t\tif(prev_x != x) {\n\t\t\tmaps.resize(max_count + 1);\n\t\t\tprev_x = x;\n\n\t\t\tfor(const auto &e : buf) {\n\t\t\t\tint k, ty, tz;\n\t\t\t\ttie(k, ty, tz) = e;\n\n\t\t\t\tauto &target = maps[k];\n\t\t\t\tauto it = target.lower_bound(ty);\n\n\t\t\t\tif(it == target.end() || it->second > tz) {\n\t\t\t\t\ttarget[ty] = tz;\n\t\t\t\t\tit = target.find(ty);\n\n\t\t\t\t\twhile(it != target.begin()) {\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tif(tz > it->second) break;\n\t\t\t\t\t\tit = target.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.clear();\n\t\t}\n\n\t\tint low = 0;\n\t\tint high = maps.size();\n\n\t\twhile(low + 1 < high) {\n\t\t\tconst int mid = (low + high) / 2;\n\t\t\tif(check(y, z, maps[mid])) {\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\tif(low == max_count) ++max_count;\n\t\tbuf.emplace_back(high, y, z);\n\t}\n\n\treturn max_count;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int m, n, a, b; cin >> m >> n >> a >> b && a;) {\n\t\tvector<point> points;\n\t\tpoints.reserve(n + m);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tpoints.emplace_back(x, y, z);\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tconst int x = r(a, b);\n\t\t\tconst int y = r(a, b);\n\t\t\tconst int z = r(a, b);\n\t\t\tpoints.emplace_back(x, y, z);\n\t\t}\n\n\t\tcout << solve(points) << \"\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pint;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<Pint> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<P> p[1000000];\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n\t}\n  for(int x=0; x<1000000; x++){\n    for(auto p0:p[x]){\n      int y=p0.first, z=p0.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(Pint(P(z, x), 0));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(Pint(P(z, x), 0));\n      }\n    }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n    //for(int j=m[i]-2; j>=0; j--){\n    //  v[i][j]=max(v[i][2*j+1], v[i][2*j+2]);\n    //}\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int x, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i=lower_bound(v1[k].begin(), v1[k].end(), Pint(P(z, x), -1))-v1[k].begin();\n  if(i<v1[k].size()){\n    update(k, i, a);\n  }\n  if(r-l>1){\n    update0(x, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(x, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), Pint(P(z, -1), -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      for(int x=0; x<1000000; x++) p[x].clear();\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p[x].push_back({y, z});\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p[x].push_back({y, z});\n      }\n      for(int x=0; x<1000000; x++){\n        if(p[x].empty()) continue;\n        sort(p[x].begin(), p[x].end());\n        p[x].erase(unique(p[x].begin(), p[x].end()), p[x].end());\n      }\n      init(1000000);\n      for(int x=0; x<1000000; x++){\n        if(p[x].empty()) continue;\n        vector<int> mx;\n        for(auto p0:p[x]){\n          mx.push_back(find0(p0.first, p0.second, 0, 0, m0));\n        }\n        for(int i=0; i<mx.size(); i++){\n          update0(x, p[x][i].first, p[x][i].second, mx[i]+1, 0, 0, m0);\n        }\n      }\n      cout<<find0(1000000, 1000000, 0, 0, m0)<<endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nunsigned int a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(10000), x[i] = dc(10000), w[i] = dc(10000);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n#include <list>\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst int M = (1 << 16) - 1;\nconst int C = ~(1 << 31);\nint a, b;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint ord[6][3];\n\nint k;\nbool cmp(const vector<int> &lhs, const vector<int> &rhs){\n\trep(i, 3) if (lhs[ord[k][i]] != rhs[ord[k][i]]) return lhs[ord[k][i]] < rhs[ord[k][i]];\n\treturn false;\n}\n\nconst int N = 3e5 + 10;\nvector<int> G[N];\n\nbool check(const vector<int> &lhs, const vector<int> &rhs){\n\trep(i, 3) if (lhs[i] >= rhs[i]) return false;\n\treturn true;\n}\n\nvoid add_edge(const vector<vector<int>> &v){\n\tint n = v.size();\n\n\tvector<int> mx = v[0];\n\tFOR(i, 1, n){\n\t\tif (!check(mx, v[i])) continue;\n\t\tG[mx[3]].push_back(v[i][3]);\n\t\tmx = v[i];\n\t}\n}\n\nint dp[N];\n\nint dfs(int v){\n\tint res = dp[v];\n\tif (res + 1) return res;\n\n\tres = 1;\n\tfor (auto nxt : G[v]){\n\t\tres = max(res, dfs(nxt) + 1);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint o[] = { 0, 1, 2 };\n\tint idx = 0;\n\tdo{\n\t\trep(j, 3) ord[idx][j] = o[j];\n\t\t++idx;\n\t} while (next_permutation(o, o + 3));\n\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m + n){\n\t\ta = A, b = B;\n\t\tvector<vector<int>> v(m+n);\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tv[i] = {x, y, z, i};\n\t\t}\n\t\trep(i, n){\n\t\t\tint x, y, z;\n\t\t\tx = r(), y = r(), z = r();\n\t\t\tv[i + m] = { x, y, z, i+m};\n\t\t}\n\t\tsort(ALL(v));\n\t\tUNIQUE(v);\n\t\tint n = v.size();\n\n\t\t//rep(i, n){\n\t\t//\tfor (auto e : v[i]) cout << e << ' ';\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\n\t\t//vector<int> G2[N];\n\t\t//rep(i, n) rep(j, n){\n\t\t//\tif (check(v[i], v[j])){\n\t\t//\t\tcout << i << j << endl;\n\t\t//\t\tG2[i].push_back(j);\n\t\t//\t}\n\t\t//}\n\n\t\trep(i, n) G[i].clear();\n\n\t\trep(i, 6){\n\t\t\tk = i;\n\t\t\tsort(ALL(v), cmp);\n\t\t\tadd_edge(v);\n\t\t}\n\n\t\tMEMSET(dp, -1);\n\t\tint ans = 0;\n\t\trep(i, n) ans = max(ans, dfs(i));\n\t\tcout << ans << '\\n';\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\nusing namespace std;\n\n\n\nnamespace _RMQ{\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\nclass SparseSegtree{\n\tstruct Node{\n\t\tint height;\n\t\tint key;\n\t\tint value, rangev;\n\n\t\tNode *left,*right;\n\t\tNode(int k,int v)\n\t\t\t:height(1),key(k),value(v),rangev(v),left(0),right(0){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\n\t\tint query(int a,int b,int l,int r)const{\n\t\t\tif(!this||r<=a||b<=l)return nil;\n\t\t\tif(a<=l&&r<=b)return rangev;\n\t\t\tint res=func(left->query(a,b,l,key),right->query(a,b,key+1,r));\n\t\t\tif(a<=key&&key<b)res=func(res,value);\n\t\t\treturn res;\n\t\t}\n\t\tNode *insert(int k,int v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tif(k < key){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->insert(k,v);\n\t\t\t}else{\n\t\t\t\tvalue=func(value,v);\n\t\t\t\trangev=func(rangev,v);\n\t\t\t}\n\t\t\treturn balance();\n\t\t}\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_value();\n\t\t}\n\t\tvoid update_value(){\n\t\t\trangev=value;\n\t\t\tif(left)rangev=func(rangev,left->rangev);\n\t\t\tif(right)rangev=func(rangev,right->rangev);\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t} *root;\n\n\n\tint max_key;\npublic:\n\tSparseSegtree():root(0),max_key(-1){}\n\t~SparseSegtree(){if(root)delete root;}\n\tvoid insert(int k,int v){\n\t\tmax_key=max(max_key,k);\n\t\troot=root->insert(k,v);\n\t}\n\tint query(int a,int b)const{//[a,b)\n\t\treturn root->query(a,b,0,max_key+1);\n\t}\n\tbool empty()const{\n\t\treturn !root;\n\t}\n};\n\n};\n\n\n\n//insert only\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<_RMQ::SparseSegtree> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1){}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tbit[x].insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ys,int ye)const{//[0,xe)*[ys,ye)\n\t\tint res=_RMQ::nil;\n\t\twhile(0<xe){\n\t\t\tres=_RMQ::func(res,bit[xe].query(ys,ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(1000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,0,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN], used[MAXC], stack[MAXN], ymap[MAXC], Y;\n\nbool cmp_x(const int &a, const int &b) {\n    if (x[a] != x[b]) return x[a] < x[b];\n    else if (y[a] != y[b]) return y[a] < y[b];\n    else return z[a] < z[b];\n}\n\nmap<int, int> bit[MAXC];\n\nint answer(int idx, int th) {\n    map<int, int>::iterator it = bit[idx].lower_bound(th);\n    if (it != bit[idx].begin()) return (--it)->second;\n    else return NO_VALUE;\n}\n\nint query(int idx, int th) {\n    int res = NO_VALUE;\n    while (idx > 0) {\n        res = max(res, answer(idx, th));\n        idx &= idx-1;\n    }\n    return res;\n}\n\nvoid update(int idx, int th, int v) {\n    map<int,int>::iterator it1, it2;\n    while (idx < Y) {\n        it1 = it2 = bit[idx].upper_bound(th);\n        while (it2 != bit[idx].end() && it2->second <= v) it2++;\n        bit[idx].erase(it1, it2);\n    \n        it1 = bit[idx].upper_bound(th);\n        if (it1 == bit[idx].begin() || (--it1)->second < v) bit[idx][th] = v;\n        idx += idx&(-idx);\n    }\n}\n\nint main() {\n    int m, n, i, j, N, t = 1, STACK;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        Y = 0;\n        for (i=0; i<N; i++) {\n            ox[i] = i;\n            if (used[y[i]] < t) { used[y[i]] = t; stack[Y++] = y[i]; }\n        }\n        sort(ox, ox+N, cmp_x);\n        sort(stack, stack+Y);\n        for (i=0; i<Y; i++) ymap[stack[i]] = i+1;\n        for (i=0; i<N; i++) y[i] = ymap[y[i]];\n        t++; Y++;\n\n        for (i=0; i<Y; i++) bit[i].clear();\n\n        i = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[ox[j]] = max(1, query(y[ox[j]]-1, z[ox[j]])+1);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[ox[i]]);\n        } while (i < N);\n        printf(\"%d\\n\", query(Y-1, MAXC));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10, inf = 1e9;\n\nstruct Node {\n    PII e;\n    Node *ls, *rs;\n    int dim, cur, sub;\n} pool[MAXN], *cnt;\n\nstruct Point {\n    int x, y, z;\n    Point() {}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} P[MAXN];\n\nmap<int, int> best[MAXN];\nint dp[MAXN], ret;\n\nint r(int &a, int &b) {\n    static const int C = ~(1u << 31), M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const map<int, int> &mp, int x, int y) {\n    auto it = mp.lower_bound(x);\n    return it != mp.begin() && (-- it)->second < y;\n}\n\nint query(int x, int y) {\n    int left = 0, right = ret;\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(best[mid], x, y)) left = mid;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nvoid update(map<int, int> &mp, int x, int y) {\n    auto it = mp.upper_bound(x);\n    if (it != mp.begin() && (-- it)->second <= y) return;\n    it = mp.lower_bound(x);\n    while (it != mp.end() && it->second >= y) mp.erase(it ++);\n    mp[x] = y;\n}\n\nint main() {\n    int N, M, A, B;\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &P[i].x, &P[i].y, &P[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            P[i].x = r(A, B);\n            P[i].y = r(A, B);\n            P[i].z = r(A, B);\n        }\n        for (int i = 0; i <= N; ++ i) best[i].clear();\n        sort(P, P + N);\n        ret = 0;\n        for (int i = 0, j; i < N;) {\n            for (j = i; j < N && P[i].x == P[j].x; ++ j) dp[j] = query(P[j].y, P[j].z) + 1;\n            for (; i < j; ++ i) {\n                update(best[dp[i]], P[i].y, P[i].z);\n                ret = max(ret, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n#include <utility>\n#include <climits>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i] = {{x, -y, -z}};\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tx = rnd(a, b);\n\t\t\ty = rnd(a, b);\n\t\t\tz = rnd(a, b);\n\t\t\tv[i] = {{x, -y, -z}};\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(size_t i = 1; i < mps.size(); ++i){\n\t\t\tmps[i][INT_MIN] = INT_MAX;\n\t\t}\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 2;\n\t\t\twhile(right - left > 1){\n\t\t\t\tint mid = (left + right) >> 1;\n\t\t\t\tconst auto &mpm = mps[mid - 1];\n\t\t\t\tauto it = mpm.upper_bound(y);\n\t\t\t\tif(it != mpm.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tauto &mpl = mps[left];\n\t\t\tfor(auto it = mpl.upper_bound(y); ; ){\n\t\t\t\t--it;\n\t\t\t\tif(it->second > z){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit = mpl.erase(it);\n\t\t\t}\n\t\t\t\n\t\t\tint &t = mpl.insert(make_pair(y, z)).first->second;\n\t\t\tt = max(t, z);\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.2;\n        // int sqn = 1;\n        // int sqn = 10000;\n        sqn = max(sqn, 1);\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            while (offset + M < n && ps[offset + M - 1][0] == ps[offset + M][0]) { M++; }\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            vector<pair<int, int> > should_removed;\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\nnext:;\n            }\n            if (should_removed.size() > 1) {\n                vector<pair<pair<int, int>, int> > ncalced;\n                auto it = should_removed.begin();\n                REP(i, calced.size()) {\n                    if (it != should_removed.end() && calced[i].first == *it) {\n                        it++;\n                        continue;\n                    }\n                    ncalced.push_back(calced[i]);\n                }\n                swap(calced, ncalced);\n            }\n\n            // calc ans with end block\n            vector<pair<pair<int, int>, int> > tcalced;\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][0] == ps[pos][0]) { break; }\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                tcalced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(tcalced.begin(), tcalced.end());\n            // sort(calced.begin(), calced.end());\n            vector<pair<pair<int, int>, int> > ncalced;\n            auto it = tcalced.begin();\n            REP(i, calced.size()) {\n                if (it != tcalced.end() && *it <= calced[i]) {\n                    ncalced.push_back(*it);\n                    i--;\n                    it++;\n                    continue;\n                }\n                ncalced.push_back(calced[i]);\n            }\n            swap(calced, ncalced);\n            // cout << calced << endl;\n\n            offset += M;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct P3{\n    int x,y,z;\n    bool operator<(const P3& p) const{\n        return x<p.x;\n    }\n\n\tP3(){\n\t}\n\n\tP3(int x,int y,int z):x(x),y(y),z(z){\n\t}\n} p[300005];\nint n,m,A,B;\nint a ,b, C = ~(1<<31), M = (1<<16)-1;\n\nint r(){\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\nint mx[300005];\nint x[300005];\n\nstruct Node{\n\tNode *ch[2];\n\tint r,v,sz,w,mx;\n\tbool operator<(const Node &nd) const{\n\t\treturn r<nd.r;\n\t}\n\tint cmp(int x){\n\t\tif(x==v) return -1;\n\t\treturn x>v;\n\t}\n\tvoid init(int w,int vv){\n\t\tv = vv;\n\t\tthis->w = w;\n\t\tmx = w;\n\t\tsz = 1;\n\t\tch[0] = ch[1] = NULL;\n\t\tr = rand();\n\t}\n} nd[10000005],*mp[300005];\nint ndcnt = 0;\nNode *newNode(int w,int v){\n\tnd[ndcnt].init(w,v);\n\treturn &nd[ndcnt++];\n}\n\nclass Treap{\npublic:\n\tTreap(){\n\t}\n\n\t\n\tvoid push_Up(Node *rt){\n\t\tif(rt==NULL) return;\n\t\trt->sz = 1;\n\t\trt->mx = rt->w;\n\t\tif(rt->ch[0]!=NULL) rt->sz+=rt->ch[0]->sz,rt->mx = max(rt->mx,rt->ch[0]->mx);\n\t\tif(rt->ch[1]!=NULL) rt->sz+=rt->ch[1]->sz,rt->mx = max(rt->mx,rt->ch[1]->mx);\n\t}\n\n\tvoid rotate(Node *&o,int d){\n\t\tNode *k = o->ch[d^1];\n\t\to->ch[d^1] = k->ch[d];\n\t\tk->ch[d] = o;\n\t\tpush_Up(o);\n\t\tpush_Up(k);\n\t\to = k;\n\t}\n\n\tvoid insert(Node *&o,int w,int x){\n\t\tif(o==NULL) o = newNode(w,x);\n\t\telse{\n\t\t\tint d = (x<o->v?0:1);\n\t\t\tinsert(o->ch[d],w,x);\n\t\t\tif(o->ch[d]>o) rotate(o,d^1);\n\t\t}\n\t\tpush_Up(o);\n\t}\n\n\tint query(Node *o,int val){\n\t\tif(o==NULL) return 0;\n\t\tint ans = 0;\n\t\tif(o->v<val){\n\t\t\tif(o->ch[0]!=NULL) ans = o->ch[0]->mx;\n\t\t\tans = max(ans,o->w);\n\t\t\tans = max(ans,query(o->ch[1],val));\n\t\t}else ans = max(ans,query(o->ch[0],val));\n\t\treturn ans;\n\t}\n} treap;\n\n#define lowbit(u) (u&(-u))\n\nstruct BIT{\n    int n;\n    BIT(int n){\n        this->n = n;\n        for(int i = 1;i<=n;i++) mp[i] = newNode(0,0);\n    }\n    \n    void add(int u,int v,int y){\n        for(int i = u;i<=n;i+=lowbit(i)) treap.insert(mp[i],v,y);\n    }\n    \n    int sum(int u,int y){\n        int ans = 0;\n        for(int i = u;i;i-=lowbit(i)) ans = max(ans,treap.query(mp[i],y));\n        return ans;\n    }\n};\n\nP3 buffer[300005];\n\nvoid getInt(int &x){\n\tx = 0;\n\tchar c = getchar();\n\twhile(c==' '||c=='\\n') c = getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tx = x*10+c-'0';\n\t\tc = getchar();\n\t}\n}\n\nint main()\n{\n\t//freopen(\"data.in\",\"r\",stdin);\n    srand(time(NULL));\n    while(scanf(\"%d %d %d %d\",&n,&m,&A,&B),n+m+A+B){\n\t\ta = A,b = B;\n        for(int i = 0;i<n;i++){\n            scanf(\"%d %d %d\",&p[i].x,&p[i].y,&p[i].z);\n        }\n        for(int i = 0;i<m;i++) p[i+n].x = r();\n        for(int i = 0;i<m;i++) p[i+n].y = r();\n        for(int i = 0;i<m;i++) p[i+n].z = r();\n        n+=m;\n        int cnt = 0;\n        for(int i = 0;i<n;i++) x[cnt++] = p[i].y;\n        sort(x,x+cnt);\n        cnt = unique(x,x+cnt)-x;\n        for(int i = 0;i<n;i++) p[i].y = lower_bound(x,x+cnt,p[i].y)-x+1;\n        sort(p,p+n);\n\t\tndcnt = 0;\n        BIT bit(cnt+1);\n\t\tint tot = 0;\n\t\tint ans = 0;\n        for(int i = 0;i<n;i++){\n\t\t\tint ret = 0;\n\t\t\tret = bit.sum(p[i].y-1,p[i].z)+1;\n\t\t\tans = max(ans,ret);\n\t\t\tbuffer[tot++] = P3(p[i].y,ret,p[i].z);\n\t\t\tif(i<n-1&&p[i].x!=p[i+1].x){\n\t\t\t\tint sz = tot;\n\t\t\t\tfor(int j = 0;j<sz;j++){\n\t\t\t\t\tbit.add(buffer[j].x,buffer[j].y,buffer[j].z);\n\t\t\t\t}\n\t\t\t\ttot = 0;\n\t\t\t}\n        }\n\t\tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\ntypedef tuple<int, int, int> tiii;\n\nstruct Random {\n\tint a, b, C, M;\n\tRandom(int A, int B) : a(A), b(B), C(~(1 << 31)), M((1 << 16) - 1) { }\n\tint operator()(){\n\t\ta = 36969 * (a & M) + (a >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint m, n, A, B;\n\t\tcin >> m >> n >> A >> B;\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0){ break; }\n\t\tn += m;\n\t\tvector<tiii> p(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tRandom random(A, B);\n\t\tfor(int i = m; i < n; ++i){\n\t\t\tconst int x = random();\n\t\t\tconst int y = random();\n\t\t\tconst int z = random();\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tvector< map<int, int> > vm(n + 1);\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < n; ){\n\t\t\tconst int x = get<0>(p[i]);\n\t\t\tvector<tiii> t;\n\t\t\twhile(i < n && get<0>(p[i]) == x){\n\t\t\t\tconst int y = get<1>(p[i]);\n\t\t\t\tconst int z = get<2>(p[i]);\n\t\t\t\tint l = 0, r = n;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tconst int c = l + (r - l) / 2;\n\t\t\t\t\tauto it = vm[c].lower_bound(y);\n\t\t\t\t\tif(it == vm[c].begin()){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else if((--it)->second >= z){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = c + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.emplace_back(l, y, z);\n\t\t\t\tanswer = max(answer, l + 1);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tfor(const auto &e : t){\n\t\t\t\tconst int k = get<0>(e);\n\t\t\t\tconst int y = get<1>(e);\n\t\t\t\tconst int z = get<2>(e);\n\t\t\t\tauto it = vm[k].upper_bound(y);\n\t\t\t\tif(it != vm[k].begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->second <= z){ continue; }\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t\twhile(it != vm[k].end()){\n\t\t\t\t\tif(it->second < z){ break; }\n\t\t\t\t\tvm[k].erase(it++);\n\t\t\t\t}\n\t\t\t\tvm[k].insert(make_pair(y, z));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      \n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      init(mx+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(mx+1, mx+1, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 30;\nint A, B;\ninline int gen()\n{\n    static int a = A;\n    static int b = B;\n    constexpr int C = ~(1 << 31);\n    constexpr int M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\n\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, 0});\n    vector<P> er;\n    for (; lower != st.end() and lower->second >= v.second; lower++) {\n        er.push_back(*lower);\n    }\n    st.insert(v);\n    for (const P& e : er) {\n        st.erase(e);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    update0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(i, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      \n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        mx=max({mx, x, y, z});\n        p.push_back(Pint(x, P(y, z)));\n        \n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      init(mx+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      cout<<find0(mx+1, mx+1, 0, 0, m0)<<endl;\n      p.clear();\n      vector<Pint>().swap(p);\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\nusing namespace std;\n#define INF (1 << 30)\ntypedef pair<int, int> P;\n\n\n\nint C = ~(1<<31), M = (1<<16)-1;\nint m, n, a, b, x, y, z;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\ntemplate <typename T>\nT next(T a){\n\treturn ++a;\n}\n\ntemplate <typename T>\nT before(T a){\n\treturn --a;\n}\n\nvector<P> points[1080000];\nset<P> dp[324000];\n\nint main(){\n\twhile(cin >> m >> n >> a >> b, m | n | a | b){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> x >> y >> z;\n\t\t\tpoints[x].push_back(P(-y, z));\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tx = r();\n\t\t\ty = r();\n\t\t\tz = r();\n\t\t\tpoints[x].push_back(P(-y, z));\n\t\t}\n\t\tn += m;\n\t\tfor(int i = 0;i < 324000;i++){\n\t\t\twhile(!dp[i].empty())dp[i].erase(dp[i].begin());\n\t\t}\n\t\tdp[0].insert(P(-INF, -INF));\n        int res = 0;\n\t\tfor(int i = 0;i < 1080000;i++){\n\t\t\tsort(points[i].begin(), points[i].end());\n\t\t\tfor(int j = 0;j < points[i].size();j++){\n\t\t\t\ty = -points[i][j].first;\n\t\t\t\tz = points[i][j].second;\n\t\t\t\tint bottom = 0, top = 324000;\n\t\t\t\twhile(top - bottom > 1){\n\t\t\t\t\tint mid = (top + bottom) / 2;\n\t\t\t\t\tif(dp[mid].empty()){\n\t\t\t\t\t\ttop = mid;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tset<P>::iterator it = dp[mid].lower_bound(P(y, -INF));\t\t\t\t\t\n\t\t\t\t\tif(it == dp[mid].begin()){\n\t\t\t\t\t\ttop = mid;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tit--;\n\t\t\t\t\tif(it->second < z)bottom = mid;\n\t\t\t\t\telse top = mid;\n\t\t\t\t}\n\t\t\t\tbottom++;\n\t\t\t\tres = max(res, bottom);\n\t\t\t\tdp[bottom].insert(P(y, z));\n\t\t\t\tset<P>::iterator it = dp[bottom].find(P(y, z));\n\n\t\t\t\tif(it != dp[bottom].begin() && before(it)->second <= z){\n\t\t\t\t\tdp[bottom].erase(it);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t\twhile(it != dp[bottom].end() && it->second >= z){\n\t\t\t\t\tdp[bottom].erase(it++);\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\tpoints[i].clear();\n\t\t}\n\t\tcout << res << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nbool check(int y, int z, const map<int, int> &contour) {\n  const auto it = contour.upper_bound(y);\n  return it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  int prev_x = x(points.front());\n  vector<tuple<int, int, int>> buf;\n  vector<map<int, int>> maps{{{1, -1}}};\n  maps.reserve(points.size());\n\n  for(const auto &p : points) {\n    const int x = x(p);\n    const int y = -y(p);\n    const int z = z(p);\n\n    if(prev_x != x) {\n      maps.resize(max_count + 1);\n      prev_x = x;\n      for(const auto &e : buf) {\n\tint k, y, z;\n\ttie(k, y, z) = e;\n\n\tif(!maps[k].count(y)) {\n\t  maps[k].insert({y, z});\n\t}\n\telse {\n\t  chmin(maps[k][y], z);\n\t}\n      }\n      buf.clear();\n    }\n\n    int low = 0;\n    int high = maps.size();\n\n    while(low + 1 < high) {\n      const int mid = (low + high) / 2;\n      if(check(y, z, maps[mid])) {\n\tlow = mid;\n      }\n      else {\n\thigh = mid;\n      }\n    }\n\n    if(low == max_count) ++max_count;\n    buf.emplace_back(high, y, z);\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1000005\ntypedef unordered_map< int ,int > vec;\ntypedef unordered_map< int , vec > mat;\n\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n\nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n\nint x[MAX],y[MAX],z[MAX];\n\n\nint query(vec &t,int x){\n  int res=0;\n  while(x>0){\n    if(t.count(x)>0){\n      res=max(res,t[x]);\n    }\n    x-=(x&-x);\n  }\n  return res;\n}\n\nint query(mat &T,int y,int x){\n  int res=0;\n  while(y>0){\n    if(T.count(y)>0){\n      res=max(res,query(T[y],x));\n    }\n    y-=(y&-y);\n  }\n  return res;\n}\n\nvoid update(vec &t,int x,int value){\n  while(x<MAX){\n    t[x]=max(t[x],value);\n    x+=(x&-x);\n  }\n}\n\nvoid update(mat &T,int y,int x,int value){\n  while(y<MAX){\n    update(T[y],x,value);\n    y+=(y&-y);\n  }\n}\n\n\nvector<int> G[MAX];\nint g[MAX];\n\nint solve(){\n  mat T;\n\n  for(int i=0;i<m+n;i++){\n    x[i]+=2,y[i]+=2,z[i]+=2;\n    G[ z[i] ].push_back(x[i]);\n    G[ z[i] ].push_back(y[i]);\n  }\n  for(int i=0;i<MAX;i++){\n    \n    for(int j=0;j<(int)G[i].size();j+=2){\n      int px=G[i][j];\n      int py=G[i][j+1];\n      g[j]=query(T,px-1,py-1)+1;\n    }\n    for(int j=0;j<(int)G[i].size();j+=2){\n      int px=G[i][j];\n      int py=G[i][j+1];\n      update(T,px,py,g[j]);\n    }\n\n    G[i].clear();\n  }\n  \n  return query(T,MAX-1,MAX-1);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n\n    a=A,b=B;\n    \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n\n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MN 300005\nint A, B, C, M;\nint rand() {\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nstruct data { int x, y, z, k; } d[MN];\nint dyn[MN], Y;\ninline bool cmp(data a, data b) {\n\tif (a.x != b.x) return a.x < b.x;\n\tif (a.y != b.y) return a.y < b.y;\n\treturn a.z < b.z;\n}\nint ym[4*MN], yd[4*MN];\nmap <int, int> r[MN];\nmap<int,int>::iterator it, it2;\nvoid upd(int x, int y, int v) {\n\twhile (x < Y) {\n\t\tit = it2 = r[x].upper_bound(y);\n\t\twhile (it2 != r[x].end() && it2->second <= v) it2++;\n\t\tr[x].erase(it, it2);\n\t\tit = r[x].upper_bound(y);\n\t\tif (it == r[x].begin() || (--it)->second < v) r[x][y] = v;\n\t\tx += x&(-x);\n\t}\n}\nint ret, val;\nint f(int x, int y) {\n\tret = -1;\n\twhile (x > 0) {\n\t\tit = r[x].lower_bound(y);\n\t\tif (it != r[x].begin()) val = (--it)->second;\n\t\telse val = -1;\n\t\tif (ret < val) ret = val;\n\t\tx &= x-1;\n\t}\n\treturn ret;\n}\nint main() {\n\tint i, j;\n\tint m, n, N;\n\twhile (scanf(\"%d%d%d%d\",&m,&n,&A,&B),m||n||A||B) {\n\t\tN = m+n; Y = 0;\n\t\tC = ~(1<<31); M = (1<<16)-1;\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d%d\",&d[i].x,&d[i].y,&d[i].z);\n\t\tfor (i = m; i < m+n; i++) d[i].x = rand(), d[i].y = rand(), d[i].z = rand();\n\t\tym[0] = -1;\n\t\tfor (i = 0; i < N; i++) d[i].k = i, ym[++Y] = d[i].y;\n\t\tsort(d, d+N, cmp);\n\t\tsort(ym+1, ym+Y+1);\n\t\tY = 0;\n\t\tfor (i = 1; i <= N; i++) if (ym[i] != ym[i-1]) yd[ym[i]] = ++Y;\n\t\tfor (i = 0; i < N; i++) d[i].y = yd[d[i].y];\n\t\tY+=2;\n\t\tfor (i = 0; i < Y; i++) r[i].clear();\n\t\ti = 0;\n\t\tdo {\n\t\t\tfor (j = i; j < N && d[i].x == d[j].x; j++) dyn[d[j].k] = max(1, f(d[j].y-1, d[j].z)+1);\n\t\t\tfor (; i < j; i++) upd(d[i].y, d[i].z, dyn[d[i].k]);\n\t\t} while (i < N);\n\t\tprintf(\"%d\\n\",f(Y-1, 3*MN));\n\t\tm = n = A = B = 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <time.h>\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef map<int,int> ::iterator aauto;\n\nint n;\n\nstruct tup{\n\tint x, y, z;\n}a[300005];\n\ntime_t st;\nbool input(){\n\tint pn, m, aa, b;\n\tscanf(\"%d %d %d %d\",&pn,&m,&aa,&b);\n\tif(pn + m == 0) return 0;\n\tfor(int i=1; i<=pn; i++){\n\t\tscanf(\"%d %d %d\",&a[i].x,&a[i].y,&a[i].z);\n\t}\n\tn = pn;\n\tint M = 65535, C = ~(1<<31);\n\twhile(m--){\n\t\tn++;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].x = (C & ((aa << 16) + b)) % 1000000;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].y = (C & ((aa << 16) + b)) % 1000000;\n\t\taa = 36969 * (aa & M) + (aa >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\ta[n].z = (C & ((aa << 16) + b)) % 1000000;\n\t}\n\treturn 1;\n}\n\nvector<int> vy, vz;\n\nstruct idx{\n\tmap<int,int> mp[1050000];\n\tint lim;\n\tvoid init(int n){\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t\tfor(int i=1; i<=lim + n; i++){\n\t\t\tmp[i].clear();\n\t\t}\n\t}\n\tint qr(int x, int p){\n\t\taauto t = mp[x].upper_bound(p);\n\t\tif(t != mp[x].begin()){\n\t\t\treturn (--t)->second;\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid manip(int x, pi t){\n\t\taauto it = mp[x].upper_bound(t.first);\n\t\tif(it != mp[x].begin() && (--it)->second >= t.second){\n\t\t\treturn;\n\t\t}\n\t\tmp[x][t.first] = t.second;\n\t\tit = mp[x].upper_bound(t.first);\n\t\twhile(it != mp[x].end()){\n\t\t\tif(it->second <= t.second){\n\t\t\t\taauto bak = it;\n\t\t\t\tbak++;\n\t\t\t\tmp[x].erase(it);\n\t\t\t\tit = bak;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tvoid add(int x, int v, int w){\n\t\tx += lim;\n\t\tmanip(x, pi(v, w));\n\t\twhile(x > 15){\n\t\t\tx >>= 1;\n\t\t\tmanip(x, pi(v, w));\n\t\t}\n\t}\n\tint q(int s, int e, int x){\n\t\ts += lim;\n\t\te += lim;\n\t\tint ret = 0;\n\t\twhile(s < e && s > 15){\n\t\t\tif(s%2 == 1) ret = max(ret, qr(s++, x));\n\t\t\tif(e%2 == 0) ret = max(ret, qr(e--, x));\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tfor(int i=s; i<=e; i++){\n\t\t\tret = max(ret, qr(i, x));\n\t\t}\n\t\treturn ret;\n\t}\n}idx;\n\nint dp[300005];\n\nbool cmp(const tup &a, const tup &b){\n\tif(a.x != b.x) return a.x < b.x;\n\tif(a.y != b.y) return a.y < b.y;\n\treturn a.z < b.z;\n}\n\nvoid solve(){\n\tsort(a+1,a+n+1,cmp);\n\tvy.clear();\n\tvz.clear();\n\tfor(int i=1; i<=n; i++){\n\t\tvy.push_back(a[i].y);\n\t\tvz.push_back(a[i].z);\n\t}\n\tsort(vy.begin(), vy.end());\n\tsort(vz.begin(), vz.end());\n\tvy.resize(unique(vy.begin(), vy.end()) - vy.begin());\n\tvz.resize(unique(vz.begin(), vz.end()) - vz.begin());\n\tfor(int i=1; i<=n; i++){\n\t\ta[i].y = (int)(lower_bound(vy.begin(), vy.end(), a[i].y) - vy.begin());\n\t\ta[i].z = (int)(lower_bound(vz.begin(), vz.end(), a[i].z) - vz.begin());\n\t}\n\tidx.init(n);\n\tfor(int i=1; i<=n;){\n\t\tint e = i;\n\t\twhile(e <= n && a[e].x == a[i].x) e++;\n\t\tfor(int j=i; j<e; j++){\n\t\t\tdp[j] = idx.q(0, a[j].y - 1, a[j].z - 1)  + 1;\n\t\t}\n\t\tfor(int j=i; j<e; j++){\n\t\t\tidx.add(a[j].y, a[j].z, dp[j]);\n\t\t}\n\t\ti = e;\n\t}\n\tprintf(\"%d\\n\",*max_element(dp+1,dp+n+1));\n}\n\nint main(){\n\twhile(input()){\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint M,N,A,B,C,a,b,mod;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector< set<P> > ss;\nset<P>::iterator it;\nvector<PP> vc;\nint ran(){\n\ta=36969*(a&mod)+(a>>16);\n\tb=18000*(b&mod)+(b>>16);\n\treturn (C&((a<<16)+b))%1000000;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N>>A>>B;\n\t\tif(M+N==0) break;\n\t\tss.clear();\n\t\tvc.clear();\n\t\ta=A,b=B,C=~(1<<31),mod=(1<<16)-1;\n\t\trep(i,M){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tvc.pb(PP(x,P(-y,-z)));\n\t\t}\n\t\trep(i,N){\n\t\t\tint x=ran(),y=ran(),z=ran();\n\t\t\tvc.pb(PP(x,P(-y,-z)));\n\t\t}\n\t\tsort(all(vc));\n\t\tN=M+N;\n\t\trep(i,N) vc[i].sc.fs*=-1,vc[i].sc.sc*=-1;\n\t\tset<P> be;\n\t\tbe.insert(P(-1,-1));\n\t\tss.pb(be);\n\t\tint mx=0;\n\t\trep(i,N){\n\t\t\tint y=vc[i].sc.fs,z=vc[i].sc.sc;\n\t\t\tint ub=mx+1,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tit=ss[m].upper_bound(P(y-1,z-1));\n\t\t\t\tif(it==ss[m].begin()){\n\t\t\t\t\tub=m;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tit--;\n\t\t\t\tif(it->sc<z) lb=m;\n\t\t\t\telse ub=m;\n\t\t\t}\n\t\t\tif(lb==-1) continue;\n\t\t\tint m=lb+1;\n\t\t\tif(m>mx){\n\t\t\t\tset<P> be;\n\t\t\t\tbe.insert(P(y,z));\n\t\t\t\tss.pb(be);\n\t\t\t\tmx++;\n\t\t\t}else{\n\t\t\t\tit=ss[m].lower_bound(P(y,z));\n\t\t\t\twhile(it!=ss[m].end()){\n\t\t\t\t\tif(it->sc<z) break;\n\t\t\t\t\tit=ss[m].erase(it);\n\t\t\t\t}\n\t\t\t\tss[m].insert(P(y,z));\n\t\t\t}\n//\t\t\tprintf(\"i=%d,  y,z=(%d,%d)     mx=%d\\n\",i,y,z,mx);\n//\t\t\tcout<<\"ss[1]\";\n//\t\t\tfor(auto s:ss[1]) cout<<\"(\"<<s.fs<<\",\"<<s.sc<<\") \";\n//\t\t\tputs(\"\");\n\t\t}\n\t\tcout<<mx<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing std::sort;\nusing std::fill;\nusing std::max;\nusing std::unique;\nusing std::lower_bound;\nconst int N = 330010;\nstruct point {\n    int x,y,z;\n    int id;\n    bool operator < (const point& b) const {\n        if(x == b.x) {\n            if(y == b.y) return z > b.z;\n            else return y > b.y;\n        }\n        return x < b.x;\n    }\n    inline void in() {\n        scanf(\"%d%d%d\",&x,&y,&z);\n    }\n}p[N],g[N];\nint num[N];\nint f[N];\ninline int cmpy(point a,point b){\n    return  a.y < b.y;\n}\nstruct BIT{\n    int n;\n    int c[N];\n    inline void init(int n) {\n        this->n = n;\n    }\n    inline void insert(int x, int add) {\n        for(; x <= n; x += x & -x) if(add > c[x]) c[x] = add;\n    }\n    inline int ask(int x) {\n        int ret = 0;\n        for(; x > 0; x -= x & -x) if(c[x] > ret) ret = c[x];\n        return ret;\n    }\n    inline void clear(int x) {\n        for(; x <= n; x += x & -x) c[x] = 0;\n    }\n}ta;\nvoid update(int l1, int r1, int l2, int r2) {\n    sort(g + l1, g + r1 + 1, cmpy);\n    sort(g + l2, g + r2 + 1, cmpy);\n    int pt = l1;\n    for(int i = l2; i <= r2; i++) {\n        while(pt <= r1 && g[pt].y < g[i].y){\n            ta.insert(g[pt].z, f[g[pt].id]);\n            pt++;\n        }\n        int opt=ta.ask(g[i].z - 1);\n        if(opt + 1 > f[g[i].id]) {\n            f[g[i].id] = opt + 1;\n        }\n    }\n    for(int i = l1; i <= r1; i++) ta.clear(g[i].z);\n}\nvoid solve(int l,int r)\n{\n    if(l == r) {    \n        if(1 > f[p[l].id]) f[p[l].id] = 1;\n        return ; \n    }\n    int mid = (l + r) >> 1;\n    solve(l,mid);\n    for(int i = l; i <= r; i++)    g[i] = p[i];\n    if(p[mid].x != p[mid + 1].x) {\n        //蟾ヲ蜿ウ蛹コ髣エ驛ス謖臥?y謗貞コ?蟾ヲ蛹コ髣エ逧з蟾イ扈丈ソ晁ッ∝ー丈コ主承蛹コ髣エ逧з莠?        update(l, mid, mid + 1, r);\n    } else {\n        int leftp = mid;\n        while(leftp >= l && p[leftp].x == p[mid].x) leftp--;\n        int rightp = mid + 1;\n        while(rightp <= r && p[rightp].x == p[mid].x) rightp++;\n        if(leftp < l && rightp > r) { \n        } else if(leftp < l) {\n            update(l, mid, rightp, r);\n        } else if(rightp > r){\n            update(l, leftp, mid + 1, r);\n        } else {\n            update(l, leftp, mid + 1, r);\n            for(int i = l; i <= r; i++) g[i] = p[i];\n            update(leftp + 1, mid, rightp, r);\n        }\n    }\n    solve(mid+1,r);\n}\n\nint M, a, b, C;\nint main()\n{\n    int t,m,nn,A,B;\n    while(scanf(\"%d%d%d%d\",&m,&nn,&A,&B) && (m + nn + A + B))\n    {\n        a = A; b = B;\n        C = ~(1 << 31);\n        M = (1 << 16) - 1;\n        for(int i = 1; i <= m; i++) {\n            p[i].in();\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        for(int i = m + 1; i <= m + nn; i++) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int x = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int y = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int z = (C & ((a << 16) + b)) % 1000000;\n            p[i].x = x;\n            p[i].y = y;\n            p[i].z = z;\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        int n = m + nn;\n        sort(num+1,num+n+1);\n        int tot = unique(num+1,num+n+1) - num - 1; \n        for(int i = 1; i <= n; i++) p[i].z = lower_bound(num+1,num+tot+1,p[i].z) - num;\n        ta.init(n);\n        sort(p+1,p+n+1); \n        fill(f, f + n + 1, 1);\n        solve(1, n);\n        int ret = 1;\n        for(int i = 1; i <= n; i++) ret = max(ret, f[i]);\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.5;\n        // int sqn = 10000;\n        sqn = max(sqn, 1);\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            vector<pair<pair<int, int>, int> > ncalced;\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                ncalced.push_back(*it);\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            swap(calced, ncalced);\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 30;\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, -1});\n    for (; lower != st.end() and lower->second >= v.second; lower++) {\n        st.erase(lower);\n    }\n    st.insert(v);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N, A, B;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto gen = [&]() {\n            static int a = A;\n            static int b = B;\n            constexpr int C = ~(1 << 31);\n            constexpr int M = (1 << 16) - 1;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            return (C & ((a << 16) + b)) % 1000000;\n        };\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<cctype>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<ctime>\n#include<map>\n#include<set>\nusing namespace std;\n#define MP(x,y) make_pair((x),(y))\n#define PB(x) push_back(x)\ntypedef long long LL;\n//typedef unsigned __int64 ULL;\n/* ****************** */\nconst int INF=100011122;\nconst double INFF=1e100;\nconst double eps=1e-8;\nconst LL mod=1000000007;\nconst int NN=300010;\nconst int MM=1000010;\n/* ****************** */\n\nconst int limit=1000000;\n\nint aa,bb;\nint C = ~(1<<31);\nint M = (1<<16)-1;\nint rr() {\n    aa = 36969 * (aa & M) + (aa >> 16);\n    bb = 18000 * (bb & M) + (bb >> 16);\n    return (C & ((aa << 16) + bb)) % 1000000;\n}\n\nstruct node\n{\n    int x,y,z;\n    bool operator<(const node &tt)const\n    {\n        return x<tt.x;\n    }\n}a[NN];\nstruct node1\n{\n    int x,y,z,id;\n    bool operator<(const node1 &tt)const\n    {\n        if(y!=tt.y)return y<tt.y;\n        return z>tt.z;\n    }\n}b[NN];\nint dp[NN];\nint c[2][limit+1];\n\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(int fg,int x,int val)\n{\n    for(;x<=limit;x+=lowbit(x))\n        c[fg][x]=max(c[fg][x],val);\n}\nint get_max(int fg,int x)\n{\n    int ans=0;\n    for(;x>0;x-=lowbit(x))\n        ans=max(ans,c[fg][x]);\n    return ans;\n}\nvoid clr_update(int fg,int x)\n{\n    for(;x<=limit;x+=lowbit(x))\n        c[fg][x]=0;\n}\n\nvoid cdq(int l,int r)\n{\n    if(l==r)\n    {\n        dp[l]=max(dp[l],1);\n        return;\n    }\n    int mid=(l+r)>>1;\n    int t,i,cnt=0,tx=a[mid+1].x;\n\n    cdq(l,mid);\n\n    for(i=l;i<=r;i++)\n    {\n        b[cnt].x=a[i].x;\n        b[cnt].y=a[i].y;\n        b[cnt].z=a[i].z;\n        b[cnt].id=i;\n        cnt++;\n    }\n    sort(b,b+cnt);\n    for(i=0;i<cnt;i++)\n    {\n        if(b[i].id<=mid)\n        {\n            update(1,b[i].z, dp[ b[i].id ] );\n            if(b[i].x!=tx)\n                update(0,b[i].z, dp[ b[i].id ] );\n        }\n        else\n        {\n            if(b[i].x==tx)\n                t=get_max(0,b[i].z-1);\n            else\n                t=get_max(1,b[i].z-1);\n\n            dp[ b[i].id ] = max( dp[ b[i].id ] , t+1 );\n        }\n    }\n    for(i=0;i<cnt;i++)\n        if(b[i].id<=mid)\n        {\n            clr_update(1,b[i].z);\n            if(b[i].x!=tx)\n                clr_update(0,b[i].z);\n        }\n\n    cdq(mid+1,r);\n}\n\nvoid solve(int n)\n{\n    int i,ans=0;\n    sort(a+1,a+1+n);\n\n    memset(c,0,sizeof(c));\n    memset(dp,0,sizeof(dp));\n\n    cdq(1,n);\n\n    for(i=1;i<=n;i++)\n        ans=max(ans,dp[i]);\n\n    printf(\"%d\\n\",ans);\n}\n\nint main()\n{\n    int m,n,i;\n    while(scanf(\"%d%d%d%d\",&m,&n,&aa,&bb)!=EOF)\n    {\n        if(m==0 && n==0)break;\n\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].z);\n            a[i].x++;\n            a[i].y++;\n            a[i].z++;\n        }\n        for(i=1;i<=n;i++)\n        {\n            a[i+m].x=rr();\n            a[i+m].y=rr();\n            a[i+m].z=rr();\n\n            a[i+m].x++;\n            a[i+m].y++;\n            a[i+m].z++;\n        }\n\n        solve(n+m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[1209], qy[1209], t[1209][1209], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? y[py[clx]] : 1 << 30), vr = (crx != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 30;\nint A, B;\ninline int gen()\n{\n    static int a = A;\n    static int b = B;\n    constexpr int C = ~(1 << 31);\n    constexpr int M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\n\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, 0});\n    vector<P> er;\n    for (; lower != st.end() and lower->second > v.second; lower++) {\n        er.push_back(*lower);\n    }\n    st.insert(v);\n    for (const P& e : er) {\n        st.erase(e);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i][0] = x;\n\t\t\tv[i][1] = -y;\n\t\t\tv[i][2] = -z;\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tv[i][0] = rnd(a, b);\n\t\t\tv[i][1] = -rnd(a, b);\n\t\t\tv[i][2] = -rnd(a, b);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mp = mps[mid - 1];\n\t\t\t\tauto it = mp.upper_bound(y);\n\t\t\t\tif(it != mp.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmps[left][y] = z;\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10, inf = 1e9;\n\nstruct Node {\n    PII e;\n    Node *ls, *rs;\n    int dim, cur, sub;\n} pool[MAXN], *cnt;\n\nstruct Point {\n    int x, y, z;\n    Point() {}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} P[MAXN];\n\nmap<int, int> best[MAXN];\nint dp[MAXN], ret;\n\nint r(int &a, int &b) {\n    static const int C = ~(1 << 31), M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const map<int, int> &mp, int x, int y) {\n    auto it = mp.lower_bound(x);\n    return it != mp.begin() && (-- it)->second < y;\n}\n\nint query(int x, int y) {\n    int left = 0, right = ret;\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(best[mid], x, y)) left = mid;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nvoid update(map<int, int> &mp, int x, int y) {\n    auto it = mp.upper_bound(x);\n    if (it != mp.begin() && (-- it)->second <= y) return;\n    it = mp.lower_bound(x);\n    while (it != mp.end() && it->second >= y) mp.erase(it ++);\n    mp[x] = y;\n}\n\nint main() {\n    int N, M, A, B;\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &P[i].x, &P[i].y, &P[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            P[i].x = r(A, B);\n            P[i].y = r(A, B);\n            P[i].z = r(A, B);\n        }\n        for (int i = 0; i <= N; ++ i) best[i].clear();\n        sort(P, P + N);\n        ret = 0;\n        for (int i = 0, j; i < N;) {\n            for (j = i; j < N && P[i].x == P[j].x; ++ j) dp[j] = query(P[i].y, P[i].z) + 1;\n            for (; i < j; ++ i) {\n                update(best[dp[i]], P[i].y, P[i].z);\n                ret = max(ret, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) delete lch, rch;\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) delete lch, rch;\n\t\tX.clear();\n\t\tdelete st;\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!(M + N)) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nbool check(int y, int z, const map<int, int> &contour) {\n  const auto it = contour.upper_bound(y);\n  return it != contour.end() && it->second < z;\n}\n\nint solve(vector<point> &points) {\n  const int n = points.size();\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  vector<map<int, int>> dp(n + 1);\n  dp[0].insert({1, -1});\n\n  for(const auto &p : points) {\n    const int y = -y(p);\n    const int z = z(p);\n\n    int low = 0;\n    int high = max_count + 1;\n\n    while(low + 1 < high) {\n      const int mid = (low + high) / 2;\n      if(check(y, z, dp[mid])) {\n\tlow = mid;\n      }\n      else {\n\thigh = mid;\n      }\n    }\n\n    if(!dp[high].count(y)) dp[high].insert({y, INT_MAX});\n    dp[high][y] = min(dp[high][y], z);\n    if(low == max_count) ++max_count;\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n#include <climits>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i][0] = x;\n\t\t\tv[i][1] = -y;\n\t\t\tv[i][2] = -z;\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tv[i][0] = rnd(a, b);\n\t\t\tv[i][1] = -rnd(a, b);\n\t\t\tv[i][2] = -rnd(a, b);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mp = mps[mid - 1];\n\t\t\t\tauto it = mp.upper_bound(y);\n\t\t\t\tif(it != mp.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint &t = mps[left].emplace(y, INT_MIN).first->second;\n\t\t\tt = max(t, z);\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\ntypedef set<P>::iterator se_it;\n\nset<P> se[300300];\n\nint xs[300300],ys[300300],zs[300300];\nPP pps[300300];\nint N;\n\nbool check(P p,int id){\n\tset<P> &se=::se[id];\n\tint x=p.first,y=p.second;\n\tif(se.size()==0) return false;\n\tse_it it=se.lower_bound(P(x,-2));\n\tif(it==se.begin()) return false;\n\tit--;\n\tint py=it->second;\n\tif(py<y) return true;\n\treturn false;\n}\n\nvoid ins(P p,int id){\n\tset<P> &se=::se[id];\n\tint x=p.first,y=p.second;\n\tse_it it=se.lower_bound(P(x,-2));\n\tif(it==se.end()){\n\t\tse.insert(p);\n\t\treturn;\n\t}\n\tif(it->first==x&&it->second<y){\n\t\treturn;\n\t}\n\twhile(true){\n\t\tif(it==se.end()||it->second<y) break;\n\t\tse.erase(it++);\n\t}\n\tse.insert(p);\n}\n\nvoid put(P p){\n\tint lb=0,ub=N+1;\n\twhile(ub-lb>1){\n\t\tint mid=(ub+lb)/2;\n\t\tbool flg=check(p,mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tins(p,lb+1);\n}\n\nint A,B;\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint m,n;\n\nvoid init(){\n\tscanf(\"%d%d%d%d\",&m,&n,&A,&B);\n\tif(m+n==0) exit(0);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",xs+i,ys+i,zs+i);\n\t}\n\ta=A,b=B;\n\tfor(int i=0;i<n;i++){\n\t\txs[i+m]=r();\n\t\tys[i+m]=r();\n\t\tzs[i+m]=r();\n\t}\n\tN=m+n;\n\tfor(int i=0;i<=N;i++){\n\t\tse[i].clear();\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tpps[i]=PP(zs[i],P(xs[i],ys[i]));\n\t}\n\tsort(pps,pps+N);\n}\n\nint solve(){\n\tse[0].insert(P(-1,-1));\n\tfor(int i=0;i<N;i++){\n\t\tP p=pps[i].second;\n\t\tput(p);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=N;i++) if(se[i].size()>0) ans=i;\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tint ans=solve();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  C = ~(1<<31);\n  M = (1<<16)-1;\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<19);\n    dp[0].insert(make_tuple(-1,-1));\n    auto p = equal_range(begin(v),end(v),make_tuple(-1,0,0));\n    REP(i,1000000) {\n      vector<tuple<int,int,int>> add;\n      vector<tuple<int,int,int>> erase;\n      while(p.second != end(v) && get<0>(*p.second) <= i) ++p.second;\n      for(;p.first != p.second; ++p.first) {\n        int y,z;\n        tie(ignore,y,z) = *p.first;\n        int k=1<<18;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          auto pitr = prev(itr);\n          if (get<0>(*pitr) <= y || get<1>(*pitr) <= z) continue;\n        }\n        while(itr != end(dp[j]) && get<1>(*itr) >= z) {\n          erase.emplace_back(j,get<0>(*itr),get<1>(*itr));\n          ++itr;\n        }\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(add),end(add));\n      vector<tuple<int,int,int>>::iterator\n        itr = begin(add), eitr = begin(add);\n      while(eitr != end(add)) {\n        while(eitr != end(add) &&\n            get<0>(*eitr) == get<0>(*itr)) ++eitr;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*itr);\n        for(; itr != eitr; ++itr) {\n          int y,z;\n          tie(ignore,y,z) = *itr;\n          if (tp.empty() || (get<0>(tp.back()) != y && get<1>(tp.back()) > z))\n            tp.emplace_back(y,z);\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n      for (auto r:erase) {\n        int j,y,z;\n        tie(j,y,z) = r;\n        dp[j].erase(make_tuple(y,z));\n      }\n    }\n    REP(i,1<<19) {\n      if(dp[i].empty()) {\n        cout << (i - 1) << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n\nusing namespace std;\nconst int MOD = 1000000007; // check!!!\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\nint m, n, A, B;\n\nstruct P {\n\tint x, y, z;\n\tP() {}\n\tP(int x, int y, int z) : x(x), y(y), z(z) {}\n\tbool operator< (const P& l) const {\n\t\tif (x != l.x) return x < l.x;\n\t\tif (y != l.y) return y > l.y;\n\t\treturn z > l.z;\n\t}\n};\n\nint r() {\n\tconst int C = ~(1 << 31);\n\tconst int M = (1 << 16) - 1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\nbool C(map<int, P>& polyline, const P& p) {\n\tmap<int, P>::iterator it = polyline.lower_bound(p.y);\n\tif (it == polyline.begin()) return true;\n\tit--;\n\treturn it->second.z >= p.z;\n}\n\nvoid insert_polyline(vector<map<int, P> >& polyline, const P& p) {\n\tint l = -1, r = sz(polyline);\n\twhile (r - l != 1) {\n\t\tint md = (l + r) / 2;\n\t\tbool ok = C(polyline[md], p);\n\t\tif (ok) r = md;\n\t\telse l = md;\n\t}\n\tif (sz(polyline) == r) {\n\t\tpolyline.push_back(map<int, P>());\n\t}\n\n\tpolyline[r][p.y] = p;\n\tmap<int, P>::iterator it = polyline[r].find(p.y);\n\t++it;\n\twhile (true) {\n\t\tif (it == polyline[r].end()) break;\n\t\tauto nxt = it; ++nxt;\n\t\tif (it->second.z >= p.z) {\n\t\t\tpolyline[r].erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tit = nxt;\n\t}\n}\n\nint main() {\n\twhile (cin >> m >> n >> A >> B, m || n || A || B) {\n\t\tvector<P> v;\n\t\tFOR(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tv.emplace_back(x, y, z);\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tv.emplace_back(x,y,z);\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tvector<map<int, P> > polyline;\n\t\tFOR(i, sz(v)) {\n\t\t\tinsert_polyline(polyline, v[i]);\n\t\t}\n\n\t\tcout << sz(polyline) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(int *st, int *en) {\n\tvector<int> vs(st, en);\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto ii = st; ii != en; ii++) {\n\t\t*ii = lower_bound(vs.begin(), vs.end(), *ii) - vs.begin();\n\t}\n}\n\nint sort_xyz(int* x, int* y, int* z, int n) {\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint x[300000];\nint y[300000];\nint z[300000];\n\nint main()\n{\n\tint m, n, A, B;\n\twhile (scanf(\"%d%d%d%d\", &m, &n, &A, &B), m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tscanf(\"%d%d%d\", x + i, y + i, z + i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x, x + m + n);\n\t\tcompress(y, x + m + n);\n\t\tcompress(z, x + m + n);\n\t\tn = sort_xyz(x, y, z, m + n);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint N, M, A, B, C = ~(1 << 31), D = 65535, lim = 1000001, x[300009], y[300009], z[300009], p[300009];\n// O(N log^3 N)\nmap<int, int> bit[1000009];\nint func() {\n\tA = 36969 * (A & D) + (A >> 16);\n\tB = 18000 * (B & D) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nvoid assign(int px, int py, int val) {\n\tfor (int i = px + 1; i <= lim; i += i & (-i)) {\n\t\tfor (int j = py + 1; j <= lim; j += j & (-j)) {\n\t\t\tbit[i][j] = max(bit[i][j], val);\n\t\t}\n\t}\n}\nint query(int px, int py) {\n\tint ret = 0;\n\tfor (int i = px; i >= 1; i -= i & (-i)) {\n\t\tfor (int j = py; j >= 1; j -= j & (-j)) {\n\t\t\tret = max(ret, bit[i][j]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d%d\", &N, &M, &A, &B), N + M) {\n\t\tfor (int i = 0; i < N; ++i) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\tfor (int i = 0; i < M; ++i) x[N] = func(), y[N] = func(), z[N] = func(), ++N;\n\t\tfor (int i = 0; i < N; ++i) p[i] = i;\n\t\tsort(p, p + N, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i <= lim; i++) bit[i].clear();\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint res = query(x[p[i]], y[p[i]]);\n\t\t\tassign(x[p[i]], y[p[i]], res + 1);\n\t\t\tret = max(ret, res + 1);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 300005\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n\nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n\nint x[MAX],y[MAX],z[MAX];\nset< P > t[MAX];\n\n\nvoid insert(set<P> &s,P p){\n  set<P> :: iterator it;\n  while(1){\n    it=s.upper_bound(p);\n    if(it==s.end())break;\n\n    if( p.first <= it->first &&\n        p.second <= it->second ){\n      s.erase(it);\n    }else{\n      break;\n    }\n  }\n  s.insert(p);\n}\n\nbool check(set<P> &s,P p){\n  set<P> :: iterator it;\n  it=s.upper_bound(p);\n  int cc=0;\n  while(it!=s.begin()){\n    cc++;\n    if(cc>3)break;\n\n    it--;\n    if(it->first < p.first)\n      if(it->second < p.second)\n        return true;\n  }\n  return false;\n}\n\nint calc(P p){\n  int left=0,right=m+n,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(t[mid],p))left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\n\nvector<P> G[1000005];\n\nint solve(){\n  int ans=1;\n\n  for(int i=0;i<=m+n;i++){\n    t[i].clear();\n  }\n  t[0].insert(P(-1,-1));\n  set<int> st;\n\n  for(int i=0;i<m+n;i++){\n    st.insert( z[i] );\n    G[ z[i] ].push_back( P(x[i],y[i]) );\n  }\n\n  for( int i : st ){\n    vector<int> v( G[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      v[j]=calc(G[i][j]);\n      ans=max(ans,v[j]);\n    }\n    for(int j=0;j<(int)G[i].size();j++){\n      insert(t[ v[j] ],G[i][j]);\n    }\n    G[i].clear();    \n  }\n  /*\n  for(int i=0;i<=ans;i++){\n    cout<<i<<\" :\"<<endl;\n    for(P p:t[i]){\n      cout<<p.first<<' '<<p.second<<endl;\n    }\n    cout<<endl;\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n\n    a=A,b=B;\n    \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n\n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 300010;\nint m, n, A, B, C = ~(1<<31), M = (1<<16) - 1;\nstruct triple {\n\tint x, y, z;\n\tbool operator<(const triple &b) const\n\t{ return x != b.x ? x < b.x : y > b.y; }\n}v[MAXN];\nint z[MAXN], tot;\nint c[MAXN];\nint f[MAXN];\n\nint r()\n{\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid init()\n{\n\tn += m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tscanf(\"%d%d%d\", &v[i].x, &v[i].y, &v[i].z);\n\t\tz[i] = v[i].z;\n\t}\n\tfor (int i = m; i < n; ++i) {\n\t\tv[i].x = r(), v[i].y = r(), v[i].z = r();\n\t\tz[i] = v[i].z;\n\t}\n\tsort(v, v + n);\n\tsort(z, z + n);\n\ttot = unique(z, z + n) - z;\n\tfor (int i = 0; i < n; ++i) {\n\t\tv[i].z = lower_bound(z, z + n, v[i].z) - z + 1;\n\t\tf[i] = 1;\n\t}\n}\n\nvoid add(int i, int x)\n{\n\tfor (; i <= tot; i += i & -i) c[i] = max(c[i], x);\n}\n\nint query(int i)\n{\n\tint s = 0;\n\tfor (; i; i -= i & -i) s = max(s, c[i]);\n\treturn s;\n}\n\nvoid clr(int i)\n{\n\tfor (; i <= tot; i += i & -i) c[i] = 0;\n}\n\nbool cmpy(int a, int b)\n{\n\treturn v[a].y < v[b].y;\n}\n\nvoid solve(int l, int r)\n{\n\tif (r - l <= 1) return;\n\tstatic int p[MAXN];\n\tint mid = (l + r) / 2;\n\tsolve(l, mid);\n\tfor (int i = l; i < r; ++i) p[i] = i;\n\tsort(p + l, p + mid, cmpy);\n\tsort(p + mid, p + r, cmpy);\n\tfor (int i = mid, j = l; i < r; ++i) {\n\t\twhile (j < mid && v[p[j]].y < v[p[i]].y) {\n\t\t\tadd(v[p[j]].z, f[p[j]]);\n\t\t\t++j;\n\t\t}\n\t\tf[p[i]] = max(f[p[i]], query(v[p[i]].z - 1) + 1);\n\t}\n\tfor (int i = l; i < mid; ++i) clr(v[i].z);\n\tsolve(mid, r);\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d%d%d\", &m, &n, &A, &B) != EOF && (m || n)) {\n\t\tinit();\n\t\tsolve(0, n);\n\t\tprintf(\"%d\\n\", *max_element(f, f + n));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing std::sort;\nusing std::fill;\nusing std::max;\nusing std::unique;\nusing std::lower_bound;\nconst int N = 330010;\nstruct point {\n    int x,y,z;\n    int id;\n    bool operator < (const point& b) const {\n        if(x == b.x) {\n            if(y == b.y) return z > b.z;\n            else return y > b.y;\n        }\n        return x < b.x;\n    }\n    inline void in() {\n        scanf(\"%d%d%d\",&x,&y,&z);\n    }\n}p[N],g[N];\nint num[N];\nint f[N];\ninline int cmpy(point a,point b){\n    return  a.y < b.y;\n}\nstruct BIT{\n    int n;\n    int c[N];\n    inline void init(int n) {\n        this->n = n;\n    }\n    inline void insert(int x, int add) {\n        for(; x <= n; x += x & -x) if(add > c[x]) c[x] = add;\n    }\n    inline int ask(int x) {\n        int ret = 0;\n        for(; x > 0; x -= x & -x) if(c[x] > ret) ret = c[x];\n        return ret;\n    }\n    inline void clear(int x) {\n        for(; x <= n; x += x & -x) c[x] = 0;\n    }\n}ta;\nvoid update(int l1, int r1, int l2, int r2) {\n    sort(g + l1, g + r1 + 1, cmpy);\n    sort(g + l2, g + r2 + 1, cmpy);\n    int pt = l1;\n    for(int i = l2; i <= r2; i++) {\n        while(pt <= r1 && g[pt].y < g[i].y){\n            ta.insert(g[pt].z, f[g[pt].id]);\n            pt++;\n        }\n        int opt=ta.ask(g[i].z - 1);\n        if(opt + 1 > f[g[i].id]) {\n            f[g[i].id] = opt + 1;\n        }\n    }\n    for(int i = l1; i <= r1; i++) ta.clear(g[i].z);\n}\nvoid solve(int l,int r)\n{\n    if(l == r) {    \n        if(1 > f[p[l].id]) f[p[l].id] = 1;\n        return ; \n    }\n    int mid = (l + r) >> 1;\n    solve(l,mid);\n    for(int i = l; i <= r; i++)    g[i] = p[i];\n    if(p[mid].x != p[mid + 1].x) {\n        //蟾ヲ蜿ウ蛹コ髣エ驛ス謖臥?y謗貞コ?蟾ヲ蛹コ髣エ逧з蟾イ扈丈ソ晁ッ∝ー丈コ主承蛹コ髣エ逧з莠?シ?        update(l, mid, mid + 1, r);\n    } else {\n        int leftp = mid;\n        while(leftp >= l && p[leftp].x == p[mid].x) leftp--;\n        int rightp = mid + 1;\n        while(rightp <= r && p[rightp].x == p[mid].x) rightp++;\n        if(leftp < l && rightp > r) { \n        } else if(leftp < l) {\n            update(l, mid, rightp, r);\n        } else if(rightp > r){\n            update(l, leftp, mid + 1, r);\n        } else {\n            update(l, leftp, mid + 1, r);\n            for(int i = l; i <= r; i++) g[i] = p[i];\n            update(leftp + 1, mid, rightp, r);\n        }\n    }\n    solve(mid+1,r);\n}\n\nint M, a, b, C;\nint main()\n{\n    int t,m,nn,A,B;\n    while(scanf(\"%d%d%d%d\",&m,&nn,&A,&B) && (m + nn + A + B))\n    {\n        a = A; b = B;\n        C = ~(1 << 31);\n        M = (1 << 16) - 1;\n        for(int i = 1; i <= m; i++) {\n            p[i].in();\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        for(int i = m + 1; i <= m + nn; i++) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int x = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int y = (C & ((a << 16) + b)) % 1000000;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            int z = (C & ((a << 16) + b)) % 1000000;\n            p[i].x = x;\n            p[i].y = y;\n            p[i].z = z;\n            p[i].id = i;\n            num[i] = p[i].z;\n        }\n        int n = m + nn;\n        sort(num+1,num+n+1);\n        int tot = unique(num+1,num+n+1) - num - 1; \n        for(int i = 1; i <= n; i++) p[i].z = lower_bound(num+1,num+tot+1,p[i].z) - num;\n        ta.init(n);\n        sort(p+1,p+n+1); \n        fill(f, f + n + 1, 1);\n        solve(1, n);\n        int ret = 1;\n        for(int i = 1; i <= n; i++) ret = max(ret, f[i]);\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> tii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=300010;\nset<pii> LIS[nmax];\nvector<tii> ary;\n\nvoid ins(int pos,pii p){\n\tauto it=LIS[pos].lower_bound(p);\n\tauto it2=it;it2--;\n\tif(it2->second<=p.second) return;\n\twhile(p.second<=it->second) LIS[pos].erase(it++);\n\tLIS[pos].insert(p);\n}\n\nbool mini(int pos,pii p){\n\tauto it=LIS[pos].lower_bound(p);\n\twhile(it->second<p.second){\n\t\tif(it->first<p.first) return true;\n\t\tit--;\n\t}\n\treturn false;\n}\n\n\ninline int rng(int &a,int &b){\n\tconst int C = ~(1<<31), M = (1<<16)-1;\n\ta=36969*(a & M)+(a >> 16);\n\tb=18000*(b & M)+(b >> 16);\n\treturn (C&((a<<16)+b))%1000000;\n}\n\nint main(void){\n\tint n,m,A,B;\n\twhile(cin >> n >> m >> A >> B){\n\t\tif(n==0&&m==0) break;\n\t\trep(i,nmax){\n\t\t\tLIS[i].clear();\n\t\t\tLIS[i].insert(mp(inf,-1));\n\t\t\tLIS[i].insert(mp(-1,inf));\n\t\t}\n\t\tary.clear();\n\t\trep(i,n){\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tary.pb(mp(-z,mp(y,x)));\n\t\t}\n\t\trep(i,m){\n\t\t\tint x=rng(A,B),y=rng(A,B),z=rng(A,B);\n\t\t\tary.pb(mp(-z,mp(y,x)));\n\t\t}\n\t\tsort(ary.rbegin(),ary.rend());\n\t\tint ans=0;\n\t\trep(i,n+m){\n\t\t\tint l=-1,r=ans;\n\t\t\twhile(r-l>1){\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\tif(mini(mid,ary[i].second))\n\t\t\t\t\tl=mid;\n\t\t\t\telse\n\t\t\t\t\tr=mid;\n\t\t\t}\n\t\t\tans=max(ans,r+1);ins(r,ary[i].second);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nclass HappySequence{\npublic:\n\tmap<int,int> seq;\n\tHappySequence(){ int inf = 1e9; seq[-inf] = -inf; }\n\tbool insert(int key,int val){\n\t\tif( (--seq.upper_bound(key))->second >= val ) return false;\n\t\tseq[key] = val;\n\t\tauto it = ++seq.find(key);\n\t\twhile( it != seq.end() ){\n\t\t\tif( (*it).second <= val ) seq.erase(it++);\n\t\t\telse it++;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nHappySequence seg[1000100];\n\nvoid ins(int y,int z,int v){\n\tfor(int i = y ; i < 1000100 ; i += i & -i ) seg[i].insert(z,v);\n}\nint get(int y,int z){\n\tint v = 0;\n\tfor(int i = y ; i > 0 ; i -= i & -i ){\n\t\tv = max(v,(--seg[i].seq.lower_bound(z))->second);\n\t}\n\treturn v;\n}\n\nint main(){\n\tint n,m,A,B;\n\twhile( cin >> m >> n >> A >> B && n+m ){\t\n\t\ta = A;\n\t\tb = B;\n\t\tvector< array<int,3> > ps;\n\t\tvector<int> uy;\n\t\tfor(int i = 0 ; i < m ; i++){\t\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.push_back({x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tps.push_back({x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tsort(uy.begin(),uy.end());\n\t\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\t\tfor(int i = 0 ; i <= uy.size() ; i++) seg[i] = HappySequence();\n\t\tsort(ps.begin(),ps.end(),[&](array<int,3> a,array<int,3> b){\n\t\t\tif( a[0] != b[0] ) return a[0] < b[0];\n\t\t\treturn make_pair(a[1],a[2]) > make_pair(b[1],b[2]);\n\t\t});\n\t\tint ans = 0;\n\t\tfor( auto p : ps ){\n\t\t\tp[1] = lower_bound(uy.begin(),uy.end(),p[1]) - uy.begin() + 1;\n\t\t\tint mx = get(p[1]-1,p[2]) + 1;\n\t\t\tans = max(ans,mx);\n\t\t\tins(p[1],p[2],mx);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntypedef tuple<int, int, int> point;\n#define x(p) get<0>(p)\n#define y(p) get<1>(p)\n#define z(p) get<2>(p)\n\nint r(int &a, int &b) {\n  static constexpr int C = ~(1 << 31);\n  static constexpr int M = (1 << 16) - 1;\n\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint solve(vector<point> &points) {\n  const int n = points.size();\n  sort(points.begin(), points.end());\n\n  int max_count = 0;\n  vector<map<int, int>> dp(n + 1);\n  dp[0].insert({1, -1});\n\n  for(const auto &p : points) {\n    const int y = -y(p);\n    const int z = z(p);\n\n    for(int i = max_count; i >= 0; --i) {\n      const auto it = dp[i].upper_bound(y);\n      if(it == dp[i].end() || it->second >= z) continue;\n      if(!dp[i + 1].count(y)) dp[i + 1].insert({y, INT_MAX});\n\n      dp[i + 1][y] = min(dp[i + 1][y], z);\n      if(i == max_count) ++max_count;\n      break;\n    }\n\n  }\n  \n  return max_count;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  for(int m, n, a, b; cin >> m >> n >> a >> b && (m | n);) {\n    vector<point> points;\n    points.reserve(n + m);\n\n    for(int i = 0; i < m; ++i) {\n      int x, y, z;\n      cin >> x >> y >> z;\n      points.emplace_back(x, y, z);\n    }\n\n    for(int i = 0; i < n; ++i) {\n      const int x = r(a, b);\n      const int y = r(a, b);\n      const int z = r(a, b);\n      points.emplace_back(x, y, z);\n    }\n\n    cout << solve(points) << endl;\n  }\n\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n\nstruct Point3 {\n\tint x, y, z;\n};\nstruct Point2 {\n\tint x, y;\n\tbool operator<(const Point2 other) const { return x < other.x; }\n};\nclass NonChainablePoints {\n\tstd::set<Point2> set;\npublic:\n\tNonChainablePoints() {};\n\tbool can_chain(const Point2& point) const {\n\t\tauto hint = set.lower_bound(point);\n\t\treturn hint != set.begin() && (--hint)->y < point.y;\n\t}\n\tvoid insert(const Point2& point) {\n\t\tauto hint = set.lower_bound(point);\n\t\tif (hint == set.end() || hint->x != point.x || hint->y >= point.y) {\n\t\t\twhile (hint != set.end() && hint->y >= point.y) hint = set.erase(hint);\n\t\t\tset.insert(point);\n\t\t}\n\t}\n\tbool is_empty() const { return set.empty(); }\n\tbool is_not_empty() const { return !is_empty(); }\n};\nint r(int& a, int& b) {\n\tconstexpr int C = ~(1 << 31);\n\tconstexpr int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\nvoid append_points(std::vector<Point3>& points, int a, int b, const int n) {\n\tfor (auto i = 0; i < n; ++i) {\n\t\tPoint3 p;\n\t\tp.x = r(a, b);\n\t\tp.y = r(a, b);\n\t\tp.z = r(a, b);\n\t\tpoints.push_back(p);\n\t}\n}\nint solve(const int m, const int n, const int a, const int b) {\n\tstd::vector<Point3> points(m);\n\tfor (auto& p : points) std::cin >> p.x >> p.y >> p.z;\n\tappend_points(points, a, b, n);\n\tstd::sort(points.begin(), points.end(), [](const Point3& a, const Point3& b) {return (a.z == b.z) ? a.x > b.x : a.z < b.z; });\n\tstd::vector<NonChainablePoints> sets(m + n);\n\tfor (const auto point : points) {\n\t\tconst Point2 p{ point.x, point.y };\n\t\tauto left = 0;\n\t\tauto right = sets.size();\n\t\twhile (left < right) {\n\t\t\tauto mid = (left + right) / 2;\n\t\t\tif (sets[mid].can_chain(p)) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tsets[right].insert(p);\n\t}\n\tfor (auto i = 0; i < sets.size(); ++i) {\n\t\tif (sets[i].is_empty()) return i;\n\t}\n\treturn sets.size();\n}\nint main() {\n\tstd::vector<int>result;\n\twhile (true) {\n\t\tint m, n, a, b;\n\t\tstd::cin >> m >> n >> a >> b;\n\t\tif (m == 0 && n == 0) break;\n\t\tresult.push_back(solve(m, n, a, b));\n\t}\n\tfor (const auto r : result) std::cout << r << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define INT(a) int((a)+1e-9)\n\nstruct P{\n\tint x,y,z;\n\tP(){}\n\tP(int x0, int y0, int z0){\n\t\tx=x0;y=y0;z=z0;\n\t}\n};\n\nbool LT(P ap, P bp){\n\treturn ap.x<bp.x && ap.y<bp.y && ap.z<bp.z;\n}\n\n\nint A,B,C,M,a,b;\nint getR() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint m,n;\nint solve(){\n\ta = A; b = B; C = ~(1<<31); M = (1<<16)-1;\n\tint pl=m+n;\n\tP ps[pl];\n\tREP(pi,m){\n\t\tint x,y,z;\n\t\tcin>>x>>y>>z;\n\t\tps[pi]=P(x,y,z);\n\t}\n\tFOR(pi,m,n){\n\t\tint x,y,z;\n\t\tx=getR();y=getR();z=getR();\n\t\tps[pi]=P(x,y,z);\n\t}\n\tsort(ps,ps+pl,LT);\n\t\n\tint rs[pl];\n\tFOR(pi,0,pl) rs[pi]=1;\n\tFOR(pi,0,pl){\n\t\tFOR(pj,0,pi){\n\t\t\tif(LT(ps[pj],ps[pi])){\n\t\t\t\trs[pi] = max(rs[pi],rs[pj]+1);\n\t\t\t}\n\t\t}\n\t\t//cout<<ps[pi].x<<\" \"<<ps[pi].y<<\" \"<<ps[pi].z<<\" \"<<rs[pi]<<endl;\n\t}\n\t\n\tint re=0;\n\tFOR(pi,0,pl) re=max(re,rs[pi]);\n\treturn re;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>m>>n>>A>>B;\t\t\tif(!m&&!n) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nconst int IINF = INT_MAX;\n\nstruct Point3d {\n  int x,y,z;\n  bool operator < ( const Point3d &p ) const {\n    if( z != p.z ) return z < p.z;\n    if( y != p.y ) return y > p.y;\n    return x > p.x;\n  }\n};\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\n\nconst int MAX = 300010;\nint m,n,A,B;\nPoint3d ps[MAX];\n\n\nset<ii> dp[MAX];\n\nbool check(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second < v.second ){\n    if( (*it).first < v.first ) return true;\n    --it;\n  }\n  return false;\n}\n\nvoid update(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  --it;\n  if( (*it).second <= v.second ) return;\n  ++it;\n  while( (*it).second >= v.second ) dp[index].erase(it++);\n  dp[index].insert(v);\n}\n\nint LIS2D(vector<ii> &vec) {\n  rep(i,(int)vec.size()+1) {\n    dp[i].clear();\n    dp[i].insert(ii(-1,IINF));\n    dp[i].insert(ii(IINF,-1));\n  }\n  dp[0].insert(ii(-1,-1));\n  int maxi = 0;\n  rep(i,(int)vec.size()){\n    int low = 0, hig = i+1;\n    while( hig - low ) {\n      int mid = ( low + hig ) / 2;\n      if( check(mid,vec[i]) ) low = mid + 1;\n      else                    hig = mid;\n    }\n    maxi = max(maxi,low);\n    update(low,vec[i]);\n  }\n  return maxi + 1;\n}\n\n\nvoid compute(){\n  sort(ps,ps+n+m);\n  vector<ii> vec;\n  rep(i,n+m) vec.push_back(ii(ps[i].y,ps[i].x));\n  cout << LIS2D(vec) << endl;\n}\n\nint main(){\n  while( scanf(\"%d %d %d %d\",&m,&n,&A,&B), m|n|A|B ){\n    a = A, b = B;\n    rep(i,m) scanf(\"%d %d %d\",&ps[i].x,&ps[i].y,&ps[i].z);\n    rep(i,n) {\n      ps[m+i].x = r();\n      ps[m+i].y = r();\n      ps[m+i].z = r();\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxe], g[maxn], ct[maxe];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint LT,RT,LB,RB;\n\tint val;\n\tnode(){\n\t\tLT=RT=LB=RB=-1;\n\t\tval=0;\n\t}\n\tnode(int a,int b,int c,int d,int e){\n\t\tLT=a;\n\t\tRT=b;\n\t\tLB=c;\n\t\tRB=d;\n\t\tval=e;\n\t}\n};\nnode pool[8000000];\nint ind;\nint Ret;\nint nowret=0;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int t){\n\tif(d<a||b<c)return 0;\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d&&g<=e&&f<=h)return pool[t].val;\n\tif(nowret>=pool[t].val)return 0;\n\tint ret=0;\n\tif(~pool[t].LT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,e,(e+f)/2,g,h,pool[t].LT));\n\t}\n\tif(~pool[t].RT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,(e+f)/2+1,f,g,h,pool[t].RT));\n\t}\n\tif(~pool[t].LB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,e,(e+f)/2,g,h,pool[t].LB));\n\t}\n\tif(~pool[t].RB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,(e+f)/2+1,f,g,h,pool[t].RB));\n\t}\n\treturn ret;\n}\ninline void update(int row,int col,int C){\n\tint now=0;\n\tint a=0;\n\tint b=1048575;\n\tint c=0;\n\tint d=1048575;\n\twhile(1){\n\t\tpool[now].val=max(pool[now].val,C);\n\t\tif(a==b)break;\n\t\tint M=(a+b)/2;\n\t\tint N=(c+d)/2;\n\t\tif(row<=M&&col<=N){//LT\n\t\t\tb=M;\n\t\t\td=N;\n\t\t\tif(~pool[now].LT){\n\t\t\t\tnow=pool[now].LT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row<=M&&col>N){//RT\n\t\t\tb=M;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RT){\n\t\t\t\tnow=pool[now].RT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col<=N){//LB\n\t\t\ta=M+1;\n\t\t\td=N;\n\t\t\tif(~pool[now].LB){\n\t\t\t\tnow=pool[now].LB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col>N){//RB\n\t\t\ta=M+1;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RB){\n\t\t\t\tnow=pool[now].RB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\t\n\t}\n}\npair<int,pair<int,int> >dat[400000];\nint x[400000];\nint y[400000];\nint z[400000];\nint Q[400000];\nint wolfa,wolfb,wolfC=~(1<<31),wolfM=(1<<16)-1;\nint r(){\n\twolfa=36969*(wolfa&wolfM)+(wolfa>>16);\n\twolfb=18000*(wolfb&wolfM)+(wolfb>>16);\n\treturn (wolfC&((wolfa<<16)+wolfb))%1000000;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,z+i);\n\t\t\tdat[i]=make_pair(x[i],make_pair(-y[i],-z[i]));\n\t\t}\n\t\twolfa=c;\n\t\twolfb=d;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint X=r();\n\t\t\tint Y=r();\n\t\t\tint Z=r();\n\t\t\tdat[i+a]=make_pair(X,make_pair(-Y,-Z));\n\t\t}\n\t\tint n=a+b;\n\t\tstd::sort(dat,dat+n);\n\t\tpool[0]=node();\n\t\tind=1;\n\t\tRet=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tnowret=0;\n\t\t\tint P=max(nowret,query(0,1048575,0,-dat[i].second.first-1,0,1048575,0,-dat[i].second.second-1,0))+1;\n\t\t\tRet=max(Ret,P);\n\t\t\tQ[i]=P;\n\t\t\tupdate(-dat[i].second.first,-dat[i].second.second,P);\n\t\t}\n\t\tprintf(\"%d\\n\",Ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<map>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int> mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int>::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it!=mp.end()&&it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\n\t\t\ts=it;\n\t\t\t++s;\n\t\t}else if(it!=mp.begin()){\n\t\t\ts=it;\n\t\t\tif((--it)->second>=v)return;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}else{\n\t\t\ts=it;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}\n\t\te=s;\n\t\twhile(e!=mp.end()&&e->second<=v)++e;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int>::const_iterator it;\n\t\tit=mp.lower_bound(xe);\n\t\tif(it==mp.begin())return nil;\n\t\treturn (--it)->second;\n\t}\n};\n\n\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<SparseRMQ*> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1,(SparseRMQ*)NULL){}\n\t~Dynamic2DRMQ_BIT(){\n\t\tfor(int i=0;i<(int)bit.size();i++)\n\t\t\tif(bit[i])delete bit[i];\n\t}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tif(!bit[x])bit[x]=new SparseRMQ();\n\t\t\tbit[x]->insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ye)const{//[0,xe)*[0,ye)\n\t\tint res=nil;\n\t\twhile(0<xe){\n\t\t\tif(bit[xe])res=func(res,bit[xe]->max(ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(2000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n\nusing namespace std ;\n\n#define CS\t\t\t\tconst static\n#define LL\t\t\t\tlong long\n#define Rep(i,l,r)\t\t\tfor(int i = (l) ; i <= (r) ; ++i)\n#define PII\t\t\t\tpair <int , int>\n#define mp(x , y)\t\t\tmake_pair(x , y)\n#define fi\t\t\t\tfirst\n#define se\t\t\t\tsecond\n\nCS int NM = 300010 , L = 1000001 ;\n\nstruct ptr\n{\n\tint x,y,z,f ;\n} p[NM] ;\n\nint c[L + 10] ;\n\nint n,m,A,B ;\n\nint a , b , C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nbool cmp1(const ptr & a , const ptr & b)\n{\n\tif(a.x != b.x)\treturn a.x < b.x ;\n\treturn b.y < a.y ;\n}\n\nbool cmp2(const ptr & a , const ptr & b)\n{\n\treturn a.y < b.y ;\n}\n\nvoid upd(int x,int d)\n{\n\tfor( ; x <= L ; x += (x & (-x)))\n\t\tc[x] = max(c[x] , d) ;\n}\n\nvoid bak(int x)\n{\n\tfor( ; x <= L ; x += (x & (-x)))\n\t\tc[x] = 0 ;\n}\n\nint query(int x)\n{\n\tint ans = 0 ;\n\tfor ( ; x > 0 ; x -= (x & (-x)))\n\t\tans = max(ans , c[x]) ;\n\treturn ans ;\n}\n\nvoid dfs(int l,int r)\n{\n\tif(l == r)\n\t{\n\t\tp[l].f = max(p[l].f , 1) ;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1 ;\n\tdfs(l , mid) ;\n\tsort(p + l , p + mid + 1, cmp2) ;\n\tsort(p + mid + 1 , p + r + 1 , cmp2) ;\n\t//memset(c,0,sizeof(c)) ;\n\tint j = 1 ; Rep(i , mid + 1 , r)\n\t{\n\t\twhile(p[j].y < p[i].y && j <= mid)\n\t\t{\n\t\t\tupd(p[j].z , p[j].f) ;\n\t\t\t++ j ;\n\t\t}\n\t\tp[i].f = max(p[i].f , query(p[i].z - 1) + 1) ;\n\t}\n\tRep(k,1,j)\tbak(p[k].z) ;\n\tdfs(mid + 1 , r) ;\n}\n\nint main()\n{\n//\tfreopen(\"data.txt\",\"r\",stdin) ;\n\twhile ( cin >> m >> n >> A >> B , n + m )\n\t{\n\t\ta = A ; b = B ;\n\t\tRep(i,1,m)\n\t\t{\n\t\t\tscanf(\"%d %d %d\",&p[i].x,&p[i].y,&p[i].z) ;\n\t\t\t++p[i].z ; p[i].f = 0 ;\n\t\t}\n\t\tRep(i,1,n)\n\t\t{\n\t\t\t++m ;\n\t\t\tp[m].x = r() ;\n\t\t\tp[m].y = r() ;\n\t\t\tp[m].z = r() ; ++ p[m].z ; p[i].f = 0 ;\n\t\t}\n\t\tsort(p + 1 , p + m + 1 , cmp1) ;\n\t\tdfs(1 , m) ;\n\t\tint ans = p[1].f ;\n\t\tRep(i,2,m)\tans = max(ans , p[i].f) ;\n\t\tcout << ans << endl ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nclass HappySequence{\npublic:\n\tmap<int,int> seq;\n\tHappySequence(){ int inf = 1e9; seq[-inf] = -inf; }\n\tbool insert(int key,int val){\n\t\t//if( (--seq.upper_bound(key))->second >= val ) return false;\n\t\tseq[key] = val;\n\t\tauto it = ++seq.find(key);\n\t\twhile( it != seq.end() && (*it).second <= val ) seq.erase(it++);\n\t\treturn true;\n\t}\n};\n\nHappySequence seg[1000100];\n\nvoid ins(int y,int z,int v){\n\tfor(int i = y ; i < 1000100 ; i += i & -i ) seg[i].insert(z,v);\n}\nint get(int y,int z){\n\tint v = 0;\n\tfor(int i = y ; i > 0 ; i -= i & -i ){\n\t\tv = max(v,(--seg[i].seq.lower_bound(z))->second);\n\t}\n\treturn v;\n}\n\nint main(){\n\tint n,m,A,B;\n\twhile( cin >> m >> n >> A >> B && n+m ){\t\n\t\ta = A;\n\t\tb = B;\n\t\tvector< array<int,3> > ps;\n\t\tvector<int> uy;\n\t\tfor(int i = 0 ; i < m ; i++){\t\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tsort(uy.begin(),uy.end());\n\t\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\t\tfor(int i = 0 ; i <= uy.size() ; i++) seg[i] = HappySequence();\n\t\tsort(ps.begin(),ps.end(),[&](array<int,3> a,array<int,3> b){\n\t\t\tif( a[0] != b[0] ) return a[0] < b[0];\n\t\t\treturn make_pair(a[1],a[2]) > make_pair(b[1],b[2]);\n\t\t});\n\t\tint ans = 0;\n\t\tfor( auto p : ps ){\n\t\t\tp[1] = lower_bound(uy.begin(),uy.end(),p[1]) - uy.begin() + 1;\n\t\t\tint mx = get(p[1]-1,p[2]) + 1;\n\t\t\tans = max(ans,mx);\n\t\t\tins(p[1],p[2],mx);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\ntypedef tuple<int, int, int> tiii;\n\nstruct Random {\n\tint a, b, C, M;\n\tRandom(int A, int B) : a(A), b(B), C(~(1 << 31)), M((1 << 16) - 1) { }\n\tint operator()(){\n\t\ta = 36969 * (a & M) + (a >> 16);\n\t\tb = 18000 * (b & M) + (b >> 16);\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint m, n, A, B;\n\t\tcin >> m >> n >> A >> B;\n\t\tif(m == 0 && n == 0 && A == 0 && B == 0){ break; }\n\t\tn += m;\n\t\tvector<tiii> p(n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tRandom random(A, B);\n\t\tfor(int i = m; i < n; ++i){\n\t\t\tconst int x = random();\n\t\t\tconst int y = random();\n\t\t\tconst int z = random();\n\t\t\tp[i] = tiii(x, y, z);\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tvector< map<int, int> > vm(n + 1);\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < n; ){\n\t\t\tconst int x = get<0>(p[i]);\n\t\t\tvector<tiii> t;\n\t\t\twhile(i < n && get<0>(p[i]) == x){\n\t\t\t\tconst int y = get<1>(p[i]);\n\t\t\t\tconst int z = get<2>(p[i]);\n\t\t\t\tint l = 0, r = n;\n\t\t\t\twhile(l < r){\n\t\t\t\t\tconst int c = l + (r - l) / 2;\n\t\t\t\t\tauto it = vm[c].lower_bound(y);\n\t\t\t\t\tif(it == vm[c].begin()){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else if((--it)->second >= z){\n\t\t\t\t\t\tr = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = c + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.emplace_back(l, y, z);\n\t\t\t\tanswer = max(answer, l + 1);\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tfor(const auto &e : t){\n\t\t\t\tconst int k = get<0>(e);\n\t\t\t\tconst int y = get<1>(e);\n\t\t\t\tconst int z = get<2>(e);\n\t\t\t\tauto it = vm[k].lower_bound(y);\n\t\t\t\tif(it->first == y && it->second < z){ continue; }\n\t\t\t\twhile(it != vm[k].end()){\n\t\t\t\t\tif(it->second < z){ break; }\n\t\t\t\t\tvm[k].erase(it++);\n\t\t\t\t}\n\t\t\t\tvm[k].insert(make_pair(y, z));\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <limits>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1 << 28;\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\ninline bool shouldInsert(set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound(v);\n    if (upper == st.begin()) {\n        return true;\n    } else {\n        upper--;\n        return upper->first != v.first and upper->second != v.second;\n    }\n}\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, -INF});\n    for (; lower != st.end() and lower->second >= v.second;) {\n        lower = st.erase(lower);\n    }\n    if (shouldInsert(st, v)) {\n        st.insert(v);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int M, N, A, B;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        int a = A;\n        int b = B;\n        const auto gen = [&]() {\n            constexpr int C = ~(1 << 31);\n            constexpr int M = (1 << 16) - 1;\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            return (C & ((a << 16) + b)) % 1000000;\n        };\n        const auto comp = [](const PP& pp1, const PP& pp2) {\n            return pp1.first != pp2.first ? pp1.first < pp2.first : pp1.second > pp2.second;\n        };\n        vector<PP> p(M + N);\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[i] = {x, {y, z}};\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[i] = {x, {y, z}};\n        }\n        sort(p.begin(), p.end(), comp);\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (int i = 0; i < M + N; i++) {\n            int inf = -1;\n            int sup = N + M + 1;\n            while (sup - inf > 1) {\n                const int mid = (sup + inf) / 2;\n                if (check(tail[mid], p[i].second)) {\n                    inf = mid;\n                } else {\n                    sup = mid;\n                }\n            }\n            insertAndErase(tail[sup], p[i].second);\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\ntypedef long long LL;\nint num[50000010], a[1000010], h[1000010], tot;\nint A, B, C = ~(1<<31), M = (1<<16)-1;\nint myRand() {\n  A = 36969 * (A & M) + (A >> 16);\n  B = 18000 * (B & M) + (B >> 16);\n  return (C & ((A << 16) + B)) % 1000000;\n}\nint N, NN;\nstruct V {\n\tint x, y, z;\n\tbool operator < (const V &t) const {\n\t\treturn x < t.x;\n\t}\n}v[300010];\nint yn, zn;\nstd::map<LL, int> node;\nvoid genNode() {\n\tnode.clear();\n\ttot = 0;\n\tfor(int i = 0; i < N; i ++) {\n\t\tfor(int y = v[i].y; y <= yn; y += y & -y) {\n\t\t\tfor(int z = v[i].z; z <= zn; z += z & -z) {\n\t\t\t\tLL k = y * 1000000ll + z;\n\t\t\t\tif(!node[k]) {\n\t\t\t\t\tnode[k] = ++ tot;\n\t\t\t\t\ta[tot] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = v[i].y - 1; y > 0; y -= y & -y) {\n\t\t\tfor(int z = v[i].z - 1; z > 0; z -= z & -z) {\n\t\t\t\tLL k = y * 1000000ll + z;\n\t\t\t\tif(!node[k]) {\n\t\t\t\t\tnode[k] = ++ tot;\n\t\t\t\t\ta[tot] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid update(int y, int z, int v) {\n\tfor(int i = y; i <= yn; i += i & -i) {\n\t\tfor(int j = z; j <= zn; j += j & -j) {\n\t\t\tint k = node[i * 1000000ll + j];\n\t\t\ta[k] = std::max(a[k], v);\n\t\t}\n\t}\n}\nint query(int y, int z) {\n\tint max = 0;\n\tfor(int i = y; i > 0; i -= i & -i) {\n\t\tfor(int j = z; j > 0; j -= j & -j) {\n\t\t\tint k = node[i * 1000000ll + j];\n\t\t\tmax = std::max(max, a[k]);\n\t\t}\n\t}\n\treturn max;\n}\nvoid process() {\n\tint ans = 0;\n\tfor(int i = 0; i < N; i ++) {\n\t\tans = std::max(ans, query(v[i].y - 1, v[i].z - 1) + 1);\n\t\tupdate(v[i].y, v[i].z, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\nint main() {\n\t//freopen(\"test.in\", \"rb\", stdin);\n\twhile(scanf(\"%d%d%d%d\", &N, &NN, &A, &B), N + NN > 0) {\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tscanf(\"%d%d%d\", &v[i].x, &v[i].y, &v[i].z);\n\t\t}\n\t\tfor(int i = 0; i < NN; i ++) {\n\t\t\tv[N].x = myRand();\n\t\t\tv[N].y = myRand();\n\t\t\tv[N].z = myRand();\n\t\t\t++ N;\n\t\t}\n\t\tstd::sort(v, v + N);\n\t\t// yn\n\t\tyn = 0;\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\ta[yn ++] = v[i].y;\n\t\t\tif(v[i].y > 0) {\n\t\t\t\ta[yn ++] = v[i].y - 1;\n\t\t\t}\n\t\t}\n\t\tstd::sort(a, a + yn);\n\t\tyn = std::unique(a, a + yn) - a;\n\t\tfor(int i = 0; i < yn; i ++) {\n\t\t\th[a[i]] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tv[i].y = h[v[i].y];\n\t\t}\n\t\t// zn\n\t\tzn = 0;\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\ta[zn ++] = v[i].z;\n\t\t\tif(v[i].z > 0) {\n\t\t\t\ta[zn ++] = v[i].z - 1;\n\t\t\t}\n\t\t}\n\t\tstd::sort(a, a + zn);\n\t\tzn = std::unique(a, a + zn) - a;\n\t\tfor(int i = 0; i < zn; i ++) {\n\t\t\th[a[i]] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < N; i ++) {\n\t\t\tv[i].z = h[v[i].z];\n\t\t}\n\t\tgenNode();\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n  \treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n\tint x, y, z;\n\tPoint(int x, int y, int z) : x(x), y(y), z(z) {}\n\tPoint(){}\n\tbool operator < (const Point &a) const {\n\t\treturn (x == a.x ? y == a.y ? z < a.z : y < a.y : x < a.x);\n\t}\n};\n\nstruct Point2 {\n\tint y, z;\n\tPoint2(int y, int z) : y(y), z(z) {}\n\tPoint2(){}\n\tbool operator < (const Point2 &a) const {\n\t\treturn (y < a.y);\n\t}\n};\n\nint main()\n{\n\tint m, n, A, B;\n\n\twhile (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && m + n){\n\t\ta = A; b = B;\n\t\tvector<Point> v(m + n);\n        vector<set<Point2>> s(m + n);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\t\tv[i] = Point(x, -y, -z);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tv[i + m] = Point(x, -y, -z);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n        int ans = 1;\n        s[0].insert(Point2(-v[0].y, -v[0].z));\n        for (int i = 1; i < m + n; i++){\n            v[i].y = -v[i].y; v[i].z = -v[i].z;\n            int lf = -1, rg = ans - 1;\n            while (lf != rg){\n                int mid = (lf + rg + 1) / 2;\n                auto it = s[mid].lower_bound(Point2(v[i].y, v[i].z)); --it;\n                if (it->y < v[i].y && it->z < v[i].z) lf = mid;\n                else rg = mid - 1;\n            }\n            rg++;\n            ans = max(ans, rg + 1);\n            if (rg >= 0 && s[rg].size()){\n                auto it = s[rg].lower_bound(Point2(v[i].y, v[i].z));\n                while (it != s[rg].end() && it->z >= v[i].z){\n                    auto it2 = it;\n                    it2++;\n                    s[rg].erase(it);\n                    it = it2;\n                }\n            }\n            if (rg >= 0) s[rg].insert(Point2(v[i].y, v[i].z));\n        }\n        printf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto print=[&](const set<P> &sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](const set<P> &sp){\n      return;\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      veri(dp[k]);\n      auto it=dp[k].lower_bound(P(p.first,-1));\n      if(it!=dp[k].begin()) --it;\n      //if(it!=dp[k].begin()&&it->first>=p.first) --it;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      veri(dp[k]);\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n      \n      veri(dp[k]);\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      //veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nconst int IINF = INT_MAX;\n\nstruct Point3d {\n  int x,y,z;\n  bool operator < ( const Point3d &p ) const {\n    if( z != p.z ) return z < p.z;\n    if( y != p.y ) return y > p.y;\n    return x > p.x;\n  }\n};\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\n\nconst int MAX = 300010;\nint m,n,A,B;\nPoint3d ps[MAX];\nset<ii> dp[MAX];\n\nbool check(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second < v.second ){\n    if( (*it).first < v.first ) return true;\n    --it;\n  }\n  return false;\n}\n\nvoid update(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second >= v.second ){\n    dp[index].erase(it++);\n  }\n  dp[index].insert(v);\n}\n\nvoid compute(){\n  rep(i,m+n+1) {\n    dp[i].clear();\n    dp[i].insert(ii(-1,IINF));\n    dp[i].insert(ii(IINF,-1));\n  }\n  dp[0].insert(ii(-1,-1));\n\n  sort(ps,ps+m+n);\n  vector<ii> vec;\n  rep(i,n+m) vec.push_back(ii(ps[i].y,ps[i].x));\n\n  //rep(i,n+m) cout << ps[i].x << \",\" << ps[i].y << \",\" << ps[i].z << endl;\n\n  int maxi = 0;\n  rep(i,n+m){\n    int low = 0, hig = n+m;\n    while( hig - low ) {\n      int mid = ( low + hig ) / 2;\n      if( check(mid,vec[i]) ) low = mid + 1;\n      else                    hig = mid;\n    }\n    maxi = max(maxi,low);\n    update(low,vec[i]);\n  }\n  printf(\"%d\\n\",maxi+1);\n}\n\nint main(){\n  while( scanf(\"%d %d %d %d\",&m,&n,&A,&B), m|n|A|B ){\n    a = A, b = B;\n    rep(i,m) scanf(\"%d %d %d\",&ps[i].x,&ps[i].y,&ps[i].z);\n    rep(i,n) {\n      ps[m+i].x = r();\n      ps[m+i].y = r();\n      ps[m+i].z = r();\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Generator{\n    int a, b, C, M;\n    Generator(int A, int B){\n        a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    }\n    int generate() {\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nconst int INF = 100000000;\ntypedef pair<int, int> Point;\n\nvoid insert(int x, int y, set<Point>& s){\n    const Point np(x, y);\n    auto itr = s.lower_bound(np);\n    if((--itr)->second <= y) return ;\n    itr++;\n    vector<Point> removes;\n    while(itr->second >= y){\n        removes.push_back(*itr);\n        itr++;\n    }\n    for(Point p : removes){\n        s.erase(p);\n    }\n    s.insert(np);\n    /*\n    for(auto p : s){\n        printf(\"(%d, %d) \", p.first, p.second);\n    }\n    cout << endl;\n    */\n}\n\nint main(){\n    int M, N, A, B;\n    const int MAX = 1000000;\n    while(cin >> M >> N >> A >> B && (M + N) != 0){\n        vector<vector<Point>> rect(MAX);\n        for(int i = 0; i < M; i++){\n            int x;\n            Point p;\n            cin >> x >> p.first >> p.second;\n            rect[x].push_back(p);\n        }\n        Generator gen(A, B);\n        for(int i = 0; i < N; i++){\n            Point p;\n            int x = gen.generate();\n            p.first = gen.generate();\n            p.second = gen.generate();\n            rect[x].push_back(p);\n        }\n\n        vector<set<Point>> sets(MAX + 1);\n        for(auto& s : sets){\n            s.insert(Point(INF, -1));\n            s.insert(Point(-1, INF));\n        }\n\n        int answer = 0;\n        for(vector<Point> points : rect){\n            vector<pair<int, Point>> querys;\n            for(const Point& p : points){\n                int x = p.first, y = p.second;\n                int l = -1, r = answer + 1;\n                while(r - l > 1){\n                    int c = (l + r) / 2;\n                    auto itr = sets[c].lower_bound(Point(x, -INF));\n                    if((--itr)->second < y){\n                        l = c;\n                    }else{\n                        r = c;\n                    }\n                }\n                querys.emplace_back(r, p);\n                answer = max(answer, r + 1);\n            }\n            for(const auto& query : querys){\n                int k = query.first;\n                Point p = query.second;\n                //printf(\"%d (%d, %d)\\n\", k, p.first, p.second);\n                insert(p.first, p.second, sets[k]);\n            }\n        }\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[1209], qy[1209], t[1209][1209], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n) * 0.85 + 1;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint A,B,C = ~(1<<31), M = (1<<16)-1;\n\nint r(){\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri,P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi-1,nw.se));\n    if(it != st[cri].begin()){\n        --it;\n        return it->se < nw.se;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m;\n        cin >> m >> n >> A >> B;\n        rep(i,n+m+1){\n            st[i].clear();\n        }\n        rep(i,1000000){\n            v[i].clear();\n        }\n        if(n == 0 && m == 0 && A == 0 && B == 0){\n            break;\n        }\n        rep(i,m){\n            int s,t,u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t,u));\n        }\n        rep(i,n){\n            v[r()].pb(P(r(),r()));\n        }\n        int mx = -1;\n        rep(i,1000000){\n            if(len(v[i])){\n                sort(all(v[i]),[&](const P& p,const P& q){\n                    return (p.fi==q.fi)?(p.se>q.se):(p.fi>q.fi);\n                });\n                each(it,v[i]){\n                    int l = -1,r = mx+1;\n                    while(r-l>1){\n                        int mid = (l+r)/2;\n                        if(contain(mid,it)){\n                            l = mid;\n                        }else{\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if(it2 != st[r].begin()){\n                        --it2;\n                        if(it2->se <= it.se){\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while(1){\n                        if(it2 != st[r].end()){\n                            if(it2->se >= it.se){\n                                it2 = st[r].erase(it2);\n                            }else{\n                                cmx(mx,r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        }else{\n                            cmx(mx,r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx+1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n \nint n;\n \nstruct tup{\n    int x, y, z;\n}a[300005];\n \nmap<int,int> mp[300005];\nint dp[300005];\n \nbool input(){\n    int m, nn, A, B;\n    scanf(\"%d %d %d %d\",&m,&nn,&A,&B);\n    if(m + nn + A + B == 0) return 0;\n    n = m + nn;\n    for(int i=1; i<=m; i++){\n        scanf(\"%d %d %d\",&a[i].x,&a[i].y,&a[i].z);\n    }\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    for(int i=m+1; i<=n; i++){\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].x = (C & ((a << 16) + b)) % 1000000;\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].y = (C & ((a << 16) + b)) % 1000000;\n      a = 36969 * (a & M) + (a >> 16);\n      b = 18000 * (b & M) + (b >> 16);\n      ::a[i].z = (C & ((a << 16) + b)) % 1000000;\n    }\n    for(int i=0; i<=n; i++){\n        mp[i].clear();\n    }\n    return 1;\n}\n \nbool trial(int m, int y, int z){\n    auto it = mp[m].lower_bound(y);\n    if(it == mp[m].begin()) return 0;\n    it--;\n    return (z > it->second);\n}\n \n\nvoid add(int x, int y, int z){\n\tauto it = mp[x].lower_bound(y);\n\tauto it2 = mp[x].upper_bound(y);\n\tif(it2 != mp[x].begin()){\n\t\tit2--;\n\t\tif(it2->second <= z) return;\n\t}\n\twhile(it != mp[x].end() && it->second >= z){\n\t\tmp[x].erase(it);\n\t\tit = mp[x].lower_bound(y);\n\t}\n\tmp[x].insert(make_pair(y, z));\n}\n\nvoid solve(){\n    sort(a + 1, a + n + 1, [&](const tup &a, const tup &b){\n        return a.x < b.x;\n    });\n    mp[0].insert(make_pair(-1, -1));\n    for(int i=1; i<=n;){\n        int e = i;\n        while(e <= n && a[e].x == a[i].x) e++;\n        for(int j=i; j<e; j++){\n            int s = 0, e = i;\n            while(s != e){\n                int m = (s+e+1) / 2;\n                if(trial(m, a[j].y, a[j].z)) s = m;\n                else e = m-1;\n            }\n            dp[j] = s + 1;\n        }\n        for(int j=i; j<e; j++){\n            add(dp[j], a[j].y, a[j].z);\n        }\n        i = e;\n    }\n    printf(\"%d\\n\",*max_element(dp+1,dp+n+1));\n}\n \nint main(){\n    while(input()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tclass node {\n\tpublic:\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\n\tvoid del(node *t) {\n\t\tif (!t) return;\n\t\tdel(t->l);\n\t\tdel(t->r);\n\t\tdelete t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\tdel(root);\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.7e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\nusing namespace std;\n\n\n\nnamespace _RMQ{\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\nclass SparseSegtree{\n\tstruct Node{\n\t\tint height;\n\t\tpair<int,int>  key;\n\t\tint value, rangev;\n\n\t\tNode *left,*right;\n\t\tint size;\n\t\tNode(pair<int,int> k,int v)\n\t\t\t:height(1),key(k),value(v),rangev(v),left(0),right(0),size(1){}\n\t\t~Node(){\n\t\t\tif(left)delete left;\n\t\t\tif(right)delete right;\n\t\t}\n\t\tNode *rotate_right(){\n\t\t\tNode *s=left;\n\t\t\tleft=s->right;\n\t\t\ts->right=this;\n\t\t\treturn s;\n\t\t}\n\t\tNode *rotate_left(){\n\t\t\tNode *s=right;\n\t\t\tright=s->left;\n\t\t\ts->left=this;\n\t\t\treturn s;\n\t\t}\n\n\t\tint query(int a,int b,int l,int r)const{\n\t\t\tif(!this||r<=a||b<=l)return nil;\n\t\t\tif(a<=l&&r<=b)return rangev;\n\t\t\tint res=func(left->query(a,b,l,key.first+1),right->query(a,b,key.first,r));\n\t\t\tif(a<=key.first&&key.first<b)res=func(res,value);\n\t\t\treturn res;\n\t\t}\n\t\tNode *insert(pair<int,int> k,int v){\n\t\t\tif(!this)return new Node(k,v);\n\t\t\tif(k < key){\n\t\t\t\tleft = left->insert(k,v);\n\t\t\t}else{\n\t\t\t\tright = right->insert(k,v);\n\t\t\t};\n\t\t\treturn balance();\n\t\t}\n\t\tNode *erase(pair<int,int> k){\n\t\t\tif(!this)return NULL;\n\t\t\tif(k==key){\n\t\t\t\tNode *le=left,*ri=right;\n\t\t\t\tleft=right=NULL;\n\t\t\t\tdelete this;\n\t\t\t\tif(!le)return ri;\n\t\t\t\tif(!ri)return le;\n\t\t\t\tNode *t;\n\t\t\t\tle = le->erase_max(&t);\n\t\t\t\tt->left = le;\n\t\t\t\tt->right = ri;\n\t\t\t\treturn t->balance();\n\t\t\t}\n\t\t\tif(k < key){\n\t\t\t\tleft = left->erase(k);\n\t\t\t}else if(key < k){\n\t\t\t\tright = right->erase(k);\n\t\t\t}else return this;\n\t\t\treturn balance();\n\t\t}\n\n\t\tNode *balance(){\n\t\t\tint bf = (right?right->height:0)-(left?left->height:0);\n\t\t\tif(2==bf){\n\t\t\t\tNode *t=right;\n\t\t\t\tif((t->right?t->right->height:0) < (t->left?t->left->height:0)){\n\t\t\t\t\tright = t->rotate_right();\n\t\t\t\t}\n\t\t\t\treturn rotate_left()->update();\n\t\t\t}else if(bf==-2){\n\t\t\t\tNode *t=left;\n\t\t\t\tif((t->right?t->right->height:0) > (t->left?t->left->height:0)){\n\t\t\t\t\tleft = t->rotate_left();\n\t\t\t\t}\n\t\t\t\treturn rotate_right()->update();\n\t\t\t}\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tNode *update(){\n\t\t\tif(left)left->updates();\n\t\t\tif(right)right->updates();\n\t\t\tupdates();\n\t\t\treturn this;\n\t\t}\n\t\tvoid updates(){\n\t\t\tupdate_height();\n\t\t\tupdate_size();\n\t\t\tupdate_value();\n\t\t}\n\t\tvoid update_value(){\n\t\t\trangev=value;\n\t\t\tif(left)rangev=func(rangev,left->rangev);\n\t\t\tif(right)rangev=func(rangev,right->rangev);\n\t\t}\n\t\tvoid update_height(){\n\t\t\tif(!this)return;\n\t\t\tif(right){\n\t\t\t\tif(left && right->height < left->height)height=left->height+1;\n\t\t\t\telse height=right->height+1;\n\t\t\t}else if(left)height=left->height+1;\n\t\t\telse height=1;\n\t\t}\n\t\tvoid update_size(){\n\t\t\tif(!this)return;\n\t\t\tsize = 1 + (left?left->size:0) + (right?right->size:0);\n\t\t}\n\t\tNode* erase_max(Node **maxnode){\n\t\t\tif(right){\n\t\t\t\tright = right->erase_max(maxnode);\n\t\t\t\treturn balance();\n\t\t\t}else{\n\t\t\t\t*maxnode=this;\n\t\t\t\treturn left;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tint calc_max_key()const{\n\t\tNode *p=root;\n\t\tif(!p)return -1;\n\t\twhile(p->right)p=p->right;\n\t\treturn p->key.first;\n\t}\n\tint max_key;\npublic:\n\tSparseSegtree():root(0),max_key(-1){}\n\t~SparseSegtree(){if(root)delete root;}\n\tvoid insert(pair<int,int> k,int v){\n\t\tmax_key=max(max_key,k.first);\n\t\troot=root->insert(k,v);\n\t}\n\tvoid erase(pair<int,int> k){\n\t\troot=root->erase(k);\n\t\tif(k.first==max_key)max_key=calc_max_key();\n\t}\n\tint query(int a,int b)const{//[a,b)\n\t\treturn root->query(a,b,0,max_key+1);\n\t}\n\tint size()const{\n\t\treturn root?root->size:0;\n\t}\n\tint height()const{\n\t\treturn root?root->height:0;\n\t}\n};\n\n};\n\n\ntemplate<int XSIZE=1<<20>\nclass Dynamic2DRMQ{\n\tstruct Node{\n\t\t_RMQ::SparseSegtree rmq;\n\t\tNode *left,*right;\n\t\tNode():left(0),right(0){}\n\t\t~Node(){\n\t\t\tdelete left;\n\t\t\tdelete right;\n\t\t}\n\t\tint query(int a,int b,int l,int r,int ys,int ye)const{\n\t\t\tif(!this||r<=a||b<=l)return _RMQ::nil;\n\t\t\tif(a<=l&&r<=b)return rmq.query(ys,ye);\n\t\t\treturn _RMQ::func(left->query(a,b,l,(l+r)/2,ys,ye),right->query(a,b,(l+r)/2,r,ys,ye));\n\t\t}\n\t\tvoid insert(int x,int y,int v,int l,int r){\n\t\t\trmq.insert(make_pair(y,x),v);\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tif(!left)left=new Node();\n\t\t\t\tleft->insert(x,y,v,l,(l+r)/2);\n\t\t\t}else{\n\t\t\t\tif(!right)right=new Node();\n\t\t\t\tright->insert(x,y,v,(l+r)/2,r);\n\t\t\t}\n\t\t}\n\t\tvoid erase(int x,int y,int l,int r){\n\t\t\trmq.erase(make_pair(y,x));\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tleft->erase(x,y,l,(l+r)/2);\n\t\t\t\tif(left->rmq.size()==0){\n\t\t\t\t\tdelete left;\n\t\t\t\t\tleft=0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tright->erase(x,y,(l+r)/2,r);\n\t\t\t\tif(right->rmq.size()==0){\n\t\t\t\t\tdelete right;\n\t\t\t\t\tright=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tNode *root;\npublic:\n\tDynamic2DRMQ():root(new Node()){}\n\t~Dynamic2DRMQ(){delete root;}\n\tvoid insert(int x,int y,int v){\n\t\troot->insert(x,y,v,0,XSIZE);\n\t}\n\tvoid erase(int x,int y){\n\t\troot->erase(x,y,0,XSIZE);\n\t}\n\tint query(int xs,int xe,int ys,int ye){//[xs,xe)*[ys,ye)\n\t\treturn root->query(xs,xe,0,XSIZE,ys,ye);\n\t}\n};\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ<> rmq2d;\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(0,v[i].second.first,0,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  C = ~(1<<31);\n  M = (1<<16)-1;\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<19);\n    dp[0].insert(make_tuple(-1,-1));\n    auto p = equal_range(begin(v),end(v),make_tuple(-1,0,0));\n    REP(i,1000001) {\n      vector<tuple<int,int,int>> add;\n      vector<tuple<int,int,int>> er;\n      while(p.second != end(v) && get<0>(*p.second) <= i) ++p.second;\n      for(;p.first != p.second; ++p.first) {\n        int y,z;\n        tie(ignore,y,z) = *p.first;\n        int k=1<<18;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          int py,pz;\n          tie(py, pz) = *prev(itr);\n          if (py == y || pz <= z) continue;\n        }\n        while(itr != end(dp[j]) && get<1>(*itr) >= z) {\n          er.emplace_back(j,get<0>(*itr),get<1>(*itr));\n          ++itr;\n        }\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(add),end(add));\n      add.erase(unique(begin(add),end(add)),end(add));\n      vector<tuple<int,int,int>>::iterator\n        itr = begin(add), eitr = begin(add);\n      while(eitr != end(add)) {\n        while(eitr != end(add) &&\n            get<0>(*eitr) == get<0>(*itr)) ++eitr;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*itr);\n        for(; itr != eitr; ++itr) {\n          int y,z;\n          tie(ignore,y,z) = *itr;\n          if (tp.empty() || (get<0>(tp.back()) < y && get<1>(tp.back()) > z)) {\n            tp.emplace_back(y,z);\n          }\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n      sort(begin(er),end(er));\n      er.erase(unique(begin(er),end(er)),end(er));\n      for (auto r:er) {\n        int j,y,z;\n        tie(j,y,z) = r;\n        dp[j].erase(make_tuple(y,z));\n      }\n    }\n    int maxl = 0;\n    REP(i,1<<19) {\n      if(!dp[i].empty()) {\n        maxl = i;\n      }\n    }\n    cout<<maxl<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nint A,B,C = ~(1<<31), M = (1<<16)-1;\n\nint r(){\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri,P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi-1,nw.se));\n    if(it != st[cri].begin()){\n        --it;\n        return it->se < nw.se;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m;\n        cin >> m >> n >> A >> B;\n        rep(i,n+m+1){\n            st[i].clear();\n        }\n        rep(i,1000000){\n            v[i].clear();\n        }\n        if(n == 0 && m == 0 && A == 0 && B == 0){\n            break;\n        }\n        rep(i,m){\n            int s,t,u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t,u));\n        }\n        rep(i,n){\n            v[r()].pb(P(r(),r()));\n        }\n        int mx = -1;\n        rep(i,1000000){\n            if(len(v[i])){\n                sort(all(v[i]),[&](const P& p,const P& q){\n                    return (p.fi==q.fi)?(p.se>q.se):(p.fi>q.fi);\n                });\n                each(it,v[i]){\n                    int l = -1,r = mx+1;\n                    while(r-l>1){\n                        int mid = (l+r)/2;\n                        if(contain(mid,it)){\n                            l = mid;\n                        }else{\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if(it2 != st[r].begin()){\n                        --it2;\n                        if(it2->se <= it.se){\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while(1){\n                        if(it2 != st[r].end()){\n                            if(it2->se >= it.se){\n                                it2 = st[r].erase(it2);\n                            }else{\n                                cmx(mx,r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        }else{\n                            cmx(mx,r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx+1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 300005\nusing namespace std;\nint n , m , a , b;\nint C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n    int x , y , z;\n    bool operator < (const Point& R) const {\n        return x < R.x;\n    }\n}p[N];\nstruct query {\n    int x , y , z , id;\n    query () {}\n    query (int _x , int _y , int _z , int _id) {\n        x = _x , y = _y , z = _z , id = _id;\n    }\n    bool operator < (const query& R) const {\n        if (y != R.y) return y < R.y;\n        if (id != R.id) return id > R.id;\n        return z < R.z;\n    }\n}t[N];\nint cnt , D , d[N];\nint f[N] , c[N] , g[N];\nvoid add(int* c , int x , int w) {\n    for ( ; x <= D ; x += x & -x)\n        c[x] = max(c[x] , w);\n}\nint get(int* c , int x) {\n    int res = 0;\n    for ( ; x > 0 ; x -= x & -x)\n        res = max(res , c[x]);\n    return res;\n}\nvoid clr(int* c , int x) {\n    for ( ; x <= D ; x += x & -x)\n        c[x] = 0;\n}\nvoid solve(int l , int r)\n{\n    if (l >= r) return;\n    int mid = (l + r) >> 1 , tx = p[mid + 1].x;\n    solve(l , mid);\n    cnt = 0;\n    for (int i = l ; i <= r ; ++ i)\n        t[cnt ++] = query(p[i].x , p[i].y , p[i].z , i);\n    sort(t , t + cnt);\n    for (int i = 0 ; i < cnt ; ++ i)\n        if (t[i].id <= mid) {\n            add(c , t[i].z , f[t[i].id]);\n            if (t[i].x != tx)\n                add(g , t[i].z , f[t[i].id]);\n        } else {\n            if (t[i].x != tx)\n                f[t[i].id] = max(f[t[i].id] , get(c , t[i].z - 1) + 1);\n            else\n                f[t[i].id] = max(f[t[i].id] , get(g , t[i].z - 1) + 1);\n        }\n    for (int i = 0 ; i < cnt ; ++ i)\n        if (t[i].id <= mid)\n            clr(c , t[i].z) , clr(g , t[i].z);\n    solve(mid + 1 , r);\n}\n\nvoid work() {\n    int i ; D = 0;\n    for (i = 1 ; i <= m ; ++ i)\n        scanf(\"%d%d%d\",&p[i].x,&p[i].y,&p[i].z);\n    for (i = m + 1 ; i <= m + n ; ++ i)\n        p[i].x = r() , p[i].y = r() , p[i].z = r();\n    n += m , sort(p + 1 , p + 1 + n);\n    for (i = 1 ; i <= n ; ++ i)\n        f[i] = 1 , d[D ++] = p[i].z;\n    sort(d , d + D) , D = unique(d , d + D) - d;\n    for (i = 1 ; i <= n ; ++ i)\n        p[i].z = lower_bound(d , d + D , p[i].z) - d + 1;\n    solve(1 , n);\n    int ans = 0;\n    for (i = 1 ; i <= n ; ++ i)\n        ans = max(ans , f[i]);\n    printf(\"%d\\n\" , ans);\n}\n\nint main() {\n    while (scanf(\"%d%d%d%d\",&m,&n,&a,&b) , n || m || a || b)\n        work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"-O3\")\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(type l, type r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<cstdlib>\n#include<map>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int> mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int>::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it!=mp.end()&&it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\n\t\t\ts=it;\n\t\t\t++s;\n\t\t}else if(it!=mp.begin()){\n\t\t\ts=it;\n\t\t\tif((--it)->second>=v)return;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}else{\n\t\t\ts=it;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}\n\t\te=s;\n\t\twhile(e!=mp.end()&&e->second<=v)++e;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int>::const_iterator it;\n\t\tit=mp.lower_bound(xe);\n\t\tif(it==mp.begin())return nil;\n\t\treturn (--it)->second;\n\t}\n};\n\n\nclass Dynamic2DRMQ_BIT{\n\tstd::vector<SparseRMQ*> bit;\npublic:\n\tDynamic2DRMQ_BIT(int xsize):bit(xsize+1,0){}\n\t~Dynamic2DRMQ_BIT(){\n\t\tfor(int i=0;i<(int)bit.size();i++)\n\t\t\tif(bit[i])delete bit[i];\n\t}\n\tvoid insert(int x,int y,int v){\n\t\tx++;\n\t\twhile(x<(int)bit.size()){\n\t\t\tif(!bit[x])bit[x]=new SparseRMQ();\n\t\t\tbit[x]->insert(y,v);\n\t\t\tx+= x&-x;\n\t\t}\n\t}\n\tint query(int xe,int ye)const{//[0,xe)*[0,ye)\n\t\tint res=nil;\n\t\twhile(0<xe){\n\t\t\tif(bit[xe])res=func(res,bit[xe]->max(ye));\n\t\t\txe-= xe&-xe;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ_BIT rmq2d(2000000);\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\t~segtree() {\n\t\tif (N > 1) { delete lch; delete rch; }\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\t~segtree_2d() {\n\t\tif (H > 1) { delete lch; delete rch; }\n\t\tX.clear();\n\t\tdelete st;\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(100), x[i] = dc(100), w[i] = dc(100);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tM = 0;\n\t\tN = 300000;\n\t\tA = dc(1, 1<<16);\n\t\tB = dc(1, 1<<16);\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tif (!(M + N)) break;\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tdelete st;\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.5;\n        // int sqn = 10000;\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            auto nsit = ns.begin();\n            vector<pair<int, int> > should_remove;\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    // cout << *nsit << \" \" << v << endl;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_remove.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\n                // ts[-it->first.second] = it->second;\nnext:;\n            }\n            vector<pair<pair<int, int>, int> > ncalced;\n            auto it = should_remove.begin();\n            REP(i, calced.size()) {\n                if (it != should_remove.end() && calced[i].first == *it) {\n                    it++;\n                    continue;\n                }\n                ncalced.push_back(calced[i]);\n            }\n            calced = ncalced;\n            // REP(i, 6) {\n            //     cout << anss[i] << \" \" ;\n            // }\n            // cout << endl;\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += sqn;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxe], g[maxn], ct[maxe];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    return make_pair(a.x, make_pair(a.y, a.z)) < make_pair(b.x, make_pair(b.y, b.z));\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(type l, type r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.9e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int r, node* t, int lb, int ub) {\n\t\tif (!t || r <= lb) return M::id();\n\t\tif (ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(r, t->l, lb, c);\n\t\tif (t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int r) {\n\t\treturn get(r, root, 0, n);\n\t}\n\tbool empty() {\n\t\treturn !root;\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(y));\n\t}\n\treturn res;\n}\n\nvoid del(int p) {\n\tif (segs[p].empty()) return;\n\tsegs[p].clear();\n\tif (p >= MAX) return;\n\tdel(p << 1);\n\tdel((p << 1) | 1);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\ttp.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define lp(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) lp(i, 0, n)\n#define fi first\n#define se second\n\nconst int INF = 1 << 28;\n\ntypedef pair<int, int> pr;\ntypedef tuple<int, int, int> tp;\n\nint a_, b_, C_ = ~(1<<31), M_ = (1<<16)-1;\nint r_() {\n  a_ = 36969 * (a_ & M_) + (a_ >> 16);\n  b_ = 18000 * (b_ & M_) + (b_ >> 16);\n  return (C_ & ((a_ << 16) + b_)) % 1000000;\n}\n\nvector<tp> ps;\n\nint solve()\n{\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\tsort(begin(ps), end(ps));\n\trep(i, ps.size()) get<1>(ps[i]) *= -1;\n\t\n\tvector<set<pr>> sts(ps.size() + 10);\n\tfor (auto &st : sts){\n\t\tst.insert(pr(-INF, INF));\n\t\tst.insert(pr(INF, -INF));\n\t}\n\t\n\tint res = 0;\n\trep(i, ps.size()){\n\t\tint x, y, z;\n\t\ttie(x, y, z) = ps[i];\n\t\tint l = 0, r = ps.size();\n\t\twhile (l + 1 < r){\n\t\t\tint m = (l + r) / 2;\n\t\t\tauto it = --sts[m].lower_bound(pr(y, -INF));\n\t\t\tif (it->se < z) l = m;\n\t\t\telse r = m;\n\t\t}\n\t\twhile (true){\n\t\t\tauto it = sts[r].lower_bound(pr(y, z));\n\t\t\tif (it->se < z) break;\n\t\t\tsts[r].erase(it);\n\t\t}\n\t\tsts[r].insert(pr(y, z));\n\t\tres = max(res, r);\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n >> a_ >> b_, m + n){\n\t\tps.clear();\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\trep(i, n){\n\t\t\tint x = r_();\n\t\t\tint y = r_();\n\t\t\tint z = r_();\n\t\t\tps.emplace_back(x, y, z);\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 300005\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n\nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n\nint x[MAX],y[MAX],z[MAX];\nset< P > t[MAX];\n\n\nvoid insert(set<P> &s,P p){\n  set<P> :: iterator it;\n  while(1){\n    it=s.upper_bound(p);\n    if(it==s.end())break;\n\n    if( p.first <= it->first &&\n        p.second <= it->second ){\n      s.erase(it);\n    }else{\n      break;\n    }\n  }\n  s.insert(p);\n}\n\nbool check(set<P> &s,P p){\n  set<P> :: iterator it;\n  it=s.upper_bound(p);\n  int cc=0;\n  while(it!=s.begin()){\n    cc++;\n    if(cc>3)break;\n\n    it--;\n    if(it->first < p.first)\n      if(it->second < p.second)\n        return true;\n  }\n  return false;\n}\n\nint calc(P p){\n  int left=0,right=m+n,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(t[mid],p))left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\n\nvector<P> G[1000005];\n\nint solve(){\n  int ans=1;\n\n  for(int i=0;i<=m+n;i++){\n    t[i].clear();\n  }\n  t[0].insert(P(-1,-1));\n  set<int> st;\n\n  for(int i=0;i<m+n;i++){\n    st.insert( z[i] );\n    G[ z[i] ].push_back( P(x[i],y[i]) );\n  }\n\n  for( int i : st ){\n    vector<int> v( G[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      v[j]=calc(G[i][j]);\n      ans=max(ans,v[j]);\n    }\n    for(int j=0;j<(int)G[i].size();j++){\n      insert(t[ v[j] ],G[i][j]);\n    }\n    G[i].clear();    \n  }\n  /*\n  for(int i=0;i<=ans;i++){\n    cout<<i<<\" :\"<<endl;\n    for(P p:t[i]){\n      cout<<p.first<<' '<<p.second<<endl;\n    }\n    cout<<endl;\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n\n    a=A,b=B;\n    \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n\n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint a,b,c=~(1<<31),M=(1<<16)-1;\n\nint r(){\n    a=36969*(a&M)+(a>>16);\n    b=18000*(b&M)+(a>>16);\n    return (c&((a<<16)+b))%1000000;\n}\n\nset<pair<int,int>> st[1010101];\nint main(){\n    int m,n;\n    while(cin>>m>>n>>a>>b,m+n!=0){\n        int l=m+n;\n        int x[l],y[l],z[l];\n        rep(i,m)cin>>x[i]>>y[i]>>z[i];\n        rep(i,n){\n            x[i+m]=r();\n            y[i+m]=r();\n            z[i+m]=r();\n        }\n        vector<int> ord(l);\n        rep(i,l)ord[i]=i;\n        sort(ord.begin(),ord.end(),[&](int s,int t){return x[s]==x[t] ? y[s]>y[t] : x[s]<x[t];});\n        rep(i,1000001){\n            if(st[i].size()==2)continue;\n            st[i].clear();\n            st[i].insert({inf,-inf});\n            st[i].insert({-inf,inf});\n        }\n        int ans=0;\n        for(auto i:ord){\n            int left=0,right=ans+1;\n            while(right-left>1){\n                int mid=(left+right)/2;\n                auto itr=--st[mid].lower_bound({y[i],0});\n                if(itr->second<z[i])left=mid;\n                else right=mid;\n            }\n            int ret=left+1;\n            ans=max(ret,ans);\n            auto itr=--st[ret].lower_bound({y[i],0});\n            if(z[i]>=itr->second)continue;\n            itr++;\n            while(itr->second>=z[i])itr=st[ret].erase(itr);\n            st[ret].insert({y[i],z[i]});\n        }\n        cout<<ans<<endl;\n    } \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned a , b , C = ~(1<<31), M = (1<<16)-1;\nvoid init(signed A,signed B){a=A;b=B;}\nsigned r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point{\n  Int x,y,z;\n  Point(){}\n  bool operator==(const Point &a)const{\n    return x==a.x&&y==a.y&&z==a.z;\n  }\n  bool operator<(const Point &a)const{\n    if(x!=a.x) return x<a.x;\n    if(y!=a.y) return y>a.y;\n    return z>a.z;\n  }\n};\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int m,n,A,B;\n  while(cin>>m>>n>>A>>B,m||n){\n    init(A,B);\n    \n    vector<Point> ps(m+n);\n    for(Int i=0;i<m;i++) cin>>ps[i].x>>ps[i].y>>ps[i].z;\n    for(Int i=m;i<m+n;i++){\n      ps[i].x=r();\n      ps[i].y=r();\n      ps[i].z=r();\n    }\n    n+=m;\n    sort(ps.begin(),ps.end());\n    using P = pair<Int, Int>;\n    vector<set<P> > dp(n+1);\n    \n    auto print=[&](const set<P> &sp){\n      for(auto p:sp) cout<<p.first<<\" \"<<p.second<<endl;\n      cout<<endl;\n    };\n    \n    auto veri=[&](const set<P> &sp){\n      P a(-1,1e7);\n      for(auto p:sp){\n\tassert(a.first<p.first);\n\tassert(a.second>p.second);\n\ta=p;\n      }\n    };\n    \n    auto check=[&](Int k,P p)->Int{\n      if(dp[k].empty()) return 0;\n      veri(dp[k]);\n      auto it=dp[k].lower_bound(p);\n      if(it!=dp[k].begin()) --it;\n      return it->first<p.first && it->second<p.second;\n    };\n    \n    auto push=[&](Int k,P p){\n      if(dp[k].count(p)) return;\n      dp[k].emplace(p);\n      \n      auto it=dp[k].lower_bound(p);\n      while(it!=dp[k].end()){\n\tauto uk=it;uk++;\n\tif(uk==dp[k].end()) break;\n\tif(it->second<=uk->second){\n\t  dp[k].erase(uk);\n\t  it=dp[k].lower_bound(p);\n\t  continue;\n\t}\n\tbreak;\n      }\n      while(it!=dp[k].begin()){\n\tauto uk=it;uk--;\n\tif(uk->second<=it->second){\n\t  it=dp[k].erase(it);\n\t  if(it==dp[k].end()) break;\n\t  continue;\n\t}\n\tbreak;\n      }\n      \n      veri(dp[k]);\n    };\n    \n    for(Int i=0;i<n;i++){\n      //cout<<ps[i].x<<\" \"<<ps[i].y<<\" \"<<ps[i].z<<endl;\n      \n      P p(ps[i].y,ps[i].z);\n      Int l=0,r=i+1;\n      while(l+1<r){\n\tInt m=(l+r)>>1;\n\tif(check(m,p)) l=m;\n\telse r=m;\n      }\n      push(l+1,p);\n      //veri(dp[l+1]);\n      \n      if(0){\n\tcout<<l+1<<endl;\n\tfor(int j=0;j<=n;j++){\n\t  cout<<j<<\":\"<<endl;\n\t  print(dp[j]);\n\t}\n      }\n    }\n    \n    Int ans=1;\n    while(ans<n&&!dp[ans+1].empty()) ans++;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint m,n,A,B;\nint x[300005],y[300005],z[300005];\nvector<int>zx,zy,zz;\nint a,b,C,M;\nint r(){\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\nvector<P>vec;\nstruct segtree{\n\tvector<int>seg[(1<<20)];\n\tvector<int>bit[(1<<20)];\n\tint cur = -INF;\n\tvoid init(int n){\n\t\tint k = 0;\n\t\twhile( (1<<k) <= n+5 ) k++;\n\t\tfor(int i=0;i<(2<<k);i++){\n\t\t\tseg[i].clear();\n\t\t\tbit[i].clear();\n\t\t}\n\t\tcur = k;\n\t}\n\tvoid pre(int a,int b){\n\t\ta += (1<<cur)-1;\n\t\tseg[a].pb(b);\n\t\twhile(a){\n\t\t\ta = (a-1)/2;\n\t\t\tseg[a].pb(b);\n\t\t}\n\t}\n\tvoid make_bit(){\n\t\tfor(int i=0;i<(2<<cur);i++){\n\t\t\tSORT(seg[i]); ERASE(seg[i]);\n\t\t\tbit[i].resize(seg[i].size()+2,0);\n\t\t}\n\t}\n\tint calc(int a,int b,int k,int l,int r,int v){\n\t\tif(r < a || b < l) return 0;\n\t\tif(a <= l && r <= b){\n\t\t\treturn calc_bit(k,v);\n\t\t}\n\t\tint L = calc(a,b,k*2+1,l,(l+r)/2,v);\n\t\tint R = calc(a,b,k*2+2,(l+r)/2+1,r,v);\n\t\treturn max(L,R);\n\t}\n\tint calc(int a,int b,int v){\n\t\treturn calc(a,b,0,0,(1<<cur)-1,v);\n\t}\n\tint f(int x){\n\t\treturn x&-x;\n\t}\n\tint calc_bit(int k,int val){\n\t\tint a = POSL(seg[k],val);\n\t\tint ret = 0;\n\t\tfor(int s=a;s>0;s-=f(s)){\n\t\t\tret = max(ret,bit[k][s]);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid upd_bit(int k,int pos,int val){\n\t\tint a = POSL(seg[k],pos);\n\t\tassert(seg[k][a] == pos);\n\t\tfor(int s=a+1;s<=seg[k].size();s+=f(s)){\n\t\t\tbit[k][s] = max(bit[k][s],val);\n\t\t}\n\t}\n\tvoid upd(int a,int b,int v){\n\t\ta += (1<<cur)-1;\n\t\tupd_bit(a,b,v);\n\t\twhile(a){\n\t\t\ta = (a-1)/2;\n\t\t\tupd_bit(a,b,v);\n\t\t}\n\t}\n}kaede;\nvector<P>query[300005];\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d\",&m,&n,&A,&B);\n\t\tif(m+n == 0) return 0;\n\t\ta = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n\t\tzx.clear(); zy.clear(); zz.clear();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tscanf(\"%d%d%d\",&x[i],&y[i],&z[i]);\n\t\t\tzx.pb(x[i]); zy.pb(y[i]); zz.pb(z[i]);\n\t\t}\n\t\tfor(int i=m+1;i<=n;i++){\n\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\tzx.pb(x[i]); zy.pb(y[i]); zz.pb(z[i]);\n\t\t}\n\t\tSORT(zx); ERASE(zx);\n\t\tSORT(zy); ERASE(zy);\n\t\tSORT(zz); ERASE(zz);\n\t\tkaede.init(m+n);\n\t\tfor(int i=0;i<zx.size();i++) query[i].clear();\n\t\tfor(int i=1;i<=m+n;i++){\n\t\t\tx[i] = POSL(zx,x[i]);\n\t\t\ty[i] = POSL(zy,y[i]);\n\t\t\tz[i] = POSL(zz,z[i]);\n\t\t\tquery[x[i]].pb(mp(y[i],z[i]));\n\t\t\tkaede.pre(y[i],z[i]);\n\t\t}\n\t\tkaede.make_bit();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<zx.size();i++){\n\t\t\tvector<int>vi;\n\t\t\tfor(int j=0;j<query[i].size();j++){\n\t\t\t\tP p = query[i][j];\n\t\t\t\tint a = kaede.calc(0,p.fi-1,p.sc);\n\t\t\t\tans = max(ans,a+1);\n\t\t\t\t//kaede.upd(p.fi,p.sc,a+1);\n\t\t\t\tvi.pb(a+1);\n\t\t\t}\n\t\t\tfor(int j=0;j<query[i].size();j++){\n\t\t\t\tP p = query[i][j];\n\t\t\t\tkaede.upd(p.fi,p.sc,vi[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n) / 3 * 2 + 1;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] >= x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (cury != r - l && y[py[j]] >= y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j <= r; j++) {\n\t\t\t\tfor (int k = l; k <= r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[gx[j]][gy[j]] = max(t[gx[j]][gy[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j <= r - l; j++) {\n\t\t\t\tfor (int k = 0; k <= r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] > x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] > y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (cly != l ? y[py[cly]] : 1 << 30), vr = (cry != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lowbit(x) ((x)&-(x))\nusing namespace std;\n\nconst int maxn = 300010, maxe = 1000010;\nconst int C = ~(1 << 31), M = (1 << 16) - 1;\nstruct node {int x, y, z;};\nstruct qry {int id, t, x, y, val;} q[maxe];\nint f[maxe], g[maxn], ct[maxn];\nnode d[maxn];\nint n, m, A, B, clk;\n\nbool cmp(const node &a, const node &b)\n{\n    if (a.x != b.x) return a.x < b.x;\n    if (a.y != b.y) return a.y > b.y;\n    return a.z > b.z;\n}\n\nbool cmp1(const qry &a, const qry &b)\n{\n    if (a.x == b.x) return a.t > b.t;\n    else return a.x < b.x;\n}\n\nvoid update(int u, int x)\n{\n    for (int i = u; i < maxe; i += lowbit(i))\n        if (ct[i] != clk)\n        {\n            ct[i] = clk;\n            f[i] = x;\n        }\n        else\n            f[i] = max(x, f[i]);\n}\n\nint query(int u)\n{\n    int ans = 0;\n    for (int i = u; i; i -= lowbit(i))\n        if (ct[i] == clk)\n            ans = max(ans, f[i]);\n    return ans;\n}\n\nint r()\n{\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nvoid solve(int l, int r)\n{\n    if (l == r)\n    {\n        g[l] = max(1, g[l]);\n        return;\n    }\n    int mid = (l + r) >> 1, cnt = 0;\n    solve(l, mid);\n    for (int i = l; i <= mid; ++i)\n        q[cnt++] = (qry) {i, 0, d[i].y, d[i].z, g[i]};\n    for (int i = mid + 1; i <= r; ++i)\n        q[cnt++] = (qry) {i, 1, d[i].y, d[i].z, 0};\n    sort(q, q + cnt, cmp1);\n    ++clk;\n    for (int i = 0; i < cnt; ++i)\n    {\n        if (!q[i].t) update(q[i].y, q[i].val);\n        else g[q[i].id] = max(g[q[i].id], query(q[i].y - 1) + 1);\n    }\n    solve(mid + 1, r);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    while (cin >> n >> m >> A >> B && n + m)\n    {\n        for (int i = 1; i <= n; ++i)\n            cin >> d[i].x >> d[i].y >> d[i].z;\n        for (int i = n + 1; i <= n + m; ++i)\n            d[i].x = r(), d[i].y = r(), d[i].z = r();\n        for (int i = 1; i <= n + m; ++i)\n            ++d[i].x, ++d[i].y, ++d[i].z;\n        sort(d + 1, d + n + m + 1, cmp);\n        memset(f, 0, sizeof(f));\n        memset(g, 0, sizeof(g));\n        memset(ct, 0, sizeof(ct));\n        clk = 0;\n        solve(1, n + m);\n        cout << *max_element(g + 1, g + 1 + n + m) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nll A,B,C = ~(1<<31), M = (1<<16)-1;\n\nll r(){\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nset<P> st[300005];\nvector<P> v[1000000];\n\nbool contain(int cri,P& nw)\n{\n    auto it = st[cri].lower_bound(P(nw.fi-1,nw.se));\n    if(it != st[cri].begin()){\n        --it;\n        return it->se < nw.se;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m;\n        cin >> m >> n >> A >> B;\n        rep(i,n+m+1){\n            st[i].clear();\n        }\n        rep(i,1000000){\n            v[i].clear();\n        }\n        if(n == 0 && m == 0 && A == 0 && B == 0){\n            break;\n        }\n        rep(i,m){\n            int s,t,u;\n            cin >> s >> t >> u;\n            v[s].pb(P(t,u));\n        }\n        rep(i,n){\n            v[r()].pb(P(r(),r()));\n        }\n        int mx = -1;\n        rep(i,1000000){\n            if(len(v[i])){\n                sort(all(v[i]),[&](const P& p,const P& q){\n                    return (p.fi==q.fi)?(p.se>q.se):(p.fi>q.fi);\n                });\n                each(it,v[i]){\n                    int l = -1,r = mx+1;\n                    while(r-l>1){\n                        int mid = (l+r)/2;\n                        if(contain(mid,it)){\n                            l = mid;\n                        }else{\n                            r = mid;\n                        }\n                    }\n                    auto it2 = st[r].upper_bound(it);\n                    if(it2 != st[r].begin()){\n                        --it2;\n                        if(it2->se <= it.se){\n                            continue;\n                        }\n                        ++it2;\n                    }\n                    while(1){\n                        if(it2 != st[r].end()){\n                            if(it2->se >= it.se){\n                                it2 = st[r].erase(it2);\n                            }else{\n                                cmx(mx,r);\n                                st[r].insert(it);\n                                break;\n                            }\n                        }else{\n                            cmx(mx,r);\n                            st[r].insert(it);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        cout << mx+1 << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n//typedef pair<P, int> Pint;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<20;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<P> p[1000000];\n \nvoid init(int m_){\n\tm0=1;\n\twhile(m0<m_) m0*=2;\n\tfor(int i=0; i<2*m0-1; i++){\n\t\tv[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n\t}\n  for(int x=0; x<m_; x++){\n    for(auto p0:p[x]){\n      int y=p0.first, z=p0.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, x));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, x));\n      }\n    }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n \nvoid update(int k, int i, int a){\n\ti+=(m[k]-1);\n\tv[k][i]=a;\n\twhile(i>0){\n\t\ti=(i-1)/2;\n\t\tv[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n\t}\n}\n\nvoid update0(int x, int y, int z, int a, int k, int l, int r){\n\tif(r<=y || y+1<=l) return;\n  int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, x))-v1[k].begin();\n  if(i<v1[k].size()){\n    update(k, i, a);\n  }\n  if(r-l>1){\n    update0(x, y, z, a, 2*k+1, l, (l+r)/2);\n    update0(x, y, z, a, 2*k+2, (l+r)/2, r);\n  }\n}\n\nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n\nint find0(int y, int z, int k, int l, int r){\n\tif(r<=0 || y<=l) return 0;\n\tif(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n\t\treturn find(k, i, 0, 0, m[k]);\n\t}else{\n\t\tint vl=find0(y, z, k*2+1, l, (l+r)/2);\n\t\tint vr=find0(y, z, k*2+2, (l+r)/2, r);\n\t\treturn max(vl, vr);\n\t}\n}\n\nint main()\n{\n\twhile(1){\n      int m, n, A, B;\n      cin>>m>>n>>A>>B;\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=b, C=~(1<<31), M=(1<<16)-1;\n      for(int x=0; x<1000000; x++){\n        p[x].clear();\n        vector<P>().swap(p[x]);\n      }\n      int mx=0;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        mx=max({mx, x, y, z});\n        p[x].push_back({y, z});\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        mx=max({mx, x, y, z});\n        p[x].push_back({y, z});\n      }\n      for(int x=0; x<mx+1; x++){\n        if(p[x].empty()) continue;\n        sort(p[x].begin(), p[x].end());\n        p[x].erase(unique(p[x].begin(), p[x].end()), p[x].end());\n      }\n      init(mx+1);\n      for(int x=0; x<mx+1; x++){\n        if(p[x].empty()) continue;\n        vector<int> mx;\n        for(auto p0:p[x]){\n          mx.push_back(find0(p0.first, p0.second, 0, 0, m0));\n        }\n        for(int i=0; i<mx.size(); i++){\n          update0(x, p[x][i].first, p[x][i].second, mx[i]+1, 0, 0, m0);\n        }\n      }\n      cout<<find0(mx+1, mx+1, 0, 0, m0)<<endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n#include <climits>\n#include <utility>\nusing namespace std;\n\nint rnd(int &a, int &b){\n\tstatic const int C = ~(1u << 31);\n\tstatic const int M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint main(){\n\tint m, n, a, b, x, y, z;\n\twhile(scanf(\"%d%d%d%d\", &m, &n, &a, &b), m | n){\n\t\tvector<array<int,3>> v(n + m);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tv[i][0] = x;\n\t\t\tv[i][1] = -y;\n\t\t\tv[i][2] = -z;\n\t\t}\n\t\tfor(int i = m; i < n + m; ++i){\n\t\t\tv[i][0] = rnd(a, b);\n\t\t\tv[i][1] = -rnd(a, b);\n\t\t\tv[i][2] = -rnd(a, b);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tvector<map<int,int>> mps(m + n + 3);\n\t\tmps[0][100] = 100;\n\t\tfor(int i = 0; i < m + n; ++i){\n\t\t\ty = v[i][1];\n\t\t\tz = v[i][2];\n\t\t\tint left = 1, right = ans + 1;\n\t\t\twhile(left < right){\n\t\t\t\tint mid = (left + right + 1) >> 1;\n\t\t\t\tconst auto &mp = mps[mid - 1];\n\t\t\t\tauto it = mp.upper_bound(y);\n\t\t\t\tif(it != mp.end() && it->second > z){\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint &t = mps[left].insert(make_pair(y, INT_MIN)).first->second;\n\t\t\tt = max(t, z);\n\t\t\tans = max(ans, left);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint a,b,C,M;\n\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nint main() {\n  C = ~(1<<31);\n  M = (1<<16)-1;\n  while(1){\n    int m,n,A,B;\n    cin>>m>>n>>A>>B;\n    if(!(m+n))break;\n    a=A;\n    b=B;\n    vector<tuple<int,int,int>> v;\n    REP(i,m){\n      int x,y,z;\n      cin>>x>>y>>z;\n      v.emplace_back(x,y,z);\n    }\n    REP(i,n){\n      int x=r(),y=r(),z=r();\n      v.emplace_back(x,y,z);\n    }\n    sort(begin(v),end(v));\n    vector<set<tuple<int,int>>> dp(1<<19);\n    dp[0].insert(make_tuple(-1,-1));\n    auto p = equal_range(begin(v),end(v),make_tuple(-1,0,0));\n    REP(i,1000000) {\n      vector<tuple<int,int,int>> add;\n      vector<tuple<int,int,int>> er;\n      while(p.second != end(v) && get<0>(*p.second) <= i) ++p.second;\n      for(;p.first != p.second; ++p.first) {\n        int y,z;\n        tie(ignore,y,z) = *p.first;\n        int k=1<<18;\n        int j=0;\n        while(k){\n          int nj=j+k;\n          auto itr = dp[nj].lower_bound(make_tuple(y,0));\n          if (itr != begin(dp[nj])) {\n            --itr;\n            if (get<1>(*itr) < z) j=nj;\n          }\n          k /= 2;\n        }\n        ++j;\n        auto itr = dp[j].lower_bound(make_tuple(y,z));\n        if (itr != begin(dp[j])) {\n          auto pitr = prev(itr);\n          if (get<0>(*pitr) == y || get<1>(*pitr) <= z) continue;\n        }\n        while(itr != end(dp[j]) && get<1>(*itr) >= z) {\n          er.emplace_back(j,get<0>(*itr),get<1>(*itr));\n          ++itr;\n        }\n        add.emplace_back(j,y,z);\n      }\n      sort(begin(add),end(add));\n      vector<tuple<int,int,int>>::iterator\n        itr = begin(add), eitr = begin(add);\n      while(eitr != end(add)) {\n        while(eitr != end(add) &&\n            get<0>(*eitr) == get<0>(*itr)) ++eitr;\n        vector<tuple<int,int>> tp;\n        int j = get<0>(*itr);\n        for(; itr != eitr; ++itr) {\n          int y,z;\n          tie(ignore,y,z) = *itr;\n          if (tp.empty() || (get<0>(tp.back()) != y && get<1>(tp.back()) > z))\n            tp.emplace_back(y,z);\n        }\n        for(auto r:tp) {\n          dp[j].insert(r);\n        }\n      }\n      sort(begin(er),end(er));\n      er.erase(unique(begin(er),end(er)),end(er));\n      for (auto r:er) {\n        int j,y,z;\n        tie(j,y,z) = r;\n        dp[j].erase(make_tuple(y,z));\n      }\n    }\n    REP(i,1<<19) {\n      if(dp[i].empty()) {\n        cout << (i - 1) << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Longest Chain\n//Level: 4\n//Category: 最長増加列,Longest Increasing Sequence,LIS,SegmentTree\n//Note: \n\n/**\n * 基本的には二次元版のマトリョーシカDP（半順序上の最長増加列問題）と同じように、x座標の順で点を挿入しながらSegmentTreeで最適解を管理すればよい。\n * ここでは残りの次元が2になるので、二次元平面上で、kd木のように平面を4分割して管理するSegmentTreeを実装する。\n * ただし、メモリが足りないので必要なノードだけ作る。\n * また、点数に比べて座標が大きいので、座標圧縮するとオーダーが減らせる。\n * こうするとN+M個の点それぞれについて、高々(log(N+M))^2個のノードが作られるので、メモリ使用量はO((N+M) (log N+M)^2)となる。\n *\n * オーダーは O((N+M) (log (N+M))^2)。\n */\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <array>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Allocator {\n    T *buf;\n    const int size_;\n    int pos_;\n\n    Allocator(size_t s) : buf(new T[s]), size_(s), pos_(0) {}\n    ~Allocator() {\n        delete[] buf;\n    }\n\n    T* operator ()() {\n        assert(pos_ < size_);\n        return &buf[pos_++];\n    }\n};\n\ntemplate<typename T>\nstruct SegmentTree {\n    struct Node {\n        T val, buf;\n        Node *children[4];\n        Node() : val(0), buf(0) {\n            fill_n(children, 4, nullptr);\n        }\n    };\n\n    Node root;\n    int size;\n    int qxl_, qxr_, qyl_, qyr_; // for querying\n    Allocator<Node> allocator_;\n    SegmentTree(int size) : size(size), allocator_(1000000) {}\n\n    T update_inner(Node *cur, int xl, int xr, int yl, int yr, T val, int idx) {\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(cur->children[idx] == nullptr) {\n            cur->children[idx] = allocator_();\n        }\n        return update(cur->children[idx], xl, xr, yl, yr, max(cur->buf, val));\n    }\n\n    T update(Node *cur, int xl, int xr, int yl, int yr, T val) {\n        assert(cur);\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            cur->buf = max(cur->buf, val);\n            return max(cur->val, cur->buf);\n        }\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        cur->val = max(cur->val, update_inner(cur, xl, xm, yl, ym, val, 0));\n        cur->val = max(cur->val, update_inner(cur, xl, xm, ym, yr, val, 1));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, yl, ym, val, 2));\n        cur->val = max(cur->val, update_inner(cur, xm, xr, ym, yr, val, 3));\n        return cur->val;\n    }\n\n    T update(int xl, int xr, int yl, int yr, T val) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return update(&root, 0, size, 0, size, val);\n    }\n\n    T query(Node *cur, int xl, int xr, int yl, int yr, T thresh) {\n        if(cur == nullptr) return 0;\n        if(qxl_ <= xl && xr <= qxr_ && qyl_ <= yl && yr <= qyr_) {\n            return max(cur->val, cur->buf);\n        }\n        if(xl >= qxr_ || xr <= qxl_ || yl >= qyr_ || yr <= qyl_) {\n            return 0;\n        }\n        if(max(cur->val, cur->buf) <= thresh) return thresh;\n\n        const int xm = (xl + xr) / 2;\n        const int ym = (yl + yr) / 2;\n        T val = 0;\n        val = max(val, query(cur->children[0], xl, xm, yl, ym, val));\n        val = max(val, query(cur->children[1], xl, xm, ym, yr, val));\n        val = max(val, query(cur->children[2], xm, xr, yl, ym, val));\n        val = max(val, query(cur->children[3], xm, xr, ym, yr, val));\n        return val;\n    }\n\n    T query(int xl, int xr, int yl, int yr) {\n        qxl_ = xl;\n        qxr_ = xr;\n        qyl_ = yl;\n        qyr_ = yr;\n        return query(&root, 0, size, 0, size, 0);\n    }\n};\n\nnamespace myrand {\n    int a, b, C, M;\n    void init(int av, int bv) {\n        a = av;\n        b = bv;\n        C = ~(1<<31);\n        M = (1<<16) - 1;\n    }\n\n    int r() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    }\n};\n\nbool solve(bool first) {\n    int M, N, A, B;\n    if(!(cin >> M >> N >> A >> B)) return false;\n    if(!M && !N && !A && !B) return false;\n\n    map<int,int> dict;\n    vector<tuple<int,int,int>> ps;\n    for(int i = 0; i < M; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        ps.emplace_back(x, y, z);\n        dict[x] = 0;\n        dict[y] = 0;\n        dict[z] = 0;\n    }\n\n    myrand::init(A, B);\n    for(int i = 0; i < N; ++i) {\n        const int x = myrand::r();\n        const int y = myrand::r();\n        const int z = myrand::r();\n        ps.emplace_back(x, y, z);\n        dict[x] = 0;\n        dict[y] = 0;\n        dict[z] = 0;\n    }\n    {\n        int cnt = 0;\n        for(auto &e : dict) {\n            e.second = cnt++;\n        }\n        for(auto &p : ps) {\n            int x, y, z;\n            tie(x, y, z) = p;\n            p = make_tuple(dict[x], dict[y], dict[z]);\n        }\n    }\n    sort(begin(ps), end(ps));\n\n    SegmentTree<int> seg(300000);\n    map<pair<int,int>,int> memo;\n    int prevx = -1;\n    for(const auto &p : ps) {\n        const int x = get<0>(p);\n        const int y = get<1>(p);\n        const int z = get<2>(p);\n        if(x != prevx) {\n            for(const auto &m : memo) {\n                seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n            }\n            memo.clear();\n            prevx = x;\n        }\n        const int m = seg.query(0, y, 0, z);\n        const auto key = make_pair(y, z);\n        memo[key] = max(memo[key], m+1);\n    }\n    for(const auto &m : memo) {\n        seg.update(m.first.first, m.first.first+1, m.first.second, m.first.second+1, m.second);\n    }\n    cout << seg.query(0, 300000, 0, 300000) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r(){\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\nconst int maxn = 3e5 + 5;\nconst int maxm = 1e6 + 5;\n\nstruct node{int x, y, z;} arry[maxn];\nint ans, n, m, A, B, f[maxn], rnk[maxn];\n\nbool cmp1(node i, node j){\n    if(i.x != j.x) return i.x < j.x;\n    if(i.y != j.y) return i.y < j.y;\n    return i.z < j.z;\n}\nbool cmp2(int i, int j){\n    if(arry[i].y != arry[j].y) return arry[i].y < arry[j].y;\n    else return i < j;\n}\n\nint bitt[maxm], vist[maxm], nowt;\nint lowbit(int i){return i & (-i);}\nint query(int pos){\n    int rtn = 0;\n    for(int i = pos; i >= 1; i -= lowbit(i)){\n        if(vist[i] == nowt) rtn = max(rtn, bitt[i]);\n    }\n    return rtn;\n}\nvoid modify(int pos, int val){\n    for(int i = pos; i <= m; i += lowbit(i)){\n        if(vist[i] == nowt) bitt[i] = max(bitt[i], val);\n        else{\n            bitt[i] = val;\n            vist[i] = nowt;\n        }\n    }\n}\n\nvoid devide(int left, int rght){\n    \n    if(left >= rght) return; \n    int mid = (left + rght) >> 1;\n    devide(left, mid);\n    for(int i = left; i <= rght; ++i) rnk[i] = i;\n    sort(rnk + left, rnk + rght + 1, cmp2);\n    ++nowt;\n    for(int i = left; i <= rght; ++i){\n        int j = rnk[i], v = arry[j].z;\n        if(j <= mid) modify(v, f[j]);\n        else f[j] = max(f[j], query(v - 1) + 1);\n    }\n    devide(mid + 1, rght); // \n}\n\nint work(){\n    \n    a = A, b = B; // \n    ans = 0;\n    for(int i = 1; i <= m; ++i) scanf(\"%d%d%d\", &arry[i].x, &arry[i].y, &arry[i].z);\n    for(int i = 1; i <= n; ++i){\n        arry[m+i].x = r();\n        arry[m+i].y = r();\n        arry[m+i].z = r();\n    }\n    n = m + n, m = 0;\n    for(int i = 1; i <= n; ++i) f[i] = 1; // \n    for(int i = 1; i <= n; ++i) arry[i].z += 2; // \n    for(int i = 1; i <= n; ++i) m = max(m, arry[i].z);\n    sort(arry + 1, arry + n + 1, cmp1);\n    devide(1, n);\n    for(int i = 1; i <= n; ++i) ans = max(ans, f[i]);\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    \n    while(true){\n        scanf(\"%d%d%d%d\", &m, &n, &A, &B);\n        if(m + n + A + B == 0) break;\n        work();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 6e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\nint m, n, a, b;\n\nstruct P {\n\tint x, y, z;\n\tP() {}\n\tP(int x, int y, int z) : x(x), y(y), z(z) {}\n\tbool operator< (const P& l) const {\n\t\tif (x != l.x) return x < l.x;\n\t\tif (y != l.y) return y > l.y;\n\t\treturn z > l.z;\n\t}\n};\n\nint r() {\n\tconst int C = ~(1 << 31), M = (1 << 16) - 1;\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nbool C(map<int, P>& polyline, const P& p) {\n\tmap<int, P>::iterator it = polyline.lower_bound(p.y);\n\tif (it == polyline.begin()) return true;\n\tit--;\n\treturn it->second.z >= p.z;\n}\n\nvoid insert_polyline(vector<map<int, P> >& polyline, const P& p) {\n\tint l = -1, r = sz(polyline);\n\twhile (r - l != 1) {\n\t\tint md = (l + r) / 2;\n\t\tbool ok = C(polyline[md], p);\n\t\tif (ok) r = md;\n\t\telse l = md;\n\t}\n\tif (sz(polyline) == r) polyline.emplace_back();\n\tif (polyline[r].find(p.y) != polyline[r].end() && polyline[r][p.y].z <= p.z) return;\n\tpolyline[r][p.y] = p;\n\tmap<int, P>::iterator it = polyline[r].find(p.y);\n\t++it;\n\twhile (it != polyline[r].end()) {\n\t\tif (it->second.z < p.z) break;\n\t\tpolyline[r].erase(it++);\n\t}\n}\n\nint main() {\n\tint cnt = 0;\n\twhile (cin >> m >> n >> a >> b, m || n || a || b) {\n\t\tcnt++;\n\t\tvector<P> v;\n\t\tFOR(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tv.emplace_back(x, y, z);\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tv.emplace_back(x, y, z);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n\t\tvector<map<int, P> > polyline;\n\t\tFOR(i, sz(v)) {\n\t\t\tinsert_polyline(polyline, v[i]);\n\t\t}\n\n\t\tcout << sz(polyline) << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 300005\nint m,n,A,B;\nint a,b,C=~(1<<31),M=(1<<16)-1;\n\nint r() {\n  a = 36969 * (a&M) + (a>>16);\n  b = 18000 * (b&M) + (b>>16);\n  return (C&((a<<16)+b))%1000000;\n}\n\nint x[MAX],y[MAX],z[MAX];\nset< P > t[MAX];\n\n\nvoid insert(set<P> &s,P p){\n  set<P> :: iterator it;\n  while(1){\n    it=s.upper_bound(p);\n    if(it==s.end())break;\n\n    if( p.first <= it->first &&\n        p.second <= it->second ){\n      s.erase(it);\n    }else{\n      break;\n    }\n  }\n  s.insert(p);\n}\n\nbool check(set<P> &s,P p){\n  set<P> :: iterator it;\n  it=s.upper_bound(p);\n  int cc=0;\n  while(it!=s.begin()){\n    cc++;\n    if(cc>3)break;\n\n    it--;\n    if(it->first < p.first)\n      if(it->second < p.second)\n        return true;\n  }\n  return false;\n}\n\nint calc(P p){\n  int left=0,right=m+n,mid;\n  while(left<right){\n    mid=(left+right)/2;\n    if(check(t[mid],p))left=mid+1;\n    else right=mid;\n  }\n  return left;\n}\n\n\nvector<P> G[1000005];\n\nint solve(){\n  int ans=1;\n\n  for(int i=0;i<=m+n;i++){\n    t[i].clear();\n  }\n  t[0].insert(P(-1,-1));\n  set<int> st;\n\n  for(int i=0;i<m+n;i++){\n    st.insert( z[i] );\n    G[ z[i] ].push_back( P(x[i],y[i]) );\n  }\n\n  for( int i : st ){\n    vector<int> v( G[i].size() );\n    for(int j=0;j<(int)G[i].size();j++){\n      v[j]=calc(G[i][j]);\n      ans=max(ans,v[j]);\n    }\n    for(int j=0;j<(int)G[i].size();j++){\n      if(check( t[ v[j] ] , G[i][j])==false)\n        insert(t[ v[j] ],G[i][j]);\n    }\n    G[i].clear();    \n  }\n  /*\n  for(int i=0;i<=ans;i++){\n    cout<<i<<\" :\"<<endl;\n    for(P p:t[i]){\n      cout<<p.first<<' '<<p.second<<endl;\n    }\n    cout<<endl;\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d\",&m,&n,&A,&B);\n    if(m==0&&n==0&&A==0&&B==0)break;\n\n    a=A,b=B;\n    \n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&x[i],&y[i],&z[i]);\n    }\n\n    for(int i=m;i<m+n;i++){\n      x[i]=r();\n      y[i]=r();\n      z[i]=r();\n    }\n    printf(\"%d\\n\",solve());\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nconst int IINF = INT_MAX;\n\nstruct Point3d {\n  int x,y,z;\n  bool operator < ( const Point3d &p ) const {\n    if( z != p.z ) return z < p.z;\n    if( y != p.y ) return y > p.y;\n    return x > p.x;\n  }\n};\n\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\n\nconst int MAX = 300010;\nint m,n,A,B;\nPoint3d ps[MAX];\nset<ii> dp[MAX];\n\nbool check(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  --it;\n  while(1){\n    if( (*it).second >= v.second ) break;\n    if( (*it).first  <  v.first  ) return true;\n    --it;\n  }\n  return false;\n}\n\nvoid update(int index,ii v){\n  set<ii>::iterator it = dp[index].lower_bound(v);\n  while( (*it).second >= v.second ){\n    dp[index].erase(it++);\n  }\n  dp[index].insert(v);\n}\n\nvoid compute(){\n  rep(i,m+n+1) {\n    dp[i].clear();\n    dp[i].insert(ii(-1,IINF));\n    dp[i].insert(ii(IINF,-1));\n  }\n  dp[0].insert(ii(-1,-1));\n\n  sort(ps,ps+m+n);\n  vector<ii> vec;\n  rep(i,n+m) vec.push_back(ii(ps[i].y,ps[i].x));\n\n  //rep(i,n+m) cout << ps[i].x << \",\" << ps[i].y << \",\" << ps[i].z << endl;\n\n  int maxi = 0;\n  rep(i,n+m){\n    int low = 0, hig = n+m;\n    while( hig - low ) {\n      int mid = ( low + hig ) / 2;\n      if( check(mid,vec[i]) ) low = mid + 1;\n      else                    hig = mid;\n    }\n    maxi = max(maxi,low);\n    update(low,vec[i]);\n  }\n  printf(\"%d\\n\",maxi+1);\n}\n\nint main(){\n  while( cin >> m >> n >> A >> B, m|n|A|B ){\n    a = A, b = B;\n    rep(i,m) scanf(\"%d %d %d\",&ps[i].x,&ps[i].y,&ps[i].z);\n    rep(i,n) {\n      ps[m+i].x = r();\n      ps[m+i].y = r();\n      ps[m+i].z = r();\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define MAXN 524288\n#define MAXC 1048576\n#define NO_VALUE -1\n\n#define LEFT(x) ( 2*(x) )\n#define RIGHT(x) ( 2*(x)+1 )\n\nint A, B, C, M;\n\nint r() {\n    A = 36969 * (A & M) + (A >> 16);\n    B = 18000 * (B & M) + (B >> 16);\n    return (C & ((A << 16) + B)) % 1000000;\n}\n\nint x[MAXN], y[MAXN], z[MAXN], ox[MAXN], val[MAXN], used[MAXC], stack[MAXN], ymap[MAXC], Y;\n\nbool cmp_x(const int &a, const int &b) {\n    if (x[a] != x[b]) return x[a] < x[b];\n    else if (y[a] != y[b]) return y[a] < y[b];\n    else return z[a] < z[b];\n}\n\nmap<int, int> bit[MAXC];\n\nint answer(int idx, int th) {\n    map<int, int>::iterator it = bit[idx].lower_bound(th);\n    if (it != bit[idx].begin()) return (--it)->second;\n    else return NO_VALUE;\n}\n\nint query(int idx, int th) {\n    int res = NO_VALUE;\n    while (idx > 0) {\n        res = max(res, answer(idx, th));\n        idx &= idx-1;\n    }\n    return res;\n}\n\nvoid update(int idx, int th, int v) {\n    map<int,int>::iterator it1, it2;\n    while (idx < Y) {\n        it1 = it2 = bit[idx].upper_bound(th);\n        while (it2 != bit[idx].end() && it2->second <= v) it2++;\n        bit[idx].erase(it1, it2);\n    \n        it1 = bit[idx].upper_bound(th);\n        if (it1 == bit[idx].begin() || (--it1)->second < v) bit[idx][th] = v;\n        idx += idx&(-idx);\n    }\n}\n\nint main() {\n    int m, n, i, j, N, t = 1, STACK;\n\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && (m || n || A || B)) {\n        C = ~(1<<31); M = (1<<16)-1;\n        for (i=0; i<m; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]);\n        for (i=m; i<m+n; i++) { x[i] = r(); y[i] = r(); z[i] = r(); }\n        N = m+n;\n\n        Y = 0;\n        for (i=0; i<N; i++) {\n            ox[i] = i;\n            if (used[y[i]] < t) { used[y[i]] = t; stack[Y++] = y[i]; }\n        }\n        sort(ox, ox+N, cmp_x);\n        sort(stack, stack+Y);\n        for (i=0; i<Y; i++) ymap[stack[i]] = i+1;\n        for (i=0; i<N; i++) y[i] = ymap[y[i]];\n        t++; Y++;\n\n        for (i=0; i<Y; i++) bit[i].clear();\n\n        i = 0;\n        do {\n            for (j=i; j<N && x[ox[j]]==x[ox[i]]; j++) val[ox[j]] = max(1, query(y[ox[j]]-1, z[ox[j]])+1);\n            for (; i<j; i++) update(y[ox[i]], z[ox[i]], val[ox[i]]);\n        } while (i < N);\n        printf(\"%d\\n\", query(Y-1, MAXC));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n  \treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nstruct Point {\n\tint x, y, z;\n\tPoint(int x, int y, int z) : x(x), y(y), z(z) {}\n\tPoint(){}\n\tbool operator < (const Point &a) const {\n\t\treturn (x == a.x ? y == a.y ? z > a.z : y > a.y : x < a.x);\n\t}\n};\n\nstruct Point2 {\n\tint y, z;\n\tPoint2(int y, int z) : y(y), z(z) {}\n\tPoint2(){}\n\tbool operator < (const Point2 &a) const {\n\t\treturn (y < a.y);\n\t}\n};\n\nint main()\n{\n\tint m, n, A, B;\n\n\twhile (scanf(\"%d %d %d %d\", &m, &n, &A, &B) && m + n){\n\t\ta = A; b = B;\n\t\tvector<Point> v(m + n);\n        vector<set<Point2>> s(m + n);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, z;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &z);\n\t\t\tv[i] = Point(x, y, z);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tv[i + m] = Point(x, y, z);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\n        int ans = 1;\n        s[0].insert(Point2(v[0].y, v[0].z));\n        for (int i = 1; i < m + n; i++){\n            int lf = -1, rg = ans - 1;\n            while (lf != rg){\n                int mid = (lf + rg + 1) / 2;\n                auto it = s[mid].lower_bound(Point2(v[i].y, v[i].z));\n                if (it != s[mid].begin() && (--it)->z < v[i].z) lf = mid;\n                else rg = mid - 1;\n            }\n            rg++;\n            ans = max(ans, rg + 1);\n\n            auto it = s[rg].lower_bound(Point2(v[i].y, v[i].z));\n            while (it != s[rg].end() && it->z >= v[i].z) it = s[rg].erase(it);\n\n            if (!s[rg].size()) s[rg].insert(Point2(v[i].y, v[i].z));\n            else {\n                auto it = s[rg].lower_bound(Point2(v[i].y, v[i].z));\n                if (it == s[rg].begin() || (--it)->z != v[i].z) s[rg].insert(Point2(v[i].y, v[i].z));\n            }\n        }\n        printf(\"%d\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, M, A, B, C = ~(1 << 31), D = 65535, lim = 1000001, x[300009], y[300009], z[300009], p[300009];\nvector<int> cp[1000009], bit[1000009];\nint func() {\n\tA = 36969 * (A & D) + (A >> 16);\n\tB = 18000 * (B & D) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\nvoid assign(int px, int py, int val) {\n\tfor (int i = px + 1; i <= lim; i += i & (-i)) {\n\t\tint ptr = lower_bound(cp[i].begin(), cp[i].end(), py) - cp[i].begin();\n\t\tfor (int j = ptr + 1; j <= cp[i].size(); j += j & (-j)) {\n\t\t\tbit[i][j - 1] = max(bit[i][j - 1], val);\n\t\t}\n\t}\n}\nint query(int px, int py) {\n\tint ret = 0;\n\tfor (int i = px; i >= 1; i -= i & (-i)) {\n\t\tint ptr = lower_bound(cp[i].begin(), cp[i].end(), py) - cp[i].begin();\n\t\tfor (int j = ptr; j >= 1; j -= j & (-j)) {\n\t\t\tret = max(ret, bit[i][j - 1]);\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d%d%d\", &N, &M, &A, &B), N + M) {\n\t\tfor (int i = 0; i < N; ++i) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\tfor (int i = 0; i < M; ++i) x[N] = func(), y[N] = func(), z[N] = func(), ++N;\n\t\tfor (int i = 0; i < N; ++i) p[i] = i;\n\t\tsort(p, p + N, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : y[i] > y[j]; });\n\t\tfor (int i = 0; i <= lim; i++) cp[i].clear();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = x[p[i]] + 1; j <= lim; j += j & (-j)) {\n\t\t\t\tcp[j].push_back(y[p[i]]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= lim; i++) {\n\t\t\tsort(cp[i].begin(), cp[i].end());\n\t\t\tcp[i].erase(unique(cp[i].begin(), cp[i].end()), cp[i].end());\n\t\t\tbit[i] = vector<int>(cp[i].size(), 0);\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint res = query(x[p[i]], y[p[i]]);\n\t\t\tassign(x[p[i]], y[p[i]], res + 1);\n\t\t\tret = max(ret, res + 1);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 300000 + 10;\n\nstruct Point {\n    int x, y, z;\n    Point() {}\n    Point(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}\n    bool operator < (const Point &rhs) const {\n        return x < rhs.x || (x == rhs.x && y < rhs.y) || (x == rhs.x && y == rhs.y && z < rhs.z);\n    }\n} P[MAXN];\n\nmap<int, int> best[MAXN];\nint dp[MAXN], ret;\n\nint r(int &a, int &b) {\n    static const int C = ~(1u << 31), M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const map<int, int> &mp, int x, int y) {\n    auto it = mp.lower_bound(x);\n    return it != mp.begin() && (-- it)->second < y;\n}\n\nint query(int x, int y) {\n    int left = 0, right = ret;\n    while (left < right) {\n        int mid = (left + right + 1) >> 1;\n        if (check(best[mid], x, y)) left = mid;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nvoid update(map<int, int> &mp, int x, int y) {\n    auto it = mp.upper_bound(x);\n    if (it != mp.begin() && (-- it)->second <= y) return;\n    it = mp.lower_bound(x);\n    while (it != mp.end() && it->second >= y) mp.erase(it ++);\n    mp[x] = y;\n}\n\nint main() {\n    int N, M, A, B;\n    while (scanf(\"%d%d%d%d\", &M, &N, &A, &B) == 4 && (N + M)) {\n        for (int i = 0; i < M; ++ i) {\n            scanf(\"%d%d%d\", &P[i].x, &P[i].y, &P[i].z);\n        }\n        N += M;\n        for (int i = M; i < N; ++ i) {\n            P[i].x = r(A, B);\n            P[i].y = r(A, B);\n            P[i].z = r(A, B);\n        }\n        for (int i = 0; i <= N; ++ i) best[i].clear();\n        sort(P, P + N);\n        ret = 0;\n        for (int i = 0, j; i < N;) {\n            for (j = i; j < N && P[i].x == P[j].x; ++ j) dp[j] = query(P[j].y, P[j].z) + 1;\n            for (; i < j; ++ i) {\n                update(best[dp[i]], P[i].y, P[i].z);\n                ret = max(ret, dp[i]);\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n\nusing namespace std;\nconst int MOD = 1000000007; // check!!!\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\n\nint m, n, A, B;\n\nstruct P {\n\tint x, y, z;\n\tP() {}\n\tP(int x, int y, int z) : x(x), y(y), z(z) {}\n\tbool operator< (const P& l) const {\n\t\tif (x != l.x) return x < l.x;\n\t\tif (y != l.y) return y > l.y;\n\t\treturn z > l.z;\n\t}\n};\n\nint r() {\n\tconst int C = ~(1 << 31);\n\tconst int M = (1 << 16) - 1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n\nbool C(map<int, P>& polyline, const P& p) {\n\tmap<int, P>::iterator it = polyline.lower_bound(p.y);\n\tif (it == polyline.begin()) return true;\n\tit--;\n\treturn it->second.z >= p.z;\n}\n\nvoid insert_polyline(vector<map<int, P> >& polyline, const P& p) {\n\tint l = -1, r = sz(polyline);\n\twhile (r - l != 1) {\n\t\tint md = (l + r) / 2;\n\t\tbool ok = C(polyline[md], p);\n\t\tif (ok) r = md;\n\t\telse l = md;\n\t}\n\tif (sz(polyline) == r) polyline.emplace_back();\n\n\tpolyline[r][p.y] = p;\n\tmap<int, P>::iterator it = polyline[r].find(p.y);\n\t++it;\n\twhile (true) {\n\t\tif (it == polyline[r].end()) break;\n\t\tauto nxt = it; ++nxt;\n\t\tif (it->second.z >= p.z) {\n\t\t\tpolyline[r].erase(it);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tit = nxt;\n\t}\n}\n\nint main() {\n\n\twhile (cin >> m >> n >> A >> B, m || n || A || B) {\n\t\tvector<P> v;\n\t\tFOR(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z;\n\t\t\tv.emplace_back(x, y, z);\n\t\t}\n\t\tFOR(i, n) {\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tv.emplace_back(x, y, z);\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tvector<map<int, P> > polyline;\n\t\tFOR(i, sz(v)) {\n\t\t\tinsert_polyline(polyline, v[i]);\n\t\t}\n\n\t\tcout << sz(polyline) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nint m[2*MAX_N-1];\nvector<Pint> p;\n  \nvoid init(int m_){\n    m0=1;\n    while(m0<m_) m0*=2;\n    for(int i=0; i<2*m0-1; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y+m0-1;\n      v1[i0].push_back(P(z, i));\n      while(i0>0){\n        i0=(i0-1)/2;\n        v1[i0].push_back(P(z, i));\n      }\n  }\n  for(int i=0; i<2*m0-1; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    m[i]=1;\n    while(m[i]<v1[i].size()) m[i]*=2;\n    for(int j=0; j<2*m[i]-1; j++){\n      if(j<m[i]-1) v[i].push_back(0);\n      else v[i].push_back(0);\n    }\n  }\n}\n  \nvoid update(int k, int i, int a){\n    i+=(m[k]-1);\n    v[k][i]=a;\n    while(i>0){\n        i=(i-1)/2;\n        v[k][i]=max(v[k][i*2+1], v[k][i*2+2]);\n    }\n}\n \nvoid update0(int i, int y, int z, int a, int k, int l, int r){\n    if(r<=y || y+1<=l) return;\n  int i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n  if(i0<v1[k].size()){\n    update(k, i0, a);\n  }\n  if(r-l>1){\n    if(l<=y && y<(l+r)/2){\n    \tupdate0(i, y, z, a, 2*k+1, l, (l+r)/2);\n    }else{\n    \tupdate0(i, y, z, a, 2*k+2, (l+r)/2, r);\n    }\n  }\n}\n \nint find(int k, int i, int k0, int l, int r){\n  if(r<=0 || i<=l) return 0;\n  if(0<=l && r<=i) return v[k][k0];\n  int vl=find(k, i, 2*k0+1, l, (l+r)/2);\n  int vr=find(k, i, 2*k0+2, (l+r)/2, r);\n  return max(vl, vr);\n}\n \nint find0(int y, int z, int k, int l, int r){\n    if(r<=0 || y<=l) return 0;\n    if(0<=l && r<=y){\n      if(v1[k].empty()) return 0;\n      int i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n      if(i==0) return 0;\n        return find(k, i, 0, 0, m[k]);\n    }else{\n        int vl=find0(y, z, k*2+1, l, (l+r)/2);\n        int vr=find0(y, z, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      scanf(\"%d %d %d %d\", &m, &n, &A, &B);\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      int mx=0;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n\t  int ind[300000];\n\t  for(int i=0; i<p.size(); i++) ind[i]=i;\n\t  sort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n\t  int ct=-1, pr=-1;\n\t  for(int i=0; i<p.size(); i++){\n\t\t  if(pr!=p[ind[i]].second.first){\n\t\t\t  pr=p[ind[i]].second.first;\n\t\t\t  ct++;\n\t\t\t  p[ind[i]].second.first=ct;\n\t\t  }else{\n\t\t\t  p[ind[i]].second.first=ct;\n\t\t  }\n\t  }\n      init(ct+1);\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z, 0, 0, m0))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1, 0, 0, m0);\n      }\n      printf(\"%d\\n\", find0(ct+1, 1000000, 0, 0, m0));\n      p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// implement 57 min\n// debug1 36min\n// debug2 ?\n// speed up ?\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <deque>\ntemplate <class T>\nostream &operator<<(ostream &os, const vector<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const deque<T> &rhs) {\n  os << \"[ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" ]\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const map<T, U> &rhs) {\n  os << \"{\" << endl;\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \",\" << endl; }\n    os << \"  \" << it->first << \" : \" << it->second;\n  }\n  os << endl << \"}\";\n  return os;\n}\ntemplate <class T>\nostream &operator<<(ostream &os, const set<T> &rhs) {\n  os << \"{ \";\n  FORIT(it, rhs) {\n    if (it != rhs.begin()) { os << \", \"; }\n    os << *it;\n  }\n  os << \" }\";\n  return os;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n  os << \"( \" << rhs.first << \", \" << rhs.second << \" )\";\n  return os;\n}\n\n\nint m, n, A, B;\nvector<int> ps[300000];\nint anss[300010];\n// map<pair<int, int>, int> calced;\nvector<pair<pair<int, int>, int> > calced;\n\nvoid generate() {\n    int a = A, b = B, C = ~(1<<31), M = (1<<16)-1;\n    REP(i, n) {\n        vector<int> p(3);\n        REP(j, 3) {\n            a = 36969 * (a & M) + (a >> 16);\n            b = 18000 * (b & M) + (b >> 16);\n            p[j] = (C & ((a << 16) + b)) % 1000000;\n        }\n        ps[m + i] = p;\n    }\n    n += m;\n    m = n;\n}\n\nint main() {\n    while (scanf(\"%d %d %d %d\", &m, &n, &A, &B) > 0 && m + n > 0) {\n        REP(i, n + m) { ps[i].clear(); }\n        MEMSET(anss, -1);\n        calced.clear();\n        calced.push_back(make_pair(make_pair(1e+9, 1e+9), 0));\n        calced.push_back(make_pair(make_pair(-1e+9, -1e+9), 0));\n        REP(i, m) {\n            int x, y, z;\n            int v = scanf(\"%d %d %d\", &x, &y, &z);\n            assert(v == 3);\n            ps[i] = { x, y, z };\n        }\n        generate();\n        sort(ps, ps + n);\n        // REP(i, n) {\n        //     cout << i << \" \" << ps[i][1] << \" \" << ps[i][2] << endl;\n        // }\n        n = unique(ps, ps + n) - ps;\n        int sqn = sqrt(n) * 1.3;\n        // int sqn = 1;\n        // int sqn = 10000;\n        sqn = max(sqn, 1);\n        int offset = 0;\n        while (offset < n) {\n            // calc end block\n            int M = min(sqn, n - offset);\n            while (offset + M < n && ps[offset + M - 1][0] == ps[offset + M][0]) { M++; }\n            vector<pair<pair<int, int>, int> > ns;\n            REP(i, M) {\n                int pos = offset + i;\n                ns.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), offset + i));\n                anss[offset + i] = 1;\n            }\n            sort(ns.begin(), ns.end());\n            map<int, int> ts;\n\n            // calc ans without end block\n            vector<pair<int, int> > should_removed;\n            auto nsit = ns.begin();\n            FORIT(it, calced) {\n                // cout << ts << endl;\n                while (nsit != ns.end() && nsit->first.first <= it->first.first) {\n                    int v = 1;\n                    auto target = ts.upper_bound(-nsit->first.second);\n                    if (target != ts.end()) {\n                        v = target->second + 1;\n                    }\n                    anss[nsit->second] = v;\n                    nsit++;\n                }\n                if (nsit == ns.end()) { break; }\n                auto target = ts.end();\n                while (true) {\n                    target = ts.upper_bound(-it->first.second);\n                    if (target == ts.end()) { break; }\n                    if (target->second >= it->second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    }\n                    if (target == ts.begin()) { break; }\n                    target--;\n                    if (target->second <= it->second) {\n                        ts.erase(target);\n                    } else if (target->first == -it->first.second) {\n                        should_removed.push_back(it->first);\n                        goto next;\n                    } else {\n                        break;\n                    }\n                }\n                ts.insert(target, make_pair(-it->first.second, it->second));\nnext:;\n            }\n            if (should_removed.size() > 1) {\n                vector<pair<pair<int, int>, int> > ncalced;\n                auto it = should_removed.begin();\n                REP(i, calced.size()) {\n                    if (it != should_removed.end() && calced[i].first == *it) {\n                        it++;\n                        continue;\n                    }\n                    ncalced.push_back(calced[i]);\n                }\n                swap(calced, ncalced);\n            }\n\n            // calc ans with end block\n            REP(i, M) {\n                int pos = offset + i;\n                REP(j, i) {\n                    int ppos = offset + j;\n                    if (ps[ppos][0] == ps[pos][0]) { break; }\n                    if (ps[ppos][1] < ps[pos][1] && ps[ppos][2] < ps[pos][2]) {\n                        anss[pos] = max(anss[pos], anss[ppos] + 1);\n                    }\n                }\n                calced.push_back(make_pair(make_pair(ps[pos][1], ps[pos][2]), anss[pos]));\n            }\n            sort(calced.begin(), calced.end());\n            // cout << calced << endl;\n\n            offset += M;\n        }\n        int ans = 0;\n        REP(i, n) { ans = max(ans, anss[i]); }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, A, B, x[300009], y[300009], z[300009], p[300009], dp[300009], px[300009], py[300009], gx[300009], gy[300009], qx[609], qy[609], t[609][609], tp[300009];\nint rng() {\n\tA = 36969 * (A & 65535) + (A >> 16);\n\tB = 18000 * (B & 65535) + (B >> 16);\n\treturn (2147483647 & ((A << 16) + B)) % 1000000;\n}\nint main() {\n\twhile (scanf(\"%d %d %d %d\", &n, &m, &A, &B), A) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &x[i], &y[i], &z[i]), p[i] = i;\n\t\tfor (int i = 0; i < m; i++) x[n] = rng(), y[n] = rng(), z[n] = rng(), p[n] = n, n++;\n\t\tsort(p, p + n, [](int i, int j) { return z[i] != z[j] ? z[i] < z[j] : i > j; });\n\t\tfor (int i = 0; i < n; i++) z[i] = x[p[i]];\n\t\tfor (int i = 0; i < n; i++) x[i] = z[i];\n\t\tfor (int i = 0; i < n; i++) z[i] = y[p[i]];\n\t\tfor (int i = 0; i < n; i++) y[i] = z[i];\n\t\tint b = sqrt(n);\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tint l = i * n / b, r = (i + 1) * n / b;\n\t\t\tfor (int j = l; j < r; j++) qx[j - l] = j, qy[j - l] = j;\n\t\t\tsort(qx, qx + r - l, [](int v1, int v2) { return x[v1] < x[v2]; });\n\t\t\tsort(qy, qy + r - l, [](int v1, int v2) { return y[v1] < y[v2]; });\n\t\t\tint curx = 0, cury = 0;\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && x[px[j]] < x[qx[curx]]) curx++;\n\t\t\t\tgx[px[j]] = curx;\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\twhile (curx != r - l && y[py[j]] < y[qy[cury]]) cury++;\n\t\t\t\tgy[py[j]] = cury;\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tfor (int k = l; k < r; k++) {\n\t\t\t\t\tt[j - l][k - l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < l; j++) {\n\t\t\t\tt[px[j]][py[j]] = max(t[px[j]][py[j]], dp[j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < r - l; j++) {\n\t\t\t\tfor (int k = 0; k < r - l; k++) {\n\t\t\t\t\tif (j >= 1) t[j][k] = max(t[j][k], t[j - 1][k]);\n\t\t\t\t\tif (k >= 1) t[j][k] = max(t[j][k], t[j][k - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = l; j < r; j++) {\n\t\t\t\tint lx = 0, ly = 0;\n\t\t\t\twhile (lx < r - l && x[j] <= x[qx[lx]]) lx++;\n\t\t\t\twhile (ly < r - l && y[j] <= y[qy[ly]]) ly++;\n\t\t\t\tdp[j] = max(t[lx][ly] + 1, 1);\n\t\t\t\tfor (int k = l; k < j; k++) {\n\t\t\t\t\tif (x[k] < x[j] && y[k] < y[j]) {\n\t\t\t\t\t\tdp[j] = max(dp[j], dp[k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint clx = 0, crx = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? x[px[clx]] : 1 << 30), vr = (crx != r ? x[qx[crx - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = px[clx++];\n\t\t\t\telse tp[j] = qx[(crx++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) px[j] = tp[j];\n\t\t\tint cly = 0, cry = l;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tint vl = (clx != l ? y[py[clx]] : 1 << 30), vr = (crx != r ? y[qy[cry - l]] : 1 << 30);\n\t\t\t\tif (vl < vr) tp[j] = py[cly++];\n\t\t\t\telse tp[j] = qy[(cry++) - l];\n\t\t\t}\n\t\t\tfor (int j = 0; j < r; j++) py[j] = tp[j];\n\t\t}\n\t\tprintf(\"%d\\n\", *max_element(dp, dp + n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cstdlib>\n#include<map>\n#include<cassert>\nusing namespace std;\n\n\n\n\nconst int nil=0;\nint func(int a,int b){\n\treturn max(a,b);\n}\n\n\n\nclass SparseRMQ{\n\tmap<int,int> mp;\npublic:\n\tvoid insert(int x,int v){\n\t\tmap<int,int>::iterator it,s,e;\n\t\tit=mp.lower_bound(x);\n\t\tif(it!=mp.end()&&it->first==x){\n\t\t\tif(v<=it->second)return;\n\t\t\tit->second=v;\n\t\t\ts=it;\n\t\t\t++s;\n\t\t}else if(it!=mp.begin()){\n\t\t\ts=it;\n\t\t\tif((--it)->second>=v)return;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}else{\n\t\t\ts=it;\n\t\t\tmp.insert(it,make_pair(x,v));\n\t\t}\n\t\te=s;\n\t\twhile(e!=mp.end()&&e->second<=v)++e;\n\t\tmp.erase(s,e);\n\t}\n\tint max(int xe)const{//(-inf,xe)\n\t\tmap<int,int>::const_iterator it;\n\t\tit=mp.lower_bound(xe);\n\t\tif(it==mp.begin())return nil;\n\t\treturn (--it)->second;\n\t}\n};\n\n\n\n\ntemplate<int XSIZE=1<<20>\nclass Dynamic2DRMQ{\n\tstruct Node{\n\t\tSparseRMQ rmq;\n\t\tNode *left,*right;\n\t\tNode():left(0),right(0){}\n\t\t~Node(){\n\t\t\tdelete left;\n\t\t\tdelete right;\n\t\t}\n\t\tint query(int a,int b,int l,int r,int ye)const{\n\t\t\tif(!this||r<=a||b<=l)return nil;\n\t\t\tif(a<=l&&r<=b)return rmq.max(ye);\n\t\t\treturn func(left->query(a,b,l,(l+r)/2,ye),right->query(a,b,(l+r)/2,r,ye));\n\t\t}\n\t\tvoid insert(int x,int y,int v,int l,int r){\n\t\t\trmq.insert(y,v);\n\t\t\tif(r-l==1)return;\n\t\t\tif(x<(l+r)/2){\n\t\t\t\tif(!left)left=new Node();\n\t\t\t\tleft->insert(x,y,v,l,(l+r)/2);\n\t\t\t}else{\n\t\t\t\tif(!right)right=new Node();\n\t\t\t\tright->insert(x,y,v,(l+r)/2,r);\n\t\t\t}\n\t\t}\n\t};\n\tNode *root;\npublic:\n\tDynamic2DRMQ():root(new Node()){}\n\t~Dynamic2DRMQ(){delete root;}\n\tvoid insert(int x,int y,int v){\n\t\troot->insert(x,y,v,0,XSIZE);\n\t}\n\tint query(int xe,int ye){//[xs,xe)*[ys,ye)\n\t\treturn root->query(0,xe,0,XSIZE,ye);\n\t}\n};\n\n\n\n\n\nint m,n,A,B;\n\nint r() {\n\tstatic const int C = ~(1<<31), M = (1<<16)-1;\n\tA = 36969 * (A & M) + (A >> 16);\n\tB = 18000 * (B & M) + (B >> 16);\n\treturn (C & ((A << 16) + B)) % 1000000;\n}\n \n\nint main(){\n\twhile(cin>>m>>n>>A>>B,m|n){\n\t\tvector<pair<int,pair<int,int> > > v(n+m),w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>v[i].first>>v[i].second.first>>v[i].second.second;\n\t\t}\n\t\tfor(int i=m;i<m+n;i++){\n\t\t\tv[i].first=r();\n\t\t\tv[i].second.first=r();\n\t\t\tv[i].second.second=r();\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans=0;\n\t\tDynamic2DRMQ<> rmq2d;\n\t\tint prevx=-1;\n\t\tfor(int i=0;i<m+n;i++){\n\t\t\tif(prevx<v[i].first){\n\t\t\t\tfor(int j=0;j<w.size();j++)\n\t\t\t\t\trmq2d.insert(w[j].second.first,w[j].second.second, w[j].first);\n\t\t\t\tw.clear();\n\t\t\t\tprevx=v[i].first;\n\t\t\t}\n\t\t\tint t=rmq2d.query(v[i].second.first,v[i].second.second)+1;\n\t\t\tans=max(ans,t);\n\t\t\tw.push_back(make_pair(t,make_pair(v[i].second.first,v[i].second.second) ) );\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> Pint;\ntypedef pair<P, P> PP;\nint a, b, C, M;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\nconst int MAX_N=1<<19;\nint m0;\nvector<P> v1[2*MAX_N-1];\nvector<int> v[2*MAX_N-1];\nvector<Pint> p;\nint ct;\nvoid init(){\n    for(int i=1; i<=ct; i++){\n        v[i].clear(); v1[i].clear();\n      vector<int>().swap(v[i]);\n      vector<P>().swap(v1[i]);\n    }\n  for(int i=0; i<p.size(); i++){\n    int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n      int i0=y;\n      while(i0<=ct){\n        v1[i0].push_back(P(z, i));\n\t\ti0+=(i0&(-i0));\n      }\n  }\n  for(int i=1; i<=ct; i++){\n    if(v1[i].empty()) continue;\n    sort(v1[i].begin(), v1[i].end());\n    for(int j=0; j<=v1[i].size(); j++){\n      v[i].push_back(0);\n    }\n  }\n}\n    \nvoid update(int k, int i, int a){\n   while(i<=v1[k].size()){\n       v[k][i]=max(v[k][i], a);\n       i+=(i&(-i));\n   }\n}\n   \nvoid update0(int i, int y, int z, int a){\n\tint k=y;\n\twhile(k<=ct){\n\t\tint i0=lower_bound(v1[k].begin(), v1[k].end(), P(z, i))-v1[k].begin();\n\t\tupdate(k, i0+1, a);\n\t\tk+=(k&(-k));\n\t}\n}\n   \nint find(int k, int i){\n    int s=0;\n    while(i>0){\n        s=max(s, v[k][i]);\n        i-=(i&(-i));\n    }\n    return s;\n}\n   \nint find0(int y, int z){\n\tint s=0;\n\tint k=y-1;\n\twhile(k>0){\n\t\tif(!v1[k].empty()){\n\t\t\tint i=lower_bound(v1[k].begin(), v1[k].end(), P(z, -1))-v1[k].begin();\n\t\t\tif(i!=0) s=max(s, find(k, i));\n\t\t}\n\t\tk-=(k&(-k));\n\t}\n\treturn s;\n}\n   \nint main()\n{\n    while(1){\n      int m, n, A, B;\n      scanf(\"%d %d %d %d\", &m, &n, &A, &B);\n      if(m==0 && n==0 && A==0 && B==0) return 0;\n      a=A, b=B, C=~(1<<31), M=(1<<16)-1;\n      for(int i=0; i<m; i++){\n        int x, y, z;\n        cin>>x>>y>>z;\n        p.push_back(Pint(x, P(y, z)));\n      }\n      for(int i=0; i<n; i++){\n        int x=r();\n        int y=r();\n        int z=r();\n        p.push_back(Pint(x, P(y, z)));\n      }\n      sort(p.begin(), p.end());\n      p.erase(unique(p.begin(), p.end()), p.end());\n      int ind[300000];\n      for(int i=0; i<p.size(); i++) ind[i]=i;\n      sort(ind, ind+p.size(), [&](int x, int y){ return p[x].second.first<p[y].second.first;});\n      int pr=-1;\n\t  ct=0;\n      for(int i=0; i<p.size(); i++){\n          if(pr!=p[ind[i]].second.first){\n              pr=p[ind[i]].second.first;\n              ct++;\n              p[ind[i]].second.first=ct;\n          }else{\n              p[ind[i]].second.first=ct;\n          }\n      }\n      init();\n      vector<PP> mxv;\n      int xp=-1;\n      for(int i=0; i<p.size(); i++){\n        int x=p[i].first, y=p[i].second.first, z=p[i].second.second;\n        if(xp==x){\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n        }else{\n          for(auto t:mxv){\n            update0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n          }\n          mxv.clear();\n          xp=x;\n          mxv.push_back(PP(P(i, y), P(z, find0(y, z))));\n        }\n      }\n      for(auto t:mxv){\n        update0(t.first.first, t.first.second, t.second.first, t.second.second+1);\n      }\n      printf(\"%d\\n\", find0(ct+1, 1000000));\n      p.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 1000010\n#define INF (1000000050)\n\ntypedef set< pair<int,int> >::iterator It;\nint nextscore[MAX_N];\nset< pair<int,int> > seg[MAX_N];\n\nvoid add(int x,int y,int score){\n\t//cout << x << \",\" << y << \",\" << score << endl;\n\twhile(x<MAX_N){\n\t\tIt it1 = --seg[x].lower_bound(make_pair(y+1,-INF));\n\t\tIt it2 = seg[x].lower_bound(make_pair(y+1,-INF));\n\t\t\n\t\tif( it1->first <= y && it1->second >= score ){\n\t\t\tx += x & -x;\n\t\t\tcontinue;\n\t\t}\n\t\twhile( it2->first != INF && it2->second <= score ){\n\t\t\tseg[x].erase(it2++);\n\t\t}\n\t\tseg[x].insert(make_pair(y,score));\n\t\tx += x & -x;\n\t}\n}\nint get(int x,int y){\n\t//cout << \"(\" << x << \",\" << y << \")\" << endl;\n\tint maximum = 0;\n\twhile(x>0){\n\t\tIt it = --seg[x].lower_bound(make_pair(y+1,-INF));\n\t\t\n\t\t\n\t\t/*\n\t\tIt\t it = seg[x].begin();\n\t\twhile( it != seg[x].end() ){\n\t\t\tif( it->first <= y ){\n\t\t\t\tmaximum = max(maximum,it->second);\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t\t*/\n\t\t//cout << \" (\" << it->first << \",\" << it->second << \")\" << endl;\n\t\tmaximum = max(maximum,it->second);\n\t\tx -= x & -x;\n\t}\n\treturn maximum;\n}\n\n\nint aa, bb, C = ~(1<<31), M = (1<<16)-1;\n\nint r() {\n\taa = 36969 * (aa & M) + (aa >> 16);\n\tbb = 18000 * (bb & M) + (bb >> 16);\n\treturn (C & ((aa << 16) + bb)) % 1000000;\n}\n\nvector< pair<int, pair<int,int> >  > inp;\n\nint main(){\n\tfor(int i = 0 ; i < MAX_N ; i++){\n\t\tseg[i].insert(make_pair(INF,INF));\n\t\tseg[i].insert(make_pair(-INF,0));\n\t}\n\tint m,n;\n\twhile(\tcin >> m >> n >> aa >> bb && m+n ){\n\t\tinp.clear();\n\t\tfor(int i = 0 ; i < MAX_N ; i++){\n\t\t\tif( seg[i].size() != 2 ){\n\t\t\t\tseg[i].clear();\n\t\t\t\tseg[i].insert(make_pair(INF,INF));\n\t\t\t\tseg[i].insert(make_pair(-INF,0));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> ux;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\ta++;\n\t\t\tb++;\n\t\t\tc++;\n\t\t\tinp.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint a,b,c;\n\t\t\ta=r()+1;\n\t\t\tb=r()+1;\n\t\t\tc=r()+1;\n\t\t\tinp.push_back(make_pair(c,make_pair(a,b)));\n\t\t}\n\t\tsort(inp.begin(),inp.end());\n\t\tint res = 0;\n\t\tfor(int i = 0 ; i < inp.size() ; ){\n\t\t\t\n\t\t\tint j = i;\n\t\t\twhile( j < inp.size() && inp[i].first == inp[j].first ) j++;\n\t\t\tfor(int k = i ; k < j ; k++){\n\t\t\t\tint a = inp[k].second.first;\n\t\t\t\tint b = inp[k].second.second;\n\t\t\t\tnextscore[k] = get(a-1,b-1) + 1;\n\t\t\t\tres = max( res , nextscore[k] );\n\t\t\t\t//cout << k << \": \" << inp[k].first << \" \" << inp[k].second.first << \" \" << inp[k].second.second << \" \" <<  get(a-1,b-1) <<  endl;\n\t\t\t}\n\t\t\tfor(int k = i ; k < j ; k++){\n\t\t\t\tint a = inp[k].second.first;\n\t\t\t\tint b = inp[k].second.second;\n\t\t\t\tadd(a,b,nextscore[k]);\n\t\t\t}\n\t\t\ti = j;\n\t\t}\n\t\tcout << res << endl;\n\t\t//return 0;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing PP = pair<int, P>;\nconstexpr int INF = 1LL << 30;\nint A, B;\ninline int gen()\n{\n    static int a = A;\n    static int b = B;\n    constexpr int C = ~(1 << 31);\n    constexpr int M = (1 << 16) - 1;\n    a = 36969 * (a & M) + (a >> 16);\n    b = 18000 * (b & M) + (b >> 16);\n    return (C & ((a << 16) + b)) % 1000000;\n}\n\ninline bool check(const set<P>& st, const P& v)\n{\n    auto upper = st.upper_bound({v.first, -INF});\n    if (upper == st.begin()) {\n        return false;\n    } else {\n        upper--;\n        return upper->second < v.second;\n    }\n}\n\ninline void insertAndErase(set<P>& st, const P& v)\n{\n    auto lower = st.lower_bound({v.first, INF});\n    vector<P> er;\n    for (; lower != st.end() and lower->second > v.second; lower++) {\n        er.push_back(*lower);\n    }\n    st.insert(v);\n    for (const P& e : er) {\n        st.erase(e);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int M, N;\n        cin >> M >> N >> A >> B;\n        if (M == 0 and N == 0 and A == 0 and B == 0) {\n            break;\n        }\n        map<int, set<P, greater<P>>> p;\n        for (int i = 0; i < M; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            p[x].insert({y, z});\n        }\n        for (int i = M; i < M + N; i++) {\n            const int x = gen();\n            const int y = gen();\n            const int z = gen();\n            p[x].insert({y, z});\n        }\n        vector<set<P>> tail(M + N + 1);\n        tail[0].insert({-INF, -INF});\n        for (const auto& e : p) {\n            for (const P& v : e.second) {\n                int inf = -1;\n                int sup = N + M;\n                while (sup - inf > 1) {\n                    const int mid = (sup + inf) / 2;\n                    if (check(tail[mid], v)) {\n                        inf = mid;\n                    } else {\n                        sup = mid;\n                    }\n                }\n                insertAndErase(tail[sup], v);\n            }\n        }\n        for (int i = N + M; i >= 0; i--) {\n            if (not tail[i].empty()) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint LT,RT,LB,RB;\n\tint val;\n\tnode(){\n\t\tLT=RT=LB=RB=-1;\n\t\tval=0;\n\t}\n\tnode(int a,int b,int c,int d,int e){\n\t\tLT=a;\n\t\tRT=b;\n\t\tLB=c;\n\t\tRB=d;\n\t\tval=e;\n\t}\n};\nnode pool[8000000];\nint ind;\nint Ret;\nint nowret=0;\nint query(int a,int b,int c,int d,int e,int f,int g,int h,int t){\n\tif(d<a||b<c)return 0;\n\tif(h<e||f<g)return 0;\n\tif(c<=a&&b<=d&&g<=e&&f<=h)return pool[t].val;\n\tif(nowret>pool[t].val)return 0;\n\tint ret=0;\n\tif(~pool[t].LT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,e,(e+f)/2,g,h,pool[t].LT));\n\t}\n\tif(~pool[t].RT){\n\t\tret=nowret=max(ret,query(a,(a+b)/2,c,d,(e+f)/2+1,f,g,h,pool[t].RT));\n\t}\n\tif(~pool[t].LB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,e,(e+f)/2,g,h,pool[t].LB));\n\t}\n\tif(~pool[t].RB){\n\t\tret=nowret=max(ret,query((a+b)/2+1,b,c,d,(e+f)/2+1,f,g,h,pool[t].RB));\n\t}\n\treturn ret;\n}\nvoid update(int row,int col,int C){\n\tint now=0;\n\tint a=0;\n\tint b=1048575;\n\tint c=0;\n\tint d=1048575;\n\twhile(1){\n\t\tpool[now].val=max(pool[now].val,C);\n\t\tif(a==b)break;\n\t\tint M=(a+b)/2;\n\t\tint N=(c+d)/2;\n\t\tif(row<=M&&col<=N){//LT\n\t\t\tb=M;\n\t\t\td=N;\n\t\t\tif(~pool[now].LT){\n\t\t\t\tnow=pool[now].LT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row<=M&&col>N){//RT\n\t\t\tb=M;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RT){\n\t\t\t\tnow=pool[now].RT;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RT=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col<=N){//LB\n\t\t\ta=M+1;\n\t\t\td=N;\n\t\t\tif(~pool[now].LB){\n\t\t\t\tnow=pool[now].LB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].LB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\n\t\tif(row>M&&col>N){//RB\n\t\t\ta=M+1;\n\t\t\tc=N+1;\n\t\t\tif(~pool[now].RB){\n\t\t\t\tnow=pool[now].RB;\n\t\t\t}else{\n\t\t\t\tpool[ind]=node();\n\t\t\t\tpool[now].RB=ind;\n\t\t\t\tnow=ind++;\n\t\t\t}\n\t\t}\t\n\t}\n}\npair<int,pair<int,int> >dat[400000];\nint x[400000];\nint y[400000];\nint z[400000];\nint Q[400000];\nint wolfa,wolfb,wolfC=~(1<<31),wolfM=(1<<16)-1;\nint r(){\n\twolfa=36969*(wolfa&wolfM)+(wolfa>>16);\n\twolfb=18000*(wolfb&wolfM)+(wolfb>>16);\n\treturn (wolfC&((wolfa<<16)+wolfb))%1000000;\n}\nint main(){\n\tint a,b,c,d;\n\twhile(scanf(\"%d%d%d%d\",&a,&b,&c,&d),a+b){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",x+i,y+i,z+i);\n\t\t\tdat[i]=make_pair(x[i],make_pair(-y[i],-z[i]));\n\t\t}\n\t\twolfa=c;\n\t\twolfb=d;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint X=r();\n\t\t\tint Y=r();\n\t\t\tint Z=r();\n\t\t\tdat[i+a]=make_pair(X,make_pair(-Y,-Z));\n\t\t}\n\t\tint n=a+b;\n\t\tstd::sort(dat,dat+n);\n\t\t//for(int i=0;i<ind;i++)pool[i]=node();\n\t\tpool[0]=node();\n\t\tind=1;\n\t\tRet=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t//int X=dat[i].second.first;\n\t\t\t//int Y=;\n\t\t\tnowret=0;\n\t\t\tint P=max(nowret,query(0,1048575,0,-dat[i].second.first-1,0,1048575,0,-dat[i].second.second-1,0))+1;\n\t\t\tRet=max(Ret,P);\n\t\t\tQ[i]=P;\n\t\t\tupdate(-dat[i].second.first,-dat[i].second.second,P);\n\t\t//\tif(i<n-1&&dat[i].first!=dat[i+1].first){\n\t\t\t//\tfor(int j=i;j>=0;j--){\n\t\t\t\t//\tif(dat[j].first!=dat[i].first)break;\n\t\t\t//\t\tupdate(-dat[j].second.first,-dat[j].second.second,Q[j]);\n\t\t\t//\t}\n\t\t//\t}\n\t\t}\n\t\tprintf(\"%d\\n\",Ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct rmq {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return max(l, r); }\n};\n\nconst int BS = 19;\nconst int MAX = 1 << BS;\n\nint it = 0;\n\ntemplate <typename M>\nclass dynamic_segment_tree {\n\tusing T = typename M::type;\n\tstruct node {\n\t\tint pos;\n\t\tT val, all;\n\t\tnode *l, *r;\n\t\tnode() {}\n\t\tnode(int p, T v) : pos(p), val(v), all(v), l(nullptr), r(nullptr) {}\n\t\tvoid *operator new(size_t) {\n\t\t\tstatic const int pmax = 5.5e6;\n\t\t\tassert(it < pmax);\n\t\t\tstatic node pool[pmax];\n\t\t\treturn pool + it++;\n\t\t}\n\t};\nprivate:\n\tT value(node *t) {\n\t\treturn t ? t->all : M::id();\n\t}\n\tT get(int l, int r, node* t, int lb, int ub) {\n\t\tif (!t || ub <= l || r <= lb) return M::id();\n\t\tif (l <= lb && ub <= r) return t->all;\n\t\tint c = (lb + ub) >> 1;\n\t\tT res = get(l, r, t->l, lb, c);\n\t\tif (l <= t->pos && t->pos < r) res = M::op(res, t->val);\n\t\treturn M::op(res, get(l, r, t->r, c, ub));\n\t}\n\tnode *change(node* t, int p, T val, int lb, int ub) {\n\t\tif (!t) return new node(p, val);\n\t\tif (t->pos == p) {\n\t\t\tt->val = val;\n\t\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\t\treturn t;\n\t\t}\n\t\tint c = (lb + ub) >> 1;\n\t\tif (p < c) {\n\t\t\tif (p > t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->l = change(t->l, p, val, lb, c);\n\t\t}\n\t\telse {\n\t\t\tif (p < t->pos) swap(p, t->pos), swap(val, t->val);\n\t\t\tt->r = change(t->r, p, val, c, ub);\n\t\t}\n\t\tt->all = M::op(value(t->l), M::op(t->val, value(t->r)));\n\t\treturn t;\n\t}\nprivate:\n\tconst int n;\n\tnode *root;\npublic:\n\tdynamic_segment_tree() : n(MAX), root(nullptr) {}\n\tvoid update(int p, T val) {\n\t\troot = change(root, p, val, 0, n);\n\t}\n\tT find(int l, int r) {\n\t\treturn get(l, r + 1, root, 0, n);\n\t}\n\tvoid clear() {\n\t\troot = nullptr;\n\t}\n};\n\ndynamic_segment_tree<rmq> segs[MAX * 2];\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px].update(py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (r & 1) res = max(res, segs[--r].find(0, y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tsegs[p].clear();\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n  a = 36969 * (a & M) + (a >> 16);\n  b = 18000 * (b & M) + (b >> 16);\n  return (C & ((a << 16) + b)) % 1000000;\n}\n\nclass HappySequence{\npublic:\n\tmap<int,int> seq;\n\tHappySequence(){ int inf = 1e9; seq[-inf] = -inf; }\n\tbool insert(int key,int val){\n\t\tif( (--seq.lower_bound(key))->second >= val ) return false;\n\t\tseq[key] = val;\n\t\tauto it = ++seq.find(key);\n\t\twhile( it != seq.end() && (*it).second <= val ) seq.erase(it++);\n\t\treturn true;\n\t}\n};\n\nHappySequence seg[1000100];\n\nvoid ins(int y,int z,int v){\n\tfor(int i = y ; i < 1000100 ; i += i & -i ) seg[i].insert(z,v);\n}\nint get(int y,int z){\n\tint v = 0;\n\tfor(int i = y ; i > 0 ; i -= i & -i ){\n\t\tv = max(v,(--seg[i].seq.lower_bound(z))->second);\n\t}\n\treturn v;\n}\n\nint main(){\n\tint n,m,A,B;\n\twhile( cin >> m >> n >> A >> B && n+m ){\t\n\t\ta = A;\n\t\tb = B;\n\t\tvector< array<int,3> > ps;\n\t\tvector<int> uy;\n\t\tfor(int i = 0 ; i < m ; i++){\t\n\t\t\tint x,y,z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x = r();\n\t\t\tint y = r();\n\t\t\tint z = r();\n\t\t\tps.push_back(array<int,3>{x,y,z});\n\t\t\tuy.push_back(y);\n\t\t}\n\t\tsort(uy.begin(),uy.end());\n\t\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\t\tfor(int i = 0 ; i <= uy.size() ; i++) seg[i] = HappySequence();\n\t\tsort(ps.begin(),ps.end(),[&](array<int,3> a,array<int,3> b){\n\t\t\tif( a[0] != b[0] ) return a[0] < b[0];\n\t\t\treturn make_pair(a[1],a[2]) > make_pair(b[1],b[2]);\n\t\t});\n\t\tint ans = 0;\n\t\tfor( auto p : ps ){\n\t\t\tp[1] = lower_bound(uy.begin(),uy.end(),p[1]) - uy.begin() + 1;\n\t\t\tint mx = get(p[1]-1,p[2]) + 1;\n\t\t\tans = max(ans,mx);\n\t\t\tins(p[1],p[2],mx);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nstruct node {\n\tint val;\n\tnode *l, *r;\n\tnode() {}\n};\n\nconst int MAX = 1 << 19;\n\nint it;\nconst int pmax = 4e7;\n\nnode pool[pmax];\n\nnode *segs[MAX * 2];\n\nnode *new_node(int val) {\n\tassert(it < pmax);\n\tpool[it].val = val;\n\tpool[it].l = pool[it].r = nullptr;\n\treturn pool + it++;\n}\n\nnode* update(node *p, int x, int val, int lb = 0, int ub = MAX) {\n\tif (!p) p = new_node(val);\n\tif (ub - lb == 1) return p;\n\tint m = (lb + ub) >> 1;\n\tif (x < m) {\n\t\tp->l = update(p->l, x, val, lb, m);\n\t}\n\telse {\n\t\tp->r = update(p->r, x, val, m, ub);\n\t}\n\tp->val = max(p->l ? p->l->val : 0, p->r ? p->r->val : 0);\n\treturn p;\n}\n\nvoid update(int px, int py, int val) {\n\tpx += MAX;\n\twhile (px > 0) {\n\t\tsegs[px] = update(segs[px], py, val);\n\t\tpx >>= 1;\n\t}\n}\n\nint find(node *p, int r, int lb = 0, int ub = MAX) {\n\tif (!p || ub <= 0 || r <= lb) return 0;\n\tif (0 <= lb && ub <= r) return p->val;\n\tint m = (lb + ub) >> 1;\n\treturn max(find(p->l, r, lb, m), find(p->r, r, m, ub));\n}\n\nint find(int x, int y) {\n\tint res = 0;\n\tfor (int l = MAX, r = MAX + x; l < r; l >>= 1, r >>= 1) {\n\t\tif (l & 1) res = max(res, find(segs[l++], y));\n\t\tif (r & 1) res = max(res, find(segs[--r], y));\n\t}\n\treturn res;\n}\n\nvoid del(int p, int r, int lb = 0, int ub = MAX) {\n\tif (r <= lb) return;\n\tif (segs[p]) segs[p] = nullptr;\n\tif (ub - lb == 1) return;\n\tint m = (lb + ub) / 2;\n\tdel(p << 1, r, lb, m);\n\tdel((p << 1) | 1, r, m, ub);\n}\n\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nvoid compress(vector<int>& v) {\n\tauto vs = v;\n\tsort(vs.begin(), vs.end());\n\tfor (auto& val : v) {\n\t\tval = lower_bound(vs.begin(), vs.end(), val) - vs.begin();\n\t}\n}\n\nint sort_xyz(vector<int>& x, vector<int>& y, vector<int>& z) {\n\tint n = x.size();\n\tvector<tuple<int, int, int>> tp;\n\tfor (int i = 0; i < n; i++) {\n\t\ttp.emplace_back(x[i], -y[i], -z[i]);\n\t}\n\tsort(tp.begin(), tp.end());\n\ttp.erase(unique(tp.begin(), tp.end()), tp.end());\n\tn = tp.size();\n\tx.resize(n);\n\ty.resize(n);\n\tz.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\ttie(x[i], y[i], z[i]) = tp[i];\n\t\ty[i] = -y[i];\n\t\tz[i] = -z[i];\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m | n | A | B) {\n\t\ta = A;\n\t\tb = B;\n\t\tvector<int> x(m + n), y(m + n), z(m + n);\n\t\tfor (int i = 0; i < m + n; i++) {\n\t\t\tif (i < m) {\n\t\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i] = r(); y[i] = r(); z[i] = r();\n\t\t\t}\n\t\t}\n\t\tcompress(x);\n\t\tcompress(y);\n\t\tcompress(z);\n\t\tn = sort_xyz(x, y, z);\n\t\tint res = 0;\n\t\tit = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint val = find(y[i], z[i]) + 1;\n\t\t\tres = max(res, val);\n\t\t\tupdate(y[i], z[i], val);\n\t\t}\n\t\tdel(1, *max_element(y.begin(), y.end()) + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n#include <list>\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst int M = (1 << 16) - 1;\nconst int C = ~(1 << 31);\nint a, b;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint ord[6][3];\n\nint k;\nbool cmp(const vector<int> &lhs, const vector<int> &rhs){\n\trep(i, 3) if (lhs[ord[k][i]] != rhs[ord[k][i]]) return lhs[ord[k][i]] < rhs[ord[k][i]];\n\treturn false;\n}\n\nconst int N = 3e5 + 10;\nvector<int> G[N];\n\nbool check(const vector<int> &lhs, const vector<int> &rhs){\n\trep(i, 3) if (lhs[i] >= rhs[i]) return false;\n\treturn true;\n}\n\nvoid add_edge(const vector<vector<int>> &v){\n\tint n = v.size();\n\n\tvector<int> mx = v[0];\n\tFOR(i, 1, n){\n\t\tif (!check(mx, v[i])) continue;\n\t\tG[mx[3]].push_back(v[i][3]);\n\t\tmx = v[i];\n\t}\n}\n\nint dp[N];\n\nint dfs(int v){\n\tint &res = dp[v];\n\tif (res + 1) return res;\n\n\tres = 1;\n\tfor (auto nxt : G[v]){\n\t\tres = max(res, dfs(nxt) + 1);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint o[] = { 0, 1, 2 };\n\tint idx = 0;\n\tdo{\n\t\trep(j, 3) ord[idx][j] = o[j];\n\t\t++idx;\n\t} while (next_permutation(o, o + 3));\n\n\tint m, n, A, B;\n\twhile (cin >> m >> n >> A >> B, m + n){\n\t\ta = A, b = B;\n\t\tvector<vector<int>> v(m+n);\n\t\trep(i, m){\n\t\t\tint x, y, z;\n\t\t\tcin >> x >> y >> z;\n\t\t\tv[i] = {x, y, z, i};\n\t\t}\n\t\trep(i, n){\n\t\t\tint x, y, z;\n\t\t\tx = r(), y = r(), z = r();\n\t\t\tv[i + m] = { x, y, z, i+m};\n\t\t}\n\t\tsort(ALL(v));\n\t\tUNIQUE(v);\n\t\tint n = v.size();\n\n\t\t//rep(i, n){\n\t\t//\tfor (auto e : v[i]) cout << e << ' ';\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\n\t\t//vector<int> G2[N];\n\t\t//rep(i, n) rep(j, n){\n\t\t//\tif (check(v[i], v[j])){\n\t\t//\t\tcout << i << j << endl;\n\t\t//\t\tG2[i].push_back(j);\n\t\t//\t}\n\t\t//}\n\n\t\trep(i, n) G[i].clear();\n\n\t\trep(i, 6){\n\t\t\tk = i;\n\t\t\tsort(ALL(v), cmp);\n\t\t\tadd_edge(v);\n\t\t}\n\n\t\tMEMSET(dp, -1);\n\t\tint ans = 0;\n\t\trep(i, n) ans = max(ans, dfs(i));\n\t\tcout << ans << '\\n';\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<cctype>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<ctime>\n#include<map>\n#include<set>\nusing namespace std;\n#define MP(x,y) make_pair((x),(y))\n#define PB(x) push_back(x)\ntypedef long long LL;\n//typedef unsigned __int64 ULL;\n/* ****************** */\nconst int INF=100011122;\nconst double INFF=1e100;\nconst double eps=1e-8;\nconst LL mod=1000000007;\nconst int NN=300010;\nconst int MM=1000010;\n/* ****************** */\n\nconst int limit=1000000;\n\nint aa,bb;\nint C = ~(1<<31);\nint M = (1<<16)-1;\nint rr() {\n    aa = 36969 * (aa & M) + (aa >> 16);\n    bb = 18000 * (bb & M) + (bb >> 16);\n    return (C & ((aa << 16) + bb)) % 1000000;\n}\n\nstruct node\n{\n    int x,y,z,id;\n    bool operator<(const node &tt)const\n    {\n        return x<tt.x;\n    }\n}a[NN];\nstruct node1\n{\n    int x,y,z,id,yuan_id;\n    bool operator<(const node1 &tt)const\n    {\n        if(y!=tt.y)return y<tt.y;\n        return z>tt.z;\n    }\n}b[NN];\nint dp[NN];\nint c[2][limit+1];\n\nint lowbit(int x)\n{\n    return x&(-x);\n}\nvoid update(int fg,int x,int val)\n{\n    for(;x<=limit;x+=lowbit(x))\n        c[fg][x]=max(c[fg][x],val);\n}\nint get_max(int fg,int x)\n{\n    int ans=0;\n    for(;x>0;x-=lowbit(x))\n        ans=max(ans,c[fg][x]);\n    return ans;\n}\nvoid clr_update(int fg,int x)\n{\n    for(;x<=limit;x+=lowbit(x))\n        c[fg][x]=0;\n}\n\nvoid cdq(int l,int r)\n{\n    if(l==r)\n    {\n        dp[ a[l].id ]=max(dp[a[l].id],1);\n        return;\n    }\n    int mid=(l+r)>>1;\n    cdq(l,mid);\n   // cdq(mid+1,r);\n\n    int t,i,cnt=0,tx=a[mid+1].x;\n    for(i=l;i<=r;i++)\n    {\n        b[cnt].x=a[i].x;\n        b[cnt].y=a[i].y;\n        b[cnt].z=a[i].z;\n        b[cnt].id=i;\n        b[cnt].yuan_id=a[i].id;\n        cnt++;\n    }\n\n  //  printf(\"go to solve [%d,%d]\\n\",l,r);\n   // memset(c,0,sizeof(c));\n\n    sort(b,b+cnt);\n    for(i=0;i<cnt;i++)\n    {\n       // printf(\"          yes? %d %d %d\\n\",b[i].x,b[i].y,b[i].z);\n\n        if(b[i].id<=mid)\n        {\n           // printf(\"up [%d]->%d\\n\",b[i].z, dp[ b[i].yuan_id ]);\n\n            update(1,b[i].z, dp[ b[i].yuan_id ] );\n            if(b[i].x!=tx)\n                update(0,b[i].z, dp[ b[i].yuan_id ] );\n        }\n        else\n        {\n            if(b[i].x==tx)\n                t=get_max(0,b[i].z-1);\n            else\n                t=get_max(1,b[i].z-1);\n\n           // printf(\"id==%d t==%d\\n\",b[i].yuan_id,t);\n\n            dp[ b[i].yuan_id ] = max( dp[ b[i].yuan_id ] , t+1 );\n        }\n    }\n    for(i=0;i<cnt;i++)\n        if(b[i].id<=mid)\n        {\n            clr_update(1,b[i].z);\n            if(b[i].x!=tx)\n                clr_update(0,b[i].z);\n        }\n\n    cdq(mid+1,r);\n}\n\nvoid solve(int n)\n{\n    int i,ans=0;\n    sort(a+1,a+1+n);\n    for(i=1;i<=n;i++)\n    {\n        a[i].id=i;\n\n      //  printf(\"-- %d %d %d\\n\",a[i].x,a[i].y,a[i].z);\n    }\n\n    memset(c,0,sizeof(c));\n    memset(dp,0,sizeof(dp));\n\n    cdq(1,n);\n\n    for(i=1;i<=n;i++)\n        ans=max(ans,dp[i]);\n\n   // printf(\"ans==\");\n    printf(\"%d\\n\",ans);\n}\n\nint main()\n{\n    int m,n,i;\n    while(scanf(\"%d%d%d%d\",&m,&n,&aa,&bb)!=EOF)\n    {\n        if(m==0 && n==0)break;\n\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].z);\n            a[i].x++;\n            a[i].y++;\n            a[i].z++;\n        }\n        for(i=1;i<=n;i++)\n        {\n            a[i+m].x=rr();\n            a[i+m].y=rr();\n            a[i+m].z=rr();\n\n            a[i+m].x++;\n            a[i+m].y++;\n            a[i+m].z++;\n        }\n\n        solve(n+m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\n#include <cassert>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nconst int MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nstruct segtree {\n\tsegtree *lch, *rch;\n\tint N, val;\n\tsegtree(int _N) : N(_N), val(0) {\n\t\tif (N > 1) {\n\t\t\tint n = N / 2;\n\t\t\tlch = new segtree(n);\n\t\t\trch = new segtree(N - n);\n\t\t}\n\t}\n\tint get(int l, int r) {\n\t\tif (r <= 0 || N <= l) return 0;\n\t\tif (l <= 0 && N <= r) return val;\n\t\tint n = N / 2;\n\t\treturn max(lch->get(l, r), rch->get(l - n, r - n));\n\t}\n\tvoid set(int i, int _val) {\n\t\tif (N == 1) {\n\t\t\tval = max(val, _val);\n\t\t\treturn;\n\t\t}\n\t\tint n = N / 2;\n\t\tif (i < n) lch->set(i, _val);\n\t\telse rch->set(i - n, _val);\n\t\tval = max(lch->val, rch->val);\n\t}\n};\n\nstruct segtree_2d {\n\tsegtree_2d *lch, *rch;\n\tint H;\n\tvector<int> X;\n\tsegtree* st;\n\tsegtree_2d(int _H, vector<int>& y, vector<int>& x) : H(_H) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2, N = y.size();\n\t\t\tvector<int> y1, x1, y2, x2;\n\t\t\trep(i, N)\n\t\t\t\tif (y[i] < h) y1.pb(y[i]), x1.pb(x[i]);\n\t\t\t\telse y2.pb(y[i] - h), x2.pb(x[i]);\n\t\t\tlch = new segtree_2d(h, y1, x1);\n\t\t\trch = new segtree_2d(H - h, y2, x2);\n\t\t}\n\t\tX = x;\n\t\tsort(X.begin(), X.end());\n\t\tX.erase(unique(X.begin(), X.end()), X.end());\n\t\tst = new segtree(X.size());\n\t}\n\tint get(int yl, int yr, int xl, int xr) {\n\t\tif (yr <= 0 || H <= yl) return 0;\n\t\tif (yl <= 0 && H <= yr) {\n\t\t\tint l = lower_bound(X.begin(), X.end(), xl) - X.begin();\n\t\t\tint r = lower_bound(X.begin(), X.end(), xr) - X.begin();\n\t\t\treturn st->get(l, r);\n\t\t}\n\t\tint h = H / 2;\n\t\treturn max(lch->get(yl, yr, xl, xr), rch->get(yl - h, yr - h, xl, xr));\n\t}\n\tvoid set(int y, int x, int _val) {\n\t\tif (H > 1) {\n\t\t\tint h = H / 2;\n\t\t\tif (y < h) lch->set(y, x, _val);\n\t\t\telse rch->set(y - h, x, _val);\n\t\t}\n\t\tint i = lower_bound(X.begin(), X.end(), x) - X.begin();\n\t\tst->set(i, _val);\n\t}\n};\n\nlong long a, b, C = ~(1<<31), M = (1<<16)-1;\nint r() {\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % 1000000;\n}\n\nint compress(vector<int>& a) {\n\tvector<int> A = a;\n\tsort(A.begin(), A.end());\n\tA.erase(unique(A.begin(), A.end()), A.end());\n\tfor (int& x: a) x = lower_bound(A.begin(), A.end(), x) - A.begin();\n\treturn A.size();\n}\n\nstruct dice {\n\tmt19937 mt;\n\tdice() {\n\t\trandom_device rd;\n\t\tmt = mt19937(rd());\n\t}\n\tint operator()(int x) { return this->operator()(0, x - 1); }\n\tint operator()(int x, int y) {\n\t\tuniform_int_distribution<int> dist(x, y);\n\t\treturn dist(mt);\n\t}\n} dc;\n\nint main() {\n\t/*\n\tfor (;;) {\n\t\tcout << 'a' << endl;\n\t\tint N = 10000;\n\t\tvector<int> y(N), x(N), w(N);\n\t\trep(i, N) y[i] = dc(10000), x[i] = dc(10000), w[i] = dc(10000);\n\t\tsegtree_2d* st = new segtree_2d(10000, y, x);\n\t\trep(i, N) st->set(y[i], x[i], w[i]);\n\t\trep(i, N) {\n\t\t\tint ans1 = st->get(0, y[i], 0, x[i]);\n\t\t\tint ans2 = 0;\n\t\t\trep(j, N) if (y[j] < y[i] && x[j] < x[i])\n\t\t\t\tans2 = max(ans2, w[j]);\n\t\t\tif (ans1 != ans2) cout << \"ERR\" << endl;\n\t\t}\n\t}\n\t*/\n\tfor (;;) {\n\t\tint M, N, A, B;\n\t\tif (!M) break;\n\t\tscanf(\"%d%d%d%d\", &M, &N, &A, &B);\n\t\tvector<int> x(M + N), y(M + N), z(M + N);\n\t\trep(i, M) scanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\ta = A; b = B;\n\t\trep(i, N) x[M + i] = r(), y[M + i] = r(), z[M + i] = r();\n\t\tN = M + N;\n\t\tint W = compress(x), H = compress(y), D = compress(z);\n\t\tsegtree_2d* st = new segtree_2d(H, y, x);\n\t\tvector<vector<int> > v(D);\n\t\trep(i, N) v[z[i]].pb(i);\n\t\tvector<int> len(N);\n\t\trep(z, D) {\n\t\t\tfor (int i: v[z]) len[i] = st->get(0, y[i], 0, x[i]) + 1;\n\t\t\tfor (int i: v[z]) st->set(y[i], x[i], len[i]);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, N) ans = max(ans, len[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1341 Longest Chain\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 高速数値入出力\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()   // 整数の入力（負数に対応）\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\n\t\tc = gc();\n\t\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX 1000000\ntypedef struct { int x, y, z, id; } T;\nT t[300005], s[300005];\nint dp[300005];\nint c[2][1000005];\nint m, n;\nint a, b, C = ~(1 << 31), M = (1 << 16) - 1;\n\n#define lowbit(x) (x & (-x))\nvoid update(int f, int x, int v)\n{\n\twhile (x <= MAX) {\n\t\tif (c[f][x] < v) c[f][x] = v;\n\t\tx += lowbit(x);\n\t}\n}\n\nint getmax(int f, int x)\n{\n\tint a = 0;\n\twhile (x > 0) {\n\t\tif (a < c[f][x]) a = c[f][x];\n\t\tx -= lowbit(x);\n\t}\n\treturn a;\n}\n\nvoid clear(int f, int x)\n{\n\twhile (x <= MAX) {\n\t\tc[f][x] = 0;\n\t\tx += lowbit(x);\n\t}\n}\n\nint cmp2(const void *a, const void *b)\n{\n\tint t = ((T *)a)->y - ((T *)b)->y; if (t) return t;\n\treturn ((T *)b)->z - ((T *)a)->z;\n}\n\nvoid cdq(int l, int r)\n{\n\tint i, k, a, tx, m;\n\n\tif (l == r) { if (dp[l] == 0) dp[l] = 1; return; }\n\tm = (l + r) >> 1;\n\ttx = t[m + 1].x;\n\tcdq(l, m);\n\tk = 0;  for (i = l; i <= r; i++) s[k] = t[i], s[k++].id = i;\n\tqsort(s, k, sizeof(T), cmp2);\n\tfor (i = 0; i < k; i++) {\n\t\tif (s[i].id <= m) {\n\t\t\tupdate(1, s[i].z, dp[s[i].id]);\n\t\t\tif (s[i].x != tx) update(0, s[i].z, dp[s[i].id]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (s[i].x == tx) a = getmax(0, s[i].z - 1);\n\t\t\telse a = getmax(1, s[i].z - 1);\n\t\t\tif (dp[s[i].id] < a + 1) dp[s[i].id] = a + 1;\n\t\t}\n\t}\n\tfor (i = 0; i < k; i++) {\n\t\tif (s[i].id <= m) {\n\t\t\tclear(1, s[i].z);\n\t\t\tif (s[i].x != tx) clear(0, s[i].z);\n\t\t}\n\t}\n\tcdq(m + 1, r);\n}\n\nint r()\n{\n\ta = 36969 * (a & M) + (a >> 16);\n\tb = 18000 * (b & M) + (b >> 16);\n\treturn (C & ((a << 16) + b)) % MAX;\n}\n\nint cmp(const void *a, const void *b) { return ((T *)a)->x - ((T *)b)->x; }\n\nint main()\n{\n\tint i, ans;\n\n\twhile (1) {\n\t\tm = in(), n = in() + m;\n\t\tif (m + n == 0) break;\n\t\ta = in(), b = in();\n\t\tfor (i = 1; i <= m; i++) t[i].x = in() + 1, t[i].y = in() + 1, t[i].z = in() + 1;\n\t\tfor (; i <= n; i++) t[i].x = r() + 1, t[i].y = r() + 1, t[i].z = r() + 1;\n\t\tqsort(t + 1, n, sizeof(T), cmp);\n\t\tmemset(c, 0, sizeof(c));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tcdq(1, n);\n\t\tans = 0; for (i = 1; i <= n; i++) if (dp[i] > ans) ans = dp[i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].floor(S[i]);\n\t\t\t\tif (tmp != null && tmp[1] == S[i][1])\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && S[i][1] <= tmp[1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i + m][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].floor(S[i]);\n\t\t\t\tif (tmp != null && tmp[1] == S[i][1])\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && S[i][1] <= tmp[1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i + m][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// C[left+1]???S???????????????\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].floor(S[i]);\n\t\t\t\tif (tmp != null && tmp[1] == S[i][1])\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && S[i][1] <= tmp[1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i + m][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// C[left+1]???S???????????????\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].ceiling(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] >= S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].ceiling(S[i]);\n\t\t\t\t}\n\t\t\t\ttmp = C[left + 1].floor(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] == S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].floor(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].floor(S[i]);\n\t\t\t\tif (tmp != null && tmp[1] == S[i][1])\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && S[i][1] <= tmp[1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i + m][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].floor(S[i]);\n\t\t\t\tif (tmp != null && tmp[1] == S[i][1])\n\t\t\t\t\tcontinue;\n\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && S[i][1] <= tmp[1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i + m][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] S?? = C.lower(S);\n\t\tif (S?? != null && S??[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// C[left+1]???S???????????????\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\tint[] tmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] >= S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] Sl = C.lower(S);\n\t\tif (Sl != null && Sl[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// C[left+1]???S???????????????\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint[] tmp = C[left + 1].ceiling(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] >= S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].ceiling(S[i]);\n\t\t\t\t}\n\t\t\t\ttmp = C[left + 1].floor(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] == S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].floor(S[i]);\n\t\t\t\t}\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn -Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn -Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean check(TreeSet<int[]> C, int[] S) {\n\t\tint[] S?? = C.lower(S);\n\t\tif (S?? != null && S??[1] < S[1]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(int N, int[][] S) {\n\t\tTreeSet<int[]>[] C = new TreeSet[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tC[i] = new TreeSet<>(new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0]) {\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tC[0].add(S[0]);\n\t\tint maxLen = 1;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint left = -1;\n\t\t\tint right = maxLen;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tif (check(C[middle], S[i])) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// C[left+1]???S???????????????\n\t\t\tif (left + 1 == maxLen) {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\t++maxLen;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tC[left + 1].add(S[i]);\n\t\t\t\tint[] tmp = C[left + 1].higher(S[i]);\n\t\t\t\twhile (tmp != null && tmp[1] >= S[i][1]) {\n\t\t\t\t\tC[left + 1].remove(tmp);\n\t\t\t\t\ttmp = C[left + 1].higher(S[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxLen);\n\t}\n\n\tint nextA(int a, int M) {\n\t\treturn 36969 * (a & M) + (a >> 16);\n\t}\n\n\tint nextB(int b, int M) {\n\t\treturn 18000 * (b & M) + (b >> 16);\n\t}\n\n\tint nextVal(int a, int b, int C) {\n\t\treturn (C & ((a << 16) + b)) % 1000000;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint A = sc.nextInt();\n\t\t\tint B = sc.nextInt();\n\t\t\tif (m == 0 && n == 0 && A == 0 && B == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] S = new int[m + n][3];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tS[i][0] = sc.nextInt();\n\t\t\t\tS[i][1] = sc.nextInt();\n\t\t\t\tS[i][2] = sc.nextInt();\n\t\t\t}\n\t\t\tint a = A, b = B, C = ~(1 << 31), M = (1 << 16) - 1;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\ta = nextA(a, M);\n\t\t\t\t\tb = nextB(b, M);\n\t\t\t\t\tS[i][j] = nextVal(a, b, C);\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(S, new Comparator<int[]>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\tif (o1[0] != o2[0])\n\t\t\t\t\t\treturn Integer.compare(o1[0], o2[0]);\n\t\t\t\t\telse if (o1[1] != o2[1]) {\n\t\t\t\t\t\treturn Integer.compare(o1[1], o2[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Integer.compare(o1[2], o2[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tint[][] tmp = new int[m + n][2];\n\t\t\tfor (int i = 0; i < m + n; ++i) {\n\t\t\t\ttmp[i][0] = S[i][1];\n\t\t\t\ttmp[i][1] = S[i][2];\n\t\t\t}\n\t\t\tsolve(m + n, tmp);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            for (;;)\n            {\n                var a = init(sc.Integer(), sc.Integer(), sc.Integer(), sc.Integer());\n                var n = a.Length;\n                if (n == 0) return;\n                var set = Enumerate(n + 5, x => new Set<long>());\n                Array.Sort(a, (l, r) =>\n                {\n                    if (l[0] != r[0]) return l[0].CompareTo(r[0]);\n                    if (l[1] != r[1]) return r[1].CompareTo(l[1]);\n                    return r[2].CompareTo(l[2]);\n                });\n                var b = Enumerate(n, x => a[x][1] * X + a[x][2]);\n                set[0].Add(0);\n                var ans = 0;\n                foreach (var x in b)\n                {\n                    var px = x / X;\n                    var py = x % X;\n                    var p = (px - 1) * X + py - 1;\n                    var l = 0; var r = n + 1;\n                    while (l + 1 < r)\n                    {\n                        var m = (l + r) / 2;\n                        if (contain(set[m], p)) l = m;\n                        else r = m;\n                    }\n                    ans = Math.Max(ans, r);\n                    add(set[r], x);\n                }\n                IO.Printer.Out.WriteLine(ans);\n            }\n        }\n        const long X = 1000000000;\n        bool contain(Set<long> s, long x)\n        {\n            var px = x / X;\n            var py = x % X;\n            var ptr = s.UpperBound(x) - 1;\n            if (ptr < 0) return false;\n            var q = s[ptr];\n            var qx = q / X;\n            var qy = q % X;\n            if (qx <= px && qy <= py) return true;\n            else return false;\n        }\n        void add(Set<long> s, long x)\n        {\n            var px = x / X;\n            var py = x % X;\n            var ptr = s.LowerBound(x);\n            while (ptr < s.Count)\n            {\n                var q = s[ptr];\n                var qx = q / X;\n                var qy = q % X;\n                if (px <= qx && py <= qy)\n                    s.RemoveAt(ptr);\n                else break;\n            }\n            ptr--;\n            if (ptr >= 0)\n            {\n                var q = s[ptr];\n                var qx = q / X;\n                var qy = q % X;\n                if (qx <= px && qy <= py) return;\n            }\n            s.Add(x);\n\n\n        }\n        int[][] init(int m, int n, int a, int b)\n        {\n\n            var ret = new int[m + n][];\n            for (int i = 0; i < m; i++)\n                ret[i] = sc.Integer(3);\n            const int c = ~(1 << 31);\n            const int M = (1 << 16) - 1;\n            Func<int> get = () =>\n               {\n                   unchecked\n                   {\n                       a = 36969 * (a & M) + (a >> 16);\n                       b = 18000 * (b & M) + (b >> 16);\n                       return ((c & ((a << 16) + b)) % 1000000);\n                   }\n               };\n            for (int i = m; i < m + n; i++)\n            {\n                ret[i] = new int[3];\n                for (int k = 0; k < 3; k++)\n                    ret[i][k] = get();\n            }\n            for (int i = 0; i < m + n; i++)\n                for (int j = 0; j < 3; j++)\n                    ret[i][j]++;\n            return ret;\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region Set<T>\npublic class Set<T>\n    where T : IComparable<T>\n{\n\n    Node root = Node.NIL;\n\n    public int Count { get { return root.cnt; } }\n    public void Add(T v) { Insert(v, LowerBound(v)); }\n    public bool Remove(T v)\n    {\n        if (EqualRange(v) == 0) return false;\n        RemoveAt(LowerBound(v));\n        return true;\n    }\n    #region Impl\n    public void Insert(T v, int k)\n    {\n        root = insert(root, v, k);\n    }\n    public void RemoveAt(int k)\n    {\n        root = removeat(root, k);\n    }\n    public int EqualRange(T v) { return UpperBound(v) - LowerBound(v); }\n    public int LowerBound(T v) { return lowerBound(root, v); }\n    public int UpperBound(T v) { return upperBound(root, v); }\n    public T this[int k] { get { return find(root, k); } }\n    Node insert(Node t, T v, int k)\n    {\n        Debug.Assert(t.cnt >= k);\n        if (t == Node.NIL) return new Node(v);\n        if (t.lst.cnt >= k)\n            t.lst = insert(t.lst, v, k);\n        else\n            t.rst = insert(t.rst, v, k - t.lst.cnt - 1);\n        t.Update();\n\n        if (t.lst.h - t.rst.h == -2)\n        {\n            if (t.rst.lst.h - t.rst.rst.h > 0) t.rst = rotR(t.rst);\n            t = rotL(t);\n        }\n        else if (t.lst.h - t.rst.h == 2)\n        {\n            if (t.lst.lst.h - t.lst.rst.h < 0) t.lst = rotL(t.lst);\n            t = rotR(t);\n        }\n        t.Update();\n        return t;\n    }\n    Node removeat(Node t, int k)\n    {\n        Debug.Assert(t.cnt > k);\n        var cnt = t.lst.cnt;\n        if (cnt < k) t.rst = removeat(t.rst, k - cnt - 1);\n        else if (cnt > k) t.lst = removeat(t.lst, k);\n        else\n        {\n            if (cnt == 0) return t.rst;\n            if (t.rst.cnt == 0) return t.lst;\n\n            t.val = find(t, k - 1);\n            t.lst = removeat(t.lst, k - 1);\n        }\n        t.Update();\n        if (t.lst.h - t.rst.h == -2)\n        {\n            if (t.rst.lst.h - t.rst.rst.h > 0) t.rst = rotR(t.rst);\n            t = rotL(t);\n        }\n        else if (t.lst.h - t.rst.h == 2)\n        {\n            if (t.lst.lst.h - t.lst.rst.h < 0) t.lst = rotL(t.lst);\n            t = rotR(t);\n        }\n        else t.Update();\n        return t;\n    }\n\n    int lowerBound(Node t, T v)\n    {\n        if (t.cnt == 0) return 0;\n        if (v.CompareTo(t.val) <= 0) return lowerBound(t.lst, v);\n        else return t.lst.cnt + 1 + lowerBound(t.rst, v);\n    }\n    int upperBound(Node t, T v)\n    {\n        if (t.cnt == 0) return 0;\n        if (t.val.CompareTo(v) <= 0) return t.lst.cnt + 1 + upperBound(t.rst, v);\n        else return upperBound(t.lst, v);\n    }\n    T find(Node t, int k)\n    {\n        Debug.Assert(k < t.cnt);\n        if (k == t.lst.cnt) return t.val;\n        else if (k < t.lst.cnt) return find(t.lst, k);\n        else return find(t.rst, k - (t.lst.cnt + 1));\n    }\n    Node rotR(Node t)\n    {\n        var l = t.lst;\n        var lr = l.rst;\n        l.rst = t;\n        t.lst = lr;\n        t.Update();\n        l.Update();\n        return l;\n    }\n    Node rotL(Node t)\n    {\n        var r = t.rst;\n        var rl = r.lst;\n        t.rst = rl;\n        r.lst = t;\n        t.Update();\n        r.Update();\n        return r;\n    }\n    #endregion\n    class Node\n    {\n        static public readonly Node NIL = new Node();\n        public int h;\n        public int cnt;\n        internal T val;\n        internal Node lst, rst;\n        private Node() { }\n        internal Node(T v) { h = 1; cnt = 1; val = v; lst = NIL; rst = NIL; }\n        public void Update()\n        {\n            if (cnt == 0) return;\n            h = 1 + Math.Max(lst.h, rst.h);\n            cnt = 1 + lst.cnt + rst.cnt;\n        }\n        public override string ToString()\n        {\n            return string.Format(\"count:{0}, value:{1}\", cnt, val);\n        }\n        public T[] Items { get { return items(this); } }\n        static public T[] items(Node t)\n        {\n            var ret = new T[t.cnt];\n            var ptr = 0;\n            dfs(t, ref ptr, ret);\n            return ret;\n        }\n        static void dfs(Node t, ref int ptr, T[] ret)\n        {\n            if (t == Node.NIL) return;\n            dfs(t.lst, ref ptr, ret);\n            ret[ptr++] = t.val;\n            dfs(t.rst, ref ptr, ret);\n        }\n    }\n    public T[] Items { get { return root.Items; } }\n    public override string ToString() { return string.Format(\"Count = {0}\", Count); }\n\n}\n#endregion\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst bool D = false;\n\nauto createGenerator(int A, int B) {\n    static const C = ~(1<<31), M = (1<<16)-1;\n    int a = A, b = B;\n    return delegate() {\n        a = 36969 * (a & M) + (a >> 16);\n        b = 18000 * (b & M) + (b >> 16);\n        return (C & ((a << 16) + b)) % 1000000;\n    };\n}\n\nstruct P {\n    int x, y, z;\n}\n\nstruct Q {\n    int y, z;\n    int opCmp(const ref Q q) const {\n        return y - q.y;\n    }\n}\n \nvoid main() {\n    int m, n, A, B; \n    while (readf(\"%d %d %d %d\\n\", &m, &n, &A, &B), m || n || A || B) {\n        auto gen = createGenerator(A, B);\n        int N = n + m;\n        P[] ps = new P[N];\n        foreach (i; 0 .. m) {\n            readf(\"%d %d %d\\n\", &ps[i].x, &ps[i].y, &ps[i].z);\n        }\n        foreach (i; 0 .. n) {\n            ps[m + i].x = gen();\n            ps[m + i].y = gen();\n            ps[m + i].z = gen();\n        }\n        ps.sort!((a, b) => a.x < b.x);\n\n        auto X = new RedBlackTree!Q [N];\n        foreach (ref x; X) x = new RedBlackTree!Q;\n\n        void I(int x, const ref P p) {\n            auto r = X[x].upperBound(Q(p.y - 1, p.z));\n            //writeln(\"x: \", x, \" y: \", p.y, \" r: \", r);\n            if (r.empty) {\n                if (X[x].empty || X[x].back.z > p.z) {\n                    //writeln([p.y, p.z]);\n                    auto q = Q(p.y, p.z);\n                    if (q in X[x] && X[x].equalRange(q).front.z > p.z) X[x].removeKey(q);\n                    X[x].insert(q);\n                }\n            } else {\n                auto q = Q(p.y, p.z);\n                auto r1 = X[x].lowerBound(q);\n                if (!r1.empty && r1.back.z <= p.z) return;\n                Q[] del;\n                foreach (e; r) {\n                    if (e.z >= p.z) del ~= e;\n                    else break;\n                }\n                foreach (e; del) {\n                    X[x].removeKey(e);\n                }\n                //writeln([p.y, p.z]);\n                //writeln(\"del: \", del);\n                if (q in X[x] && X[x].equalRange(q).front.z > p.z) X[x].removeKey(q);\n                X[x].insert(q);\n            }\n        }\n\n        int f(const ref P p) {\n\n            bool C(int x) {\n                if (X[x].empty) return false;\n                auto r = X[x].lowerBound(Q(p.y, p.z));\n                //writeln(\"lowerBound. x: \", x, \" X: \", X[x][], \" p: \", p, \" r: \", r);\n                if (r.empty) return false;\n                return r.back.z < p.z;\n            }\n\n            if (!C(0)) {\n                return 0;\n            }\n\n            int lb = 0, ub = N;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (C(mid)) {\n                    lb = mid;\n                } else {\n                    ub = mid;\n                }\n            }\n            return ub;\n        }\n\n        int[] v = new int[N];\n        for (int i = 0; i < N; ) {\n            int j;\n            for (j = 0; i + j < N && ps[i].x == ps[i + j].x; j++) {\n                v[i + j] = f(ps[i + j]);\n            }\n            for (j = 0; i + j < N && ps[i].x == ps[i + j].x; j++) {\n                I(v[i + j], ps[i + j]);\n            }\n            i += j;\n        }\n\n        static if (D) {\n            foreach (x; X) {\n                if (x.empty) break;\n                write(\"TREE: \");\n                foreach (e; x) e.write;\n                writeln;\n            }\n        }\n\n        int ans = 0;\n        foreach (i; 0 .. N) {\n            if (X[i].empty) break;\n            ans++;\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "#Longest Chain: O(NlogN + ??)\n\ndef R(A, B):\n    a, b = A, B\n    C, M = ~(1 << 31), (1 << 16) - 1\n    while True:\n        a = 3696 * (a & M) + (a >> 16)\n        b = 1800 * (b & M) + (b >> 16)\n        yield (C & ((a << 16) + b)) % 1000000\n\ndef compare(a, b):\n    return all(aa < bb for aa, bb in zip(a, b))\n\ndef upper_bound(data, a, comp):\n    left, right = 0, len(data)\n    while True:\n        mid = (right + left) / 2        \n        if not left < mid < right:\n            return right\n        if comp(data[mid], a):\n            left = mid\n        else:\n            right = mid\n\ndef solve(L):\n    A = [(0,0,0)]\n    val = {A[0]: 0}\n    count = 0\n    for n in L:\n        idx = upper_bound(A, n, compare)\n        A.insert(idx, n)\n        val[n] = val[A[idx - 1]] + 1\n    return max(val.values())\n\nwhile True:\n    m, n, A, B = map(int, raw_input().split())\n    if m | n | A | B == 0:\n        break\n    L = [tuple(map(int, raw_input().split())) for _ in xrange(m)]\n    r = R(A, B)\n    L += [(r.next(), r.next(), r.next()) for _ in xrange(n)]\n    L.sort()\n    print solve(L)"
  },
  {
    "language": "Python",
    "code": "#Longest Chain: O(n^2)\n\ndef R(A, B):\n    a, b = A, B\n    C, M = ~(1 << 31), (1 << 16) - 1\n    while True:\n        a = 3696 * (a & M) + (a >> 16)\n        b = 1800 * (b & M) + (b >> 16)\n        yield (C & ((a << 16) + b)) % 1000000\n\ndef check(p1, p2):\n    return all(map(lambda (x, y): x <= y, zip(p1, p2)))\n\ndef solve():\n    dp = [1] * (m + n)\n    for i in xrange(m + n):\n        for j in xrange(i + 1,m + n):\n            if check(L[i], L[j]):\n                dp[j] = max(dp[j], dp[i] + 1)\n    return max(dp)\n\nwhile True:\n    m, n, A, B = map(int, raw_input().split())\n    if m | n | A | B == 0:\n        break\n    L = [map(int, raw_input().split()) for _ in xrange(m)]\n    r = R(A, B)\n    L += [(r.next(), r.next(), r.next()) for _ in xrange(n)]\n    L.sort()\n    print solve()    "
  }
]