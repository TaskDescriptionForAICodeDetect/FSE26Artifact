[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, z;\n} Triple;\n\nint compare(const void *a, const void *b) {\n    Triple *t1 = (Triple *)a;\n    Triple *t2 = (Triple *)b;\n    if (t1->x != t2->x) return t1->x - t2->x;\n    if (t1->y != t2->y) return t1->y - t2->y;\n    return t1->z - t2->z;\n}\n\nint findLIS(Triple *triples, int n) {\n    int *dp = (int *)malloc(n * sizeof(int));\n    int max = 0;\n    for (int i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (int j = 0; j < i; j++) {\n            if (triples[j].x < triples[i].x && triples[j].y < triples[i].y && triples[j].z < triples[i].z) {\n                if (dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                }\n            }\n        }\n        if (dp[i] > max) {\n            max = dp[i];\n        }\n    }\n    free(dp);\n    return max;\n}\n\nint main() {\n    int N, M, A, B, x, y, z;\n    while (scanf(\"%d %d %d %d\", &N, &M, &A, &B) == 4) {\n        Triple *triples = (Triple *)malloc((N + M) * sizeof(Triple));\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d %d %d\", &x, &y, &z);\n            triples[i] = (Triple){x, y, z};\n        }\n        for (int i = 0; i < M; i++) {\n            x = 1 + (triples[i % N].x * A + triples[(i + 1) % N].x * B) % 10007;\n            y = 1 + (triples[i % N].y * A + triples[(i + 1) % N].y * B) % 10007;\n            z = 1 + (triples[i % N].z * A + triples[(i + 1) % N].z * B) % 10007;\n            triples[N + i] = (Triple){x, y, z};\n        }\n        qsort(triples, N + M, sizeof(Triple), compare);\n        int result = findLIS(triples, N + M);\n        printf(\"%d\\n\", result);\n        free(triples);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Triple {\n    int x, y, z;\n    bool operator<(const Triple& other) const {\n        return x < other.x && y < other.y && z < other.z;\n    }\n};\n\nvoid generateTriples(vector<Triple>& triples, int N, int A, int B) {\n    for (int i = 1; i < N; ++i) {\n        Triple prev = triples[i - 1];\n        Triple next;\n        next.x = (prev.x * A + prev.y * B) % 1000;\n        next.y = (prev.y * A + prev.z * B) % 1000;\n        next.z = (prev.z * A + prev.x * B) % 1000;\n        triples.push_back(next);\n    }\n}\n\nint longestAscendingSeries(vector<Triple>& triples) {\n    sort(triples.begin(), triples.end(), [](const Triple& a, const Triple& b) {\n        if (a.x != b.x) return a.x < b.x;\n        if (a.y != b.y) return a.y < b.y;\n        return a.z < b.z;\n    });\n\n    vector<int> dp;\n    for (const auto& t : triples) {\n        auto it = lower_bound(dp.begin(), dp.end(), t.z);\n        if (it == dp.end()) {\n            dp.push_back(t.z);\n        } else {\n            *it = t.z;\n        }\n    }\n    return dp.size();\n}\n\nint main() {\n    int M;\n    cin >> M;\n    while (M--) {\n        int N, A, B;\n        cin >> N >> A >> B;\n        vector<Triple> triples;\n        Triple first;\n        cin >> first.x >> first.y >> first.z;\n        triples.push_back(first);\n        generateTriples(triples, N, A, B);\n\n        cout << longestAscendingSeries(triples) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Triple implements Comparable<Triple> {\n    int x, y, z;\n\n    Triple(int x, int y, int z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    @Override\n    public int compareTo(Triple other) {\n        if (this.x != other.x) {\n            return this.x - other.x;\n        } else if (this.y != other.y) {\n            return this.y - other.y;\n        } else {\n            return this.z - other.z;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int N = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n            List<Triple> triples = new ArrayList<>();\n            \n            for (int i = 0; i < N; i++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int z = scanner.nextInt();\n                triples.add(new Triple(x, y, z));\n            }\n            \n            for (int i = N; i < A + N; i++) {\n                int x = (triples.get(i - N).x + triples.get(i - 1).x) % B;\n                int y = (triples.get(i - N).y + triples.get(i - 1).y) % B;\n                int z = (triples.get(i - N).z + triples.get(i - 1).z) % B;\n                triples.add(new Triple(x, y, z));\n            }\n            \n            Collections.sort(triples);\n            \n            int[] dp = new int[triples.size()];\n            int maxLen = 0;\n            \n            for (int i = 0; i < triples.size(); i++) {\n                dp[i] = 1;\n                for (int j = 0; j < i; j++) {\n                    if (triples.get(j).x < triples.get(i).x && \n                        triples.get(j).y < triples.get(i).y && \n                        triples.get(j).z < triples.get(i).z) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n                maxLen = Math.max(maxLen, dp[i]);\n            }\n            \n            System.out.println(maxLen);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 20:54:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LongestAscendingSeries {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            int n = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n\n            List<Triple> triples = new ArrayList<>();\n\n            // Add explicitly given triples\n            for (int i = 0; i < n; i++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int z = scanner.nextInt();\n                triples.add(new Triple(x, y, z));\n            }\n\n            // Generate additional triples\n            for (int i = n; i < n + A; i++) {\n                int x = (int) ((long) B * triples.get(i - 1).x + triples.get(i - 2).x) % 1000000007;\n                int y = (int) ((long) B * triples.get(i - 1).y + triples.get(i - 2).y) % 1000000007;\n                int z = (int) ((long) B * triples.get(i - 1).z + triples.get(i - 2).z) % 1000000007;\n                triples.add(new Triple(x, y, z));\n            }\n\n            int longestSeries = findLongestAscendingSeries(triples);\n            System.out.println(longestSeries);\n        }\n    }\n\n    private static int findLongestAscendingSeries(List<Triple> triples) {\n        Collections.sort(triples, (a, b) -> {\n            if (a.x != b.x) return Integer.compare(a.x, b.x);\n            if (a.y != b.y) return Integer.compare(a.y, b.y);\n            return Integer.compare(a.z, b.z);\n        });\n\n        int[] dp = new int[triples.size()];\n        Arrays.fill(dp, 1);\n\n        int maxLength = 1;\n        for (int i = 1; i < triples.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (isAscending(triples.get(j), triples.get(i))) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLength = Math.max(maxLength, dp[i]);\n        }\n\n        return maxLength;\n    }\n\n    private static boolean isAscending(Triple a, Triple b) {\n        return a.x < b.x && a.y < b.y && a.z < b.z;\n    }\n\n    static class Triple {\n        int x, y, z;\n\n        Triple(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:54:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TRIPLES 10000\n\ntypedef struct {\n    int x, y, z;\n} Triple;\n\nint compare_triples(const void* a, const void* b) {\n    Triple* trip_a = (Triple*)a;\n    Triple* trip_b = (Triple*)b;\n    \n    if (trip_a->x != trip_b->x)\n        return trip_a->x - trip_b->x;\n    if (trip_a->y != trip_b->y)\n        return trip_a->y - trip_b->y;\n    return trip_a->z - trip_b->z;\n}\n\nint is_ascending(Triple* a, Triple* b) {\n    return a->x < b->x && a->y < b->y && a->z < b->z;\n}\n\nint longest_ascending_series(Triple* triples, int n) {\n    qsort(triples, n, sizeof(Triple), compare_triples);\n    \n    int dp[MAX_TRIPLES];\n    memset(dp, 0, sizeof(dp));\n    \n    int max_length = 1;\n    \n    for (int i = 0; i < n; i++) {\n        dp[i] = 1;\n        for (int j = 0; j < i; j++) {\n            if (is_ascending(triples + j, triples + i)) {\n                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;\n            }\n        }\n        max_length = (max_length > dp[i]) ? max_length : dp[i];\n    }\n    \n    return max_length;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    for (int dataset = 0; dataset < datasets; dataset++) {\n        int m, a, b;\n        scanf(\"%d %d %d\", &m, &a, &b);\n        \n        Triple triples[MAX_TRIPLES];\n        int n = 0;\n        \n        for (int i = 0; i < m; i++) {\n            int x, y, z;\n            scanf(\"%d %d %d\", &x, &y, &z);\n            triples[n].x = x;\n            triples[n].y = y;\n            triples[n].z = z;\n            n++;\n        }\n        \n        for (int i = m; i < m + a; i++) {\n            int x = (triples[i-1].x * b + 1) % 100000;\n            int y = (triples[i-1].y * b + 1) % 100000;\n            int z = (triples[i-1].z * b + 1) % 100000;\n            triples[n].x = x;\n            triples[n].y = y;\n            triples[n].z = z;\n            n++;\n        }\n        \n        int result = longest_ascending_series(triples, n);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Triple {\n    int x, y, z;\n};\n\nbool compareTriples(const Triple& a, const Triple& b) {\n    return a.x < b.x && a.y < b.y && a.z < b.z;\n}\n\nint longestAscendingSeries(vector<Triple>& triples) {\n    int n = triples.size();\n    vector<int> dp(n, 1);\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (compareTriples(triples[j], triples[i])) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    for (int dataset = 0; dataset < datasets; dataset++) {\n        int n, A, B;\n        cin >> n >> A >> B;\n        \n        vector<Triple> triples;\n        \n        // Read explicit triples\n        for (int i = 0; i < n; i++) {\n            Triple t;\n            cin >> t.x >> t.y >> t.z;\n            triples.push_back(t);\n        }\n        \n        // Generate additional triples\n        for (int i = n; i < 2*n; i++) {\n            Triple t;\n            t.x = (A * triples[i-1].x + B) % 1000000007;\n            t.y = (A * triples[i-1].y + B) % 1000000007;\n            t.z = (A * triples[i-1].z + B) % 1000000007;\n            triples.push_back(t);\n        }\n        \n        int result = longestAscendingSeries(triples);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_ascending_series(triple_sets):\n    def can_follow(triple_a, triple_b):\n        return triple_a[0] < triple_b[0] and triple_a[1] < triple_b[1] and triple_a[2] < triple_b[2]\n\n    def lis_length(triples):\n        n = len(triples)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if can_follow(triples[j], triples[i]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    results = []\n    for triples, A, B, N in triple_sets:\n        generated_triples = [(A * i % B, A * (i + 1) % B, A * (i + 2) % B) for i in range(N)]\n        all_triples = triples + generated_triples\n        results.append(lis_length(all_triples))\n    return results\n\n# Example usage\n# triple_sets = [([(1, 2, 3), (2, 3, 4)], 4, 5, 10)]\n# print(longest_ascending_series(triple_sets))",
    "timestamp": "2025-08-13 04:02:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LongestAscendingSeries {\n    static class Triple implements Comparable<Triple> {\n        int x, y, z;\n\n        Triple(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public int compareTo(Triple other) {\n            if (this.x != other.x) return Integer.compare(this.x, other.x);\n            if (this.y != other.y) return Integer.compare(this.y, other.y);\n            return Integer.compare(this.z, other.z);\n        }\n    }\n\n    private static int findLongestAscendingSeries(List<Triple> triples) {\n        Collections.sort(triples);\n        int n = triples.size();\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int maxLen = 1;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (triples.get(j).x < triples.get(i).x &&\n                    triples.get(j).y < triples.get(i).y &&\n                    triples.get(j).z < triples.get(i).z) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        \n        for (int d = 0; d < datasets; d++) {\n            int givenCount = scanner.nextInt();\n            int generatedCount = scanner.nextInt();\n            int A = scanner.nextInt();\n            int B = scanner.nextInt();\n\n            List<Triple> triples = new ArrayList<>(givenCount + generatedCount);\n\n            for (int i = 0; i < givenCount; i++) {\n                int x = scanner.nextInt();\n                int y = scanner.nextInt();\n                int z = scanner.nextInt();\n                triples.add(new Triple(x, y, z));\n            }\n\n            for (int j = 0; j < generatedCount; j++) {\n                int x = (A * (j + 1)) % B;\n                int y = (A * (j + 1)) % B;\n                int z = (A * (j + 1)) % B;\n                triples.add(new Triple(x, y, z));\n            }\n\n            System.out.println(findLongestAscendingSeries(triples));\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 04:02:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, z;\n} Triple;\n\nint compareTriples(const void *a, const void *b) {\n    Triple *t1 = (Triple *)a;\n    Triple *t2 = (Triple *)b;\n    if (t1->x != t2->x) return t1->x - t2->x;\n    if (t1->y != t2->y) return t1->y - t2->y;\n    return t1->z - t2->z;\n}\n\nint longestAscendingSeries(Triple *triples, int n) {\n    int *dp = (int *)malloc(n * sizeof(int));\n    int longest = 1;\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i] = 1;\n    }\n    \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (triples[j].x < triples[i].x && triples[j].y < triples[i].y && triples[j].z < triples[i].z) {\n                if (dp[i] < dp[j] + 1) {\n                    dp[i] = dp[j] + 1;\n                }\n            }\n        }\n        if (longest < dp[i]) {\n            longest = dp[i];\n        }\n    }\n    \n    free(dp);\n    return longest;\n}\n\nint main() {\n    int datasetCount;\n    scanf(\"%d\", &datasetCount);\n    \n    for (int dataset = 0; dataset < datasetCount; ++dataset) {\n        int n, g;\n        scanf(\"%d %d\", &n, &g);\n        \n        Triple *triples = (Triple *)malloc((n + g) * sizeof(Triple));\n        \n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d %d\", &triples[i].x, &triples[i].y, &triples[i].z);\n        }\n        \n        int A, B;\n        int x1, x2, y1, y2, z1, z2;\n        scanf(\"%d %d\", &A, &B);\n        scanf(\"%d %d %d %d %d %d\", &x1, &x2, &y1, &y2, &z1, &z2);\n        \n        int prev_x = x1, prev_y = y1, prev_z = z1;\n        for (int i = 0; i < g; ++i) {\n            int xi = (prev_x * A + B) % x2;\n            int yi = (prev_y * A + B) % y2;\n            int zi = (prev_z * A + B) % z2;\n            triples[n + i].x = xi;\n            triples[n + i].y = yi;\n            triples[n + i].z = zi;\n            prev_x = xi;\n            prev_y = yi;\n            prev_z = zi;\n        }\n        \n        n += g;\n\n        qsort(triples, n, sizeof(Triple), compareTriples);\n\n        int result = longestAscendingSeries(triples, n);\n        printf(\"%d\\n\", result);\n\n        free(triples);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:03:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_longest_ascending_series(n, A, B, given_triples):\n    # Create the full list of triples\n    triples = given_triples.copy()\n    \n    # Generate additional triples\n    for i in range(len(given_triples), n):\n        x = (A * triples[i-1][0] + B) % 1000000\n        y = (A * triples[i-1][1] + B) % 1000000\n        z = (A * triples[i-1][2] + B) % 1000000\n        triples.append((x, y, z))\n    \n    # Longest Increasing Subsequence (LIS) logic\n    def is_ascending(a, b):\n        return a[0] < b[0] and a[1] < b[1] and a[2] < b[2]\n    \n    # Dynamic Programming to find longest ascending series\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if is_ascending(triples[j], triples[i]):\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# Input processing and output\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, A, B = map(int, input().split())\n        given_triples = []\n        \n        # Read given triples\n        for _ in range(min(3, n)):\n            x, y, z = map(int, input().split())\n            given_triples.append((x, y, z))\n        \n        result = solve_longest_ascending_series(n, A, B, given_triples)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 04:03:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import bisect\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        ptr += 1\n        A = int(input[ptr])\n        B = int(input[ptr+1])\n        ptr += 2\n        triples = []\n        for _ in range(N):\n            x = int(input[ptr])\n            y = int(input[ptr+1])\n            z = int(input[ptr+2])\n            triples.append((x, y, z))\n            ptr += 3\n        \n        # Generate additional triples\n        for i in range(1, 10001):\n            x = 1 + (A * i + B) % 10000\n            y = 1 + (B * i + A) % 10000\n            z = 1 + (A * (i + B) + B) % 10000\n            triples.append((x, y, z))\n        \n        # Sort the triples based on x, then y, then z\n        triples.sort()\n        \n        # Find LIS based on y and z\n        tails = []\n        for triple in triples:\n            y, z = triple[1], triple[2]\n            idx = bisect.bisect_left(tails, (y, z))\n            if idx == len(tails):\n                tails.append((y, z))\n            else:\n                if tails[idx][0] > y and tails[idx][1] > z:\n                    tails[idx] = (y, z)\n        print(len(tails))\n\nsolve()",
    "timestamp": "2025-08-13 04:03:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Represent a triple as a structure\nstruct Triple {\n    int x, y, z;\n    \n    // Custom comparison for sorting\n    bool operator<(const Triple& other) const {\n        if (x != other.x) return x < other.x;\n        if (y != other.y) return y < other.y;\n        return z < other.z;\n    }\n};\n\n// Function to find the longest increasing subsequence\nint longestAscendingSeries(const vector<Triple>& triples) {\n    int n = triples.size();\n    // dp array to store the length of longest sequence ending with each triple\n    vector<int> dp(n, 1);\n    \n    // Compute the LIS based on the given partial order\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (triples[j].x < triples[i].x && \n                triples[j].y < triples[i].y && \n                triples[j].z < triples[i].z) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    // Return the maximum length found\n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    int t;\n    cin >> t; // Number of datasets\n    while(t--) {\n        int n, g;\n        cin >> n >> g; // Number of explicitly given triples and generated triples\n        vector<Triple> triples(n + g);\n        \n        // Read given triples\n        for (int i = 0; i < n; ++i) {\n            cin >> triples[i].x >> triples[i].y >> triples[i].z;\n        }\n        \n        // Read parameters for generation\n        int a, b, c, p, q, r, x0, y0, z0;\n        cin >> a >> b >> c >> p >> q >> r >> x0 >> y0 >> z0;\n        \n        // Generate triples\n        for (int i = 0; i < g; ++i) {\n            x0 = (a * x0 + b) % p;\n            y0 = (c * y0 + a) % q;\n            z0 = (b * z0 + c) % r;\n            triples[n + i] = {x0, y0, z0};\n        }\n        \n        // Sort the triples\n        sort(triples.begin(), triples.end());\n        \n        // Get the length of the longest ascending series\n        cout << longestAscendingSeries(triples) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:16:47"
  }
]