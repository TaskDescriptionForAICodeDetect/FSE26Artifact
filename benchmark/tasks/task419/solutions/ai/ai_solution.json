[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_V 100000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_V * 2];\nint head[MAX_V];\nint color[MAX_V];\nint edge_count;\n\nvoid init(int V) {\n    for (int i = 0; i < V; ++i) {\n        head[i] = -1;\n        color[i] = -1;\n    }\n    edge_count = 0;\n}\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nint is_bipartite(int V) {\n    for (int i = 0; i < V; ++i) {\n        if (color[i] == -1) {\n            int queue[MAX_V];\n            int front = 0, rear = 0;\n            queue[rear++] = i;\n            color[i] = 0;\n            while (front < rear) {\n                int u = queue[front++];\n                for (int j = head[u]; j != -1; j = edges[j].next) {\n                    int v = edges[j].to;\n                    if (color[v] == -1) {\n                        color[v] = color[u] ^ 1;\n                        queue[rear++] = v;\n                    } else if (color[v] == color[u]) {\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n    init(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        --u; --v;\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    if (!is_bipartite(V)) {\n        printf(\"-1\\n\");\n    } else {\n        long long cnt0 = 0, cnt1 = 0;\n        for (int i = 0; i < V; ++i) {\n            if (color[i] == 0) cnt0++;\n            else cnt1++;\n        }\n        printf(\"%lld\\n\", cnt0 * cnt1 - E);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool isBipartite(vector<vector<int>>& graph, int V, vector<int>& color) {\n    queue<int> q;\n    for (int i = 0; i < V; ++i) {\n        if (color[i] == -1) {\n            color[i] = 0;\n            q.push(i);\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : graph[u]) {\n                    if (color[v] == -1) {\n                        color[v] = color[u] ^ 1;\n                        q.push(v);\n                    } else if (color[v] == color[u]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    vector<vector<int>> graph(V);\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<int> color(V, -1);\n    if (!isBipartite(graph, V, color)) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int cnt0 = 0, cnt1 = 0;\n    for (int c : color) {\n        if (c == 0) cnt0++;\n        else cnt1++;\n    }\n\n    int max_roads = cnt0 * cnt1 - E;\n    cout << max_roads << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int V = scanner.nextInt();\n        int E = scanner.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < V; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < E; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int[] color = new int[V];\n        Arrays.fill(color, -1);\n        boolean isBipartite = true;\n        Queue<Integer> queue = new LinkedList<>();\n\n        for (int i = 0; i < V; i++) {\n            if (color[i] == -1) {\n                queue.offer(i);\n                color[i] = 0;\n                while (!queue.isEmpty()) {\n                    int u = queue.poll();\n                    for (int v : adj.get(u)) {\n                        if (color[v] == -1) {\n                            color[v] = color[u] ^ 1;\n                            queue.offer(v);\n                        } else if (color[v] == color[u]) {\n                            isBipartite = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!isBipartite) {\n            System.out.println(-1);\n        } else {\n            int count0 = 0, count1 = 0;\n            for (int c : color) {\n                if (c == 0) count0++;\n                else count1++;\n            }\n            System.out.println(count0 * count1 - E);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:28:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RabbitRoads {\n    public static int maxRoads(int V, int[][] existingRoads) {\n        // Create adjacency list\n        List<List<Integer>> graph = new ArrayList<>(V);\n        for (int i = 0; i < V; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Add existing roads\n        for (int[] road : existingRoads) {\n            graph.get(road[0] - 1).add(road[1] - 1);\n            graph.get(road[1] - 1).add(road[0] - 1);\n        }\n        \n        // Check if any cycle exists with odd length\n        boolean[] visited = new boolean[V];\n        boolean hasCycle = false;\n        \n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                if (dfs(graph, i, visited, -1, 0)) {\n                    hasCycle = true;\n                    break;\n                }\n            }\n        }\n        \n        // If odd cycle exists, return -1\n        if (hasCycle) {\n            return -1;\n        }\n        \n        // Calculate max roads\n        int maxPossibleRoads = V * (V - 1) / 2;\n        int existingRoadCount = existingRoads.length;\n        \n        return maxPossibleRoads - existingRoadCount;\n    }\n    \n    private static boolean dfs(List<List<Integer>> graph, int node, boolean[] visited, \n                                int parent, int depth) {\n        visited[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (neighbor == parent) continue;\n            \n            if (visited[neighbor]) {\n                if ((depth + 1) % 2 == 1) {\n                    return true;\n                }\n            } else {\n                if (dfs(graph, neighbor, visited, node, depth + 1)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    public static void main(String[] args) {\n        int V1 = 4;\n        int[][] roads1 = {{1,2}, {2,3}, {3,4}};\n        System.out.println(maxRoads(V1, roads1));  // Example usage\n        \n        int V2 = 3;\n        int[][] roads2 = {{1,2}, {2,3}, {3,1}};\n        System.out.println(maxRoads(V2, roads2));  // Example usage\n    }\n}",
    "timestamp": "2025-08-05 21:28:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_V 501\n\nint V, E;\nint graph[MAX_V][MAX_V];\nbool visited[MAX_V];\nint dist[MAX_V];\n\nbool dfs(int node, int start, int steps) {\n    visited[node] = true;\n    \n    if (node == start && steps % 2 == 1 && steps > 0) {\n        return true;\n    }\n    \n    for (int next = 1; next <= V; next++) {\n        if (graph[node][next] && !visited[next]) {\n            if (dfs(next, start, steps + 1)) {\n                return true;\n            }\n        }\n    }\n    \n    visited[node] = false;\n    return false;\n}\n\nbool can_return_odd(int start) {\n    memset(visited, 0, sizeof(visited));\n    return dfs(start, start, 0);\n}\n\nint main() {\n    scanf(\"%d %d\", &V, &E);\n    \n    for (int i = 0; i < E; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = 1;\n    }\n    \n    int odd_return_count = 0;\n    for (int i = 1; i <= V; i++) {\n        if (can_return_odd(i)) {\n            odd_return_count++;\n        }\n    }\n    \n    if (odd_return_count == V) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int max_roads = (V * (V - 1)) / 2 - E;\n    printf(\"%d\\n\", max_roads);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXV = 505;\n\nclass Solution {\npublic:\n    int maxRoads(int V, vector<pair<int, int>>& roads) {\n        vector<vector<int>> graph(V + 1);\n        vector<int> degree(V + 1, 0);\n        \n        // Build graph\n        for (auto& road : roads) {\n            int u = road.first, v = road.second;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            degree[u]++;\n            degree[v]++;\n        }\n        \n        // Check if odd walk is already impossible\n        vector<bool> visited(V + 1, false);\n        if (!hasOddWalk(V, graph, visited)) {\n            return -1;\n        }\n        \n        // Compute max roads\n        int maxAdditionalRoads = 0;\n        for (int u = 1; u <= V; u++) {\n            for (int v = u + 1; v <= V; v++) {\n                if (find(graph[u].begin(), graph[u].end(), v) == graph[u].end()) {\n                    maxAdditionalRoads++;\n                }\n            }\n        }\n        \n        return maxAdditionalRoads;\n    }\n    \nprivate:\n    bool hasOddWalk(int V, vector<vector<int>>& graph, vector<bool>& visited) {\n        for (int start = 1; start <= V; start++) {\n            fill(visited.begin(), visited.end(), false);\n            if (dfs(start, start, 0, graph, visited)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    bool dfs(int curr, int start, int length, vector<vector<int>>& graph, vector<bool>& visited) {\n        visited[curr] = true;\n        \n        if (curr == start && length > 0 && length % 2 == 1) {\n            return true;\n        }\n        \n        for (int next : graph[curr]) {\n            if (!visited[next]) {\n                if (dfs(next, start, length + 1, graph, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        visited[curr] = false;\n        return false;\n    }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    \n    vector<pair<int, int>> roads(E);\n    for (int i = 0; i < E; i++) {\n        cin >> roads[i].first >> roads[i].second;\n    }\n    \n    Solution solution;\n    cout << solution.maxRoads(V, roads) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_additional_edges(V, E, roads):\n    import networkx as nx\n    \n    G = nx.Graph()\n    G.add_edges_from(roads)\n    \n    # Check if graph is bipartite\n    if not nx.is_bipartite(G):\n        return -1\n    \n    # Count existing edges\n    current_edges = len(G.edges())\n    \n    # A bipartite graph with |A| and |B| can have a maximum of |A| * |B| edges\n    partition = nx.bipartite.sets(G)\n    A, B = partition\n    \n    # Maximum edges in a bipartite graph\n    max_possible_edges = len(A) * len(B)\n    \n    # Calculate maximum additional edges\n    max_additional = max_possible_edges - current_edges\n    \n    return max_additional\n\n# Example Usage:\nV = 5\nE = 4\nroads = [(0, 1), (1, 2), (2, 3), (3, 4)]\nprint(max_additional_edges(V, E, roads))",
    "timestamp": "2025-08-13 06:36:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RabbitCity {\n    public static int maxEvenRoads(int V, int E, int[][] roads) {\n        List<Integer>[] graph = new ArrayList[V];\n        for (int i = 0; i < V; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int[] road : roads) {\n            graph[road[0]].add(road[1]);\n            graph[road[1]].add(road[0]);\n        }\n        \n        int[] color = new int[V];\n        Arrays.fill(color, -1);\n        \n        for (int i = 0; i < V; i++) {\n            if (color[i] == -1 && !bipartiteCheck(graph, color, i, 0)) {\n                return -1; // Rabbit's request already satisfied\n            }\n        }\n        \n        int black = 0, white = 0;\n        for (int c : color) {\n            if (c == 0) black++;\n            else if (c == 1) white++;\n        }\n        \n        return black * white - E;\n    }\n    \n    private static boolean bipartiteCheck(List<Integer>[] graph, int[] color, int node, int col) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(node);\n        color[node] = col;\n        \n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : graph[u]) {\n                if (color[v] == -1) {\n                    color[v] = 1 - color[u];\n                    queue.add(v);\n                } else if (color[v] == color[u]) {\n                    return false; // Not bipartite\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int V = 4;\n        int E = 3;\n        int[][] roads = {{0, 1}, {1, 2}, {2, 3}};\n        System.out.println(maxEvenRoads(V, E, roads)); // Outputs 1\n    }\n}",
    "timestamp": "2025-08-13 06:36:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_V 100\n\nint V, E;\nint adj[MAX_V][MAX_V];\nint visited[MAX_V];\nint depth[MAX_V];\n\nvoid add_road(int u, int v) {\n    adj[u][v] = 1;\n    adj[v][u] = 1;\n}\n\nvoid remove_road(int u, int v) {\n    adj[u][v] = 0;\n    adj[v][u] = 0;\n}\n\nint dfs(int u, int d) {\n    visited[u] = 1;\n    depth[u] = d;\n    for (int v = 0; v < V; v++) {\n        if (adj[u][v]) {\n            if (!visited[v]) {\n                if (dfs(v, d + 1)) return 1;\n            } else if ((depth[u] - depth[v]) % 2 == 0) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint check_odd_cycle() {\n    memset(visited, 0, sizeof(visited));\n    memset(depth, 0, sizeof(depth));\n    for (int u = 0; u < V; u++) {\n        if (!visited[u]) {\n            if (dfs(u, 0)) return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d %d\", &V, &E);\n    memset(adj, 0, sizeof(adj));\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_road(u, v);\n    }\n    \n    if (!check_odd_cycle()) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    \n    int max_additional_roads = 0;\n    for (int u = 0; u < V; u++) {\n        for (int v = u + 1; v < V; v++) {\n            if (!adj[u][v]) {\n                add_road(u, v);\n                if (!check_odd_cycle()) {\n                    max_additional_roads++;\n                } else {\n                    remove_road(u, v);\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_additional_roads);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:37:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_roads_to_add(V, E, roads):\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(V)]\n    for u, v in roads:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if current graph allows odd-length return paths\n    visited = [False] * V\n    def dfs(node, parity):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, 1 - parity):\n                    return True\n            elif visited[neighbor] and parity == 0:\n                return True\n        return False\n    \n    for start in range(V):\n        if not visited[start]:\n            if dfs(start, 0):\n                return -1\n    \n    # If no odd-length return paths exist, find max roads to add\n    return (V * (V - 1) // 2) - E\n\n# Example usage\nV, E = map(int, input().split())\nroads = []\nfor _ in range(E):\n    u, v = map(int, input().split())\n    roads.append((u, v))\n\nprint(max_roads_to_add(V, E, roads))",
    "timestamp": "2025-08-13 06:37:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    V, E = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(V+1)]\n    for _ in range(E):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (V+1)\n    is_bipartite = True\n    q = deque()\n    \n    for i in range(1, V+1):\n        if color[i] == -1:\n            color[i] = 0\n            q.append(i)\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        is_bipartite = False\n    \n    if not is_bipartite:\n        print(-1)\n    else:\n        cnt0 = color.count(0)\n        cnt1 = V - cnt0\n        max_edges = cnt0 * cnt1\n        print(max_edges - E)\n\nsolve()",
    "timestamp": "2025-08-13 06:37:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int node, int color, vector<vector<int>>& adj, vector<int>& colors, bool& isBipartite) {\n    colors[node] = color;\n    for (int neighbor : adj[node]) {\n        if (colors[neighbor] == 0) {\n            dfs(neighbor, -color, adj, colors, isBipartite);\n        } else if (colors[neighbor] == color) {\n            isBipartite = false;\n            return;\n        }\n    }\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    vector<vector<int>> adj(V + 1);\n    for (int i = 0; i < E; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> colors(V + 1, 0);\n    bool isBipartite = true;\n\n    for (int i = 1; i <= V; ++i) {\n        if (colors[i] == 0) {\n            dfs(i, 1, adj, colors, isBipartite);\n            if (!isBipartite) {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << V * (V - 1) / 2 - E << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:03"
  }
]