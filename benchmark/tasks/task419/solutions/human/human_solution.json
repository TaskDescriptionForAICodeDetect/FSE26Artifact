[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 100000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint v, ee;\nvector<int> e[100000];\nint val[100000];\nbool dp[2][100001];\n\nP dfs(int x, int now){\n    P ret = P(0,0);\n    val[x] = now;\n    if(now) ret.second++;\n    else ret.first++;\n    rep(i,e[x].size()){\n        if(val[e[x][i]] != 2 && val[e[x][i]] != (now^1)){\n            return P(-1,-1);\n        }\n        if(val[e[x][i]] != 2) continue;\n        P tmp = dfs(e[x][i],now^1);\n        if(tmp.first == -1) return P(-1,-1);\n        ret.first += tmp.first;\n        ret.second += tmp.second;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> v >> ee;\n    rep(i,v) val[i] = 2;\n    uf.init(v);\n    int ho = 0, ge = 1;\n    dp[ho][0] = true;\n    rep(i,ee){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n        uf.unite(a,b);\n    }\n    rep(i,v){\n        if(uf.find(i) != i) continue;\n        P d = dfs(i,0);\n        if(d.first == -1){\n            cout << -1 << endl;\n            return 0;\n        }\n        if(d.first > d.second) swap(d.first,d.second);\n        //cout << d.first << \" \" << d.second << endl;\n        memset(dp[ge],0,sizeof(dp[ge]));\n        for(int j = v/2+1; j >= 0; j--){\n            if(j >= d.first) dp[ge][j] |= dp[ho][j-d.first];\n            else break;\n            if(j >= d.second) dp[ge][j] |= dp[ho][j-d.second];\n        }\n        swap(ho,ge);\n    }\n    ll ans = 0;\n    for(ll i = 0; i <= v; i++){\n        if(dp[ho][i]) ans = max(ans,i*(v-i));\n    }\n    cout << ans-ee << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n\n    map<int,int> m;\n    for (int i = 0; i < s[0].size(); i++) {\n        if (s[0][i].size() == s[1][i].size()) {\n            m[s[0][i].size()]++;\n        } else {\n            m[s[0][i].size()]++;\n            m[s[1][i].size()]++;\n        }\n    }\n\n    vector<int> dp((N+3)/2, -1);\n    dp[0] = 0;\n    for (auto p : m) {\n        for (int i = 0; i < dp.size(); i++) {\n            if (dp[i] >= 0) dp[i] = p.second;\n            else if (i < p.first || dp[i - p.first] < 0) dp[i] = -1;\n            else dp[i] = dp[i - p.first] - 1;\n        }\n    }\n\n    int ans = dp.size() - 1;\n    while (dp[ans] < 0) ans--;\n\n    cout << ans * (N - ans) - M << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nconstexpr int max_v = 100000;\nint main() {\n    // input\n    int v, e; scanf(\"%d%d\", &v, &e);\n    vector<vector<int> > g(v);\n    repeat (i, e) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    bool is_impossible = false;\n    vector<pair<int, int> > component_size; {\n        vector<char> color(v);\n        function<bool (int, char, int &, int &)> go = [&](int i, char c, int & red_count, int & black_count) {\n            if (color[i]) return color[i] == c;\n            color[i] = c;\n            (c == 'R' ? red_count : black_count) += 1;\n            char d = c ^ 'R' ^ 'B';\n            for (int j : g[i]) {\n                if (not go(j, d, red_count, black_count)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        repeat (i, v) if (not color[i]) {\n            int red_count = 0;\n            int black_count = 0;\n            if (go(i, 'R', red_count, black_count)) {\n                component_size.emplace_back(red_count, black_count);\n            } else {\n                is_impossible = true;\n                break;\n            }\n        }\n    }\n    ll result = -1;\n    if (not is_impossible) {\n        bitset<max_v+1> dp = {};\n        dp[0] = true;\n        for (auto it : component_size) {\n            int a, b; tie(a, b) = it;\n            dp = (dp << a) | (dp << b);\n        }\n        repeat (a, v+1) if (dp[a]) {\n            ll b = v - a;\n            setmax(result, a * b - e);\n        }\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\nusing ll = long long;\n\n\nstruct Graph {\n    Graph(const int n) : edge(n) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n};\n\nusing P = pair<int, int>;\nP dfs(const Graph& g, const int s, vector<int>& color, bool black = true)\n{\n    int b = 1;\n    int w = 0;\n    color[s] = (int)(black);\n    for (const int to : g.edge[s]) {\n        if (color[to] != -1) {\n            if (black == color[to]) {\n                return make_pair(-1, -1);\n            }\n            continue;\n        }\n        int sb, sw;\n        tie(sw, sb) = dfs(g, to, color, not black);\n        if (sw == -1) {\n            return make_pair(-1, -1);\n        }\n        w += sw;\n        b += sb;\n    }\n    return make_pair(b, w);\n}\n\nint main()\n{\n    ll V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.addEdge(a, b);\n    }\n    vector<int> div;\n    vector<int> color(V, -1);\n    for (int i = 0; i < V; i++) {\n        if (color[i] != -1) {\n            continue;\n        }\n        const auto p = dfs(g, i, color);\n        if (p.first == -1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        div.push_back(abs(p.first - p.second));\n    }\n\n    sort(div.begin(), div.end());\n    auto a = div;\n    a.erase(unique(a.begin(), a.end()), a.end());\n    vector<int> num(a.size());\n    int pos = 0;\n    for (int i = 0; i < a.size(); i++) {\n        int n = 0;\n        for (; pos < div.size(); pos++) {\n            if (div[pos] == a[i]) {\n                n++;\n            } else {\n                break;\n            }\n        }\n        num[i] = n;\n    }\n    const int sum = accumulate(div.begin(), div.end(), 0);\n    const int half = sum / 2;\n    vector<int> dp(sum + 1, -1);\n    const int size = a.size();\n    dp[0] = 0;\n    for (int i = 0; i < size; i++) {\n        vector<int> copy = dp;\n        for (int j = 0; j <= sum; j++) {\n            if (copy[j] >= 0) {\n                dp[j] = num[j];\n            } else if (j < a[i] or dp[j - a[i]] <= 0) {\n                dp[j] = -1;\n            } else {\n                dp[j] = dp[j - a[i]] - 1;\n            }\n        }\n    }\n    ll mini = sum + 1;\n    for (int i = 0; i <= sum; i++) {\n        if (dp[i] > -1) {\n            mini = min(mini, (ll)abs(i - half));\n        }\n    }\n    cout << ((V - mini) / 2) * ((V + mini) / 2) - E << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n  vector<PLL> xs;\n  VI parity(V);\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  xs.EB(res);\n\t}\n  }\n  \n  LL ans = 0;\n  bitset<100001> bs;\n  bs[0] = 1;\n  for(auto& p: xs)\n\tbs = (bs << p.FF) | (bs << p.SS);\n\n  REP(i,V+1)\n\tif(bs[i]){\n\t  maxi(ans, (LL)i * (V - i));\n\t}\n  cout << ans - E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,x,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nvector<vi> edges;\nvi color;\nmap<int, int> d2n;\n\nusing pii = pair<int, int>;\n#define fst first\n#define snd second\n\nbool ok = true;\n\npii dfs(int v, bool b){\n    color[v] = b ? 1:0;\n\n    pii ret(b ? 1:0, b ? 0:1);\n    for(auto & nv : edges[v]){\n        if(color[nv] == b) ok = false;\n        if(color[nv] != -1) continue;\n\n        pii nret = dfs(nv, !b);\n        ret.fst += nret.fst; ret.snd += nret.snd;\n    }\n\n    return ret;\n}\n\nint main(void){\n    int n, m; cin >> n >> m;\n    edges = vector<vi>(n);\n\n    rep(loop, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n\n    color = vi(n, -1);\n    int min_b = 0;\n    rep(i, n){\n        if(color[i] != -1) continue;\n\n        pair<int, int> ret = dfs(i, true);\n        if(ret.fst > ret.snd) swap(ret.fst, ret.snd);\n\n        d2n[ret.snd - ret.fst]++;\n        min_b += ret.fst;\n    }\n\n    if(not ok){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int opt = n / 2 - min_b;\n    vi dp(opt + 1, -1);\n    dp[0] = 0;\n\n    for(auto & e : d2n){\n        rep(i, opt + 1){\n            if(dp[i] >= 0){\n                dp[i] = e.snd;\n            }\n            else if(i - e.fst < 0 or dp[i - e.fst] <= 0){\n                dp[i] = -1;\n            }\n            else {\n                dp[i] = dp[i - e.fst] - 1;\n            }\n        }\n    }\n\n    rrep(i, opt + 1){\n        if(dp[i] >= 0){\n            int num_b = min_b + i;\n            cout << 1LL * num_b * (n - num_b) - m << endl;\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint V,E;\nvector<int> g[100100];\nbool used[100100];\nint col[100100];\nbool flag=false;\nint cnt[3];\nbool dp[100100];\nint num[600];\nmap<int,int> m;\nvoid dfs(int v,int c)\n{\n\tused[v]=true;\n\tcol[v] = c;\n\tcnt[c+1]++;\n\tfor(int i=0;i<g[v].size();i++)\n\t{\n\t\tif(used[g[v][i]]&&col[g[v][i]]==col[v])flag=true;\n\t\tif(!used[g[v][i]])dfs(g[v][i],-c);\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<int> v;\n\tll base = 0ll;\n\tll sum = 0ll;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcnt[0]=0,cnt[2]=0;\n\t\tif(!used[i])\n\t\t{\n\t\t\tdfs(i,1);\n\t\t\tif(cnt[0]>cnt[2])swap(cnt[0],cnt[2]);\n\t\t\tbase += cnt[0];\n\t\t\tsum += cnt[2]-cnt[0];\n\t\t\tv.pb(cnt[2]-cnt[0]);\n\t\t\tm[cnt[2]-cnt[0]]++;\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\tint N = v.size();\n\t//cout << base << ' ' << sum << endl;\n\tfor(int i=0;i<N;i++)num[i]=m[v[i]];\n\t//for(int i=0;i<N;i++)printf(\"%d %d\\n\",v[i],num[i]);\n\tdp[0]=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<=V;j++)\n\t\t{\n\t\t\tif(dp[j]>=0)dp[j]=num[i];\n\t\t\telse if(j<v[i]||dp[j-v[i]]<=0)dp[j]=-1;\n\t\t\telse dp[j] = dp[j-v[i]]-1;\n\t\t}\n\t}\n\tll ans = 0ll;\n\tfor(int i=0;i<=V;i++)if(dp[i]>=0)ans = max(ans,(base+i)*(base+sum-i));\n\tprintf(\"%lld\\n\",ans-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\nvector<int> G[100010];\nint col[100010];\nvoid dfs(int s,int c){\n    col[s] = c;\n    for(int v:G[s]){\n        if(col[v]==-1) dfs(v,1 - c);\n    }\n}\n\nbool bip_ch(int v){\n    int i;\n    for(i=0;i<v;i++){\n        col[i] = -1;\n    }\n    for(i=0;i<v;i++){\n        if(col[i]==-1) dfs(i,0);\n    }\n    for(i=0;i<v;i++){\n        for(int ver:G[i]){\n            if(col[i]==col[ver]) return false;\n        }\n    }\n    return true;\n}\n\nint par[100010],sz[100010],wh[100010];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i; sz[i] = 1; wh[i] = col[i];\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x); y = find(y);\n\tif(x==y) return;\n\tif(sz[x]>sz[y]) swap(x,y);\n\tpar[x] = y;\n\tsz[y] += sz[x]; wh[y] += wh[x];\n}\n\nbitset<100010> dp1,dp2;\nint main(){\n    long long i,j,n,m;\n    cin >> n >> m;\n    for(i=0;i<m;i++){\n        int a,b; cin >> a >> b;\n        a--; b--;\n        G[a].push_back(b); G[b].push_back(a);\n    }\n    if(!bip_ch(n)){\n        cout << -1 << endl;\n        return 0;\n    }\n    init(n);\n    for(i=0;i<n;i++){\n        for(int v:G[i]){\n            unite(v,i);\n        }\n    }\n    dp1[0] = 1;\n    for(i=0;i<n;i++){\n        if(par[i]==i){\n            dp2 = (dp1<<wh[i]);\n            dp2 |= (dp1<<(sz[i] - wh[i]));\n            dp1 = dp2;\n        }\n    }\n    for(i=n/2;i>=0;i--){\n        if(dp1[i]){\n            cout << i*(n - i) - m << endl;\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\nvector<int> G[N];\n\nint color[N],idx=-1,startcolor=0;\n\nvoid dfs(int x,int c){\n\n  color[x]=c;\n\n  idx=x;\n  startcolor=!c;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i];\n\n    if(color[nx]==c){\n      cout<<-1<<endl;\n      exit(0);\n    }\n    \n    if(color[nx]==-1) dfs(nx,!c);\n    \n  }\n\n}\n\nint main(){\n\n  int n,e;\n\n  cin>>n>>e;\n\n  for(int i=0;i<e;i++){\n\n    int a,b;\n    cin>>a>>b;\n\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n    \n  }\n\n  memset(color,-1,sizeof(color));\n  \n  for(int i=0;i<n;i++)\n    \n    if(color[i]==-1){\n\n      if(idx>=0){\n\tG[idx].push_back(i);\n\tG[i].push_back(idx);\n      }\n      \n      dfs(i,startcolor);\n      \n    }\n\n  int cnt0=0,cnt1=0;\n\n  for(int i=0;i<n;i++)\n    if(!color[i]) cnt0++;\n    else cnt1++;\n\n  int ans=0;\n\n  for(int i=0;i<n;i++){\n\n    int sum=0;\n    \n    for(int j=0;j<G[i].size();j++)\n\n      if(color[i]!=color[G[i][j]]){\n\tsum++;\n\tif(i>G[i][j])sum++;\n      }\n    \n    if(!color[i]) ans+=cnt1-sum;\n    else ans+=cnt0-sum;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[N];\n\nint color[N],idx=-1,startcolor=0;\n\nvoid dfs(int x,int c){\n\n  color[x]=c;\n\n  idx=x;\n  startcolor=!c;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i];\n\n    if(color[nx]==c){\n      cout<<-1<<endl;\n      exit(0);\n    }\n    \n    if(color[nx]==-1) dfs(nx,!c);\n    \n  }\n\n}\n\nint main(){\n\n  int n,e;\n\n  cin>>n>>e;\n\n  for(int i=0;i<e;i++){\n\n    int a,b;\n    cin>>a>>b;\n\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n    \n  }\n\n  memset(color,-1,sizeof(color));\n  \n  for(int i=0;i<n;i++)\n    \n    if(color[i]==-1){\n\n      if(idx>=0){\n\tG[idx].push_back(i);\n\tG[i].push_back(idx);\n      }\n      \n      dfs(i,startcolor);\n      \n    }\n\n  int cnt0=0, cnt1=0;\n  \n  for(int i=0;i<n;i++)\n    if(!color[i]) cnt0++;\n    else cnt1++;\n\n  ll ans=0;\n\n  for(int i=0;i<n;i++){\n    \n    ll sum=0;\n    \n    for(int j=0;j<G[i].size();j++)\n      \n      if(color[i]!=color[G[i][j]]){\n\tsum++;\n\tif(i>G[i][j])sum++;\n      }\n    \n    if(!color[i]) ans+=cnt1-sum;\n    else ans+=cnt0-sum;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] < CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType2[0], CityType2[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nstruct Part {\n\tlint a, b;\n\tlint sub() const { return abs(a - b); }\n\tlint maxi() const { return max(a, b); }\n\tlint mini() const { return min(a, b); }\n\tbool operator > (const Part& o) const { return sub() > o.sub(); }\n};\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tcol.assign(N, -1);\n\t\n\tlint ans = 0;\n\tvector< Part > parts;\n\t\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tlint a = g[0].size(), b = g[1].size();\n\t\tparts.push_back(Part{a, b});\n\t\t\n\t\tlint sum = 0;\n\t\tfor (int u : g[0]) sum += adj[u].size();\n\t\tans += a * b - sum;\n\t}\n\t\n\tif (!flag) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tsort(parts.begin(), parts.end(), greater< Part >());\n\t\n\tint m = parts.size();\n\tlint sub = 0;\n\tvector< lint > a, b;\n\t\n\tfor_(i,0,m) {\n\t\tif (sub >= 0) {\n\t\t\tsub -= parts[i].sub();\n\t\t\ta.push_back(parts[i].maxi());\n\t\t\tb.push_back(parts[i].mini());\n\t\t} else {\n\t\t\tsub += parts[i].sub();\n\t\t\ta.push_back(parts[i].mini());\n\t\t\tb.push_back(parts[i].maxi());\n\t\t}\n\t}\n\t\n\tlint suma = 0, sumb = 0;\n\t\n\tfor_(i,0,m) {\n\t\tans += suma * b[i] + sumb * a[i];\n\t\tsuma += a[i];\n\t\tsumb += b[i];\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr int INF = 1001001001;\n//constexpr ll INF = 1001001001001001001ll;\nconstexpr double EPS = 1e-10;\nusing number = long long;\n\n\n\n// nums[i] := i 番目の連結成分の {左ノード数, 右ノード数}, 「dir = 1: 左、-1: 右」\nusing Graph = vector<vector<int> >;\n\n//dfs()とisbiparite()で二部グラフ判定を行う 　副作用でi番目の連結成分について調べる(UnionFindでも似たようなことはできる)\nbool dfs(const Graph &G, int v, int vdir, pii &num, vector<int> &dir) {\n    bool res = true;\n    dir[v] = vdir;\n    if (vdir == 1) ++num.first;\n    else if (vdir == -1) ++num.second;\n    for (auto nv : G[v]) {\n        if (dir[nv] == 0) {\n            if (!dfs(G, nv, -vdir, num, dir)) res = false;\n        }\n        else if (dir[nv] != -vdir) res = false;\n    }\n    return res;\n}\n\nbool isbipartite(const Graph &G, vector<pii> &nums) {\n    bool res = true;\n    int N = (int)G.size();\n    vector<int> dir(N, 0);\n    for (int v = 0; v < N; ++v) {\n        if (dir[v] != 0) continue;\n        pii num = {0, 0};\n        if (!dfs(G, v, 1, num, dir)) res = false;\n        nums.push_back(num);\n    }\n    return res;\n}\n\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    for (int i = 0; i < E; ++i) {\n        int a, b; cin >> a >> b; --a, --b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    // 二部グラフ判定して、左ノード数と右ノード数の差分ごとに集計\n    vector<pii> nums;\n    if (!isbipartite(G, nums)) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    //√Vでの平方分割を行う\n    map<int, int> ma;\n    for (auto p : nums) ma[abs(p.first - p.second)]++;\n\n    // DP　dp[i][v]は最初の i (<= √V)種類だけ見て、総和が実質 v になるようにしたときの、最後の要素の使用最小値\n    //特にINFでなければ総和がvの組み合わせが存在(余分な情報を持たせてdpを回す 個数制限付き部分和問題)　\n    //実装上iは省略し配列使いまわし\n    int geta = 0;\n    vector<int> dp(V * 2 + 10, INF);\n    dp[0] = 0;\n    for (auto it = ma.begin(); it != ma.end(); ++it) {\n        int diff = it->first;\n        geta += diff * it->second;\n        for (int v = 0; v <= V * 2; ++v) {\n            if (dp[v] < INF) dp[v] = 0;\n        }\n        for (int v = 0; v <= V * 2; ++v) {\n            if (v + diff * 2 <= V * 2 && dp[v] < it->second) {\n                chmin(dp[v + diff * 2], dp[v] + 1);\n            }\n        }\n    }\n\n    // 集計\n    int diff = V;\n    for (int v = 0; v <= V * 2; ++v) {\n        if (dp[v] < INF) chmin(diff, abs(v - geta));\n    }\n\n    ll a = (V + diff) / 2, b = (V - diff) / 2;\n    cout << a * b - E << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint main() {\n    // input\n    int v, e; scanf(\"%d%d\", &v, &e);\n    vector<vector<int> > g(v);\n    repeat (i, e) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    bool is_impossible = false;\n    vector<int> component_size_delta; {\n        vector<char> color(v);\n        function<bool (int, char, int &, int &)> go = [&](int i, char c, int & red_count, int & black_count) {\n            if (color[i]) return color[i] == c;\n            color[i] = c;\n            (c == 'R' ? red_count : black_count) += 1;\n            char d = c ^ 'R' ^ 'B';\n            for (int j : g[i]) {\n                if (not go(j, d, red_count, black_count)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        repeat (i, v) if (not color[i]) {\n            int red_count = 0;\n            int black_count = 0;\n            if (go(i, 'R', red_count, black_count)) {\n                component_size_delta.push_back(abs(red_count - black_count));\n            } else {\n                is_impossible = true;\n                break;\n            }\n        }\n    }\n    ll result = -1;\n    if (not is_impossible) {\n        vector<int> cur, prv;\n        cur.push_back(0);\n        for (int delta : component_size_delta) {\n            cur.swap(prv);\n            cur.clear();\n            for (auto it : prv) {\n                cur.push_back(it + delta);\n                cur.push_back(abs(it - delta));\n            }\n            whole(sort, cur);\n            cur.erase(whole(unique, cur), cur.end());\n        }\n        for (int delta : cur) {\n            ll a = (v + delta) / 2;\n            ll b = (v - delta) / 2;\n            setmax(result, a * b - e);\n        }\n    }\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint V, E;\nvector< vector<int> > graph;\nint color[100010];\n\nPi dfs(int u, int c) {\n  Pi res(0, 0);\n  color[u] = c;\n  if(c == 1) res.first++;\n  else res.second++;\n  for(int v : graph[u]) {\n    if(color[v] == c) return Pi(-1, -1);\n    if(color[v] == 0) {\n      Pi tmp = dfs(v, -c);\n      if(tmp.first < 0) return Pi(-1, -1);\n      res.first += tmp.first;\n      res.second += tmp.second;\n    }\n  }\n  return res;\n}\n\nmap<int, int> mp;\n\nint dp[100010]; // テ・ツ?凝ヲツ閉ーテ・ツ按カテゥツ卍静、ツサツ佚」ツ?催ゥツδィテ・ツ按?・ツ陳?テ」ツ??」ツ?湘」ツ?、テ」ツ?凝」ツ?ョテ・ツョツ古・ツ?ィテ、ツコツ古ゥツδィテ」ツつーテ」ツδゥテ」ツδ陛」ツつ津」ツ?湘」ツ?」テ」ツ?、テ」ツ?妥」ツ?ヲテ」ツつづ・ツョツ古・ツ?ィテ、ツコツ古ゥツδィテ」ツつーテ」ツδゥテ」ツδ陛」ツ?ォテ」ツ?ァテ」ツ?催」ツ?敕」ツ??」ツ?ェテ」ツ?ョテ」ツ?ァテ」ツ??」ツ??ヲツ?淌」ツ?佚」ツ?ォテ」ツ?湘」ツ?」テ」ツ?、テ」ツ?妥」ツ?淌」ツ??」ツ?づゥツサツ津」ツつ津」ツ?ゥテ」ツつ古」ツ??」ツ?妥・ツ「ツ療」ツつ?」ツ?崚」ツつ凝」ツ??\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> V >> E;\n  resz(graph, V);\n  rep(i, E) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  mp.clear();\n  memset(color, 0, sizeof(color));\n  int v = 0; // テ、ツコツ古ゥツδィテ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテァツ可?ヲツ鳴ケテ」ツ?ァテ、ツスツ愿」ツつ古」ツつ凝ヲツ慊?・ツーツ湘」ツ?ョテゥツδィテ・ツ按?ゥツ崢?・ツ青暗」ツ?ョテ・ツ、ツァテ」ツ?催」ツ??\n  rep(i, V) {\n    if(color[i] != 0) continue;\n    Pi p = dfs(i, 1);\n    int a = min(p.first, p.second);\n    int b = max(p.first, p.second);\n    if(a < 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    mp[b-a]++;\n    v += a;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for(auto p : mp) {\n    int plus = p.first, num = p.second;\n    rep(i, V+1) {\n      if(dp[i] >= 0) dp[i] = num;\n      else if(i < plus || dp[i-plus] <= 0) dp[i] = -1;\n      else dp[i] = dp[i-plus]-1;\n    }\n  }\n  int ans = 0;\n  rep(i, V+1) if(dp[i] >= 0) chmax(ans, (v+i)*(V-v-i));\n  cout << ans-E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint V, E, a, b, col[100009]; bool flag; vector<int> g[100009];\nvoid dfs(int pos) {\n\ta++;\n\tif (col[pos] == 1) b++;\n\tfor (int i : g[pos]) {\n\t\tif (col[pos] == col[i]) flag = true;\n\t\tif (!col[i]) col[i] = 3 - col[pos], dfs(i);\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tbitset<50001> dp = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (!col[i]) {\n\t\t\ta = b = 0; col[i] = 1;\n\t\t\tdfs(i);\n\t\t\tif (b * 2 > a) b = a - b;\n\t\t\tcur += b;\n\t\t\tdp |= dp << (a - b * 2);\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = cur; i <= V && i - cur <= 50000; i++) {\n\t\tif (dp[i - cur]) ret = max(ret, 1LL * i * (V - i));\n\t}\n\tprintf(\"%lld\\n\", (flag ? -1LL : ret - E));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nP dfs(int v,int b,vi& used){\n\tused[v]=b;\n\tP p;\n\tif(b) p.first++;\n\telse p.second++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(used[u]==-1){\n\t\t\tP q=dfs(u,!b,used);\n\t\t\tp.first+=q.first;\n\t\t\tp.second+=q.second;\n\t\t}\n\t\tif(used[u]==b) return {-inf,0};\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvi used(n,-1);\n\tint tmp=0;\n\tmap<int,int> M;\n\tfor(int i=0;i<n;i++) if(used[i]==-1){\n\t\tP p=dfs(i,1,used);\n\t\tint A=p.first,B=p.second;\n\t\tif(A<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp+=min(A,B);\n\t\tM[abs(A-B)]++;\n\t}\n\tvi dp(n+1);\n\tdp[tmp]=1;\n\tfor(auto i=M.begin();i!=M.end();i++){\n\t\tint v=i->first,N=i->second;\n\t\tvi DP(n+1,-1);\n\t\tfor(int j=v;j<=n;j++){\n\t\t\tint dp_=DP[j-v];\n\t\t\tif(dp_!=-1&&dp_<N){\n\t\t\t\tDP[j]=dp_+1;\n\t\t\t\tdp[j]|=1;\n\t\t\t}\n\t\t\tif(dp[j]) DP[j]=0;\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<=n;i++) res=max(res,(ll)dp[i]*i*(n-i));\n\tcout<<res-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint V, E, a, b, col[100009]; bool flag; vector<int> g[100009];\nvoid dfs(int pos) {\n\ta++;\n\tif (col[pos] == 1) b++;\n\tfor (int i : g[pos]) {\n\t\tif (col[pos] == col[i]) flag = true;\n\t\tif (!col[i]) col[i] = 3 - col[pos], dfs(i);\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tbitset<100001> dp = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (!col[i]) {\n\t\t\ta = b = 0; col[i] = 1;\n\t\t\tdfs(i);\n\t\t\tcur += b;\n\t\t\tdp |= 1 << (a - b);\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = cur; i <= V; i++) {\n\t\tif (dp[i - cur]) ret = max(ret, 1LL * i * (V - i));\n\t}\n\tprintf(\"%lld\\n\", (flag ? -1LL : ret - E));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(P(a[1],a[0]));\n    else return -1;\n  }\n  int k=0,m=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<=m;j++){\n      if(dp[f][j])\n\tdp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1,\n\t  m=max(m,j+max(v[i].first,v[i].second));\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      if((V-k)*k<(V-i)*i) k=i;\n    }\n  }\n  return (V-k)*k-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\n\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int> > G(N);\n  REP(i, M){\n    int a, b;\n    cin >> a >> b; a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n    // cout << a << \" \" << b << endl;\n  }\n\n  vector<int> color(N, -1);\n  map<int, int> diffs;\n\n\n  ll S = 0;\n  REP(i, N) if (color[i] == -1){\n    queue<int> que;\n    que.push(i);\n    color[i] = 0;\n    vector<int> count(2, 0);\n\n    \n    while (!que.empty()){\n      int v = que.front(); que.pop();\n      // cout << v << endl;\n\n      count[color[v]]++;\n      for (int w : G[v]){\n        if (color[w] == color[v]) {\n          cout << -1 << endl;\n          return 0;\n        } else if (color[w] == -1){\n          color[w] = 1 - color[v];\n          que.push(w);\n        }\n      }\n    }\n    diffs[abs(count[1] - count[0])]++;\n    S += *min_element(ALL(count));\n  }\n  vector<int> dp(2 * N + 1, -1);\n  dp[0] = 0;\n  for (const auto &p : diffs){\n    REP(j, 2 * N + 1){\n      if (dp[j] >= 0){\n        dp[j] = p.second;\n      } else if (j < p.first || dp[j - p.first] <= 0){\n        dp[j] = -1;\n      } else {\n        dp[j] = dp[j - p.first] - 1;\n      }\n    }\n  }\n  ll res = 0;\n  REP(i, 2 * N + 1) if (dp[i] != -1){\n    ll A = S + i;\n    ll B = N - A;\n    // cout << A << \" \"<< B << endl;\n    res = max(res,  A * B - M);\n  }\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nint n;\nvector<vector<int>> g;\nvector<int> color;\nvector<int> parts;\nvector<pair<int, int>> ps;\n\nbool dfs(int u, int c) {\n    color[u] = c;\n    parts[c]++;\n    for (int v: g[u]) {\n        if (~color[v]) {\n            if (color[v] == color[u]) return false;\n        } else {\n            if (!dfs(v, c ^ 1)) return false;\n        }\n    }\n    return true;\n}\n\nbool is_bipartite() {\n    color.assign(n, -1);\n    parts.assign(2, 0);\n    for (int u = 0; u < n; u++) if (color[u] == -1) {\n        if (!dfs(u, 0)) return false;\n        ps.emplace_back(parts[0], parts[1]);\n        parts.assign(2, 0);\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int m; cin >> n >> m;\n    g.resize(n);\n    for (int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b; a--; b--;\n        g[a].emplace_back(b);\n        g[b].emplace_back(a);\n    }\n    if (!is_bipartite()) return !(cout << -1 << endl);\n    map<int, int> diff;\n    for (auto &p: ps) diff[abs(p.first - p.second)]++;\n    bitset<(int)2e5 + 1> dp; dp.set(n);\n    vector<int> ds;\n    for (auto &p: diff) {\n        int u = 1;\n        while (p.second >= u) {\n            ds.emplace_back(p.first * u);\n            p.second -= u, u <<= 1;\n        }\n        if (p.second) ds.emplace_back(p.first * p.second);\n    }\n    for (auto d: ds) dp = dp << d | dp >> d;\n    long long ma = 0;\n    for (int d = 0; d <= n; d++) if (dp[d + n]) {\n        int t = (n - d) / 2;\n        ma = max(ma, 1LL * t * (t + d));\n    }\n    cout << ma - m << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n\n  vector<int> B;\n  int sum =0;\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n\n    A.push_back(cnt);\n    B.push_back(cnt.first-cnt.second);\n    sum+=cnt.first+cnt.second;\n  }\n\n  assert(sum == n);\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  sort(B.begin(),B.end(),greater<int>());\n\n  int ave = 0;\n  for(int i=0;i<(int)B.size();i++)ave += B[i];\n  ave /= B.size();\n\n  int d = 0;\n  for(int i=0;i<(int)B.size();i++) {\n    d += B[i]-ave;\n  }\n  \n  int a = (d + sum)/2;\n  //cout<<d<<endl;\n  int b = sum - a;\n\n  \n  cout<<a*b-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tlong long int xx = 0;\n\n\tlong long int base = 0;\n\tmap<long long int, long long int>MLL;\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tMLL[abs( two[i].first - two[i].second )]++;\n\t\tbase += min( two[i].first , two[i].second );\n\t}\n\tvector<long long int>dp( V / 2 + 1, -1 );\n\tdp[base] = 0;\n\tfor( auto now : MLL ) {\n\t\t//cout << now.first << \" \" << now.second << endl;\n\t\tfor( size_t i = 0; i < V / 2 + 1; i++ ) {\n\t\t\tif( dp[i] >= 0 ) {\n\t\t\t\tdp[i] = now.second;\n\t\t\t} else if( i < now.first || dp[i - now.first] <= 0 ) {\n\t\t\t\tdp[i] = -1;\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i - now.first] - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor( long long int i = 0; i < V / 2 + 1; i++ ) {\n\t\tif( dp[i] != -1 ) {\n\t\t\txx = max( i, xx );\n\t\t}\n\t}\n\tcout << xx*( V - xx ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tfor (int j = 0; j < City[CitySet[0][i]].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[CitySet[0][i]] == Bipartite[City[CitySet[0][i]][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tlong long ret = 0;\n\n\tfor (int bits = 0; bits < (1 << (CitySet.size() - 1)); bits++)\n\t{\n\t\tlong long crt = 0;\n\n\t\tfor (int i = 1; i < CitySet.size(); i++)\n\t\t{\n\t\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\t\tvector<int> Bipartite2(Bipartite.begin(), Bipartite.end());\n\n\t\t\tif (bits & (1 << (i - 1)))\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tBipartite2[CitySet[i][j]] = (Bipartite2[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][0]] + 1) % 2]; CityType[Bipartite2[CitySet[i][0]]]++;\n\n\t\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][j]] + 1) % 2];\n\n\t\t\t\tCityType[Bipartite2[CitySet[i][j]]]++;\n\t\t\t}\n\t\t}\n\n\t\tret = max(ret, crt);\n\t}\n\n\tcout << count_ + ret << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nunordered_set<int> used[N];\n\nint dfs(int idx, int a,int sum){\n  int b = sum - a;\n  if(used[idx].count(a)) return -1;\n  used[idx].insert(a);\n\n  if(idx == (int)A.size()) return a*b;\n  int na = a+A[idx].first;\n  int nb = b+A[idx].second;\n  int nsum = sum+A[idx].first+A[idx].second;\n  if(na>nb) swap(na,nb);\n  int s = dfs(idx+1,na,nsum);\n\n  na = a+A[idx].second;\n  nb = b+A[idx].first;\n  if(na>nb) swap(na,nb);\n  int t = dfs(idx+1,na,nsum);\n  return max(s,t);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A.push_back(cnt);\n  }\n\n  sort(A.begin(),A.end());\n  if(flag) cout<<\"-1\"<<endl;\n  else cout<<dfs(0,0,0)-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nstruct Part { int a, b; };\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col;\nvector< Part > parts;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nmap< pii, lint > memo[100010];\n\nlint rec(int i, int lft, int rgt) {\n\tif (i == (int)parts.size()) return 0;\n\t\n\tif (memo[i].count(pii(lft, rgt))) return memo[i].at(pii(lft, rgt));\n\t\n\tlint& res = memo[i][pii(lft, rgt)];\n\t\n\tres = max(res, rec(i + 1, lft + parts[i].a, rgt + parts[i].b) +\n\t\t\t\t   (lint)lft * (lint)parts[i].b + (lint)rgt * (lint)parts[i].a);\n\t\n\tres = max(res, rec(i + 1, lft + parts[i].b, rgt + parts[i].a) +\n\t\t\t\t   (lint)lft * (lint)parts[i].a + (lint)rgt * (lint)parts[i].b);\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tcol.assign(N, -1);\n\t\n\tlint ans = 0;\n\t\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = g[0].size(), b = g[1].size();\n\t\tparts.push_back(Part{a, b});\n\t\t\n\t\tlint sum = 0;\n\t\tfor (int u : g[0]) sum += adj[u].size();\n\t\tans += (lint)a * (lint)b - sum;\n\t}\n\t\n\tif (!flag) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << ans + rec(0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(;;);\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n\n  vector<int> B;\n  int sum =0;\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n\n    A.push_back(cnt);\n    B.push_back(cnt.first-cnt.second);\n    sum+=cnt.first+cnt.second;\n  }\n\n  assert(sum == n);\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  if(B.size()==1) cout<<A[0].first*A[0].second-m<<endl,exit(0);\n\n  sort(B.begin(),B.end(),greater<int>());\n\n  double ave = 0;\n  for(int i=0;i<(int)B.size();i++)ave += B[i];\n  ave /= B.size();\n  \n  double d = 0;\n  for(int i=0;i<(int)B.size();i++) {\n    d += B[i]-ave;\n  }\n\n  //cout<<A[0].first<<\" \"<<A[0].second<<endl;\n  //for(int i=0;i<B.size();i++)cout<<B[i]<<endl;  \n\n  //cout<<\"d=\"<<d<<endl;\n\n  int a = (sum-d)/2;\n  //cout<<d<<endl;\n  int b = sum - a;\n  \n  \n  cout<<a*b-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\n\nset<P> used[N];\n\nint dfs(int idx, int a,int b){\n  if(used[idx].count(P(a,b))) return -1;\n  used[idx].insert(P(a,b));\n  if(idx == (int)A.size()) return a*b;\n  int na = a+A[idx].first,nb = b+A[idx].second;\n  if(na>nb) swap(na,nb);\n\n\n  int s = dfs(idx+1,na,nb);\n  na = a+A[idx].second,nb = b+A[idx].first;\n  if(na>nb) swap(na,nb);\n  int t = dfs(idx+1,a+A[idx].first,b+A[idx].second);\n  return max(s,t);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    cnt = P(0,0);\n    if(col[i]==-1) dfs(i,0),A.push_back(cnt);\n  }\n\n  sort(A.begin(),A.end());\n  if(flag) cout<<\"-1\"<<endl;\n  else cout<<dfs(0,0,0)-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint DP(){\n  int dp[N] = {};\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n  for(P a:A){\n    dp[0] = a.second;\n    for(int i=0;i<=N;i++)if(dp[i]>0) dp[i] = a.second;\n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n  for(int i=0;i<N;i++)\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  return res;\n}\n \nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n\n  vector<int> B;\n  int sum =0;\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n    A.push_back(cnt);\n    B.push_back(cnt.first-cnt.second);\n    sum+=cnt.first+cnt.second;\n  }\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  sort(B.begin(),B.end(),greater<int>());\n  \n  int d = 0;\n  for(int i=0;i<(int)B.size();i++) d>0? d-=B[i]:d+=B[i];\n  int a = (d + sum)/2;\n  int b = sum - a;\n  \n  cout<<a*b-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e9\n\nbool dfs(int now, const vector<vector<int> >& adj, vector<int>& history, int& a, int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int input_a, input_b;\n  vector<vector<int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  int a_sum = 0, b_sum = 0;\n  vector<int> c_tmp;\n  vector<int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      int a = 0;\n      int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<int> > dp(n, vector<int>(v + 1, -INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i].first ? dp[i][j - c[i].first] - 1 : (int)INF * (-1));\n\n  int minpoint = -1;\n  int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tfor (int j = 0; j < City[CitySet[0][i]].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[CitySet[0][i]] == Bipartite[City[CitySet[0][i]][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tlong long ret = 0;\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int bits = 0; bits < (1 << (CitySet.size() - 1)); bits++)\n\t{\n\t\tlong long crt = 0;\n\n\t\tfor (int i = 1; i < CitySet.size(); i++)\n\t\t{\n\t\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\t\tvector<int> Bipartite2(Bipartite.begin(), Bipartite.end());\n\n\t\t\tif (bits & (1 << (i - 1)))\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tBipartite2[CitySet[i][j]] = (Bipartite2[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][0]] + 1) % 2]; CityType[Bipartite2[CitySet[i][0]]]++;\n\n\t\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][j]] + 1) % 2];\n\n\t\t\t\tCityType[Bipartite2[CitySet[i][j]]]++;\n\t\t\t}\n\t\t}\n\n\t\tret = max(ret, crt);\n\t}\n\n\tcout << count_ + ret << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> e[100000];\n\ntypedef pair<int,int> P;\n\nint c[100000];// -1 0 1 2 ;\nint g;\nset<P> st;\nint used[100000];\n\nvoid dfs(int p,int d){\n  if(c[p]==-1)c[p]=d;\n  else if((c[p]==0&&d==1)||(c[p]==1&&d==0))c[p]=2;\n  used[p]=g;\n  for(int i=0;i<e[p].size();i++){\n    if(st.count(P(min(e[p][i],p),max(e[p][i],p))))continue;\n    st.insert(P(min(e[p][i],p),max(e[p][i],p)));\n    dfs(e[p][i],!d);\n  }\n}\n\n\nint main(){\n  int V,E;\n  memset(c,-1,sizeof(c));\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++){\n    cin>>a>>b;\n    a--,b--;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  for(int i=0;i<V;i++){\n    if(!used[i])++g,dfs(i,0);\n\n  }\n  long long ans=0;\n  for(int i=0;i<V;i++)\n    if(c[i]==2)ans=-1;\n  \n  if(ans!=-1){\n    long long cnt[100001][2]={};\n    \n    for(int i=0;i<V;i++)\n      cnt[used[i]][c[i]]++;\n    for(int i=1;i<=g;i++)ans+=cnt[i][0]*cnt[i][1];\n    vector<long long> v[2];\n    for(int i=1;i<=g;i++){\n      v[0].push_back(max(cnt[i][0],cnt[i][1]));\n      v[1].push_back(min(cnt[i][0],cnt[i][1]));\n    }\n\n    sort(v[0].begin(),v[0].end());\n    sort(v[1].begin(),v[1].end());\n\n    long long g0=v[0][0],g1=v[1][0];\n\n    for(int i=1;i<v[0].size();i++)\n      ans+=g0*v[0][i],g0+=v[0][i];\n    for(int i=1;i<v[1].size();i++)\n      ans+=g1*v[1][i],g1+=v[1][i];\n    \n    ans-=E;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< int, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc(lint A) {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tint a = (*it).first, c = (*it).second;\n\t\t\n\t\tfor_(j,0,N+1) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,N+1) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tbool flag = true;\n\tlint A = 0;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[b - a];\n\t\tA += a;\n\t}\n\t\t\n\tcout << (!flag ? -1 : calc(A) - M) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n\n    map<pair<int,int>,int> m;\n    for (int i = 0; i < s[0].size(); i++) {\n        m[pair<int,int>(min(s[0][i].size(), s[1][i].size()), max(s[0][i].size(), s[1][i].size()))]++;\n    }\n\n    vector<int> dp(N+1, -1);\n    dp[0] = 0;\n    for (auto p : m) {\n        int x = p.first.first;\n        int y = p.first.second;\n        int count = p.second;\n        for (int i = 0; i < dp.size(); i++) {\n            if (dp[i] >= 0) dp[i] = count;\n            else if (i < x || dp[i - x] < 0) dp[i] = -1;\n            else dp[i] = dp[i - x] - 1;\n        }\n        vector<int> tmp(N+1, -1);\n        for (int i = 0; i < tmp.size(); i++) {\n            if (dp[i] >= 0 && i + dp[i] * y < dp.size()) {\n                tmp[i + dp[i] * y] = 0;\n            }\n        }\n        dp = tmp;\n    }\n\n    int ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (dp[i] >= 0)\n            ans = max(ans, i * (N - i) - M);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}else continue;\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqv.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint a=0;\n\tfor(int i=0;i<=n;i++) a=max(a,dp[i]);\n//\tint dif=S-2*dp[n];\n\tint dif=S-2*a;\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint V,E;\nvector<int> g[100100];\nbool used[100100];\nint col[100100];\nbool flag=false;\nint cnt[3];\nint dp[100100];\nint num[600];\nmap<int,int> m;\nvoid dfs(int v,int c)\n{\n\tused[v]=true;\n\tcol[v] = c;\n\tcnt[c+1]++;\n\tfor(int i=0;i<g[v].size();i++)\n\t{\n\t\tif(used[g[v][i]]&&col[g[v][i]]==col[v])flag=true;\n\t\tif(!used[g[v][i]])dfs(g[v][i],-c);\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<int> v;\n\tll base = 0ll;\n\tll sum = 0ll;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcnt[0]=0,cnt[2]=0;\n\t\tif(!used[i])\n\t\t{\n\t\t\tdfs(i,1);\n\t\t\tif(cnt[0]>cnt[2])swap(cnt[0],cnt[2]);\n\t\t\tbase += cnt[0];\n\t\t\tsum += cnt[2]-cnt[0];\n\t\t\tv.pb(cnt[2]-cnt[0]);\n\t\t\tm[cnt[2]-cnt[0]]++;\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\tint N = v.size();\n\t//cout << base << ' ' << sum << endl;\n\tfor(int i=0;i<N;i++)num[i]=m[v[i]];\n\t//for(int i=0;i<N;i++)printf(\"%d %d\\n\",v[i],num[i]);\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0]=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tfor(int j=0;j<=V;j++)\n\t\t{\n\t\t\tif(dp[j]>=0)dp[j]=num[i];\n\t\t\telse if(j<v[i]||dp[j-v[i]]<=0)dp[j]=-1;\n\t\t\telse dp[j] = dp[j-v[i]]-1;\n\t\t}\n\t}\n\tll ans = 0ll;\n\tfor(int i=0;i<=V;i++)if(dp[i]>=0)ans = max(ans,(base+i)*(base+sum-i));\n\tprintf(\"%lld\\n\",ans-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n/**** Const List   ****/\n\nconst ll INF = (ll)1e20;\nconst ll mod = 1000000007;\nconst ll UNION_FIND_MAX = 100000;\nconst ll SEGMENT_TREE_MAX = (1 << 19) - 1;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll nCk(ll n, ll k, ll mod) {\n  ll ans = 1;\n  for (ll i = n, j = 1; j <= k; i--, j++) ans = (((ans * i) % mod) * invmod(j, mod)) % mod;\n  return ans;\n}\n\nll lmin(ll a, ll b) { return a > b ? b : a; };\n\nll lmax(ll a, ll b) { return a > b ? a : b; };\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  vector<ll> par, rank;\npublic:\n  void init(ll n) {\n    par.resize(n); rank.resize(n, 0);\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\ntemplate <typename T>\nstruct UnionFindT {\n  vector<ll> par;\n  vector<ll> rank;\n  vector<T> diff_weight;\n\n  UnionFindT(ll n = 1, T SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(ll n = 1, T SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (ll i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n  }\n\n  T weight(ll x) {\n    find(x);\n    return diff_weight[x];\n  }\n\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n\n  bool merge(ll x, ll y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  T diff(ll x, ll y) {\n    return weight(y) - weight(x);\n  }\n};\n\nclass PersistentUnionFind {\n  vector<ll> rank, fin, par;\n  ll index;\npublic:\n  void init(ll n) {\n    index = 0;\n    par.resize(n); rank.resize(n, 1); fin.resize(n, 0);\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x, ll t) {\n    if (t >= fin[x] && par[x] != x) return find(par[x], t);\n    return x;\n  }\n  void merge(ll x, ll y) {\n    x = find(x, index);\n    y = find(y, index);\n    index++;\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y, fin[x] = index;\n    else {\n      par[y] = x, fin[y] = index;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y, ll t) { return find(x, t) == find(y, t); }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass LazySegmentTree {\n  ll n;\n  vector<T> node;\n  vector<T> lazyNode;\n  function<T(T, T)> fun, fun2;\n  function<T(T, ll)> fun3;\n  T outValue, initValue;\n  T substitution(T a, T b) { return a; }\n  void eval(ll k, ll l, ll r) {\n    if (lazyNode[k] == 0) return;\n    node[k] = fun2(fun3(lazyNode[k], r - l), node[k]);\n    if (r - l > 1) {\n      lazyNode[2 * k + 1] = fun2(lazyNode[k], lazyNode[2 * k + 1]);\n      lazyNode[2 * k + 2] = fun2(lazyNode[k], lazyNode[2 * k + 2]);\n    }\n    lazyNode[k] = initValue;\n  }\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, function<T(T, T)> changeFunction, function<T(T, ll)> lazyFunction, T init, T out) {\n    // changeFunction: (input, beforevalue) => newvalue\n    // lazyFunction: (lazyNode, diff) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    fun3 = lazyFunction;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    lazyNode.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void rangeChange(ll a, ll b, T value, ll l = 0, ll r = -1, ll k = 0) {\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazyNode[k] = fun2(value, lazyNode[k]);\n      eval(k, l, r);\n    } else {\n      ll mid = (l + r) / 2;\n      rangeChange(a, b, value, l, mid, 2*k+1);\n      rangeChange(a, b, value, mid, r, 2*k+2);\n      node[k] = fun(node[2*k+1], node[2*k+2]);\n    }\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (b <= l || r <= a) return outValue;\n    eval(k, l, r);\n    if (a <= l && r <= b) return node[k];\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\npublic:\n  ll V;\n  vector<ll> G[BIPARTITE_MATCHING_MAX_V];\n  ll match[BIPARTITE_MATCHING_MAX_V];\n  bool used[BIPARTITE_MATCHING_MAX_V];\n  \n  BipartiteMatching(ll v) {\n    V = v;\n  }\n  void init(ll v) {\n    V = v;\n    for (ll i = 0; i < BIPARTITE_MATCHING_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool dfs(ll v) {\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      ll u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  ll max_matching() {\n    ll res = 0;\n    memset(match, -1, sizeof(match));\n    for (ll v = 0; v < V;v++) {\n      if (match[v] < 0) {\n        memset(used, 0, sizeof(used));\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** LIS ****/\nll lis(ll* a, ll n, ll* dp) {\n  fill(dp, dp + n, INF);\n  for (ll i = 0; i < n; i++) *lower_bound(dp, dp + n, a[i]) = a[i];\n  return (ll)(lower_bound(dp, dp + n, INF) - dp);\n}\n\n/**** Kruskal ****/\n\n/**** main function ****/\n\nll v, e, a, b, d[100000], dp[100001];\nUnionFind uf;\nP p[100000];\n\nint main() {\n  scanf(\"%lld%lld\", &v, &e);\n  uf.init(2*v);\n  for (ll i = 0; i < e; i++) {\n    scanf(\"%lld%lld\", &a, &b); a--; b--;\n    if (uf.isSame(a, b)) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n    uf.merge(a, b+v); uf.merge(a+v, b);\n  }\n  ll temp = 0; dp[0] = 1; ll v2 = v/2, counter = 0;\n  for (ll i = 0; i < v; i++) {\n    ll tn = uf.find(i);\n    if (tn < v) p[tn].first++;\n    else p[tn-v].second++;\n  }\n  for (ll i = 0; i < v; i++) {\n    if (p[i].first == 0 && p[i].second == 0) continue;\n    if (p[i].first == 1 && p[i].second == 0) {\n      temp++;\n      continue;\n    }\n    ll f = p[i].first, s = p[i].second;\n    for (ll j = v2; j >= 0; j--) {\n      if (j-f >= 0 && dp[j-f] == counter+1) dp[j] = counter+2;\n      if (j-s >= 0 && dp[j-s] == counter+1) dp[j] = counter+2;\n    }\n    counter++;\n  }\n  for (ll i = 0; i <= v2; i++) {\n    if (dp[v2 - i] == counter+1) {\n      ll temp2 = lmin(v2 - i + temp, v2);\n      printf(\"%lld\\n\", temp2 * (v - temp2) - e);\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(P(a[1],a[0]));\n    else return -1;\n  }\n  int k=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<V;j++){\n      if(dp[f][j]) dp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1;\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      if((V-k)*k<(V-i)*i) k=i;\n    }\n  }\n  return (V-k)*k-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\n#define int long long\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  int x=0;\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)){\n      if(a[1]) v.push_back(P(a[1],a[0]));\n      else x++;\n    }else return -1;\n  }\n  int k=0,m=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<=m;j++){\n      if(dp[f][j])\n\tdp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1,\n\t  m=max(m,j+max(v[i].first,v[i].second));\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      for(int j=0;j<x&&i+j<V;j++){\n\t//cout<<i+j<<\":\"<<(V-(i+j))*(i+j)<<endl;\n\tif((V-k)*k<(V-(i+j))*(i+j)) k=i+j;\n      }\n    }\n  }\n  return (V-k)*k-E;\n}\nsigned main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  cout<<F<<\" \"<<S<<endl;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n    A.push_back(cnt);\n  }\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n\n  sort(A.begin(),A.end(),greater<P>());\n  for(int i=A.size()-1;i>=0;i--)\n    Sum[i]=P(Sum[i+1].first+A[i].first,Sum[i+1].second+A[i].second);\n\n  cout<<\"OK\"<<endl;\n\n  dfs(0,0,0);\n  cout<<ans-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] > CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType2[0], CityType2[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nint A(){\n\twhile( S[p] == 'm' ){\n\t\tp++;\n\t\tA();\n\t\tif( S[p] != 'e' ) throw 2;\n\t\tp++;\n\t\tA();\n\t\tif( S[p] != 'w' ) throw 2;\n\t\tp++;\n\t}\n}\nint main(){\n\tcin >> S;\n\tS += \"=\";\n\ttry{\n\t\tA();\n\t\tif( S[p] != '=' ) throw 0;\n\t\tcout << \"Cat\" << endl;\n\t}catch(int x){\n\t\tcout << \"Rabbit\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nvector< int > g[100000];\nbool v[100000];\nint black, white;\n\nvoid dfs(int idx, bool pre)\n{\n  if(v[idx]++) return;\n  if(pre) ++black;\n  else ++white;\n  for(auto &to : g[idx]) dfs(to, 1 - pre);\n}\n\nint main()\n{\n  int V, E;\n  cin >> V >> E;\n  UnionFind tree(V + V);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    tree.unite(a + V, b);\n    tree.unite(a, b + V);\n  }\n\n  for(int i = 0; i < V; i++) {\n    if(tree.find(i) == tree.find(i + V)) {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n\n  bitset< 50001 > dp;\n  dp[0] = 1;\n\n  for(int i = 0; i < V; i++) {\n    if(v[i]) continue;\n    black = white = 0;\n    dfs(i, 0);\n    dp = (dp << black) | (dp << white);\n  }\n\n  int ret = 0;\n  for(int i = 0; i <= V / 2; i++) {\n    if(dp[i]) ret = max(ret, i * (V - i) - E);\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 200001;\nint n, m, v[100000], sum[MX];\nbool dp[2][MX];\nvector<vi> e;\n\nbool rec(int c, int col, int &a, int &b){\n\ta++;\n\tv[c] = col;\n\trep(i, e[c].size()){\n\t\tif(v[e[c][i]]){\n\t\t\tif(v[e[c][i]] == col) return 0;\n\t\t}\n\t\telse rec(e[c][i], -col, b, a);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\te.resize(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tmap<int, int> s;\n\trep(i, n) if(!v[i]){\n\t\tint a = 0, b = 0;\n\t\tif(!rec(i, 1, a, b)){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ts[abs(a - b)]++;\n\t}\n\t\n\t//each(i, s) cerr<<i->first<<\" \"<<i->second<<endl;\n\tconst int GETA = 100000;\n\tdp[0][GETA] = 1;\n\tint cur = 0, next = 1;\n\teach(i, s){\n\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\t\n\t\tint a = i->first, b = i->second;\n\t\tif(a == 0) continue;\n\t\t\n\t\trep(j, MX) if(dp[cur][j]){\n\t\t\tint t = (MX - 1 - j) / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tif(t >= 0 && j + a * (t + 2) < MX) sum[j + a * (t + 2)]--;\n\t\t\t\n\t\t\tt = j / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tif(t >= 0) sum[j - a * t]++;\n\t\t}\n\t\trep(j, 2 * a){\n\t\t\tint l = 0;\n\t\t\tfor(int k = j; k < MX; k += 2 * a){\n\t\t\t\tl += sum[k];\n\t\t\t\tif(l) dp[next][k] = 1;\n\t\t\t}\n\t\t}\n\t\tswap(cur, next);\n\t}\n\tll mx = 0;\n\trep(i, MX) if(dp[cur][i]){\n\t\tmx = max(mx, (ll)((n + i - GETA) / 2) * ((n - i + GETA) / 2));\n\t}\n\tcout << mx - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tset<long long int>c;\n\tc.insert( 0 );\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tsub[i] = two[i].first - two[i].second;\n\t\tset<long long int>d;\n\t\tfor( auto xx : c ) {\n\t\t\td.insert( xx + sub[i] );\n\t\t\td.insert( xx - sub[i] );\n\t\t}\n\t\tc = d;\n\t}\n\tlong long int xx = LLONG_MAX;\n\tfor( auto now : c ) {\n\t\txx = min( abs( now ), xx );\n\t}\n\tcout << ( V - xx ) / 2 * ( ( ( V - xx ) / 2 ) + xx ) - E << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool dfs(const vvi& g,int u,int c,vi& color,int& x,int& y)\n{\n\tif(color[u]!=-1)\n\t\treturn color[u]==c;\n\tcolor[u]=c;\n\t(c==0?x:y)++;\n\tfor(int v:g[u])\n\t\tif(!dfs(g,v,!c,color,x,y))\n\t\t\treturn false;\n\treturn true;\n}\n\nint solve(const vvi& g)\n{\n\tint n=g.size();\n\t\n\tvector<pii> ps;\n\t{\n\t\tvi color(n,-1);\n\t\trep(i,n) if(color[i]==-1){\n\t\t\tint x=0,y=0;\n\t\t\tif(!dfs(g,i,0,color,x,y))\n\t\t\t\treturn -1;\n\t\t\tps.emplace_back(x,y);\n\t\t}\n\t}\n\t\n\tset<int> s; s.insert(0);\n\tfor(pii p:ps){\n\t\tset<int> t;\n\t\tfor(int x:s){\n\t\t\tt.insert(x+p.first);\n\t\t\tt.insert(x+p.second);\n\t\t}\n\t\tswap(s,t);\n\t}\n\t\n\tll mx=0;\n\tfor(int x:s)\n\t\tmx=max(mx,ll(x)*(n-x));\n\t\n\tint e=0;\n\trep(i,n) e+=g[i].size();\n\t\n\treturn mx-e/2;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvvi g(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tcout<<solve(g)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tlong long count = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount += F[0] * F[1];\n\t}\n\n\tcount -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < City[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[City[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[CitySet[i][0]] < CityType2[(CitySet[i][0] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> G[100001];\nint col[100001];\nll dp[2][901];\nvector<P> p;\nP po;\n\nbool dfs(int v,int c){\n\tif(c==1){\n\t\tpo.first++;\n\t}else{\n\t\tpo.second++;\n\t}\n\tcol[v]=c;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(col[G[v][i]]==0){\n\t\t\tif(!dfs(G[v][i],-c))return false;\n\t\t}else if(col[G[v][i]]==c){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(col[i]==0){\n\t\t\tpo=P(0,0);\n\t\t\tif(!dfs(i,1)){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp.push_back(po);\n\t\t}\n\t}\n\tdp[0][0]=1;\n\tint cur=0,nxt=1;\n\tfor(int i=0;i<p.size();i++){\n\t\tfor(int j=0;j<900;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tint v=p[i].first;\n\t\t\t\tint dig=v/60;\n\t\t\t\tint diff=v%60;\n\t\t\t\tif(j+dig<900){\n\t\t\t\t\tll va=dp[cur][j]&((1LL<<(60-diff))-1LL);\n\t\t\t\t\tdp[nxt][j+dig]|=va<<diff;\n\t\t\t\t}\n\t\t\t\tif(j+dig+1<900 && diff>0){\n\t\t\t\t\tdp[nxt][j+dig+1]|=dp[cur][j]>>(60-diff);\n\t\t\t\t}\n\t\t\t\tswap(p[i].first,p[i].second);\n\t\t\t}\n\t\t}\n\t\tswap(cur,nxt);\n\t\tmemset(dp[nxt],0,sizeof(dp[nxt]));\n\t}\n\tint best=0;\n\tfor(int i=0;i<900;i++){\n\t\tfor(int j=0;j<60;j++){\n\t\t\tif(dp[cur][i]>>j & 1){\n\t\t\t\tint val=j+i*60;\n\t\t\t\tif(abs(n/2-val)<abs(n/2-best)){\n\t\t\t\t\tbest=val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ll)best*(n-best)-m);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<int> v[111111];\nvector<P> p;\nint u[111111][2],c[2];\n\nvoid dfs(int x,int t) {\n  if(u[x][t]) return;\n  c[t]++;\n  u[x][t]=1;\n  for(int i=0; i<v[x].size(); i++) dfs(v[x][i],t^1);    \n}\n\nbitset<100001> t;\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  for(int i=0; i<m; i++) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  for(int i=0; i<n; i++) {\n    if(u[i][0]||u[i][1]) continue;\n    c[0]=c[1]=0;\n    dfs(i,0);\n    if(c[0]<c[1]) swap(c[0],c[1]);\n    p.push_back(P(c[0],c[1]));\n  }\n  for(int i=0; i<n; i++) {\n    if(u[i][0]&&u[i][1]) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  t.set(0);\n  for(int i=0; i<p.size(); i++) {\n    t=(t<<p[i].first)|(t<<p[i].second);\n  }\n  ll ans=0;\n  for(ll i=0; i<=n; i++) {\n    if(t[i]) ans=max(ans,i*(n-i)-m);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint V, E, a, b, col[100009]; bool flag; vector<int> g[100009];\nvoid dfs(int pos) {\n\ta++;\n\tif (col[pos] == 1) b++;\n\tfor (int i : g[pos]) {\n\t\tif (col[pos] == col[i]) flag = true;\n\t\tif (!col[i]) col[i] = 3 - col[pos], dfs(i);\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tbitset<100001> dp = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (!col[i]) {\n\t\t\ta = b = 0; col[i] = 1;\n\t\t\tdfs(i);\n\t\t\tif (b * 2 > a) b = a - b;\n\t\t\tcur += b;\n\t\t\tdp |= dp << (a - b * 2);\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = cur; i <= V; i++) {\n\t\tif (dp[i - cur]) ret = max(ret, 1LL * i * (V - i));\n\t}\n\tprintf(\"%lld\\n\", (flag ? -1LL : ret - E));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\nvi graph[vmax];\nint color[vmax];\n\nbool dfs(int v,int c){\n\tcolor[v]=c;\n\tfor(auto &v2:graph[v]){\n\t\tif(color[v2]==0&&dfs(v2,-c)==false) return false;\n\t\tif(color[v2]==color[v]) return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\tll v,e;\n\tcin >> v >> e;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a-1].pb(b-1);\n\t\tgraph[b-1].pb(a-1);\n\t}\n\tbool ok=true;;\n\trep(i,v) if(color[i]==0&&dfs(i,1)==false) ok=false;\n\tconst ll all=v/2*(v-v/2);\n\tif(ok)\n\t\tcout << all-e << endl;\n\telse\n\t\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=abs(even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tfor(;;);\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] < CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define int int64_t\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconstexpr int IINF = (1 << 30) - 1;\nconstexpr long long LLINF = 1LL << 61;\nconstexpr double EPS = 1e-8;\n\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\n\nclass UnionFind{\n    vector<int> par;\n    vector<long long> wei;\n    int groupCount;\n\npublic:\n    UnionFind(int n = 0){\n        init(n);\n    }\n\n    void init(int n = 0){\n        par.resize(n);\n        fill(par.begin(), par.end(), -1);\n\n        wei.resize(n);\n        fill(wei.begin(), wei.end(), 0LL);\n\n        groupCount = n;\n\n        return;\n    }\n\n    int root(int x){\n        if(par[x] < 0){\n            return x;\n        }\n        int r = root(par[x]);\n        wei[x] += wei[par[x]];\n        return par[x] = r;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    int size(int x){\n        return -par[root(x)];\n    }\n\n    long long weight(int x){\n        root(x);\n        return wei[x];\n    }\n\n    long long diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n    bool unite(int x, int y, long long w = 0){\n        w += weight(x) - weight(y);\n\n        x = root(x);\n        y = root(y);\n\n        if(x == y){\n            return false;\n        }\n\n        if(par[y] < par[x]){\n            swap(x, y);\n            w = -w;\n        }\n\n        par[x] += par[y];\n        par[y] = x;\n        wei[y] = w;\n        --groupCount;\n\n        return true;\n    }\n\n    int size(void){\n        return groupCount;\n    }\n};\n\ntemplate<typename T>\nbool chmax(T& a, T b, bool equal = false){\n    if(a < b || equal && a == b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T& a, T b, bool equal = false){\n    if(b < a || equal && a == b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid dfs(int v, int d, const vector< vector<int> >& g, vector<int>& c){\n    c[v] = d;\n\n    for(auto to : g[v]){\n        if(c[to] < 0){\n            dfs(to, d ^ 1, g, c);\n        }\n    }\n\n    return;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int v, e;\n    cin >> v >> e;\n\n    vector< vector<int> > g(v);\n    UnionFind uf(v);\n    rep(i, e){\n        int a, b;\n        cin >> a >> b;\n        g[--a].emplace_back(--b);\n        g[b].emplace_back(a);\n        uf.unite(a, b);\n    }\n\n    vector<int> c(v, -1);\n    rep(i, v){\n        if(c[i] < 0){\n            dfs(i, 0, g, c);\n        }\n    }\n\n    rep(i, v){\n        for(auto to : g[i]){\n            if(c[i] == c[to]){\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    vector< vector<int> > cnt(2, vector<int>(v, 0));\n    int t = 0;\n    rep(i, v){\n        if(uf.size(i) == 1){\n            ++t;\n        }else{\n            ++cnt[c[i]][uf.root(i)];\n        }\n    }\n\n    unordered_map<int, int> mp;\n    int mi = 0;\n    int ma = 0;\n    int lim = 0;\n    rep(i, v){\n        if(0 < cnt[0][i]){\n            ++mp[abs(cnt[0][i] - cnt[1][i])];\n            mi += min(cnt[0][i], cnt[1][i]);\n            ma += max(cnt[0][i], cnt[1][i]);\n            lim += abs(cnt[0][i] - cnt[1][i]);\n        }\n    }\n\n    vector<int> a, m;\n    for(auto it = mp.begin() ; it != mp.end() ; ++it){\n        a.emplace_back((*it).first);\n        m.emplace_back((*it).second);\n    }\n    m.emplace_back(0);\n\n    vector< vector<int> > dp(2, vector<int>(lim + 1, -1));\n    dp[0][0] = m[0];\n\n    rep(i, a.size()){\n        rep(j, lim + 1){\n            if(dp[i & 1][j] >= 0){\n                dp[(i + 1) & 1][j] = m[i + 1];\n            }\n            if(j + a[i] <= lim){\n                chmax(dp[i & 1][j + a[i]], dp[i & 1][j] - 1);\n            }\n        }\n        rep(j, lim + 1){\n            dp[i & 1][j] = -1;\n        }\n    }\n\n    int k = 0;\n    int mini = ma - mi;\n    rep(j, lim + 1){\n        if(dp[((signed)a.size()) & 1][j] >= 0 && chmin(mini, abs(ma - j - mi - j))){\n            k = j;\n        }\n    }\n\n    mi += k;\n    ma -= k;\n\n    while(t){\n        if(mi < ma){\n            ++mi;\n        }else{\n            ++ma;\n        }\n        --t;\n    }\n\n    cout << (lint)(mi * ma) - e << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tmap<int, int> mp;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 0);\n\t\tadd_edge(g, b, a, 0);\n\t}\n\tvi color(n, -1);\n\tREP(i, n)\n\t{\n\t\tif (color[i] >= 0) continue;\n\t\tint b = 1, w = 0;\n\t\tcolor[i] = 0;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (color[nx] >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (color[nx] == color[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\tcolor[nx] = 1 - color[t];\n\t\t\t\tif (color[nx]) w++;\n\t\t\t\telse b++;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\tmp[abs(b - w)]++;\n\t}\n\tvi v;\n\tint sum = 0;\n\tfor (auto i : mp)\n\t{\n\t\tsum += i.first*i.second;\n\t\tint t = 1;\n\t\tint cnt = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (cnt + t <= i.second)\n\t\t\t{\n\t\t\t\tcnt += t;\n\t\t\t\tv.push_back(i.first*t);\n\t\t\t\tt *= 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv.push_back(i.first*(i.second - cnt));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> dp(n + 1, false);\n\tdp[0] = true;\n\tREP(i, v.size())\n\t{\n\t\tfor (int j = n; j >= 0; j--)\n\t\t{\n\t\t\tif (j - v[i] < 0) break;\n\t\t\tif (!dp[j - v[i]]) continue;\n\t\t\tdp[j] = true;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, dp.size())\n\t{\n\t\tif (dp[i])\n\t\t{\n\t\t\tll tmp = i * (n - i) - m;\n\t\t\tchmax(ans, tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nvector<int> G[1 << 17];\nbool used[1 << 17];\nint col[1 << 17];\n\nbitset<100001> b;\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tvector<P> v;\n\trep(i, n) {\n\t\tif (used[i])continue;\n\t\tint c[2] = {};\n\t\tint id = 0; queue<int> q;\n\t\tq.push(i); used[i] = true; col[i] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tid ^= 1;\n\t\t\tint len = q.size();\n\t\t\tc[id^1] += len;\n\t\t\trep(aa, len) {\n\t\t\t\tint v = q.front(); q.pop();\n\t\t\t\trep(j, G[v].size()) {\n\t\t\t\t\tint to = G[v][j];\n\t\t\t\t\tif (used[to]) {\n\t\t\t\t\t\tif (col[to] == col[v]) {\n\t\t\t\t\t\t\tcout << -1 << endl; return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tused[to] = true; col[to] = id;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.push_back({ c[0],c[1] });\n\t}\n\tb[0] = 1;\n\trep(i, v.size()) {\n\t\tb = (b << v[i].first) | (b << v[i].second);\n\t}\n\tll ans = 0;\n\trep(i, n + 1) {\n\t\tif (b[i]) {\n\t\t\t//cout << i << endl;\n\t\t\tans = max(ans,(ll)i*(n - i) - m);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <utility>\nusing namespace std;\n\npair<int,int> dfs(vector< vector<int> > &G, int v, int c, vector<int> &visited){\n  pair<int,int> ret = make_pair(0, 0);\n  if(c) ++ret.first;\n  else ++ret.second;\n  for(int i = 0; i < G[v].size(); ++i){\n    int u = G[v][i];\n    if(visited[u] == 1 - c) continue;\n    if(visited[u] == c) return make_pair(-1,-1);\n    visited[u] = 1 - c;\n    pair<int,int> p = dfs(G, u, 1 - c, visited);\n    if(p == make_pair(-1,-1)) return make_pair(-1,-1);\n    ret.first += p.first;\n    ret.second += p.second;\n  }\n  return ret;\n}\n\nint main(){\n  int V, E;\n  cin >> V >> E;\n  vector< vector<int> > G(V);\n  for(int i = 0; i < E; ++i){\n    int a, b;\n    cin >> a >> b;\n    --a,--b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<int> visited(V, -1);\n  bitset<100001> dp = 1;\n  for(int i = 0; i < V; ++i){\n    if(visited[i] >= 0) continue;\n    pair<int,int> p = dfs(G, i, 0, visited);\n    if(p == make_pair(-1, -1)){\n      cout << -1 << endl;\n      return 0;\n    }\n    dp = (dp << p.first)|(dp << p.second);\n  }\n  long long int ans = 0;\n  for(int i = 0; i <= V/2; ++i){\n    if(dp[i]) ans = max(ans, (long long int)i*(V-i) - E);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nP dfs(int v,int b,vi& used){\n\tused[v]=b;\n\tP p;\n\tif(b) p.first++;\n\telse p.second++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(used[u]==-1){\n\t\t\tP q=dfs(u,!b,used);\n\t\t\tp.first+=q.first;\n\t\t\tp.second+=q.second;\n\t\t}\n\t\tif(used[u]==b) return {-inf,0};\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvi used(n,-1);\n\tint tmp=0;\n\tmap<int,int> M;\n\tfor(int i=0;i<n;i++) if(used[i]==-1){\n\t\tP p=dfs(i,1,used);\n\t\tint A=p.first,B=p.second;\n\t\tif(A<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp+=min(A,B);\n\t\tM[abs(A-B)]++;\n\t}\n\tvi dp(n+1);\n\tdp[tmp]=1;\n\tfor(auto i=M.begin();i!=M.end();i++){\n\t\tint v=i->first,N=i->second;\n\t\tvi DP(n+1,-1);\n\t\tfor(int j=v;j<=n;j++){\n\t\t\tint dp_=DP[j-v];\n\t\t\tif(dp[j]) DP[j]=0;\n\t\t\telse if(dp_!=-1&&dp_<N){\n\t\t\t\tDP[j]=dp_+1;\n\t\t\t\tdp[j]|=1;\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<=n;i++) res=max(res,(ll)dp[i]*i*(n-i));\n\tcout<<res-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool ok = true;\n\nint f(int u, int x, vector<vector<int> >& G, vector<int>& vis) {\n\tvis[u] = x;\n\tint sum = 1;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (vis[v] == x) ok = false;\n\t\tif (vis[v] != -1) continue;\n\t\tsum -= f(v, !x, G, vis);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvector<int> vis(N, -1);\n\tint n = 0;\n\tvector<int> a(N + 1);\n\tfor (int u = 0; u < N; u++)\n\t\tif (vis[u] == -1) {\n\t\t\tint x = abs(f(u, 0, G, vis));\n\t\t\tn += x;\n\t\t\ta[x]++;\n\t\t}\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<bool> dp(n + 1);\n\tdp[0] = true;\n\tfor (int x = 1; x <= N; x++)\n\t\tfor (int y = 1; a[x]; y *= 2) {\n\t\t\tint z = min(a[x], y);\n\t\t\ta[x] -= z;\n\t\t\tfor (int k = n; k - z * x>= 0; k--)\n\t\t\t\tif (dp[k - z * x])\n\t\t\t\t\tdp[k] = true;\n\t\t}\n\tll ma = 0;\n\tfor (int k = 0; k <= n; k++)\n\t\tma = max(ma, (ll)((N - n) / 2 + k) * ((N - n) / 2 + (n - k)));\n\tcout << ma - M << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int64_t i=(k);i<(int64_t)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nvoid add_edge(Graph &g, int a, int b) {\n  g[a].push_back(b);\n  g[b].push_back(a);\n}\n\nbool dfs(const Graph &g, vector<int> &vis, int i) {\n  for (int j : g[i]) {\n    if (vis[j] == -1) {\n      vis[j] = vis[i] ^ 1;\n      if (!dfs(g, vis, j)) return false;\n    } else if (vis[j] == vis[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int64_t v,e;\n  cin>>v>>e;\n  Graph g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    add_edge(g, a, b);\n  }\n  vector<int> vis(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (vis[i] == -1) {\n      vis[i] = 2 * cnt;\n      if (!dfs(g, vis, i)) {\n        ok = false;\n      }\n      ++cnt;\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> ary(cnt, 0);\n  REP(i,v) {\n    if ((vis[i] % 2) == 0) {\n      ++ary[vis[i]/2];\n    } else {\n      --ary[vis[i]/2];\n    }\n  }\n  REP(i,cnt) ary[i] = abs(ary[i]);\n  int64_t sum = 0;\n  REP(i,cnt) sum += ary[i];\n  bitset<100001> dp;\n  dp[0] = true;\n  REP(i,cnt) {\n    bitset<100001> tmp = dp;\n    tmp |= dp << ary[i];\n    swap(tmp, dp);\n  }\n  int64_t mx = 0;\n  REP(i,v+1) {\n    if (dp[i]) {\n      int64_t k = 2*i - sum;\n      mx = max(mx, (v/2 - k) * ((v+1)/2 + k) - e);\n      mx = max(mx, ((v+1)/2 - k) * (v/2 + k) - e);\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nunordered_set<int> used[N];\n\nint dfs(int idx, int a,int sum){\n  int b = sum - a;\n  if(a > b) return -1;\n  if(used[idx].count(a)) return -1;\n  used[idx].insert(a);\n  \n  if(idx == (int)A.size()) return a*b;\n  int na = a+A[idx].first;\n  int nb = b+A[idx].second;\n  int nsum = sum+A[idx].first+A[idx].second;\n  int s = dfs(idx+1,na,nsum);\n\n  na = a+A[idx].second;\n  nb = b+A[idx].first;\n  int t = dfs(idx+1,na,nsum);\n  return max(s,t);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A.push_back(cnt);\n  }\n\n  sort(A.begin(),A.end());\n  if(flag) cout<<\"-1\"<<endl;\n  else cout<<dfs(0,0,0)-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nbool flag;\nint visit[MAX_N];\n\nvoid dfs(int u,int k,int& s,int& t)\n{\n    visit[u] = k;\n    if(k > 0){\n        s++;\n    }else{\n        t++;\n    }\n    rep(i,len(G[u])){\n        if(visit[G[u][i]] == 0){\n            dfs(G[u][i],-k,s,t);\n            if(flag){\n                return;\n            }\n        }else if(visit[G[u][i]] == k){\n            flag = true;\n            return;\n        }\n    }\n}\n\nmap<int,int> mp;\nbool dp[MAX_N];\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,m){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    vector<P> vec;\n    rep(i,n){\n        if(visit[i] == 0){\n            int r1 = 0,r2 = 0;\n            dfs(i,1,r1,r2);\n            if(flag){\n                cout << \"-1\\n\";\n                return 0;\n            }\n            vec.pb(P(r1,r2));\n        }\n    }\n    int sm = 0,al = 0;\n    rep(i,len(vec)){\n        sm += min(vec[i].fi,vec[i].se);\n        al += max(vec[i].fi,vec[i].se);\n        if(abs(vec[i].fi-vec[i].se) != 0){\n            mp[abs(vec[i].fi-vec[i].se)]++;\n        }\n    }\n    dp[0] = true;\n    each(it,mp){\n        int num = it.se;\n        for(int i=1;num>0;i<<=1){\n            int mul = min(i,num);\n            for(int j=al-sm;j>=it.fi*mul;j--){\n                if(dp[j-it.fi*mul]){\n                    dp[j] = true;\n                }\n            }\n            num -= mul;\n        }\n    }\n    int mn = INF;\n    rep(i,al-sm+1){\n        if(dp[i]){\n            cmn(mn,max(sm+i,al-i));\n        }\n    }\n    if(n % 2 == 0){\n        if(mn <= n/2){\n            cout << (ll)n*n/2/2 - m << \"\\n\";\n        }else{\n            cout << (ll)mn*(n-mn) - m << \"\\n\";\n        }\n    }else{\n        if(mn <= (n+1)/2){\n            cout << (ll)(n-1)*(n+1)/2/2 - m << \"\\n\";\n        }else{\n            cout << (ll)mn*(n-mn) - m << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}else continue;\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint a=0;\n\tfor(int i=0;i<=n;i++) a=max(a,dp[i]);\n//\tint dif=S-2*dp[n];\n\tint dif=S-2*a;\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint n,e,s[2];\nvector<int> G[N];\nint color[N];\n\nvoid dfs(int x,int c){\n  \n  color[x]=c;\n  s[c]++;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i];\n    if(color[nx]!=-1){\n      \n      if(color[x]==color[nx]){\n\tcout<<-1<<endl;\n\texit(0);\n      }\n      \n    }else dfs(nx,!c);\n\n  }\n  \n}\n\nll dp[N];\nmap<P,int> S;\n\nint main(){\n    \n  cin>>n>>e;\n \n  for(int i=0;i<e;i++){\n    \n    int a,b;\n    cin>>a>>b;\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  memset(color,-1,sizeof(color));\n\n  for(int i=0;i<n;i++)\n    if(color[i]==-1){\n      s[0]=s[1]=0;\n      dfs(i,0);\n      if(s[0]>s[1]) swap(s[0],s[1]);\n      S[P(s[0],s[1])]++;\n    }\n\n  map<P,int>::iterator ite=S.begin();\n  \n  memset(dp,-1,sizeof(dp));\n  \n  while(ite!=S.end()){\n    \n    dp[0]=0;\n    \n    P x=(*ite).first;\n    \n    for(int i=0;i<n;i++)\n      if(dp[i]>=0) dp[i]=(*ite).second;\n    \n    for(int i=0;i<n;i++)\n\n      if(dp[i]>0){\n\tif(i+x.first<=n) dp[i+x.first]=max(dp[i+x.first],dp[i]-1);\n\tif(i+x.second<=n) dp[i+x.second]=max(dp[i+x.second],dp[i]-1);\n      }\n\n    ite++;\n  }\n  \n  ll ans=0;\n  \n  for(ll i=0;i<=n;i++)\n    if(dp[i]>=0) ans=max(ans,i*(n-i));\n  \n  cout<<ans-e<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V,E;\nvector<int> G[100005];\nvector<int> A,B;\nbool flg=false;\nbool visited[100005];\nint depth[100005];\nint cnt[2];\n\nvoid dfs(int pos,int d){\n  \n  if(visited[pos]){\n    if(depth[pos]!=d)flg=true;\n    return;\n  }\n  \n  visited[pos]=true;\n  depth[pos]=d;\n  cnt[d]++;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dfs(to,1-d);\n  }\n}\n\ntypedef long long ll;\nint dp[100005];\nint cc[100005];\n\nll solve(){\n  if(flg)return -1;\n  map<int,int> mp;\n  int sum=0;\n  for(int i=0;i<(int)A.size();i++){\n    int mn=min(A[i],B[i]);\n    int mx=max(A[i],B[i]);\n    sum+=mn;\n    mp[mx-mn]++;\n  }\n  dp[0]=1;\n  map<int,int>::iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    int a=it->first,b=it->second;\n    if(a==0)continue;\n    memset(cc,0,sizeof(cc));    \n    for(int i=0;i<=V;i++){\n      if(i-a>=0)dp[i]+=cc[i-a];\n      if(i-a*b-a>=0)dp[i]-=cc[i-a*b-a];\n      cc[i]=dp[i];\n      if(i-a>=0)cc[i]+=cc[i-a];\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<=V;i++){\n    if(dp[i]){\n      ans=max(ans, (ll)(i+sum)*(ll)(V-i-sum) );\n    }\n  }\n  return ans-(ll)E;\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);    \n  }\n  for(int i=0;i<V;i++){\n    if(visited[i])continue;\n    cnt[0]=cnt[1]=0;\n    dfs(i,0);\n    A.push_back(cnt[0]);\n    B.push_back(cnt[1]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector< vector<bool> > dp(goods.size() + 1, vector<bool>(V / 2 - sum + 1, false));\n    dp[0][0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      for(int S = 1; S <= goods[i].second; S <<= 1) {\n        REP(j, dp[i].size()){\n          if(dp[i][j]){\n            dp[i + 1][j] = true;\n            int nj = j + goods[i].first * S;\n            if(nj < dp[i + 1].size()){\n              max_c = max(max_c, nj);\n              dp[i + 1][nj] = true;\n            }\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n\n  map<PLL,int> xs;\n  VI parity(V);\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs[res]++;\n\t}\n  }\n\n  int crt = 0, nxt = 1;\n  vector<vector<bool>> dp(2, vector<bool>(V+1));\n  dp[crt][0] = true;\n  for(auto&& p_: xs){\n\tint num = p_.SS;\n\tint b = 1;\n\twhile(num){\n\t  fill(ALL(dp[nxt]), false);\n\t  if(num < b)\n\t\tb = num;\n\t  num -= b;\n\n\t  PLL p(p_.FF.FF * b, p_.FF.SS*b);\n\t  for(int i=V;i-p.FF>=0;--i)\n\t\tdp[nxt][i] = dp[nxt][i] || dp[crt][i-p.FF];\n\t  for(int i=V;i-p.SS>=0;--i)\n\t\tdp[nxt][i] = dp[nxt][i] || dp[crt][i-p.SS];\n\t  \n\t  b <<= 1;\n\t  swap(crt, nxt);\n\t}\n  }\n\n  LL ans = 0;\n  REP(i,V+1) if(dp[crt][i]) maxi(ans, (LL)i*(V-i));\n  cout << ans - E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< pii, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\n\tlint A = 0;\n\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tpii p = (*it).first;\n\t\tint a = p.second, c = (*it).second;\n\t\tA += p.first;\n\t\t\n\t\tfor_(j,0,2*N) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,2*N) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[pii(a, b - a)];\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint V,E;\nvi g[100010];\nint size;\nmap<int,int> M;\nint dp[50010];\n\nint color[100010];\n\npi dfs(int v,int c){\n\tpi res;\n\tif(c==1)res.fir=1;\n\telse res.sec=1;\n\tcolor[v]=c;\n\trep(i,sz(g[v])){\n\t\tif(color[g[v][i]]==c)return mp(-1,-1);\n\t\tif(!color[g[v][i]]){\n\t\t\tpi res2=dfs(g[v][i],-c);\n\t\t\tif(res2.fir==-1)return mp(-1,-1);\n\t\t\tres.fir+=res2.fir;\n\t\t\tres.sec+=res2.sec;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>V>>E;\n\trep(i,E){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\trep(i,V)if(!color[i]){\n\t\tpi res=dfs(i,1);\n\t\tif(res.fir==-1){\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(res.fir>res.sec)swap(res.fir,res.sec);\n\t\tsize+=res.fir;\n\t\tM[res.sec-res.fir]++;\n\t}\n\tint m=V/2-size;\n\tfill(dp,dp+m+1,-1);\n\tdp[0]=0;\n\tforeach(it,M){\n\t\trep(i,m+1){\n\t\t\tif(dp[i]>=0){\n\t\t\t\tdp[i]=it->sec;\n\t\t\t}else if(i < it->fir || dp[i - it->fir] <= 0){\n\t\t\t\tdp[i]=-1;\n\t\t\t}else{\n\t\t\t\tdp[i]=dp[i - it->fir]-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m;i>=0;i--)if(dp[i]>=0){\n\t\tsize+=i;\n\t\tcout<<size*(V-size)-E<<endl;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col, a, b;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tint P = a.size(), lft = 0, rgt = 0;\n\t\n\tfor_(i,0,P) {\n\t\t//cout << a[i] << \" \" << b[i] << endl;\n\t\tlft += a[i];\n\t\trgt += b[i];\n\t}\n\t\n\twhile (1) {\n\t\tbool update = false;\n\t\t\n\t\t//cout << lft << \" \" << rgt << endl;\n\t\t\n\t\tfor_(i,0,P) {\n\t\t\tint cur_abs = abs(lft - rgt);\n\t\t\t\n\t\t\tint nlft = lft - a[i] + b[i];\n\t\t\tint nrgt = rgt - b[i] + a[i];\n\t\t\t\n\t\t\tint nxt_abs = abs(nlft - nrgt);\n\t\t\t\n\t\t\tif (cur_abs > nxt_abs) {\n\t\t\t\tupdate = true;\n\t\t\t\tswap(a[i], b[i]);\n\t\t\t\tlft = nlft;\n\t\t\t\trgt = nrgt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!update) break;\n\t}\n\t\t\n\treturn (lint)lft * (lint)rgt;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\ta.push_back(g[0].size());\n\t\tb.push_back(g[1].size());\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tset<long long int>dp;\n\tdp.insert( 0 );\n\tlong long int xx = 0;\n\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tsub[i] = abs(two[i].first - two[i].second);\n\t}\n\tsort( sub.rbegin(), sub.rend() );\n\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tif( xx > 0 ) {\n\t\t\txx -= sub[i];\n\t\t} else {\n\t\t\txx += sub[i];\n\t\t}\n\t}\n\n\tcout << ( V - xx ) / 2 * ( ( V - xx ) / 2 + xx ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define int ll\nint n,m;\nvvi G;\nvi used,in,tmp;\nint dfs(int a,int b=0){\n\ttmp.pb(a);\n\tused[a]=b;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(used[to]==2){\n\t\t\tif(!dfs(to,b^1))return 0;\n\t\t}else if(used[to]==b)return 0;\n\t}\n\treturn 1;\n}\nsigned main(){\n\tcin>>n>>m;\n\tG=vvi(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tused=vi(n,2);\n\tin=vi(n);\n\tll sum=0;\n\trep(i,n)if(used[i]==2){\n\t\ttmp=vi(0);\n\t\tif(!dfs(i)){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll co=0;\n\t\trep(j,tmp.size())if(used[tmp[j]]==1)co++;else co--;\n\t\tin[abs(co)]++;\n\t\tsum+=abs(co);\n\t}\n\tvi dp(100010,-1);\n\tdp[0]=0;\n\trep(i,n)if(in[i])rep(j,100010){\n\t\tif(dp[j]>=0)dp[j]=in[i];\n\t\telse if(j<i||dp[j-i]<=0)dp[j]=-1;\n\t\telse dp[j]=dp[j-i]-1;\n\t}\n\tll t=INF;\n\trep(i,100010)if(dp[i]>=0)t=min(t,abs(i-(sum-i)));\n\tcout<<(n*n-t*t)/4-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 100100;\ntypedef pair<int, int> P;\n\nvector<int> g[MN];\nbool used[MN];\nbool color[MN];\nint c0, c1;\nbool err;\nvoid dfs(int p, bool c) {\n    used[p] = true;\n    color[p] = c;\n    if (!c) c0++;\n    else c1++;\n    for (int d: g[p]) {\n        if (used[d]) {\n            if (color[p] == color[d]) err = true;\n            continue;\n        }\n        dfs(d, !c);\n    }\n}\n\nbitset<MN> b;\nll solve() {\n    int v, e;\n    cin >> v >> e;\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    b[0] = true;\n    for (int i = 0; i < v; i++) {\n        if (used[i]) continue;\n        c0 = c1 = 0;\n        dfs(i, 0);\n        if (err) return -1;\n        b = (b<<c0) | (b<<c1);\n    }\n    ll sm = -1;\n    for (int i = 0; i < v; i++) {\n        if (!b[i]) continue;\n        sm = max(sm, (ll)(v-i)*i-e);\n    }\n    return sm;\n}\n\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint dp[N] = {};\nint DP(){\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n\n  for(P a:A){\n    dp[0] = 1;\n    for(int j=0;j<N;j++)if(dp[j]) dp[j] = a.second+1;\n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n  for(int i=0;i<N;i++)\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector<bool> dp(V / 2 - sum + 1, false);\n    dp[0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      int num = goods[i].second;\n      for(int k = 1; num > 0; k <<= 1) {\n        int s = min(num, k);\n        num -= s;\n        for(int j = dp.size() - 1; j >= 0; j--){\n          int nj = j + goods[i].first * s;\n          if(nj < dp.size()){\n            max_c = max(max_c, nj);\n            dp[nj] = true;\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\nusing ll = long long;\n\n\nstruct Graph {\n    Graph(const int n) : edge(n) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n};\n\nusing P = pair<int, int>;\nP dfs(const Graph& g, const int s, vector<int>& color, bool black = true)\n{\n    int b = 1;\n    int w = 0;\n    color[s] = (int)(black);\n    for (const int to : g.edge[s]) {\n        if (color[to] != -1) {\n            if (black == color[to]) {\n                return make_pair(-1, -1);\n            }\n            continue;\n        }\n        int sb, sw;\n        tie(sw, sb) = dfs(g, to, color, not black);\n        if (sw == -1) {\n            return make_pair(-1, -1);\n        }\n        w += sw;\n        b += sb;\n    }\n    return make_pair(b, w);\n}\n\nint main()\n{\n    ll V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.addEdge(a, b);\n    }\n    vector<int> div;\n    vector<int> color(V, -1);\n    for (int i = 0; i < V; i++) {\n        if (color[i] != -1) {\n            continue;\n        }\n        const auto p = dfs(g, i, color);\n        if (p.first == -1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        div.push_back(abs(p.first - p.second));\n    }\n\n    sort(div.begin(), div.end());\n    vector<int> a = div;\n    a.erase(unique(a.begin(), a.end()), a.end());\n    vector<int> num(a.size());\n    int pos = 0;\n    for (int i = 0; i < a.size(); i++) {\n        int n = 0;\n        for (; pos < div.size(); pos++) {\n            if (div[pos] == a[i]) {\n                n++;\n            } else {\n                break;\n            }\n        }\n        num[i] = n;\n    }\n    const int sum = accumulate(div.begin(), div.end(), 0);\n    vector<int> dp(sum + 1, -1);\n    const int size = a.size();\n    dp[0] = 0;\n    for (int i = 0; i < size; i++) {\n        for (int j = 0; j <= sum; j++) {\n            if (dp[j] >= 0) {\n                dp[j] = num[i];\n            } else if (j < a[i] or dp[j - a[i]] <= 0) {\n                dp[j] = -1;\n            } else {\n                dp[j] = dp[j - a[i]] - 1;\n            }\n        }\n    }\n    constexpr ll INF = 1LL << 60;\n    ll mini = INF;\n    for (int i = 0; i <= sum; i++) {\n        if (dp[i] > -1) {\n            mini = min(mini, (ll)abs(i - (sum - i)));\n        }\n    }\n    cout << ((V - mini) / 2) * ((V + mini) / 2) - E << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tfor(;;);\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//良問すぎん?\n\n// グラフに奇数長の閉路を持たない　<=> 二部グラフ\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nbool dfs(long long node, long long c, long long& cnt_0, long long& cnt_1, vector<long long>& used, vector<vector<long long> >& adj){\n\n    used[node] = c;\n    long long next_c = (c + 1) % 2;\n    if(c == 0) cnt_0++;\n    else cnt_1++;\n\n    for(auto next_node : adj[node]){\n        if(used[next_node] == next_c) continue;\n        else if(used[next_node] == c) return false;\n        else{\n            if(!dfs(next_node, next_c, cnt_0, cnt_1, used, adj)) return false;\n        }\n    }\n\n    return true;\n}\n\n\nint main(){\n    \n    // 入力受け取り\n    long long V, E; cin >> V >> E;\n    vector<vector<long long> > adj(V);\n\n    for(long long i = 0; i < E; i++){\n        long long a, b; cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n\n\n    //二部グラフ判定パート\n    vector<long long> used(V, -1);     //-1 := 見訪問  0:= 白  1 := 黒\n    map<long long, long long> M;\n    long long sum = 0;\n    for(long long i = 0; i < V; i++){\n        if(used[i] == -1){\n\n            long long cnt_0 = 0;\n            long long cnt_1 = 0;\n            if(!dfs(i, 0, cnt_0, cnt_1, used, adj)){\n                cout << -1 << endl;\n                return 0;\n            }\n\n            //cout << i + 1 << \" \" << cnt_0 << \" \" << cnt_1 << endl;\n            sum += (long long)abs(cnt_0 - cnt_1);\n            M[(long long)abs(cnt_0 - cnt_1)]++;\n        }\n    }\n\n\n\n    //個数制限付き部分和問題\n\n    long long n = (long long)M.size();\n\n    //dp[i][j] := i番目までのものを使って j を作る最大の a[i]の残る個数 (作れない場合は -1)\n    vector<vector<long long> > dp(2, vector<long long> (sum + 1, -1LL));\n    dp[0][0] = 0;\n    int now_i = 0;\n    int next_i = 1;\n    for(auto x : M){\n        for(long long j = 0; j <= sum; j++){\n\n            if(dp[now_i][j] != -1) dp[next_i][j] = x.second;\n            else{\n                if(j - x.first >= 0) dp[next_i][j] = max(-1LL, dp[next_i][j - x.first] - 1LL);\n            }\n            //cout << \"dp[\" << i << \"][\" << j << \"] = \" << dp[i][j] << endl;\n        }\n        swap(now_i, next_i);\n    }\n\n    long long ans = sum;\n    for(long long j = 0; j <= sum; j++){\n\n        //cout << \"dp[\" << i - 1 << \"][\" << j << \"] = \" << dp[i - 1][j] << endl;         \n        if(dp[now_i][j] != -1) ans = min(ans, (long long)abs(sum - 2 * j));\n    }\n\n    cout << (V * V - ans * ans) / 4 - E << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_, ret;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tfor (int j = 0; j < City[CitySet[0][i]].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[CitySet[0][i]] == Bipartite[City[CitySet[0][i]][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int bits = 0; bits < (1 << (CitySet.size() - 1)); bits++)\n\t{\n\t\tlong long crt = 0;\n\n\t\tfor (int i = 1; i < CitySet.size(); i++)\n\t\t{\n\t\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\t\tvector<int> Bipartite2(Bipartite.begin(), Bipartite.end());\n\n\t\t\tif (bits & (1 << (i - 1)))\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tBipartite2[CitySet[i][j]] = (Bipartite2[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][0]] + 1) % 2]; CityType[Bipartite2[CitySet[i][0]]]++;\n\n\t\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tcrt += CityType2[(Bipartite2[CitySet[i][j]] + 1) % 2];\n\n\t\t\t\tCityType[Bipartite2[CitySet[i][j]]]++;\n\t\t\t}\n\t\t}\n\n\t\tret = max(ret, crt);\n\t}\n\n\tcout << count_ + ret << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=abs(even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nvector<pair<int,int>>colors;\nvector<vector<int>>edges;\npair<int,int> dfs(const int now,const int num) {\n\tconst int nextcolor = !colors[now].second;\n\tpair<int, int>nums(0,0);\n\tif (colors[now].second == 1)nums.second++;\n\telse nums.first++;\n\tfor (auto e : edges[now]) {\n\t\tif (colors[e].second == -1) {\n\t\t\tcolors[e] = make_pair(now,nextcolor);\n\t\t\tpair<int,int>p=dfs(e, num);\n\t\t\tif (!p.first&&!p.second)return p;\n\t\t\tnums.first += p.first;\n\t\t\tnums.second += p.second;\n\t\t}\n\t\telse if (colors[e].second != nextcolor)return make_pair(0, 0);\n\t}\n\treturn nums;\n}\n\nbool dp[2][100001];\nint main() {\n\tint V, E; cin >> V >> E;\n\tfor (int i = 0; i < V; ++i) {\n\t\tcolors.push_back(make_pair(-1, -1));\n\t}\n\tedges.resize(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint color = 0;\n\tvector<pair<int, int>>ps;\n\tbool ok = true;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (colors[i].second == -1) {\n\t\t\tcolors[i] = make_pair(color,0);\n\t\t\tpair<int,int>p=dfs(i, color);\n\t\t\tif (!p.first&&!p.second) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\tif (p.first > p.second)swap(p.first, p.second);\n\t\t\tps.push_back(p);\n\t\t\tcolor++;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tint amin = 0;\n\t\tmap<int,int>pluss;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\tamin += ps[i].first;\n\t\t\tif (ps[i].first != ps[i].second) {\n\t\t\t\tpluss[ps[i].second - ps[i].first]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < 100000; ++i) {\n\t\t\tif (pluss.find(i) != pluss.end()) {\n\t\t\t\tconst int bai = (pluss[i] - 1) / 2;\n\t\t\t\tif (bai) {\n\n\n\t\t\t\t\tpluss[2 * i] += bai;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>naps;\n\t\tfor (int i = 1; i < 100000; ++i) {\n\t\t\tif (pluss.find(i) != pluss.end()) {\n\t\t\t\tfor (int j = 0; j < pluss[i]; ++j) {\n\t\t\t\t\tnaps.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = true;\n\t\tfor (int i = 0; i < naps.size(); ++i) {\n\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\tfor (int i = 0; i < 100001; ++i) {\n\t\t\t\tdp[cur][i] = 0;\n\t\t\t}\n\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\tfor (int j = 0; j < 100000; ++j) {\n\t\t\t\tif (dp[tar][j]) {\n\t\t\t\t\tdp[cur][j] = true;\n\t\t\t\t\tdp[cur][j + naps[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tif (abs(ans+amin - V / 2)>abs(i+amin - V / 2) && dp[naps.size()%2][i]) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tcout << (amin+ans)*(V - ans-amin) - E << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V,E;\nvector<int> G[100005];\nvector<int> A,B;\nbool flg=false;\nbool visited[100005];\nint depth[100005];\nint cnt[2];\n\nvoid dfs(int pos,int d){\n  \n  if(visited[pos]){\n    if(depth[pos]!=d)flg=true;\n    return;\n  }\n  \n  visited[pos]=true;\n  depth[pos]=d;\n  cnt[d]++;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dfs(to,1-d);\n  }\n}\n\ntypedef long long ll;\nint dp[2][100005];\n\nint cc[100005];\n\nll solve(){\n  if(flg)return -1;\n  \n  map<int,int> mp;\n  int sum=0;\n  for(int i=0;i<(int)A.size();i++){\n    int mn=min(A[i],B[i]);\n    int mx=max(A[i],B[i]);\n    sum+=mn;\n    mp[mx-mn]++;\n  }\n  \n  dp[0][0]=1;\n  dp[1][0]=1;\n  \n  map<int,int>::iterator it;\n\n  int ai=0,bi=1;\n  for(it=mp.begin();it!=mp.end();it++){\n    swap(ai,bi);\n    \n    int a=it->first,b=it->second;\n    if(a==0)continue;\n    \n    \n    memset(cc,0,sizeof(cc));    \n    for(int i=0;i<=V;i++){\n      int k=0;\n      if(i-a>=0)k+=cc[i-a];\n      if(i-a*b-a>=0)k-=cc[i-a*b-a];\n      if(k>0 || dp[bi][i]==1)dp[ai][i]=1;\n      \n      cc[i]=dp[bi][i];\n      if(i-a>=0)cc[i]+=cc[i-a];\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<=V;i++){\n    if(dp[ai][i]>0 || dp[bi][i]>0){\n      ans=max(ans, (ll)(i+sum)*(ll)(V-i-sum) );\n    }\n  }\n  return ans-(ll)E;\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);    \n  }\n  for(int i=0;i<V;i++){\n    if(visited[i])continue;\n    cnt[0]=cnt[1]=0;\n    dfs(i,0);\n    A.push_back(cnt[0]);\n    B.push_back(cnt[1]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> G[100000];\nbool flag = false;\nint a = 0, b = 0;\nint color[100000];\n\nvoid dfs(int n, int c) {\n\tcolor[n] = c;\n\tif (c - 1) {\n\t\tb++;\n\t}\n\telse {\n\t\ta++;\n\t}\n\tfor (auto v : G[n]) {\n\t\tif (color[v] == 0) {\n\t\t\tdfs(v, 3 - c);\n\t\t}\n\t\telse if (color[v] == c) {\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll V, E;\n\tcin >> V >> E;\n\tfor (int i = 0, a, b; i < E; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tll x = 0;\n\tvector<ll> d;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (color[i] == 0) {\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tif (a != b) {\n\t\t\td.push_back(abs(a - b) * 2);\n\t\t\tx += abs(a - b);\n\t\t}\n\t\ta = b = 0;\n\t}\n\tvector<int> dp(V + 1); dp[0] = 1;\n\tfor (auto bi : d) {\n\t\tfor (int i = 0; i <= V - bi; i++) {\n\t\t\tif (dp[i]) {\n\t\t\t\tdp[i + bi] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\twhile (dp[x - res] == 0 && dp[x + res] == 0) res++;\n\tcout << (flag ? -1ll : (V + res) * (V - res) / 4 - E) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nint memo[2][2][1010][1010];\n\nint rec(int p, int t, int o, int e){\n  if (o + e == 2){\n    return 1 - 2 * ((e == 2) ^ p ^ t);\n  } else if (memo[p][t][o][e] != 0){\n    return memo[p][t][o][e];\n  } else {\n    int &res = memo[p][t][o][e] = -1;\n    if (o > 1) res = max(res, -rec(p, 1 - t, o - 1, e));\n    if (e > 1) res = max(res, -rec(p, 1 - t, o, e - 1));\n    if (o > 0 && e > 0) res = max(res, -rec(p, 1 - t, o, e - 1));\n    return res;\n  }\n}\n\nint main(){\n  int V;\n  char A[1010];\n  while (cin >> V){\n    int E = 0;\n    vector<vector<int> > G(V);\n    REP(i, V){\n      scanf(\" %s\", A);\n      REP(j, V) if (A[j] == 'Y'){\n        G[i].push_back(j);\n        E++;\n      }\n    }\n\n    int even = 0;\n    int odd  = 0;\n    vector<int> visit(V);\n    REP(i, V) if (!visit[i]){\n      int count = 0;\n      visit[i] = true;\n      queue<int> que;\n      que.push(i);\n      while (!que.empty()){\n        int v = que.front(); que.pop();\n        count++;\n        for (int w : G[v]){\n          if (!visit[w]){\n            visit[w] = true;\n            que.push(w);\n          }\n        }\n      }\n      (count % 2 ? odd : even) += 1;\n    }\n    E /= 2;\n    int p = (V * (V - 1) / 2 - E) % 2;\n    cout << (rec(p, true, odd, even) >= 0? \"Taro\" : \"Hanako\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,int c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n\n  vertex.resize(n,-1);\n  vector<int> dis;\n  for(int i=0;i<chunk.size();i++){\n\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    dis.push_back(abs(cnt1-(chunk[i].size()-cnt1)));\n  }\n  int n2=1;\n  while(n2<n) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  int sum=accumulate(dis.begin(),dis.end(),0);\n  long long int res=0;\n  for(auto v:now[0]){\n    int dist=v;\n    long long int b=(n+dist)/2;\n    long long int a=(n-dist)/2;\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2370.cpp\n//\n//\n//  Created by Yoshida Satoshi on 2018/11/07.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define MAX 100010\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct D\n{\n    int a,b;\n    ll d;\n    \n    bool operator<(const D& rhs)const\n    {\n        return d>rhs.d;\n    }\n};\n\nstruct UF\n{\n    vector<int> p;\n    \n    \n    UF(int n):p(n)\n    {\n        for(int i=0;i<n;i++) p[i]=i;\n    }\n    \n    int root(int x)\n    {\n        if(p[x]==x) return x;\n        else        return p[x]=root(p[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        p[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    \n    {\n        int rx=root(x);\n        int ry=root(y);\n        return rx==ry;\n    }\n};\n\nstruct Graph\n{\n    int v,e;\n    vector<int> p[MAX];//iとconnectedなvertex\n    ll even[MAX]={};\n    ll odd[MAX]={};\n    int c[MAX]={};\n    ll ans=0;\n    \n    \n    void input()\n    {\n        cin>>v>>e;\n        int a,b;\n        for(int i=0;i<e;i++)\n        {\n            cin>>a>>b;\n            a--;b--;\n            p[a].push_back(b);\n            p[b].push_back(a);\n        }\n    }\n    \n    void dfs(int x,int col,int l)\n    {\n        if(c[x]==-1*col)\n        {\n            ans=-1;return;\n        }\n        if(ans==-1) return;\n        if(c[x]!=0) return;\n        \n        c[x]=col;\n        if(col==1) odd[l]++;\n        else   even[l]++;\n        \n        for(int i=0;i<p[x].size();i++)\n        {\n            int y=p[x][i];\n            dfs(y,-1*col,l);\n        }\n    }\n    \n    void solve()\n    {\n        int l=0;\n        for(int i=0;i<v;i++)\n        {\n            if(c[i]==0)\n            {\n                dfs(i,1,l);\n                l++;\n            }\n        }\n        \n        if(ans!=-1)\n        {\n            int d[MAX];\n            int m[MAX]={};\n            ll sum=0;\n            for(int i=0;i<l;i++)\n            {\n                if(even[i]<odd[i]) swap(even[i],odd[i]);\n                d[i]=even[i]-odd[i];\n                sum+=odd[i];\n                //ans+=even[i]*odd[i];\n            }\n            //ans-=e;\n            \n            int dp[MAX];\n            \n            sort(d,d+l);\n            \n            int tmp=-1;\n            int cnt=-1;\n            \n            for(int i=0;i<l;i++)\n            {\n                if(d[i]==tmp) m[cnt]++;\n                else\n                {\n                    cnt++;\n                    tmp=d[i];\n                    d[cnt]=d[i];\n                    m[cnt]++;\n                }\n            }\n            for(int i=0;i<=v;i++)\n            {\n                dp[i]=-1;\n            }\n            dp[0]=0;\n            \n            for(int i=0;m[i]>0;i++)\n            {\n                for(int j=0;j<=v;j++)\n                {\n                    if(dp[j]>=0) dp[j]=m[i];\n                    else if(j>=d[i]&&dp[j-d[i]]>0) dp[j]=dp[j-d[i]]-1;\n                    else         dp[j]=-1;\n                }\n            }\n            \n            ll ans2=0;\n            for(int i=0;i<=v;i++)\n            {\n                if(dp[i]>=0) ans2=max(ans2,(sum+i)*(v-sum-i));\n            }\n            \n            ans2-=e;\n            ans=ans2;\n            \n            \n            /*\n            UF uf(4*l);//0~l-1:even is -1,l~2l-1:even is 1,2l~:odd is -1,3l~:odd is 1\n            vector<D> d;\n            \n            \n            for(int i=0;i<l;i++)\n            {\n                for(int j=0;j<i;j++)\n                {\n                    d.push_back({i,j,(even[i]*even[j]+odd[i]*odd[j])-(even[i]*odd[j]+odd[i]*even[j])});\n                }\n            }\n            sort(d.begin(),d.end());\n            \n            for(int i=0;i<d.size();i++)\n            {\n                int x=d[i].a;int y=d[i].b;\n                if(!uf.same(d[i].a,d[i].b)&&!uf.same(d[i].a+l,d[i].b+l))\n                {\n                    uf.unite(d[i].a,d[i].b+l);\n                    uf.unite(d[i].a+l,d[i].b);\n                    uf.unite(d[i].a+2*l,d[i].b+3*l);\n                    uf.unite(d[i].a+3*l,d[i].b+2*l);\n                    ans+=(even[x]*even[y]+odd[x]*odd[y]);\n                }\n                else if(!uf.same(d[i].a+2*l,d[i].b)&&!uf.same(d[i].a+3*l,d[i].b+l))\n                {\n                    uf.unite(d[i].a+2*l,d[i].b+l);\n                    uf.unite(d[i].a+3*l,d[i].b);\n                    uf.unite(d[i].a,d[i].b+3*l);\n                    uf.unite(d[i].a+l,d[i].b+2*l);\n                    ans+=(even[x]*odd[y]+odd[x]*even[y]);\n                }\n            }\n             */\n        }\n        cout<<ans<<endl;\n    }\n    \n};\n\nint main()\n{\n    Graph g;\n    g.input();\n    g.solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nvoid dfs2(VVI& G, int u, vector<bool>& vis, VI& parity, PLL& ps, LL& ans){\n  vis[u] = true;\n  if(parity[u] > 0)\n\tans += ps.SS - SZ(G[u]);\n  else{\n\tans += ps.FF - SZ(G[u]);\n  }\n  \n  for(int to: G[u]){\n\tif(vis[to]) continue;\n\tdfs2(G, to, vis, parity, ps, ans);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n  vector<PLL> xs;\n  vector<bool> vis(V);\n  VI parity(V);\n  LL ans = 0;\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  LL tmp = 0;\n\t  dfs2(G, i, vis, parity, res, tmp);\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs.EB(res);\n\t  ans += tmp / 2;\n\t}\n  }\n\n  while(SZ(xs) > 1){\n\tPLL p1 = xs.back(); xs.pop_back();\n\tPLL p2 = xs.back(); xs.pop_back();\n\tif(p1.FF*p2.FF + p1.SS*p2.SS > p1.FF*p2.SS + p1.SS*p2.FF){\n\t  ans += p1.FF*p2.FF + p1.SS*p2.SS;\n\t  xs.EB(p1.FF+p2.SS, p1.SS+p2.FF);\n\t}\n\telse{\n\t  ans += p1.FF*p2.SS + p1.SS*p2.FF;\n\t  xs.EB(p1.FF+p2.FF, p1.SS+p2.SS);\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n\n    map<ll,ll> m;\n    ll sub = 0;\n    for (int i = 0; i < s[0].size(); i++) {\n        m[(ll)max(s[0][i].size(), s[1][i].size()) - (ll)min(s[0][i].size(), s[1][i].size())]++;\n        sub += (ll)min(s[0][i].size(), s[1][i].size());\n    }\n\n    vector<ll> dp(N+1, -1);\n    dp[0] = 0;\n    for (auto p : m) {\n        ll x = p.first;\n        ll count = p.second;\n        for (ll i = 0; i < dp.size(); i++) {\n            if (dp[i] >= 0) dp[i] = count;\n            else if (i < x || dp[i - x] < 0) dp[i] = -1LL;\n            else dp[i] = dp[i - x] - 1LL;\n        }\n    }\n\n    ll ans = 0;\n    for (ll i = 0; i <= N; i++) {\n        if (dp[i] >= 0)\n            ans = max(ans, (sub + i) * (N - sub - i) - M);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\n\n\nint main(){\n\tcin>>n;\n\tcout<<n+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  vector<int> df2(cnt);\n  REP(i,cnt) {\n    df2[i] = 2 * abs(sum[2*i]);\n  }\n  sort(ALL(df2));\n  int ofs = 0;\n  REP(i,cnt) if (!df2[i]) ++ofs;\n  int ofs2 = ofs;\n  REP(i,cnt) if (df2[i] == 2) ++ofs2;\n  int twice = 0;\n  REP(i,cnt) twice += df2[i];\n  vector<bool> dp(twice+1);\n  dp[0] = 1;\n  REP(i,cnt-ofs2) {\n    auto tmp = dp;\n    REP(j,twice-df2[i+ofs2]+1) {\n      if (dp[j])\n        tmp[j+df2[i+ofs2]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,twice+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int64_t smaller = v/2 - mn/2 + ofs2-ofs;\n  if (smaller > v/2) smaller = v/2;\n  int64_t larger = v - smaller;\n  int64_t m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nvector<int> check;\n\nbool solve(int curr, int color, vector<int>& x)\n{\n    check[curr] = color;\n    ++ x[color];\n\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        int next = edges[curr][i];\n        if(check[next] == -1){\n            if(!solve(next, color^1, x))\n                return false;\n        }else{\n            if(check[next] == color)\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n\n    edges.assign(v, vector<int>());\n    for(int i=0; i<e; ++i){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    check.assign(v, -1);\n    bitset<50001> bs;\n    bs[0] = true;\n\n    for(int i=0; i<v; ++i){\n        if(check[i] != -1)\n            continue;\n\n        vector<int> x(2, 0);\n        if(!solve(i, 0, x)){\n            cout << -1 << endl;\n            return 0;\n        }\n\n        bs = (bs << x[0]) | (bs << x[1]);\n    }\n\n    int a = v / 2;\n    while(!bs[a])\n        -- a;\n\n    long long ret = (long long)a * (v - a);\n    ret -= e;\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 12345678;\n\nconst int B = 10;\n// const int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[B][N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n    // calc large\n    int L = l.size();\n\n    memset(dp,0,sizeof(dp));\n    queue<pi> que;\n\n    dp[0][0] = 1;\n    que.push({0,0});\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        int idx = now.fi;\n        int val = now.se;\n        if(idx == L) continue;\n\n        for(int i=-1; i<=1; i+=2){\n            int nx = abs(val+i*l[idx]);\n            if(!dp[idx+1][nx]){\n                dp[idx+1][nx] = 1;\n                que.push({idx+1, nx});\n            }\n        }\n    }\n    rep(i,N)if(dp[L][i]) Ld.pb(i);\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0] = 0;\n    for(int i=1; i<B; ++i){\n        priority_queue<pi> pq;\n        rep(j,N)if(dp[i-1][j]%2==0){\n            pq.push({ct[i],j});\n            dp[i][j] = ct[i];\n        }\n\n        while(!pq.empty()){\n            pi now = pq.top();\n            pq.pop();\n            if(now.fi == 0) continue;\n\n            for(int j=-1; j<=1; j+=2){\n                int nx = abs(now.se+j*i);\n                if(dp[i][nx] < dp[i][now.se]-1){\n                    dp[i][nx] = dp[i][now.se]-1;\n                    pq.push({dp[i][nx],nx});\n                }\n            }\n        }\n    }\n\n    rep(i,N)if(dp[B-1][i]==0) Sd.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int j=-1; j<=1; ++j){\n            int nx = idx + j;\n            if(0<=nx && nx<sz){\n                int dd = abs(i-Sd[nx]);\n                if(n-dd>0){\n                    assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tlong long int xx = 0;\n\n\tmap<long long int, long long int>MLL;\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tMLL[abs( two[i].first - two[i].second )]++;\n\t}\n\tvector<long long int>dp( V / 2 + 1, -1 );\n\tdp[0] = 0;\n\tfor( auto now : MLL ) {\n\t\tfor( size_t i = 0; i < V / 2 + 1; i++ ) {\n\t\t\tif( dp[i] >= 0 ) {\n\t\t\t\tdp[i] = now.second;\n\t\t\t} else if( i < now.first || dp[i - now.first] ) {\n\t\t\t\tdp[i] = -1;\n\t\t\t} else {\n\t\t\t\tdp[i] = dp[i - now.first] - 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor( long long int i = 0; i < V / 2 + 1; i++ ) {\n\t\tif( dp[i] != -1 ) {\n\t\t\txx = max( i, xx );\n\t\t}\n\t}\n\tcout << ( V - xx ) / 2 * ( V - ( V - xx ) / 2 ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector< vector<bool> > dp(goods.size() + 1, vector<bool>(V / 2 - sum + 1, false));\n    dp[0][0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      int num = goods[i].second;\n      for(int k = 1; num > 0; k <<= 1) {\n        int s = min(num, k);\n        num -= k;\n        REP(j, dp[i].size()){\n          if(dp[i][j]){\n            dp[i + 1][j] = true;\n            int nj = j + goods[i].first * s;\n            if(nj < dp[i + 1].size()){\n              max_c = max(max_c, nj);\n              dp[i + 1][nj] = true;\n            }\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,bool c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n  \n  vertex.resize(n,-1);\n  vector<int> dis;\n  int smsum=0;\n  for(int i=0;i<chunk.size();i++){\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    smsum+=min(cnt1,int(chunk[i].size())-cnt1);\n    dis.push_back(abs(cnt1-(int(chunk[i].size())-cnt1)));\n  }\n  int n2=1;\n  while(n2<chunk.size()) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n    assert(now.size()==n2);\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  \n  long long int res=0;\n  for(auto v:now[0]){\n    long long int b=(smsum+v);\n    long long int a=(n-smsum-v);\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector<bool> dp(V / 2 - sum + 1, false);\n    dp[0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      int num = goods[i].second;\n      for(int k = 1; num > 0; k <<= 1) {\n        int s = min(num, k);\n        num -= s;\n        for(int j = dp.size() - 1; j >= 0; j--)if(dp[j]){\n          int nj = j + goods[i].first * s;\n          if(nj < dp.size()){\n            max_c = max(max_c, nj);\n            dp[nj] = true;\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 200001;\nint n, m, v[100000], sum[MX];\nbool dp[2][MX];\nvector<vi> e;\n\nbool rec(int c, int col, int &a, int &b){\n\ta++;\n\tv[c] = col;\n\trep(i, e[c].size()){\n\t\tif(v[e[c][i]]){\n\t\t\tif(v[e[c][i]] == col) return 0;\n\t\t}\n\t\telse rec(e[c][i], -col, b, a);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\te.resize(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tmap<int, int> s;\n\trep(i, n) if(!v[i]){\n\t\tint a = 0, b = 0;\n\t\tif(!rec(i, 1, a, b)){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ts[abs(a - b)]++;\n\t}\n\t//each(i, s) cerr<<i->first<<\" \"<<i->second<<endl;\n\tconst int GETA = 100000;\n\tdp[0][GETA] = 1;\n\tint cur = 0, next = 1;\n\teach(i, s){\n\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\t\n\t\tint a = i->first, b = i->second;\n\t\tif(a == 0) continue;\n\t\t\n\t\trep(j, MX) if(dp[cur][j]){\n\t\t\tint t = (MX - 1 - j) / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tif(j + a * (t + 2) < MX) sum[j + a * (t + 2)]--;\n\t\t\t\n\t\t\tt = j / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tsum[j - a * t]++;\n\t\t}\n\t\tint l = 0;\n\t\trep(j, 2 * a) for(int k = j; k < MX; k += 2 * a){\n\t\t\tl += sum[k];\n\t\t\tif(l) dp[next][k] = 1;\n\t\t}\n\t\tswap(cur, next);\n\t}\n\tll mx = 0;\n\trep(i, MX) if(dp[cur][i]){\n\t\t//dbg(i);\n\t\tmx = max(mx, (ll)((n + i - GETA) / 2) * ((n - i + GETA) / 2));\n\t}\n\tcout << mx - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\nint n, m, a, b, d, u[200000]; vector<int>x[100000], c[100000], H; bool used[100000], f[200009], g[200009];\nvector<pair<int, int>>I;\nbool solve() {\n\tvector<int>col(n, -1);\n\tfor (int i = 0; i < d; i++) {\n\t\tqueue<int>Q; col[c[i][0]] = 0; Q.push(c[i][0]);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (col[j] == -1) { Q.push(j); col[j] = 1 - col[a1]; }\n\t\t\t\telse if (col[j] == col[a1]) { return false; }\n\t\t\t}\n\t\t}\n\t\tint v = 0; for (int j = 0; j < c[i].size(); j++) { if (col[c[i][j]] == 0)v++; else v--; }\n\t\tH.push_back(abs(v));\n\t}\n\treturn true;\n}\nvoid knapsack() {\n\tfor (int i = 0; i <= n * 2; i++)f[i] = false; f[n] = true;\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j = 0; j <= n * 2; j++) { g[j] = false; u[j] = -1; }\n\t\tfor (int j = 0; j <= n * 2; j++) {\n\t\t\tif (f[j] == false)continue;\n\t\t\tint r1 = I[i].first * 2;\n\t\t\tif (r1 == 0) { g[j] = true; continue; }\n\t\t\tint r3 = I[i].first*I[i].second*-1, r4 = -r3; r4 += j; r3 += j;\n\t\t\tr3 = max(r3, u[r3%r1]);\n\t\t\tfor (int k = r3; k <= r4; k += r1) { g[k] = true; u[k%r1] = k; }\n\t\t}\n\t\tfor (int j = 0; j <= n * 2; j++)f[j] = g[j];\n\t}\n}\nint main() {\n\tcin >> n >> m; for (int i = 0; i < m; i++) { cin >> a >> b; a--; b--; x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i] == true)continue; queue<int>Q;\n\t\tQ.push(i); used[i] = true;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop(); c[d].push_back(a1);\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (used[j] == false) { Q.push(j); used[j] = true; }\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tbool U = solve(); map<int, int>M, M2;\n\tif (U == false) { cout << \"-1\" << endl; return 0; }\n\tfor (int i = 0; i < H.size(); i++) M[H[i]]++;\n\tfor (int i = 0; i < H.size(); i++) {\n\t\tif (M2[H[i]] == 0) { M2[H[i]] = 1; I.push_back(make_pair(H[i], M[H[i]])); }\n\t}\n\tknapsack();\n\tlong long ret = 0;\n\tfor (int i = 0; i <= n; i++) { if (f[2 * i] == true)ret = max(ret, 1LL * (n - i)*i); }\n\tcout << ret - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < City[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[City[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] < CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[Bipartite[CitySet[i][j]]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint dp[N];\nint DP(){\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n  for(P a:A){\n    dp[0] = a.second;\n    for(int i=0;i<N;i++)if(dp[i]>0) dp[i] = a.second;\n    \n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n  for(int i=0;i<N;i++)\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  return res;\n}\n \nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<bitset>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for(int i=m;i<(int)(n);i++)\ntypedef pair<int,int> pint;\ntypedef long long ll;\nconst int inf   = 1<<30;\nconst ll  longinf = 1LL<<60;\nconst int mod=1e9+7;\nint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\nvector<int> v[100001];\nint cnt,used[100001];\nbool nibu;\n\nvoid dfs(int x,int flag){\n  if(flag==1)cnt++;\n  else cnt--;\n  rep(i,v[x].size()){\n    if(used[v[x][i]]==flag){\n      nibu=false;\n      return;\n      }\n    if(used[v[x][i]]==-1){\n      used[v[x][i]]=1-flag;\n      dfs(v[x][i],1-flag);\n      }\n    }\n  }\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n    }\n  rep(i,n)used[i]=-1;\n  vector<int> e;\n  rep(i,n){\n    if(used[i]==-1){\n      used[i]=1;\n      cnt=0;\n      nibu=true;\n      dfs(i,1);\n      if(!nibu){cout<<-1<<endl;return 0;}\n      if(abs(cnt))e.push_back(abs(cnt));\n      }\n    }\n  bitset<2000001> b;\n  b=1;\n  b=b<<100000;\n  rep(i,e.size())b=(b<<e[i])|(b>>e[i]);\n  rep(i,100001){\n    if(b[100000+i]||b[100000-i]){\n      ll ma=(ll)(n+i)/2;\n      ll mi=(ll)(n-i)/2;\n      cout<<ma*mi-m<<endl;\n      return 0;\n      }\n    }\n  return 0;    \n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[N][2], nx[N][2];\nint dp2[N], nx2[N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0] = 0;\n    for(int i=1; i<B; ++i){\n        memset(nx,-1,sizeof(nx));\n\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[j][0]>=0){\n            pq.push({C,{j,C%2}});\n            nx[j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int idx = abs(p.fi+j*i);\n\n                if(idx<N && nx[idx][!p.se] < now.fi-1){\n                    nx[idx][!p.se] = now.fi-1;\n                    pq.push({nx[idx][!p.se], {idx,!p.se}});\n                }\n            }\n        }\n\n        rep(j,N)rep(k,2) dp[j][k] = nx[j][k];\n    }\n    rep(i,N)if(dp[i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0] = 1;\n    rep(i,L){\n        memset(nx2,0,sizeof(nx2));\n        rep(j,N)if(dp2[j]){\n            for(int k=-1; k<=1; k+=2){\n                int idx = abs(j+k*Ld[i]);\n                if(idx<N) nx2[idx] = 1;\n            }\n        }\n\n        rep(j,N) dp2[j] = nx2[j];\n    }\n    rep(i,N)if(dp2[i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int a=-1; a<=1; ++a){\n            int j = idx + a;\n            if(0<=j && j<sz){\n                int dd = abs(i-Sd[j]);\n                if(n-dd>0){\n                    assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\ntypedef pair<int, int> P;\ntypedef long long ll;\nvector<int> v[100100];\nvector<int> e(100100); //0:uncolored 1:white -1:black\nbool flag;\nP dfs(int color, int node)\n{ //P.first:1 P.decond:-1\n    P res = P(0, 0);\n    for (auto i : v[node])\n    {\n        if (e[i] == 0)\n        {\n            e[i] = -color;\n            P p = dfs(-color, i);\n            res.first += p.first;\n            res.second += p.second;\n        }\n        else if (e[i] == color)\n        {\n            flag = true;\n        }\n    }\n    if (color == 1)\n    {\n        res.first++;\n    }\n    else\n    {\n        res.second++;\n    }\n    return res;\n}\nint dp[100100];\nint main()\n{\n    ll n, m;\n    cin >> n >> m;\n    rep(i, m)\n    {\n        int a, b;\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    vector<P> ans;\n    for (int i = 1; i <= n; i++)\n    {\n        if (e[i] == 0)\n        {\n            e[i] = 1;\n            P p = dfs(1, i);\n            ans.push_back(p);\n        }\n    }\n    int mx = 0;\n    int mn = 0;\n    dp[0] = 1;\n    for (auto i : ans)\n    {\n        int tmn = dp[mn] + i.first;\n        int tmx = tmn;\n        for (int j = n; j >= 0; j--)\n        {\n            if (dp[j])\n            {\n                dp[j] = 0;\n                dp[j + i.first] = 1;\n                dp[j + i.second] = 1;\n                tmx = max(tmx, dp[j + i.first]);\n                tmx = max(tmx, dp[j + i.second]);\n                tmn = min(tmn, dp[j + i.first]);\n                tmn = min(tmn, dp[j + i.second]);\n            }\n        }\n        mx = tmx;\n        mn = tmn;\n    }\n    if (flag)\n    {\n        cout << -1 << endl;\n    }\n    else\n    {\n        ll ans = 0;\n        for(ll i = 1;i<=n;i++){\n            if(dp[i]){\n                ans = max(ans,i*(n-i));\n            }\n        }\n        cout << ans - m << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int64_t i=(k);i<(int64_t)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nvoid add_edge(Graph &g, int a, int b) {\n  g[a].push_back(b);\n  g[b].push_back(a);\n}\n\nbool dfs(const Graph &g, vector<int> &vis, int i) {\n  for (int j : g[i]) {\n    if (vis[j] == -1) {\n      vis[j] = vis[i] ^ 1;\n      if (!dfs(g, vis, j)) return false;\n    } else if (vis[j] == vis[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int64_t v,e;\n  cin>>v>>e;\n  Graph g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    add_edge(g, a, b);\n  }\n  vector<int> vis(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (vis[i] == -1) {\n      vis[i] = 2 * cnt;\n      if (!dfs(g, vis, i)) {\n        ok = false;\n      }\n      ++cnt;\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> ary(cnt, 0);\n  REP(i,v) {\n    if ((vis[i] % 2) == 0) {\n      ++ary[vis[i]/2];\n    } else {\n      --ary[vis[i]/2];\n    }\n  }\n  REP(i,cnt) ary[i] = abs(ary[i]);\n  int64_t sum = 0;\n  REP(i,cnt) sum += ary[i];\n  bitset<100001> dp;\n  dp[0] = true;\n  REP(i,cnt) {\n    bitset<100001> tmp = dp;\n    tmp |= dp << ary[i];\n    swap(tmp, dp);\n  }\n  int64_t mx = 0;\n  REP(i,sum+1) {\n    if (dp[i]) {\n      int64_t k = 2*i - sum;\n      mx = max(mx, (v/2 - k) * ((v+1)/2 + k) - e);\n      mx = max(mx, ((v+1)/2 - k) * (v/2 + k) - e);\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nvector<pair<int,int>>colors;\nvector<vector<int>>edges;\npair<int,int> dfs(const int now,const int num) {\n\tconst int nextcolor = !colors[now].second;\n\tpair<int, int>nums(0,0);\n\tif (colors[now].second == 1)nums.second++;\n\telse nums.first++;\n\tfor (auto e : edges[now]) {\n\t\tif (colors[e].second == -1) {\n\t\t\tcolors[e] = make_pair(now,nextcolor);\n\t\t\tpair<int,int>p=dfs(e, num);\n\t\t\tif (!p.first&&!p.second)return p;\n\t\t\tnums.first += p.first;\n\t\t\tnums.second += p.second;\n\t\t}\n\t\telse if (colors[e].second != nextcolor)return make_pair(0, 0);\n\t}\n\treturn nums;\n}\n\nbool dp[2][100001];\nint main() {\n\tint V, E; cin >> V >> E;\n\tfor (int i = 0; i < V; ++i) {\n\t\tcolors.push_back(make_pair(-1, -1));\n\t}\n\tedges.resize(V);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint color = 0;\n\tvector<pair<int, int>>ps;\n\tbool ok = true;\n\tfor (int i = 0; i < V; ++i) {\n\t\tif (colors[i].second == -1) {\n\t\t\tcolors[i] = make_pair(color,0);\n\t\t\tpair<int,int>p=dfs(i, color);\n\t\t\tif (!p.first&&!p.second) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\tif (p.first > p.second)swap(p.first, p.second);\n\t\t\tps.push_back(p);\n\t\t\tcolor++;\n\t\t}\n\t}\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tint amin = 0;\n\t\tmap<int,int>pluss;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\tamin += ps[i].first;\n\t\t\tif (ps[i].first != ps[i].second) {\n\t\t\t\tpluss[ps[i].second - ps[i].first]++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < 100000; ++i) {\n\t\t\tif (pluss.find(i) != pluss.end()) {\n\t\t\t\tconst int bai = (pluss[i] - 1) / 2;\n\t\t\t\tif (bai) {\n\n\n\t\t\t\t\tpluss[2 * i] += bai;\n\t\t\t\t\tpluss[i] -= bai * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>naps;\n\t\tfor (int i = 1; i < 100000; ++i) {\n\t\t\tif (pluss.find(i) != pluss.end()) {\n\t\t\t\tfor (int j = 0; j < pluss[i]; ++j) {\n\t\t\t\t\tnaps.push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = true;\n\t\tfor (int i = 0; i < naps.size(); ++i) {\n\t\t\tint tar = i & 1, cur = tar ^ 1;\n\t\t\tfor (int i = 0; i < 100001; ++i) {\n\t\t\t\tdp[cur][i] = 0;\n\t\t\t}\n\t\t\tif (i == 0)assert(tar == 0 && cur == 1);\n\t\t\tfor (int j = 0; j < 100000; ++j) {\n\t\t\t\tif (dp[tar][j]) {\n\t\t\t\t\tdp[cur][j] = true;\n\t\t\t\t\tdp[cur][j + naps[i]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < 100000; ++i) {\n\t\t\tif (abs(ans+amin - V / 2)>abs(i+amin - V / 2) && dp[naps.size()%2][i]) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tcout << (amin+ans)*(V - ans-amin) - E << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\n#define int long long\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  int x=0;\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)){\n      if(a[1]) v.push_back(P(a[1],a[0]));\n      else x++;\n    }else return -1;\n  }\n  int k=0,m=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<=m;j++){\n      if(dp[f][j])\n\tdp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1,\n\t  m=max(m,j+max(v[i].first,v[i].second));\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      for(int j=0;j<=x&&i+j<V;j++){\n\t//cout<<i+j<<\":\"<<(V-(i+j))*(i+j)<<endl;\n\tif((V-k)*k<(V-(i+j))*(i+j)) k=i+j;\n      }\n    }\n  }\n  return (V-k)*k-E;\n}\nsigned main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nvector<int> G[100000];\nbool visited[100000][2],vis[100000];\nint cnt=0,a[100000],b[100000];\ntypedef vector<int> vi;\nvector<vi> group(100000);\nvoid dfs(int v,int x){\n\tvisited[v][x]=true;\n\trep(i,G[v].size()){\n\t\tif(visited[G[v][i]][1-x]) continue;\n\t\tdfs(G[v][i],1-x);\n\t}\n}\nvoid dfs2(int v){\n\tgroup[cnt].pb(v);\n\tvis[v]=true;\n\trep(i,G[v].size()){\n\t\tif(vis[G[v][i]]) continue;\n\t\tdfs2(G[v][i]);\n\t}\n}\nint cnta[100001];\nvector<int> vca,vcm;\nint dp[100001];\nint main(){\n\tint V,E;\n\tcin>>V>>E;\n\trep(i,E){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a-1].pb(b-1);\n\t\tG[b-1].pb(a-1);\n\t}\n\trep(i,V) if(!(visited[i][0]||visited[i][1])) dfs(i,0);\n\trep(i,V) if(visited[i][0]&&visited[i][1]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\trep(i,V) if(!vis[i]) dfs2(i),cnt++;\n\tint ssum=0;\n\trep(i,cnt){\n\t\trep(j,group[i].size()){\n\t\t\tif(visited[group[i][j]][0]) a[i]++;\n\t\t\telse b[i]++;\n\t\t}\n\t\tif(a[i]<b[i]) swap(a[i],b[i]);\n\t\tssum+=b[i];\n//\t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n\t}\n\trep(i,cnt) cnta[a[i]-b[i]]++;\n\trep1(i,100000) if(cnta[i]>0){\n\t\tvca.pb(i);\n\t\tvcm.pb(cnta[i]);\n\t}\n\tint n=vca.size();\n\trep(i,100001) dp[i]=-1;\n\tdp[0]=0;\n\trep(i,n){\n\t\trep(j,100001){\n\t\t\tif(dp[j]>=0){\n\t\t\t\tdp[j]=vcm[i];\n\t\t\t}else if(j<vca[i]||dp[j-vca[i]]<=0){\n\t\t\t\tdp[j]=-1;\n\t\t\t}else{\n\t\t\t\tdp[j]=dp[j-vca[i]]-1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=0;\n\trep(i,100001) if(dp[i]>=0){\n\t\tlong long si=ssum+i;\n\t\tans=max(ans,si*(V-si));\n\t}\n\tcout<<ans-E<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<deque>\n#include<map>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MN=100100;\n\nvector<int> G[MN];\nbool used[MN];\nint root[MN],dep[MN];\nint even[MN],odd[MN];\nint N;\n\nvoid dfs(int v,int p,int d,int r){\n\tused[v]=true;\n\tdep[v]=d;\n\troot[v]=r;\n\tif(d%2==0) even[r]++;\n\telse odd[r]++;\n\t\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i];\n\t\tif(u==p) continue;\n\t\tif(used[u]){\n\t\t\tif((dep[v]-dep[u])%2==0){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\texit(0);\n\t\t\t}else continue;\n\t\t}\n\t\tdfs(u,v,d+1,r);\n\t}\n}\n\nint w[MN],v[MN],num[MN];\nmap<int,int> nums;\nint K,n;\n\nint dp[MN];\n\nvoid solve(){\n\tfor(int i=0;i<K;i++){\n\t\tfor(int a=0;a<w[i];a++){\n\t\t\tdeque<int> deqi,deqv;\n\t\t\tfor(int j=0;j*w[i]+a<=n;j++){\n\t\t\t\tint val=dp[j*w[i]+a]-j*v[i];\n\t\t\t\twhile(!deqi.empty()&&deqi.back()<=val){\n\t\t\t\t\tdeqi.pop_back();\n\t\t\t\t\tdeqv.pop_back();\n\t\t\t\t}\n\t\t\t\tdeqi.push_back(j);\n\t\t\t\tdeqv.push_back(val);\n\t\t\t\tdp[j*w[i]+a]=deqv.front()+j*v[i];\n\t\t\t\tif(deqi.front()==j-num[i]){\n\t\t\t\t\tdeqi.pop_front();\n\t\t\t\t\tdeqv.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint E;\n\tscanf(\"%d%d\",&N,&E);\n\tif(E==0){\n\t\tint a=N/2;\n\t\tint b=N-a;\n\t\tlong long all=(long long)a*b;\n\t\tprintf(\"%lld\\n\",all);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;v--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tif(used[i]==false){\n\t\t\tdfs(i,-1,0,i);\n\t\t}\n\t}\n\tint S=0;\n\tfor(int i=0;i<N;i++){\n\t\tif(root[i]==i){\n\t\t\tint d=max(odd[i]-even[i],even[i]-odd[i]);\n\t\t\tif(d!=0) nums[d]++;\n\t\t\tS+=d;\n\t\t}\n\t}\n\tif(nums.size()==0){\n\t\tint n=N/2;\n\t\tlong long all=(long long)n*n;\n\t\tprintf(\"%lld\\n\",all-E);\n\t\treturn 0;\n\t}\n\tn=S/2;\n\tK=nums.size();\n\tmap<int,int>::iterator it=nums.begin();\n\tint c=0;\n\tfor(;it!=nums.end();it++){\n\t\tv[c]=it->first;\n\t\tw[c]=it->first;\n\t\tnum[c++]=it->second;\n\t}\n\tsolve();\n\tint dif=S-2*dp[n];\n\tint x=(N-dif)/2;\n\tint y=x+dif;\n\tlong long all=(long long)x*y;\n\tprintf(\"%lld\\n\",all-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint dp[N];\nint DP(){\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n\n  for(P a:A){\n    dp[0] = 1;\n    for(int j=0;j<N;j++)if(dp[j]) dp[j] = a.second+1;\n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n  for(int i=0;i<N;i++)\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector< vector<int> > Graph;\nbool dfs(Graph &g, vector<int> &color, int v, int c){\n\tcolor[v] = c;\n\tFOR(it, g[v]){\n\t\tif(color[*it] == c) return false;\n\t\tif(!color[*it] && !dfs(g, color, *it, -c)) return false;\n\t}\n\treturn true;\n}\n\nbool isBipartite(Graph &g){\n\tint n = g.size();\n\tvector<int> color(n);\n\tREP(i, n) if(!color[i] && !dfs(g, color, i, 1)) return false;\n\treturn true;\n}\n\nll n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint ans;\n\tif(!isBipartite(g)) cout << -1 << endl;\n\telse cout << n/2*((n+1)/2) - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector< vector<int> > Graph;\npii dfs(Graph &g, vector<int> &color, int v, int c){\n\tcolor[v] = c;\n\tpii res(c==1, c==-1);\n\tFOR(it, g[v]){\n\t\tif(color[*it] == c) return pii(-1, -1);\n\t\tpii ret(0, 0);\n\t\tif(!color[*it] && (ret = dfs(g, color, *it, -c)).first < 0) return pii(-1, -1);\n\t\tres.first += ret.first;\n\t\tres.second += ret.second;\n\t}\n\treturn res;\n}\n\nvector<pii> isBipartite(Graph &g){\n\tint n = g.size();\n\tvector<int> color(n);\n\tvector<pii> knap;\n\tREP(i, n){\n\t\tpii ret(0, 0);\n\t\tif(!color[i] && (ret = dfs(g, color, i, 1)).first < 0) return vector<pii>();\n\t\tif(ret.first || ret.second){\n\t\t\tknap.push_back(ret);\n\t\t}\n\t}\n\treturn knap;\n}\n\nll n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint ans;\n\tvector<pii> knap = isBipartite(g);\n\tif(knap.empty()) cout << -1 << endl;\n\telse{\n\t\tvi dp(n+1);\n\t\tdp[0] = 1;\n\t\tint sum = 0;\n\t\tREP(i, knap.size()){\n\t\t\tRREP(j, sum+1){\n\t\t\t\tdp[j+knap[i].first] |= dp[j];\n\t\t\t\tdp[j+knap[i].second] |= dp[j];\n\t\t\t}\n\t\t\tsum += max(knap[i].first, knap[i].second);\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, sum+1) if(dp[i]) ans = max(ans, (ll)(i)*(n-i));\n\t\tcout << ans - m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\nvi graph[vmax];\nint color[vmax];\nll black=0LL,white=0LL;\n\nbool dfs(int v,int c){\n\tcolor[v]=c;\n\tif(c==1) black++;\n\tif(c==-1) white++;\n\tfor(auto &v2:graph[v]){\n\t\tif(color[v2]==0&&dfs(v2,-c)==false) return false;\n\t\tif(color[v2]==color[v]) return false;\n\t}\n\treturn true;\n}\n\nll base=0LL;\nll num[100010];\nll dp[100010];\n\nll calc(ll v){\n\tclr(dp,-1);\n\tdp[0]=0LL;\n\n\trep(i,v+1){\n\t\tif(num[i]==0) continue;\n\t\trep(j,v+1){\n\t\t\tif(dp[j]>=0)\n\t\t\t\tdp[j]=num[i];\n\t\t\telse if(j<i || dp[j-i]<=0)\n\t\t\t\tdp[j]=-1;\n\t\t\telse\n\t\t\t\tdp[j]=dp[j-i]-1;\n\t\t}\n\t}\n\tll all=0LL;\n\trep(i,v+1){\n\t\tif(dp[i]>=0){\n\t\t\tll white=base+i;\n\t\t\tll black=v-white;\n\t\t\tall=max(all,white*black);\n\t\t}\n\t}\n\treturn all;\n}\n\nint main(void){\n\tll v,e;\n\tcin >> v >> e;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a-1].pb(b-1);\n\t\tgraph[b-1].pb(a-1);\n\t}\n\n\tbool ok=true;;\n\trep(i,v){\n\t\tif(color[i]!=0) continue;\n\t\tint c=1;\n\t\tif(dfs(i,c)==false) ok=false;\n\t\tbase+=min(black,white);\n\t\tnum[max(black,white)-min(black,white)]++;\n\t\tblack=0,white=0;\n\t}\n\n\tll all=calc(v);\n\tif(ok)\n\t\tcout << all-e << endl;\n\telse\n\t\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint MAX = 101010;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tvec.emplace_back(p.second - p.first);\n\t\t\tMAX = max(MAX,vec.back());\n\t\t}\n\t}\n\tvector<vector<int>> dp(vec.size() + 1,vector<int>(MAX + 1,0));\n\tdp[0][0] = 1;\n\tfor(int i = 0;i < vec.size();i++){\n\t\tfor(int j = 0;j <= MAX;j++){\n\t\t\tif(abs(j + vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j + vec[i])] |= dp[i][j];\n\t\t\t}\n\t\t\tif(abs(j - vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j - vec[i])] |= dp[i][j];\n\t\t\t}\n\n\t\t}\n\t}\n\tint dif = MAX;\n\n\tfor(int j = MAX;j >= 0;j--){\n\t\tif(dp[vec.size()][j]){\n\t\t\tdif = j;\n\t\t}\n\t}\n\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tset<long long int>dp;\n\tdp.insert( 0 );\n\tlong long int xx = 0;\n\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tsub[i] = two[i].first - two[i].second;\n\t\tauto memo = dp;\n\t\tfor( auto xxx : dp ) {\n\t\t\tif( xxx + sub[i] <= V / 2 ) {\n\t\t\t\tmemo.insert( xxx + sub[i] );\n\t\t\t\txx = max( xx, xxx + sub[i] );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp = memo;\n\t}\n\t\n\tcout << xx*( V - xx ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> G[100000];\nbool flag = false;\nint a = 0, b = 0;\nint color[100000];\n\nvoid dfs(int n, int c) {\n\tcolor[n] = c;\n\tif (c - 1) {\n\t\tb++;\n\t}\n\telse {\n\t\ta++;\n\t}\n\tfor (auto v : G[n]) {\n\t\tif (color[v] == 0) {\n\t\t\tdfs(v, 3 - c);\n\t\t}\n\t\telse if (color[v] == c) {\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll V, E;\n\tcin >> V >> E;\n\tfor (int i = 0, a, b; i < E; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tll x = 0;\n\tvector<ll> d;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (color[i] == 0) {\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tif (a != b) {\n\t\t\td.push_back(abs(a - b) * 2);\n\t\t\tx += abs(a - b);\n\t\t}\n\t\ta = b = 0;\n\t}\n\tvector<int> dp(V + 1); dp[0] = 1;\n\tfor (auto bi : d) {\n\t\tfor (int i = V - bi; i >= 0; i--) {\n\t\t\tif (dp[i]) {\n\t\t\t\tdp[i + bi] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\twhile (dp[x - res] == 0 && dp[x + res] == 0) res++;\n\tcout << (flag ? -1ll : (V + res) * (V - res) / 4 - E) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector< vector<bool> > dp(goods.size() + 1, vector<bool>(V / 2 - sum + 1, false));\n    dp[0][0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      int num = goods[i].second;\n      for(int k = 1; num > 0; k <<= 1) {\n        int s = min(num, k);\n        num -= s;\n        REP(j, dp[i].size()){\n          if(dp[i][j]){\n            dp[i + 1][j] = true;\n            int nj = j + goods[i].first * s;\n            if(nj < dp[i + 1].size()){\n              max_c = max(max_c, nj);\n              dp[i + 1][nj] = true;\n            }\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int vmax=100010;\nvi graph[vmax];\nint color[vmax];\nll black=0LL,white=0LL;\n\nbool dfs(int v,int c){\n\tcolor[v]=c;\n\tif(c==1) black++;\n\tif(c==-1) white++;\n\tfor(auto &v2:graph[v]){\n\t\tif(color[v2]==0&&dfs(v2,-c)==false) return false;\n\t\tif(color[v2]==color[v]) return false;\n\t}\n\treturn true;\n}\n\nll base=0LL;\nll num[100010];\nll dp[100010];\n\nll calc(ll v){\n\tclr(dp,-1);\n\tdp[0]=0LL;\n\n\trep(i,v+1){\n\t\tif(num[i]==0) continue;\n\t\trep(j,v+1){\n\t\t\tif(dp[j]>=0)\n\t\t\t\tdp[j]=num[i];\n\t\t\telse if(j<i || dp[j-i]<=0)\n\t\t\t\tdp[j]=-1;\n\t\t\telse\n\t\t\t\tdp[j]=dp[j-i]-1;\n\t\t}\n\t}\n\tll all=0LL;\n\trep(i,v+1){\n\t\tif(dp[i]>=0){\n\t\t\tll white=base+i;\n\t\t\tll black=v-white;\n\t\t\tall=max(all,white*black);\n\t\t}\n\t}\n\treturn all;\n}\n\nint main(void){\n\tll v,e;\n\tcin >> v >> e;\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tgraph[a-1].push_back(b-1);\n\t\tgraph[b-1].push_back(a-1);\n\t}\n\n\tbool ok=true;;\n\trep(i,v){\n\t\tif(color[i]!=0) continue;\n\t\tint c=1;\n\t\tif(dfs(i,c)==false) ok=false;\n\t\tbase+=min(black,white);\n\t\tnum[max(black,white)-min(black,white)]++;\n\t\tblack=0,white=0;\n\t}\n\n\t// ?????°??¶???????????¨????????????????§£???\n\tll all=calc(v);\n\tif(ok)\n\t\tcout << all-e << endl;\n\telse\n\t\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll v, e;\nvector<vector<ll>> g;\nvector<ll> used;\n\nbool dfs(ll p, ll col, P &cnt) {\n\tused[p] = col;\n\tif(col == 0) cnt.first++;\n\telse cnt.second++;\n\tbool ret = true;\n\tREP(i,g[p].size()) {\n\t\tif(used[g[p][i]] != -1) {\n\t\t\tif(used[g[p][i]] == col) ret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tret = ret & dfs(g[p][i], !col, cnt);\n\t}\n\treturn ret;\n}\n\nll solve() {\n\tused.assign(v, -1);\n\tbitset<100010> dp(0);\n\tdp[0] = 1;\n\tREP(i,v) {\n\t\tif(used[i] != -1) continue;\n\t\tP cnt = P(0, 0);\n\t\tif(!dfs(i, 0, cnt)) return -1;\n\t\tdp = (dp << cnt.first) | (dp << cnt.second);\n\t}\n\tll ans = 0;\n\tREP(i,100010) if(dp[i]) {\n\t\tans = max(ans, i * (v - i) - e);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> v >> e;\n\tg.resize(v);\n\tREP(i,e) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 100010\nll n,m;\nvector<ll> g[N];\nll col[N],cnt[2];\nbool dfs(ll x,ll c){\n\tif(~col[x]){\n\t\treturn c==col[x];\n\t}\n\tcol[x]=c;\n\tcnt[c]++;\n\tfor(auto y:g[x]){\n\t\tif(!dfs(y,c^1))return 0;\n\t}\n\treturn 1;\n}\nll val[N],dp[N],dq[N];\nint main(){\n\tcin>>n>>m;\n\trep(i,m){\n\t\tll a,b; cin>>a>>b;\n\t\ta--,b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\trep(i,N)val[i]=0;\n\trep(i,n)col[i]=-1;\n\tbool ok=1;\n\tll base=0;\n\trep(i,n){\n\t\tif(col[i]==-1){\n\t\t\trep(k,2)cnt[k]=0;\n\t\t\tif(!dfs(i,0))ok=0;\n\t\t\tif(cnt[0]>cnt[1])swap(cnt[0],cnt[1]);\n\t\t\tbase+=cnt[0];\n\t\t\tval[cnt[1]-cnt[0]]++;\n\t\t}\n\t}\n\trep(i,N)dp[i]=0; dp[0]=1;\n\tfor(ll d=1;d<N;d++)if(val[d]>0){\n\t\trep(i,N)dq[i]=(dp[i]>0);\n\t\trep(i,N){\n\t\t\tif(i-d>=0){\n\t\t\t\tdp[i]=dp[i-d]+dq[i];\n\t\t\t\tll id=i-d*(val[d]+1);\n\t\t\t\tif(id>=0)dp[i]-=dq[id];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[i]=dq[i];\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\trep(i,N)if(dp[i]>0){\n\t\tll x=i+base;\n\t\tchmax(ans,x*(n-x)-m);\n\t}\n\tif(ok==0)ans=-1;\n\tcout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint n,e,s[2];\nvector<int> G[N];\nint color[N];\n\nvoid dfs(int x,int c){\n  \n  color[x]=c;\n  s[c]++;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i];\n    if(color[nx]!=-1){\n      \n      if(color[x]==color[nx]){\n\tcout<<-1<<endl;\n\texit(0);\n      }\n      \n    }else dfs(nx,!c);\n\n  }\n  \n}\n\nll dp[N];\nmap<int,int> S;\n\nint main(){\n    \n  cin>>n>>e;\n \n  for(int i=0;i<e;i++){\n    \n    int a,b;\n    cin>>a>>b;\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  memset(color,-1,sizeof(color));\n\n  ll sum=0,sum2=0;\n  \n  for(int i=0;i<n;i++)\n    if(color[i]==-1){\n      s[0]=s[1]=0;\n      dfs(i,0);\n      if(s[0]>s[1]) swap(s[0],s[1]);\n      sum+=s[1];\n      S[abs(s[0]-s[1])]++;\n      sum2+=abs(s[0]-s[1]);\n    }\n\n  map<int,int>::iterator ite=S.begin();\n  \n  memset(dp,-1,sizeof(dp));\n  \n  while(ite!=S.end()){\n    \n    dp[0]=0;\n    \n    ll x=(*ite).first;\n    \n    for(int i=0;i<n;i++)\n      if(dp[i]>=0) dp[i]=(*ite).second;\n    \n    for(int i=0;i<n;i++)\n\n      if(dp[i]>0&&i+x<=n) dp[i+x]=max(dp[i+x],dp[i]-1);\n\n    ite++;\n  }\n  \n  ll ans=0;\n  \n  for(ll i=0;i<=n;i++)\n    if(dp[i]>=0) ans=max(ans,(sum-i)*(sum-(sum2-i)));\n  \n  cout<<ans-e<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tset<long long int>dp;\n\tdp.insert( 0 );\n\tlong long int xx = 0;\n\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tsub[i] = abs( two[i].first - two[i].second );\n\t}\n\tif( sub.size() % 2 ) {\n\t\tsub.push_back( 0 );\n\t}\n\tsort( sub.rbegin(), sub.rend() );\n\n\tfor( size_t i = 0; i + 1 < two.size(); i += 2 ) {\n\t\tif( xx >= 0 ) {\n\t\t\txx -= sub[i] - sub[i+1];\n\t\t} else {\n\t\t\txx += sub[i] - sub[i+1];\n\t\t}\n\t}\n\n\tcout << ( V - xx ) / 2 * ( ( V - xx ) / 2 + xx ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int64_t i=(k);i<(int64_t)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nvoid add_edge(Graph &g, int a, int b) {\n  g[a].push_back(b);\n  g[b].push_back(a);\n}\n\nbool dfs(const Graph &g, vector<int> &vis, int i) {\n  for (int j : g[i]) {\n    if (vis[j] == -1) {\n      vis[j] = vis[i] ^ 1;\n      if (!dfs(g, vis, j)) return false;\n    } else if (vis[j] == vis[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int64_t v,e;\n  cin>>v>>e;\n  Graph g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    add_edge(g, a, b);\n  }\n  vector<int> vis(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (vis[i] == -1) {\n      vis[i] = 2 * cnt;\n      if (!dfs(g, vis, i)) {\n        ok = false;\n      }\n      ++cnt;\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> ary(cnt, 0);\n  REP(i,v) {\n    if ((vis[i] % 2) == 0) {\n      ++ary[vis[i]/2];\n    } else {\n      --ary[vis[i]/2];\n    }\n  }\n  REP(i,cnt) ary[i] = abs(ary[i]);\n  int64_t sum = 0;\n  REP(i,cnt) sum += ary[i];\n  bitset<100001> dp;\n  dp[0] = true;\n  REP(i,cnt) {\n    bitset<100001> tmp = dp;\n    tmp |= dp << ary[i];\n    swap(tmp, dp);\n  }\n  int64_t mx = 0;\n  REP(i,sum+1) {\n    if (dp[i]) {\n      int64_t k = 2*i - sum;\n      mx = max(mx, (v - k)/2 * (v + k)/2 - e);\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 100000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint v, ee;\nvector<int> e[100000];\nint val[100000];\nbool dp[2][100001];\n\nP dfs(int x, int now){\n    P ret = P(0,0);\n    val[x] = now;\n    if(now) ret.second++;\n    else ret.first++;\n    rep(i,e[x].size()){\n        if(val[e[x][i]] != 2 && val[e[x][i]] != (now^1)){\n            return P(-1,-1);\n        }\n        if(val[e[x][i]] != 2) continue;\n        P tmp = dfs(e[x][i],now^1);\n        if(tmp.first == -1) return P(-1,-1);\n        ret.first += tmp.first;\n        ret.second += tmp.second;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> v >> ee;\n    rep(i,v) val[i] = 2;\n    uf.init(v);\n    int ho = 0, ge = 1;\n    dp[ho][0] = true;\n    rep(i,ee){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n        uf.unite(a,b);\n    }\n    rep(i,v){\n        if(uf.find(i) != i) continue;\n        P d = dfs(i,0);\n        if(d.first == -1){\n            cout << -1 << endl;\n            return 0;\n        }\n        if(d.first > d.second) swap(d.first,d.second);\n        //cout << d.first << \" \" << d.second << endl;\n        memset(dp[ge],0,sizeof(dp[ge]));\n        for(int j = v; j >= 0; j--){\n            if(j >= d.first) dp[ge][j] |= dp[ho][j-d.first];\n            else break;\n            if(j >= d.second) dp[ge][j] |= dp[ho][j-d.second];\n        }\n        swap(ho,ge);\n    }\n    ll ans = 0;\n    for(ll i = 0; i <= v; i++){\n        if(dp[ho][i]) ans = max(ans,i*(v-i));\n    }\n    cout << ans-ee << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\nbool dfs_coloring(int v, int c, vector<int> &num_c, vector<int> &color, vector<vector<int>> &g){\n    if(color[v] != -1) return color[v]==c;\n    color[v] = c;\n    num_c[c]++;\n    for(int next: g[v]){\n        bool ret = dfs_coloring(next, 1-c, num_c, color, g);\n        if(!ret) return false;\n    }\n    return true;\n}\nvector<vector<int>> bipertite_color_count(vector<vector<int>> &g){\n    int n = g.size();\n    vector<int> color(n, -1);\n    vector<vector<int>> res;\n    for(int i=0; i<n; i++){\n        if(color[i] != -1) continue;\n        vector<int> num_color{0, 0};\n        bool ret = dfs_coloring(i, 0, num_color, color, g);\n        if(!ret) return {};\n        res.push_back(num_color);\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for(int i=0; i<m; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    auto ret = bipertite_color_count(adj);\n    if(ret.empty()){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    map<int, int> w_pre;\n    int base = 0;\n    for(auto v: ret){\n        if(v[0] != v[1]){\n            w_pre[abs(v[0]-v[1])]++;\n        }\n        base += min(v[0], v[1]);\n    }\n    int ulim = n-2*base;\n    vector<int> w;\n    for(auto p: w_pre){\n        int num = 1;\n        while(p.second >= num){\n            w.push_back(p.first * num);\n            p.second -= num;\n            num *= 2;\n        }\n        if(p.second > 0){\n            w.push_back(p.first * p.second);\n        }\n    } \n    vector<bool> dp(ulim+1, false);\n    dp[0] = true;\n    for(int t: w){\n        for(int i=ulim; i>=0; i--){\n            if(dp[i] and i+t <= ulim){\n                dp[i+t] = true;\n            }\n        }\n    }\n    lli ans = 0;\n    for(int i=0; i<=ulim; i++){\n        if(!dp[i]) continue;\n        ans = max(ans, 1LL*(base+i)*(base+ulim-i)-m);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e18\n\nbool dfs(int now, const vector<vector<long long int> >& adj,\n         vector<long long int>& history, long long int& a, long long int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  long long int input_a, input_b;\n  vector<vector<long long int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  long long int a_sum = 0, b_sum = 0;\n  vector<long long int> c_tmp;\n  vector<long long int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      long long int a = 0;\n      long long int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<long long int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<long long int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<long long int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<long long int> > dp(n, vector<long long int>(v + 1, -INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i].first ? dp[i][j - c[i].first] - 1 : (int)INF * (-1));\n\n  int minpoint = -1;\n  long long int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      long long int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  long long int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] > CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[(Bipartite[CitySet[i][0]] + 1) % 2]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += CityType2[(Bipartite[CitySet[i][j]] + 1) % 2];\n\n\t\t\tCityType[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\nint c(int k){\n\tpriority_queue<int> que;\n\tque.push(k);\n\tfor(int a : vec){\n\t\tque.push(a);\n\t}\n\twhile(que.size() >= 2){\n\t\tint t1 = que.top();\n\t\tque.pop();\n\t\tint t2 = que.top();\n\t\tque.pop();\n\t\tque.push(t1 - t2);\n\t}\n\treturn que.top();\n}\n\nint binary(){\n\tfor(int i = 0;i <= v;i++){\n\t\tif(c(i) == 0){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint MAX = 0;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tvec.emplace_back(p.second - p.first);\n\t\t\tMAX += vec.back();\n\t\t}\n\t}\n\n\n\tint dif = binary();\n\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 50000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint v, ee;\nvector<P> vec;\nvector<int> e[100000];\nint val[100000];\nbool dp[100001];\n\nP dfs(int x, int now){\n    P ret = P(0,0);\n    val[x] = now;\n    if(now) ret.second++;\n    else ret.first++;\n    rep(i,e[x].size()){\n        if(val[e[x][i]] != 2 && val[e[x][i]] != (now^1)){\n            return P(-1,-1);\n        }\n        if(val[e[x][i]] != 2) continue;\n        P tmp = dfs(e[x][i],now^1);\n        if(tmp.first == -1) return P(-1,-1);\n        ret.first += tmp.first;\n        ret.second += tmp.second;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> v >> ee;\n    rep(i,v) val[i] = 2;\n    dp[0] = true;\n    uf.init(v);\n    rep(i,ee){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n        uf.unite(a,b);\n    }\n    rep(i,v){\n        if(uf.find(i) != i) continue;\n        P d = dfs(i,0);\n        if(d.first == -1){\n            cout << -1 << endl;\n            return 0;\n        }\n        if(d.first > d.second) swap(d.first,d.second);\n        //cout << d.first << \" \" << d.second << endl;\n        for(int j = v; j >= 0; j--){\n            if(j >= d.first) dp[j] |= dp[j-d.first];\n            else break;\n            if(j >= d.second) dp[j] |= dp[j-d.second];\n        }\n    }\n    ll ans = 0;\n    for(ll i = 0; i <= v; i++){\n        if(dp[i]) ans = max(ans,i*(v-i));\n    }\n    cout << ans-ee << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\nconst long double epsA=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tllint n,e,i;cin>>n>>e;\n\tvector<vector<int>>go(n);\n\tfor(i=0;i<e;i++){\n\t\t\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tgo[a].pub(b);go[b].pub(a);\n\t\t\n\t}\n\t\n\tvector<int>pa(n,-1);\n\tqueue<int>que;\n\tint base=0;\n\tstatic int kaz[100001]={0};\n\tfor(i=0;i<n;i++){\n\t\t\n\t\tif(pa[i]!=-1){continue;}\n\t\t\n\t\tpa[i]=0;que.push(i);\n\t\tint g=0,k=0;\n\t\twhile(que.size()){\n\t\t\tint t=que.front();que.pop();\n\t\t\tint z=pa[t];\n\t\t\tif(z){g++;}\n\t\t\telse{k++;}\n\t\t\tfor(auto it:go[t]){\n\t\t\t\t//cerr<<it<<endl;\n\t\t\t\tif(pa[it]==-1){que.push(it);pa[it]=1-z;}\n\t\t\t\tif(pa[it]==z){cout<<-1<<endl;return 0;}\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"g=\"<<g<<\"k=\"<<k<<endl;\n\t\tbase+=min(g,k);\n\t\tkaz[abs(g-k)]++;//偏り\n\t}\n\tbitset<100001>bits;bits[base]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(kaz[i]==0){continue;}\n\t\tif(kaz[i]>2){\n\t\t\tint t=(kaz[i]-2)/2;\n\t\t\tkaz[i]-=t*2;kaz[i+i]+=t;\n\t\t}\n\t\tif(kaz[i]>0){bits|=(bits<<i);}\n\t\tif(kaz[i]>1){bits|=(bits<<i);}\n\t}\n\tllint ans=0;\n\tfor(i=0;i<=n;i++){\n\t\tif(bits[i]){maxeq(ans,i*(n-i));}\n\t}\n\tcout<<ans-e<<endl;\n\t//gの合計をできるだけn/2-baseに近づける\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 100010;\nvector<int> G[MAX_V];\nint odd, even;\nvector<P> d;\n// 2部グラフ判定\nstruct BipartiteGraph{\n    int n;    \n    vector<int> color;\n    BipartiteGraph(int _n){\n        n = _n;\n        color.resize(n, 0);\n    }\n    bool dfs(int v, int c){\n        color[v] = c;\n        if(c == 1) odd++;\n        else even++;\n        bool res = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(color[G[v][i]] == c) res &= false;\n            if(color[G[v][i]] == 0) res &= dfs(G[v][i], -c);\n        }\n        return res;\n    }\n    bool isBipartiteGraph(){\n        bool res = true;\n        for(int i = 0; i < n; i++){\n            if(color[i] == 0){\n                odd = 0; even = 0;\n                res &= dfs(i, 1);\n                d.push_back({odd, even});\n            }\n        }\n        return res;\n    }\n};\n\nbitset<MAX_V> dp, nxt;\n\nsigned main(){\n    long long n, m;\n    cin >> n >> m;\n    for(int i = 0; i < m; i++){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        G[s].push_back(t);\n        G[t].push_back(s);\n    }\n    BipartiteGraph bg(n);\n    bool f = bg.isBipartiteGraph();\n    if(!f){\n        cout << -1 << endl;\n        return 0;\n    }\n    dp[0] = true;\n    rep(i, 0, d.size()){\n        nxt.reset();\n        nxt = dp << d[i].first;\n        nxt |= dp << d[i].second;\n        dp = nxt;\n    }\n    int ans = 0;\n    rep(i, 0, n + 1){\n        if(dp[i]){\n            int tmp = i * (n - i);\n            ans = max(ans, tmp - m);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool dfs(const vvi& g,int u,int c,vi& color,int& x,int& y)\n{\n\tif(color[u]!=-1)\n\t\treturn color[u]==c;\n\tcolor[u]=c;\n\t(c==0?x:y)++;\n\tfor(int v:g[u])\n\t\tif(!dfs(g,v,!c,color,x,y))\n\t\t\treturn false;\n\treturn true;\n}\n\nll solve(const vvi& g)\n{\n\tint n=g.size();\n\t\n\tvector<pii> ps;\n\t{\n\t\tvi color(n,-1);\n\t\trep(i,n) if(color[i]==-1){\n\t\t\tint x=0,y=0;\n\t\t\tif(!dfs(g,i,0,color,x,y))\n\t\t\t\treturn -1;\n\t\t\tps.emplace_back(x,y);\n\t\t}\n\t}\n\t\n\tbitset<100001> b;\n\tb[0]=1;\n\tfor(pii p:ps)\n\t\tb=(b<<p.first)|(b<<p.second);\n\t\n\tll mx=0;\n\trep(i,b.size()) if(b[i])\n\t\tmx=max(mx,ll(i)*(n-i));\n\t\n\tint e=0;\n\trep(i,n) e+=g[i].size();\n\t\n\treturn mx-e/2;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvvi g(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tcout<<solve(g)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tmap<int, int> mp;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 0);\n\t\tadd_edge(g, b, a, 0);\n\t}\n\tvi color(n, -1);\n\tREP(i, n)\n\t{\n\t\tif (color[i] >= 0) continue;\n\t\tint b = 1, w = 0;\n\t\tcolor[i] = 0;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (color[nx] >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (color[nx] == color[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\tcolor[nx] = 1 - color[t];\n\t\t\t\tif (color[nx]) w++;\n\t\t\t\telse b++;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\tmp[abs(b - w)]++;\n\t}\n\tvi v;\n\tint sum = 0;\n\tfor (auto i : mp)\n\t{\n\t\tsum += i.first*i.second;\n\t\tint t = 1;\n\t\tint cnt = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (cnt + t <= i.second)\n\t\t\t{\n\t\t\t\tcnt += t;\n\t\t\t\tv.push_back(i.first*t);\n\t\t\t\tt *= 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv.push_back(i.first*(i.second - cnt));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> dp(n + 1, false);\n\tdp[0] = true;\n\tREP(i, v.size())\n\t{\n\t\tfor (int j = n; j >= 0; j--)\n\t\t{\n\t\t\tif (j - v[i] < 0) break;\n\t\t\tif (!dp[j - v[i]]) continue;\n\t\t\tdp[j] = true;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, dp.size())\n\t{\n\t\tif (dp[i])\n\t\t{\n\t\t\tll dif = abs(i - (sum - i));\n\t\t\tll tmp = (n + dif) / 2 * (n - dif) / 2 - m;\n\t\t\tchmax(ans, tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint V,E;\nvi g[100010];\nll size;\nmap<int,int> M;\nint dp[100010];\n\nint color[100010];\n\npi dfs(int v,int c){\n\tpi res;\n\tif(c==1)res.fir=1;\n\telse res.sec=1;\n\tcolor[v]=c;\n\trep(i,sz(g[v])){\n\t\tif(color[g[v][i]]==c)return mp(-1,-1);\n\t\tif(!color[g[v][i]]){\n\t\t\tpi res2=dfs(g[v][i],-c);\n\t\t\tif(res2.fir==-1)return mp(-1,-1);\n\t\t\tres.fir+=res2.fir;\n\t\t\tres.sec+=res2.sec;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>V>>E;\n\trep(i,E){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\trep(i,V)if(!color[i]){\n\t\tpi res=dfs(i,1);\n\t\tif(res.fir==-1){\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(res.fir>res.sec)swap(res.fir,res.sec);\n\t\tsize+=res.fir;\n\t\tM[res.sec-res.fir]++;\n\t}\n\tint m=V/2-size;\n\tfill(dp,dp+m+1,-1);\n\tdp[0]=0;\n\tforeach(it,M){\n\t\trep(i,m+1){\n\t\t\tif(dp[i]>=0){\n\t\t\t\tdp[i]=it->sec;\n\t\t\t}else if(i < it->fir || dp[i - it->fir] <= 0){\n\t\t\t\tdp[i]=-1;\n\t\t\t}else{\n\t\t\t\tdp[i]=dp[i - it->fir]-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=m;i>=0;i--)if(dp[i]>=0){\n\t\tsize+=i;\n\t\tcout<<size*(V-size)-E<<endl;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nvector<int> unify_ones(const vector<int> &a){\n\tvector<int> res;\n\tint one=0;\n\trep(i,a.size()){\n\t\tif(a[i]==1) one++;\n\t\telse        res.push_back(a[i]);\n\t}\n\n\tint two=1;\n\twhile(one>0){\n\t\tres.push_back(min(two,one));\n\t\tone-=min(two,one);\n\t\ttwo<<=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\n\t// add[i]==1 がたくさんあると部分和問題を解くのに時間がかかりすぎるので, 適当にまとめる ( 個数制約があるナップザックと同じ tips )\n\tadd=unify_ones(add);\n\tsort(add.begin(),add.end());\n\n\t// knapsack DP\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tint ub=0;\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=min(ub,n/2-L_sum-add[i]);j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t\tub=max(ub,j+add[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",(ll)N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 10;\n// const int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[B][N][2];\nint dp2[B][N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0][0] = 0;\n    for(int i=1; i<B; ++i){\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[i-1][j][0]>=0){\n            pq.push({C,{j,C%2}});\n            dp[i][j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int nx = abs(p.fi+j*i);\n\n                if(dp[i][nx][!p.se] < dp[i][p.fi][p.se]-1){\n                    dp[i][nx][!p.se] = dp[i][p.fi][p.se]-1;\n                    pq.push({dp[i][nx][!p.se], {nx,!p.se}});\n                }\n            }\n        }\n    }\n    rep(i,N)if(dp[B-1][i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0][0] = 1;\n    que.push({0,0});\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        int idx = now.fi;\n        int val = now.se;\n        if(idx == L) continue;\n\n        for(int i=-1; i<=1; i+=2){\n            int nx = abs(val+i*l[idx]);\n            if(!dp2[idx+1][nx]){\n                dp2[idx+1][nx] = 1;\n                que.push({idx+1, nx});\n            }\n        }\n    }\n    rep(i,N)if(dp2[L][i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int j=-1; j<=1; ++j){\n            int nx = idx + j;\n            if(0<=nx && nx<sz){\n                int dd = abs(i-Sd[nx]);\n                if(n-dd>0){\n                    assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nvector<int> unify_ones(const vector<int> &a){\n\tvector<int> res;\n\tint one=0;\n\trep(i,a.size()){\n\t\tif(a[i]==1) one++;\n\t\telse        res.push_back(a[i]);\n\t}\n\n\tint two=1;\n\twhile(one>0){\n\t\tres.push_back(min(two,one));\n\t\tone-=min(two,one);\n\t\ttwo<<=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\n\t// add[i]==1 がたくさんあると部分和問題を解くのに時間がかかりすぎるので, 適当にまとめる ( 個数制約があるナップザックと同じ tips )\n\tadd=unify_ones(add);\n\tsort(add.begin(),add.end(),greater<int>());\n\n\t// knapsack DP\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=n/2-L_sum-add[i];j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\",N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col, a, b;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tint P = a.size(), lft = 0, rgt = 0;\n\t\n\tfor_(i,0,P) {\n\t\tlft += a[i];\n\t\trgt += b[i];\n\t}\n\t\n\twhile (1) {\n\t\tbool update = false;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tint cur_abs = abs(lft - rgt);\n\t\t\t\n\t\t\tint nlft = lft - a[i] + b[i];\n\t\t\tint nrgt = rgt - b[i] + a[i];\n\t\t\t\n\t\t\tint nxt_abs = abs(nlft - nrgt);\n\t\t\t\n\t\t\tif (cur_abs > nxt_abs) {\n\t\t\t\tcur_abs = nxt_abs;\n\t\t\t\tupdate = true;\n\t\t\t\tswap(a[i], b[i]);\n\t\t\t\tlft = nlft;\n\t\t\t\trgt = nrgt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!update) break;\n\t}\n\t\t\n\treturn (lint)lft * (lint)rgt;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\ta.push_back(g[0].size());\n\t\tb.push_back(g[1].size());\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint MAX = 0;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tvec.emplace_back(p.second - p.first);\n\t\t\tMAX = max(MAX,vec.back());\n\t\t}\n\t}\n\tvector<vector<int>> dp(vec.size() + 1,vector<int>(MAX + 1,0));\n\tdp[0][0] = 1;\n\tfor(int i = 0;i < vec.size();i++){\n\t\tfor(int j = 0;j <= MAX;j++){\n\t\t\tif(abs(j + vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j + vec[i])] |= dp[i][j];\n\t\t\t}\n\t\t\tif(abs(j - vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j - vec[i])] |= dp[i][j];\n\t\t\t}\n\n\t\t}\n\t}\n\tint dif = MAX;\n\n\tfor(int j = MAX;j >= 0;j--){\n\t\tif(dp[vec.size()][j]){\n\t\t\tdif = j;\n\t\t}\n\t}\n\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[N][2], nx[N][2];\nint dp2[N], nx2[N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0] = 0;\n    for(int i=1; i<B; ++i){\n        memset(nx,-1,sizeof(nx));\n\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[j][0]>=0){\n            pq.push({C,{j,C%2}});\n            nx[j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int idx = abs(p.fi+j*i);\n\n                if(nx[idx][!p.se] < now.fi-1){\n                    nx[idx][!p.se] = now.fi-1;\n                    pq.push({nx[idx][!p.se], {idx,!p.se}});\n                }\n            }\n        }\n\n        rep(j,N)rep(k,2) dp[j][k] = nx[j][k];\n    }\n    rep(i,N)if(dp[i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0] = 1;\n    rep(i,L){\n        memset(nx2,0,sizeof(nx2));\n        rep(j,N)if(dp2[j]){\n            for(int k=-1; k<=1; k+=2){\n                int idx = abs(j+k*Ld[i]);\n                if(idx<N) nx2[idx] = 1;\n            }\n        }\n\n        rep(j,N) dp2[j] = nx2[j];\n    }\n    rep(i,N)if(dp2[i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int a=-1; a<=1; ++a){\n            int j = idx + a;\n            if(0<=j && j<sz){\n                int dd = abs(i-Sd[j]);\n                if(n-dd>0){\n                    assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\ntypedef pair<int, int> P;\nP dfs(int u, int c, Graph& G, vector<int>& color){\n  P res;\n  if(color[u] != -1){\n    if(color[u] == c) return P(0, 0);\n    else return P(INF, INF);\n  }else{\n    color[u] = c;\n    if(c == 0) res.first ++;\n    else res.second ++;\n  }\n  REP(i, G[u].size()){\n    int v = G[u][i];\n    P p = dfs(v, c ^ 1, G, color);\n    if(p.first >= INF) return P(INF, INF);\n    res = P(res.first + p.first, res.second + p.second);\n  }\n  return res;\n}\n\nint main(){\n  int V, E;\n  while(cin >> V >> E && V){\n    Graph G(V);\n    REP(i, E){\n      int a, b;\n      scanf(\"%d %d\", &a, &b);\n      a--; b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    vector<int> color(V, -1);\n    vector<P> ps;\n    int ans = 0;\n    REP(i, V) if(color[i] == -1){\n      P p = dfs(i, 0, G, color);\n      if(p.first >= INF) ans = -1;\n      ps.push_back(p);\n    }\n    if(ans == -1){\n      cout << ans << endl;\n      continue;\n    }\n    map<int, int> cnt;\n    int sum = 0;\n    REP(i, ps.size()){\n      int a = min(ps[i].first, ps[i].second);\n      int b = max(ps[i].first, ps[i].second);\n      sum += a;\n      if(b - a > 0) cnt[b - a]++;\n    }\n    vector<P> goods;\n    FORIT(it, cnt) goods.push_back(P(it->first, it->second));\n    vector<bool> dp(V / 2 - sum + 1, false);\n    dp[0] = true;\n    int max_c = 0;\n    REP(i, goods.size()){\n      int num = goods[i].second;\n      for(int k = 1; num > 0; k <<= 1) {\n        int s = min(num, k);\n        num -= s;\n        REP(j, dp.size())if(dp[j]){\n          int nj = j + goods[i].first * s;\n          if(nj < dp.size()){\n            max_c = max(max_c, nj);\n            dp[nj] = true;\n          }\n        }\n      }\n    }\n    max_c += sum;\n    cout << (ll)max_c * (V - max_c) - E << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\nusing ll = long long;\n\n\nstruct Graph {\n    Graph(const int n) : edge(n) {}\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n};\n\nusing P = pair<int, int>;\nP dfs(const Graph& g, const int s, vector<int>& color, bool black = true)\n{\n    int b = 1;\n    int w = 0;\n    color[s] = (int)(black);\n    for (const int to : g.edge[s]) {\n        if (color[to] != -1) {\n            if (black == color[to]) {\n                return make_pair(-1, -1);\n            }\n            continue;\n        }\n        int sb, sw;\n        tie(sw, sb) = dfs(g, to, color, not black);\n        if (sw == -1) {\n            return make_pair(-1, -1);\n        }\n        w += sw;\n        b += sb;\n    }\n    return make_pair(b, w);\n}\n\nint main()\n{\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n    for (int i = 0; i < E; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.addEdge(a, b);\n    }\n    vector<int> div;\n    vector<int> color(V, -1);\n    for (int i = 0; i < V; i++) {\n        if (color[i] != -1) {\n            continue;\n        }\n        const auto p = dfs(g, i, color);\n        if (p.first == -1) {\n            cout << -1 << endl;\n            return 0;\n        }\n        div.push_back(abs(p.first - p.second));\n    }\n\n    sort(div.begin(), div.end());\n    auto a = div;\n    a.erase(unique(a.begin(), a.end()), a.end());\n    vector<int> num(a.size());\n    int pos = 0;\n    for (int i = 0; i < a.size(); i++) {\n        int n = 0;\n        for (; pos < div.size(); pos++) {\n            if (div[pos] == a[i]) {\n                n++;\n            } else {\n                break;\n            }\n        }\n        num[i] = n;\n    }\n    const int half = accumulate(div.begin(), div.end(), 0) / 2;\n    vector<int> dp(half + 1, -1);\n    const int size = a.size();\n    dp[0] = 0;\n    for (int i = 0; i < size; i++) {\n        vector<int> copy = dp;\n        for (int j = 0; j <= half; j++) {\n            if (copy[j] != -1) {\n                dp[j] = num[j];\n            } else if (j < a[i] or copy[j - a[i]] <= 0) {\n                dp[j] = -1;\n            } else {\n                dp[j] = dp[j - a[i]] - 1;\n            }\n        }\n        dp = copy;\n    }\n    for (int i = half; i >= 0; i--) {\n        if (dp[i] > -1) {\n            cout << (ll)((V - i) / 2) * (ll)((V + i) / 2) - E << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,int c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n\n  vertex.resize(n,-1);\n  vector<int> dis;\n  for(int i=0;i<chunk.size();i++){\n\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    dis.push_back(abs(cnt1-(chunk[i].size()-cnt1)));\n  }\n  int n2=1;\n  while(n2<n) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  int sum=accumulate(dis.begin(),dis.end(),0);\n  int dist=*now[0].lower_bound(sum/2);\n  long long int b=(n+dist)/2;\n  long long int a=(n-dist)/2;\n  cout<<a*b-e<<endl;\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <utility>\nusing namespace std;\n\npair<int,int> dfs(vector< vector<int> > &G, int v, int c, vector<int> &visited){\n  pair<int,int> ret = make_pair(1, 0);\n  for(int i = 0; i < G[v].size(); ++i){\n    int u = G[v][i];\n    if(visited[u] == c) continue;\n    if(visited[u] == 1-c) return make_pair(-1,-1);\n    visited[u] = c;\n    pair<int,int> p = dfs(G, u, 1 - c, visited);\n    if(p == make_pair(-1,-1)) return p;\n    ret.first += p.second;\n    ret.second += p.first;\n  }\n  return ret;\n}\n\nint main(){\n  int V, E;\n  cin >> V >> E;\n  vector< vector<int> > G(V);\n  for(int i = 0; i < E; ++i){\n    int a, b;\n    cin >> a >> b;\n    --a,--b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  vector<int> visited(V, -1);\n  bitset<100001> dp = 1;\n  for(int i = 0; i < V; ++i){\n    if(visited[i] >= 0) continue;\n    visited[i] = 1;\n    pair<int,int> p = dfs(G, i, 0, visited);\n    if(p == make_pair(-1, -1)){\n      cout << -1 << endl;\n      return 0;\n    }\n    dp = (dp << p.first)|(dp << p.second);\n  }\n  long long int ans = 0;\n  for(int i = 0; i <= V/2; ++i){\n    if(dp[i]) ans = max(ans, (long long int)i*(V-i) - E);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nP dfs(int v,int b,vi& used){\n\tused[v]=b;\n\tP p;\n\tif(b) p.first++;\n\telse p.second++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(used[u]==-1){\n\t\t\tP q=dfs(u,!b,used);\n\t\t\tp.first+=q.first;\n\t\t\tp.second+=q.second;\n\t\t}\n\t\tif(used[u]==b) return {-inf,0};\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvi used(n,-1);\n\tint tmp=0;\n\tmap<int,int> M;\n\tfor(int i=0;i<n;i++) if(used[i]==-1){\n\t\tP p=dfs(i,1,used);\n\t\tint A=p.first,B=p.second;\n\t\tif(A<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp+=min(A,B);\n\t\tM[abs(A-B)]++;\n\t}\n\tvi dp(n+1);\n\tdp[tmp]=1;\n\tfor(auto i=M.begin();i!=M.end();i++){\n\t\tint v=i->first,N=i->second;\n\t\tvi DP(n+1,-1);\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(dp[j]) DP[j]=0;\n\t\t\telse if(j>=v&&dp[j-v]!=-1&&dp[j-v]<N){\n\t\t\t\tDP[j]=dp[j-v]+1;\n\t\t\t\tdp[j]|=1;\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<=n;i++) res=max(res,(ll)dp[i]*i*(n-i));\n\tcout<<res-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2370\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<long,long> plong;\ntypedef vector<int> vint;\ntypedef vector<long> vlong;\n\nconst double pi=M_PI;\nconst int INF10 = 1000000001;\nconst ll INF15 = 1e15 +1;\nconst long long INF18 = 1e18 + 1;\nconst int mod = 1000000007;\n//const int mod = 998244353;\nconst double EPS=0.00001;\n\n#define rep(i, n) for (int i = 0; i < (ll)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (ll)(n); i++)\n#define rep2(i,start,end) for(int i=(ll)start;i<=(ll)end;i++)\n#define vrep(i, n) for(int i=(ll)n-1;i>=0;i--)\n#define vrep1(i, n) for(int i=(ll)n;i>0;i--)\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define debug(x) cerr << #x <<\": \" << x << '\\n'\n\nstruct edge{\n    edge(int i,long c=1){\n        to=i;\n        cost=c;\n    }\n    int to;\n    long cost;\n};\n\n//bを何回足せばaを超えるか(O(a/b))\n//a+b-1/bとすればよし\n\n//2進数表示したときの最高桁(O(log n))\nint bi_max(long n){\n    int m = 0;\n    for (m; (1 << m) <= n; m++);\n    m = m - 1;\n    return m;\n}\n//bi_eに二進数表示したやつを代入(O(log^2 n))\n//bitset<N> a(n)でnの二進数表示が得られて、a[i]=0or1でi番目のfragが立ってるかわかる\n//x^n mod m (nが負の時は０)(O(log n))\nlong myPow(long x, long n, long m=mod){\n    if (n < 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint{\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint &operator+=(const mint a)\n    {\n        if ((x += a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator-=(const mint a)\n    {\n        if ((x += mod - a.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n    mint &operator*=(const mint a)\n    {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const { return mint(*this) += a; }\n    mint operator-(const mint a) const { return mint(*this) -= a; }\n    mint operator*(const mint a) const { return mint(*this) *= a; }\n    mint pow(ll t) const\n    {\n        if (!t)\n            return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1)\n            a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const { return pow(mod - 2); }\n    mint &operator/=(const mint a) { return *this *= a.inv(); }\n    mint operator/(const mint a) const { return mint(*this) /= a; }\n    bool operator!=(const int a) { return this->x!=a; }\n     bool operator==(const int a) { return this->x==a; }\n};\nistream &operator>>(istream &is, const mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination{\n    vector<mint> fact, ifact;\n    combination(int n) : fact(n + 1), ifact(n + 1)\n    {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i)\n            ifact[i - 1] = ifact[i] * i;\n    }\n    mint operator()(int n, int k)\n    {\n        if (k < 0 || k > n)\n            return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\ntemplate<class T>\nvoid maxin (T &a,T b){a=max(a,b);}\ntemplate<class T>\nvoid minin (T &a,T b){a=min(a,b);}\ntemplate<class M,class N> \nconstexpr common_type_t<M,N> gcd(M a,N b){\n    a=abs(a);b=abs(b);\n    if(a < b) return gcd(b, a);\n    M r;\n    while ((r=a%b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\ntemplate<class M,class N>\nconstexpr common_type_t<M,N> lcm(M a,N b){\n    return a*b/gcd(a,b);\n}\n\nconst int N_MAX=100005;\nll n,m,col[N_MAX];\nvector<int> v[N_MAX];\nint dp[N_MAX],nd[N_MAX];\n\nll solve(){\n    ll ano=0;\n    vector<pair<ll,ll>> res;\n    rep(i,n){\n        if(col[i]!=0)continue;\n        if(v[i].size()==0){\n            ano++;\n            continue;\n        }\n        ll blo=0,whi=0;\n        queue<int> que;\n        que.push(i);\n        col[i]=1;\n        while(que.size()){\n            int now=que.front();que.pop();\n            col[now]==1?blo++:whi++;\n            for(auto w:v[now]){\n                if(col[w]==0){\n                    col[w]=-col[now];\n                    que.push(w);\n                }else if(col[w]==col[now])return -1;\n            }\n        }\n        res.pb({max(blo,whi),min(blo,whi)});\n    }\n    ll blo=0,whi=0;\n    bitset<N_MAX> a,b;a[0]=1;\n    for(auto w:res){\n        rep(i,(1+(n+1)/2)-w.first){\n            if(a[i])b[i+w.first]=1;\n        }\n        rep(i,(1+(n+1)/2)-w.second){\n            if(a[i])b[i+w.second]=1;\n        }\n        rep(i,(1+(n+1)/2)){\n            a[i]=b[i];\n        }\n        b.reset();\n    }\n    vrep(i,1+(n+1)/2){\n        if(a[i]){\n            blo=i;\n            break;\n        }\n    }\n    whi=n-blo-ano;\n    /*debug(blo);\n    debug(whi);\n    debug(ano);*/\n    if((n+1)/2<max(blo,whi)){\n        blo>whi?whi+=ano:blo+=ano;\n        return whi*blo-m;\n    }else{\n        return ((n+1)/2)*(n-((n+1)/2))-m;\n    }\n}\n\nint main(){\n    int x,y;\n    //入力\n    cin>>n>>m;\n    rep(i,m){\n        cin>>x>>y;\n        v[x-1].pb(y-1);\n        v[y-1].pb(x-1);\n    }\n    //処理\n    auto ans=solve();\n    //出力\n    cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V,E;\nvector<int> G[100005];\nvector<int> A,B;\nbool flg=false;\nbool visited[100005];\nint depth[100005];\nint cnt[2];\n\nvoid dfs(int pos,int d){\n  \n  if(visited[pos]){\n    if(depth[pos]!=d)flg=true;\n    return;\n  }\n  \n  visited[pos]=true;\n  depth[pos]=d;\n  cnt[d]++;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dfs(to,1-d);\n  }\n}\n\ntypedef long long ll;\nint dp[2][100005];\n\nint cc[100005];\n\nll solve(){\n  if(flg)return -1;\n  \n  map<int,int> mp;\n  int sum=0;\n  for(int i=0;i<(int)A.size();i++){\n    int mn=min(A[i],B[i]);\n    int mx=max(A[i],B[i]);\n    sum+=mn;\n    mp[mx-mn]++;\n  }\n  \n  dp[0][0]=1;\n  dp[1][0]=1;\n  \n  map<int,int>::iterator it;\n\n  int ai=0,bi=1;\n  for(it=mp.begin();it!=mp.end();it++){\n    swap(ai,bi);\n    \n    int a=it->first,b=it->second;\n    if(a==0)continue;\n    \n    \n    memset(cc,0,sizeof(cc));    \n    for(int i=0;i<=V;i++){\n      int k=0;\n      if(i-a>=0)k+=cc[i-a];\n      if(i-a*b-a>=0)k-=cc[i-a*b-a];\n      if(k>0)dp[ai][i]=1;\n      \n      cc[i]=dp[bi][i];\n      if(i-a>=0)cc[i]+=cc[i-a];\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<=V;i++){\n    if(dp[ai][i]>0 || dp[bi][i]>0){\n      ans=max(ans, (ll)(i+sum)*(ll)(V-i-sum) );\n    }\n  }\n  return ans-(ll)E;\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);    \n  }\n  for(int i=0;i<V;i++){\n    if(visited[i])continue;\n    cnt[0]=cnt[1]=0;\n    dfs(i,0);\n    A.push_back(cnt[0]);\n    B.push_back(cnt[1]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nusing graph = vector<vector<int>>;\n\nbool dfs(graph const& g, int v, int b, vector<int>& visited, pii& res) {\n    (b ? res.first : res.second) += 1;\n    visited[v] |= (1 << b);\n    bool ret = (visited[v] == 0b11);\n    for(auto to : g[v]) {\n        int nb = !b;\n        if(visited[to] & (1 << nb)) {\n            continue;\n        }\n        ret |= dfs(g, to, nb, visited, res);\n    }\n    return ret;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    graph g(V);\n    for(int i = 0; i < E; ++i) {\n        int a, b;\n        cin >> a >> b;\n        g[a - 1].push_back(b - 1);\n        g[b - 1].push_back(a - 1);\n    }\n\n    vector<int> visited(V);\n    vector<int> C(V + 1);\n    ll sum = 0;\n    for(int i = 0; i < V; ++i) {\n        if(visited[i] == 0) {\n            auto p = make_pair(0, 0);\n            if(dfs(g, i, 0, visited, p)) {\n                cout << -1 << endl;\n                return 0;\n            }\n            if(p.first > p.second) {\n                swap(p.first, p.second);\n            }\n            C[p.second - p.first]++;\n            sum += p.first;\n        }\n    }\n    vector<pii> s;\n    for(int i = 1; i < C.size(); ++i) {\n        if(C[i] > 0) {\n            s.emplace_back(i, C[i]);\n        }\n    }\n\n    vector<bool> dp(V + 1);\n    dp[0] = true;\n    for(int i = 0; i < s.size(); ++i) {\n        auto nxt = dp;\n        int prev = -1;\n        int val = s[i].first, m = s[i].second;\n        for(int j = 0; j < val; ++j) {\n            for(int k = 0; k * val + j < V + 1; ++k) {\n                nxt[k * val + j] = nxt[k * val + j] | (prev != -1);\n                if(dp[k * val + j]) {\n                    prev = k;\n                }\n                if(k - prev >= m) {\n                    prev = -1;\n                }\n            }\n        }\n        dp = move(nxt);\n    }\n\n    ll res = 0;\n    for(int i = 0; i < V + 1; ++i) {\n        if(dp[i]) {\n            ll a = sum + i;\n            ll b = V - a;\n            res = max(res, a * b - E);\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nint n,e,s[2];\nvector<int> G[N];\nint color[N];\n\nvoid dfs(int x,int c){\n  \n  color[x]=c;\n  s[c]++;\n  \n  for(int i=0;i<G[x].size();i++){\n\n    int nx=G[x][i];\n    if(color[nx]!=-1){\n      \n      if(color[x]==color[nx]){\n\tcout<<-1<<endl;\n\texit(0);\n      }\n      \n    }else dfs(nx,!c);\n\n  }\n  \n}\n\nll dp[N];\nmap<P,int> S;\n\nint main(){\n    \n  cin>>n>>e;\n \n  for(int i=0;i<e;i++){\n    \n    int a,b;\n    cin>>a>>b;\n    \n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  memset(color,-1,sizeof(color));\n\n  for(int i=0;i<n;i++)\n    if(color[i]==-1){\n      s[0]=s[1]=0;\n      dfs(i,0);\n      if(s[0]>s[1]) swap(s[0],s[1]);\n      S[P(s[0],s[1])]++;\n    }\n\n  map<P,int>::iterator ite=S.begin();\n  \n  memset(dp,-1,sizeof(dp));\n  \n  while(ite!=S.end()){\n    \n    dp[0]=0;\n    \n    P x=(*ite).first;\n    \n    for(int i=0;i<n;i++)\n      if(dp[i]>=0) dp[i]=(*ite).second;\n    \n    for(int i=0;i<n;i++)\n\n      if(dp[i]>=0){\n\tif(i+x.first<=n) dp[i+x.first]=max(dp[i+x.first],dp[i]-1);\n\tif(i+x.second<=n) dp[i+x.second]=max(dp[i+x.second],dp[i]-1);\n      }\n\n    ite++;\n  }\n  \n  ll ans=0;\n  \n  for(ll i=0;i<=n;i++)\n    if(dp[i]>=0) ans=max(ans,i*(n-i));\n  \n  cout<<ans-e<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[200010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< pii, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\n\tlint A = 0;\n\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tpii p = (*it).first;\n\t\tint a = p.second, c = (*it).second;\n\t\tA += p.first;\n\t\t\n\t\tfor_(j,0,2*N) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,2*N) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[pii(a, b - a)];\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nlli n,m;\nvector<int> vs[100005];\n\n\nint gone[100005];\n\nvoid dfs(int no,int &p,int& q,int c){\n\tgone[no] = c;\n\tint tc=3-c;\n\trep(i,vs[no].size()){\n\t\tint to = vs[no][i];\n\t\tif(gone[to]){\n\t\t\tif(gone[to]!=tc){\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to,p,q,tc);\n\t}\n\tif(c==1)p++;\n\telse q++;\n}\n\n\nint tn[100005]={};\n\n\nint dpn=1;\nint dp[2][100005]={};\n\nint main(void){\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b); a--; b--;\n\t\tvs[a].push_back(b);\n\t\tvs[b].push_back(a);\n\t}\n\t\n\tlli ds = 0;\n\trep(i,n){\n\t\tif(gone[i])continue;\n\t\tint p=0,q=0;\n\t\tdfs(i,p,q,1);\n\t\tds += abs(p-q);\n\t\ttn[abs(p-q)]++;\n\t}\n\t\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,n+1){\n\t\tif(!tn[i])continue;\n\t\t//printf(\"%d : %d\\n\",i,tn[i]);\n\t\trep(j,n+3){\n\t\t\tif(dp[1 - dpn][j]>=0)dp[dpn][j]=tn[i];\n\t\t\telse if(j<i || dp[dpn][j-i]<=0);\n\t\t\telse{\n\t\t\t\tdp[dpn][j] = dp[dpn][j-i]-1;\n\t\t\t}\n\t\t\t//printf(\"dp[%d][%d] :: %d ,, %d %d\\n\",dpn,j,dp[dpn][j],dp[dpn-1][j],dp[dpn][j-i]);\n\t\t}\n\t\tdpn = 1 - dpn;\n\t}\n\t\n\t\n\tlli mt = IINF;\n\trep(i,n+3){\n\t\tif(dp[1-dpn][i]>=0)mt = min(mt,abs(i-(ds-i)));\n\t}\n\t\n\t//printf(\"mt %lld\\n\",mt);\n\t\n\tprintf(\"%lld\\n\",((n+mt)/2)*((n+mt)/2-mt)-m);\n\t\n\t\n\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,M;\nvector<int> g[100010];\nint p[100010];\nvector<int> ds;\nint c0,c1;\nint dp[100010];\nll sum=0;\n\nbool dfs(int v,int pari){\n  p[v]=pari;\n  if(pari==0)c0++;\n  else c1++;\n  bool ok=true;\n  for(int nv : g[v]){\n    if(p[v]==p[nv])ok=false;\n    else{\n      if(p[nv]==-1&&!dfs(nv,1-pari))ok=false;\n    }\n  }\n  return ok;\n}\n\nint main(){\n  cin>>N>>M;\n  rep(i,M){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  memset(p,-1,sizeof(p));\n  rep(i,N){\n    if(p[i]!=-1)continue;\n    c0=0;\n    c1=0;\n    if(!dfs(i,0)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ds.push_back(abs(c0-c1));\n    sum+=abs(c0-c1);\n  }\n  sort(all(ds));\n  vector<int> a,m;\n  rep(i,ds.size()){\n    int j=i;\n    a.push_back(ds[i]);\n    int cnt=0;\n    while(j<ds.size()&&ds[j]==ds[i]){\n      j++; cnt++;\n    }\n    m.push_back(cnt);\n    i=j-1;\n  }\n\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  rep(i,a.size()){\n    rep(j,N+1){\n      if(dp[j]>=0)dp[j]=m[i];\n      else if(j<a[i]||dp[j-a[i]]<=0)dp[j]=-1;\n      else dp[j]=dp[j-a[i]]-1;\n    }\n  }\n\n  ll res=-INF;\n  rep(j,N+1){\n    if(dp[j]<0)continue;\n    ll d=abs(sum-2*j);\n    ll x=(N+d)/2,y=(N-d)/2;\n    assert(x+y==N);\n    maxch(res,x*y-M);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 100000\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint v, ee;\nvector<int> e[100000];\nint val[100000];\nbool dp[100001];\n\nP dfs(int x, int now){\n    P ret = P(0,0);\n    val[x] = now;\n    if(now) ret.second++;\n    else ret.first++;\n    rep(i,e[x].size()){\n        if(val[e[x][i]] != 2 && val[e[x][i]] != (now^1)){\n            return P(-1,-1);\n        }\n        if(val[e[x][i]] != 2) continue;\n        P tmp = dfs(e[x][i],now^1);\n        if(tmp.first == -1) return P(-1,-1);\n        ret.first += tmp.first;\n        ret.second += tmp.second;\n    }\n    return ret;\n}\n\nint main(){\n    cin >> v >> ee;\n    rep(i,v) val[i] = 2;\n    dp[0] = true;\n    uf.init(v);\n    rep(i,ee){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        e[a].push_back(b);\n        e[b].push_back(a);\n        uf.unite(a,b);\n    }\n    rep(i,v){\n        if(uf.find(i) != i) continue;\n        P d = dfs(i,0);\n        if(d.first == -1){\n            cout << -1 << endl;\n            return 0;\n        }\n        if(d.first > d.second) swap(d.first,d.second);\n        //cout << d.first << \" \" << d.second << endl;\n        for(int j = v; j >= 0; j--){\n            if(j >= d.first) dp[j] |= dp[j-d.first];\n            else break;\n            if(j >= d.second) dp[j] |= dp[j-d.second];\n        }\n    }\n    ll ans = 0;\n    for(ll i = 0; i <= v; i++){\n        if(dp[i]) ans = max(ans,i*(v-i));\n    }\n    cout << ans-ee << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n    A.push_back(cnt);\n  }\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n\n  sort(A.begin(),A.end(),greater<P>());\n  for(int i=A.size()-1;i>=0;i--)\n    Sum[i]=P(Sum[i+1].first+A[i].first,Sum[i+1].second+A[i].second);\n\n  dfs(0,0,0);\n  cout<<ans-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tGraph g(n);\n\tmap<int, int> mp;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tadd_edge(g, a, b, 0);\n\t\tadd_edge(g, b, a, 0);\n\t}\n\tvi color(n, -1);\n\tREP(i, n)\n\t{\n\t\tif (color[i] >= 0) continue;\n\t\tint b = 1, w = 0;\n\t\tcolor[i] = 0;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto e : g[t])\n\t\t\t{\n\t\t\t\tint nx = e.to;\n\t\t\t\tif (color[nx] >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (color[nx] == color[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse continue;\n\t\t\t\t}\n\t\t\t\tcolor[nx] = 1 - color[t];\n\t\t\t\tif (color[nx]) w++;\n\t\t\t\telse b++;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t\tmp[abs(b - w)]++;\n\t}\n\tvi v;\n\tint sum = 0;\n\tfor (auto i : mp)\n\t{\n\t\tsum += i.first*i.second;\n\t\tint t = 1;\n\t\tint cnt = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (cnt + t <= i.second)\n\t\t\t{\n\t\t\t\tcnt += t;\n\t\t\t\tv.push_back(i.first*t);\n\t\t\t\tt *= 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv.push_back(i.first*(i.second - cnt));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> dp(n + 1, false);\n\tdp[0] = true;\n\tREP(i, v.size())\n\t{\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (j + v[i] > n) break;\n\t\t\tif (!dp[j]) continue;\n\t\t\tdp[j + v[i]] = true;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, dp.size())\n\t{\n\t\tif (dp[i])\n\t\t{\n\t\t\tll tmp = i * (n - i) - m;\n\t\t\tchmax(ans, tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n    A.push_back(cnt);\n  }\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n\n  sort(A.begin(),A.end(),greater<P>());\n  for(int i=A.size()-1;i>=0;i--)\n    Sum[i]=P(Sum[i+1].first+A[i].first,Sum[i+1].second+A[i].second);\n\n  cout<<\"OK\"<<endl;\n\n  dfs(0,0,0);\n  cout<<ans-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint V,E;\nvector<int> g[100100];\nbool used[100100];\nint col[100100];\nbool flag=false;\nint cnt[3];\nbool dp[100100];\nvoid dfs(int v,int c)\n{\n\tused[v]=true;\n\tcol[v] = c;\n\tcnt[c+1]++;\n\tfor(int i=0;i<g[v].size();i++)\n\t{\n\t\tif(used[g[v][i]]&&col[g[v][i]]==col[v])flag=true;\n\t\tif(!used[g[v][i]])dfs(g[v][i],-c);\n\t}\n}\nbool comp(P a,P b)\n{\n\treturn (a.sec-a.fi)>(b.sec-b.fi);\n}\nint main()\n{\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<P> v;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcnt[0]=0,cnt[2]=0;\n\t\tif(!used[i])\n\t\t{\n\t\t\tdfs(i,1);\n\t\t\tif(cnt[0]>cnt[2])swap(cnt[0],cnt[2]);\n\t\t\tv.pb(P(cnt[0],cnt[2]));\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(v),comp);\n\tll v1=0ll,v2=0ll;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(v1<v2)\n\t\t{\n\t\t\tv1+=v[i].sec;\n\t\t\tv2+=v[i].fi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv1+=v[i].fi;\n\t\t\tv2+=v[i].sec;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",v1*v2-(ll)E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll v, e;\nvector<vector<ll>> g;\nvector<ll> used;\n\nbool dfs(ll p, ll col, P &cnt) {\n\tused[p] = col;\n\tif(col == 0) cnt.first++;\n\telse cnt.second++;\n\tbool ret = true;\n\tREP(i,g[p].size()) {\n\t\tif(used[g[p][i]]) {\n\t\t\tif(used[g[p][i]] == col) ret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tret = ret & dfs(g[p][i], !col, cnt);\n\t}\n\treturn ret;\n}\n\nll solve() {\n\tused.assign(v, -1);\n\tbitset<100010> dp(0);\n\tdp[0] = 1;\n\tREP(i,v) {\n\t\tif(used[i] != -1) continue;\n\t\tP cnt = P(0, 0);\n\t\tif(!dfs(i, 0, cnt)) return -1;\n\t\tdp = (dp << cnt.first) | (dp << cnt.second);\n\t}\n\tll ans = 0;\n\tREP(i,100010) if(dp[i]) {\n\t\tans = max(ans, i * (v - i) - e);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> v >> e;\n\tg.resize(v);\n\tREP(i,e) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nll V,E;\nint color[NUM];\nll num[2];\nbool dp[2][NUM];\nvector<int> G[NUM];\n\n//2部グラフか判定する(2色で全連結成分を塗れるか)\nbool dfs(int node_id,int which){\n\n\tcolor[node_id] = which;\n\tnum[which]++;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t//隣接している頂点が同じ色ならfalse\n\t\tif(color[G[node_id][i]] == which)return false;\n\t\t//隣接している頂点がまだ塗られていないなら反対色で塗る\n\t\tif(color[G[node_id][i]] == -1 && dfs(G[node_id][i],1-which) == false)return false;\n\t}\n\n\treturn true; //全ての頂点を塗れたらtrue\n}\n\n\nint main(){\n\n\tscanf(\"%lld %lld\",&V,&E);\n\n\tfor(ll i = 0; i < V; i++){\n\t\tcolor[i] = -1;\n\t}\n\n\tint from,to;\n\tfor(ll loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t}\n\n\tmap<int,int> MAP; //MAP[差] = 差の個数\n\tll base_num = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(color[i] != -1)continue;\n\n\t\tnum[0] = 0;\n\t\tnum[1] = 0;\n\n\t\tif(!dfs(i,0)){ //2部グラフでない\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tMAP[max(num[0],num[1])-min(num[0],num[1])]++;\n\t\tbase_num += min(num[0],num[1]);\n\t}\n\n\t//任意の個数を作れるかを計算する\n\tint CURRENT = 0,NEXT = 0;\n\tfor(int i = 0; i < NUM; i++){\n\t\tdp[CURRENT][i] = false;\n\t\tdp[NEXT][i] = false;\n\t}\n\n\n\n\tint add,count,num,mult;\n\n\tdp[CURRENT][0] = true;\n\tdp[NEXT][0] = true;\n\n\tfor(auto at: MAP){\n\n\t\tadd = at.first; //差分\n\t\tcount = at.second; //add分の差分を反映できる数\n\n\t\t//ダブリングナップザック\n\t\tnum = count;\n\t\tfor(int k = 1; num > 0; k *= 2){\n\t\t\tmult = min(k,num);\n\t\t\tfor(int diff = NUM-1; diff-add*mult >= 0; diff--){\n\t\t\t\tif(dp[CURRENT][diff-add*mult] == false)continue;\n\t\t\t\tdp[NEXT][diff] = true;\n\t\t\t}\n\t\t\tnum -= mult;\n\t\t}\n\n\t\tswap(CURRENT,NEXT);\n\t}\n\n\tll ans = 0;\n\tfor(int i = 1; i < NUM; i++){\n\t\tif(dp[CURRENT][i]){\n\t\t\tans = max(ans,(base_num+i)*(V-(base_num+i)));\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans-E);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\nconst int INF = 1<<29;\nconst int MAX_V = 100100;\nstruct Graph {\n    int V;\n    vector<int> list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    inline vector<int>& operator [] (int i) {return list[i];}\n    \n    void connect(int f, int t) {\n        list[f].push_back(t);\n        list[t].push_back(f);\n    }\n} G; \n\n\nmap<ll, int> ma;\nvector<pll> item;\n\nint color[MAX_V];\nbool bidfs(Graph &G, int v, int c, vector<int> &left, vector<int> &right) {\n    color[v] = c;\n    if (c == 1) left.push_back(v);\n    else right.push_back(v);\n    for (int i = 0; i < G[v].size(); ++i) {\n        if (color[G[v][i]] == c) return false;\n        if (color[G[v][i]] == 0) {\n            if (!bidfs(G, G[v][i], -c, left, right)) return false;\n        }\n    }\n    return true;\n}\n\nbool Isbipartite(Graph &G, vector<int> &left, vector<int> &right) {\n    memset(color, 0, sizeof(color));\n    left.clear(); right.clear();\n    for (int i = 0; i < G.V; ++i) {\n        if (color[i] == 0) {\n            if (!bidfs(G, i, 1, left, right)) return false;\n            else {\n                int num = abs((int)left.size() - (int)right.size());\n                ma[num]++;\n                left.clear(); right.clear();\n            }\n        }\n    }\n    return true;\n}\n\n\nll V, E, from, to;\nll dp[MAX_V*2], tdp[MAX_V*2];\n\nll solve() {\n    vint left, right;\n    if (!Isbipartite(G, left, right)) return -1;\n    EACH(it,ma) if (it->FI != 0) item.PB(MP(it->FI, it->SE));\n    \n    //COUT(item);\n    \n    int n = item.size();\n    for (int i = 0; i < MAX_V*2; ++i) dp[i] = tdp[i] = INF;\n    dp[MAX_V] = 0;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < MAX_V*2; ++j) {\n            //if (dp[j] < INF) cout << i << \", \" << j-MAX_V << \" : \" << dp[j] << endl;\n        }\n        if (i == n) break;\n            \n        ll sub = item[i].FI * item[i].SE;\n        for (int j = 0; j < MAX_V*2; ++j) {\n            if (j >= sub && dp[j] < INF) tdp[j-sub] = 0;\n        }\n        for (int j = 0; j < MAX_V*2; ++j) {\n            if (j >= item[i].FI*2) {\n                if (tdp[j - item[i].FI*2] < item[i].SE) \n                    tdp[j] = min(tdp[j], tdp[j - item[i].FI*2] + 1);\n            }\n        }\n        for (int j = 0; j < MAX_V*2; ++j) {\n            dp[j] = tdp[j], tdp[j] = INF;\n        }\n    }\n    \n    ll res = INF;\n    for (int i = 0; i < MAX_V*2; ++i) {\n        if (dp[i] < INF) {\n            res = min(res, (ll)abs(i-MAX_V));\n        }\n    }\n    //COUT(res);\n    \n    ll a = (V + res) / 2, b = (V - res) / 2;\n\n    return a * b - E;\n}\n\nint main() {\n    while (cin >> V >> E) {\n        ma.clear(); item.clear();\n        G.init(V);\n        for (int i = 0; i < E; ++i) {\n            scanf(\"%d %d\", &from, &to);\n            --from; --to;\n            G.connect(from, to);\n        }\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,M;\nvector<int> g[100010];\nint p[100010];\nvector<int> ds;\nint c0,c1;\nint dp[100010];\nll sum=0;\n\nbool dfs(int v,int pari){\n  p[v]=pari;\n  if(pari==0)c0++;\n  else c1++;\n  bool ok=true;\n  for(int nv : g[v]){\n    if(p[v]==p[nv])ok=false;\n    else{\n      if(p[nv]==-1&&!dfs(nv,1-pari))ok=false;\n    }\n  }\n  return ok;\n}\n\nint main(){\n  cin>>N>>M;\n  rep(i,M){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  memset(p,-1,sizeof(p));\n  rep(i,N){\n    if(p[i]!=-1)continue;\n    c0=c1=0;\n    if(!dfs(i,0)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ds.push_back(abs(c0-c1));\n    sum+=abs(c0-c1);\n  }\n  sort(all(ds));\n  vector<int> a,m;\n  rep(i,ds.size()){\n    int j=i;\n    a.push_back(ds[i]);\n    int cnt=1;\n    while(j<ds.size()&&ds[j]==ds[i]){\n      j++;\n    }\n    m.push_back(cnt);\n    i=j-1;\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  rep(i,a.size()){\n    rep(j,N+1){\n      if(dp[j]>=0)dp[j]=m[j];\n      else if(j<a[i]||dp[j-a[i]]<=0)dp[j]=-1;\n      else dp[j]=dp[j-a[i]]-1;\n    }\n  }\n\n  ll res=-INF;\n  rep(j,N+1){\n    if(dp[j]<0)continue;\n    ll d=abs(sum-2*j);\n    ll x=(N+d)/2,y=(N-d)/2;\n    assert(x+y==N);\n    maxch(res,x*y-M);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e9\n\nbool dfs(int now, const vector<vector<int> >& adj, vector<int>& history, int& a, int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int input_a, input_b;\n  vector<vector<int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  int a_sum = 0, b_sum = 0;\n  vector<int> c_tmp;\n  vector<int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      int a = 0;\n      int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<int> > dp(n, vector<int>(v + 1, -INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i - 1].first ? dp[i][j - c[i].first] - 1 : (int)INF * (-1));\n    \n  \n  int minpoint = -1;\n  int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\nint n, m, a, b, d, u[200000]; vector<int>x[100000], c[100000], H; bool used[100000], f[200009], g[200009];\nvector<pair<int, int>>I;\nbool solve() {\n\tvector<int>col(n, -1);\n\tfor (int i = 0; i < d; i++) {\n\t\tqueue<int>Q; col[c[i][0]] = 0; Q.push(c[i][0]);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (col[j] == -1) { Q.push(j); col[j] = 1 - col[a1]; }\n\t\t\t\telse if (col[j] == col[a1]) { return false; }\n\t\t\t}\n\t\t}\n\t\tint v = 0; for (int j = 0; j < c[i].size(); j++) { if (col[c[i][0]] == 0)v++; else v--; }\n\t\tH.push_back(abs(v));\n\t}\n\treturn true;\n}\nvoid knapsack() {\n\tfor (int i = 0; i <= n * 2; i++)f[i] = false; f[n] = true;\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j = 0; j <= n * 2; j++) { g[j] = false; u[j] = -1; }\n\t\tfor (int j = 0; j <= n * 2; j++) {\n\t\t\tif (f[j] == false)continue;\n\t\t\tint r1 = I[i].first * 2;\n\t\t\tint r3 = I[i].first*I[i].second*-1, r4 = -r3; r4 += j; r3 += j;\n\t\t\tr3 = max(r3, u[r3%r1]);\n\t\t\tfor (int k = r3; k <= r4; k += r1) { g[k] = true; u[k%r1] = k; }\n\t\t}\n\t\tfor (int j = 0; j <= n * 2; j++)f[j] = g[j];\n\t}\n}\nint main() {\n\tcin >> n >> m; for (int i = 0; i < m; i++) { cin >> a >> b; a--; b--; x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i] == true)continue; queue<int>Q;\n\t\tQ.push(i); used[i] = true;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop(); c[d].push_back(a1);\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (used[j] == false) { Q.push(j); used[j] = true; }\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tbool U = solve(); map<int, int>M, M2;\n\tif (U == false) { cout << \"-1\" << endl; return 0; }\n\tfor (int i = 0; i < H.size(); i++) M[H[i]]++;\n\tfor (int i = 0; i < H.size(); i++) {\n\t\tif (M2[H[i]] == 0) { M2[H[i]] = 1; I.push_back(make_pair(H[i], M[H[i]])); }\n\t}\n\tknapsack();\n\tlong long ret = 0;\n\tfor (int i = 0; i <= n; i++) { if (f[2 * i] == true)ret = max(ret, 1LL * (n - i)*i); }\n\tcout << ret - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> G[100000];\nbool flag = false;\nint a = 0, b = 0;\nint color[100000];\n\nvoid dfs(int n, int c) {\n\tcolor[n] = c;\n\tif (c - 1) {\n\t\tb++;\n\t}\n\telse {\n\t\ta++;\n\t}\n\tfor (auto v : G[n]) {\n\t\tif (color[v] == 0) {\n\t\t\tdfs(v, 3 - c);\n\t\t}\n\t\telse if (color[v] == c) {\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tll V, E;\n\tcin >> V >> E;\n\tfor (int i = 0, a, b; i < E; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tll x = 0;\n\tvector<ll> d;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (color[i] == 0) {\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tif (a != b) {\n\t\t\td.push_back(abs(a - b) * 2);\n\t\t\tx += abs(a - b);\n\t\t}\n\t\ta = b = 0;\n\t}\n\tsort(d.begin(), d.end());\n\tll ma = 0;\n\tvector<int> dp(x * 2 + 1); dp[0] = 1;\n\tfor (auto bi : d) {\n\t\tfor (int i = min(x * 2 - bi, ma); i >= 0; i--) {\n\t\t\tif (dp[i]) {\n\t\t\t\tdp[i + bi] = 1;\n\t\t\t\tma = max(ma, i + bi);\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\twhile (dp[x - res] == 0 && dp[x + res] == 0) res++;\n\tcout << (flag ? -1ll : (V + res) * (V - res) / 4 - E) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    bool f = false;\n    vector<int> col(n, -1);\n    vector<P> p;\n    for (int i = 0; i < n; i++)\n    {\n        if (col[i] != -1)\n            continue;\n        queue<int> que;\n        que.push(i);\n        col[i] = 0;\n        int one = 0, zero = 1;\n        while (!que.empty())\n        {\n            int cur = que.front();\n            que.pop();\n            for (auto v : g[cur])\n            {\n                if (col[v] == -1)\n                {\n                    col[v] = 1 - col[cur];\n                    que.push(v);\n                    if (col[v])\n                        one++;\n                    else\n                        zero++;\n                    continue;\n                }\n                if (col[v] == col[cur])\n                    f = true;\n            }\n        }\n        p.emplace_back(min(one, zero), max(one, zero));\n    }\n    if (f)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    bitset<100000> bs;\n    bs.set(0);\n    for (auto pp : p)\n    {\n        int a = pp.first, b = pp.second;\n        bs = (bs << a) | (bs << b);\n    }\n    ll ret = 0;\n    for (ll i = 0; i <= n; i++)\n        if (bs[i])\n            ret = max(ret, i * (n - i) - m);\n    cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <map>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint V, E;\nvector<llint> G[100005];\nllint color[100005];\nmap<llint, llint> mp;\nllint dp[2][100005];\n\nP dfs(int v, int prev, int c)\n{\n\tcolor[v] = c;\n\tP ret = make_pair(0, 0);\n\tif(c == 1) ret.first++;\n\telse ret.second++;\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tif(color[G[v][i]]){\n\t\t\tif(color[G[v][i]] != -c) return make_pair(-1, -1);\n\t\t\telse continue;\n\t\t}\n\t\tP res = dfs(G[v][i], v, -c);\n\t\tif(res.first == -1) return make_pair(-1, -1);\n\t\tret.first += res.first;\n\t\tret.second += res.second;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> V >> E;\n\tllint a, b;\n\tfor(llint i = 0; i < E; i++){\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\t\n\tllint goal = 0;\n\tfor(llint i = 1; i <= V; i++){\n\t\tif(color[i]) continue;\n\t\tP res = dfs(i, -1, 1);\n\t\tif(res.first == -1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tgoal += abs(res.first - res.second);\n\t\tmp[2 * abs(res.first - res.second)]++;\n\t}\n\tllint N = mp.size();\n\t\n\tfor(llint j = 0; j <= V; j++){\n\t\tdp[0][j] = dp[1][j] = -1;\n\t}\n\tdp[0][0] = 0;\n\t\n\tauto it = mp.begin();\n\tfor(llint i = 1; i <= N; i++){\n\t\tfor(llint j = 0; j <= V; j++){\n\t\t\tif(dp[(i+1)%2][j] >= 0) dp[i%2][j] = max(dp[i%2][j], it->second);\n\t\t\tif(j - it->first >= 0){\n\t\t\t\tif(dp[i%2][j - it->first] >= 1) dp[i%2][j] = max(dp[i%2][j], dp[i%2][j - it->first] - 1);\n\t\t\t}\n\t\t}\n\t\tit++;\n\t}\n\t\n\tllint close_val = inf, close_i;\n\tfor(llint i = 0; i <= V; i++){\n\t\tif(dp[N%2][i] < 0) continue;\n\t\tif(close_val > abs(goal - i)){\n\t\t\tclose_val = abs(goal - i);\n\t\t\tclose_i = i;\n\t\t}\n\t}\n\t\n\tllint black = (close_i - goal + V) / 2;\n\tllint ans = black * (V - black) - E;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nbool flag = true;\nbitset<100010> bit;\nint black,white,col[100010];\nvector<int> G[100010];\nvector<P> vec;\n\nvoid dfs(int v,int c){\n\tcol[v] = c;\n\t(c ? black : white) += 1;\n\tfor(int to : G[v]){\n\t\tif(col[to] == -1){\n\t\t\tdfs(to,(c + 1) % 2);\n\t\t}else if(col[to] != (c + 1) % 2){\n\t\t\tflag = false;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint n,m,ma = 0;\n\tcin >> n >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b; a--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tfor(int i = 0;i < n;i++) col[i] = -1;\n\tfor(int i = 0;i < n;i++){\n\t\tif(col[i] == -1){\n\t\t\tblack = 0;\n\t\t\twhite = 0;\n\t\t\tdfs(i,0);\n\t\t\tif(!flag){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvec.pb(P(black,white));\n\t\t}\n\t}\n\tbit.set(0);\n\tfor(P p : vec){\n\t\tbit = (bit << p.first) | (bit << p.second);\n\t}\n\tfor(int i = 0;i < 100005;i++){\n\t\tif(bit[i]) chmax(ma,i * (n - i));\n\t}\n\tcout << ma - m << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n\n  map<PLL,int> xs;\n  VI parity(V);\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs[res]++;\n\t}\n  }\n\n  int crt = 0, nxt = 1;\n  vector<vector<bool>> dp(2, vector<bool>(V+1));\n  dp[crt][0] = true;\n  for(auto&& p_: xs){\n\tdp[nxt] = dp[crt];\n\n\tint num = p_.SS;\n\tint b = 1;\n\twhile(num){\n\t  if(num < b)\n\t\tb = num;\n\t  num -= b;\n\n\t  VL ps{p_.FF.FF * b, p_.FF.SS*b};\n\t  for(auto&& p: ps)\n\t\tfor(int i=V;i-p>=0;--i)\n\t\t  dp[nxt][i] = dp[nxt][i] | dp[nxt][i-p];\n\n\t  \n\t  b <<= 1;\n\t}\n\tswap(crt, nxt);\n  }\n\n  LL ans = 0;\n  REP(i,V+1)if(dp[crt][i]) maxi(ans, (LL)i*(V-i));\n  cout << ans - E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tcol.assign(N, -1);\n\t\n\tbool flag = true;\n\tfor_(v,0,N) if (col[v] == -1) flag &= dfs(v, 0);\n\t\n\tif (!flag) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tlint ans = 0;\n\t\tint m = g[1].size();\n\t\t\n\t\tfor (int v : g[0]) ans += m - adj[v].size();\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint dp[N] = {};\nint DP(){\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n\n  for(P a:A){\n    dp[0] = 1;\n    for(int j=0;j<N;j++)if(dp[j]) dp[j] = a.second+1;\n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n\n  for(int i=0;i<N;i++){\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  }\n  return res;\n}\n\nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> e[100000];\n\ntypedef pair<int,int> P;\n\nint c[100000],g;// -1 0 1 2 ;\nset<P> st;\nint used[100000];\n\nvoid dfs(int p,int d){\n  if(c[p]==-1)c[p]=d;\n  else if((c[p]==0&&d==1)||(c[p]==1&&d==0))c[p]=2;\n  used[p]=g;\n  for(int i=0;i<e[p].size();i++){\n    if(st.count(P(min(e[p][i],p),max(e[p][i],p))))continue;\n    st.insert(P(min(e[p][i],p),max(e[p][i],p)));\n    dfs(e[p][i],!d);\n  }\n}\n\n\nint main(){\n  int V,E;\n  memset(c,-1,sizeof(c));\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++){\n    cin>>a>>b;\n    a--,b--;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  for(int i=0;i<V;i++){\n    if(!used[i])++g,dfs(i,0);\n\n  }\n  long long ans=0;\n  for(int i=0;i<V;i++)\n    if(c[i]==2)ans=-1;\n  \n  if(ans!=-1){\n    long long cnt[100001][2]={};\n    \n    for(int i=0;i<V;i++)\n      cnt[used[i]][c[i]]++;\n    for(int i=1;i<=g;i++)ans+=cnt[i][0]*cnt[i][1];\n    vector<int> v[2];\n    for(int i=1;i<=g;i++){\n      v[0].push_back(max(cnt[i][0],cnt[i][1]));\n      v[1].push_back(min(cnt[i][0],cnt[i][1]));\n    }\n\n    sort(v[0].begin(),v[0].end());\n    sort(v[1].begin(),v[1].end());\n\n    long long g0=v[0][0],g1=v[1][0];\n\n    for(int i=1;i<v[0].size();i++)\n      ans+=g0*v[0][i],g0+=v[0][i];\n    for(int i=1;i<v[1].size();i++)\n      ans+=g1*v[1][i],g1+=v[1][i];\n    \n    ans-=E;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define int ll\nint n,m;\nvvi G;\nvi used,in,tmp;\nint dfs(int a,int b=0){\n\ttmp.pb(a);\n\tused[a]=b;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(used[to]==2){\n\t\t\tif(!dfs(to,b^1))return 0;\n\t\t}else if(used[to]==b)return 0;\n\t}\n\treturn 1;\n}\nsigned main(){\n\tcin>>n>>m;\n\tG=vvi(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tused=vi(n,2);\n\trep(i,n)if(used[i]==2){\n\t\ttmp=vi(0);\n\t\tif(!dfs(i)){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint co=0;\n\t\trep(j,tmp.size())if(used[tmp[j]]==1)co++;else co--;\n\t\tin.pb(-abs(co));\n\t}\n\tsort(all(in));\n\tint sum=0;\n\trep(i,in.size())if(sum>=0)sum+=in[i];else sum-=in[i];\n\tsum=abs(sum);\n\tcout<<(n*n-sum*sum)/4-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nbool dfs(const vvi& g,int u,int c,vi& color,int& x,int& y)\n{\n\tif(color[u]!=-1)\n\t\treturn color[u]==c;\n\tcolor[u]=c;\n\t(c==0?x:y)++;\n\tfor(int v:g[u])\n\t\tif(!dfs(g,v,!c,color,x,y))\n\t\t\treturn false;\n\treturn true;\n}\n\nint solve(const vvi& g)\n{\n\tint n=g.size();\n\t\n\tvector<pii> ps;\n\t{\n\t\tvi color(n,-1);\n\t\trep(i,n) if(color[i]==-1){\n\t\t\tint x=0,y=0;\n\t\t\tif(!dfs(g,i,0,color,x,y))\n\t\t\t\treturn -1;\n\t\t\tps.emplace_back(x,y);\n\t\t}\n\t}\n\t\n\tbitset<100001> b;\n\tb[0]=1;\n\tfor(pii p:ps)\n\t\tb=(b<<p.first)|(b<<p.second);\n\t\n\tll mx=0;\n\trep(i,b.size()) if(b[i])\n\t\tmx=max(mx,ll(i)*(n-i));\n\t\n\tint e=0;\n\trep(i,n) e+=g[i].size();\n\t\n\treturn mx-e/2;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvvi g(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tcout<<solve(g)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cmath>\nusing namespace std;\nint n, m, a, b, d, u[200000]; vector<int>x[100000], c[100000], H; bool used[100000], f[200009], g[200009];\nvector<pair<int, int>>I;\nbool solve() {\n\tvector<int>col(n, -1);\n\tfor (int i = 0; i < d; i++) {\n\t\tqueue<int>Q; col[c[i][0]] = 0; Q.push(c[i][0]);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (col[j] == -1) { Q.push(j); col[j] = 1 - col[a1]; }\n\t\t\t\telse if (col[j] == col[a1]) { return false; }\n\t\t\t}\n\t\t}\n\t\tint v = 0; for (int j = 0; j < c[i].size(); j++) { if (col[c[i][j]] == 0)v++; else v--; }\n\t\tH.push_back(abs(v));\n\t}\n\treturn true;\n}\nvoid knapsack() {\n\tfor (int i = 0; i <= n * 2; i++)f[i] = false; f[n] = true;\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j = 0; j <= n * 2; j++) { g[j] = false; u[j] = -1; }\n\t\tfor (int j = 0; j <= n * 2; j++) {\n\t\t\tif (f[j] == false)continue;\n\t\t\tint r1 = I[i].first * 2;\n\t\t\tint r3 = I[i].first*I[i].second*-1, r4 = -r3; r4 += j; r3 += j;\n\t\t\tr3 = max(r3, u[r3%r1]);\n\t\t\tfor (int k = r3; k <= r4; k += r1) { g[k] = true; u[k%r1] = k; }\n\t\t}\n\t\tfor (int j = 0; j <= n * 2; j++)f[j] = g[j];\n\t}\n}\nint main() {\n\tcin >> n >> m; for (int i = 0; i < m; i++) { cin >> a >> b; a--; b--; x[a].push_back(b); x[b].push_back(a); }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i] == true)continue; queue<int>Q;\n\t\tQ.push(i); used[i] = true;\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop(); c[d].push_back(a1);\n\t\t\tfor (int j : x[a1]) {\n\t\t\t\tif (used[j] == false) { Q.push(j); used[j] = true; }\n\t\t\t}\n\t\t}\n\t\td++;\n\t}\n\tbool U = solve(); map<int, int>M, M2;\n\tif (U == false) { cout << \"-1\" << endl; return 0; }\n\tfor (int i = 0; i < H.size(); i++) M[H[i]]++;\n\tfor (int i = 0; i < H.size(); i++) {\n\t\tif (M2[H[i]] == 0) { M2[H[i]] = 1; I.push_back(make_pair(H[i], M[H[i]])); }\n\t}\n\tknapsack();\n\tlong long ret = 0;\n\tfor (int i = 0; i <= n; i++) { if (f[2 * i] == true)ret = max(ret, 1LL * (n - i)*i); }\n\tcout << ret - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nconst int MAX_V = 100000;\nvector<int> es[MAX_V];\nvector<int> c(MAX_V, -1);\nll cnt[] = {0, 0};\nbool flag = false;\n\nvoid dfs(int now, int col){\n    cnt[c[now] = col]++;\n    for(auto &e: es[now]){\n        if(c[e] == -1) dfs(e, col^1);\n        if(c[e] == col) flag = true;\n    }\n}\n\nint main(){\n    ll V, E;\n    cin >> V >> E;\n    rep(i, E){\n        int u, v; cin >> u >> v; u--, v--;\n        es[u].pb(v), es[v].pb(u);\n    }\n    ll base = 0;\n    bitset<MAX_V+1> bs;\n    bs.set(0);\n    rep(i, V){\n        if(c[i] != -1) continue;\n        dfs(i, 0);\n        if(cnt[0] < cnt[1]) swap(cnt[0], cnt[1]);\n        base += cnt[1], bs |= (bs << (cnt[0]-cnt[1]));\n        cnt[0] = cnt[1] = 0;\n    }\n    if(flag) {cout << -1 << endl; return 0;}\n    ll ans = E;\n    rep(i, V){\n        if(!bs[i]) continue;\n        ll x = base+i;\n        chmax(ans, x*(V-x));\n    }\n    cout << ans-E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nvector<pair<int, int>> sizesOfBipartiteGraph(const Graph &g) {\n  int n = g.size();\n  vector<int> color(n, -1);\n  vector<pair<int, int>> v;\n  rep(i, n) {\n    if (color[i] >= 0) continue;\n    color[i] = 0;\n    int l = 1, r = 0;\n    for (queue<int> q({i}); q.size(); q.pop()) {\n      int v = q.front();\n      for (auto &e : g[v]) {\n        if (color[e.dst] == color[e.src]) return {};\n        if (color[e.dst] == -1) {\n          color[e.dst] = color[e.src] ^ 1;\n          (color[e.dst] ? r : l)++;\n          q.emplace(e.dst);\n        }\n      }\n    }\n    v.emplace_back(l, r);\n  }\n  return v;\n}\n\nmain() {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  rep(i, m) {\n    int a, b;\n    cin >> a >> b;\n    g.addEdge(--a, --b);\n  }\n  auto v = sizesOfBipartiteGraph(g);\n  if (v.empty()) return cout << -1 << endl, 0;\n  bitset<100001> dp = 1;\n  for (auto &p : v) dp = dp << p.first | dp << p.second;\n  int ans = 0;\n  rep(l, n + 1) {\n    if (not dp[l]) continue;\n    int r = n - l;\n    cmax(ans, l * r - m);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector< vector<int> > Graph;\nint dfs(Graph &g, vector<int> &color, int v, int c){\n\tcolor[v] = c;\n\tint res = c==1;\n\tFOR(it, g[v]){\n\t\tif(color[*it] == c) return -1;\n\t\tint ret = 0;\n\t\tif(!color[*it] && (ret = dfs(g, color, *it, -c)) < 0) return -1;\n\t\tres += ret;\n\t}\n\treturn res;\n}\n\nvi isBipartite(Graph &g){\n\tint n = g.size();\n\tvector<int> color(n);\n\tvector<int> knap;\n\tREP(i, n){\n\t\tint ret = 0;\n\t\tif(!color[i] && (ret = dfs(g, color, i, 1)) < 0) return vi();\n\t\tif(ret) knap.push_back(ret);\n\t}\n\treturn knap;\n}\n\nll n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint ans;\n\tvi knap = isBipartite(g);\n\tif(knap.empty()) cout << -1 << endl;\n\telse{\n\t\tvi dp(n+1);\n\t\tdp[0] = 1;\n\t\tint sum = 0;\n\t\tREP(i, knap.size()){\n\t\t\tRREP(j, sum+1) dp[j+knap[i]] |= dp[j];\n\t\t\tsum += knap[i];\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, n+1) if(dp[i]) ans = max(ans, i*(n-i));\n\t\tcout << ans - m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint V,E;\nvector<int> g[100100];\nbool used[100100];\nint col[100100];\nbool flag=false;\nint cnt[3];\nbool dp[100100];\nvoid dfs(int v,int c)\n{\n\tused[v]=true;\n\tcol[v] = c;\n\tcnt[c+1]++;\n\tfor(int i=0;i<g[v].size();i++)\n\t{\n\t\tif(used[g[v][i]]&&col[g[v][i]]==col[v])flag=true;\n\t\tif(!used[g[v][i]])dfs(g[v][i],-c);\n\t}\n}\nbool comp(P a,P b)\n{\n\treturn abs(a.fi-a.sec)>abs(b.fi-b.sec);\n}\nint main()\n{\n\tscanf(\"%d %d\",&V,&E);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<P> v;\n\tfor(int i=0;i<V;i++)\n\t{\n\t\tcnt[0]=0,cnt[2]=0;\n\t\tif(!used[i])\n\t\t{\n\t\t\tdfs(i,1);\n\t\t\tif(cnt[0]>cnt[2])swap(cnt[0],cnt[2]);\n\t\t\tv.pb(P(cnt[0],cnt[2]));\n\t\t}\n\t}\n\tif(flag)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(v),comp);\n\tint v1=0,v2=0;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tif(v1<v2)\n\t\t{\n\t\t\tv1+=v[i].sec;\n\t\t\tv2+=v[i].fi;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv1+=v[i].fi;\n\t\t\tv2+=v[i].sec;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",v1*v2-E);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct UnionFind {\npublic:\n  int n;\n  std::vector<int> par;\n  UnionFind(int n): n(n) {\n    par.resize(n, -1);\n  }\n  int root(int x) {\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = root(x), ry = root(y);\n    if(rx == ry) return;\n    if(par[rx] < par[ry]) {\n      std::swap(x, y);\n      rx = root(x), ry = root(y);\n    }\n    par[rx] += par[ry];\n    par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return -par[root(x)];\n  }\n};\nstruct XorShift\n{\n   uint32_t w, x, y, z;\n   XorShift(uint32_t seed = time(nullptr))\n   {\n       w = seed;\n       x = w << 13;\n       y = (w >> 9) ^ (x << 6);\n       z = y >> 7;\n   }\n   uint32_t rand()\n   {\n       uint32_t t = x ^ (x << 11);\n       x = y;\n       y = z;\n       z = w;\n       return w = (w ^ (w >> 19) ^ (t ^ (t >> 8)));\n   }\n   int randInt(int min = 0, int max = 0x7FFFFFFF)\n   {\n       return rand() % (max - min + 1) + min;\n   }\n   double randDouble(double min = 0, double max = 1)\n   {\n       return (double)(rand() % 0xFFFF) / 0xFFFF * (max - min) + min;\n   }\n   void SetDefault()\n   {\n       w = 123456789;\n       x = 362436069;\n       y = 521288629;\n       z = 88675123;\n   }\n};\nXorShift randgen;\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<ll, ll>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst ll INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(ll i=0;i<((ll)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nvi col;\nbool ok = true;\nvoid dfs(ll now, ll prev, ll nowc, const vvi &g) {\n  if(!ok) return;\n  col[now] = nowc;\n  for(ll i=0;i<((ll)(g[now].size()));++i) {\n    ll nxt = g[now][i];\n    if(nxt == prev) continue;\n    if(col[nxt] == nowc) {\n      ok = false;\n      return;\n    }\n    if(col[nxt] != -1) continue;\n    dfs(nxt, now, !nowc, g);\n  }\n}\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  ll n, m; cin >> n >> m;\n  vvi g(n);\n  UnionFind uf(n);\n  for(ll i=0;i<(m);++i) {\n    ll a, b; cin >> a >> b;\n    a--; b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    uf.unite(a, b);\n  }\n  col.resize(n, -1);\n  for(ll i=0;i<(n);++i) {\n    if(col[i] != -1) continue;\n    dfs(i, -1, 0, g);\n  }\n  if(!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  map<ll, ll> mp;\n  for(ll i=0;i<(n);++i) {\n    mp[uf.root(i)] += col[i];\n  }\n  vi v;\n  for(auto &e: mp) {\n    v.push_back(abs(uf.size(e.first) - 2 * e.second));\n  }\n  bitset<200010> dp(0);\n  dp[100001] = 1;\n  for(auto &e: v) {\n    auto tmp = dp >> e;\n    dp = (dp << e) | tmp;\n  }\n  ll ans = LINF;\n  for(ll i=0;i<(200010);++i) {\n    if(dp[i]) chmin(ans, abs(i-100001));\n  }\n  ll add = (n - ans) / 2;\n  cout << add * (add + ans) - m << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< int, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc(lint A) {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tint a = (*it).first, c = (*it).second;\n\t\t\n\t\tfor_(j,0,N+1) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,N+1) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tbool flag = true;\n\tlint A = 0;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[b - a];\n\t\tA += a;\n\t}\n\t\t\n\tcout << (!flag ? -1 : calc(A) - M) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvector<int> G[100000];\nbool flag = false;\nint a = 0, b = 0;\nint color[100000];\n\nvoid dfs(int n, int c) {\n\tcolor[n] = c;\n\tif (c - 1) {\n\t\tb++;\n\t}\n\telse {\n\t\ta++;\n\t}\n\tfor (auto v : G[n]) {\n\t\tif (color[v] == 0) {\n\t\t\tdfs(v, 3 - c);\n\t\t}\n\t\telse if (color[v] == c) {\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tll V, E;\n\tcin >> V >> E;\n\tfor (int i = 0, a, b; i < E; i++) {\n\t\tcin >> a >> b;\n\t\tG[a - 1].push_back(b - 1);\n\t\tG[b - 1].push_back(a - 1);\n\t}\n\tll x = 0;\n\tvector<ll> d;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (color[i] == 0) {\n\t\t\tdfs(i, 1);\n\t\t}\n\t\tif (a != b) {\n\t\t\td.push_back(abs(a - b) * 2);\n\t\t\tx += abs(a - b);\n\t\t}\n\t\ta = b = 0;\n\t}\n\tvector<int> dp(x * 2 + 1); dp[0] = 1;\n\tfor (auto bi : d) {\n\t\tfor (int i = x * 2 - bi; i >= 0; i--) {\n\t\t\tif (dp[i]) {\n\t\t\t\tdp[i + bi] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\twhile (dp[x - res] == 0 && dp[x + res] == 0) res++;\n\tcout << (flag ? -1ll : (V + res) * (V - res) / 4 - E) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector< vector<int> > Graph;\npii dfs(Graph &g, vector<int> &color, int v, int c){\n\tcolor[v] = c;\n\tpii res(c==1, c==-1);\n\tFOR(it, g[v]){\n\t\tif(color[*it] == c) return pii(-1, -1);\n\t\tpii ret(0, 0);\n\t\tif(!color[*it] && (ret = dfs(g, color, *it, -c)).first < 0) return pii(-1, -1);\n\t\tres.first += ret.first;\n\t\tres.second += ret.second;\n\t}\n\treturn res;\n}\n\nvi isBipartite(Graph &g){\n\tint n = g.size();\n\tvector<int> color(n);\n\tvector<int> knap;\n\tREP(i, n){\n\t\tpii ret(0, 0);\n\t\tif(!color[i] && (ret = dfs(g, color, i, 1)).first < 0) return vi();\n\t\tif(ret.first || ret.second){\n\t\t\tif(ret.first < ret.second) swap(ret.first, ret.second);\n\t\t\tknap.push_back(ret.first - ret.second);\n\t\t}\n\t}\n\treturn knap;\n}\n\nll n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint ans;\n\tvi knap = isBipartite(g);\n\tif(knap.empty()) cout << -1 << endl;\n\telse{\n\t\tvi dp(n+1);\n\t\tdp[0] = 1;\n\t\tint sum = 0;\n\t\tREP(i, knap.size()){\n\t\t\tRREP(j, sum+1) dp[j+knap[i]] |= dp[j];\n\t\t\tsum += knap[i];\n\t\t}\n\t\tll ans = 0;\n\t\tint geta = (n - sum)/2;\n\t\tREP(i, sum+1) if(dp[i]) ans = max(ans, (ll)(i+geta)*(sum-i+geta));\n\t\tcout << ans - m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint p = 0;\n\nint A(){\n\tif( S[p] == 'm' ){\n\t\tp++;\n\t\tA();\n\t\tif( S[p] != 'e' ) throw 2;\n\t\tp++;\n\t\tA();\n\t\tif( S[p] != 'w' ) throw 2;\n\t\tp++;\n\t}else if( S[p] == 'm' ) throw 2;\n}\nint main(){\n\tcin >> S;\n\tS += \"=\";\n\ttry{\n\t\tA();\n\t\tif( S[p] != '=' ) throw 0;\n\t\tcout << \"Cat\" << endl;\n\t}catch(int x){\n\t\tcout << \"Rabbit\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll v, e; cin >> v >> e;\n    vector<vector<int>> g(v);\n    rep(i, e) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    vector<int> used(v, -1);\n    vll diff;\n    rep(i, v) {\n        if (used[i] != -1) continue;\n//        cout << used << endl;\n        vll counter(2);\n        bool contradiction = false;\n        function<void(int, int)> f = [&](ll x, ll k){\n            if (used[x] != -1) {\n                if (used[x] != k % 2) {\n                    contradiction = true;\n                }\n                return;\n            }\n            used[x] = k % 2;\n            counter[k % 2]++;\n            for (int next : g[x]) {\n//                cout << x << \"->\" << next << endl;\n                f(next, k+1);\n            }\n        };\n        f(i, 0);\n        if (contradiction) {\n            cout << -1 << endl;\n            return 0;\n        }\n        diff.pb(abs(counter[0] - counter[1]));\n    }\n\n//    cout << diff << endl;\n\n    int n = diff.size();\n    const ll MAXD = 200000;\n    vector<int> dp(MAXD);\n    vector<int> dp_next(MAXD);\n    dp_next[0] = 1;\n    rep(d, n) {\n        swap(dp, dp_next);\n        rep(i, MAXD) {\n            dp_next[i] = 0;\n        }\n        rep(i, MAXD) if (dp[i]) {\n            dp_next[i+diff[d]] = 1;\n            dp_next[abs(i-diff[d])] = 1;\n        }\n    }\n    /*\n    rep(i, MAXD) {\n        if (dp_next[i]) {\n            cout << i << \" \";\n        }\n    }\n        cout << endl;\n        */\n\n    rep(i, MAXD) {\n        if (dp_next[i]) {\n            ll a = (v + i) / 2, b = (v - i) / 2;\n//            cout << a << \" \" << b << endl;\n            cout << a * b - e << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvi g;\n\nP dfs(int v,int b,vi& used){\n\tused[v]=b;\n\tP p;\n\tif(b) p.first++;\n\telse p.second++;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u=g[v][i];\n\t\tif(used[u]==-1){\n\t\t\tP q=dfs(u,!b,used);\n\t\t\tp.first+=q.first;\n\t\t\tp.second+=q.second;\n\t\t}\n\t\tif(used[u]==b) return {-inf,0};\n\t}\n\treturn p;\n}\n\nint main(){\n\tcin>>n>>m;\n\tg=vvi(n);\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvi used(n,-1);\n\tint tmp=0;\n\tmap<int,int> M;\n\tfor(int i=0;i<n;i++) if(used[i]==-1){\n\t\tP p=dfs(i,1,used);\n\t\tint A=p.first,B=p.second;\n\t\tif(A<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ttmp+=min(A,B);\n\t\tM[abs(A-B)]++;\n\t}\n\tvi dp(n+1);\n\tdp[tmp]=1;\n\tfor(auto i=M.begin();i!=M.end();i++){\n\t\tint v=i->first,N=i->second;\n\t\tvi DP(n+1,-1);\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(dp[j]) DP[j]=0;\n\t\t\telse if(j>=v&&DP[j-v]!=-1&&DP[j-v]<N){\n\t\t\t\tDP[j]=DP[j-v]+1;\n\t\t\t\tdp[j]|=1;\n\t\t\t}\n\t\t}\n\t}\n\tll res=0;\n\tfor(int i=0;i<=n;i++) res=max(res,(ll)dp[i]*i*(n-i));\n\tcout<<res-m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nvector<int>G[100000];\n\nint col[100000];\npint dfs(int v,int c){\n    pint ret(0,0);\n    col[v]=c;\n    if(c==1)ret.fi++;\n    else ret.se++;\n    for(auto u:G[v]){\n        if(col[u]==c){\n            return pint(-1001001001,0);\n        }\n        if(col[u]==-c)continue;\n        pint p=dfs(u,-c);\n        ret.fi+=p.fi;\n        ret.se+=p.se;\n    }\n    return ret;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,M){\n        int a,b;\n        scanf(\"%lld %lld\",&a,&b);\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    vector<pint>vec;\n    rep(i,N)if(col[i]==0){\n        pint p=dfs(i,1);\n        if(p.fi<0){\n            puts(\"-1\");\n            return 0;\n        }\n        vec.pb(p);\n    }\n\n    bitset<100000>bs;\n    bs[0]=1;\n    rep(i,vec.size()){\n        bs=(bs<<vec[i].fi)|(bs<<vec[i].se);\n    }\n\n    int ma=0;\n    rep(i,N)if(bs[i])chmax(ma,i*(N-i)-M);\n    printf(\"%lld\\n\",ma);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef vector< vector<int> > Graph;\npii dfs(Graph &g, vector<int> &color, int v, int c){\n\tcolor[v] = c;\n\tpii res(c==1, c==-1);\n\tFOR(it, g[v]){\n\t\tif(color[*it] == c) return pii(-1, -1);\n\t\tpii ret(0, 0);\n\t\tif(!color[*it] && (ret = dfs(g, color, *it, -c)).first < 0) return pii(-1, -1);\n\t\tres.first += ret.first;\n\t\tres.second += ret.second;\n\t}\n\treturn res;\n}\n\nvector<pii> isBipartite(Graph &g){\n\tint n = g.size();\n\tvector<int> color(n);\n\tvector<pii> knap;\n\tREP(i, n){\n\t\tpii ret(0, 0);\n\t\tif(!color[i] && (ret = dfs(g, color, i, 1)).first < 0) return vector<pii>();\n\t\tif(ret.first || ret.second){\n\t\t\tknap.push_back(ret);\n\t\t}\n\t}\n\treturn knap;\n}\n\nll n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tGraph g(n);\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;u--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint ans;\n\tvector<pii> knap = isBipartite(g);\n\tif(knap.empty()) cout << -1 << endl;\n\telse{\n\t\tvi dp(n+1);\n\t\tdp[0] = 1;\n\t\tint sum = 0;\n\t\tREP(i, knap.size()){\n\t\t\tRREP(j, sum+1){\n\t\t\t\tint t = dp[j];\n\t\t\t\tdp[j] = 0;\n\t\t\t\tdp[j+knap[i].first] |= t;\n\t\t\t\tdp[j+knap[i].second] |= t;\n\t\t\t}\n\t\t\tsum += max(knap[i].first, knap[i].second);\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, sum+1) if(dp[i]) ans = max(ans, (ll)(i)*(n-i));\n\t\tcout << ans - m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< pii, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\n\tlint A = 0;\n\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tpii p = (*it).first;\n\t\tint a = p.second, c = (*it).second;\n\t\tA += p.first;\n\t\t\n\t\tfor_(j,0,N+1) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,N+1) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + (lint)a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[pii(a, b - a)];\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n    vector<int> d[2];\n    for (int i = 0; i < s[0].size(); i++) {\n        d[0].push_back(s[0][i].size());\n        d[1].push_back(s[1][i].size());\n    }\n\n    vector<vector<bool>> dp(d[0].size()+1, vector<bool>((N+3)/2));\n    dp[0][0] = true;\n    for (int i = 0; i < d[0].size(); i++) {\n        for (int j = dp[0].size()-1; j >= 0; j--) {\n            if (j >= d[0][i] && dp[i][j-d[0][i]]) dp[i+1][j] = true;\n            if (j >= d[1][i] && dp[i][j-d[1][i]]) dp[i+1][j] = true;\n        }\n    }\n\n    int ans = dp[0].size() - 1;\n    while (!dp[d[0].size()][ans]) ans--;\n\n    cout << ans * (N - ans) - M << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll v, e; cin >> v >> e;\n    vector<vector<int>> g(v);\n    rep(i, e) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    vector<int> used(v, -1);\n    vll diff;\n    rep(i, v) {\n        if (used[i] != -1) continue;\n//        cout << used << endl;\n        vll counter(2);\n        bool contradiction = false;\n        function<void(int, int)> f = [&](ll x, ll k){\n            if (used[x] != -1) {\n                if (used[x] != k % 2) {\n                    contradiction = true;\n                }\n                return;\n            }\n            used[x] = k % 2;\n            counter[k % 2]++;\n            for (int next : g[x]) {\n//                cout << x << \"->\" << next << endl;\n                f(next, k+1);\n            }\n        };\n        f(i, 0);\n        if (contradiction) {\n            cout << -1 << endl;\n            return 0;\n        }\n        diff.pb(abs(counter[0] - counter[1]));\n    }\n\n//    cout << diff << endl;\n\n    int n = diff.size();\n    const ll MAXD = 100010;\n    vector<int> dp(MAXD);\n    vector<int> dp_next(MAXD);\n    dp_next[0] = 1;\n\n    rep(d, n) {\n//        cout << d << endl;\n        swap(dp, dp_next);\n        rep(i, MAXD) {\n            dp_next[i] = 0;\n        }\n        rep(i, MAXD) if (dp[i]) {\n            dp_next[i+diff[d]] = 1;\n            dp_next[abs(i-diff[d])] = 1;\n        }\n    }\n    /*\n    rep(i, MAXD) {\n        if (dp_next[i]) {\n            cout << i << \" \";\n        }\n    }\n        cout << endl;\n        */\n\n    rep(i, MAXD) {\n        if (dp_next[i]) {\n            ll a = (v + i) / 2, b = (v - i) / 2;\n//            cout << a << \" \" << b << endl;\n            cout << a * b - e << endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V,E;\nvector<int> G[100005];\nvector<int> A,B;\nbool flg=false;\nbool visited[100005];\nint depth[100005];\nint cnt[2];\n\nvoid dfs(int pos,int d){\n  \n  if(visited[pos]){\n    if(depth[pos]!=d)flg=true;\n    return;\n  }\n  \n  visited[pos]=true;\n  depth[pos]=d;\n  cnt[d]++;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dfs(to,1-d);\n  }\n}\n\ntypedef long long ll;\nint dp[2][100005];\n\nint cc[100005];\n\nll solve(){\n  if(flg)return -1;\n  \n  map<int,int> mp;\n  int sum=0;\n  for(int i=0;i<(int)A.size();i++){\n    int mn=min(A[i],B[i]);\n    int mx=max(A[i],B[i]);\n    sum+=mn;\n    mp[mx-mn]++;\n  }\n  \n  dp[0][0]=1;\n  dp[1][0]=1;\n  \n  map<int,int>::iterator it;\n\n  int ai=0,bi=1;\n  for(it=mp.begin();it!=mp.end();it++){\n    swap(ai,bi);\n    \n    int a=it->first,b=it->second;\n    if(a==0)continue;\n    \n    \n    memset(cc,0,sizeof(cc));    \n    for(int i=0;i<=V;i++){\n      int k=0;\n      if(i-a>=0)k+=cc[i-a];\n      if(i-a*b-a>=0)k-=cc[i-a*b-a];\n      if(k>0)dp[ai][i]=1;\n      \n      cc[i]=dp[bi][i];\n      if(i-a>=0)cc[i]+=cc[i-a];\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<=V;i++){\n    if(dp[ai][i]){\n      ans=max(ans, (ll)(i+sum)*(ll)(V-i-sum) );\n    }\n  }\n  return ans-(ll)E;\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);    \n  }\n  for(int i=0;i<V;i++){\n    if(visited[i])continue;\n    cnt[0]=cnt[1]=0;\n    dfs(i,0);\n    A.push_back(cnt[0]);\n    B.push_back(cnt[1]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 100100;\ntypedef pair<int, int> P;\n\nvector<int> g[MN];\nbool used[MN];\nbool color[MN];\nint c0, c1;\nbool err;\nvoid dfs(int p, bool c) {\n    used[p] = true;\n    color[p] = c;\n    if (!c) c0++;\n    else c1++;\n    for (int d: g[p]) {\n        if (used[d]) {\n            if (color[p] == color[d]) err = true;\n            continue;\n        }\n        dfs(d, !c);\n    }\n}\n\nbitset<MN> b;\nll solve() {\n    int v, e;\n    cin >> v >> e;\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    b[0] = true;\n    for (int i = 0; i < v; i++) {\n        if (used[i]) continue;\n        c0 = c1 = 0;\n        dfs(i, 0);\n        if (err) return -1;\n        b |= (b<<c0) | (b<<c1);\n    }\n    ll sm = -1;\n    for (int i = 0; i < v; i++) {\n        if (!b[i]) continue;\n        sm = max(sm, (ll)(v-i)*i-e);\n    }\n    return sm;\n}\n\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint V, E;\nvector< vector<int> > graph;\nint color[100010];\n\nPi dfs(int u, int c) {\n  Pi res(0, 0);\n  color[u] = c;\n  if(c == 1) res.first++;\n  else res.second++;\n  for(int v : graph[u]) {\n    if(color[v] == c) return Pi(-1, -1);\n    if(color[v] == 0) {\n      Pi tmp = dfs(v, -c);\n      if(tmp.first < 0) return Pi(-1, -1);\n      res.first += tmp.first;\n      res.second += tmp.second;\n    }\n  }\n  return res;\n}\n\nmap<int, int> mp;\n\nint dp[100010]; // ?????°??¶???????????¨?????? ????????????????????¨?????¨??°??????????????£?????????????????¨?????¨??°???????????§?????????????????§????????????????????£??????????????????????????????????¢?????????????\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> V >> E;\n  resz(graph, V);\n  rep(i, E) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  mp.clear();\n  memset(color, 0, sizeof(color));\n  int v = 0; // ?????¨??°?????????????????§?????????????°??????¨??????????????§??????\n  rep(i, V) {\n    if(color[i] != 0) continue;\n    Pi p = dfs(i, 1);\n    int a = min(p.first, p.second);\n    int b = max(p.first, p.second);\n    if(a < 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    mp[b-a]++;\n    v += a;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for(auto p : mp) {\n    int plus = p.first, num = p.second;\n    rep(i, V+1) {\n      if(dp[i] >= 0) dp[i] = num;\n      else if(i < plus || dp[i-plus] <= 0) dp[i] = -1;\n      else dp[i] = dp[i-plus]-1;\n    }\n  }\n  int ans = 0;\n  rep(i, V+1) if(dp[i] >= 0) chmax(ans, (v+i)*(V-v-i));\n  cout << ans-E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint V, E;\nvector< vector<int> > graph;\nint color[100010];\n\nPi dfs(int u, int c) {\n  Pi res(0, 0);\n  color[u] = c;\n  if(c == 1) res.first++;\n  else res.second++;\n  for(int v : graph[u]) {\n    if(color[v] == c) return Pi(-inf, -inf);\n    if(color[v] == 0) {\n      Pi tmp = dfs(v, -c);\n      res.first += tmp.first;\n      res.second += tmp.second;\n    }\n  }\n  return res;\n}\n\nvector<Pi> vec;\nmap<int, int> mp;\n\nint dp[100010]; // ?????°??¶???????????¨??????\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> V >> E;\n  resz(graph, V);\n  rep(i, E) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    graph[a].push_back(b);\n    graph[b].push_back(a);\n  }\n\n  vec.clear();\n  mp.clear();\n  memset(color, 0, sizeof(color));\n  int v = 0; // ?????¨??°?????????????????§?????????????°??????¨??????????????§??????\n  rep(i, V) {\n    if(color[i] != 0) continue;\n    int a, b;\n    tie(a, b) = dfs(i, 1);\n    if(a < 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    tie(a, b) = minmax(a, b);\n    mp[b-a]++;\n    v += a;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for(auto p : mp) {\n    int plus = p.first, num = p.second;\n    if(plus == 0) continue;\n    rep(i, V+1) {\n      if(dp[i] >= 0) dp[i] = num;\n      else if(i < plus || dp[i-plus] <= 0) dp[i] = -1;\n      else dp[i] = dp[i-plus]-1;\n    }\n  }\n  int ans = 0;\n  rep(i, V+1) if(dp[i] >= 0) chmax(ans, (v+i)*(V-v-i));\n  cout << ans-E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nvector< int > g[100000];\nbool v[100000];\nint black, white;\n\nvoid dfs(int idx, bool pre)\n{\n  if(v[idx]++) return;\n  if(pre) ++black;\n  else ++white;\n  for(auto &to : g[idx]) dfs(to, 1 - pre);\n}\n\nint main()\n{\n  int V, E;\n  cin >> V >> E;\n  UnionFind tree(V + V);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n    tree.unite(a + V, b);\n    tree.unite(a, b + V);\n  }\n\n  for(int i = 0; i < V; i++) {\n    if(tree.find(i) == tree.find(i + V)) {\n      cout << -1 << endl;\n      return (0);\n    }\n  }\n\n  bitset< 50001 > dp;\n  dp[0] = 1;\n\n  for(int i = 0; i < V; i++) {\n    if(v[i]) continue;\n    black = white = 0;\n    dfs(i, 0);\n    dp = (dp << black) | (dp << white);\n  }\n\n  long long ret = 0;\n  for(int i = 0; i <= V / 2; i++) {\n    if(dp[i]) ret = max(ret, 1LL * i * (V - i));\n  }\n  cout << ret - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,int c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n\n  vertex.resize(n,-1);\n  vector<int> dis;\n  for(int i=0;i<chunk.size();i++){\n\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    dis.push_back(abs(cnt1-(chunk[i].size()-cnt1)));\n  }\n  int n2=1;\n  while(n2<n) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  int sum=accumulate(dis.begin(),dis.end(),0);\n  long long int res=0;\n  for(auto v:now[0]){\n    int dist=*now[0].lower_bound((sum+1)/2);\n    long long int b=(n+dist)/2;\n    long long int a=(n-dist)/2;\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\tsort(add.begin(),add.end());\n\n\t// knapsack\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tint ub=0;\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=min(ub,n/2-L_sum-add[i]);j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t\tub=max(ub,j+add[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",(ll)N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e18\n\nbool dfs(int now, const vector<vector<long long int> >& adj,\n         vector<long long int>& history, long long int& a, long long int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  long long int input_a, input_b;\n  vector<vector<long long int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  long long int a_sum = 0, b_sum = 0;\n  vector<long long int> c_tmp;\n  vector<long long int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      long long int a = 0;\n      long long int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<long long int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<long long int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<long long int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<long long int> dp(vector<long long int>(v + 1, -INF));\n  dp[0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[j] = dp[j] >= 0 ? c[i].second :\n        j >= c[i].first ? dp[j - c[i].first] - 1 : (int)INF * (-1);\n\n  int minpoint = -1;\n  long long int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[i] >= 0){\n      long long int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  long long int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\n#define int long long\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  int x=0;\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)){\n      if(a[1]) v.push_back(P(a[1],a[0]));\n      else x++;\n    }else return -1;\n  }\n  int k=0,m=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<V;j++){\n      if(dp[f][j])\n\tdp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1,\n\t  m=max(m,j+max(v[i].first,v[i].second));\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      for(int j=0;j<=x&&i+j<V;j++){\n\t//cout<<i+j<<\":\"<<(V-(i+j))*(i+j)<<endl;\n\tif((V-k)*k<(V-(i+j))*(i+j)) k=i+j;\n      }\n    }\n  }\n  return (V-k)*k-E;\n}\nsigned main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tvector<int> f(n); // G における頂点番号 -> 連結成分の番号\n\tvector<int> g(n); // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nvector<int> unify_ones(const vector<int> &a){\n\tvector<int> res;\n\tint one=0;\n\trep(i,a.size()){\n\t\tif(a[i]==1) one++;\n\t\telse        res.push_back(a[i]);\n\t}\n\n\tint two=1;\n\twhile(one>0){\n\t\tres.push_back(min(two,one));\n\t\tone-=min(two,one);\n\t\ttwo<<=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\n\t// add[i]==1 がたくさんあると部分和問題を解くのに時間がかかりすぎるので, 適当にまとめる ( 個数制約があるナップザックと同じ tips )\n\tadd=unify_ones(add);\n\n\t// knapsack DP\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=n/2-L_sum-add[i];j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\",N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\nstruct dsu {\n  int cc;\n  vector<int> p, sz;\n  dsu(int n = 0) : cc(n), p(n, -1), sz(n, 1) {}\n  int root(int v) const {\n    while (p[v] != -1) v = p[v];\n    return v;\n  }\n  bool unite(int u, int v) {\n    u = root(u), v = root(v);\n    if (u == v) return false;\n    --cc;\n    if (sz[u] < sz[v]) swap(u, v);\n    p[v] = u;\n    sz[u] += sz[v];\n    return true;\n  }\n  bool same(int u, int v) const { return root(u) == root(v); }\n  int size(int v) const { return sz[root(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  dsu d(n), b(2 * n + 1);\n  long long res = -m;\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    d.unite(u, v);\n    b.unite(u, n + v);\n    b.unite(n + u, v);\n  }\n  for (int v = 0; v < n; ++v) {\n    if (b.same(v, n + v)) {\n      cout << \"-1\\n\";\n      exit(0);\n    }\n    if (b.same(v, 2 * n) or b.same(n + v, 2 * n)) continue;\n    b.unite(v, 2 * n);\n  }\n  vector<int> x(n), y(n);\n  for (int v = 0; v < n; ++v) {\n    if (b.same(v, 2 * n)) {\n      ++x[d.root(v)];\n    } else {\n      ++y[d.root(v)];\n    }\n  }\n  bitset<100001> dp;\n  dp[0] = 1;\n  for (int v = 0; v < n; ++v) {\n    if (v != d.root(v)) continue;\n    dp = dp << x[v] | dp << y[v];\n  }\n  for (int i = n / 2; ; --i) {\n    if (dp[i]) {\n      assert(dp[n - i]);\n      res += (long long)i * (n - i);\n      break;\n    }\n  }\n  cout << res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll ,P> P3;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint v, e, used[MAX_N], cnt[2]{}, dif[MAX_N];\nvector<vector<int> > g;\nbitset<MAX_N*2> dp;\n\nbool dfs(int i, int c){\n    used[i] = c;\n    cnt[c]++;\n    bool res = true;\n    for(auto to : g[i]){\n        if(used[to] < 0){\n            res &= dfs(to,c^1);\n        }\n        else{\n            res &= used[to] != c;\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin >> v >> e;\n    g.resize(v);\n    REP(i,e){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // 二部グラフ判定\n    bool ok = true;\n    fill(used,used+v,-1);\n    REP(i,v){\n        if(used[i]<0){\n            ok &= dfs(i,0);\n            dif[abs(cnt[0]-cnt[1])]++;\n            cnt[0] = cnt[1] = 0;\n        }\n    }\n    if(ok){\n        dp.set(v);  // 差分を調整してある数を作れるか\n        vector<int> ls;\n        for(int i=1;i<v;i++){  // 差分の種類はsqrt(V)程度なので圧縮できる\n            int m=1;\n            while(dif[i]>=m){\n                ls.push_back(i*m);\n                dif[i] -= m;\n                m*=2;\n            }\n            if(dif[i]>0) ls.push_back(i*dif[i]);\n        }\n        for(auto i : ls){\n            dp = dp<<i | dp>>i;\n        }\n        ll ans = 0;\n        REP(i,v){\n            if(dp[i+v]) ans = max(ans,ll(v-i)/2*ll((v-i)/2+i));\n        }\n        cout << ans - e << endl;\n    }\n    else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nvoid dfs2(VVI& G, int u, vector<bool>& vis, VI& parity, PLL& ps, LL& ans){\n  vis[u] = true;\n  if(parity[u] > 0)\n\tans += ps.SS - SZ(G[u]);\n  else{\n\tans += ps.FF - SZ(G[u]);\n  }\n  \n  for(int to: G[u]){\n\tif(vis[to]) continue;\n\tdfs2(G, to, vis, parity, ps, ans);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n  vector<PLL> xs;\n  vector<bool> vis(V);\n  VI parity(V);\n  LL ans = 0;\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  LL tmp = 0;\n\t  dfs2(G, i, vis, parity, res, tmp);\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs.EB(res);\n\t  ans += tmp / 2;\n\t}\n  }\n\n  sort(ALL(xs), [](const PLL& p1, const PLL& p2){\n\t  return p1.FF+p1.SS < p2.FF+p2.SS;\n\t});\n  while(SZ(xs) > 1){\n\tPLL p1 = xs.back(); xs.pop_back();\n\tPLL p2 = xs.back(); xs.pop_back();\n\tif(p1.FF*p2.FF + p1.SS*p2.SS > p1.FF*p2.SS + p1.SS*p2.FF){\n\t  ans += p1.FF*p2.FF + p1.SS*p2.SS;\n\t  xs.EB(p1.FF+p2.SS, p1.SS+p2.FF);\n\t}\n\telse{\n\t  ans += p1.FF*p2.SS + p1.SS*p2.FF;\n\t  xs.EB(p1.FF+p2.FF, p1.SS+p2.SS);\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <map>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint V, E;\nvector<llint> G[100005];\nllint color[100005];\nmap<llint, llint> mp;\nllint dp[2][100005];\n\nP dfs(int v, int prev, int c)\n{\n\tcolor[v] = c;\n\tP ret = make_pair(0, 0);\n\tif(c == 1) ret.first++;\n\telse ret.second++;\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tif(color[G[v][i]]){\n\t\t\tif(color[G[v][i]] != -c) return make_pair(-1, -1);\n\t\t\telse continue;\n\t\t}\n\t\tP res = dfs(G[v][i], v, -c);\n\t\tif(res.first == -1) return make_pair(-1, -1);\n\t\tret.first += res.first;\n\t\tret.second += res.second;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> V >> E;\n\tllint a, b;\n\tfor(llint i = 0; i < E; i++){\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\t\n\tllint goal = 0;\n\tfor(llint i = 1; i <= V; i++){\n\t\tif(color[i]) continue;\n\t\tP res = dfs(i, -1, 1);\n\t\tif(res.first == -1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tgoal += abs(res.first - res.second);\n\t\tmp[2 * abs(res.first - res.second)]++;\n\t}\n\tllint N = mp.size();\n\t\n\tfor(llint j = 0; j <= V; j++){\n\t\tdp[0][j] = dp[1][j] = -1;\n\t}\n\tdp[0][0] = 0;\n\t\n\tauto it = mp.begin();\n\tfor(llint i = 1; i <= N; i++){\n\t\tfor(llint j = 0; j <= V; j++){\n\t\t\tif(dp[(i+1)%2][j] >= 0) dp[i%2][j] = max(dp[i%2][j], it->second);\n\t\t\tif(j - it->first >= 0){\n\t\t\t\tif(dp[i%2][j - it->first] >= 1) dp[i%2][j] = max(dp[i%2][j], dp[i%2][j - it->first] - 1);\n\t\t\t}\n\t\t}\n\t\tit++;\n\t}\n\t\n\tllint close_val = inf, close_i;\n\tfor(llint i = 0; i <= V; i++){\n\t\tif(dp[N%2][i] < 0) continue;\n\t\tif(close_val > abs(goal - i)){\n\t\t\tclose_val = abs(goal - i);\n\t\t\tclose_i = i;\n\t\t}\n\t}\n\t\n\tllint black = (close_i - goal + V) / 2;\n\tllint ans = black * (V - black) - E;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[N][2], nx[N][2];\nint dp2[N], nx2[N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0] = 0;\n    for(int i=1; i<B; ++i){\n        memset(nx,-1,sizeof(nx));\n\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[j][0]>=0){\n            pq.push({C,{j,C%2}});\n            nx[j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int idx = abs(p.fi+j*i);\n\n                if(idx<N && nx[idx][!p.se] < now.fi-1){\n                    nx[idx][!p.se] = now.fi-1;\n                    pq.push({nx[idx][!p.se], {idx,!p.se}});\n                }\n            }\n        }\n\n        rep(j,N)rep(k,2) dp[j][k] = nx[j][k];\n    }\n    rep(i,N)if(dp[i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0] = 1;\n    rep(i,L){\n        memset(nx2,0,sizeof(nx2));\n        rep(j,N)if(dp2[j]){\n            for(int k=-1; k<=1; k+=2){\n                int idx = abs(j+k*l[i]);\n                if(idx<N) nx2[idx] = 1;\n            }\n        }\n\n        rep(j,N) dp2[j] = nx2[j];\n    }\n    rep(i,N)if(dp2[i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int a=-1; a<=1; ++a){\n            int j = idx + a;\n            if(0<=j && j<sz){\n                int dd = abs(i-Sd[j]);\n                if(n-dd>0){\n                    // assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,M;\nvector<int> g[100010];\nint p[100010];\nvector<int> ds;\nint c0,c1;\nint dp[100010];\nll sum=0;\n\nbool dfs(int v,int pari){\n  p[v]=pari;\n  if(pari==0)c0++;\n  else c1++;\n  bool ok=true;\n  for(int nv : g[v]){\n    if(p[v]==p[nv])ok=false;\n    else{\n      if(p[nv]==-1&&!dfs(nv,1-pari))ok=false;\n    }\n  }\n  return ok;\n}\n\nint main(){\n  cin>>N>>M;\n  rep(i,M){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  memset(p,-1,sizeof(p));\n  rep(i,N){\n    if(p[i]!=-1)continue;\n    c0=0;\n    c1=0;\n    if(!dfs(i,0)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ds.push_back(abs(c0-c1));\n    sum+=abs(c0-c1);\n  }\n  sort(all(ds));\n  vector<int> a,m;\n  rep(i,ds.size()){\n    int j=i;\n    a.push_back(ds[i]);\n    int cnt=1;\n    while(j<ds.size()&&ds[j]==ds[i]){\n      j++;\n    }\n    m.push_back(cnt);\n    i=j-1;\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  rep(i,a.size()){\n    rep(j,N+1){\n      if(dp[j]>=0)dp[j]=m[i];\n      else if(j<a[i]||dp[j-a[i]]<=0)dp[j]=-1;\n      else dp[j]=dp[j-a[i]]-1;\n    }\n  }\n\n  ll res=-INF;\n  rep(j,N+1){\n    if(dp[j]<0)continue;\n    ll d=abs(sum-2*j);\n    ll x=(N+d)/2,y=(N-d)/2;\n    assert(x+y==N);\n    maxch(res,x*y-M);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\npair<int, int> dfs(vector<vector<int>> &g, int v, vector<int> &bs, int b, int &f){\n\tpair<int, int> ans(0, 0);\n\tif(bs[v] != -1){\n\t\tif(bs[v] != b){\n\t\t\tf = 1;\n\t\t}\n\t}\n\telse{\n\t\tbs[v] = b;\n\t\tif(b == 0){\n\t\t\tans.first++;\n\t\t}\n\t\telse{\n\t\t\tans.second++;\n\t\t}\n\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\tpair<int, int> res = dfs(g, g[v][i], bs, 1 - b, f);\n\t\t\tans.first += res.first;\n\t\t\tans.second += res.second;\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tint N, M, a, b, i;\n\tscanf(\"%lld%lld\", &N, &M);\n\tvector<vector<int>> g(N, vector<int>(0));\n\tfor(i = 0; i < M; i++){\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<int> bs(N, -1);\n\tvector<pair<int, int>> ps(0);\n\tint f = 0;\n\tfor(i = 0; i < N; i++){\n\t\tif(bs[i] == -1){\n\t\t\tps.push_back(dfs(g, i, bs, 0, f));\n\t\t\tif(f == 1){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i = 0; i < ps.size(); i++){\n\t\tprintf(\"(%lld, %lld)\\n\", ps[i].first, ps[i].second);\n\t}\n*/\tbitset<50001> dp(1);\n\tfor(i = 0; i < ps.size(); i++){\n\t\tdp = ((dp << ps[i].first) | (dp << ps[i].second));\n\t}\n\tint near_half = 0;\n\tfor(i = 0; i <= N / 2; i++){\n\t\tif(dp[i] == 1){\n\t\t\tnear_half = max(near_half, i);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", near_half * (N - near_half) - M);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  REP(i,cnt) {\n    sum[2*i] = 2 * abs(sum[2*i]);\n  }\n  int twice = 0;\n  REP(i,cnt) twice += sum[2*i];\n  vector<bool> dp(2*v+1);\n  dp[0] = 1;\n  REP(i,cnt) {\n    auto tmp = dp;\n    REP(j,2*v-sum[2*i]+1) {\n      if (dp[j])\n        tmp[j+sum[2*i]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,2*v+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int smaller = v/2 - mn/2;\n  int larger = v - smaller;\n  int m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nlli n,m;\nvector<int> vs[100005];\n\n\nint gone[100005];\n\nvoid dfs(int no,int &p,int& q,int c){\n\tgone[no] = c;\n\tint tc=3-c;\n\trep(i,vs[no].size()){\n\t\tint to = vs[no][i];\n\t\tif(gone[to]){\n\t\t\tif(gone[to]!=tc){\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to,p,q,tc);\n\t}\n\tif(c==1)p++;\n\telse q++;\n}\n\n\nint tn[100005]={};\n\n\nint dpn=1;\nint dp[1005][100005]={};\n\nint main(void){\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b); a--; b--;\n\t\tvs[a].push_back(b);\n\t\tvs[b].push_back(a);\n\t}\n\t\n\tlli ds = 0;\n\trep(i,n){\n\t\tif(gone[i])continue;\n\t\tint p=0,q=0;\n\t\tdfs(i,p,q,1);\n\t\tds += abs(p-q);\n\t\ttn[abs(p-q)]++;\n\t}\n\t\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0]=0;\n\trep(i,n+1){\n\t\tif(!tn[i])continue;\n\t\t//printf(\"%d : %d\\n\",i,tn[i]);\n\t\trep(j,n+3){\n\t\t\tif(dp[dpn-1][j]>=0)dp[dpn][j]=tn[i];\n\t\t\telse if(j<i || dp[dpn][j-i]<=0);\n\t\t\telse{\n\t\t\t\tdp[dpn][j] = dp[dpn][j-i]-1;\n\t\t\t}\n\t\t\t//printf(\"dp[%d][%d] :: %d ,, %d %d\\n\",dpn,j,dp[dpn][j],dp[dpn-1][j],dp[dpn][j-i]);\n\t\t}\n\t\tdpn++;\n\t}\n\t\n\t\n\tlli mt = IINF;\n\trep(i,n+3){\n\t\tif(dp[dpn-1][i]>=0)mt = min(mt,abs(i-(ds-i)));\n\t}\n\t\n\t//printf(\"mt %lld\\n\",mt);\n\t\n\tprintf(\"%lld\\n\",((n+mt)/2)*((n+mt)/2-mt)-m);\n\t\n\t\n\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nint dfs(int p, vector<vector<int>>& edge, vector<int>& col) {\n    int ret = (col[p] ? 1 : -1);\n    for (int i : edge[p]) {\n        if (col[i] == col[p])\n            return M;\n        if (col[i] == 1 - col[p])\n            continue;\n\n        col[i] = col[p] ^ 1;\n        int t = dfs(i, edge, col);\n        if (t == M)\n            return M;\n\n        ret += t;\n    }\n    return ret;\n}\n\nint main() {\n    int v, e;\n    cin >> v >> e;\n    vector<vector<int>> edge(v);\n    for (int i = 0; i < e; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> col(v, -1);\n    vector<int> pm;\n    int sum = 0, c1 = 0;\n    for (int i = 0; i < v; ++i) {\n        if (col[i] == -1) {\n            col[i] = 0;\n            int t = dfs(i, edge, col);\n            if (t == M) {\n                cout << \"-1\\n\";\n                return 0;\n            }\n            if (t < 0) t = -t;\n            if (t == 1) ++c1;\n            sum += t;\n            if (t > 0) pm.push_back(t);\n        }\n    }\n    if (c1 >= sum / 2) {\n        long long a = v / 2;\n        long long b = v - a;\n        cout << (a * b - e) << \"\\n\";\n        return 0;\n    }\n    vector<int> dp(sum + 1, 0);\n    dp[0] = 1;\n    for (int i : pm) {\n        for (int j = sum; j >= i; --j) {\n            dp[j] |= dp[j - i];\n        }\n    }\n    long long ma = 0;\n    long long vv = (v - sum) / 2;\n    for (int i = 0; i <= sum; ++i) {\n        if (dp[i]) {\n            ma = max(ma, (vv + i) * (vv + sum - i));\n        }\n    }\n    cout << (ma - e) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nbool flag;\nint visit[MAX_N];\n\nvoid dfs(int u,int k,int& s,int& t)\n{\n    visit[u] = k;\n    if(k > 0){\n        s++;\n    }else{\n        t++;\n    }\n    rep(i,len(G[u])){\n        if(visit[G[u][i]] == 0){\n            dfs(G[u][i],-k,s,t);\n            if(flag){\n                return;\n            }\n        }else if(visit[G[u][i]] == k){\n            flag = true;\n            return;\n        }\n    }\n}\n\nmap<int,int> mp;\nbool dp[MAX_N];\n\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    rep(i,m){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a-1].pb(b-1),G[b-1].pb(a-1);\n    }\n    vector<P> vec;\n    rep(i,n){\n        if(visit[i] == 0){\n            int r1 = 0,r2 = 0;\n            dfs(i,1,r1,r2);\n            if(flag){\n                cout << \"-1\\n\";\n                return 0;\n            }\n            vec.pb(P(r1,r2));\n        }\n    }\n    int sm = 0,al = 0;\n    rep(i,len(vec)){\n        sm += min(vec[i].fi,vec[i].se);\n        al += max(vec[i].fi,vec[i].se);\n        if(abs(vec[i].fi-vec[i].se) != 0){\n            mp[abs(vec[i].fi-vec[i].se)]++;\n        }\n    }\n    dp[0] = true;\n    each(it,mp){\n        int num = it.se;\n        for(int i=1;num>0;i<<=1){\n            int mul = min(i,num);\n            for(int j=al-sm;j>=it.fi*mul;j--){\n                if(dp[j-it.fi*mul]){\n                    dp[j] = true;\n                }\n            }\n            num -= mul;\n        }\n    }\n    int mn = INF;\n    rep(i,al-sm+1){\n        if(dp[i]){\n            cmn(mn,max(sm+i,al-i));\n        }\n    }\n    if(n % 2 == 0){\n        if(mn <= n/2){\n            cout << (ll)n*n/2/2 - m << \"\\n\";\n        }else{\n            cout << (ll)mn*(n-mn) - m << \"\\n\";\n        }\n    }else{\n        if(mn <= (n+1)/2){\n            cout << (ll)(n-1)*(n+1)/2/2 - m << \"\\n\";\n        }else{\n            cout << (ll)mn*(n-mn) - m << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 10;\n// const int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[B][N][2];\nint dp2[B][N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0][0] = 0;\n    for(int i=1; i<B; ++i){\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[i-1][j][0]>=0){\n            pq.push({C,{j,C%2}});\n            dp[i][j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int nx = abs(p.fi+j*i);\n\n                if(dp[i][nx][!p.se] < dp[i][p.fi][p.se]-1){\n                    dp[i][nx][!p.se] = dp[i][p.fi][p.se]-1;\n                    pq.push({dp[i][nx][!p.se], {nx,!p.se}});\n                }\n            }\n        }\n    }\n    rep(i,N)if(dp[B-1][i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0][0] = 1;\n    que.push({0,0});\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        int idx = now.fi;\n        int val = now.se;\n        if(idx == L) continue;\n\n        for(int i=-1; i<=1; i+=2){\n            int nx = abs(val+i*l[idx]);\n            if(!dp2[idx+1][nx]){\n                dp2[idx+1][nx] = 1;\n                que.push({idx+1, nx});\n            }\n        }\n    }\n    rep(i,N)if(dp2[L][i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int j=-1; j<=1; ++j){\n            int nx = idx + j;\n            if(0<=nx && nx<sz){\n                int dd = abs(i-Sd[nx]);\n                if(n-dd>0){\n                    // assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool ok = true;\n\nint f(int u, int x, vector<vector<int> >& G, vector<int>& vis) {\n\tvis[u] = x;\n\tint sum = 1;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (vis[v] == x) ok = false;\n\t\tif (vis[v] != -1) continue;\n\t\tsum -= f(v, !x, G, vis);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvector<int> vis(N, -1);\n\tint n = 0;\n\tvector<int> a(N + 1);\n\tfor (int u = 0; u < N; u++)\n\t\tif (vis[u] == -1) {\n\t\t\tint x = abs(f(u, 0, G, vis));\n\t\t\tn += x;\n\t\t\ta[x]++;\n\t\t}\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<bool> dp(n + 1);\n\tdp[0] = true;\n\tfor (int x = 1; x <= N; x++)\n\t\tfor (int y = 1; a[x]; y *= 2) {\n\t\t\tint z = min(a[x], y);\n\t\t\ta[x] -= z;\n\t\t\tfor (int k = n; k - z >= 0; k--)\n\t\t\t\tif (dp[k - z])\n\t\t\t\t\tdp[k] = true;\n\t\t}\n\tll ma = 0;\n\tfor (int k = 0; k <= n; k++)\n\t\tma = max(ma, (ll)((N - n) / 2 + k) * ((N - n) / 2 + (n - k)));\n\tcout << ma - M << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nvector<int> check;\n\nbool solve(int curr, int color, vector<int>& x)\n{\n    check[curr] = color;\n    ++ x[color];\n\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        int next = edges[curr][i];\n        if(check[next] == color)\n            return false;\n\n        if(check[next] == -1){\n            if(!solve(next, color^1, x))\n                return false;\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    int v, e;\n    cin >> v >> e;\n\n    edges.assign(v, vector<int>());\n    for(int i=0; i<e; ++i){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    check.assign(v, -1);\n    bitset<50001> bs;\n    bs[0] = true;\n\n    for(int i=0; i<v; ++i){\n        if(check[i] != -1)\n            continue;\n\n        vector<int> x(2, 0);\n        if(!solve(i, 0, x)){\n            cout << -1 << endl;\n            return 0;\n        }\n\n        bs |= (bs << x[0]) | (bs << x[0]);\n    }\n\n    int a = v / 2;\n    while(!bs[a])\n        -- a;\n    int b = v - a;\n\n    long long ret = (long long)a * b;\n    ret -= e;\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,bool c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n  \n  vertex.resize(n,-1);\n  vector<int> dis;\n  for(int i=0;i<chunk.size();i++){\n\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    dis.push_back(abs(cnt1-int((chunk[i].size()-cnt1))));\n  }\n  int n2=1;\n  while(n2<chunk.size()) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n    assert(now.size()==n2);\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  int sum=accumulate(dis.begin(),dis.end(),0);\n  long long int res=0;\n  for(auto v:now[0]){\n\n    int dist=v;\n    long long int b=(n+dist)/2;\n    long long int a=(n-dist)/2;\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, part_cnt[100010], dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc(lint A) {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\t\n\tfor (int a = 0; a <= N; ++a) {\n\t\tint c = part_cnt[a];\n\t\tif (c == 0) continue;\n\t\t\n\t\tfor_(j,0,N+1) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,N+1) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\tmemset(part_cnt, 0, sizeof(part_cnt));\n\t\n\tbool flag = true;\n\tlint A = 0;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[b - a];\n\t\tA += a;\n\t}\n\t\t\n\tcout << (!flag ? -1 : calc(A) - M) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>g[110000];\nvector<int>v;\nint color[110000];\nbool ok=true;\nint B,W;\nvoid dfs(int a,int b){\n\tcolor[a]=b;\n\t//printf(\"%d %d\\n\",a,b);\n\tif(b)B++;\n\telse W++;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(!~color[g[a][i]]){\n\t\t\tdfs(g[a][i],!b);\n\t\t}else if(color[g[a][i]]==b){\n\t\t\tok=false;\n\t\t}\n\t}\n}\nint sg[310];\nint dp[2][110000];\nint dp2[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tfor(int i=0;i<a;i++)color[i]=-1;\n\tint now=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(!~color[i]){\n\t\t\tB=W=0;\n\t\t\tdfs(i,0);\n\t\t\tnow+=min(B,W);\n\t\t\tif(max(B,W)-min(B,W)<300)sg[max(B,W)-min(B,W)]++;\n\t\t\telse v.push_back(max(B,W)-min(B,W));\n\t\t}\n\t}\n\tif(!ok){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<110000;i++)dp[0][i]=dp[1][i]=-1;\n\tdp[1][0]=0;\n\tfor(int i=1;i<300;i++){\n\t\tint f=i%2;\n\t\tfor(int j=0;j<110000;j++){\n\t\t\tif(~dp[f][j])dp[!f][j]=0;\n\t\t\telse dp[!f][j]=-1;\n\t\t}\n\t\tfor(int j=0;j<110000;j++){\n\t\t\tif(j-i>=0&&~dp[!f][j-i]&&dp[!f][j-i]<sg[i]){\n\t\t\t\tif(!~dp[!f][j])dp[!f][j]=dp[!f][j-i]+1;\n\t\t\t\telse dp[!f][j]=min(dp[!f][j],dp[!f][j-i]+1);\n\t\t\t}\n\t\t}\n\t/*\tif(i<5){\n\t\t\tfor(int j=0;j<20;j++)printf(\"%d \",dp[!f][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\tfor(int i=0;i<110000;i++)if(~dp[0][i])dp2[i]=1;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=109999;j>=v[i];j--){\n\t\t\tdp2[j]|=dp2[j-v[i]];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<110000;i++){\n\t\tif(dp2[i]){\n\t\t\tret=max(ret,(long long)(now+i)*(a-now-i)-b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\nint c(int k){\n\tpriority_queue<int> que;\n\tque.push(k);\n\tfor(int a : vec){\n\t\tque.push(a);\n\t}\n\twhile(que.size() >= 2){\n\t\tint t1 = que.top();\n\t\tque.pop();\n\t\tint t2 = que.top();\n\t\tque.pop();\n\t\tque.push(t1 - t2);\n\t}\n\treturn que.top();\n}\n\nint binary(){\n\tfor(int i = 0;i <= v;i++){\n\t\tif(c(i) == 0){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tbitset<101010> bit(1);\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbit = (bit << p.first) | (bit << p.second);\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor(int i = 0;i < v;i++){\n\t\tif(bit[i])res = max(res, i * (v - i) - e);\n\t}\n\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef vector<int> Edges;\ntypedef vector<Edges> Graph;\n\nint n, m;\nint color[100010];\nbitset<100010> ok[2];\nGraph g;\n\nbool dfs(int from, int c, int &cnt1, int &cnt2) {\n  if (color[from] != -1) { return color[from] == c; }\n  color[from] = c;\n  if (c == 1) { cnt1++; }\n  else { cnt2++; }\n  bool ret = true;\n  FORIT(it, g[from]) {\n    int to = *it;\n    ret &= dfs(to, c ^ 1, cnt1, cnt2);\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    MEMSET(color, -1);\n    g = Graph(n);\n    REP(i, m) {\n      int f, t;\n      scanf(\"%d %d\", &f, &t);\n      f--; t--;\n      g[f].push_back(t);\n      g[t].push_back(f);\n    }\n    int base = 0;\n    map<int, int> cnt;\n    REP(i, n) {\n      if (color[i] != -1) { continue; }\n      int c1 = 0;\n      int c2 = 0;\n      if (!dfs(i, 0, c1, c2)) {\n        goto ng;\n      }\n      base += min(c1, c2);\n      if (c1 == c2) { continue; }\n      cnt[max(c1, c2) - min(c1, c2)]++;\n    }\n    {\n      ll ans = 0;\n      ok[0].reset();\n      ok[1].reset();\n      ok[0][0] = 1;\n      int prev = 0;\n      int next = 1;\n      FORIT(it, cnt) {\n        int v = it->first;\n        int c = it->second;\n        REP(start, v) {\n          int rest = 0;\n          for (int i = start; i < n; i += v) {\n            if (ok[prev][i]) {\n              ok[next][i] = 1;\n              rest = c;\n            } else if (rest > 0) {\n              ok[next][i] = 1;\n              rest--;\n            }\n          }\n        }\n        swap(prev, next);\n      }\n      ok[0] |= ok[1];\n      REP(i, n) {\n        if (!ok[0][i]) { continue; }\n        ll left = base + i;\n        ll right = n - left;\n        ans = max(ans, left * right - m);\n      }\n      printf(\"%lld\\n\", ans);\n    }\n    continue;\nng:\n    puts(\"-1\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N, M;\nvector<vector<int>> E;\n\nint color[100001];\n\nvoid dfs(int pos, int bef, bool now_color, pair<int, int>& cnt) {\n\tcolor[pos] = now_color ? 1 : 2;\n\tif (now_color)cnt.first++;\n\telse cnt.second++;\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint nxt = E[pos][i];\n\t\tif (nxt == bef)continue;\n\t\tif (color[nxt] != 0 && color[nxt] + color[pos] != 3) {\n\t\t\t//二部グラフではない\n\t\t\tcnt.first -= 114514, cnt.second -= 114514;\n\t\t\tbreak;\n\t\t}\n\t\tif (color[nxt] == 0) {\n\t\t\tdfs(nxt, pos, !now_color, cnt);\n\t\t}\n\t}\n}\n\nint main() {\n\n\tcin >> N >> M;\n\t\n\tE.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\n\tmap<int, int> element_m;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (color[i] == 0) {\n\t\t\tpair<int, int> tmp;\n\t\t\tdfs(i, -1, true, tmp);\n\t\t\tif (tmp.first < 0 && tmp.second < 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telement_m[abs(tmp.first - tmp.second)]++;\n\t\t}\n\t}\n\n\tvector<pair<int, int>> element;\n\tfor (auto it = element_m.begin(); it != element_m.end(); it++)element.push_back((*it));\n\tvector<int> dp(2 * N + 100, -1);\n\n\tint geta = 0;\n\tdp[0] = 0;\n\tfor (int i = 0; i < element.size(); i++) {\n\t\tgeta += element[i].second * element[i].first;\n\t\tfor (int j = 0; j <= 2 * N; j++) {\n\t\t\tif (dp[j] >= 0)dp[j] = element[i].second;\n\t\t\telse if (j < 2 * element[i].first || dp[j - 2 * element[i].first] == -1)\n\t\t\t\tdp[j] = -1;//そのまま\n\t\t\telse dp[j] = dp[j - 2 * element[i].first] - 1;\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (ll i = 0; i <= 2 * N; i++) {\n\t\tif (dp[i] >= 0) {\n\t\t\tll diff = abs(i - geta);\n\t\t\tans = max(ans, ((N - diff) / 2) * ((N - diff) / 2 + diff) - M);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] < CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[Bipartite[CitySet[i][j]]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n// nums[i] := i 番目の連結成分の {左ノード数, 右ノード数}, 「dir = 1: 左、-1: 右」\nusing pint = pair<int,int>;\nusing Graph = vector<vector<int> >;\n\nbool dfs(const Graph &G, int v, int vdir, pint &num, vector<int> &dir) {\n    bool res = true;\n    dir[v] = vdir;\n    if (vdir == 1) ++num.first;\n    else if (vdir == -1) ++num.second;\n    for (auto nv : G[v]) {\n        if (dir[nv] == 0) {\n            if (!dfs(G, nv, -vdir, num, dir)) res = false;\n        }\n        else if (dir[nv] != -vdir) res = false;\n    }\n    return res;\n}\n\nbool isbipartite(const Graph &G, vector<pint> &nums) {\n    bool res = true;\n    int N = (int)G.size();\n    vector<int> dir(N, 0);\n    for (int v = 0; v < N; ++v) {\n        if (dir[v] != 0) continue;\n        pint num = {0, 0};\n        if (!dfs(G, v, 1, num, dir)) res = false;\n        nums.push_back(num);\n    }\n    return res;\n}\n\nconst int INF = 1<<29;\n\nint main() {\n    int V, E; cin >> V >> E;\n    Graph G(V);\n    for (int i = 0; i < E; ++i) {\n        int a, b; cin >> a >> b; --a, --b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    \n    // 二部グラフ判定して、左ノード数と右ノード数の差分ごとに集計\n    vector<pint> nums;\n    if (!isbipartite(G, nums)) {\n        cout << -1 << endl;\n        return 0;\n    }\n    map<int,int> ma;\n    for (auto p : nums) ma[abs(p.first - p.second)]++;\n    \n    // DP\n    int geta = 0;\n    vector<int> dp(V*2+10, INF);\n    dp[0] = 0;\n    for (auto it = ma.begin(); it != ma.end(); ++it) {\n        int diff = it->first;\n        geta += diff * it->second;\n        for (int v = 0; v <= V*2; ++v) {\n            if (dp[v] < INF) dp[v] = 0;\n        }\n        for (int v = 0; v <= V*2; ++v) {\n            if (v + diff * 2 <= V*2 && dp[v] < it->second) chmin(dp[v + diff*2], dp[v] + 1);\n        }\n    }\n\n    // 集計\n    int diff = V;\n    for (int v = 0; v <= V*2; ++v) {\n        if (dp[v] < INF) diff = min(diff, abs(v-geta));\n    }\n    long long a = (V + diff)/2, b = (V - diff)/2;\n    cout << a * b - E << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<bitset>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for(int i=m;i<(int)(n);i++)\ntypedef pair<int,int> pint;\ntypedef long long ll;\nconst int inf   = 1<<30;\nconst ll  longinf = 1LL<<60;\nconst int mod=1e9+7;\nint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\nvector<int> v[100001];\nint cnt,used[100001];\nbool nibu;\n\nvoid dfs(int x,int flag){\n  if(flag==1)cnt++;\n  else cnt--;\n  rep(i,v[x].size()){\n    if(used[v[x][i]]==flag){\n      nibu=false;\n      return;\n      }\n    if(used[v[x][i]]==-1){\n      used[v[x][i]]=1-flag;\n      dfs(v[x][i],1-flag);\n      }\n    }\n  }\n\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y;\n    x--;y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n    }\n  rep(i,n)used[i]=-1;\n  int num=0;\n  vector<int> e;\n  rep(i,n){\n    if(used[i]==-1){\n      used[i]=1;\n      cnt=0;\n      nibu=true;\n      dfs(i,1);\n      if(!nibu){cout<<-1<<endl;return 0;}\n      if(abs(cnt)>1)e.push_back(abs(cnt));\n      if(abs(cnt)==1)num++;\n      }\n    }\n  bitset<2000001> b;\n  b=1;\n  b=b<<100000;\n  rep(i,e.size())b=(b<<e[i])|(b>>e[i]);\n  rep(i,100001){\n    if(b[100000+i]){\n      ll ma,mi,d;\n      if(i>num)d=ll(i-num);\n      else d=(ll)(num-i)%2;\n      ma=(ll)(d+n)/2;\n      mi=(ll)(n-d)/2;\n      cout<<ma*mi-m<<endl;\n      return 0;\n      }\n    }\n  return 0;    \n  }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\nint c(int k){\n\tpriority_queue<int> que;\n\tque.push(k);\n\tfor(int a : vec){\n\t\tque.push(a);\n\t}\n\twhile(que.size() >= 2){\n\t\tint t1 = que.top();\n\t\tque.pop();\n\t\tint t2 = que.top();\n\t\tque.pop();\n\t\tque.push(t1 - t2);\n\t}\n\treturn que.top();\n}\n\nint binary(){\n\tfor(int i = 0;i <= v;i++){\n\t\tif(c(i) == 0){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tif(e == 0){\n\t\tcout << 0 << endl;\n\t}\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tbitset<101010> bit(1);\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbit = (bit << p.first) | (bit << p.second);\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor(int i = 0;i < v;i++){\n\t\tif(bit[i])res = max(res, i * (v - i) - e);\n\t}\n\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<int> g[100000];\nint n,m;\n\nint color[100000];\n\nint c1,c2;\nbool dfs(int v, int c) {\n  color[v] = c;\n  if (c == 1) c1++;\n  else c2++;\n  FOR(it, g[v]) {\n    if (color[*it] == c) return 0;\n    if (color[*it] == 0 && !dfs(*it,-c)) return 0;\n  }\n  return 1;\n}\n\nint dp[100001];\nll ans;\nbool solve() {\n  map<int,int> mp;\n  int summin = 0;\n  int sumdiff = 0;\n  REP(i,n) {\n    if (color[i] == 0) {\n      c1 = 0, c2 = 0;\n      if (!dfs(i,1)) return 0;\n      mp[abs(c1-c2)]++;\n      summin += min(c1,c2);\n      sumdiff += abs(c1-c2);\n    }\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0] = 0;\n  int i = 0;\n  FOR(it, mp) {\n    REP(j,n+1) {\n      if (dp[j] >= 0) {\n        dp[j] = it->second;\n      } else if (j<it->first || dp[j-it->first] <= 0) {\n        dp[j] = -1;\n      } else {\n        dp[j] = dp[j-it->first]-1;\n      }\n    }\n    i++;\n  }\n  ans = 0;\n  REP(i,n+1) {\n    if (dp[i] >= 0) {\n      ll a = summin + i;\n      ll b = summin + sumdiff - i;\n      chmax(ans, a*b);\n    }\n  }\n  ans -= m;\n  return 1;\n}\n\nint main() {\n  cin >> n >> m;\n  REP(i,m) {\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  if (!solve()) cout << -1 << endl;\n  else cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,bool c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n  \n  vertex.resize(n,-1);\n  vector<int> dis;\n  int smsum=0;\n  for(int i=0;i<chunk.size();i++){\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    smsum+=min(cnt1,int(chunk[i].size())-cnt1);\n    dis.push_back(abs(cnt1-(int(chunk[i].size())-cnt1)));\n  }\n  int n2=1;\n  while(n2<chunk.size()) n2*=2;\n  while(dis.size()<n2) dis.push_back(0);\n\n  vector<set<int>> now(n2);\n  for(int i=0;i<n2;i++){\n\n    now[i].insert(dis[i]);\n    now[i].insert(0);\n  }\n\n  while(n2!=1){\n    assert(now.size()==n2);\n    vector<set<int>> nex;\n    for(int i=0;i<n2/2;i++){\n      set<int> s;\n      for(auto v1:now[2*i]){\n\tfor(auto v2:now[2*i+1]){\n\t  s.insert(v1+v2);\n\t}\n      }\n      nex.push_back(s);\n    }\n    n2/=2;\n    now=nex;\n  }\n  \n  long long int res=0;\n  for(auto v:now[0]){\n    long long int b=(smsum+v);\n    long long int a=(n-smsum-v);\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nint N, M, dp[100010];\nvector< vector< int > > adj;\nvector< int > g[2], col;\nmap< pii, int > part_cnt;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nlint calc() {\n\tmemset(dp, -1, sizeof(dp));\n\t\n\tdp[0] = 0;\n\t\n\tlint A = 0;\n\t\n\tfor (auto it = part_cnt.begin(); it != part_cnt.end(); ++it) {\n\t\tpii p = (*it).first;\n\t\tint a = p.second, c = (*it).second;\n\t\tA += p.first;\n\t\t\n\t\tfor_(j,0,N+1) {\n\t\t\tif (dp[j] >= 0) {\n\t\t\t\tdp[j] = c;\n\t\t\t} else if (j < a || dp[j - a] <= 0) {\n\t\t\t\tdp[j] = -1;\n\t\t\t} else {\n\t\t\t\tdp[j] = dp[j - a] - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor_(a,0,100010) {\n\t\tif (dp[a] == -1) continue;\n\t\tlint B = N - (A + a);\n\t\tres = max(res, (A + a) * B);\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tcol.assign(N, -1);\n\t\n\tlint sub_sum = 0;\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = min(g[0].size(), g[1].size()), b = max(g[0].size(), g[1].size());\n\t\t++part_cnt[pii(a, b - a)];\n\t\t\n\t\tfor (int u : g[0]) sub_sum += adj[u].size();\n\t}\n\t\n\tcout << (!flag ? -1 : calc() - sub_sum) << endl;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\nint solve(){\n  vector<int> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(abs(a[1]-a[0]));\n    else return -1;\n  }\n  int k=V;\n  sort(v.begin(),v.end(),greater<int>());\n  set<int> s[2];\n  s[0].insert(0);\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    s[!f].clear();\n    for(set<int>::iterator it=s[f].begin();it!=s[f].end();++it){\n      s[!f].insert(*it+v[i]);\n      s[!f].insert(*it-v[i]);\n    }\n  }\n  for(set<int>::iterator it=s[v.size()%2].begin();it!=s[v.size()%2].end();++it)\n    k=min(k,abs(*it));\n  return ((V-k)/2)*((V-k)/2+k)-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\ntypedef pair< int, int > pii;\n\nstruct Part { int a, b; };\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col;\nvector< Part > parts;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nmap< pii, lint > memo[100010];\n\nlint rec(int i, int lft, int rgt) {\n\tif (i == (int)parts.size()) return 0;\n\t\n\tif (memo[i].count(pii(lft, rgt))) return memo[i].at(pii(lft, rgt));\n\t\n\tlint& res = memo[i][pii(lft, rgt)];\n\t\n\tres = max(res, rec(i + 1, lft + parts[i].a, rgt + parts[i].b) +\n\t\t\t\t   (lint)lft * (lint)parts[i].b + (lint)rgt * (lint)parts[i].a);\n\t\n\tres = max(res, rec(i + 1, lft + parts[i].b, rgt + parts[i].a) +\n\t\t\t\t   (lint)lft * (lint)parts[i].a + (lint)rgt * (lint)parts[i].b);\n\t\n\treturn res;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tcol.assign(N, -1);\n\t\n\tlint ans = 0;\n\tint cnt0 = 0;\n\t\n\tbool flag = true;\n\t\n\tfor_(v,0,N) {\n\t\tif (col[v] != -1) continue;\n\t\tfor_(i,0,2) g[i].clear();\n\t\t\n\t\tflag &= dfs(v, 0);\n\t\t\n\t\tint a = g[0].size(), b = g[1].size();\n\t\t\n\t\tif (a == 0 || b == 0) ++cnt0;\n\t\telse parts.push_back(Part{a, b});\n\t\t\n\t\tlint sum = 0;\n\t\tfor (int u : g[0]) sum += adj[u].size();\n\t\tans += (lint)a * (lint)b - sum;\n\t}\n\t\n\tparts.push_back(Part{cnt0 / 2, cnt0 / 2 + cnt0 % 2});\n\tans += (lint)(cnt0 / 2) * (lint)(cnt0 / 2 + cnt0 % 2);\n\t\n\tif (!flag) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tcout << ans + rec(0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[B][N][2];\nint dp2[B][N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0][0] = 0;\n    for(int i=1; i<B; ++i){\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[i-1][j][0]>=0){\n            pq.push({C,{j,C%2}});\n            dp[i][j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int nx = abs(p.fi+j*i);\n\n                if(dp[i][nx][!p.se] < now.fi-1){\n                    dp[i][nx][!p.se] = now.fi-1;\n                    pq.push({dp[i][nx][!p.se], {nx,!p.se}});\n                }\n            }\n        }\n    }\n    rep(i,N)if(dp[B-1][i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0][0] = 1;\n    que.push({0,0});\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n\n        int idx = now.fi;\n        int val = now.se;\n        if(idx == L) continue;\n\n        for(int i=-1; i<=1; i+=2){\n            int nx = abs(val+i*l[idx]);\n            if(!dp2[idx+1][nx]){\n                dp2[idx+1][nx] = 1;\n                que.push({idx+1, nx});\n            }\n        }\n    }\n    rep(i,N)if(dp2[L][i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int j=-1; j<=1; ++j){\n            int nx = idx + j;\n            if(0<=nx && nx<sz){\n                int dd = abs(i-Sd[nx]);\n                if(n-dd>0){\n                    assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e9\n#define MINUS_INF -(1e9)\n\nbool dfs(int now, const vector<vector<int> >& adj, vector<int>& history, int& a, int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int input_a, input_b;\n  vector<vector<int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  int a_sum = 0, b_sum = 0;\n  vector<int> c_tmp;\n  vector<int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      int a = 0;\n      int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<int> > dp(n, vector<int>(v + 1, MINUS_INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i - 1].first ? dp[i][j - c[i].first] - 1 : (int)MINUS_INF);\n    \n  \n  int minpoint = -1;\n  int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>g[110000];\nvector<int>v;\nint color[110000];\nbool ok=true;\nint B,W;\nvoid dfs(int a,int b){\n\tcolor[a]=b;\n\tif(b)B++;\n\telse W++;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(!color[g[a][i]]){\n\t\t\tdfs(g[a][i],!b);\n\t\t}else if(color[g[a][i]]==b){\n\t\t\tok=false;\n\t\t}\n\t}\n}\nint sg[310];\nint dp[2][110000];\nint dp2[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tfor(int i=0;i<a;i++)color[i]=-1;\n\tint now=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(!color[i]){\n\t\t\tB=W=0;\n\t\t\tdfs(a,0);\n\t\t\tnow+=min(B,W);\n\t\t\tif(max(B,W)-min(B,W)<300)sg[max(B,W)-min(B,W)]++;\n\t\t\telse v.push_back(max(B,W)-min(B,W));\n\t\t}\n\t}\n\tif(!ok){\n\t\tprintf(\"-1\\n\");\n\t}\n\tfor(int i=0;i<110000;i++)dp[0][i]=dp[1][i]=-1;\n\tdp[1][0]=0;\n\tfor(int i=1;i<300;i++){\n\t\tint f=i%2;\n\t\tfor(int j=0;j<110000;j++){\n\t\t\tif(~dp[f][j])dp[!f][j]=0;\n\t\t\telse dp[!f][j]=-1;\n\t\t}\n\t\tfor(int j=0;j<110000;j++){\n\t\t\tif(j-i>=0&&~dp[!f][j-i]&&dp[!f][j-i]<sg[i]){\n\t\t\t\tif(!~dp[!f][j])dp[!f][j]=dp[!f][j-i]+1;\n\t\t\t\telse dp[!f][j]=min(dp[!f][j],dp[!f][j-i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<110000;i++)if(dp[0][i])dp2[i]=1;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=109999;j>=v[i];j--){\n\t\t\tdp2[j]|=dp2[j-v[i]];\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<110000;i++){\n\t\tif(dp2[i]){\n\t\t\tret=max(ret,(long long)(now+i)*(a-now-i)-b);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nvector<int> unify_ones(const vector<int> &a){\n\tvector<int> res;\n\tint one=0;\n\trep(i,a.size()){\n\t\tif(a[i]==1) one++;\n\t\telse        res.push_back(a[i]);\n\t}\n\n\tint two=1;\n\twhile(one>0){\n\t\tres.push_back(min(two,one));\n\t\tone-=min(two,one);\n\t\ttwo<<=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\n\t// add[i]==1 がたくさんあると部分和問題を解くのに時間がかかりすぎるので, 適当にまとめる ( 個数制約があるナップザックと同じ tips )\n\tadd=unify_ones(add);\n\n\t// knapsack DP\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=n/2-L_sum-add[i];j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\",N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 200001;\nint n, m, v[100000], sum[MX];\nbool dp[2][MX];\nvector<vi> e;\n\nbool rec(int c, int col, int &a, int &b){\n\ta++;\n\tv[c] = col;\n\trep(i, e[c].size()){\n\t\tif(v[e[c][i]]){\n\t\t\tif(v[e[c][i]] == col) return 0;\n\t\t}\n\t\telse rec(e[c][i], -col, b, a);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\te.resize(n);\n\trep(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\tmap<int, int> s;\n\trep(i, n) if(!v[i]){\n\t\tint a = 0, b = 0;\n\t\tif(!rec(i, 1, a, b)){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\ts[abs(a - b)]++;\n\t}\n\tconst int GETA = 100000;\n\tdp[0][GETA] = 1;\n\tint cur = 0, next = 1;\n\teach(i, s){\n\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\t\n\t\tint a = i->first, b = i->second;\n\t\tif(a == 0) continue;\n\t\t\n\t\trep(j, MX) if(dp[cur][j]){\n\t\t\tint t = (MX - 1 - j) / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tif(j + a * (t + 2) < MX) sum[j + a * (t + 2)]--;\n\t\t\t\n\t\t\tt = j / a;\n\t\t\tif(t % 2 != b % 2) t--;\n\t\t\tt = min(t, b);\n\t\t\tsum[j - a * t]++;\n\t\t}\n\t\tint k = 0;\n\t\trep(j, MX){\n\t\t\tk += sum[j];\n\t\t\tif(k) dp[next][j] = 1;\n\t\t}\n\t\tswap(cur, next);\n\t}\n\tll mx = 0;\n\trep(i, MX) if(dp[cur][i]){\n\t\t//dbg(i);\n\t\tmx = max(mx, (ll)((n + i - GETA) / 2) * ((n - i + GETA) / 2));\n\t}\n\tcout << mx - m << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n\n    map<int,int> m;\n    int sub = 0;\n    for (int i = 0; i < s[0].size(); i++) {\n        m[max(s[0][i].size(), s[1][i].size()) - min(s[0][i].size(), s[1][i].size())]++;\n        sub += min(s[0][i].size(), s[1][i].size());\n    }\n\n    vector<int> dp(N+1, -1);\n    dp[0] = 0;\n    for (auto p : m) {\n        int x = p.first;\n        int count = p.second;\n        for (int i = 0; i < dp.size(); i++) {\n            if (dp[i] >= 0) dp[i] = count;\n            else if (i < x || dp[i - x] < 0) dp[i] = -1;\n            else dp[i] = dp[i - x] - 1;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i <= N; i++) {\n        if (dp[i] >= 0)\n            ans = max(ans, (sub + i) * (N - sub - i) - M);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n\n  map<PLL,int> xs;\n  VI parity(V);\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs[res]++;\n\t}\n  }\n\n  int crt = 0, nxt = 1;\n  vector<vector<bool>> dp(2, vector<bool>(V+1));\n  dp[crt][0] = true;\n  for(auto&& p_: xs){\n\tint num = p_.SS;\n\tint b = 1;\n\twhile(num){\n\t  fill(ALL(dp[nxt]), false);\n\t  if(num < b)\n\t\tb = num;\n\t  num -= b;\n\n\t  PLL p(p_.FF.FF * b, p_.FF.SS*b);\n\t  for(int i=V;i-p.FF>=0;--i)\n\t\tdp[nxt][i] = dp[nxt][i] || dp[crt][i-p.FF];\n\t  for(int i=V;i-p.SS>=0;--i)\n\t\tdp[nxt][i] = dp[nxt][i] || dp[crt][i-p.SS];\n\t  \n\t  b <<= 1;\n\t  swap(crt, nxt);\n\t}\n  }\n\n  LL ans = 0;\n  REP(i,V+1) if(dp[crt][i]) maxi(ans, (LL)i*(V-i));\n  cout << ans - E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  REP(i,cnt) {\n    sum[2*i] = 2 * abs(sum[2*i]);\n  }\n  int twice = 0;\n  REP(i,cnt) twice += sum[2*i];\n  vector<bool> dp(twice+1);\n  dp[0] = 1;\n  REP(i,cnt) {\n    auto tmp = dp;\n    REP(j,twice-sum[2*i]+1) {\n      if (dp[j])\n        tmp[j+sum[2*i]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,twice+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int smaller = v/2 - mn/2;\n  int larger = v - smaller;\n  int m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tpriority_queue<int> que;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tque.emplace(p.second - p.first);\n\t\t}\n\t}\n\twhile(que.size() > 1){\n\t\tint t1 = que.top();\n\t\tque.pop();\n\t\tint t2 = que.top();\n\t\tque.pop();\n\t\tque.emplace(t1 - t2);\n\t}\n\n\tint dif = que.top();\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nvector<int> G[100010];\nint dpn[200010], dpc[200010];\n \nsigned main() {\n    int V, E; cin >> V >> E;\n\n    vector<int> visited(V, -1);\n    for(int i=0; i<E; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    bool bipartite = true;\n    int cnt0 = 0, cnt1 = 0, sum = 0, add = 0;\n    function<void(int)> check = [&](int cur) {\n        int c = visited[cur];\n        for(auto to : G[cur]) {\n            if(visited[to] >= 0) {\n                bipartite &= (visited[to] == 1 - c);\n            }\n            else {\n                visited[to] = 1 - c;\n                (1 - c == 0 ? cnt0 : cnt1)++;\n                check(to);\n            }\n        }\n    };\n\n    map<int, int> rec;\n    for(int i=0; i<V; i++) {\n        cnt0 = 0, cnt1 = 0;\n        if(visited[i] >= 0) continue;\n        visited[i] = 0; cnt0++;\n        \n        check(i);\n        int val = abs(cnt0 - cnt1);\n        sum += val * 2;\n        add += min(cnt0, cnt1);\n        rec[val]++;\n    }\n\n    if(!bipartite) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    fill(dpc, dpc + sum + 1, -1);\n    fill(dpn, dpn + sum + 1, -1);\n    dpc[0] = 0;\n    for(auto e : rec) {\n        int val, cnt; tie(val, cnt) = e;\n        for(int i=0; i<=sum; i++) {\n            if(dpc[i] >= 0) chmax(dpn[i], cnt);\n            if(i + 2*val <= sum) chmax(dpn[i + 2*val], dpn[i] - 1);\n            dpc[i] = -1;\n        }\n        swap(dpn, dpc);\n    }\n\n    int ans = 0;\n    for(int i=0; i<=sum; i++) {\n        if(dpc[i] < 0) continue;\n        int A = i / 2 + add, B = V - A;\n        chmax(ans, A * B - E);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nbool dfs(VVI& G, int u, VI& parity, PLL& res){\n  if(parity[u] > 0) res.FF++;\n  else res.SS++;\n\n  for(int to: G[u]){\n\tif(parity[to]){\n\t  if(parity[to] == parity[u])\n\t\treturn false;\n\t}\n\telse{\n\t  parity[to] = -parity[u];\n\t  if(!dfs(G, to, parity, res))\n\t\treturn false;\n\t}\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int V, E; cin >> V >> E;\n  VVI G(V);\n  REP(i,E){\n\tint u, v; cin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].PB(v);\n\tG[v].PB(u);\n  }\n\n  map<PLL,int> xs;\n  VI parity(V);\n  REP(i,V){\n\tif(!parity[i]){\n\t  parity[i] = 1;\n\t  PLL res;\n\t  if(!dfs(G, i, parity, res)){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t  }\n\t  if(res.FF < res.SS) swap(res.FF, res.SS);\n\t  xs[res]++;\n\t}\n  }\n\n  int crt = 0, nxt = 1;\n  vector<vector<bool>> dp(2, vector<bool>(V+1));\n  dp[crt][0] = true;\n  for(auto&& p_: xs){\n\tdp[nxt] = dp[crt];\n\n\tint num = p_.SS;\n\tint b = 1;\n\twhile(num){\n\t  if(num < b)\n\t\tb = num;\n\t  num -= b;\n\n\t  VL ps{p_.FF.FF * b, p_.FF.SS*b};\n\t  for(auto&& p: ps)\n\t\tfor(int i=V;i-p>=0;--i)\n\t\t  dp[nxt][i] = dp[nxt][i] | dp[crt][i-p];\n\t  \n\t  b <<= 1;\n\t}\n\tswap(crt, nxt);\n  }\n\n  LL ans = 0;\n  REP(i,V+1)if(dp[crt][i]) maxi(ans, (LL)i*(V-i));\n  cout << ans - E << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint MAX = 101010;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tvec.emplace_back(p.second - p.first);\n\t\t\tMAX = max(MAX,vec.back());\n\t\t}\n\t}\n\tvector<vector<int>> dp(vec.size() + 1,vector<int>(MAX + 1,0));\n\tdp[0][0] = 1;\n\tfor(int i = 0;i < vec.size();i++){\n\t\tfor(int j = 0;j <= MAX;j++){\n\t\t\tif(abs(j + vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j + vec[i])] |= dp[i][j];\n\t\t\t}\n\t\t\tif(abs(j - vec[i]) <= MAX){\n\t\t\t\tdp[i + 1][abs(j - vec[i])] |= dp[i][j];\n\t\t\t}\n\n\t\t}\n\t}\n\tint dif = MAX;\n\n\tfor(int j = MAX;j >= 0;j--){\n\t\tif(dp[vec.size()][j]){\n\t\t\tdif = j;\n\t\t}\n\t}\n\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\nusing ld = long double;\n\nint N, M;\nvector<int> G[100010];\n\nbool vis[100010];\nbool col[100010];\n\nvoid dfs(int n, bool res, int &a, int &b) {\n    vis[n] = true;\n    if (res == 0)\n        a++;\n    else\n        b++;\n    col[n] = res;\n    for (auto nxt : G[n]) {\n        if (vis[nxt]) {\n            if (col[nxt] == res) {\n                cout << -1 << endl;\n                exit(0);\n            }\n            continue;\n        }\n        dfs(nxt, !res, a, b);\n    }\n}\nbitset<100010> dp[2];\nbool solve() {\n    cin >> N >> M;\n    REP(i, M) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<int> A, B, C;\n    REP(i, N) {\n        if (!vis[i]) {\n            int a = 0, b = 0;\n            dfs(i, 0, a, b);\n            A.push_back(a);\n            B.push_back(b);\n            C.push_back(abs(a - b));\n        }\n    }\n    int K = A.size();\n    dp[0][0] = true;\n    REP(i, K) {\n        //cerr << A[i] << \" \" << B[i] << endl;\n        int now = i % 2;\n        int nxt = (now + 1) % 2;\n        dp[nxt] = (dp[now] << A[i]) | (dp[now] << B[i]);\n    }\n    int mx = 0;\n    int sum = N;\n    // cout << dp[K % 2] << endl;\n    REP(i, N + 1) {\n        if (dp[K % 2][i]) {\n            mx = max(mx, (N - i) * i);\n        }\n    }\n    cout << mx - M << endl;\n    return true;\n}\n\nsigned main() {\n    // while (solve())\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<int> G[N];\nint flag;\nint col[N];\n \nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n \nmap<int,int> A;\nint dp[N];\n\nint calc(int d){\n  int a = (n-d)/2;\n  int b = n - a;\n  return a*b;\n}\n\nint DP(){\n  int sum = 0;\n  for(P a:A) sum+=a.first*a.second;\n  for(P a:A){\n    dp[0] = a.second;\n    for(int i=0;i<=N;i++)if(dp[a.first]>0) dp[a.first] = a.second;\n    for(int j=0;j<N;j++){\n      if(j+a.first>=N)break;\n      if(dp[j] == 0)continue;\n      dp[j+a.first] = max(dp[j+a.first],dp[j] - 1);\n    }\n  }\n  \n  int res = 0;\n  for(int i=0;i<N;i++)\n    if(dp[i]>0) res = max(res,calc(abs(i-(sum-i))));\n  return res;\n}\n \nsigned main(){\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n \n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A[abs(cnt.first-cnt.second)]++;\n  }\n\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  cout<<DP()-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n\n  vector<int> B;\n  int sum =0;\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n    A.push_back(cnt);\n    B.push_back(cnt.first-cnt.second);\n    sum+=cnt.first+cnt.second;\n  }\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  sort(B.begin(),B.end(),greater<int>());\n  \n  int d = 0;\n  for(int i=0;i<(int)B.size();i++) d>0? d-=B[i]:d+=B[i];\n  int a = (abs(d) + sum)/2;\n  int b = sum - a;\n\n  \n  cout<<a*b-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\nint solve(){\n  vector<int> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(abs(a[1]-a[0]));\n    else return -1;\n  }\n  int k=0;\n  sort(v.begin(),v.end(),greater<int>());\n  for(int i=0;i<(int)v.size();i++){\n    if(k>=v[i]) k-=v[i];\n    else k+=v[i];\n  }\n  return ((V-k)/2)*((V-k)/2+k)-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\n\npair<int,int> bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tpair<int,int> res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tint MAX = 0;\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(p.first > p.second) swap(p.first,p.second);\n\t\t\tvec.emplace_back(p.second - p.first);\n\t\t\tMAX += vec.back();\n\t\t}\n\t}\n\tvector<vector<int>> dp(2,vector<int>(MAX + 1,0));\n\tdp[0][0] = 1;\n\tfor(int i = 0;i < vec.size();i++){\n\t\tint ne = (i + 1) % 2;\n\t\tdp[ne].assign(MAX + 1,0);\n\t\tfor(int j = 0;j <= MAX;j++){\n\t\t\tif(abs(j + vec[i]) <= MAX){\n\t\t\t\tdp[ne][abs(j + vec[i])] |= dp[i % 2][j];\n\t\t\t}\n\t\t\tif(abs(j - vec[i]) <= MAX){\n\t\t\t\tdp[ne][abs(j - vec[i])] |= dp[i % 2][j];\n\t\t\t}\n\n\t\t}\n\t}\n\tint dif = MAX;\n\n\tfor(int j = MAX;j >= 0;j--){\n\t\tif(dp[vec.size() % 2][j]){\n\t\t\tdif = j;\n\t\t}\n\t}\n\n\tint res = (v - dif) / 2;\n\tint res2 = (v + dif) / 2;\n\tcout << res * res2 - e << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> e[100000];\n\ntypedef pair<int,int> P;\n\nint c[100000],g;// -1 0 1 2 ;\nset<P> st;\nint used[100000];\n\nvoid dfs(int p,int d){\n  if(c[p]==-1)c[p]=d;\n  else if((c[p]==0&&d==1)||(c[p]==1&&d==0))c[p]=2;\n  used[p]=g;\n  for(int i=0;i<e[p].size();i++){\n    if(st.count(P(min(e[p][i],p),max(e[p][i],p))))continue;\n    st.insert(P(min(e[p][i],p),max(e[p][i],p)));\n    dfs(e[p][i],!d);\n  }\n}\n\n\nint main(){\n  int V,E;\n  memset(c,-1,sizeof(c));\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++){\n    cin>>a>>b;\n    a--,b--;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  for(int i=0;i<V;i++){\n    if(!used[i])++g,dfs(i,0);\n\n  }\n  long long ans=0;\n  for(int i=0;i<V;i++)\n    if(c[i]==2)ans=-1;\n  \n  if(ans!=-1){\n    int cnt[100001][2]={};\n    \n    for(int i=0;i<V;i++)\n      cnt[used[i]][c[i]]++;\n    for(int i=1;i<=g;i++)ans+=cnt[i][0]*cnt[i][1];\n    vector<int> v[2];\n    for(int i=1;i<=g;i++){\n      v[0].push_back(max(cnt[i][0],cnt[i][1]));\n      v[1].push_back(min(cnt[i][0],cnt[i][1]));\n    }\n\n    sort(v[0].begin(),v[0].end());\n    sort(v[1].begin(),v[1].end());\n\n    long long g0=v[0][0],g1=v[1][0];\n\n    for(int i=1;i<v[0].size();i++)\n      ans+=g0*v[0][i],g0+=v[0][i];\n    for(int i=1;i<v[1].size();i++)\n      ans+=g1*v[1][i],g1+=v[1][i];\n    \n    ans-=E;\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] > CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[(Bipartite[CitySet[i][0]] + 1) % 2]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += CityType2[(Bipartite[CitySet[i][j]] + 1) % 2];\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<int,pi>;\n\nconst int INF = 12345678;\n\nconst int B = 320;\nconst int N = 100010;\nvector<int> G[N];\n\nint dp[N][2], nx[N][2];\nint dp2[N], nx2[N];\n\nll solve(){\n    int n,m;\n    cin >>n >>m;\n    rep(i,m){\n        int u,v;\n        cin >>u >>v;\n        --u; --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    vector<int> d(n,INF);\n    vector<int> x;\n    rep(i,n){\n        if(d[i]!=INF) continue;\n\n        queue<int> que;\n        vector<int> cc;\n\n        d[i] = 0;\n        que.push(i);\n        cc.pb(i);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(d[e] > d[v]+1){\n                    d[e] = d[v]+1;\n                    que.push(e);\n                    cc.pb(e);\n                }\n            }\n        }\n\n        int diff = 0;\n        for(int v:cc){\n            if(d[v]%2==0) ++diff;\n            else --diff;\n\n            for(int e:G[v]){\n                // 奇閉路が存在する\n                if(abs(d[v]-d[e])%2==0) return -1;\n            }\n        }\n\n        x.pb(abs(diff));\n    }\n\n    vector<int> s,l;\n    for(int i:x){\n        if(i<B) s.pb(i);\n        else l.pb(i);\n    }\n\n    vector<int> Ld, Sd;\n\n    // calc small\n    vector<int> ct(B);\n    for(int i:s) ++ct[i];\n\n    memset(dp,-1,sizeof(dp));\n    dp[0][0] = 0;\n    for(int i=1; i<B; ++i){\n        memset(nx,-1,sizeof(nx));\n\n        priority_queue<P> pq;\n        int C = ct[i];\n        rep(j,N)if(dp[j][0]>=0){\n            pq.push({C,{j,C%2}});\n            nx[j][C%2] = C;\n        }\n\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n\n            if(now.fi == 0) continue;\n\n            pi p = now.se;\n            for(int j=-1; j<=1; j+=2){\n                int idx = abs(p.fi+j*i);\n\n                if(idx<N && nx[idx][!p.se] < now.fi-1){\n                    nx[idx][!p.se] = now.fi-1;\n                    pq.push({nx[idx][!p.se], {idx,!p.se}});\n                }\n            }\n        }\n\n        rep(j,N)rep(k,2) dp[j][k] = nx[j][k];\n    }\n    rep(i,N)if(dp[i][0]>=0) Sd.pb(i);\n\n    // calc large\n    int L = l.size();\n\n    memset(dp2,0,sizeof(dp2));\n    queue<pi> que;\n\n    dp2[0] = 1;\n    rep(i,L){\n        memset(nx2,0,sizeof(nx2));\n        rep(j,N)if(dp2[j]){\n            for(int k=-1; k<=1; k+=2){\n                int idx = abs(j+k*Ld[i]);\n                if(idx<N) nx2[idx] = 1;\n            }\n        }\n\n        rep(j,N) dp2[j] = nx2[j];\n    }\n    rep(i,N)if(dp2[i]) Ld.pb(i);\n\n    // calc ans\n    ll ans = 0;\n\n    int sz = Sd.size();\n    for(int i:Ld){\n        int idx = lower_bound(all(Sd), i) - Sd.begin();\n        for(int a=-1; a<=1; ++a){\n            int j = idx + a;\n            if(0<=j && j<sz){\n                int dd = abs(i-Sd[j]);\n                if(n-dd>0){\n                    // assert((n-dd)%2==0);\n                    int xx = (n-dd)/2;\n\n                    ll X = xx, Y = xx+dd;\n                    ans = max(ans, X*Y-m);\n                }\n            }\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<utility>\n\nusing namespace std;\n\nvector<int> G[123456];\nint c[123456];\n\npair<int,int> color(int v,int cc){\n  if(c[v]){\n    if(cc!=c[v])throw 0;\n    return make_pair(0,0);\n  }else{\n    c[v]=cc;\n    pair<int,int> p(cc==1,cc==-1);\n    for(auto e:G[v]){\n      auto r=color(e,cc*-1);\n      p.first+=r.first;\n      p.second+=r.second;\n    }\n    return p;\n  }\n}\n\nint main(){\n  int V,E;\n  cin>>V>>E;\n  for(int i=0;i<E;i++){\n    int a,b;\n    cin>>a>>b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  bitset<123456> dp(1);\n  try{\n    for(int i=1;i<=V;i++){\n      if(!c[i]){\n\tauto r=color(i,1);\n\tdp=dp<<r.first|dp<<r.second;\n      }\n    }\n    long long ans=0;\n    for(int i=0;i<=V;i++){\n      if(dp[i]){\n\tans=max(ans,1LL*i*(V-i)-E);\n      }\n    }\n    cout<<ans<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\n\nint main(){\n\tcin>>n;\n\tcout<<n+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {vector<int> par; // uf(x,y)->y\n    UnionFind(int NV) { par.clear(); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) {x = operator[](x); y = operator[](y);if (x != y) par[x] = y;}};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, M;\nvector<int> E[101010];\n//---------------------------------------------------------------------------------------------------\ninline int rev(int x) {\n    if (x == 1) return 2;\n    return 1;\n}\nvector<int> gr[101010];\nint col[101010];\nint dfs(int cu, int co) {\n    col[cu] = co;\n    fore(to, E[cu]) {\n        if (col[to]) {\n            if (col[cu] == col[to]) return -1;\n        } else {\n            int re = dfs(to, rev(co));\n            if (re < 0) return -1;\n        }\n    }\n    return 0;\n}\nint get(int st) {\n    int res = dfs(st, 1);\n    if (res < 0) return -1;\n\n    int a = 0, b = 0;\n    fore(i, gr[st]) {\n        if (col[i] == 1) a++;\n        else b++;\n    }\n    return abs(a-b);\n}\n//---------------------------------------------------------------------------------------------------\nint dp[2][201010][2];\nvoid _main() {\n    cin >> N >> M;\n    UnionFind uf(N);\n    rep(i, 0, M) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n        uf(a, b);\n    }\n\n    map<int, int> m;\n    rep(i, 0, N) gr[uf[i]].push_back(i);\n    rep(i, 0, N) if(uf[i] == i) {\n        auto p = get(i);\n        if (p < 0) {\n            printf(\"-1\\n\");\n            return;\n        }\n        m[p]++;\n    }\n\n    vector<pair<int, int>> v;\n    fore(p, m) v.push_back(p);\n    int n = v.size();\n    int offset = 100010;\n\n    rep(d, 0, 201010) rep(parity, 0,2) dp[0][d][parity] = -1;\n    dp[0][offset][0] = 0;\n    rep(_i, 0, n) {\n        int c = v[_i].first;\n        int num = v[_i].second;\n        int i = _i % 2;\n        int ii = 1 - i;\n\n        rep(d, 0, 201010) rep(parity, 0, 2) dp[ii][d][parity] = -1;\n\n        rep(d, 0, 201010) if (0 <= dp[i][d][0]) dp[ii][d][num % 2] = num;\n        rep(d, 0, 201010) rep(parity, 0, 2) if (0 < dp[ii][d][parity]) {\n            int dd = d + c;\n            if (dd < 201010) chmax(dp[ii][dd][1-parity], dp[ii][d][parity] - 1);\n        }\n        rrep(d, 201010-1, 0) rep(parity, 0, 2) if (0 < dp[ii][d][parity]) {\n            int dd = d - c;\n            if (0 <= dd) chmax(dp[ii][dd][1 - parity], dp[ii][d][parity] - 1);\n        }\n    }\n\n    int mi = inf;\n    rep(i, 0, 201010) if (0 <= dp[n%2][i][0]) chmin(mi, abs(i - offset));\n\n    int a = (N - mi) / 2;\n    int b = N - a;\n\n    ll ans = 1LL * a * b - M;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nvector<int> unify_ones(const vector<int> &a){\n\tvector<int> res;\n\tint one=0;\n\trep(i,a.size()){\n\t\tif(a[i]==1) one++;\n\t\telse        res.push_back(a[i]);\n\t}\n\n\tint two=1;\n\twhile(one>0){\n\t\tres.push_back(min(two,one));\n\t\tone-=min(two,one);\n\t\ttwo<<=1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\n\t// add[i]==1 がたくさんあると部分和問題を解くのに時間がかかりすぎるので, 適当にまとめる ( 個数制約があるナップザックと同じ tips )\n\tadd=unify_ones(add);\n\tsort(add.begin(),add.end());\n\n\t// knapsack DP\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 以下で最大になるよう振り分ける )\n\tvector<bool> dp(n+1); dp[0]=true;\n\trep(i,add.size()){\n\t\tfor(int j=n/2-L_sum-add[i];j>=0;j--){\n\t\t\tif(dp[j]){\n\t\t\t\tdp[j+add[i]]=true;\n\t\t\t\tif(abs(L_sum+j+add[i]-n/2.0)<abs(N-n/2.0)) N=L_sum+j+add[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\",N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  vector<int> df2(cnt);\n  REP(i,cnt) {\n    df2[i] = 2 * abs(sum[2*i]);\n  }\n  sort(ALL(df2));\n  int ofs = 0;\n  REP(i,cnt) if (!df2[i]) ++ofs;\n  int ofs2 = ofs;\n  REP(i,cnt) if (df2[i] == 1) ++ofs2;\n  int twice = 0;\n  REP(i,cnt) twice += df2[i];\n  vector<bool> dp(twice+1);\n  dp[0] = 1;\n  REP(i,cnt-ofs2) {\n    auto tmp = dp;\n    REP(j,twice-df2[i+ofs2]+1) {\n      if (dp[j])\n        tmp[j+df2[i+ofs2]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,twice+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int smaller = v/2 - mn/2 + ofs2-ofs;\n  if (smaller > v/2) smaller = v/2;\n  int larger = v - smaller;\n  int m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e9\n#define MINUS_INF -(1e9)\n\nbool dfs(int now, const vector<vector<int> >& adj, vector<int>& history, int& a, int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int input_a, input_b;\n  vector<vector<int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  int a_sum = 0, b_sum = 0;\n  vector<int> c_tmp;\n  vector<int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      int a = 0;\n      int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){ swap(a, b); }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<int> > dp(n, vector<int>(v + 1, MINUS_INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i - 1].first ? dp[i][j - c[i].first] - 1 : (int)MINUS_INF);\n    \n  \n  int minpoint = -1;\n  int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      int candiate = abs((a_sum + i) - (b_sum - i));\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> v(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    vector<set<int>> s[2];\n    vector<bool> used(N);\n    for (int i = 0; i < N; i++) {\n        if (used[i]) continue;\n        int len = s[0].size();\n        s[0].push_back(set<int>());\n        s[1].push_back(set<int>());\n        int side = 0;\n        queue<int> que[2];\n        que[0].push(i);\n        while (que[0].size()) {\n            while (que[0].size()) {\n                int num = que[0].front(); que[0].pop();\n                s[side][len].insert(num);\n                used[num] = true;\n                for (auto j : v[num]) {\n                    if (s[side][len].find(j) == s[side][len].end()) {\n                        if (!used[j]) que[1].push(j);\n                    } else {\n                        cout << - 1 << endl;\n                        return 0;\n                    }\n                }\n            }\n            que[0] = que[1];\n            que[1] = queue<int>();\n            side = !side;\n        }\n    }\n    vector<int> d[2];\n    for (int i = 0; i < s[0].size(); i++) {\n        d[0].push_back(s[0][i].size());\n        d[1].push_back(s[1][i].size());\n    }\n\n    vector<bool> dp((N+3)/2);\n    dp[0] = true;\n    for (int i = 0; i < d[0].size(); i++) {\n        for (int j = dp.size()-1; j >= 0; j--) {\n            if (j >= d[0][i] && dp[j-d[0][i]]) dp[j] = true;\n            if (j >= d[1][i] && dp[j-d[1][i]]) dp[j] = true;\n        }\n    }\n\n    int ans = dp.size() - 1;\n    while (!dp[ans]) ans--;\n\n    cout << ans * (N - ans) - M << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nvector<vector<int>> g;\n\nvector<int> color;\nP dfs(int v, int c){\n  P res = {0, 0};\n  color[v] = c;\n  if(c == 1)++res.first; \n  else ++res.second; \n  for(auto nv : g[v]){\n    if(color[nv] == c)return {-1, -1};\n    if(color[nv] == 0){\n      P tmp = dfs(nv, -c);\n      if(tmp.first < 0)return {-1, -1};\n      res.first += tmp.first;\n      res.second += tmp.second;\n    }\n  }\n  return res;\n}\n\nint dp[100100];\nmap<int, int> mp;\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  g.resize(n);\n  for(int i = 0; i < m; ++i){\n    int a, b;\n    cin >> a >> b;\n    --a;\n    --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  color.assign(n, 0);\n  int v = 0;\n  for(int i = 0; i < n; ++i){\n    if(color[i] != 0)continue;\n    P p = dfs(i, 1);\n    int a = min(p.first, p.second);\n    int b = max(p.first, p.second);\n    if(a < 0){\n      cout << -1 << endl;\n      return 0;\n    }\n    ++mp[b - a];\n    v += a;\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for(auto p : mp){\n    int plus = p.first;\n    int num = p.second;\n    for(int i = 0; i <= n; ++i){\n      if(dp[i] >= 0)dp[i] = num;\n      else if(i < plus || dp[i - plus] <= 0)dp[i] = -1;\n      else dp[i] = dp[i - plus] - 1;\n    }\n  }\n\n  ll ans = 0;\n  for(int i = 0; i <= n; ++i){\n    if(dp[i] >= 0)ans = max(ans, ll(v + i) * (n - v - i));\n  }\n  cout << ans - m << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + j * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\t\tif (dp[i])\n\t\t\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((long)(base + x) * (long)(V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,M;\nvector<int> g[100010];\nint p[100010];\nvector<int> ds;\nint c0,c1;\nint dp[100010];\nll sum=0;\n\nbool dfs(int v,int pari){\n  p[v]=pari;\n  if(pari==0)c0++;\n  else c1++;\n  bool ok=true;\n  for(int nv : g[v]){\n    if(p[v]==p[nv])ok=false;\n    else{\n      if(p[nv]==-1&&!dfs(nv,1-pari))ok=false;\n    }\n  }\n  return ok;\n}\n\nint main(){\n  cin>>N>>M;\n  rep(i,M){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  memset(p,-1,sizeof(p));\n  rep(i,N){\n    if(p[i]!=-1)continue;\n    c0=c1=0;\n    if(!dfs(i,0)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ds.push_back(abs(c0-c1));\n    sum+=abs(c0-c1);\n  }\n  sort(all(ds));\n  vector<int> a,m;\n  rep(i,ds.size()){\n    int j=i;\n    a.push_back(ds[i]);\n    int cnt=1;\n    while(j<ds.size()&&ds[j]==ds[i]){\n      j++;\n    }\n    m.push_back(cnt);\n    i=j-1;\n  }\n  memset(dp,-1,sizeof(dp));\n  dp[0]=0;\n  rep(i,a.size()){\n    rep(j,N+1){\n      if(dp[j]>=0)dp[j]=m[j];\n      else if(j<a[i]||dp[j-a[i]]<=0)dp[j]=-1;\n      else dp[j]=dp[j-a[i]]-1;\n    }\n  }\n\n  ll res=-INF;\n  rep(j,N+1){\n    if(dp[j]<0)continue;\n    ll d=abs(sum-2*j);\n    assert(d<=N);\n    ll x=(N+d)/2,y=(N-d)/2;\n    assert(x+y==N);\n    maxch(res,x*y-M);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nint ans;\nP Sum[N];\n\n\nvoid dfs(int idx,int f,int s){\n  if(idx == (int)A.size()) ans = max(ans,f*s);\n  if(idx == (int)A.size()) return;\n  if(f>s) swap(f,s);\n\n  int F = f + Sum[idx].first;\n  int S = s + Sum[idx].second;\n  ans = max(ans,F*S);\n  if(F<S)return;\n\n  int a = A[idx].first;\n  int b = A[idx].second;\n  dfs(idx+1,f+a,s+b);\n  dfs(idx+1,f+b,s+a);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n\n  vector<int> B;\n  int sum =0;\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    if(cnt.first<cnt.second) swap(cnt.first,cnt.second);\n\n    A.push_back(cnt);\n    B.push_back(cnt.first-cnt.second);\n    sum+=cnt.first+cnt.second;\n  }\n\n  assert(sum == n);\n  if(flag) cout<<\"-1\"<<endl,exit(0);\n  if(B.size()==1) cout<<A[0].first*A[0].second-m<<endl,exit(0);\n\n  sort(B.begin(),B.end(),greater<int>());\n\n  int ave = 0;\n  for(int i=0;i<(int)B.size();i++)ave += B[i];\n  ave /= B.size();\n  \n  int d = 0;\n  for(int i=0;i<(int)B.size();i++) {\n    d += B[i]-ave;\n  }\n\n  //cout<<A[0].first<<\" \"<<A[0].second<<endl;\n  //for(int i=0;i<B.size();i++)cout<<B[i]<<endl;  \n\n  //cout<<\"d=\"<<d<<endl;\n\n  int a = (sum-d)/2;\n  //cout<<d<<endl;\n  int b = sum - a;\n  \n  \n  cout<<a*b-m<<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector< vector<int> > graph;\n\n// G を連結成分に分解する\nvector<graph> decomp(const graph &G){\n\tint n=G.size();\n\tvector<graph> cc;\n\tmap<int,int> f; // G における頂点番号 -> 連結成分の番号\n\tmap<int,int> g; // G における頂点番号 -> 連結成分における頂点番号\n\n\tint c_id=0;\n\tvector<bool> vis(n);\n\trep(u,n) if(!vis[u]) {\n\t\tvis[u]=true;\n\n\t\tvector<int> tmp; // 今調べている連結成分\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\t\t\ttmp.push_back(v);\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(!vis[w]) vis[w]=true, Q.push(w);\n\t\t\t}\n\t\t}\n\n\t\tcc.push_back(graph(tmp.size()));\n\t\trep(i,tmp.size()){\n\t\t\tf[tmp[i]]=c_id;\n\t\t\tg[tmp[i]]=i;\n\t\t}\n\t\tc_id++;\n\t}\n\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tcc[f[u]][g[u]].push_back(g[v]);\n\t}\n\n\treturn cc;\n}\n\nbool is_bipartite(const graph &G,int &L_res,int &R_res){\n\tint n=G.size();\n\tint L=0,R=0;\n\tvector<int> color(n,-1);\n\n\trep(u,n) if(color[u]==-1) {\n\t\tcolor[u]=2*(L++);\n\n\t\tqueue<int> Q; Q.push(u);\n\t\twhile(!Q.empty()){\n\t\t\tint v=Q.front(); Q.pop();\n\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint w=G[v][i];\n\t\t\t\tif(color[w]%2==color[v]%2) return false;\n\t\t\t\tif(color[w]==-1){\n\t\t\t\t\tif(color[v]%2==0) color[w]=2*(R++)+1;\n\t\t\t\t\telse              color[w]=2*(L++);\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tL_res=L;\n\tR_res=R;\n\treturn true;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tgraph G(n);\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tvector<graph> cc=decomp(G);\n\n\tvector<int> L(cc.size()),R(cc.size()); // 二部グラフの左右の頂点数\n\trep(i,cc.size()){\n\t\tif(!is_bipartite(cc[i],L[i],R[i])) return puts(\"-1\"),0;\n\t\tif(L[i]>R[i]) swap(L[i],R[i]);\n\t}\n\n\tint L_sum=0;\n\tvector<int> add(cc.size());\n\trep(i,cc.size()){\n\t\tL_sum+=L[i];\n\t\tadd[i]=R[i]-L[i];\n\t}\n\tsort(add.begin(),add.end());\n\n\t// knapsack\n\tvector<bool> dp(n+1);\n\tdp[0]=true;\n\tint ub=0;\n\trep(i,add.size()){\n\t\tfor(int j=min(ub,n-add[i]);j>=0;j--) if(dp[j]) {\n\t\t\tdp[j+add[i]]=true;\n\t\t\tub=max(ub,j+add[i]);\n\t\t}\n\t}\n\n\tint N=L_sum; // 最適な左の頂点数 ( n/2 に最も近い振り分け )\n\trep(i,n+1) if(dp[i] && abs(L_sum+i-n/2.0)<abs(N-n/2.0)) N=L_sum+i;\n\n\tprintf(\"%lld\\n\",(ll)N*(n-N)-m);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint v;\nint e;\n\nvector<vector<int>> edges(101010,vector<int>());\nvector<int> vis(101010,-1);\n\nvector<int> vec;\n\nint c(int k){\n\tpriority_queue<int> que;\n\tque.push(k);\n\tfor(int a : vec){\n\t\tque.push(a);\n\t}\n\twhile(que.size() >= 2){\n\t\tint t1 = que.top();\n\t\tque.pop();\n\t\tint t2 = que.top();\n\t\tque.pop();\n\t\tque.push(t1 - t2);\n\t}\n\treturn que.top();\n}\n\nint binary(){\n\tfor(int i = 0;i <= v;i++){\n\t\tif(c(i) == 0){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nP bfs(int s){\n\tqueue<P> que;\n\tque.emplace(s,0);\n\tvis[s] =  0;\n\tP res = {0,0};\n\twhile(!que.empty()){\n\t\tint v = que.front().first;\n\t\tint d= que.front().second;\n\t\tque.pop();\n\t\tif(d % 2 == 0) res.first++;\n\t\telse res.second++;\n\n\t\tfor(auto& to : edges[v]){\n\t\t\tif(vis[to] == -1){\n\t\t\t\tvis[to] = (d + 1) % 2;\n\t\t\t\tque.emplace(to,vis[to]);\n\t\t\t}\n\t\t\telse if((vis[to] - vis[v] + 1) % 2 != 0){\n\t\t\t\treturn {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> v >> e;\n\tfor(int i = 0;i < e;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tbitset<101010> bit(1);\n\tfor(int i = 1;i <= v;i++){\n\t\tif(vis[i] == -1){\n\t\t\tauto p = bfs(i);\n\t\t\tif(p.first == -1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbit = (bit << p.first) | (bit << p.second);\n\t\t}\n\t}\n\n\ti64 res = 0;\n\tfor(i64 i = 0;i < v;i++){\n\t\tif(bit[i])res = max(res, i * (v - i) - e);\n\t}\n\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nint N, M;\nvector< vector< int > > adj;\nvector< int > g[2], col;\n\nbool dfs(int v, int c) {\n\tif (col[v] != -1) {\n\t\tif (col[v] != c) return false;\n\t\treturn true;\n\t}\n\t\n\tcol[v] = c;\n\tg[c].push_back(v);\n\t\n\tfor (int u : adj[v]) if (!dfs(u, 1 - c)) return false;\n\t\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tcol.assign(N, -1);\n\t\n\tbool flag = true;\n\tfor_(v,0,N) if (col[v] == -1) flag &= dfs(v, 0);\n\t\n\tif (!flag) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tlint ans = 0;\n\t\tint m = g[1].size();\n\t\t\n\t\tfor (int v : g[0]) ans += m - adj[v].size();\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < City[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[City[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[CitySet[i][0]] < CityType2[(CitySet[i][0] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\n\n// ----- Variables ----- //\n\nint N, M, A, B, cycles;\n\nvector<vector<int> > G; // Graph\n\nvector<int> R;          // Cycles\n\nvector<int> D;          // Distance\n\nvector<int> X, Y;       // X = Even, Y = Odd\n\nvector<long long> sum;\n\nvector<vector<long long> > dp;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\n\tG = vector<vector<int> >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\n\t\tG[A - 1].push_back(B - 1);\n\t\tG[B - 1].push_back(A - 1);\n\t}\n\n\tR = vector<int>(N, -1);\n\tD = vector<int>(N, -1);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (R[i] == -1)\n\t\t{\n\t\t\tqueue<int> que; que.push(i); D[i] = 0;\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint node = que.front(); que.pop();\n\n\t\t\t\tR[node] = cycles;\n\n\t\t\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tif (R[G[node][j]] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tR[G[node][j]] = cycles;\n\t\t\t\t\t\tD[G[node][j]] = D[node] + 1;\n\n\t\t\t\t\t\tque.push(R[G[node][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcycles++;\n\t\t}\n\t}\n\n\tX = vector<int>(cycles, 0);\n\tY = vector<int>(cycles, 0);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (D[i] % 2 == 0)\n\t\t{\n\t\t\tX[R[i]]++;\n\t\t}\n\n\t\tif (D[i] % 2 == 1)\n\t\t{\n\t\t\tY[R[i]]++;\n\t\t}\n\t}\n\n\tsum = vector<long long>(N); sum[0] = X[0] + Y[0];\n\n\tfor (int i = 1; i < N; i++) sum[i] = sum[i - 1] + X[i] + Y[i];\n\n\tlong long ret = 0;\n\n\tfor (int i = 0; i < cycles; i++)\n\t{\n\t\tret += 1LL * X[i] * Y[i];\n\t}\n\n\tret -= M;\n\n\tdp = vector<vector<long long> >(cycles + 1, vector<long long>(N >> 1 + 1, 0));\n\n\tfor (int i = 1; i <= cycles; i++)\n\t{\n\t\tfor (int j = 0; j <= (N >> 1); j++)\n\t\t{\n\t\t\tdp[i][j] = dp[i - 1][j] + 1LL * Y[i - 1] * j; // Select Y\n\n\t\t\tif (j - X[i - 1] >= 0)\n\t\t\t{\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i - 1][j - X[i - 1]] + X[i - 1] * (sum[i - 1] - j));\n\t\t\t}\n\t\t}\n\t}\n\n\tret += *max_element(dp[cycles].begin(), dp[cycles].end());\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nset<P> used[N];\n\nint dfs(int idx, int a,int b){\n  if(used[idx].count(P(a,b))) return -1;\n  used[idx].insert(P(a,b));\n\n  if(idx == (int)A.size()) return a*b;\n  int na = a+A[idx].first,nb = b+A[idx].second;\n  if(na>nb) swap(na,nb);\n  int s = dfs(idx+1,na,nb);\n\n  na = a+A[idx].second,nb = b+A[idx].first;\n  if(na>nb) swap(na,nb);\n  int t = dfs(idx+1,na,nb);\n  return max(s,t);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A.push_back(cnt);\n  }\n\n  sort(A.begin(),A.end());\n  if(flag) cout<<\"-1\"<<endl;\n  else cout<<dfs(0,0,0)-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  vector<int> df2(cnt);\n  REP(i,cnt) {\n    df2[i] = 2 * abs(sum[2*i]);\n  }\n  sort(ALL(df2));\n  int ofs = 0;\n  REP(i,cnt) if (!df2[i]) ++ofs;\n  int twice = 0;\n  REP(i,cnt) twice += df2[i];\n  vector<bool> dp(twice+1);\n  dp[0] = 1;\n  REP(i,cnt-ofs) {\n    auto tmp = dp;\n    REP(j,twice-df2[i+ofs]+1) {\n      if (dp[j])\n        tmp[j+df2[i+ofs]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,twice+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int smaller = v/2 - mn/2;\n  int larger = v - smaller;\n  int m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V,E;\nvector<int> G[100005];\nvector<int> A,B;\nbool flg=false;\nbool visited[100005];\nint depth[100005];\nint cnt[2];\n\nvoid dfs(int pos,int d){\n  \n  if(visited[pos]){\n    if(depth[pos]!=d)flg=true;\n    return;\n  }\n  \n  visited[pos]=true;\n  depth[pos]=d;\n  cnt[d]++;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    dfs(to,1-d);\n  }\n}\n\ntypedef long long ll;\nint dp[100005];\nint cc[100005];\n\nll solve(){\n  if(flg)return -1;\n  \n  map<int,int> mp;\n  int sum=0;\n  for(int i=0;i<(int)A.size();i++){\n    int mn=min(A[i],B[i]);\n    int mx=max(A[i],B[i]);\n    sum+=mn;\n    mp[mx-mn]++;\n  }\n  dp[0]=1;\n  map<int,int>::iterator it;\n  for(it=mp.begin();it!=mp.end();it++){\n    int a=it->first,b=it->second;\n    if(a==0)continue;\n    \n    \n    memset(cc,0,sizeof(cc));    \n    for(int i=0;i<=V;i++){\n      int k=0;\n      if(i-a>=0)k+=cc[i-a];\n      if(i-a*b-a>=0)k-=cc[i-a*b-a];\n      if(k>0)dp[i]=1;\n      \n      cc[i]=dp[i];\n      if(i-a>=0)cc[i]+=cc[i-a];\n    }\n  }\n  ll ans=0;\n  for(int i=0;i<=V;i++){\n    if(dp[i]){\n      ans=max(ans, (ll)(i+sum)*(ll)(V-i-sum) );\n    }\n  }\n  return ans-(ll)E;\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);    \n  }\n  for(int i=0;i<V;i++){\n    if(visited[i])continue;\n    cnt[0]=cnt[1]=0;\n    dfs(i,0);\n    A.push_back(cnt[0]);\n    B.push_back(cnt[1]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\n\nint main(){\n\tcin>>n;\n\tcout<<n+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100010\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<int> G[N];\nint flag;\nint col[N];\n\nP cnt;\nvoid dfs(int pos,int c){\n  if(col[pos]!=-1 && c!=col[pos]) flag = 1;\n  if(col[pos]!=-1 && c==col[pos]) return; \n  if(flag) return;\n  c? cnt.first++:cnt.second++;\n  col[pos] = c;\n  for(int nx:G[pos])dfs(nx,!c);\n}\n\nvector<P> A;\nset<P> used[N];\n\nint dfs(int idx, int a,int b){\n  if(used[idx].count(P(a,b))) return -1;\n  used[idx].insert(P(a,b));\n\n  if(idx == (int)A.size()) return a*b;\n  int na = a+A[idx].first;\n  int nb = b+A[idx].second;\n  if(na>nb) swap(na,nb);\n  int s = dfs(idx+1,na,nb);\n\n  na = a+A[idx].second;\n  nb = b+A[idx].first;\n  if(na>nb) swap(na,nb);\n  int t = dfs(idx+1,na,nb);\n  return max(s,t);\n}\n\nsigned main(){\n  int m;\n  cin>>n>>m;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  memset(col,-1,sizeof(col));\n  for(int i=0;i<n;i++) {\n    if(col[i]!=-1)continue;\n    cnt = P(0,0); \n    dfs(i,0);\n    A.push_back(cnt);\n  }\n\n  sort(A.begin(),A.end());\n  if(flag) cout<<\"-1\"<<endl;\n  else cout<<dfs(0,0,0)-m<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint V, E, a, b, col[100009]; bool flag; vector<int> g[100009];\nvoid dfs(int pos) {\n\ta++;\n\tif (col[pos] == 1) b++;\n\tfor (int i : g[pos]) {\n\t\tif (col[pos] == col[i]) flag = true;\n\t\tif (!col[i]) col[i] = 3 - col[pos], dfs(i);\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &V, &E);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tbitset<100001> dp = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (!col[i]) {\n\t\t\ta = b = 0; col[i] = 1;\n\t\t\tdfs(i);\n\t\t\tif (b * 2 > a) b = a - b;\n\t\t\tcur += b;\n\t\t\tdp |= dp << (a - b * 2);\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = cur; i <= V; i++) {\n\t\tif (dp[i - cur]) ret = max(ret, 1LL * i * (V - i));\n\t}\n\tprintf(\"%lld\\n\", (flag ? -1LL : ret - E));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[City[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] < CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[Bipartite[CitySet[i][j]]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[Bipartite[CitySet[i][0]]]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType[0], CityType[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 29)\n\nusing namespace std;\n\nint V, E, A, B;\n\nvector<vector<int> > City;\nvector<vector<int> > CitySet;\n\nvector<int> CityType;\nvector<int> Bipartite;\n\nlong long count_;\n\nint main()\n{\n\t// ------ Graph Construction ------ //\n\n\tcin >> V >> E;\n\n\tCity = vector<vector<int> >(V);\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tCity[A - 1].push_back(B - 1);\n\t\tCity[B - 1].push_back(A - 1);\n\t}\n\n\n\t// ------ Shortest Path ------ //\n\n\tvector<int> Bipartite(V, 2); // 0 --> 0, 1 --> 1, 2 --> Unknown\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (Bipartite[i] == 2)\n\t\t{\n\t\t\tCitySet.push_back(vector<int>());\n\n\t\t\tvector<int> D(V, INF); D[i] = 0;\n\n\t\t\tpriority_queue<pair<int, int> > que; que.push(make_pair(0, i));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tpair<int, int> p1 = que.top(); que.pop();\n\n\t\t\t\tint u = p1.second;\n\n\t\t\t\tCitySet.back().push_back(u);\n\n\t\t\t\tBipartite[u] = (p1.first * (-1)) % 2;\n\n\t\t\t\tif (D[u] < p1.first * (-1)) { continue; }\n\n\t\t\t\tfor (int j = 0; j < City[u].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint v = City[u][j];\n\n\t\t\t\t\tif (D[v] > D[u] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[v] = D[u] + 1;\n\n\t\t\t\t\t\tque.push(make_pair(D[v] * (-1), v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// ------ Minus One ------ //\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < City[i].size(); j++)\n\t\t{\n\t\t\tif (Bipartite[i] == Bipartite[City[i][j]])\n\t\t\t{\n\t\t\t\tcout << -1 << endl; goto Exit;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t// ------ Search ------ //\n\n\tcount_ = 0;\n\n\tfor (int i = 0; i < CitySet.size(); i++)\n\t{\n\t\tvector<long long> F(2, 0);\n\n\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tF[Bipartite[CitySet[i][j]]]++;\n\t\t}\n\n\t\tcount_ += F[0] * F[1];\n\t}\n\n\tcount_ -= E;\n\n\tCityType = vector<int>(2, 0);\n\n\tfor (int i = 0; i < CitySet[0].size(); i++)\n\t{\n\t\tCityType[Bipartite[CitySet[0][i]]]++;\n\t}\n\n\tfor (int i = 1; i < CitySet.size(); i++)\n\t{\n\t\tvector<int> CityType2(CityType.begin(), CityType.end());\n\n\t\tif (CityType2[Bipartite[CitySet[i][0]]] > CityType2[(Bipartite[CitySet[i][0]] + 1) % 2])\n\t\t{\n\t\t\tfor (int j = 0; j < CitySet[i].size(); j++)\n\t\t\t{\n\t\t\t\tBipartite[CitySet[i][j]] = (Bipartite[CitySet[i][j]] + 1) % 2; // Graph Reverse\n\t\t\t}\n\t\t}\n\n\t\tcount_ += CityType2[(Bipartite[CitySet[i][0]] + 1) % 2]; CityType[Bipartite[CitySet[i][0]]]++;\n\n\t\tfor (int j = 1; j < CitySet[i].size(); j++)\n\t\t{\n\t\t\tcount_ += max(CityType2[0], CityType2[1]);\n\t\t}\n\t}\n\n\tcout << count_ << endl;\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\ntypedef pair<int,int> P;\nbool dp[2][MAX_V];\nint solve(){\n  vector<P> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(P(a[1],a[0]));\n    else return -1;\n  }\n  int k=0;\n  memset(dp[0],0,sizeof(dp[0]));\n  dp[0][0]=1;\n  for(int i=0;i<(int)v.size();i++){\n    bool f=i%2;\n    memset(dp[!f],0,sizeof(dp[!f]));\n    for(int j=0;j<=V/2;j++){\n      if(dp[f][j]) dp[!f][j+v[i].first]=dp[!f][j+v[i].second]=1;\n    }\n  }\n  for(int i=0;i<V;i++){\n    if(dp[v.size()%2][i]){\n      if((V-k)*k<(V-i)*i) k=i;\n    }\n  }\n  return (V-k)*k-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int V, E;\n\tcin >> V >> E;\n\tvector<vector<long long int>>path( V );\n\tfor( size_t i = 0; i < E; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tpath[a].push_back( b );\n\t\tpath[b].push_back( a );\n\t}\n\tvector<bool>flag( V );\n\tvector<pair<long long int, long long int>>two;\n\tvector<long long int>len( V, LLONG_MAX / 6 );\n\tfor( size_t i = 0; i < V; i++ ) {\n\t\tif( !flag[i] ) {\n\t\t\tflag[i] = true;\n\t\t\tlen[i] = 0;\n\t\t\tpair<long long int, long long int>memo( 1, 0 );\n\t\t\tqueue<pair<long long int, long long int>>que;\n\t\t\tque.push( make_pair( 0, i ) );\n\t\t\twhile( que.size() ) {\n\t\t\t\tauto now = que.front(); que.pop();\n\t\t\t\tfor( auto x : path[now.second] ) {\n\t\t\t\t\tif( flag[x] ) {\n\t\t\t\t\t\tif( len[x] % 2 == now.first % 2 ) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflag[x] = true;\n\t\t\t\t\t\tlen[x] = now.first + 1;\n\t\t\t\t\t\tif( len[x] % 2 ) {\n\t\t\t\t\t\t\tmemo.second++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemo.first++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push( make_pair( len[x], x ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttwo.push_back( memo );\n\t\t}\n\t}\n\tvector<long long int>sub( two.size() );\n\tset<long long int>dp;\n\tdp.insert( 0 );\n\tlong long int xx = 0;\n\n\tfor( size_t i = 0; i < two.size(); i++ ) {\n\t\tsub[i] = abs( two[i].first - two[i].second );\n\t}\n\tsort( sub.rbegin(), sub.rend() );\n\n\tif( sub.size() % 2 ) {\n\t\tsub.push_back( 0 );\n\t}\n\tfor( size_t i = 0; i + 1 < two.size(); i += 2 ) {\n\t\tif( xx > 0 ) {\n\t\t\txx -= sub[i + 1] - sub[i];\n\t\t} else {\n\t\t\txx += sub[i + 1] - sub[i];\n\t\t}\n\t}\n\n\tcout << ( V - xx ) / 2 * ( ( V - xx ) / 2 + xx ) - E << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nbool ok = true;\n\nint f(int u, int x, vector<vector<int> >& G, vector<int>& vis) {\n\tvis[u] = x;\n\tint sum = 1;\n\tfor (int i = 0; i < G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif (vis[v] == x) ok = false;\n\t\tif (vis[v] != -1) continue;\n\t\tsum -= f(v, !x, G, vis);\n\t}\n\treturn sum;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--; y--;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvector<int> vis(N, -1);\n\tint n = 0;\n\tvector<int> a(N + 1);\n\tfor (int u = 0; u < N; u++)\n\t\tif (vis[u] == -1) {\n\t\t\tint x = abs(f(u, 0, G, vis));\n\t\t\tn += x;\n\t\t\ta[x]++;\n\t\t}\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<bool> dp(n + 1);\n\tdp[0] = true;\n\tfor (int x = 1; x <= N; x++)\n\t\tfor (int y = 1; a[x]; y *= 2) {\n\t\t\tint z = min(a[x], y);\n\t\t\ta[x] -= z;\n\t\t\tfor (int k = n; k - z * x >= 0; k--)\n\t\t\t\tif (dp[k - z * x])\n\t\t\t\t\tdp[k] = true;\n\t\t}\n\tll ma = 0;\n\tfor (int k = 0; k <= n; k++)\n\t\tif (dp[k])\n\t\t\tma = max(ma, (ll)((N - n) / 2 + k) * ((N - n) / 2 + (n - k)));\n\tcout << ma - M << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 1000000000;\n\nbool dfs(vector<vector<int>>& g, int i, vector<int>& clr, int cnt, int odd = 1) {\n  clr[i] = 2 * cnt + odd;\n  bool ok = true;\n  for (int nx : g[i]) {\n    if (clr[nx] == clr[i]) return false;\n    if (clr[nx] != -1) continue;\n    ok = ok && dfs(g, nx, clr, cnt, 1-odd);\n  }\n  return ok;\n}\n\nint main() {\n  int v,e;\n  cin>>v>>e;\n  vector<vector<int>> g(v);\n  REP(i,e) {\n    int a,b;\n    cin>>a>>b;\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  vector<int> clr(v, -1);\n  bool ok = true;\n  int cnt = 0;\n  REP(i,v) {\n    if (clr[i] == -1) {\n      ok = ok && dfs(g, i, clr, cnt++);\n    }\n  }\n  if (!ok) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<int> sum(2*cnt);\n  REP(i,v) {\n    ++sum[clr[i]];\n  }\n  REP(i,cnt) {\n    sum[2*i] -= sum[2*i+1];\n  }\n  vector<int> df2(cnt);\n  REP(i,cnt) {\n    df2[i] = 2 * abs(sum[2*i]);\n  }\n  sort(ALL(df2));\n  int ofs = 0;\n  REP(i,cnt) if (!df2[i]) ++ofs;\n  int ofs2 = ofs;\n  REP(i,cnt) if (df2[i] == 1) ++ofs2;\n  int twice = 0;\n  REP(i,cnt) twice += df2[i];\n  vector<bool> dp(twice+1);\n  dp[0] = 1;\n  REP(i,cnt-ofs2) {\n    auto tmp = dp;\n    REP(j,twice-df2[i+ofs2]+1) {\n      if (dp[j])\n        tmp[j+df2[i+ofs2]] = true;\n    }\n    swap(tmp, dp);\n  }\n  int mn = INF;\n  REP(i,twice+1) {\n    if (dp[i]) mn = min(mn, abs(i - twice/2));\n  }\n  int64_t smaller = v/2 - mn/2 + ofs2-ofs;\n  if (smaller > v/2) smaller = v/2;\n  int64_t larger = v - smaller;\n  int64_t m = smaller * larger;\n  cout << (m - e) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph {\n\tstruct Vertex {\n\t\tVertex() {}\n\t};\n\tstruct Edge {\n\t\tint to;\n\t\tEdge(int t) : to(t) {}\n\t\tEdge() {}\n\t};\n\tint sz;\n\tvector<Vertex> v;\n\tvector<vector<Edge>> e;\n\tGraph(int n) : sz(n), v(n), e(n) {}\n\ttemplate<class... Args>\n\tinline void assign_vertex(int pos, Args... args) {\n\t\tv[pos] = Vertex(args...);\n\t}\n\ttemplate<class... Args>\n\tinline void add_edge(int pos, Args... args) {\n\t\te[pos].emplace_back(args...);\n\t}\n\tinline int size() {\n\t\treturn sz;\n\t}\n};\n\nstruct is_Biparite : Graph {\n\tis_Biparite(int n) : Graph(n) {}\n\tvector<pair<int, int>> is_biparite() {\n\t\tvector<pair<int, int>> res;\n\t\tvector<char> color(sz, -1);\n\t\tint count[2] = {0, 0};\n\t\tauto dfs = [&] (auto f, int v, int c) {\n\t\t\tif (color[v] == c) return true;\n\t\t\tif (color[v] != -1) return false;\n\t\t\tcolor[v] = c;\n\t\t\tcount[c]++;\n\t\t\tfor (auto& x: e[v]) {\n\t\t\t\tif (!f(f, x.to, 1 - c)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\tif (color[i] == -1 && !dfs(dfs, i, 0)) return vector<pair<int, int>>(0);\n\t\t\tif (count[0]) res.emplace_back(count[0], count[1]);\n\t\t\tcount[0] = count[1] = 0;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint V, E;\n\tcin >> V >> E;\n\tis_Biparite B(V);\n\tfor (int i = 0; i < E; i++) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tB.add_edge(a, b);\n\t\tB.add_edge(b, a);\n\t}\n\tauto res = B.is_biparite();\n\tif (res.size() == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tmap<int, int> m;\n\tint zero = 0;\n\tvector<pair<int, int>> w;\n\tfor (auto& x: res) {\n\t\tint diff = abs(x.first - x.second);\n\t\tzero += diff;\n\t\tm[diff]++;\n\t}\n\tfor (auto& x: m) {\n\t\tw.emplace_back(x.first*2, x.second);\n\t}\n\tvector<int> dp(zero * 2 + 1, -1);\n\tdp[0] = 0;\n\tfor (auto& x: w) {\n\t\tfor (int i = 0; i < (int) dp.size(); i++) {\n\t\t\tif (x.first >= 0) {\n\t\t\t\tif (dp[i] >= 0) {\n\t\t\t\t\tdp[i] = x.second;\n\t\t\t\t} else if (i < x.first || dp[i-x.first] <= 0) {\n\t\t\t\t\tdp[i] = -1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i] = dp[i-x.first] - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <= zero; i++) {\n\t\tif (dp[zero+i] >= 0 || dp[zero-i] >= 0) {\n\t\t\tlong long a = V + i;\n\t\t\tlong long b = V - i;\n\t\t\tcout << a * b / 4 - E << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define INF 1e9\n\nbool dfs(int now, const vector<vector<int> >& adj, vector<int>& history, int& a, int& b, int odd_even = 1){\n  history[now] = odd_even;\n  if(odd_even == 1){ ++a; }\n  else{ ++b; }\n  \n  for(int i = 0; i < (int)adj[now].size(); i++){\n    if(history[adj[now][i]] == odd_even){ return false; }\n    if(history[adj[now][i]] == 0)\n      if(!dfs(adj[now][i], adj, history, a, b, -odd_even))\n        return false;\n  }\n  \n  return true;\n}\n\n\nint main(void){\n  int v, e;\n  cin >> v >> e;\n\n  int input_a, input_b;\n  vector<vector<int> > adj(v);\n  for(int i = 0; i < e; i++){\n    cin >> input_a >> input_b;\n    --input_a;\n    --input_b;\n    adj[input_a].push_back(input_b);\n    adj[input_b].push_back(input_a);\n  }\n\n  int a_sum = 0, b_sum = 0;\n  vector<int> c_tmp;\n  vector<int> history(v, 0);\n  for(int i = 0; i < v; i++){\n    if(history[i] == 0){\n      int a = 0;\n      int b = 0;\n      if(!dfs(i, adj, history, a, b)){\n        cout << -1 << endl;\n        return 0;\n      }\n      else{\n        if(a > b){\n          int tmp = a;\n          a = b;\n          b = tmp;\n        }\n        a_sum += a;\n        b_sum += b;\n        c_tmp.push_back(b - a);\n      }\n    }\n  }\n  map<int, int> c_map;\n  for(size_t i = 0; i < c_tmp.size(); i++){ ++c_map[c_tmp[i]]; }\n\n  vector<pair<int, int> > c;\n  c.push_back(make_pair(0, INF));\n  for(map<int, int>::iterator it = c_map.begin(); it != c_map.end(); ++it){ c.push_back(*it); }\n  \n  int n = c.size();\n  vector<vector<int> > dp(n, vector<int>(v + 1, -INF));\n  dp[0][0] = INF;\n  for(int i = 1; i < n; i++)\n    for(int j = 0; j <= v; j++)\n      dp[i][j] = max(dp[i][j],\n                     dp[i - 1][j] >= 0 ? c[i].second :\n                     j >= c[i - 1].first ? dp[i][j - c[i].first] - 1 : (int)INF * (-1));\n    \n  \n  int minpoint = -1;\n  int mindiff = INF;\n  for(int i = 0; i <= v; i++){\n    if(dp[n - 1][i] >= 0){\n      int candiate = (a_sum + i) - (b_sum - i);\n      if(candiate < 0){ candiate *= -1; }\n      if(mindiff > candiate){\n        mindiff = candiate;\n        minpoint = i;\n      }\n    }\n  }\n\n  int ans = (a_sum + minpoint) * (b_sum - minpoint) - e;\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = i / (n / 2);\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M;\n    cin >> N >> M;\n    UnionFind uni(2 * N);\n    for(int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        uni.merge(a, b + N);\n        uni.merge(b, a + N);\n    }\n    set<i_i> st;\n    //ll maxi = 0;\n    bitset<50001> bits;\n    bits[0] = true;\n    for(int i = 0; i < N; i++) {\n        if(uni.issame(i, i + N)) {\n            cout << -1 << endl;\n            return 0;\n        }\n        i_i tmp = {uni.root(i), uni.root(i+N)};\n        if(tmp.first < tmp.second) swap(tmp.first, tmp.second);\n        if(st.count(tmp)) continue;\n        st.insert(tmp);\n        //cerr << i << \" \" << uni.size(i) << \" \" << uni.size(i+N) << endl;\n        //maxi += max(uni.size(i), uni.size(i+N));\n        bits = (bits << uni.size(i)) | (bits << uni.size(i+N));\n    }\n    /*\n    cerr << maxi << endl;\n    ll ans = maxi * (N - maxi) - M;\n    cout << ans << endl;\n    */\n    for(ll i = N / 2; i >= 0; i--) {\n        if(bits[i]) {\n            cout << i * (N - i) - M << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\nint V,E;\nvector<int> G[MAX_V];\nint used[MAX_V];\nvoid add_edge(int a,int b){\n  G[a].push_back(b);\n  G[b].push_back(a);\n}\nint a[2];\nbool dfs(int v,int c){\n  if(~used[v]) return used[v]==c;\n  bool f=1;\n  a[c]++;used[v]=c;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i],!c);\n  return f;\n}\nint solve(){\n  vector<int> v;\n  memset(used,-1,sizeof(used));\n  for(int i=0;i<V;i++){\n    if(used[i]>=0) continue;\n    a[0]=a[1]=0;\n    if(dfs(i,0)) v.push_back(abs(a[1]-a[0]));\n    else return -1;\n  }\n  int k=0;\n  sort(v.begin(),v.end(),greater<int>());\n  for(int i=0;i<(int)v.size();i++){\n    if(abs(k-v[i])<abs(k+v[i])) k-=v[i];\n    else k+=v[i];\n  }\n  k=abs(k);\n  return ((V-k)/2)*((V-k)/2+k)-E;\n}\nint main(){\n  cin>>V>>E;\n  for(int i=0,a,b;i<E;i++) cin>>a>>b,add_edge(a-1,b-1);\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> edge;\nvector<int> vertex;\n\nvoid color(int v,bool c){\n  if(vertex[v]!=-1){\n    if(vertex[v]!=c) throw \"nonbin\";\n    return;\n  }\n  vertex[v]=c;\n  for(int i=0;i<edge[v].size();i++){\n    color(edge[v][i],!c);\n  }\n  return;\n}\n\nvoid dfs(int v,vector<int> &used,vector<int>& con){\n  if(used[v]) return;\n  used[v]=true;\n  con.push_back(v);\n  for(int i=0;i<edge[v].size();i++){\n    dfs(edge[v][i],used,con);\n  }\n  return;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,e;\n  cin>>n>>e;\n  edge.resize(n);\n  for(int i=0;i<e;i++){\n    int a,b;\n    cin>>a>>b;\n    a--,b--;\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n  }\n  vector<vector<int>> chunk;\n  vector<int> used(n);\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      vector<int> con;\n      dfs(i,used,con);\n      chunk.push_back(con);\n    }\n  }\n  \n  vertex.resize(n,-1);\n  vector<int> dis;\n  int smsum=0;\n  for(int i=0;i<chunk.size();i++){\n    try{\n      color(chunk[i][0],0);\n    }catch(const char* ex){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int cnt1=0;\n    for(int j=0;j<chunk[i].size();j++){\n      cnt1+=vertex[chunk[i][j]];\n    }\n    smsum+=min(cnt1,int(chunk[i].size())-cnt1);\n    dis.push_back(abs(cnt1-(int(chunk[i].size())-cnt1)));\n  }\n  map<int,int> m;\n  for(int i=0;i<dis.size();i++){\n    if(!m.count(dis[i])){\n      m[dis[i]]=1;\n    }\n    else m[dis[i]]++;\n\n  }\n  \n  vector<vector<int>> s;\n  for(auto it=m.begin();it!=m.end();it++){\n    vector<int> ss;\n    int val=it->first;\n    int time=it->second;\n\n    for(int i=0;i<=time;i++){\n      ss.push_back(val*i);\n    }\n    s.push_back(ss);\n  }\n\n  set<int> ob(s[0].begin(),s[0].end());\n\n  for(int i=1;i<s.size();i++){\n\n    set<int> nexob;\n    for(auto v:s[i]){\n      for(auto vv:ob){\n\tnexob.insert(v+vv);\n      }\n    }\n    ob=nexob;\n  }\n\n\n  \n  long long int res=0;\n  for(auto v:ob){\n    long long int b=(smsum+v);\n    long long int a=(n-smsum-v);\n    res=max(res,a*b-e);\n  }\n  cout<<res<<endl;  \n  \n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\n\n\nfun main(args: Array<String>?): Unit {\n    val (v, e) = readLine()!!.trim().split(' ').map(String::toInt)\n    val color = IntArray(v){-1}\n    val nodes = Array(v){Stack<Int>()}\n    repeat(e){\n        val (a, b) = readLine()!!.trim().split( ' ').map(String::toInt)\n        nodes[a - 1].push(b - 1)\n        nodes[b - 1].push(a - 1)\n    }\n    val networks = ArrayList<Int>()\n    for (i in 0 until v) {\n        if (color[i] == -1) {\n            var diff = 1\n            color[i] = 0\n            val stack = Stack<Int>().also { it.push(i) }\n            while (stack.isNotEmpty()) {\n                val top = stack.pop()\n                for (next in nodes[top]) if (color[next] == -1) {\n                    color[next] = (color[top] + 1) % 2\n                    if (color[next] % 2 == 0) ++diff\n                    else --diff\n                    stack.push(next)\n                }else if (color[next] == color[top]) {\n                    println(-1)\n                    return\n                }\n            }\n            networks.add(Math.abs(diff))\n        }\n    }\n    val sum = networks.sum()\n    val canMake = BooleanArray(sum / 2 + 1){false}.also{it[0] = true}\n    for (s in networks) {\n        for (i in canMake.lastIndex - s downTo 0) if (canMake[i]) {\n            canMake[i + s] = true\n        }\n    }\n    val minDiff = canMake.lastIndex - canMake.lastIndexOf(true)\n    val side = v.toLong() / 2 - minDiff\n    println(side * (v - side) - e)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + j * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((long) (base + x) * (long) (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = -1;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + c * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + c * value] |= dp[i];\n\t\t\t\t\t\t\tif (dp[i])\n\t\t\t\t\t\t\t\tx = Math.max(x, i + c * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println((base + x) * (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c && i + j * value < dp.length; j++) {\n\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((long) (base + x) * (long) (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = -1;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i++) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + c * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + c * value] |= dp[i];\n\t\t\t\t\t\t\tif (dp[i])\n\t\t\t\t\t\t\t\tx = Math.max(x, i + c * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println((base + x) * (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int V, E;\n\n\tpublic static void main(String[] args) {\n\t\tV = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tSystem.out.println(solve());\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tg.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint A = Integer.parseInt(sc.next()) - 1;\n\t\t\tint B = Integer.parseInt(sc.next()) - 1;\n\t\t\tg.get(A).add(B);\n\t\t\tg.get(B).add(A);\n\t\t}\n\t\tint[] color = new int[V];\n\t\tArrays.fill(color, -1);\n\t\tlong ans = 0;\n\t\tint black = 0;\n\t\tint white = 0;\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (color[i] != -1) continue;\n\t\t\tlong[] count = { 0, 0 };\n\t\t\tint t = 0;\n\t\t\tint road = 0;\n\t\t\tArrayList<Integer> cur = new ArrayList<Integer>();\n\t\t\tcur.add(i);\n\t\t\twhile (!cur.isEmpty()) {\n\t\t\t\tcount[t] += cur.size();\n\t\t\t\tArrayList<Integer> next = new ArrayList<Integer>();\n\t\t\t\tfor (int p : cur) {\n\t\t\t\t\troad += g.get(p).size();\n\t\t\t\t\tfor (int n : g.get(p)) {\n\t\t\t\t\t\tif (color[n] != -1) {\n\t\t\t\t\t\t\tif (color[n] == t) return -1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[n] = 1 - t;\n\t\t\t\t\t\tnext.add(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t\tt = 1 - t;\n\t\t\t}\n\t\t\tans += count[0] * count[1] - road;\n\t\t\tlong max = Math.max(count[0], count[1]);\n\t\t\tlong min = Math.min(count[0], count[1]);\n\t\t\tans += max * black + min * white;\n\t\t\tblack += max;\n\t\t\twhite += min;\n\t\t}\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + j * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\t\tif (dp[i])\n\t\t\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((long)(base + x) * (long)(V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c && i + j * value < dp.length; j++) {\n\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((long) (base + x) * (long) (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tArrayList<Integer>[] g = new ArrayList[V];\n\t\tfor (int i = 0; i < g.length; i++)\n\t\t\tg[i] = new ArrayList<>();\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\tInteger[] color = new Integer[V];\n\t\tArrays.fill(color, -1);\n\t\tint base = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tif (color[i] == -1) {\n\t\t\t\tcolor[i] = 0;\n\t\t\t\tcounter[0] = 1;\n\t\t\t\tcounter[1] = 0;\n\t\t\t\tif (!dfs(g, color, i)) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbase += Math.min(counter[0], counter[1]);\n\t\t\t\t\tif (counter[0] != counter[1]) {\n\t\t\t\t\t\tint value = Math.abs(counter[0] - counter[1]);\n\t\t\t\t\t\tmap.put(Math.abs(value), map.containsKey(value) ? map.get(value) + 1 : 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] dp = new boolean[V / 2 - base + 1];\n\t\tdp[0] = true;\n\t\tIterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\n\t\tint x = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tEntry<Integer, Integer> entry = it.next();\n\t\t\tint value = entry.getKey();\n\t\t\tint c = entry.getValue();\n\t\t\tfor (int i = dp.length - 1; i >= 0; i--) {\n\t\t\t\tif (dp[i]) {\n\t\t\t\t\tfor (int j = 1; j <= c; j++) {\n\t\t\t\t\t\tif (i + j * value < dp.length) {\n\t\t\t\t\t\t\tdp[i + j * value] = true;\n\t\t\t\t\t\t\tif (dp[i])\n\t\t\t\t\t\t\t\tx = Math.max(x, i + j * value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println((base + x) * (V - x - base) - E);\n\t}\n\n\tint[] counter = new int[2];\n\n\tboolean dfs(ArrayList<Integer>[] g, Integer[] color, int cur) {\n\t\tfor (int v : g[cur]) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tcolor[v] = 1 ^ color[cur];\n\t\t\t\tcounter[color[v]]++;\n\t\t\t\tif (!dfs(g, color, v)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (color[cur] != (1 ^ color[v]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n//using Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            G = Enumerate(n, x => new List<int>());\n            c = Enumerate(n, x => -1);\n            for (int i = 0; i < m; i++)\n            {\n                var a = sc.Integer() - 1;\n                var b = sc.Integer() - 1;\n                G[a].Add(b);\n                G[b].Add(a);\n            }\n            var cnt = new int[n + 1];\n            var min = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (c[i] == -1)\n                {\n                    var x = new int[2];\n                    dfs(i, 0, x);\n                    if (x[0] == -1)\n                    {\n                        IO.Printer.Out.WriteLine(-1);\n                        return;\n                    }\n                    min += x.Min();\n                    cnt[x.Max() - x.Min()]++;\n                }\n            }\n            //Debug.WriteLine(string.Join(\" \", cnt));\n            var dp = new bool[n + 1];\n            dp[0] = true;\n            var rem = 0;\n            for (int i = 1; i <= n; i++)\n            {\n                if (cnt[i] == 0) continue;\n                rem += cnt[i] * i;\n                var X = new List<int>();\n                var k = cnt[i];\n                for (int j = 0; j < 20; j++)\n                {\n                    if (k > 1 << j) { X.Add((1 << j) * i); k -= 1 << j; }\n                    else { X.Add(k * i); break; }\n                }\n                foreach (var x in X)\n                {\n                    for (int j = n; j >= 0; j--)\n                        if (dp[j] && j + x <= n) dp[j + x] |= dp[j];\n                }\n            }\n            //Debug.WriteLine(string.Join(\" \", dp.Select(x => x ? 1 : 0)));\n            var max = 0L;\n            for (int i = 0; i <= n; i++)\n            {\n                if (dp[i])\n                {\n                    max = Math.Max(max, 1L * (min + i) * (min + rem - i) - m);\n                }\n            }\n            IO.Printer.Out.WriteLine(max);\n\n        }\n        int[] c;\n        List<int>[] G;\n\n        void dfs(int cur, int k, int[] a)\n        {\n            c[cur] = k;\n            a[k]++;\n            foreach (var to in G[cur])\n            {\n                if (c[to] == -1) dfs(to, k ^ 1, a);\n                else if (c[to] == k)\n                {\n                    a[0] = -1;\n                    a[1] = -1;\n                    return;\n                }\n            }\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Knapsack\n\tdef initialize(items, budget)\n\t\t@items = items\n\t\t@budget = budget\n\t\t@states = []\n\tend\n\n\tdef solve\n\t\t@items = @items.sort_by{|c, v| -v.to_f / c}\n\t\t@left_value = 0\n\t\t@left_cost = 0\n\t\ti = 0\n\t\twhile i < @items.size\n\t\t\tc, v = @items[i]\n\t\t\tbreak if @left_cost + c > @budget\n\t\t\t@left_cost += c\n\t\t\t@left_value += v\n\t\t\ti += 1\n\t\tend\n\n\t\t@l = @r = i\n\t\t@lower_bound = @left_value\n\n\t\treturn @left_value if @left_cost == @budget || @l == @items.size || @items.size == 1\n\n\t\t@states << [@left_cost, @left_value]\n\t\t@states << [@left_cost + @items[@l][0], @left_value + @items[@l][1]]\n\t\n\t\tloop {\n\t\t\tif @r < @items.size - 1\n\t\t\t\t@r += 1\n\t\t\t\tadded = @items[@r]\n\t\t\t\t@states += @states.map{|c, v| [c + added[0], v + added[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\t\n\t\t\tif @l > 0\n\t\t\t\t@l -= 1\n\t\t\t\tremoved = @items[@l]\n\t\t\t\t@left_cost -= removed[0]\n\t\t\t\t@left_value -= removed[1]\n\t\t\t\t@states += @states.map{|c, v| [c - removed[0], v - removed[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\n\t\t}\n\t\n\t\treturn @lower_bound\n\tend\n\nprivate\n\tdef upper_bound(cost, value)\n\t\tif cost <= @budget\n\t\t\t@r == @items.size-1 ?\n\t\t\tvalue : value + (@budget - cost).to_f * @items[@r+1][1] / @items[@r+1][0] else\n\t\t\t@l == 0 ?\n\t\t\tvalue :\n\t\t\tvalue + (@budget - cost).to_f * @items[@l-1][1] / @items[@l-1][0]\n\t\tend\n\tend\n\n\tdef prun\n\t\t@states.reject!{|c, v|\n\t\t\tnext true if c - @left_cost > @budget\n\t\t\tnext true if upper_bound(c, v) < @lower_bound+1\n\t\t\tfalse\n\t\t}\n\t\thash = Hash.new(0)\n\t\t@states.each{|c, v|\n\t\t\thash[c] = v if v > hash[c]\n\t\t}\n\t\t@states = hash.to_a\n\tend\n\n\tdef update_lower_bound\n\t\t@states.each{|c, v|\t\n\t\t\t@lower_bound = v if c <= @budget && v > @lower_bound\n\t\t}\n\tend\nend\n\ndef knapsack_core(items, budget)\n\tk = Knapsack.new(items, budget)\n\tk.solve\nend\n\ndef knapsack_preprocess(items, budget)\n\tcost_group = items.group_by(&:first)\n\titems = cost_group.map{|c, group|\n\t\tgroup.sort_by(&:last).last(budget / c)\n\t}.inject([], &:+)\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\tdiff = -count.sort.inject(:-)\n\tdiffs << diff unless diff == 0\n}\n\ntotal = diffs.inject(:+)\nitems = diffs.map{|x| [x, x]}\nd = total/2 - knapsack_core(items, total/2)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\n\tdiffs << -count.sort.inject(:-)\n}\n\ntotal = diffs.inject(:+)\nd = total/2 - knapsack(diffs.map{|x| [x, x]}, total/2)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Knapsack\n\tdef initialize(items, budget)\n\t\t@items = items\n\t\t@budget = budget\n\t\t@states = []\n\tend\n\n\tdef solve\n\t\t@items = @items.sort_by{|c, v| -v.to_f / c}\n\t\t@left_value = 0\n\t\t@left_cost = 0\n\t\ti = 0\n\t\twhile i < @items.size\n\t\t\tc, v = @items[i]\n\t\t\tbreak if @left_cost + c > @budget\n\t\t\t@left_cost += c\n\t\t\t@left_value += v\n\t\t\ti += 1\n\t\tend\n\n\t\t@l = @r = i\n\t\t@lower_bound = @left_value\n\n\t\treturn @left_value if @left_cost == @budget || @l == @items.size\n\n\t\t@states << [@left_cost, @left_value]\n\t\t@states << [@left_cost + @items[@l][0], @left_value + @items[@l][1]]\n\t\n\t\tloop {\n\t\t\tif @r < @items.size - 1\n\t\t\t\t@r += 1\n\t\t\t\tadded = @items[@r]\n\t\t\t\t@states += @states.map{|c, v| [c + added[0], v + added[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\t\n\t\t\tif @l > 0\n\t\t\t\t@l -= 1\n\t\t\t\tremoved = @items[@l]\n\t\t\t\t@left_cost -= removed[0]\n\t\t\t\t@left_value -= removed[1]\n\t\t\t\t@states += @states.map{|c, v| [c - removed[0], v - removed[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\n\t\t}\n\t\n\t\treturn @lower_bound\n\tend\n\nprivate\n\tdef upper_bound(cost, value)\n\t\tif cost <= @budget\n\t\t\t@r == @items.size-1 ?\n\t\t\tvalue : value + (@budget - cost).to_f * @items[@r+1][1] / @items[@r+1][0] else\n\t\t\t@l == 0 ?\n\t\t\tvalue :\n\t\t\tvalue + (@budget - cost).to_f * @items[@l-1][1] / @items[@l-1][0]\n\t\tend\n\tend\n\n\tdef prun\n\t\t@states.reject!{|c, v|\n\t\t\tnext true if c - @left_cost > @budget\n\t\t\tnext true if upper_bound(c, v) < @lower_bound+1\n\t\t\tfalse\n\t\t}\n\t\thash = Hash.new(0)\n\t\t@states.each{|c, v|\n\t\t\thash[c] = v if v > hash[c]\n\t\t}\n\t\t@states = hash.to_a\n\tend\n\n\tdef update_lower_bound\n\t\t@states.each{|c, v|\t\n\t\t\t@lower_bound = v if c <= @budget && v > @lower_bound\n\t\t}\n\tend\nend\n\ndef knapsack_core(items, budget)\n\tk = Knapsack.new(items, budget)\n\tk.solve\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tp i\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\ndef knapsack_preprocess(items, budget)\n\tcost_group = items.group_by(&:first)\n\titems = cost_group.map{|c, group|\n\t\tgroup.sort_by(&:last).last(budget / c)\n\t}.inject([], &:+)\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\tdiff = -count.sort.inject(:-)\n\tdiffs << diff unless diff == 0\n}\n\ntotal = diffs.inject(:+)\nitems = diffs.map{|x| [x, x]}\nd = total/2 - knapsack_core(items, total/2)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Knapsack\n\tdef initialize(items, budget)\n\t\t@items = items\n\t\t@budget = budget\n\t\t@states = []\n\tend\n\n\tdef solve\n\t\t@items.sort_by!{|c, v| -v.to_f / c}\n\t\t@left_value = 0\n\t\t@left_cost = 0\n\t\ti = 0\n\t\twhile i < @items.size\n\t\t\tc, v = @items[i]\n\t\t\tbreak if @left_cost + c > @budget\n\t\t\t@left_cost += c\n\t\t\t@left_value += v\n\t\t\ti += 1\n\t\tend\n\n\t\t@l = @r = i\n\t\t@lower_bound = @left_value\n\n\t\treturn @left_value if @left_cost == @budget || @l == @items.size || @items.size == 1\n\n\t\t@states << [@left_cost, @left_value]\n\t\t@states << [@left_cost + @items[@l][0], @left_value + @items[@l][1]]\n\t\t@states\n\t\n\t\tloop {\n\t\t\tif @r < @items.size - 1\n\t\t\t\t@r += 1\n\t\t\t\tadded = @items[@r]\n\t\t\t\t@states += @states.map{|c, v| [c + added[0], v + added[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\t\n\t\t\tif @l > 0\n\t\t\t\t@l -= 1\n\t\t\t\tremoved = @items[@l]\n\t\t\t\t@left_cost -= removed[0]\n\t\t\t\t@left_value -= removed[1]\n\t\t\t\t@states += @states.map{|c, v| [c - removed[0], v - removed[1]]}\n\t\t\t\tupdate_lower_bound\n\t\t\t\tprun\n\t\t\t\tbreak if @states.empty?\n\t\t\tend\n\t\t}\n\t\n\t\treturn @lower_bound\n\tend\n\nprivate\n\tdef upper_bound(cost, value)\n\t\tif cost <= @budget\n\t\t\t@r == @items.size-1 ?\n\t\t\tvalue : value + (@budget - cost).to_f * @items[@r+1][1] / @items[@r+1][0] else\n\t\t\t@l == 0 ?\n\t\t\tvalue :\n\t\t\tvalue + (@budget - cost).to_f * @items[@l-1][1] / @items[@l-1][0]\n\t\tend\n\tend\n\n\tdef prun\n\t\t@states.reject!{|c, v|\n\t\t\tnext true if c - @left_cost > @budget\n\t\t\tnext true if upper_bound(c, v) < @lower_bound+1\n\t\t\tfalse\n\t\t}\n\t\thash = Hash.new(0)\n\t\t@states.each{|c, v|\n\t\t\thash[c] = v if v > hash[c]\n\t\t}\n\t\t@states = hash.to_a\n\tend\n\n\tdef update_lower_bound\n\t\t@states.each{|c, v|\t\n\t\t\t@lower_bound = v if c <= @budget && v > @lower_bound\n\t\t}\n\tend\nend\n\ndef knapsack_core(items, budget)\n\tk = Knapsack.new(items, budget)\n\tk.solve\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tp i\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\ndef knapsack_preprocess(items, budget)\n\tcost_group = items.group_by(&:first)\n\titems = cost_group.map{|c, group|\n\t\tgroup.sort_by(&:last).last(budget / c)\n\t}.inject([], &:+)\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\tdiff = -count.sort.inject(:-)\n\tdiffs << diff unless diff == 0\n}\n\ntotal = diffs.inject(:+)\nitems = diffs.map{|x| [x, x]}\nd = total/2 - knapsack_core(knapsack_preprocess(items, total/2), total/2)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\n\tdiffs << -count.sort.inject(:-)\n}\n\ntotal = diffs.inject(:+)\nd = total/2 - knapsack(diffs.map{|x| [x, x]}, total/2)\np (n/2 + d) * ((n+1)/2 - d) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n\n\tdiffs << -count.sort.inject(:-)\n}\n\ntotal = diffs.inject(:+)\nd = total/2 - knapsack(diffs.map{|x| [x, x]}, total/2+1)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\ndef knapsack(items, budget)\n\ttable = (0..1).map{ Array.new(budget+1, 0) }\n\tfor i in 0..items.size-1\n\t\tc, v = items[i]\n\t\tfor j in 0..budget\n\t\t\tx = table[0][j]\n\t\t\ty = (j >= c ? table[0][j-c] + v : 0)\n\t\t\ttable[1][j] = x > y ? x : y\n\t\tend\n\t\ttable << table.shift\n\tend\n\ttable[0][budget]\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\nnodes = (0..n).map{g.add_node}\nm.times {\n\ti, j = gets.split.map &:to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\ndiffs = []\ncolor = {}\n\n(1..n).each{|i|\n\tu = nodes[i]\n\tnext if color[u]\n\tcolor[u] = 0\n\tcount = [0, 0]\n\n\tqueue = [u]\n\tuntil queue.empty?\n\t\tu = queue.shift\n\t\tc = color[u]\n\t\tcount[c] += 1\n\t\tg.each_out_connection_of(u){|v|\n\t\t\tif color[v] == c\n\t\t\t\tputs -1\n\t\t\t\texit\n\t\t\tend\n\t\t\tnext if color[v] \n\t\t\tcolor[v] = 1 - c\n\t\t\tqueue << v\n\t\t}\n\tend\n    diff = -count.sort.inject(:-)\n    diffs << diff unless diff == 0 \n}\n\ntotal = diffs.inject(:+)\nd = total/2 - knapsack(diffs.map{|x| [x, x]}, total/2)\nx = n / 2 - d\np x * (n - x) - m"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.typecons;\nimport std.stdio;\nimport std.algorithm;\nimport std.math;\n\nvoid main(){\n\tint v,e;\n\tscanf(\"%d%d\",&v,&e);\n\tint[][] graph = new int[][v];\n\tforeach(i;0..e){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tgraph[--a]~=--b;\n\t\tgraph[b]~=a;\n\t}\n\tint[] d=new int[v];\n\tint[] s=new int[v];\n\tint[] t=new int[v];\n\tvoid dfs(int i,int b,ref int e,ref int f){\n\t\tif(d[i])\n\t\t\treturn;\n\t\td[i]=b;\n\t\te++;\n\t\tforeach(c;graph[i])\n\t\t\tdfs(c,3-b,f,e);\n\t}\n\tforeach(i;0..v)\n\t\tdfs(i,1,s[i],t[i]);\n\tforeach(i;0..v)\n\t\tforeach(c;graph[i])\n\t\t\tif(d[i]==d[c]){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\tint g;\n\tint[int] h;\n\tforeach(i;0..v)\n\t\tif(s[i]||t[i]){\n\t\t\tg+=min(s[i],t[i]);\n\t\t\tint w=abs(s[i]-t[i]);\n\t\t\tif(w in h)\n\t\t\t\th[w]++;\n\t\t\telse\n\t\t\t\th[w]=1;\n\t\t}\n\tint[] dp=new int[v+1];\n\tstatic immutable int inf=1145141919;\n\tdp[]=inf;\n\tdp[0]=0;\n\tforeach(q;h.byKeyValue){\n\t\tforeach(ref x;dp)\n\t\t\tif(x<inf)x=0;\n\t\tforeach(i;q.key..v+1)\n\t\t\tif(dp[i-q.key]<q.value)\n\t\t\t\tdp[i]=min(dp[i],dp[i-q.key]+1);\n\t}\n//\twriteln(g,\" \",dp);\n\tlong ans=0;\n\tforeach(i,x;dp)\n\t\tif(x<inf)\n\t\t\tans=max(ans,cast(long)(g+i)*(v-g-i));\n\tprintf(\"%lld\\n\",ans-e);\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N, M = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        a, b = map(int, readline().split())\n        G[a-1].append(b-1)\n        G[b-1].append(a-1)\n    col = [-1]*N\n    C = {}\n    L0 = 0\n    L = 0\n    for i in range(N):\n        if col[i] != -1:\n            continue\n        que = deque([i])\n        col[i] = 0\n        cs = [1, 0]\n        while que:\n            v = que.popleft()\n            c = col[v]^1\n            for w in G[v]:\n                if col[w] != -1:\n                    if col[w] != c:\n                        write(\"-1\\n\")\n                        return\n                else:\n                    col[w] = c\n                    cs[c] += 1\n                    que.append(w)\n        e = abs(cs[1] - cs[0])\n        L += e\n        if e > 0:\n            C[e] = C.get(e, 0) + 1\n    W = L//2\n    dp = [0]*(W+1)\n    dp[0] = 1\n    for v, c in C.items():\n        for b in range(v):\n            s = 0\n            k0 = (W - b) // v * v + b\n            for i in range(c):\n                if k0-v*i >= 0:\n                    s += dp[k0-v*i]\n            for k in range(k0, -1, -v):\n                s -= dp[k]\n                if k-c*v >= 0:\n                    s += dp[k-c*v]\n                if s:\n                    dp[k] = 1\n    k = 0\n    for i in range(W, -1, -1):\n        if dp[i]:\n            k = i\n            break\n    A = (N - L) // 2 + k\n    B = (N - L) // 2 + L - k\n    write(\"%d\\n\" % (A*B - M))\nsolve()\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\nconst TRUE: &bool = &true;\nconst FALSE: &bool = &false;\n#[derive(Clone, Debug)]\n/// Efficient bool collection\npub struct BitSet {\n    buf: Vec<u64>,\n    size: usize,\n}\nimpl BitSet {\n    #[allow(dead_code)]\n    pub fn new(size: usize) -> BitSet {\n        BitSet {\n            buf: vec![0; (size + 63) / 64],\n            size: size,\n        }\n    }\n    #[allow(dead_code)]\n    pub fn set(&mut self, i: usize, b: bool) {\n        assert!(i < self.size);\n        if b {\n            self.buf[i >> 6] |= 1 << (i & 63);\n        } else {\n            self.buf[i >> 6] &= !(1 << (i & 63));\n        }\n    }\n    #[allow(dead_code)]\n    pub fn count_ones(&self) -> u32 {\n        self.buf.iter().map(|x| x.count_ones()).sum()\n    }\n    #[allow(dead_code)]\n    fn chomp(&mut self) {\n        let r = self.size & 63;\n        if r != 0 {\n            if let Some(x) = self.buf.last_mut() {\n                let d = 64 - r;\n                *x = (*x << d) >> d;\n            }\n        }\n    }\n}\nimpl std::ops::Index<usize> for BitSet {\n    type Output = bool;\n    fn index(&self, index: usize) -> &bool {\n        [FALSE, TRUE][(self.buf[index >> 6] >> (index & 63)) as usize & 1]\n    }\n}\nimpl std::ops::ShlAssign<usize> for BitSet {\n    fn shl_assign(&mut self, x: usize) {\n        let q = x >> 6;\n        let r = x & 63;\n        if q >= self.buf.len() {\n            for x in &mut self.buf {\n                *x = 0;\n            }\n            return;\n        }\n        if r == 0 {\n            for i in (q..self.buf.len()).rev() {\n                self.buf[i] = self.buf[i - q];\n            }\n        } else {\n            for i in (q + 1..self.buf.len()).rev() {\n                self.buf[i] = (self.buf[i - q] << r) | (self.buf[i - q - 1] >> (64 - r));\n            }\n            self.buf[q] = self.buf[0] << r;\n        }\n        for i in 0..q {\n            self.buf[i] = 0;\n        }\n        self.chomp();\n    }\n}\nimpl std::ops::Shl<usize> for BitSet {\n    type Output = Self;\n    fn shl(mut self, x: usize) -> Self {\n        self <<= x;\n        self\n    }\n}\nimpl std::ops::ShrAssign<usize> for BitSet {\n    fn shr_assign(&mut self, x: usize) {\n        let q = x >> 6;\n        let r = x & 63;\n        if q >= self.buf.len() {\n            for x in &mut self.buf {\n                *x = 0;\n            }\n            return;\n        }\n        if r == 0 {\n            for i in 0..self.buf.len() - q {\n                self.buf[i] = self.buf[i + q];\n            }\n        } else {\n            for i in 0..self.buf.len() - q - 1 {\n                self.buf[i] = (self.buf[i + q] >> r) | (self.buf[i + q + 1] << (64 - r));\n            }\n            let len = self.buf.len();\n            self.buf[len - q - 1] = self.buf[len - 1] >> r;\n        }\n        for i in self.buf.len() - q..self.buf.len() {\n            self.buf[i] = 0;\n        }\n    }\n}\nimpl std::ops::Shr<usize> for BitSet {\n    type Output = Self;\n    fn shr(mut self, x: usize) -> Self {\n        self >>= x;\n        self\n    }\n}\nimpl<'a> std::ops::BitAndAssign<&'a BitSet> for BitSet {\n    fn bitand_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a &= *b;\n        }\n    }\n}\nimpl<'a> std::ops::BitAnd<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitand(mut self, rhs: &'a Self) -> Self {\n        self &= rhs;\n        self\n    }\n}\nimpl<'a> std::ops::BitOrAssign<&'a BitSet> for BitSet {\n    fn bitor_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a |= *b;\n        }\n        self.chomp();\n    }\n}\nimpl<'a> std::ops::BitOr<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitor(mut self, rhs: &'a Self) -> Self {\n        self |= rhs;\n        self\n    }\n}\nimpl<'a> std::ops::BitXorAssign<&'a BitSet> for BitSet {\n    fn bitxor_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a ^= *b;\n        }\n        self.chomp();\n    }\n}\nimpl<'a> std::ops::BitXor<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitxor(mut self, rhs: &'a Self) -> Self {\n        self ^= rhs;\n        self\n    }\n}\n\nfn solve() {\n    let (n, e) = get!(usize, usize);\n    let ab = get!(usize, usize; e);\n\n    let mut g = vec![Vec::new(); n];\n\n    for (a, b) in ab {\n        g[a - 1].push(b - 1);\n        g[b - 1].push(a - 1);\n    }\n\n    let mut col = vec![None; n];\n    let mut xy = Vec::new();\n\n    for i in 0..n {\n        if col[i].is_none() {\n            let mut stack = vec![(i, true)];\n            let mut x = 0;\n            let mut y = 0;\n\n            while let Some((i, c)) = stack.pop() {\n                if col[i] == Some(!c) {\n                    println!(\"-1\");\n                    return;\n                }\n\n                if col[i] == Some(c) {\n                    continue;\n                }\n\n                col[i] = Some(c);\n\n                if c {\n                    x += 1;\n                } else {\n                    y += 1;\n                }\n\n                for &to in &g[i] {\n                    stack.push((to, !c));\n                }\n            }\n            xy.push((x, y));\n        }\n    }\n\n    let mut dp = BitSet::new(n + 1);\n    dp.set(0, true);\n\n    for (x, y) in xy {\n        let xx = (dp.clone()) << x;\n        let yy = (dp.clone()) << y;\n\n        dp |= &xx;\n        dp |= &yy;\n    }\n\n    let s = (0..n + 1)\n        .filter(|&i| dp[i])\n        .map(|i| i * (n - i))\n        .max()\n        .unwrap();\n\n    println!(\"{}\", s - e);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\nconst TRUE: &bool = &true;\nconst FALSE: &bool = &false;\n#[derive(Clone, Debug)]\n/// Efficient bool collection\npub struct BitSet {\n    buf: Vec<u64>,\n    size: usize,\n}\nimpl BitSet {\n    #[allow(dead_code)]\n    pub fn new(size: usize) -> BitSet {\n        BitSet {\n            buf: vec![0; (size + 63) / 64],\n            size: size,\n        }\n    }\n    #[allow(dead_code)]\n    pub fn set(&mut self, i: usize, b: bool) {\n        assert!(i < self.size);\n        if b {\n            self.buf[i >> 6] |= 1 << (i & 63);\n        } else {\n            self.buf[i >> 6] &= !(1 << (i & 63));\n        }\n    }\n    #[allow(dead_code)]\n    pub fn count_ones(&self) -> u32 {\n        self.buf.iter().map(|x| x.count_ones()).sum()\n    }\n    #[allow(dead_code)]\n    fn chomp(&mut self) {\n        let r = self.size & 63;\n        if r != 0 {\n            if let Some(x) = self.buf.last_mut() {\n                let d = 64 - r;\n                *x = (*x << d) >> d;\n            }\n        }\n    }\n}\nimpl std::ops::Index<usize> for BitSet {\n    type Output = bool;\n    fn index(&self, index: usize) -> &bool {\n        [FALSE, TRUE][(self.buf[index >> 6] >> (index & 63)) as usize & 1]\n    }\n}\nimpl std::ops::ShlAssign<usize> for BitSet {\n    fn shl_assign(&mut self, x: usize) {\n        let q = x >> 6;\n        let r = x & 63;\n        if q >= self.buf.len() {\n            for x in &mut self.buf {\n                *x = 0;\n            }\n            return;\n        }\n        if r == 0 {\n            for i in (q..self.buf.len()).rev() {\n                self.buf[i] = self.buf[i - q];\n            }\n        } else {\n            for i in (q + 1..self.buf.len()).rev() {\n                self.buf[i] = (self.buf[i - q] << r) | (self.buf[i - q - 1] >> (64 - r));\n            }\n            self.buf[q] = self.buf[0] << r;\n        }\n        for i in 0..q {\n            self.buf[i] = 0;\n        }\n        self.chomp();\n    }\n}\nimpl std::ops::Shl<usize> for BitSet {\n    type Output = Self;\n    fn shl(mut self, x: usize) -> Self {\n        self <<= x;\n        self\n    }\n}\nimpl std::ops::ShrAssign<usize> for BitSet {\n    fn shr_assign(&mut self, x: usize) {\n        let q = x >> 6;\n        let r = x & 63;\n        if q >= self.buf.len() {\n            for x in &mut self.buf {\n                *x = 0;\n            }\n            return;\n        }\n        if r == 0 {\n            for i in 0..self.buf.len() - q {\n                self.buf[i] = self.buf[i + q];\n            }\n        } else {\n            for i in 0..self.buf.len() - q - 1 {\n                self.buf[i] = (self.buf[i + q] >> r) | (self.buf[i + q + 1] << (64 - r));\n            }\n            let len = self.buf.len();\n            self.buf[len - q - 1] = self.buf[len - 1] >> r;\n        }\n        for i in self.buf.len() - q..self.buf.len() {\n            self.buf[i] = 0;\n        }\n    }\n}\nimpl std::ops::Shr<usize> for BitSet {\n    type Output = Self;\n    fn shr(mut self, x: usize) -> Self {\n        self >>= x;\n        self\n    }\n}\nimpl<'a> std::ops::BitAndAssign<&'a BitSet> for BitSet {\n    fn bitand_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a &= *b;\n        }\n    }\n}\nimpl<'a> std::ops::BitAnd<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitand(mut self, rhs: &'a Self) -> Self {\n        self &= rhs;\n        self\n    }\n}\nimpl<'a> std::ops::BitOrAssign<&'a BitSet> for BitSet {\n    fn bitor_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a |= *b;\n        }\n        self.chomp();\n    }\n}\nimpl<'a> std::ops::BitOr<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitor(mut self, rhs: &'a Self) -> Self {\n        self |= rhs;\n        self\n    }\n}\nimpl<'a> std::ops::BitXorAssign<&'a BitSet> for BitSet {\n    fn bitxor_assign(&mut self, rhs: &'a Self) {\n        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {\n            *a ^= *b;\n        }\n        self.chomp();\n    }\n}\nimpl<'a> std::ops::BitXor<&'a BitSet> for BitSet {\n    type Output = Self;\n    fn bitxor(mut self, rhs: &'a Self) -> Self {\n        self ^= rhs;\n        self\n    }\n}\n\nfn solve() {\n    let (n, e) = get!(usize, usize);\n    let ab = get!(usize, usize; e);\n\n    let mut g = vec![Vec::new(); n];\n\n    for (a, b) in ab {\n        g[a - 1].push(b - 1);\n        g[b - 1].push(a - 1);\n    }\n\n    let mut col = vec![None; n];\n    let mut xy = Vec::new();\n\n    for i in 0..n {\n        if col[i].is_none() {\n            let mut stack = vec![(i, true)];\n            let mut x = 0;\n            let mut y = 0;\n\n            while let Some((i, c)) = stack.pop() {\n                if col[i] == Some(!c) {\n                    println!(\"-1\");\n                    return;\n                }\n\n                if col[i] == Some(c) {\n                    continue;\n                }\n\n                col[i] = Some(c);\n\n                if c {\n                    x += 1;\n                } else {\n                    y += 1;\n                }\n\n                for &to in &g[i] {\n                    stack.push((to, !c));\n                }\n            }\n            xy.push((x, y));\n        }\n    }\n\n    let mut dp = BitSet::new(n + 1);\n    dp.set(0, true);\n\n    for (x, y) in xy {\n        let xx = (dp.clone()) << x;\n        let yy = (dp.clone()) << y;\n\n        dp = xx | &yy;\n    }\n\n    let s = (0..n + 1)\n        .filter(|&i| dp[i])\n        .map(|i| i * (n - i))\n        .max()\n        .unwrap();\n\n    println!(\"{}\", s - e);\n}\n\n"
  }
]