[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=a.s,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考 \n*/\n\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n/*\n\trep (i, n - 2 ){\n\t\tdouble sk = area2((point<double>)G[n-1], (point<double>)G[i], (point<double>)G[i+1] );\n\t\tS += sk;\n\t\tg.x += (G[i].x+G[i+1].x-2.*G[n-1].x)*sk;\n\t\tg.y += (G[i].y+G[i+1].y-2.*G[n-1].y)*sk;\n\t} // end rep\n\tg.x /= 3.*S;\n\tg.y /= 3.*S;\n*/\t\n\treturn g;\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n*/\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2442-2\", \"r\", stdin );\n\tint n;\n\tscanf (\"%d\", &n );\n\tint x, y;\n\tpolygon<double> G(n );\n\trep (i, n ) scanf (\"%d %d\", &x, &y ), G[i].x=(double)x, G[i].y=(double)y;\n\t\n\tpoint<double> cg = centerG(G );\n//\tcerr << \"cg:(\"<< cg.x << ',' << cg.y << ')' << endl;\n\tbool ok = true;\n\trep (i, n ){\n\t\tpoint<double> rp = symmetry_point (G[i], cg );\n\t\tbool good = false;\n\t\trep (j, n ){\n\t\t\tif (abs(rp-G[j])<EPS ){\n\t\t\t\tgood = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end rep\n\t\tif (!good ){\n\t\t\tok = false; break; \n\t\t} // end if\n\t} // end rep\n\tif (ok ){\n\t\tprintf (\"%.5lf %.5lf\\n\", cg.x, cg.y );\n\t}else{\n\t\tprintf (\"NA\\n\" );\n\t} // end if\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(getdis(a,p[i])!=getdis(a,p[n/2+i]))an=0;\n  }\n  double x=a.f,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nint main() {\n\tint N; cin >> N;\n\tif (N % 2 == 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i] >> Y[i];\n\tset<i_i> s;\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tint x = X[i] + X[N / 2 + i];\n\t\tint y = Y[i] + Y[N / 2 + i];\n\t\ts.insert(i_i(x, y));\n\t}\n\tif (s.size() > 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\ti_i p = *(s.begin());\n\tcout << p.first / 2.0 << ' ' << p.second / 2.0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <math.h>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t\tcx += p[i][0];\n\t\tcy += p[i][1];\n\t}\n\tcx /= n;\n\tcy /= n;\n\tif(n%2) f=1;\n\telse for(i = 0; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) /2 - cx) <= 0.0001 && fabs((p[i][1] + p[i + n/2][1]) /2 - cy) <= 0.0001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse cout << cx << \" \" << cy << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <math.h>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t}\n\tcx = (p[0][0] + p[n/2][0]) / 2;\n\tcy = (p[0][1] + p[n/2][1]) / 2;\n\tif(n%2) f=1;\n\telse for(i = 1; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) / 2 - cx) <= 0.0000001 && fabs((p[i][1] + p[i + n/2][1]) / 2 - cy) <= 0.0000001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse printf(\"%.9lf %.9lf\\n\", cx , cy);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vector<point> ps(N);\n    for(int i=0;i<N;i++){\n        cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(N % 2 == 0){\n        point p = ps[0] + ps[N/2];\n        bool ok = true;\n        for(int i=0;i<N/2;i++){\n            point np = ps[i] + ps[i+N/2];\n            if(abs(p-np) > EPS){\n                ok = false;\n            }\n        }\n        if(ok){\n            cout << (p/2.0).real() << \" \" << (p/2.0).imag() << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP centroidG(G g) {\n    int n = g.size();\n    double x = 0, y = 0;\n    rep(i, n) {\n        x += g[i].real();\n        y += g[i].imag();\n    }\n    return P(x / n, y / n);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nG rotG(G g, P p, double theta) {\n    rep(i, g.size()) {\n        g[i] = rotP(g[i], p, theta);\n    }\n    return g;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG() {\n    int n;\n    cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nbool EQ(double a, double b) {\n    return abs(a - b) < EPS;\n}\n\nbool EqP(P p, P q) {\n    return EQ(p.real(), q.real()) && EQ(p.imag(), q.imag());\n}\n\nbool EqG(G g, G h) {\n    if (g.size() != h.size()) return false;\n    rep(k, g.size()) {\n        bool flag = true;\n        rep(i, g.size()) {\n            if (!EqP(g[(i + k) % g.size()], h[i])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// void printG(G g) {\n//     rep(i, g.size()) {\n//         cout << g[i].real() << \" \" << g[i].imag() << endl;\n//     }\n//     cout << endl;\n// }\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    G g = readG();\n    P c = centroidG(g);\n    // cout << fixed << setprecision(10) << c.real() << \" \" << c.imag() << endl;\n    // cout << endl;\n\n    G h = rotG(g, c, PI);\n    // printG(g);\n    // printG(h);\n\n    if (EqG(g, h)) {\n        cout << fixed << setprecision(10) << c.real() << \" \" << c.imag() << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //??????\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //??????\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //??????\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //??????\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //?????????\n\tdouble abs() { return sqrt(norm()); }   //??§??????\n\tvoid normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}\t//??£??????\n};\nstruct C{P p;double r;};    //???\nstruct S{P p1,p2;};         //??????\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\ntypedef S L;                //??´???\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<P> pol,pol2;\n\tP min1=P(INF,INF),min2=P(INF,INF);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpol.pb(P(x,y));\n\t\tpol2.pb(P(-x,-y));\n\t\tmin1 = min(min1,P(x,y));\n\t\tmin2 = min(min2,P(-x,-y));\n\t}\n\t\n\trep(i,n){\n\t\tpol2[i]=pol2[i]+(min1-min2);\n\t}\n\t\n\tP cent;\n\trep(i,n)cent=cent+pol[i];\n\tcent=cent/n;\n\t\n\tsort(all(pol)),sort(all(pol2));\n\t\n\tbool f = true;\n\trep(i,n)if(pol[i].x!=pol2[i].x||pol[i].y!=pol2[i].y)f=false;\n\tif(f)printf(\"%.10lf %.10lf\\n\",cent.x,cent.y);\n\telse cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n/**************************************************************/\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// ???\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double c) {\n\t\treturn Point(c * x, c * y);\n\t}\n\tPoint operator / (double c) {\n\t\treturn Point(x / c, y / c);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n\t}\n\n\t// ?????????\n\tdouble norm() {\n\t\treturn (x * x + y * y);\n\t}\n\t// ??§??????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\n\n// ????????????\ntypedef Point Vector;\n\n// ??????\ndouble dot(Vector a, Vector b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\n// ??????\ndouble cross(Vector a, Vector b) {\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// ?????????\ndouble norm(Vector a) {\n\treturn (a.x * a.x + a.y * a.y);\n}\n\n// ??§??????\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\n// ??????\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\n// ??????(Parallel)????????????\nbool isParal(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParal(a1 - a2, b1 - b2);\n}\n\n// ?????????????????????????????????!!\nbool isParal(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// ?????¨???????????¢\ndouble distP(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\nint n;\nvector<Point> v;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tcin >> n;\n\tv.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> v[i].x >> v[i].y;\n\t}\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tSegment s(v[i], v[i+1]), t(v[(n/2+i)%n], v[(n/2+i+1)%n]);\n\t\t\n\t\t// ????????´????????¨????????§???????????????????????°????????°???????§°??§??????\n\t\tif (!isParal(s, t) || (s.p2 - s.p1).norm() != (t.p2 - t.p1).norm()) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// ????§°???????????????????±???????\n\tPoint ans((v[0].x + v[n/2].x)/2, (v[0].y + v[n/2].y)/2);\n\t\n\tcout << ans.x << \" \" << ans.y << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble compute_area(vector<Point>& points){\n  double area = 0;\n  for(int i = 0; i < points.size(); i++){\n    area += (points[i].real() - points[(i + 1) % points.size()].real())\n      * (points[i].imag() + points[(i + 1) % points.size()].imag());\n  }\n  return 1.0/2.0 * abs(area);\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nPoint reflection(const Line &l, const Point &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLS(const Line &l, const Line &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble distanceLL(const Line &l, const Line &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<Point> points;\n    double high,low,lhs,rhs;\n\n    high = rhs = numeric_limits<double>::min();\n    low = lhs = numeric_limits<double>::max();\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      points.push_back(Point(x,y));\n      low = min(low,y);\n      high = max(high,y);\n\n      lhs = min(lhs,x);\n      rhs= max(rhs,x);\n    }\n    vector<Line> lines;\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      lines.push_back(Line(points[pos_i],points[(pos_i+1) % N]));\n    }\n\n    double area_target;\n    //horizontal line\n    for(int round = 0; round < 50; round++){\n      double mid = low + (high - low) / 2.0;\n      Line horizontal_line(Point(-1000000.0,mid),Point(1000000.0,mid));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(horizontal_line,lines[line_i])){\n          Point p = crosspoint(horizontal_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n      vector<Point> top,bottom;\n      top.push_back(div[0]);\n      top.push_back(div[1]);\n      bottom.push_back(div[0]);\n      bottom.push_back(div[1]);\n\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS <= points[pos_i].imag()){\n          top.push_back(points[pos_i]);\n        }\n        if(mid + EPS >= points[pos_i].imag()){\n          bottom.push_back(points[pos_i]);\n        }\n      }\n      top = compute_convex_hull(top);      \n      bottom = compute_convex_hull(bottom);      \n      double area_top = compute_area(top);\n      double area_bottom = compute_area(bottom);\n      double whole = area_top + area_bottom;\n\n      if(area_top >= area_bottom){\n        low = mid;\n        area_target = area_top;\n      }\n      else{\n        high = mid;\n      }\n    }\n\n    //vertical line\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Line vertical_line(Point(mid,-10000000.0),Point(mid,10000000.0));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(vertical_line,lines[line_i])){\n          Point p = crosspoint(vertical_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n\n      vector<Point> left,right;\n      left.push_back(div[0]);\n      right.push_back(div[0]);\n      left.push_back(div[1]);\n      right.push_back(div[1]);\n\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS >= points[pos_i].real()){\n          left.push_back(points[pos_i]);\n        }\n        if(mid + EPS <= points[pos_i].real()){\n          right.push_back(points[pos_i]);\n        }\n      }\n\n      left = compute_convex_hull(left);\n      right = compute_convex_hull(right);\n      double area_left = compute_area(left);\n      double area_right = compute_area(right);\n      double whole = area_left + area_right;\n\n      if(area_right >= area_left){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n    \n    //check\n    Line check_line(Point(lhs,low),Point(lhs + 1.0,low + 1.0));\n    vector<Point> div;\n    int first = -1;\n    int last = -1;\n    for(int line_i = 0; line_i < lines.size(); line_i++){\n      if(intersectLS(check_line,lines[line_i])){\n        Point p = crosspoint(check_line,lines[line_i]);\n        div.push_back(p);\n        if(first == -1) first = line_i;\n        else if(last == -1) last = line_i;\n      }\n    }\n    \n    vector<Point> half;\n    half.push_back(div[0]);\n\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      if(first <= pos_i && pos_i <= last){\n        half.push_back(points[pos_i]);\n      }\n    }\n    half.push_back(div[1]);\n    double area_half = compute_area(half);\n    if(abs(area_half - area_target) > 0.01){\n      cout << \"NA\" << endl;\n    }\n    else{\n      printf(\"%.7lf %.7lf\\n\",lhs,low);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\ntypedef complex<double> po;\nvector<po>vec;\n\nint main(){\n    int N;\n    cin>>N;\n    if(N%2==1){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<N;i++){\n        double x,y;\n        cin>>x>>y;\n        vec.push_back(po(x,y));\n    }\n    int fini=1;\n    for(int i=0;i<N/2;i++){\n        double l1=abs(vec[i]-vec[(i+1)%N]);\n        double l2=abs(vec[N/2+i]-vec[(N/2+i+1)%N]);\n        double d1=abs(vec[i]-vec[(i+N/2)%N]);\n        double d2=abs(vec[i+1]-vec[(i+N/2+1)%N]);\n        if(abs(l1-l2)>=1e-5||abs(d1-d2)>=1e-5){\n            fini=0;\n            break;\n        }\n    }\n    if(fini==0)\n        cout<<\"NA\"<<endl;\n    else{\n        double x=0,y=0;\n        for(int i=0;i<N;i++){\n            x+=vec[i].real();\n            y+=vec[i].imag();\n        }\n        cout<<x/N<<\" \"<<y/N<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nint main(){\n    int N; cin>>N;\n    vec V[N];\n    for(auto& v:V) cin>>v.x>>v.y;\n    if(N%2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    vec M[N/2];\n    for(int i=0;i<N/2;i++){\n        M[i]=(V[i]+V[N/2+i])*0.5;\n    }\n    for(int i=1;i<N/2;i++){\n        if((M[0]-M[i]).norm()>1e-4){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout.precision(5);\n    cout << fixed;\n    cout << M[0].x << \" \" << M[0].y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 1000000000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                  友利奈緒ぱわーでACしてくれ！！！！！！！！！！！！\n                  Charlotteまだ見てない人は見ような！！！！！！！\n\n                  ／　 /:／　　　　　　　　　　　 　 ＼:ヽ　＼\n  　　　　　　　 /　　／　　　　　　 　 　 　 　 　 　 　 ＼　　ヽ\n  　　　　　＼__L 彡　　　　　　　　　　　　　　　　　　　 ヽ　　',\n  　　　　　　　ﾌ /　　　/　　/　 /　　　,　　 　 　 　 ヽ　　', 　ｊ\n  　　　　　　　ﾚ　　　 /　　/ 　/　 　 　 　 　 　 　 　 ', 　ヽ　j\n  　　　 　 　 // 　 　 !　/_l＿/__ノ 　　{ ＼}　　　　 　 ',　　',/\n  　　　　　　i ﾊ 　 　 {　从j　ﾊ　i　　　 ',　 ト-､}　 i i　 }　　jj\n  　　　　　　( ﾊ　　　(　 川　ハ ﾊ　 !　 '　ﾊ　 ﾊ　j j　,' 　 八\n  　　　 ＜＿,ｨ∧　　　斗芹ﾃミxハ ﾊ　 ﾚ　} /__ﾚﾚ　/ 　 ∧ ＼　ﾉ\n  　　　 　 　 ∨　＼ 　ゝ　辷:ソ　　 　)　芹ﾚ心ヾレ′　/ ト--　´\n  　　　＼ｰ‐'　ﾉ　　 ＼ゝ　　　　　　 　 　 ゞ:_ソ \"/ 　／ 　ヽ\n  　　　　 　 フ　　　　i八 \" \"　　　,　　　　　　　ム彡　　　　＼\n  　　　　 　/　　/　　j　 ト　　　　　　 　 　 \" \"イト＜　 　 　 ＼＼\n  　　　　 /　　/　　　j　/／ヽ､ 　 ∩　　 　 イ　{ {　　￣ フフへ ＼＼\n  　　　　(　／　　　 ,/ / 　　i　＞――＜ニニニﾆ┐　 〃／: : ヽ　ヽヽ\n  　　　　／　　ィT´/ /┌―　￣￣ /::: , ,)　 　 　 〃／／: : : : : :}　ヽヽ)\n  　　　/ /　 ∧ヾi┌― { {￣　　　 ﾉ:::トﾟ<　 　 　 ∥//: : : : : : : : i　 ﾉ ﾉ\n  . 　　( 人　 {:ヽヾi∨　∧V　　　 /:::/　､ヽ　　　 ∥/: : : : : : : : : :}　/\n  　　　V　( ∧: :＼'∨　∧V　　 ﾉ:::/　 ∧ 〉＿__∥: : : : : :／: : : :ﾚ\n  　　 　 　 /∧: : : : ∨　∧V┬ｲ:::ﾉ　 〈 TT　|　|{{: : : : ／: : : : : ∧　　 ﾉ\n  　　　 　 (　ハ: : : : :∨'T∧Vi　i (　 　 V　!　!　{{: : ／ : : : : : : /　ｰ　ノ\n  　　　　　V　ハ: : : : :∨ﾍ∧V　i ゝゝ　 i／⌒＼{／ : : : : : : : /ｰ― ´\n  　　　　　 ∨　ヽ: : : : :∨ﾍ∧∨i　〉 〉 /　/二　 ): : : : : : : : :/\n\n          (https://seesaawiki.jp/asciiart/d/Charlotte より)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n// #define int ll\n// #define DEBUG 42\ninline void nprint(){}\ntemplate <class Head, class... Tail>\ninline void nprint(Head &&head, Tail &&... tail) {\n    cout << head << endl;\n    nprint(move(tail)...);\n}\n#ifdef DEBUG\n  #define eprint(...) nprint(__VA_ARGS__)\n#else\n  #define eprint(...) if(0==1) cout << 1 << endl;\n#endif\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << endl\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << endl\n#define POSSIBLE(a) cout << (a ? \"POSSIBLE\" : \"IMPOSSIBLE\") << endl\nusing cmp = complex<double>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORS(i,a,b) FOR(i,a,b+1)\n#define REPS(i,n) REP(i,n+1)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPS(i,n) RREP(i,n+1)\n#define RFORS(i,a,b) RFOR(i,a,b+1)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define PERM(c) sort(ALL(c)); for(bool cp = true;cp;cp = next_permutation(ALL(c)))\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconstexpr ll MOD = 1E9+7;\nconstexpr int dx[] = {1,0,-1,0}; constexpr int dy[] = {0,1,0,-1};\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p){\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\n\ndouble add(double l, double r){\n\tif(abs(l+r)<EPS*(abs(l)+abs(r))) return 0;\n\treturn l+r;\n}\nstruct pt{\n\tdouble x, y;\n\tpt(double xx=0, double yy=0){x=xx; y=yy;}\n\t// pt(pt z):x(z.x),y(z.y){}\n\tpt& operator+=(const pt &rhs){\n\t\tx = add(x,rhs.x); y = add(y,rhs.y); return *this;\n\t}\n\tpt& operator-=(const pt &rhs){\n\t\tx = add(x,-rhs.x); y = add(y,-rhs.y); return *this;\n\t}\n\tpt& operator*=(const double &rhs){\n\t\tx *= rhs; y *= rhs; return *this;\n\t}\n\tpt& operator/=(const double &rhs){\n\t\tx /= rhs; y /= rhs; return *this;\n\t}\n\tpt operator+(const pt &that) const { return pt(*this) += that; }\n  pt operator-(const pt &that) const { return pt(*this) -= that; }\n  pt operator*(const double &that) const { return pt(*this) *= that; }\n  pt operator/(const double &that) const { return pt(*this) /= that; }\n\tpt operator+(){return *this;}\n\tpt operator-(){y=-y; return *this;}\n\n\n\tbool operator==(const pt &rhs){\n\t\treturn add(x,-rhs.x)==0 && add(y,-rhs.y)==0;\n\t}\n\tbool operator!=(const pt &rhs){return !(*this==rhs);}\n\tbool operator<(const pt &rhs){\n\t\treturn add(x,-rhs.x)!=0 ? x<rhs.x : add(y,-rhs.y)<0;\n\t}\n\tbool operator>(const pt &rhs){return add(x,-rhs.x)!=0 ? x>rhs.x : add(y,-rhs.y)>0;}\n\tbool operator<=(const pt &rhs){return !(*this>rhs);}\n\tbool operator>=(const pt &rhs){return !(*this<rhs);}\n\tfriend istream& operator>>(istream& is, pt& z)noexcept{\n\t\treturn is >> z.x >> z.y;\n\t}\n\tfriend ostream& operator<<(ostream &os, pt &p) { return os << p.x << \" \" << p.y; }\n\tdouble norm(){return add(x*x,y*y);}\n\tdouble abs(){return sqrt(this->norm());}\n};\ndouble dot(pt a, pt b){return add(a.x*b.x,a.y*b.y);}\ndouble cross(pt a, pt b){return add(a.x*b.y,-a.y*b.x);}\n\nstruct line{\n\tpt a, b;\n\tline(pt a=pt(0,0), pt b=pt(0,0)):a(a),b(b){}\n};\npt crosspoint(const line &l, const line &m){\n\tdouble A = cross(l.b - l.a, m.b - m.a);\n\tdouble B = cross(l.b - l.a, l.b - m.a);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n\treturn m.a + (m.b - m.a) * B / A;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\tint n;\n\tcin >> n;\n\tV<pt> ps(n);\n\tcin >> ps;\n\tif(n&1){\n\t\tnprint(\"NA\");\n\t\treturn 0;\n\t}\n\tpt ans = (ps[0]+ps[n/2])/2;\n\tbool ok = true;\n\tREP(i,n/2){\n\t\tok &= (ps[i]-ans + ps[i+(n/2)]-ans)==pt(0,0);\n\t}\n\tif(!ok) nprint(\"NA\");\n\telse cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst double eps = 1e-6;\nconst long double pi = 3.14159265358979323846264338327950288419716939937510L;\n\nusing Point = complex<double>;\n\nstruct DualPoints : public pair<Point, Point> {\n    using pair<Point, Point>::pair;\n\n    Point& operator [](size_t idx) { return idx == 0 ? first : second; }\n    \n    const Point& operator [](size_t idx) const { return idx == 0 ? first : second; }\n};\n\nstruct get_xy {\n    double &x, &y;\n\n    get_xy(double &x, double &y) : x(x), y(y) { }\n\n    get_xy& operator =(const Point &p) {\n        x = real(p);\n        y = imag(p);\n        return *this;\n    }\n};\n\nstruct Line : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\nstruct Seg : public DualPoints {\n    using DualPoints::DualPoints;\n};\n\ndouble dot(const Point &a, const Point &b) {\n    return (conj(a) * b).real();\n}\n\ndouble cross(const Point &a, const Point &b) {\n    return (conj(a) * b).imag();\n}\n\nenum ccwd {\n    Clock = -1,\n    CoClock = 1,\n    CAB = 2,\n    ABC = -2,\n    ACB = 0,\n};\n\nccwd ccw(Point a, Point b, Point c) {\n    b -= a;\n    c -= a;\n    double p, q;\n    {\n        auto tmp = conj(b) * c;\n        p = tmp.real();\n        q = tmp.imag();\n    }\n    if (0 < q) return CoClock;\n    if (q < 0) return Clock;\n    if (p < 0) return CAB;\n    if (norm(b) < norm(c)) return ABC;\n    return ACB;\n}\n\nbool is_zero(double a) {\n    return abs(a) <= eps;\n}\n\nbool is_parallel(const Line &l1, const Line &l2) {\n    return is_zero(cross(l1[1] - l1[0], l2[1] - l2[0]));\n}\n\nbool is_same_line(Point o, Point a, Point b) {\n    return is_zero(cross(a - o, b - o));\n}\n\nbool intersect(const Line &p, const Line &q) {\n    if (!is_parallel(p, q)) return true;\n    return is_same_line(p[0], p[1], q[1]);\n}\n\nbool intersect(const Line &l, const Seg &s) {\n    double a = cross(l[1] - l[0], s[0] - l[0]);\n    double b = cross(l[1] - l[0], s[1] - l[0]);\n    return a * b < 0;\n}\n\nbool intersect(const Seg &p, const Seg &q) {\n    bool pf = (ccw(p[0], p[1], q[0]) * ccw(p[0], p[1], q[1])) <= 0;\n    bool qf = (ccw(q[0], q[1], p[0]) * ccw(q[0], q[1], p[1])) <= 0;\n    return pf && qf;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return is_same_line(p, l[0], l[1]);\n}\n\nbool intersect(const Seg &s, const Point &p) {\n    double l1 = abs(s[0] - s[1]);\n    double l2 = abs(s[0] - p);\n    double l3 = abs(s[1] - p);\n    return is_zero(l2 + l3 - l1);\n}\n\n// projection from p to l\nPoint proj(const Line &l, const Point &p) {\n    double mul = dot(p - l[0], l[1] - l[0]) / norm(l[0] - l[1]);  // cos(theta) / (p-l[0]).norm()\n    return l[0] + mul * (l[1] - l[0]);\n}\n\nPoint refl(const Line &l, const Point &p) {\n    Point pr = proj(l, p);\n    return p + (2. * (pr - p));\n}\n\ndouble distance(const Line &l, const Point &p) {\n    return abs(p - proj(l, p));\n}\n\ndouble distance(const Line &p, const Line &q) {\n    if (is_parallel(p, q)) return distance(p, q[0]);\n    return 0;\n}\n\ndouble distance(const Line &l, const Seg &s) {\n    if (intersect(l, s)) return 0;\n    return min(distance(l, s[0]), distance(l, s[1]));\n}\n\ndouble distance(const Seg &s, const Point &p) {\n    Line l(s[0], s[1]);\n    Point pr = proj(l, p);\n    if (intersect(s, pr)) return abs(pr - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distance(const Seg &p, const Seg &q) {\n    if (intersect(p, q)) return 0;\n    return var_min(distance(p, q[0]), distance(p, q[1]),\n                   distance(q, p[0]), distance(q, p[1]));\n}\n\ndouble fix_arg(double arg) {\n    arg += 2 * pi;\n    if (2 * pi <= arg) arg -= 2 * pi;\n    return arg;\n}\n\nbool comp_coclock(const Point &p1, const Point &p2) {\n    return fix_arg(arg(p1)) < fix_arg(arg(p2));\n}\n\nPoint rotate(const Point &p, double arg) {\n    complex<double> r(cos(arg), sin(arg));\n    return p * r;\n}\n\nPoint ans;\n\nbool solve() {\n    ll N;\n    cin >> N;\n\n    if (N & 1) return false;\n\n    V<Point> points(N);\n    for (auto &&e : points) {\n        double x, y;\n        cin >> x >> y;\n        e = Point(x, y);\n    }\n    \n    {\n        Point p = points[0], q = points[(N + 1) / 2];\n        double px, py, qx, qy;\n        get_xy(px, py) = p;\n        get_xy(qx, qy) = q;\n        ans = Point((px + qx) / 2., (py + qy) / 2.);\n    }\n\n    for (auto &&e : points) e -= ans;\n\n    for (ll i = 0; i < N / 2; i++) {\n        Point p = points[i];\n        Point q = points[i + (N + 1) / 2];\n        Point r = rotate(p, pi);\n        double qx, qy, rx, ry;\n        get_xy(qx, qy) = q;\n        get_xy(rx, ry) = r;\n        if (is_zero(qx - rx) && is_zero(qy - ry)) continue;\n        return false;\n    }\n    return true;\n}\n\nint main() {\n    if (!solve()) cout << \"NA\" << endl;\n    else cout << ans.real() << ' ' << ans.imag() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n;\n\tcin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°?????¨??????????§°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\tvector<double> len(n);\n\trep(i, n - 1){\n\t\tdouble tmp = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tlen.push_back(tmp);\n\t}\n\tdouble tmp = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tlen.push_back(tmp);\n\tsort(all(len));\n\tif(len[n - 1] - len[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//????±???¨???????????????????±???????\n\tvector<double> Px(n / 2);\n\tvector<double> Py(n / 2);\n\trep(i, n / 2){\n\t\tdouble x = (point[i].fi + point[i + n / 2].fi) / 2.0;\n\t\tPx.push_back(x);\n\t\tdouble y = (point[i].se + point[i + n / 2].se) / 2.0;\n\t\tPy.push_back(y);\n\t\t//printf(\"%f %f %f\\n\", x, y, Py[i]);\n\t}\n\n\tsort(all(Px));\n\tif(Px[n / 2 - 1] - Px[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(Py));\n\tif(Py[n / 2 - 1] - Py[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t/*\n\trep(i, n / 2){\n\t\tprintf(\"%f %f\\n\", Px[i], Py[i]);\n\t}\n\t*/\n\n\tprintf(\"%.9f %.9f\\n\", Px[0], Py[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-4;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x[50], y[50];\n\nsigned main() {\n\tcin >> n;\n\tif (n%2) return cout << \"NA\" << ln, 0;\n\trep(i,n) cin >> x[i] >> y[i];\n\tdouble xx = 1.*(x[0] + x[n/2])/2, yy = 1.*(y[0] + y[n/2])/2;\n\tbool ok = true;\n\trep(i,n/2) if (fabs(x[i]+x[(i+n/2)%n]-xx*2)>=eps || fabs(y[i]+y[(i+n/2)%n]-yy*2)>=eps) ok = false;\n\tif (ok) printf(\"%.10lf %.10lf\\n\",xx,yy);\n\telse cout << \"NA\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nbool eq(const ld a, const ld b) {\n  return (abs(a - b) < eps);\n}\n\nld dot(const Point& a, const Point& b) {\n  return real(conj(a) * b);\n}\n\nld cross(const Point& a, const Point& b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n  Point operator[](const int _num)const {\n    if (_num == 0)return a;\n    else if (_num == 1)return b;\n    else {\n      assert(false);\n      return Point();\n    }\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n  const Point nb(b - a);\n  const Point nc(c - a);\n  if (cross(nb, nc) > eps) return 1;   // a,b,c\n  if (cross(nb, nc) < -eps) return -1; // a,\n  if (dot(nb, nc) < 0) return 2;       //\n  if (norm(nb) < norm(nc)) return -2;  // \n  return 0;                          \n}\n\n\nbool isis_ll(const Line& l, const Line& m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(const Line& l, const Line& s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(const Line& s, const Line& t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(const Line& l, const Point& p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(const Line& s, const Point& p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(const Line &l, const Point& p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nvector<Point> is_ll2(const Line &s, const Line& t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  if (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n  else {\n    vector<Point>ans;\n    for (int k = 0; k < 2; ++k) {\n      if (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n      if (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n    }\n    return ans;\n  }\n}\nPoint is_ss(const Line &s, const Line& t) {\n  if (isis_ss(s, t)) {\n    for (int k = 0; k < 2; ++k) {\n      for (int l = 0; l < 2; ++l) {\n        if (s[k] == t[l])return s[k];\n      }\n    }\n    return is_ll(s, t);\n  }\n  else {\n    assert(false);\n    return Point(0, 0);\n  }\n}\nld dist_lp(const Line& l, const Point& p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll(const Line& l, const Line& m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(const Line& l, const Line& s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(const Line& s, const Point& p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(const Line& s, const Line& t) {\n  if (isis_ss(s, t)) return 0;\n  return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nLine bisection(const Line &s, const Line &t) {\n  const Point laglanju(is_ll(s, t));\n  const Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n  const Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n  return Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\nPoint  inner_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n  Line bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n  Line bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n  if (bi1[0] == bi2[0])return bi1[0];\n  else {\n    return is_ll(bi1, bi2);\n  }\n}\n\nvector<Point>  ex_center(const vector<Line>&ls) {\n  vector<Point>vertics;\n  for (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n    vertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n  }\n  if (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n  vector<Point>ecs;\n  for (int i = 0; i < 3; ++i) {\n    Line bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n    Line bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n    ecs.push_back(is_ll(bi1, bi2));\n  }\n  return ecs;\n}\n\n\nvector<Point>  same_dis(const vector<Line>&ls) {\n  vector<Point>vertics;\n  vertics.push_back(is_ll(ls[0], ls[2]));\n  vertics.push_back(is_ll(ls[1], ls[2]));\n\n  if (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n  Line bis(bisection(ls[0], ls[1]));\n  vector<Point>ecs;\n\n  Line abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, abi));\n\n\n  Line bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n  ecs.push_back(is_ll(bis, bbi));\n\n  return ecs;\n}\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res; // no intersection\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nint is_in_circle(const Circle &cir, const  Point& p) {\n  ld dis = abs(cir.p - p);\n  if (dis > cir.r + eps)return 0;\n  else if (dis < cir.r - eps)return 2;\n  else return 1;\n}\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n  ld dis = abs(lc.p - rc.p);\n  if (dis < rc.r - lc.r - eps)return 2;\n  else if (dis>rc.r - lc.r + eps)return 0;\n  else return 1;\n}\n\nvector<Point> is_lc(const Circle& c, const Line& l) {\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps) {\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\nvector<Point> is_sc(const Circle& c, const Line& l) {\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d, c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0, 1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\nld two_circle_area(const Circle&l, const Circle&r) {\n  ld dis = abs(l.p - r.p);\n  if (dis > l.r + r.r)return 0;\n  else if (dis + r.r < l.r) {\n    return r.r*r.r*pi;\n  }\n  else if (dis + l.r < r.r) {\n    return l.r*l.r*pi;\n  }\n  else {\n    ld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n      (r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n      sqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n    return ans;\n  }\n\n}\n\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j, n) res += cross(p[j], p[(j + 1) % n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i, n) {\n    Point a = poly[i], b = poly[(i + 1) % n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n  const int n = P.size();\n  Point g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n  int a = 0, b = n;\n  while (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n      if (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n      else                                                  a = c;\n    }\n    else {\n      if (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\n\n\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n  int n = ps.size();\n  Polygon Q;\n  Polygon R;\n  REP(i, n) {\n    Point A = ps[i], B = ps[(i + 1) % n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) != 1) R.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n      Q.push_back(is_ll(l, m));\n      R.push_back(is_ll(l, m));\n    }\n  }\n  const vector<Polygon>polys{ Q,R };\n  return polys;\n}\n\n\nvoid add_point(vector<Point> &ps, const Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n  g[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i, m) {\n    vector<pair<ld, int>> vec;\n    REP(j, n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j, vec.size() - 1) {\n      int from = vec[j].second, to = vec[j + 1].second;\n      add_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n    }\n  }\n  return g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n  vector<Point>crss;\n  for (int i = 0; i < static_cast<int>(s.size()); ++i) {\n    for (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n      if (isis_ss(s[i], s[j])) {\n        crss.push_back(is_ll(s[i], s[j]));\n      }\n    }\n  }\n  for (int i = 0; i <static_cast<int>(s.size()); ++i) {\n    crss.push_back(s[i][0]);\n    crss.push_back(s[i][1]);\n  }\n  return segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n\n\nint main() {\n  \n  int N; cin >> N;\n  vector<Point>ps;\n  for (int i = 0; i < N; ++i) {\n    int x, y; cin >> x >> y;\n    Point p(x, y);\n    ps.push_back(p);\n  }\n\n  Point center = (ps[0] + ps[1]) / 2.l;\n  bool ok = true;\n  if (N % 2) {\n    ok = false;\n  }\n  else {\n    center = (ps[0] + ps[N/2]) / 2.l;\n    \n    for (int i = 0; i < N / 2; ++i) {\n      Point kouho = (ps[ i] + ps[(i + N/2)%N]) / 2.l;\n      if (abs(center - kouho) > eps)ok = false;\n    }\n  }\n  if (ok)cout << setprecision(22) << fixed << center.real() << \" \" << center.imag() << endl;\n  else cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nint N;\nint x[50],y[50];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  set<pair<int,int> >s;\n  for(int i=0;i+N/2<N;i++){\n    s.insert(make_pair(x[i]+x[i+N/2],y[i]+y[i+N/2]));\n  }\n  if(N%2==1||s.size()>1){\n    cout<<\"NA\"<<endl;\n  }else{\n    auto p=*begin(s);\n    cout<<fixed<<p.first/2.<<' '<<p.second/2.<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-4;\nconst double INF = 1000000001.0;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\n\nP crossPoint(L l, L m){\n   double A = cross(l.second - l.first, m.second - m.first);\n   double B = cross(l.second - l.first, l.second - m.first);\n   if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n   else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n   double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\n\nbool equal(double a, double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, double theta){\n   theta = theta * M_PI / 180.0;\n   double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      double l = miny;\n      double r = maxy;\n      double all = area(v);\n      L yoko, tate;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(-INF,mid),P(INF,mid))));\n\t if(equal(half*2.0, all) || equal(l,r)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   yoko = L(P(-INF,mid),P(INF,mid));\n\t   break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(mid,INF),P(mid,-INF))));\n\t if(equal(half*2.0, all) || equal(l,r)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   tate = L(P(mid,-INF),P(mid,INF));\n\t   break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n      //printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n\n      for(int i=0;i<v.size();i++){\n\t//L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\tL line = L(v[i], (ans + (ans-v[i])*INF));\n\tdouble half = area(convex_cut(v,line));\n\tif(!equal(half*2.0,all)){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Q;\n\nint n;\nint x[50];\nint y[50];\nQ sx[25];\nQ sy[25];\n\nll gcd(ll a, ll b){\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nvoid make_q(ll p, ll q, Q& x){\n    if(q < 0){\n        p = -p;\n        q = -q;\n    }\n    ll g = gcd(abs(p), q);\n    x.first = p / g;\n    x.second = q / g;\n}\n\ndouble eval_q(Q x){\n    return double(x.first) / x.second;\n}\n\nvoid line_eq(int i, int j, ll& p, ll& q, ll& r){\n    ll a = x[i];\n    ll b = y[i];\n    ll c = x[j];\n    ll d = y[j];\n    p = b - d;\n    q = c - a;\n    r = a * d - b * c;\n}\n\nvoid intersect(ll p0, ll q0, ll r0, ll p1, ll q1, ll r1, Q& x, Q& y){\n    ll a = q0 * r1 - q1 * r0;\n    ll b = p1 * r0 - p0 * r1;\n    ll c = p0 * q1 - p1 * q0;\n    make_q(a, c, x);\n    make_q(b, c, y);\n}\n\nbool is_parallel(int i, int j, int k, int l){\n    ll a = x[i] - x[j];\n    ll b = y[i] - y[j];\n    ll c = x[k] - x[l];\n    ll d = y[k] - y[l];\n    return a * d - b * c == 0;\n}\n\nbool solve(double& x, double& y){\n    if(n % 2){\n        return false;\n    }\n\n    int m = n / 2;\n    \n    rep(i, m){\n        if(!is_parallel(i, i + 1, m + i, (m + i + 1) % n)){\n            return false;\n        }\n    }\n\n    rep(i, m){\n        ll p0, q0, r0, p1, q1, r1;\n        line_eq(i, m + i, p0, q0, r0);\n        line_eq(i + 1, (m + i + 1) % n, p1, q1, r1);\n        intersect(p0, q0, r0, p1, q1, r1, sx[i], sy[i]);\n    }\n    rep(i, m - 1){\n        if(sx[i] != sx[m - 1] || sy[i] != sy[m - 1]){\n            return false;\n        }\n    }\n    x = eval_q(sx[0]);\n    y = eval_q(sy[0]);\n    return true;\n}\n\nint main(){\n    cin >> n;\n    rep(i, n){\n        cin >> x[i] >> y[i];\n    }\n\n    double x, y;\n    if(solve(x, y)){\n        cout << fixed << setprecision(8) << x << ' ' << fixed << setprecision(8) << y << endl;\n    }\n    else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\nlong double distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\nlong double distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\nlong double distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\nlong double distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.second), distanceSP(t, s.second)));\n}\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\npoint intersection_l(const point& a1,const point& a2,const point& b1,const point& b2) {\n  const point& a=a2-a1,b=b2-b1;\n  return a1+a*cross(b, b1-a1)/cross(b, a);\n}\npoint intersection_l(const line& l,const line& m){\n    return intersection_l(l.first,l.second,m.first,m.second);\n}\n// ????§???¢????¬?????????¢???\nlong double area(const vector<point>& pol){\n    long double s=0;\n    rep(i,0,pol.size()) s+=cross(pol[i],pol[(i+1)%pol.size()]);\n    return s/2;\n}\n\nvector<point> convex_cut(const vector<point>& ps, const line& l) {\n    vector<point> res;\n    for (int i = 0; i < ps.size(); ++i) {\n        point a = ps[i], b = ps[(i+1)%ps.size()];\n        if (ccw(l.first, l.second, a) != -1) res.push_back(a);\n        if (ccw(l.first, l.second, a)*ccw(l.first, l.second, b) < 0) res.push_back(intersection_l(line(a, b), l));\n    }\n    return res;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<point> ps(n);\n    for(point& p:ps){\n        long double x,y;\n        cin >> x >> y;\n        p=point(x,y);\n    }\n\n    const long double s=area(ps);\n    auto opt=[&](){\n        long double left=inf,right=-inf;\n        for(const auto& p:ps){\n            if(p.real()<left) left=p.real();\n            if(p.real()>right) right=p.real();\n        }\n        line l(point(left,0),point(left,1));\n        long double lb=0,ub=distanceLP(l,point(right,0));\n        rep(i,0,200){\n            long double mid=(lb+ub)/2;\n            l=line(point(left+mid,0),point(left+mid,1));\n            if(area(convex_cut(ps,l))<=s/2) lb=mid;\n            else ub=mid;\n        }\n        return l;\n    };\n\n    line l1=opt();\n    for(auto& p:ps) p*=point(0,1);\n    line l2=opt();\n    l2=line(l2.first*point(0,-1),l2.second*point(0,-1));\n    for(auto& p:ps) p*=point(0,-1);\n    point ans=intersection_l(l1,l2);\n    bool ok=true;\n    const long double pi=3.14159265;\n    rep(i,0,10000){\n        const point tmp=ans+point(1,0)*point(cos(2*pi*i/10000),sin(2*pi*i/10000));\n        if(abs(area(convex_cut(ps,line(ans,tmp)))-s/2)>eps){\n            ok=false;\n            break;\n        }\n    }\n    if(ok) cout << ans.real() << \" \" << ans.imag() << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8) << endl;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto & it:v)\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\n#define IL inline\n#define X real()\n#define Y imag()\nIL D dot(P a,P b){\n    return a.X*b.X+a.Y*b.Y;\n}\nIL D cross(P a,P b){\n    return a.X*b.Y-a.Y*b.X;\n}\n\n\nIL D ccw(P a,P b,P c){\n    return cross(b-a,c-a);\n}\n\n\nIL D convex_area(Poly pp){\n    D res=0;\n    for(int i=2,n=pp.size();i<n;i++)\n\tres+=abs(ccw(pp[0],pp[i-1],pp[i]))/2,0;\n    return res;\n}\n\nstruct INIT{\n    INIT(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout<<fixed;\n\tcout<<setprecision(10);\n    }\n}init;\n\nIL P convex_gravity_point(Poly& pp){\n    P g(0,0);\n    D s=0;\n    for(int i=2,n=pp.size();i<n;i++){\n\tD t=convex_area({pp[0],pp[i-1],pp[i]});\n\tg+=t*(pp[0]+pp[i-1]+pp[i])/3.0;\n\ts+=t;\n    }\n    return g/s;\n}\nint main(){\n    int N;\n    cin>>N;\n    Poly p(N);\n    rep(i,N){\n\tD x,y;\n\tcin>>x>>y;\n\tp[i]=P(x,y);\n    }\n    auto g=convex_gravity_point(p);\n    if(N&1)cout<<\"NA\"<<endl;\n    else{\n\tint M=N/2;\n\trep(i,N){\n\t    if(abs(abs(g-p[i])-abs(g-p[i+M]))>1e8){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t    }\n\t}\n\tcout<<g.X<<\" \"<<g.Y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[50], y[50], t[50];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = x[0]*x[0]+y[0]*y[0];\n\t\telse{\n\t\t\tdouble d = x[i]*x[i]+y[i]*y[i];\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n-1) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\tif(i == 0){ \n\t\t\n\t\t} else{\n\t\t\ta = t[i]-t[i-1];\n\t\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double INF = 1e+9;\nconst double EPS = 1e-6;\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\nbool equal(P a, P b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n\nint n;\nvector<P> v;\n\ndouble binary_search(bool is_h){\n  L l;\n  double le = -INF, ri = INF, mid;\n  vector<P> cut_v;\n\n  while(ri - le > EPS/100.0){\n    mid = (ri + le) / 2.0;\n    if(is_h) l = L(P(-INF, mid), P(INF, mid));\n    else l = L(P(mid, INF), P(mid, -INF));\n    cut_v = convex_cut(v, l);\n    if(area(v) > area(cut_v) * 2.0) ri = mid;\n    else le = mid;\n  }\n\n  return (ri + le) / 2.0;\n}\n\nP solve(){\n  P res = P(binary_search(false), binary_search(true));\n  bool f = true;\n\n  /*\n  if(equal(area(v), area(convex_cut(v, L(res, res+P(1.0, 1.0)))) * 2.0) &&\n     equal(area(v), area(convex_cut(v, L(res, res+P(1.0, -1.0)))) * 2.0)) return res;\n  else return P(INF, INF);\n  */\n\n  //if(n % 2) f = false;\n  //else {\n    for(int i=0;i<n/2;i++){\n      if(!equal(v[i] - res, res - v[i+n/2])){\n        f = false;\n        break;\n      }\n    }\n    //}\n\n  if(f) return res;\n  else return P(INF, INF);\n}\n\nint main(){\n  double x, y;\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      v.push_back(P(x, y));\n    }\n    P res = solve();\n    if(equal(res, P(INF, INF))) cout << \"NA\" << endl;\n    else printf(\"%.5f %.5f\\n\",res.real(),res.imag());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nvoid solve(const vector<Point> &vp) {\n    int N = (int)vp.size();\n    if (N & 1) { cout << \"NA\" << endl; return; }\n    auto res = (vp[0] + vp[N/2]) / 2;\n    for (int i = 0; i < N/2; ++i) {\n        if (abs(abs(res - vp[i]) - abs(res - vp[i+N/2])) > EPS) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    cout << fixed << setprecision(10) << res.x << \" \" << res.y << endl;\n    return;\n}\n\nint main() {\n    int N; cin >> N;\n    vector<Point> vp(N);\n    for (int i = 0; i < N; ++i) cin >> vp[i].x >> vp[i].y;\n    solve(vp);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nVector Cross_Point(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tVector base = p4 - p3;\n\n\tVector v1 = p1 - p3;\n\tVector v2 = p2 - p3;\n\n\tlong double d1 = fabsl(cross(base, v1));\n\tlong double d2 = fabsl(cross(base, v2));\n\n\tlong double t = d1 / (d1 + d2);\n\n\treturn p1 + ((p2 - p1) * t);\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X, Y;\n\n\tvector<Vector> Plane;\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X >> Y;\n\n\t\tPlane.push_back(Vector(X, Y));\n\t}\n\n\tif (N % 2 == 1)\n\t{\n\t\tcout << \"NA\" << endl;\n\t}\n\telse\n\t{\n\t\tVector C;\n\n\t\tfor (int i = 0; i < N / 2; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N / 2; j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint l1 = i;\n\t\t\t\t\tint r1 = i + N / 2;\n\t\t\t\t\tint l2 = j;\n\t\t\t\t\tint r2 = j + N / 2;\n\n\t\t\t\t\tC = Cross_Point(Plane[l1], Plane[r1], Plane[l2], Plane[r2]);\n\n\t\t\t\t\tif ((Plane[l1] + Plane[r1]) / 2 != C)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"NA\" << endl;\n\n\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9f %.9f\\n\", C.x, C.y);\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-7)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  if(n%2)flag=0;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nint main() {\n\tint N; cin >> N;\n\tif (N % 2 == 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> X[i] >> Y[i];\n\tset<i_i> s;\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tint x = X[i] + X[N / 2 + i];\n\t\tint y = Y[i] + Y[N / 2 + i];\n\t\ts.insert(i_i(x, y));\n\t}\n\tif (s.size() > 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\ti_i p = *(s.begin());\n\tprintf(\"%.10f %.10f\\n\", p.first / 2.0, p.second / 2.0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nint main(){\n    int N; cin>>N;\n    vec V[N];\n    for(auto& v:V) cin>>v.x>>v.y;\n    if(N%2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    vec M[N/2];\n    for(int i=0;i<N/2;i++){\n        M[i]=(V[i]+V[N/2+i])*0.5;\n    }\n    for(int i=1;i<N/2;i++){\n        if((M[0]-M[i]).norm()>5e-5){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << M[0].x << \" \" << M[0].y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,x[55],y[55];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tif(n%2){\n\t\tcout<<\"NO\"<<endl;\n\t\treturn 0;\n\t}\n\trep(i,n)cin>>x[i]>>y[i],x[i]*=2,y[i]*=2;\n\tint cx=x[0]+x[n/2],cy=y[0]+y[n/2];\n\trep(i,n/2)if(x[i]+x[i+n/2]!=cx || y[i]+y[i+n/2]!=cy){\n\t\tcout<<\"NO\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<cx/4.<<\" \"<<cy/4.<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nint N;\nPol pol;\nD s;\nL edges[50];\nD eps=1e-50;\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nD aPol(Pol p){\n\tD ret=0;\n\tint n=p.size();\n\trep(i,n) ret+=cro(p[i],p[(i+1)%n])/2;\n\treturn ret;\n}\nP gpol(Pol p){\n\tP g;\n\ts=aPol(p);\n\tint n=p.size();\n\trep(i,n){\n\t\tD ds=cro(p[i],p[(i+1)%n])/2;\n\t\tg+=ds/3*(p[i]+p[(i+1)%n]);\n\t}\n\treturn g/s;\n}\nbool iLS(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nD pi=acos(-1.0);\nvector<D> args,thetas;\nint main(){\n\tcin>>N;\n\trep(i,N){\n\t\tD x,y;\n\t\tcin>>x>>y;\n\t\tpol.pb(P(x,y));\n\t}\n\trep(i,N){\n\t\tedges[i]=L(pol[i],pol[(i+1)%N]);\n\t}\n\tP g=gpol(pol);\n\trep(i,N){\n\t\targs.pb(arg(pol[i]-g));\n\t}\n\trep(i,N) rep(j,i+1){\n\t\tthetas.pb((args[i]+args[j])/2+1e-9);\n\t\tthetas.pb((args[i]+args[j])/2-1e-9);\n\t}\n\tfor(D theta:thetas){\n\t\tL l=L(g,g+polar(1.0,theta));\n\t\tPol npol;\n\t\trep(i,N){\n\t\t\tif(iLS(l,edges[i])){\n\t\t\t\tnpol.pb(intLL(edges[i],l));\n\t\t\t\tnpol.pb(pol[(i+1)%N]);\n\t\t\t\tfor(int j=i+1;;j++){\n\t\t\t\t\tif(j==N) j=0;\n\t\t\t\t\tif(iLS(l,edges[j])){\n\t\t\t\t\t\tnpol.pb(intLL(edges[j],l));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnpol.pb(pol[(j+1)%N]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(abs(s/aPol(npol)-2)>1e-9){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.12f %.12f\\n\",g.real(),g.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-6)<b&&b<a+(1e-6);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else cout<<a.f<<\" \"<<a.s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\tif (N & 1) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tint posX = X[0] + X[N / 2], posY = Y[0] + Y[N / 2];\n\tbool ng = false;\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tint px = X[i] + X[i + N / 2], py = Y[i] + Y[i + N / 2];\n\t\tif (px != posX || py != posY) {\n\t\t\tng = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ng) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tcout << fixed << setprecision(8) << posX / 2.0 << ' ' << posY / 2.0 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) if((x)>(y))(x)=(y)\n#define chmax(x,y) if((x)<(y))(x)=(y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nint n, x[50], y[50];\n\nsigned main() {\n\tcin >> n;\n\tif (n%2) return cout << \"NA\" << ln, 0;\n\trep(i,n) cin >> x[i] >> y[i];\n\tdouble xx = 1.*(x[0] + x[n/2])/2, yy = 1.*(y[0] + y[n/2])/2;\n\tbool ok = true;\n\trep(i,n) if (fabs((x[i]+x[(i+n/2)%n])/2-xx)>=eps || fabs((y[i]+y[(i+n/2)%n])/2-yy)>=eps) ok = false;\n\tif (ok) printf(\"%.10lf %.10lf\\n\",xx,yy);\n\telse cout << \"NA\" << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nstruct Point{double x,y;};\n\nint main(void){\n    int N;\n    cin>>N;\n\n    vector<Point> p(N);\n    rep(i,N){\n        cin>>p[i].x>>p[i].y;\n    }\n    if(N%2==1){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n\n    Point G={(p[0].x+p[N/2].x)/2.0 , (p[0].y+p[N/2].y)/2.0};\n    bool NA=false;\n    rep1(i,N/2-1){\n        Point tmp = {(p[i].x+p[i+N/2].x)/2.0 , (p[i].y+p[i+N/2].y)/2.0};\n        if(tmp.x!=G.x || tmp.y!=G.y){\n            NA = true;\n        }\n    }\n    if(NA){\n        cout<<\"NA\"<<endl;\n    }else{\n        printf(\"%.5f %.5f\\n\",G.x,G.y);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-11;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) > total_area/2-EPS){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    assert(\"nyan\");\n}\n\n\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        xor128();\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5+1,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-7;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint main(){\n    int n;\n    cin>>n;\n    Point a[n+1];\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        a[i]={x,y};\n    }\n    if(n%2){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    a[n]=a[0];\n    rep(i,n/2){\n        if(abs(cross((a[i+1]-a[i]),a[i+n/2]-a[i+1+n/2]))>eps){\n            cout<<\"NA\"<<endl;\n            return 0;\n        }\n    }\n    Point ans=(a[0]+a[n/2])*.5;\n    cout<<setprecision(10)<<ans.real()<<\" \"<<ans.imag()<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-6;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) > total_area/2-EPS){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    assert(\"nyan\");\n}\n\n\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        xor128();\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5+1,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nint main()\n{\n  int N; cin >> N;\n  vector<Point> p(N);\n  for(int i = 0; i < N; i++) cin >> p[i].x >> p[i].y;\n\n  if(p.size() % 1) {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n\n  bool flag = true;\n  for(int i = 0; i < N/2; i++) {\n    Vector v1(p[i] - p[i+1]), v2(p[N/2+i] - p[(N/2+i+1)%N]);\n    if(!isParallel(v1, v2) || v1.norm() != v2.norm()) flag = false;\n  }\n\n  if(flag) printf(\"%.10f %.10f\\n\", (p[0].x + p[N/2].x) / 2, (p[0].y + p[N/2].y) / 2);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n?????????????????¨?????????????????¨????????????\n????±???¨?????????????????????????????¨????????????????????¨???????????´??????????????°???????????¶???????????°??¢\n*/\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n;\n\tcin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°?????¨??????????§°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\tvector<double> len(n);\n\trep(i, n - 1){\n\t\tdouble tmp = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tlen.push_back(tmp);\n\t}\n\tdouble tmp = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tlen.push_back(tmp);\n\tsort(all(len));\n\tif(len[n - 1] - len[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//????±???¨????????????????????????????±???????\n\tvector<double> Px;\n\tvector<double> Py;\n\trep(i, n / 2){\n\t\tdouble x = (point[i].fi + point[i + n / 2].fi) / 2.0;\n\t\tPx.push_back(x);\n\t\tdouble y = (point[i].se + point[i + n / 2].se) / 2.0;\n\t\tPy.push_back(y);\n\t}\n\n\t//?????§?±???????????±???¨??????????????????????????????????????§??????????????¨?°?????????????????????´??????????????°??????????±???§??????\n\tsort(all(Px));\n\tif(Px[n / 2 - 1] - Px[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(Py));\n\tif(Py[n / 2 - 1] - Py[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"%.9f %.9f\\n\", Px[0], Py[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  cout << fixed << setprecision(15);\n  \n  int N, X[50], Y[50];\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i];\n  }\n\n  bool flag = N % 2;\n  int x = X[0] + X[N / 2], y = Y[0] + Y[N / 2];\n  for(int i = 1; i < N / 2; i++) {\n    flag |= x != X[i] + X[i + N / 2];\n    flag |= y != Y[i] + Y[i + N / 2];\n  }\n  if(flag) cout << \"NA\" << endl;\n  else cout << x / 2.0 << \" \" << y / 2.0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double INF = 1e+9;\nconst double EPS = 1e-6;\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\nbool equal(P a, P b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n\nint n;\nvector<P> v;\n\ndouble binary_search(bool is_h){\n  L l;\n  double le = -INF, ri = INF, mid;\n  vector<P> cut_v;\n\n  while(ri - le > EPS/100.0){\n    mid = (ri + le) / 2.0;\n    if(is_h) l = L(P(-INF, mid), P(INF, mid));\n    else l = L(P(mid, INF), P(mid, -INF));\n    cut_v = convex_cut(v, l);\n    if(area(v) > area(cut_v) * 2.0) ri = mid;\n    else le = mid;\n  }\n\n  return (ri + le) / 2.0;\n}\n\nP solve(){\n  P res = P(binary_search(false), binary_search(true));\n  bool f = true;\n\n  /*\n  if(equal(area(v), area(convex_cut(v, L(res, res+P(1.0, 1.0)))) * 2.0) &&\n     equal(area(v), area(convex_cut(v, L(res, res+P(1.0, -1.0)))) * 2.0)) return res;\n  else return P(INF, INF);\n  */\n\n  if(n % 2) f = false;\n  else {\n    for(int i=0;i<n/2;i++){\n      if(!equal(v[i] - res, res - v[i+n/2])){\n        f = false;\n        break;\n      }\n    }\n  }\n\n  if(f) return res;\n  else return P(INF, INF);\n}\n\nint main(){\n  double x, y;\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      v.push_back(P(x, y));\n    }\n    P res = solve();\n    if(equal(res, P(INF, INF))) cout << \"NA\" << endl;\n    else printf(\"%.5f %.5f\\n\",res.real(),res.imag());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    bool operator!=(const Point& p) const{\n        return y != p.y || x != p.x;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    if(n % 2 == 1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    for(int i=0; i<n/2; ++i){\n        Point q1 = p[i] - p[i+1];\n        Point q2 = p[(n/2+i+1)%n] - p[n/2+i];\n        if(q1 != q2){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n\n    Point q = p[0] + p[n/2];\n    cout << (q.x / 2.0) << ' ' << (q.y / 2.0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n\n  bool ok = true;\n  P p = (ps[0] + ps[N/2]) * 0.5;\n  REP(i, N / 2){\n    ok &= abs(p - (ps[i] + ps[N/2 + i]) * 0.5) < EPS;\n  }\n  \n  if(ok && N % 2 == 0){\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst long double eps=1e-6;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<long double> point;\ntypedef pair<point,point> line;\nbool equal(const long double x1,const long double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\nlong double length(const point& a){ return abs(a); }\nlong double distance(const point& a,const point& b){ return abs(a-b); }\nlong double dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\nlong double cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    long double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\nlong double distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\nlong double distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\nlong double distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\nlong double distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\nlong double distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.second), distanceSP(t, s.second)));\n}\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\npoint intersection_l(const point& a1,const point& a2,const point& b1,const point& b2) {\n  const point& a=a2-a1,b=b2-b1;\n  return a1+a*cross(b, b1-a1)/cross(b, a);\n}\npoint intersection_l(const line& l,const line& m){\n    return intersection_l(l.first,l.second,m.first,m.second);\n}\n// ????§???¢????¬?????????¢???\nlong double area(const vector<point>& pol){\n    long double s=0;\n    rep(i,0,pol.size()) s+=cross(pol[i],pol[(i+1)%pol.size()]);\n    return s/2;\n}\n\nvector<point> convex_cut(const vector<point>& ps, const line& l) {\n    vector<point> res;\n    for (int i = 0; i < ps.size(); ++i) {\n        point a = ps[i], b = ps[(i+1)%ps.size()];\n        if (ccw(l.first, l.second, a) != -1) res.push_back(a);\n        if (ccw(l.first, l.second, a)*ccw(l.first, l.second, b) < 0) res.push_back(intersection_l(line(a, b), l));\n    }\n    return res;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<point> ps(n);\n    for(point& p:ps){\n        long double x,y;\n        cin >> x >> y;\n        p=point(x,y);\n        p*=point(cos(eps),sin(eps));\n    }\n\n    const long double s=area(ps);\n    auto opt=[&](){\n        long double left=inf,right=-inf;\n        for(const auto& p:ps){\n            if(p.real()<left) left=p.real();\n            if(p.real()>right) right=p.real();\n        }\n        line l(point(left,0),point(left,1));\n        long double lb=0,ub=distanceLP(l,point(right,0));\n        rep(i,0,100){\n            long double mid=(lb+ub)/2;\n            l=line(point(left+mid,0),point(left+mid,1));\n            if(area(convex_cut(ps,l))<=s/2) lb=mid;\n            else ub=mid;\n        }\n        return l;\n    };\n\n    line l1=opt();\n    for(auto& p:ps) p*=point(0,1);\n    line l2=opt();\n    l2=line(l2.first*point(0,-1),l2.second*point(0,-1));\n    for(auto& p:ps) p*=point(0,-1);\n    point ans=intersection_l(l1,l2);\n    bool ok=true;\n    const long double pi=3.14159265;\n    rep(i,0,10000){\n        const point tmp=ans+point(1,0)*point(cos(2*pi*i/10000),sin(2*pi*i/10000));\n        if(abs(area(convex_cut(ps,line(ans,tmp)))-s/2)>eps){\n            ok=false;\n            break;\n        }\n    }\n    if(ok) cout << ans.real() << \" \" << ans.imag() << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8) << endl;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <cmath>\n#define EPS 1e-8\nusing namespace std;\ntypedef complex<double> P;\n\nint main(){\n    int n;\n    cin >> n;\n\n    vector<P> G(n);\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        G[i] = P(x,y);\n    }\n\n    if(n%2!=0){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    int half = G.size()/2;\n    P mid = (G[0] + G[half])/P(2,0);\n    for(int i=1; i<half; i++){\n        P tmpmid = (G[i] + G[i+half])/P(2,0);\n        if(fabs(real(tmpmid)-real(mid))>EPS ||\n           fabs(imag(tmpmid)-imag(mid))>EPS){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed;\n    cout << setprecision(5);\n    cout << real(mid) << \" \" << imag(mid) << endl;\n            \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 55;\nll X[MAXN], Y[MAXN];\nint n;\n\nll square(ll x) {return x*x;}\n\nvoid solve() {\n    if (n != 4) {\n        cout << \"NA\" << endl;\n        return;\n    }\n    ll d[4];\n    for (int i = 0; i < 4; i++) {\n        int ni = (i+1)%4;\n        d[i] = (square(X[i]-X[ni])+square(Y[i]-Y[ni]));\n    }\n    for (int i = 0; i < 3; i++) {\n        if (d[i] != d[i+1]) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    for (int i = 0; i < 4; i++) {\n        int ni = (i+1)%4, nni = (i+2)%4;\n        ll dx0 = X[ni]-X[i], dy0 = Y[ni]-Y[i];\n        ll dx1 = X[nni]-X[ni], dy1 = Y[nni]-Y[ni];\n        if (dx0*dx1 + dy0*dy1 != 0) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    double ax = 0, ay = 0;\n    for (int i = 0; i < 4; i++) {\n        ax += X[i];\n        ay += Y[i];\n    }\n    cout << ax/4 << \" \" << ay/4 << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> X[i] >> Y[i];\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 100000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; vector<pair<long double, long double>>vec; long double X[100000], Y[100000], X1[100000], X2[100000], X3[100000], X4[100000], Y1[100000], Y2[100000], Y3[100000], Y4[100000], INF = 1e+14, EPS = 1e-14; int Q;\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; xp[0] = X1 - X2; yp[0] = Y1 - Y2; xp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }if (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }if ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }return false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { return make_pair(INF, INF); }\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }if (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }if (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }long double XP[4], YP[4], ZP[4];\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2; XP[1] = X3 - X4; YP[0] = Y1 - Y2; YP[1] = Y3 - Y4; ZP[0] = YP[0] / XP[0]; ZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1], K = (Y5 - Y1) / (ZP[0] - ZP[1]); long double L = K*ZP[0]; return make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { X1[i] = X[i]; Y1[i] = Y[i]; X2[i] = Y[(i + Q / 2) % Q]; Y2[i] = Y[(i + Q / 2) % Q]; vec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); }\n\tsort(vec.begin(), vec.end()); for (int i = 0; i < vec.size() - 1; i++) { if (fabs(vec[i].first - vec[i + 1].first) < EPS && fabs(vec[i].second - vec[i + 1].second) < EPS && vec[i].first < sqrtl(INF)) { cout << \"NA\" << endl; return; } }cout << fixed << setprecision(15) << vec[0].first << ' ' << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\n \nconst double eps = 1e-10;\n \nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n \ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n \nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n \nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n  double x = 0, y = 0;\n  for(int i = 0; i < N; ++i) {\n    x += ps[i].real();\n    y += ps[i].imag();\n  }\n  x /= N;\n  y /= N;\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 100000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-3)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!abs((a[i]+a[(i+n/2)%n])/2-c)<=0.0001||!abs((b[i]+b[(i+n/2)%n])/2-c))<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <chrono>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n/*\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back((Edge) { from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back((Edge) { from, to });\n\t\t\tg[to].push_back((Edge) { to, from });\n\t\t}\n\t}\n\treturn g;\n}*/\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\ntypedef long long ll;\n\nint main() {\n\tll N;\n\tcin >> N;\n\tPolygon ps(N);\n\tfor (int i = 0;i < N;i++)\n\t\tps[i] = input_point();\n\tvector<Line> ls;\n\tfor (int i = 0;i < N;i++)\n\t\tls.push_back(Line(ps[i], ps[(i+1)%N]));\n\tld b = 0;\n\tld t = 1;\n\tld S = area(ps) / 2;\n\tbool ok = true;\n\tLine cut1;\n\twhile (t - b > eps) {\n\t\tld m = (t + b) / 2;\n\t\tPoint now = m * ps[1] + (1-m) * ps[N-1];\n\t\tcut1 = Line(ps[0], now);\n\t\tPolygon cutted = convex_cut(ps, cut1);\n\t\tif (area(cutted) > S)\n\t\t\tt = m;\n\t\telse\n\t\t\tb = m;\n\t}\n\tassert(abs(S - area(convex_cut(ps, cut1))) < 0.0001);\n\tLine cut2;\n\tt = 1;\n\tb = 0;\n\twhile (t - b > eps) {\n\t\tld m = (t + b) / 2;\n\t\tPoint now = m * ps[0] + (1 - m) * ps[2];\n\t\tcut2 = Line(ps[1], now);\n\t\tPolygon cutted = convex_cut(ps, cut2);\n\t\tif (area(cutted) < S)\n\t\t\tt = m;\n\t\telse\n\t\t\tb = m;\n\t}\n\tassert(abs(S - area(convex_cut(ps, cut2))) < 0.0001);\n\tPoint ans = is_ll(cut1, cut2);\n\tfor (double i = 0;i < 2 * pi; i += 00.1) {\n\t\tPoint to = ans + Point(cos(i), sin(i));\n\t\tLine li(ans, to);\n\t\tPolygon cutted = convex_cut(ps, li);\n\t\tif (abs(area(cutted) - S) > 0.0001)\n\t\t\tok = false;\n\t}\n\tif (ok)\n\t\tprintf(\"%.10f %.10f\\n\", real(ans), imag(ans));\n\telse\n\t\tcout << \"NA\" << endl;\n \treturn 0;\n}\n/*\n4\n100 100\n0 100\n0 0\n100 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-8)<b&&b<a+(1e-8);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else cout<<a.f<<\" \"<<a.s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------\n//| ConvexCut |\n//| H28.03.12 |\n//-------------\n\n//---includes---//\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//---defines---//\n#define MAX_N 100000\n#define EPS 1e-14\n#define INF 1e14\n#define INF2 1e12\n\n//---ints---//\nint Q;\nvector<pair<long double, long double>>vec;\nlong double X[MAX_N], Y[MAX_N];\nlong double X1[MAX_N], X2[MAX_N], X3[MAX_N], X4[MAX_N];\nlong double Y1[MAX_N], Y2[MAX_N], Y3[MAX_N], Y4[MAX_N];\n\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; \n\txp[0] = X1 - X2; yp[0] = Y1 - Y2; \n\txp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }\n\tif (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }\n\tif ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }\n\treturn false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { \n\t\treturn make_pair(INF, INF); \n\t}\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }\n\tif (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }\n\tif (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }\n\tlong double XP[4], YP[4], ZP[4];\n\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2;\n\tXP[1] = X3 - X4; YP[1] = Y3 - Y4; \n\tZP[0] = YP[0] / XP[0]; \n\tZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1];\n\tlong double K = (Y5 - Y1) / (ZP[0] - ZP[1]); \n\tlong double L = K*ZP[0]; \n\treturn make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; \n\t\tX2[i] = X[(i + Q / 2) % Q]; \n\t\tY2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { \n\t\tlong double X_1 = vec[i].first, X_2 = vec[i + 1].first;\n\t\tlong double Y_1 = vec[i].second, Y_2 = vec[i + 1].second;\n\t\tif ((X_1 < INF2 || Y_1 < INF2) && (X_2 < INF2 || Y_2 < INF2)) {\n\t\t\tif (fabs(X_1 - X_2) > EPS || fabs(Y_1 - Y_2)>EPS) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << vec[0].first << ' ';\n\tcout << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { \n\tcin >> Q; \n\tfor (int i = 0; i < Q; i++) { \n\t\tcin >> X[i] >> Y[i]; \n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\nline half_line(vector<point> &g, int t){\n\tpoint p = g[t];\n\tdouble half = area(g)/2.0;\n\tdouble sum = 0.0;\n\tint i;\n\tdouble s;\n\tint n = g.size();\n\tfor(i=0;i<g.size();i++){\n\t\t s = cross(g[(i+t+1)%n]-p,g[(i+t+2)%n]-p)/2.0;\n\t\tif(s+sum+EPS>half)break;\n\t\telse sum+= s;\n\t}\n\t//cout<<t<<\": \"<<i+t+1<<' '<<half-sum<<' '<<s+sum-half<<endl;\n\tpoint a= g[(i+t+1)%n]*(s-half+sum) ,b= g[(i+t+2)%n]*(half-sum);\n\tpoint p2 = a+b;\n\tp2 = p2/s;\n\treturn  make(p,p2);\n}\npoint err = point(1e9,1e9);\npoint solve(vector<point> &g){\n\tdouble S =  area(g);\n\tdouble half = S/2.0;\n\tint n = g.size();\n\tvector<line>  l(n);\n\tfor(int i= 0;i<n;i++) l[i] = half_line(g,i);\n\tvector<point> ps(n);\n\tbool f = false;\n\tfor(int i=0;i<n;i++) ps[i] =  crosspoint(l[i],l[(i+1)%n] );\n\t//for(int i=0;i<n;i++) cout<<i<<\":  \"<<l[i].e.x<<' '<<l[i].e.y<<endl;\n\t//for(int i=0;i<n;i++) printf(\"%d: %0.6lf %0.6lf\\n\",i,ps[i].x,ps[i].y);\n\tfor(int i=0;i<n;i++)if(abs(ps[i]-ps[(i+1)%n] ) <1e-6 ){\n\n\t}else{\n\t\treturn err;\n\t}\n\n\treturn ps[0];\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<point> g(n);\n\tfor(int i=0;i<n;i++) g[i] = make();\n\tpoint ans = solve(g);\n\tif(ans == err||n==3){\n\t\tcout<<\"NA\"<<endl;\n\t}else{\n\t\t//cout<<ans.x<<' '<<ans.y<<endl;\n\t\tprintf(\"%0.6lf %0.6lf\\n\",ans.x,ans.y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-7)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(abs(px-x[j])<EPS&&abs(py-y[j])<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-5;\nconst long double INF = 10000000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half > all/2.0) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half > all/2.0) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!abs((a[i]+a[(i+n/2)%n])/2.0-c)<0.0001||!abs((b[i]+b[(i+n/2)%n])/2.0-d)<0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-5\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[51], y[51], t[51];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = sqrt(x[0]*x[0]+y[0]*y[0]);\n\t\telse{\n\t\t\tdouble d = sqrt(x[i]*x[i]+y[i]*y[i]);\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tx[n] = x[0]; y[n] = y[0]; t[n] = t[0];\n\trep(i,n) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\ta = t[i+1]-t[i];\n\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N;\n  cin>>N;\n  float x[N],y[N];\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  float tx,ty;\n  tx=(x[0]+x[N/2])/2;\n  ty=(y[0]+y[N/2])/2;\n  //cout<<\" \"<<\" \"<<tx<<\" \"<<ty<<endl;\n  for(int i=0;i<N/2;i++){\n    float dx=(x[i]+x[i+N/2])/2,dy=(y[i]+y[i+N/2])/2;\n    if(max(abs(dy-ty),abs(dx-tx))>0.0001){\n      cout<<\"NA\"<<endl;\n  //    cout<<dx<<\" \"<<dy<<\" \"<<tx<<\" \"<<ty<<endl;\n      return 0;\n    }\n  }\n  float l=pow(abs(x[1]-x[0]),2)+pow(abs(y[1]-y[0]),2);\n  for(int i=0;i<N-1;i++){\n    float k=pow(abs(x[i+1]-x[i]),2)+pow(abs(y[i+1]-y[i]),2);\n    if(abs(l-k)>1){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  printf(\"%f %f\\n\",tx,ty);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\n/* ??????????????¬ */\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;//????´???°\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);//conj::??±???????´???°\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\n/*int main(){\nPoint a(1,1),b(2,2);\nLine l(a,b);\n}*/\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\n//l::??´??????s::??????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨????????????????????? *slide??????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\t//norm::??¶?????????2???\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\ntypedef pair<ld, ld> P;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n        ld x,y;cin>>x>>y;\n        v[i]=P(x,y);\n    }\n    ld ma=0;\n    P mid;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            ld len= (v[i].first-v[j].first)*(v[i].first-v[j].first)+(v[i].second-v[j].second)*(v[i].second-v[j].second);\n            if(len>ma){\n                ma=len;\n                mid= P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n            }\n        }\n    }\n//    cout<<mid.first<<\" \"<<mid.second<<endl;\n//    cout<<ma<<endl;\n    if(ma==0) cout<<\"NA\"<<endl;\n    else{\n        for(int i=0;i<n;i++){\n            bool flag=false;\n            for(int j=0;j<n;j++){\n                P mi=P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n                if(eq(mi.first,mid.first)&&eq(mi.second,mid.second)){\n                    flag=true;break;\n                }\n            }\n            if(!flag){\n                cout<<\"NA\"<<endl;\n                return 0;\n            }\n        }\n        \n        cout<<fixed<<setprecision(10)<<mid.first<<\" \"<<mid.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS=1e-6;\n \ndouble cross(P a, P b){ return imag(conj(a)*b); }\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n \nint main(){\n  int n;\n  cin>>n;\n  vector<P> G(n);\n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    G[i]=P(x,y);\n  }\n  if(n%2){cout<<\"NA\"<<endl;return 0;}  \n  double len=abs(G[0]-G[1]);\n  for(int i=0;i<n/2;i++){\n    double a=abs(G[i]-G[(i+1)]);\n    double b=abs(G[i+n/2]-G[(i+n/2+1)%n]);\n    if(abs(a-b)>EPS){cout<<\"NA\"<<endl;return 0;}\n  }\n  P ans=crossPoint(L(G[0],G[n/2]),L(G[1],G[n/2+1]));\n  printf(\"%lf %lf\\n\",real(ans),imag(ans));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)cout<<gx<<' '<<gy<<endl;\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n/**************************************************************/\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// ???\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double c) {\n\t\treturn Point(c * x, c * y);\n\t}\n\tPoint operator / (double c) {\n\t\treturn Point(x / c, y / c);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n\t}\n\n\t// ?????????\n\tdouble norm() {\n\t\treturn (x * x + y * y);\n\t}\n\t// ??§??????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\n\n// ????????????\ntypedef Point Vector;\n\n// ??????\ndouble dot(Vector a, Vector b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\n// ??????\ndouble cross(Vector a, Vector b) {\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// ?????????\ndouble norm(Vector a) {\n\treturn (a.x * a.x + a.y * a.y);\n}\n\n// ??§??????\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\n// ??????\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\n// ??????(Parallel)????????????\nbool isParal(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParal(a1 - a2, b1 - b2);\n}\n\n// ?????????????????????????????????!!\nbool isParal(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// ?????¨???????????¢\ndouble distP(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\nint n;\nvector<Point> v;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tcin >> n;\n\tv.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> v[i].x >> v[i].y;\n\t}\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tSegment s(v[i], v[i+1]), t(v[(n/2+i)%n], v[(n/2+i+1)%n]);\n\t\t\n\t\t// ????????´????????¨????????§???????????????????????°????????°???????§°\n\t\tif (!isParal(s, t) || (s.p2 - s.p1).norm() != (t.p2 - t.p1).norm()) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t// ????§°???????????????????±???????\n\tPoint ans((v[0].x + v[n/2].x)/2, (v[0].y + v[n/2].y)/2);\n\t\n\tcout << fixed;\n\tcout.precision(10);\n\tcout << ans.x << \" \" << ans.y << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nint N;\nint x[50],y[50];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  set<pair<int,int> >s;\n  for(int i=0;i+N/2<N;i++){\n    s.insert(make_pair(x[i]+x[i+N/2],y[i]+y[i+N/2]));\n  }\n  if(N%2==1||s.size()>1){\n    cout<<\"NA\"<<endl;\n  }else{\n    auto p=*begin(s);\n    cout<<p.first/2.<<' '<<p.second/2.<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2442&lang=jp\n// references:http://purple-jwl.hatenablog.com/entry/20121013/1350099039\ntypedef long long ll;\ntypedef pair<ll, ll> Point;\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N; cin >> N;\n\tvector<Point> P(N);\n\tfor (int i = 0; i < N;i++) {\n\t\tll X, Y; cin >> X >> Y;\n\t\tP[i] = { X,Y };\n\t}\n\tif (N % 2 != 0) { cout << \"NA\" << endl; return 0; }\n\n\tll H = N / 2;\n\tfor (int i = 0; i < H;i++) {\n\t\tll l1 = pow(P[i].first - P[(i + 1) % N].first, 2) + pow(P[i].second - P[(i + 1) % N].second, 2);\n\t\tll l2 = pow(P[i + H].first - P[(i + 1 + H) % N].first, 2) + pow(P[i + H].second - P[(i + 1 + H) % N].second, 2);\n\t\tll l3 = pow(P[i].first - P[(i + 1 + H) % N].first, 2) + pow(P[i].second - P[(i + 1 + H) % N].second, 2);\n\t\tll l4 = pow(P[(i + 1) % N].first - P[i + H].first, 2) + pow(P[(i + 1) % N].second - P[i + H].second, 2);\n\t\tif ((l1 == l2) && (l3 == l4)) continue;\n\t\telse { cout << \"NA\" << endl; return 0; }\n\t}\n\n\tdouble gx, gy; gx = gy = 0;\n\tfor (int i = 0; i < N;i++) {\n\t\tgx += (double)P[i].first;\n\t\tgy += (double)P[i].second;\n\t}\n\tgx /= (double)N;\n\tgy /= (double)N;\n\tcout << fixed << setprecision(20) << gx << \" \" << gy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n;\n  cin >> n;\n  vector<int> x,y;\n  double ansx2,ansy2;\n  REP(i,n){\n    int tmp;\n    cin >> tmp;\n    x.push_back(tmp);\n    cin >> tmp;\n    y.push_back(tmp);\n  }\n  REP(i,n){\n    bool flag=true;\n    ansx2=x[0]+x[i];\n    ansy2=y[0]+y[i];\n    REP(j,n){\n      bool tmpflag=false;\n      REP(k,n){\n\tif(x[j]+x[k]==ansx2 && y[j]+y[k]==ansy2){\n\t  tmpflag=true;\n\t  break;\n\t}\n      }\n      if(!tmpflag){\n\tflag=false;\n\tbreak;\n      }\n    }\t\n    if(flag){\n      ansx2/=2.0;\n      ansy2/=2.0;\n      cout << fixed << setprecision(1) << ansx2 << ' ' << ansy2 << endl;\n      return 0;\n    }\n  }\n  cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\n\nbool check(const vector<P>& v, P& ans)\n{\n  int N = v.size();\n  if (N % 2 != 0) {\n    return false;\n  }\n  N /= 2;\n  ans = (v[0] + v[N])*0.5;\n  for (int i = 1; i < N; i++) {\n    const P p = (v[i] + v[N+i])*0.5;\n    if (abs(p - ans) > EPS) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int N;\n  scanf(\"%d\", &N);\n  vector<P> v;\n  for (int i = 0; i < N; i++) {\n    double x, y;\n    scanf(\"%lf %lf\", &x, &y);\n    v.push_back(P(x, y));\n  }\n  P ans;\n  if (check(v, ans)) {\n    printf(\"%.6f %.6f\\n\", ans.real(), ans.imag());\n  } else {\n    puts(\"NA\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 解説を見た　なるほど\n#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nbool equals(double x, double y){\n    return fabs(x-y) < 1e-6;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    if(n%2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    double x[n], y[n];\n    for(int i = 0; i < n; i++)  cin >> x[i] >> y[i];\n    double px = (x[0]+x[n/2])/2.0, py = (y[0]+y[n/2])/2.0;\n    bool ok = true;\n    for(int i = 1; i < n/2; i++){\n        ok &= equals(px-x[i], x[n/2+i]-px) && equals(py-y[i], y[n/2+i]-py);\n    }\n    if(ok)  cout << fixed << setprecision(12) << px << \" \" << py << endl;\n    else    cout << \"NA\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,long double> C;\n\nconst long double PI = acos(-1);\n\nlong double rabs(long double a,long double b){\n  return abs(a-b)/(a*b);\n}\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nlong double dot(P x,P y){return real(conj(x)*y);}\n\nlong double cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,long double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\nlong double arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nlong double arg(long double a,long double b,long double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nP line_cp(L a,L b){\n  long double A = cross(b.sc-b.fs,b.fs-a.fs);\n  long double B = cross(b.sc-b.fs,a.sc-a.fs);\n  if(abs(A) < EPS){\n    if(abs(B) < EPS)return a.fs; //same line\n    //else assert(false);\n  }\n  return a.fs+(a.sc-a.fs)*A/B;\n}\n\n//for polygon\n\n//all vertex is already sorted.\nlong double area(Poly p){\n  if(p.size()<3)return 0;\n  long double res = cross(p[p.size()-1],p[0]);\n  for(int i=1;i<p.size();i++)res += cross(p[i-1],p[i]);\n  return res/2;\n}\n\n//all vertex is already sorted.\nPoly convex_cut(Poly p,L l){\n  Poly res;\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    int nxt = (i+1)%n;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  Poly p;\n\n  scanf(\"%d\",&n);\n  p.resize(n);\n  for(int i=0;i<n;i++)scanf(\"%Lf%Lf\",&p[i].real(),&p[i].imag());\n  long double s = area(p)/2;\n\n  P a[2];\n  long double lx = p[0].real(), ux = p[0].real(), ly = p[0].imag();\n  for(int i=1;i<n;i++){\n    lx = min(lx,p[i].real());\n    ux = max(ux,p[i].real());\n    ly = min(ly,p[i].imag());\n  }\n  a[0] = P(lx,ly-1e2); a[1] = P(ux,ly-1e2);\n\n  L line[2];\n  for(int i=0;i<2;i++){\n    long double l = 0,r = PI,mid;\n    P u = P(1,0);\n\n    for(int j=0;j<100;j++){\n      mid = (l+r)/2;\n      L tmp = L(a[i],a[i]+rotate(u,mid));\n      long double cut = area(convex_cut(p,tmp));\n      if(cut + EPS < s)r = mid;\n      else l = mid;\n    }\n    line[i] = L(a[i],a[i]+rotate(u,l));\n  }\n  \n  P res = line_cp(line[0],line[1]);\n  \n  for(int i=0;i<n;i++){\n    L tmp = L(res,p[i]);\n    Poly hoge = convex_cut(p,tmp);\n    //printf(\"%.20Lf\\n\",area(convex_cut(p,tmp)));\n    if(rabs(s, area(convex_cut(p,tmp))) > EPS){\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.8Lf %.8Lf\\n\",res.real(),res.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    for(int i=0; i<n; i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    if(n&1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    int ax, ay;\n    for(int i=0; i*2 < n; i++){\n        int j = n/2 + i;\n        if(i == 0){\n            ax = p[i].first + p[j].first;\n            ay = p[i].second + p[j].second;\n        }\n        if(ax != p[i].first + p[j].first || ay != p[i].second + p[j].second){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed << setprecision(20) << 1.*ax/2. << \" \" << 1.*ay/2. << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto & it:v)\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\n#define IL inline\n#define X real()\n#define Y imag()\nIL D dot(P a,P b){\n    return a.X*b.X+a.Y*b.Y;\n}\nIL D cross(P a,P b){\n    return a.X*b.Y-a.Y*b.X;\n}\n\n\nIL D ccw(P a,P b,P c){\n    return cross(b-a,c-a);\n}\n\n\nIL D convex_area(Poly pp){\n    D res=0;\n    for(int i=2,n=pp.size();i<n;i++)\n\tres+=abs(ccw(pp[0],pp[i-1],pp[i]))/2,0;\n    return res;\n}\n\nstruct INIT{\n    INIT(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout<<fixed;\n\tcout<<setprecision(10);\n    }\n}init;\n\nIL P convex_gravity_point(Poly& pp){\n    P g(0,0);\n    D s=0;\n    for(int i=2,n=pp.size();i<n;i++){\n\tD t=convex_area({pp[0],pp[i-1],pp[i]});\n\tg+=t*(pp[0]+pp[i-1]+pp[i])/3.0;\n\ts+=t;\n    }\n    return g/s;\n}\nint main(){\n    int N;\n    cin>>N;\n    Poly p(N);\n    rep(i,N){\n\tD x,y;\n\tcin>>x>>y;\n\tp[i]=P(x,y);\n    }\n    auto g=convex_gravity_point(p);\n    if(N&1)cout<<\"NA\"<<endl;\n    else{\n\tint M=N/2;\n\trep(i,N){\n\t    if(abs(abs(g-p[i])-abs(g-p[i+M]))>1e-8){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t    }\n\t}\n\tcout<<g.X<<\" \"<<g.Y<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long double EPS = 1e-7;\n\nstruct point {\n\tlong double x, y;\n\tpoint(long double x = 0.0, long double y = 0.0):x(x), y(y) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(long double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n};\n\nlong double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nlong double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst long double t = cross(b, c);\n\tif(t > EPS) return 1;\n\tif(t < -EPS) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\npoint rotate(const point &p, long double theta) {\n\tconst long double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\npoint crosspoint(const line &a, const line &b) {\n\tconst long double t = cross(a.b - a.a, b.b - b.a);\n\tif(abs(t) < EPS) return a.a;\n\treturn b.a + (b.b - b.a) * cross(a.b - a.a, a.a - b.a) * (1 / t);\n}\n\ntypedef vector<point> polygon;\n\nlong double area(const polygon &p) {\n\tconst int n = p.size();\n\tif(n < 3) return 0.0;\n\n\tlong double res = cross(p[n - 1], p[0]);\n\tfor(int i = 1; i < n; ++i) {\n\t\tres += cross(p[i - 1], p[i]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\npolygon convex_cut(const polygon &p, const line &l) {\n\tconst int n = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int next = (i + 1) % n;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1) res.emplace_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0) {\n\t\t\tres.emplace_back(crosspoint(l, line(p[i], p[next])));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool ok(const point &g, const polygon &p) {\n\tconst long double S_half = area(p) / 2.0;\n\tfor(long double theta = 0; theta < M_PI; theta += 0.01) {\n\t\tconst long double  S = area(convex_cut(p, line(g, g + rotate(point(10, 0), theta))));\n\t\tif(abs((S_half - S) / S_half) > EPS) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(5);\n\tcout.flags(ios::fixed);\n\n\tint n;\n\tcin >> n;\n\n\tpoint g(0, 0);\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.emplace_back(x, y);\n\t\tg = g + p[i];\n\t}\n\n\tg = g * (1.0 / n);\n\n\tif(ok(g, p)) {\n\t\tcout << g.x << \" \" << g.y << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvi a,b;\n\nint main(){\n\tcin>>n;\n\ta=b=vi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i]>>b[i];\n\tif(n%2==1){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tbool B=1;\n\tfor(int i=0;i<n/2;i++){\n\t\tint N=n/2;\n\t\tint x=a[i+1]-a[i],y=b[i+1]-b[i];\n\t\tint x_=a[(i+N+1)%n]-a[i+N],y_=b[(i+N+1)%n]-b[i+N];\n\t\tif(x!=x_||y!=y_) x*=-1,y*=-1;\n\t\tif(x!=x_||y!=y_) B=0;\n\t}\n\tif(B){\n\t\tdouble x=0,y=0;\n\t\tfor(int i=0;i<n;i++) x+=a[i],y+=b[i];\n\t\tcout<<syosu(9)<<x/n<<' '<<y/n<<endl;\n\t}\n\telse cout<<\"NA\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(long long i=0; i<(n); i++)\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\n\nint main(){\n    ll n; cin >> n;\n    vector<ll> x(n), y(n);\n    rep(i, n){\n        cin >> x[i];\n        cin >> y[i];\n    }\n    if(n % 2 == 1) cout << \"NA\" << endl;\n    else{\n        double px = (x[0] + x[n / 2]) / 2.0, py = (y[0] + y[n / 2]) / 2.0;\n        rep(i, n / 2) {\n            double vx = (x[i] + x[i + n / 2]) / 2.0, vy = (y[i] + y[i + n / 2]) / 2.0;\n            if(abs(px - vx) > 1e-10 || abs(py - vy) > 1e-10){\n                cout << \"NA\" << endl;\n                return 0;\n            }\n        }\n        cout << fixed << setprecision(10) << px << ' ' << py << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2442.cc: ConvexCut\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50;\nconst int ITL = 100;\n\nconst double DELTA = 1.0e-4;\nconst double DINF = 1e18;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n\n/* global variables */\n\n/* subroutines */\n\nbool cross_lines(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  double op01 = av.cross(bv);\n  //if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  if (op01 == 0.0) {\n    pt v = bp - ap;\n    if (v.cross(av) != 0.0) return false;\n\n    pt a1 = ap + av;\n    pt b1 = bp + bv;\n\n    return\n      ((bp - ap).dot(b1 - ap) <= 0.0 ||\n       (bp - a1).dot(b1 - a1) <= 0.0 ||\n       (ap - bp).dot(a1 - bp) <= 0.0 ||\n       (ap - b1).dot(a1 - b1) <= 0.0);\n  }\n\n  pt v = bp - ap;\n  double op0 = v.cross(av);\n  double op1 = v.cross(bv);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = bv * t1 + bp;\n  cl.t0 = t0;\n  cl.t1 = t1;\n\n  return true;\n  //return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\nvoid convex_cut(const vpt& scpol, vpt& dcpol, const pt& p0, const pt& p1) {\n  int n = scpol.size();\n  pt pv = p1 - p0;\n  dcpol.clear();\n\n  for (int i = 0; i < n; i++) {\n    const pt& cp0 = scpol[i];\n    double cr0 = pv.cross(cp0 - p0);\n    if (cr0 >= 0.0) dcpol.push_back(cp0);\n    \n    const pt& cp1 = scpol[(i + 1) % n];\n    double cr1 = pv.cross(cp1 - p0);\n    if (cr0 * cr1 < 0.0) {\n      CL cl;\n      cross_lines(p0, pv, cp0, cp1 - cp0, cl);\n      dcpol.push_back(cl.p);\n    }\n  }\n}\n\ndouble calc_area(const vpt& cpol) {\n  int nc = cpol.size();\n  if (nc < 3) return 0.0;\n\n  const pt& p0 = cpol[0];\n  pt v0 = cpol[1] - p0;\n  double area = 0.0;\n  \n  for (int i = 2; i < nc; i++) {\n    pt v1 = cpol[i] - p0;\n    area += v0.cross(v1);\n    v0 = v1;\n  }\n\n  return (area / 2);\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  vpt pol;\n  double minx = DINF, maxx = -DINF, miny = DINF, maxy = -DINF;\n\n  \n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    pol.push_back(pt(x, y));\n    if (minx > x) minx = x;\n    if (maxx < x) maxx = x;\n    if (miny > y) miny = y;\n    if (maxy < y) maxy = y;\n  }\n\n  double pah = calc_area(pol) / 2;\n  //printf(\"pah=%.6lf\\n\", pah);\n\n  double cx0 = minx, cx1= maxx;\n  for (int i = 0; i < ITL; i++) {\n    double cx = (cx0 + cx1) / 2;\n    pt p0(cx, miny), p1(cx, maxy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cx=%.6lf => ca=%.6lf\\n\", cx, ca);\n    \n    if (ca < pah) cx0 = cx;\n    else cx1 = cx;\n  }\n  //printf(\"cx0=%.6lf, cx1=%.6lf\\n\", cx0, cx1);\n\n  double cy0 = miny, cy1= maxy;\n  for (int i = 0; i < ITL; i++) {\n    double cy = (cy0 + cy1) / 2;\n    pt p0(minx, cy), p1(maxx, cy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cy=%.6lf => ca=%.6lf\\n\", cy, ca);\n\n    if (ca > pah) cy0 = cy;\n    else cy1 = cy;\n  }\n  //printf(\"cy0=%.6lf, cy1=%.6lf\\n\", cy0, cy1);\n\n  bool ok = true;\n  pt cp0(cx0, cy0);\n\n  for (int i = 0; i < pol.size(); i++) {\n    vpt cpol;\n    convex_cut(pol, cpol, cp0, pol[i]);\n    double ca = calc_area(cpol);\n\n    if (abs(pah - ca) > DELTA) {\n      ok = false;\n      break;\n    }\n  }\n  \n  if (ok) printf(\"%.6lf %.6lf\\n\", cx0, cy0);\n  else cout << \"NA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-8;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tvector<P> vp(n);\n\tvector<Line> vl(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tvp[i] = P(x,y);\n\t\tvl[i] = Line(vp[i], vp[(i+1)%n]);\n\t}\n\t// used[i] := 辺 i について平行で長さが等しい辺が存在するかどうか\n\tbool used[51] = {false};\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) continue;\n\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\t// 辺の長さ\n\t\t\tdouble a = abs(vp[i] - vp[(i+1)%n]);\n\t\t\tdouble b = abs(vp[j] - vp[(j+1)%n]);\n\t\t\tif( vl[i].parallel( vl[j] ) && equal(a,b) ){\n\t\t\t\tused[i] = used[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) k++;\n\t}\n\t// 頂点数が奇数 かつ すべての辺について平行で長さの等しい辺が存在するときは点Pが存在する.\n\tif( n%2 == 1 ){\n\t\tprintf(\"NA\\n\");\n\t}else if( k == n ){\n\t\tLine l1(vp[0], vp[n/2]);\n\t\tLine l2(vp[1], vp[n/2+1]);\n\t\tP p;\n\t\tl1.intersection(l2, p);\n\t\tprintf(\"%.6f %.6f\\n\", p.X, p.Y);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint m;\n\tcin>>m;\n\tif(m%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tm/=2;\n\tint a[50],a1[50],b[50],b1[50];\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a[i]>>b[i];\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a1[i]>>b1[i];\n\t}\n\tint ans1=a[0]+a1[0],ans2=b[0]+b1[0];\n\tfor(int i=1;i<m;++i){\n\t\tif(a[i]+a1[i]!=ans1){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(b[i]+b1[i]!=ans2){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<(double)ans1/2.0<<\" \"<<(double)ans2/2.0<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\n\n\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tREP(i, v.size()) { if (i)os << \" \"; os << v[i]; }return os;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) {\n\tREP(i, v.size()) { if (i)os << endl; os << v[i]; }return os;\n}\n\n//誤差修正用\nconst double EPS = 1;\n\n//円周率\nconst double PI = acos(-1);\n\n//double型の値が等しいか\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//点に関する構造体\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() {}\n\n\tPoint(double x, double y) : x(x), y(y) {}\n\n\t//加減、スカラー倍、乗算など\n\tPoint operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n\tPoint operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n\tPoint operator*(const double b) const { return Point(x * b, y * b); }\n\n\tPoint operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n\tPoint operator/(const double b) const { return Point(x / b, y / b); }\n\n\tbool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n\tbool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n\t//大きさの二乗\n\tdouble norm() { return x * x + y * y; }\n\n\t//逆正接（x軸正方向からの反時計回り回転角）\n\tdouble arg() { return atan2(x, y); }\n\n\t//大きさ\n\tdouble abs() { return sqrt(norm()); }\n\n\t//反時計回りにθ回転\n\tPoint rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n\t//反時計回りにπ/2回転\n\tPoint rotate90() { return Point(-y, x); }\n\n\tfriend ostream &operator<<(ostream &os, Point &p) { return os << p.x << \" \" << p.y; }\n\n\tfriend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n};\n\n//外積\ndouble cross(const Point &a, const Point &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n//内積\ndouble dot(const Point &a, const Point &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//直線に関する構造体\n//直線が通る2点で表す\nstruct Line\n{\n\tPoint a, b;\n\n\tLine() {};\n\n\tLine(Point a, Point b) : a(a), b(b) {};\n\n\tvoid set(Point a, Point b) {\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n\tfriend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n};\n\n//多角形\ntypedef vector< Point > Polygon;\n\n//3点の位置関係を判定\nint ccw(const Point &a, Point b, Point c)\n{\n\tb = b - a, c = c - a;\n\n\t//a→bで反時計回りの方向にc\n\tif (cross(b, c) > EPS) return +1;\n\n\t//a→bで時計回りの方向にc\n\tif (cross(b, c) < -EPS) return -1;\n\n\t//c→a→bで一直線\n\tif (dot(b, c) < 0) return +2;\n\n\t//a→b→cで一直線\n\tif (b.norm() < c.norm()) return -2;\n\n\t//a→c→bで一直線\n\treturn 0;\n}\n\n//2直線の平行判定\nbool IsParallel(const Line& a, const Line& b) {\n\treturn abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\n//点集合（多角形）の凸包を求める\n//Andrew's Monotone Chain\n//O(NlogN)（ソート依存）\nPolygon Convex_Hull(Polygon& p) {\n\tint n = p.size(), k = 0;\n\tif (n >= 3) {\n\t\tsort(p.begin(), p.end());\n\t\tvector< Point > ch(2 * n);\n\t\tfor (int i = 0; i < n; ch[k++] = p[i++]) {\n\t\t\tREP(i, ch.size()) {\n\t\t\t\t//cout << ch[i] << endl;\n\t\t\t}\n\t\t\t//cout << k << endl << i << endl << endl;\n\t\t\twhile (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n\t\t\twhile (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tch.resize(k - 1);\n\t\treturn ch;\n\t}\n\telse {\n\t\treturn p;\n\t}\n}\n\n//2直線の交差判定\nbool Intersect(const Line &l, const Line &m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\n//2直線の交点\nPoint Crosspoint(const Line &l, const Line &m)\n{\n\tdouble A = cross(l.b - l.a, m.b - m.a);\n\tdouble B = cross(l.b - l.a, l.b - m.a);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n\treturn m.a + (m.b - m.a) * B / A;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n//凸多角形の切断\n//直線に対して左側にある部分（交点を含む）を返す\nPolygon ConvexCut(Polygon &U, Line l)\n{\n\tPolygon ret;\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tPoint now = curr(U, i), nxt = next(U, i);\n\t\tif (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n\t\tif (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n\t\t\tret.push_back(Crosspoint(Line(now, nxt), l));\n\t\t}\n\t}\n\treturn (ret);\n}\n\n//多角形の面積\n//ただし返り値は求めたい値の2倍になっている\ndouble Area2(const Polygon &p)\n{\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i) {\n\t\tA += cross(p[i], p[(i + 1) % p.size()]);\n\t}\n\treturn A;\n}\n\n\nint xcomp(pair<ll,ll>& a, pair<ll,ll>& b) {\n\tif (a.first == b.first) {\n\t\treturn a.second<b.second;\n\t}\n\treturn a.first < b.first;\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nll mod = 1000000007;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tPolygon polygon;\n\n\tREP(i, n) {\n\t\tPoint point;\n\t\tcin >> point;\n\n\t\tpolygon.push_back(point);\n\t}\n\n\tdouble Sall = Area2(polygon)/2.0;\n\n\tLine linecut1;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tLine line(polygon[0], polygon[i]);\n\t\t\tdouble Scut = Sall-Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i - 1] + (polygon[i] - polygon[i - 1])*ratio;\n\t\t\t\tlinecut1.set(polygon[0], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tLine linecut2;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = n-2; i >= 0; --i) {\n\t\t\tLine line(polygon[n-1], polygon[i]);\n\t\t\tdouble Scut = Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i + 1] + (polygon[i] - polygon[i + 1])*ratio;\n\t\t\t\tlinecut2.set(polygon[n-1], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tPoint crosspoint = Crosspoint(linecut1, linecut2);\n\n\tbool flag = true;\n\n\tREP(i, 100) {\n\t\trandom_device rnd;     // 非決定的な乱数生成器を生成\n\t\tmt19937 mt(rnd());     //  メルセンヌ・ツイスタの32ビット版、引数は初期シード値\n\t\tuniform_int_distribution<> rand1000000(0, 1000000);        // [0, 99] 範囲の一様乱数\n\n\t\tPoint randompoint(rand1000000(mt), rand1000000(mt));\n\n\t\tLine randomline(crosspoint, randompoint);\n\n\t\tdouble Srandomcut = Area2(ConvexCut(polygon, randomline)) / 2.0;\n\n\t\tif (!eq(Sall, Srandomcut*2.0)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag) {\n\t\tcout << crosspoint << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nusing Point = std::complex<ld>;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nclass Circle {\n public:\n  Point p;\n  ld r;\n  Circle() : p(Point(0, 0)), r(0) {}\n  Circle(Point p, ld r) : p(p), r(r) {}\n};\nld degree_ll(Line l, Line m) {\n  ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n  if (cos_shita < -1.0) cos_shita = -1.0;\n  if (cos_shita > 1.0) cos_shita = 1.0;\n  ld shita = acos(cos_shita);\n  return shita;\n}\nll dist(pair<ll, ll> p1, pair<ll, ll> p2) {\n  return (p1.first - p2.first) * (p1.first - p2.first) + (p1.second - p2.second) * (p1.second - p2.second);\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n; cin >> n;\n  if(n%2) {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  ld nowx = 0, nowy = 0;\n  vector<Point> v;\n  for(int i=0;i<n;++i) {\n    ll x, y; cin >> x >> y;\n    nowx += x; nowy += y;\n    v.push_back(Point(x, y));\n  }\n  nowx /= n;\n  nowy /= n;\n  Point ans(nowx, nowy);\n  bool ok = true;\n  for(int i=0;i<n/2;++i) {\n    ld d1 = abs(v[i] - ans);\n    ld d2 = abs(v[i+n/2] - ans);\n    if(abs(d1 - d2) > eps) {\n      ok = false;\n      break;\n    }\n  }\n  if(ok) cout << ans.real() << \" \" << ans.imag() << endl;\n  else cout << \"NA\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; x = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; y = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-4)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.5f %.5f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std; vector<pair<long double, long double>>vec; long double X[100000], Y[100000], X1[100000], X2[100000], X3[100000], X4[100000], Y1[100000], Y2[100000], Y3[100000], Y4[100000], INF = 1e+14, EPS = 1e-14; int Q;\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; xp[0] = X1 - X2; yp[0] = Y1 - Y2; xp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }if (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }if ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }return false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { return make_pair(INF, INF); }\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }if (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }if (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }long double XP[4], YP[4], ZP[4];\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2; XP[1] = X3 - X4; YP[0] = Y1 - Y2; YP[1] = Y3 - Y4; ZP[0] = YP[0] / XP[0]; ZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1], K = (Y5 - Y1) / (ZP[0] - ZP[1]); long double L = K*ZP[0]; return make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; X2[i] = X[(i + Q / 2) % Q]; Y2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { if (fabs(vec[i].first - vec[i + 1].first) > EPS && fabs(vec[i].second - vec[i + 1].second) > EPS && vec[i].first < INF / 100 && vec[i + 1].first < INF / 100 ) { cout << \"NA\" << endl; return; } }cout << fixed << setprecision(15) << vec[0].first << ' ' << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef long double Real;\n\nReal eps = 1e-12;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\nconst int MAXN = 55;\nP pnts[MAXN];\nint n;\n\nvoid solve() {\n    if (n % 2 == 1) {\n        cout << \"NA\" << endl;\n        return;\n    }\n    Real ax = 0, ay = 0;\n    for (int i = 0; i < n; i++) {\n        ax += pnts[i].x;\n        ay += pnts[i].y;\n    }\n    ax /= n; ay /= n;\n    P a(ax, ay);\n    for (int i = 0; i < n/2; i++) {\n        if (!on_seg(pnts[i], pnts[i+n/2], a) || a.dist(pnts[i]) != a.dist(pnts[i+n/2])) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    printf(\"%.10Lf %.10Lf\\n\", ax, ay);\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> pnts[i].x >> pnts[i].y;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    for(int i=0; i<n; i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    if(n&1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    int ax, ay;\n    for(int i=0; i*2 < n; i++){\n        int j = n/2 + i;\n        if(i == 0){\n            ax = p[i].first + p[j].first;\n            ay = p[i].second + p[j].second;\n        }\n        if(ax != p[i].first + p[j].first || ay != p[i].second + p[j].second){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed << setprecision(20) << 1.*ax/2. << \" \" << 1.*ay/2. << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n;\n\tcin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°?????¨??????????§°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\trep(i, n - 2){\n\t\tdouble len1 = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tdouble len2 = pow(point[i + 2].fi - point[i + 1].fi, 2) + pow(point[i + 2].se - point[i + 1].se, 2);\n\t\tif(abs(len2 - len1) > EPS){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdouble len0 = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tdouble lenf = pow(point[n - 1].fi - point[n - 2].fi, 2) + pow(point[n - 1].se - point[n - 2].se, 2);\n\tif(len0 - lenf > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tdouble x1 = ((double)point[0].fi + (double)point[n / 2].fi) / 2.0;\n\tdouble y1 = ((double)point[0].se + (double)point[n / 2].se) / 2.0;\n\n\treps(i, 1, n / 2){\n\t\tdouble x2 = ((double)point[i].se + (double)point[i + n / 2].se) / 2.0;\n\t\tdouble y2 = ((double)point[i].se + (double)point[i + n / 2].se) / 2.0;\n\t\tif(abs(x1 - x2) > EPS || abs(y1 - y2) > EPS){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\tprintf(\"%.9f %.9f\\n\", x1, y1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-7)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\n \nconst double eps = 1e-10;\n \nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n \ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n \nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n \nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n  double x = 0, y = 0;\n  for(int i = 0; i < N; ++i) {\n    x += ps[i].real();\n    y += ps[i].imag();\n  }\n  x /= N;\n  y /= N;\n  P g(x, y);\n  bool flag = true;\n  srand(time(NULL));\n  for(int k = 0; k < 100000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-2)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\tint x[110], y[110];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tset<P> s;\n\tfor (int i = 0; i < n/2; i++) {\n\t\ts.insert(P(x[i]+x[i+n/2], y[i]+y[i+n/2]));\n\t}\n\tif (s.size() == 1) {\n\t\tP p = *s.begin();\n\t\tprintf(\"%.20f %.20f\\n\", (double)(p.first)/2, (double)(p.second)/2);\n\t} else {\n\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-8;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n  \n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[(i+1)%n] - x[i];\n    double ay = y[(i+1)%n] - y[i];\n    double bx = x[(i+1+n/2)%n] - x[(i+n/2)%n];\n    double by = y[(i+1+n/2)%n] - y[(i+n/2)%n];\n    ok &= abs(ax*by - bx*ay) < EPS;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n  }\n  \n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!(abs(a[i]-a[(i+n/2)%n])/2-c)<=0.0001||!(abs(b[i]-b[(i+n/2)%n])/2-c)<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    int j = (i + N / 2) % N;\n    ok &= !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N]));\n  }\n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-------------\n//| ConvexCut |\n//| H28.03.12 |\n//-------------\n\n//---includes---//\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//---defines---//\n#define MAX_N 100000\n#define EPS 1e-14\n#define EPS2 1e-6\n#define INF 1e14\n#define INF2 1e12\n\n//---ints---//\nint Q;\nvector<pair<long double, long double>>vec;\nlong double X[MAX_N], Y[MAX_N];\nlong double X1[MAX_N], X2[MAX_N], X3[MAX_N], X4[MAX_N];\nlong double Y1[MAX_N], Y2[MAX_N], Y3[MAX_N], Y4[MAX_N];\n\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; \n\txp[0] = X1 - X2; yp[0] = Y1 - Y2; \n\txp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }\n\tif (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }\n\tif ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }\n\treturn false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { \n\t\treturn make_pair(INF, INF); \n\t}\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }\n\tif (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }\n\tif (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }\n\tlong double XP[4], YP[4], ZP[4];\n\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2;\n\tXP[1] = X3 - X4; YP[1] = Y3 - Y4; \n\tZP[0] = YP[0] / XP[0]; \n\tZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1];\n\tlong double K = (Y5 - Y1) / (ZP[0] - ZP[1]); \n\tlong double L = K*ZP[0]; \n\treturn make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; \n\t\tX2[i] = X[(i + Q / 2) % Q]; \n\t\tY2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { \n\t\tlong double X_1 = vec[i].first, X_2 = vec[i + 1].first;\n\t\tlong double Y_1 = vec[i].second, Y_2 = vec[i + 1].second;\n\t\tif ((X_1 < INF2 || Y_1 < INF2) && (X_2 < INF2 || Y_2 < INF2)) {\n\t\t\tif (fabs(X_1 - X_2) > EPS2 || fabs(Y_1 - Y_2) > EPS2) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << vec[0].first << ' ';\n\tcout << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { \n\tcin >> Q; \n\tfor (int i = 0; i < Q; i++) { \n\t\tcin >> X[i] >> Y[i]; \n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-12;\n\ntypedef complex<long double> P;\nlong double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nlong double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  long double A = cross(l[1] - l[0], m[1] - m[0]);\n  long double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    bool f = false;\n    REP(j, N)if(i != j){\n      f |= !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N]));\n    }\n    ok &= f;\n  }\n  \n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\n int x[60],y[60];\n     signed main(){\nint n;\n cin>>n;\n     \tif(n%2) {\n     \tcout<<\"NA\"<<endl;\n     \t\treturn 0;\n     \t}\n     \tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n     \t\n     \tint d=n/2;\n     \t\n     \tdouble gx=(x[0]+x[0+d]+0.0)/2.0;\n     \tdouble gy=(y[0]+y[0+d]+0.0)/2.0;\n     \tbool bo=true;\n     \tfor(int i=1;i<d;i++){\n     \t\tif(abs(gx-(x[i]+x[i+d]+0.0)/2.0)>0.00001)bo=false;\n     \t\tif(abs(gy-(y[i]+y[i+d]+0.0)/2.0)>0.00001)bo=false;\n     \t}\n     \tif(bo) printf(\"%.10lf %.10lf\\n\",gx,gy);\n     \telse cout<<\"NA\"<<endl;\n \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n\nint main(){\n    int n;\n    cin >> n;\n\n    Point p[55];\n    rep(i,n){\n        double x, y;\n        cin >> x >> y;\n        p[i] = Point(x,y);\n    }\n    if(n % 2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    Segment seg[55];\n    rep(i,n / 2){\n        seg[i] = Segment{p[i], p[i + n / 2]};\n    }\n\n    set<Point> s;\n    rep(i,n / 2){\n        rep(j,n / 2){\n            if(i == j) continue;\n            s.insert(intersectionLs(seg[i], seg[j]));\n        }\n    }\n    if(s.size() > 1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    cout <<fixed << setprecision(5)<< s.begin()->real() << ' ' << s.begin()->imag() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nusing Point = complex<double>;\nenum { OUT, ON, IN };\nistream &operator>>(istream &is, Point &p)\n{\n    double a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nconst double  PI = acos(-1);\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//二つのスカラーが等しいか\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n//二つのベクトルが等しいか\n#define EQV(a, b) (EQ((a), real(), (b).real()) && EQ((a), imag(), (b).imag()))\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    //a, bはそれぞれ座標を指す. これより一つの「line」に対して二個の点を持つことになる\n    Line(double A, double B, double C) // Ax + By = C\n    {\n        if (eq(A, 0))\n            a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0))\n            b = Point(C / A, 0), b = Point(C / A, 1);\n        else\n            a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p)\n    {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a)\n    {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line\n{\n    Segment() {}\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\nstruct Circle\n{\n    Point p;\n    double r;\n\n    Circle() {}\n\n    Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\ndouble dot(const Point a, const Point b)\n{\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(const Point a, const Point b)\n{\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nint ccw(const Point &a, Point b, Point c)\n{\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS)\n        return +1; // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS)\n        return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0)\n        return +2; // \"ONLINE_BACK\"\n    if (norm(b) < norm(c))\n        return -2; // \"ONLINE_FRONT\"\n    return 0;      // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b)\n{\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b)\n{\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p)\n{\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p)\n{\n    return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p)\n{\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m)\n{\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p)\n{\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s)\n{\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS)\n        return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\ndouble distance(const Point &a, const Point &b)\n{\n    return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p)\n{\n    return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m)\n{\n    return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p)\n{\n    Point r = projection(s, p);\n    if (intersect(s, r))\n        return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b)\n{\n    if (intersect(a, b))\n        return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s)\n{\n    if (intersect(l, s))\n        return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\ndouble area2(const Polygon &p)\n{\n    double A = 0;\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        A += cross(p[i], p[(i + 1) % p.size()]);\n    }\n    return A;\n}\n\nbool isConvex(const Polygon &p)\n{\n    for (int i = 0; i < (int)p.size(); ++i)\n    {\n        if (cross(p[(i - 1 + p.size()) % p.size()] - p[i], p[i] - p[(i + 1) % p.size()]) < -EPS)\n            return false;\n    }\n    return true;\n}\n\nint contains(const Polygon &Q, const Point &p)\n{\n    bool in = false;\n    for (int i = 0; i < Q.size(); ++i)\n    {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if (a.imag() > b.imag())\n            swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0)\n            in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0)\n            return ON;\n    }\n    return in ? IN : OUT;\n}\nPolygon convex_hull(Polygon &p)\n{\n    int n = (int)p.size(), k = 0;\n    if (n <= 2)\n        return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(n * 2);\n\n    for (int i = 0; i < n; ch[k++] = p[i++])\n    {\n        while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--])\n    {\n        while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0)\n            --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\ndouble convex_diameter(const Polygon &p)\n{\n    int n = (int)p.size();\n    if (n == 2)\n        return abs(p[0] - p[1]);\n\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i)\n    {\n        if (imag(p[i]) > imag(p[is]))\n            is = i;\n        if (imag(p[i]) < imag(p[js]))\n            js = i;\n    }\n\n    double res = abs(p[is] - p[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do\n    {\n        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n        res = max(res, abs(p[i] - p[j]));\n    } while (i != is || j != js);\n    return res;\n}\n\nPolygon convex_cut(const Polygon &p, const Line l)\n{\n    Polygon ret;\n    for (int i = 0; i < p.size(); ++i)\n    {\n        Point now = p[i], nxt = p[(i + 1) % p.size()];\n        if (ccw(l.a, l.b, now) != -1) //交点が線分l上にあるとき\n            ret.push_back(now);\n        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0)\n        {\n            ret.push_back(crosspoint(Line(now, nxt), l));\n        }\n    }\n    return (ret);\n}\nusing ld= long double;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(5);\n    \n    int n; cin >> n;\n    ld xx=0,yy=0;\n    Polygon p(n);\n    REP(i,n) {\n        ld x, y; cin >> x >> y;\n        p[i] = Point(x, y);\n        xx+=x, yy+=y;\n    }\n    Point pp(xx/n, yy/n);\n    if(n%2 == 0){\n        \n\n        if(area2(convex_cut(p, Line(pp, p[0])))*0.5 == area2(convex_cut(p, Line(pp, p[1])))*0.5){\n            cout << real(pp) << \" \" << imag(pp) << endl;\n        }else{\n            cout << \"NA\" << endl;\n        }\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-15\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[51], y[51];\ndouble ax = 0.0, ay = 0.0;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t}\n\trep(i,n){\n\t\tint j = i+n/2;\n\t\tif(j >= n) j -= n;\n\t\tif(fabs(x[i])+EPS < fabs(x[j]) || fabs(x[i]) > fabs(x[j])+EPS){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(fabs(y[i])+EPS < fabs(y[j]) || fabs(y[i]) > fabs(y[j])+EPS){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<P> vec;\nint n;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n    if(n % 2){\n        printf(\"NA\\n\");\n        return 0;\n    }\n\trep(i,n){\n        int x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n        vec.push_back(P(x,y));\n\t}\n    P cent = P(vec[0].first + vec[n/2].first,vec[0].second + vec[n/2].second);\n    bool flag = false;\n    for(int i = 1;i < n/2; i++){\n        P p = P(vec[i].first + vec[n/2 + i].first,vec[i].second + vec[n/2 + i].second);\n        if(cent != p){\n            flag = true;\n            break;\n        }\n    }\n    if(flag){\n        printf(\"NA\\n\");\n    }else{\n        printf(\"%.5f %.5f\\n\",cent.first / 2.0,cent.second / 2.0);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  int x,y;\n};\n  \nint n;\npoint p[50];\n\nvoid solve(){\n  bool flg=true;\n  int X=0,Y=0;\n  if(n%2)flg=false;\n  for(int i=0;i<n&&flg;i++){\n    int j=(i+1)%n;\n    int i2=(i+n/2)%n;\n    int j2=(j+n/2)%n;\n    point v=(point){p[i].x-p[j].x,p[i].y-p[j].y};\n    point w=(point){p[i2].x-p[j2].x,p[i2].y-p[j2].y};\n    if(v.x*w.y-v.y*w.x)flg=false;\n    X+=p[i].x;\n    Y+=p[i].y;\n  }\n  if(flg){\n    printf(\"%.8f %.8f\\n\",(double)X/n,(double)Y/n);\n  }else{\n    cout<<\"NA\"<<endl;\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n  solve();\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n \nclass Point {\npublic:\n    Point();\n    Point(int x_in, int y_in);\n \n    Point  operator+(const Point& obj);\n    Point  operator-(const Point& obj);\n    Point  operator*(const double n);\n    Point  operator/(const double n);\n \n    void set(int x_in, int y_in);\n \n    double x;\n    double y;\n};\n \nPoint::Point() {\n    x = 0;\n    y = 0;\n}\n \nPoint::Point(int x_in, int y_in) {\n    x = x_in;\n    y = y_in;\n}\n \nPoint Point::operator+(const Point& obj) {\n    Point temp;\n    temp.x = x + obj.x;\n    temp.y = y + obj.y;\n    return temp;\n}\n \nPoint Point::operator-(const Point& obj) {\n    Point temp;\n    temp.x = x - obj.x;\n    temp.y = y - obj.y;\n    return temp;\n}\n \nPoint Point::operator*(const double n) {\n    Point temp;\n    temp.x = x * n;\n    temp.y = y * n;\n    return temp;\n}\n \nPoint Point::operator/(const double n) {\n    Point temp;\n    temp.x = x / n;\n    temp.y = y / n;\n    return temp;\n}\n \nvoid Point::set(int x_in, int y_in) {\n    x = x_in;\n    y = y_in;\n}\n \ndouble abs(Point point) {\n    return sqrt(point.x * point.x + point.y * point.y);\n}\n \nint N;\nPoint V[50];\n \nstd::string solve() {\n    if (N % 2 != 0) return \"NA\";\n    Point center = (V[0] + V[N / 2]) / 2;\n    for (int i = 1; i < N / 2; i++) {\n        Point median = (V[i] + V[i + N / 2]) / 2;\n        Point dist = center - median;\n        if (abs(dist) >= 1e-8) {\n            return \"NA\";\n        }\n    }\n    std::ostringstream str;\n    str << center.x << \" \" << center.y;\n    return str.str();\n}\n \nint main() {\n    //入力\n    std::cin >> N;\n    int x, y;\n    for (int i = 0; i < N; i++) {\n        std::cin >> x >> y;\n        V[i].set(x, y);\n    }\n    //演算\n    std::string answer = solve();\n    //出力\n    std::cout << answer << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  avgx/=N;avgy/=N;\n  for(int i=0;i<N;i++){\n    double d1=abs(ps[(i+1)%N]-ps[i]);\n    double d2=abs(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n    // P p1=(ps[(i+1)%N]-ps[i]);\n    // P p2=(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n    //cout<<d1<<\" \"<<d2<<endl;\n    //cout<<p1<<\" \"<<p2<<endl;\n    //if(!EQV(p1,p2)){\n    if(!EQ(d1,d2)){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  P avgp=P(avgx,avgy);\n  printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  // for(int i=0;i<N;i++)ps[i]-=avgp;\n  // for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  // bool ok=false;\n  // for(int i=0;i<N;i++){\n  //   for(int j=0;j<N;j++){\n  //     if(EQV(ps[i],ps2[j])){\n  // \tfor(int k=0;k<N;k++){\n  // \t  int a=(k+j)%N;\n  // \t  int b=(k+i)%N;\n  // \t  if(!EQV(ps[a],ps2[b])){\n  // \t    cout<<\"NA\"<<endl;\n  // \t    return 0;\n  // \t  }\n  // \t}\n  // \tok=true;\n  // \tbreak;\n  //     }\n  //   }\n  //   if(ok)break;\n  // }\n  // if(ok)printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  // else cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <set>\n#include <tuple>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n    int n, x[55], y[55];\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        x[i] *= 2;  y[i] *= 2;\n    }\n    \n    vector<pair<pair<int, int>, pair<int, int>>> center;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            center.emplace_back(make_pair((x[i] + x[j]) / 2, (y[i] + y[j]) / 2), make_pair(i, j));\n        }\n    }\n    sort(center.begin(), center.end());\n    \n    //for (int idx = 0; idx < center.size(); idx++) cout << center[idx].first.first << \" \" << center[idx].first.second << \" \"<<center[idx].second.first << \" \" << center[idx].second.second << endl;\n    \n    int idx = 0;\n    while (idx != center.size()) {\n        bool ok[55] = {};\n        int cx = center[idx].first.first, cy = center[idx].first.second, sub = 0;\n        while (cx == center[idx + sub].first.first && cy == center[idx + sub].first.second) {\n            ok[center[idx + sub].second.first] = true;\n            ok[center[idx + sub].second.second] = true;\n            sub++;\n        }\n        idx += sub;\n        bool ans = true;\n        //for (int i = 0; i < n; i++) cout << ok[i] << \" \";\n        //cout << endl;\n        for (int i = 0; i < n; i++) {\n            if (!ok[i]) ans = false;\n        }\n        if (ans){\n            cout << setprecision(10) << float(cx) / 2.0 << \" \" << float(cy) / 2.0 << endl;\n            return 0;\n        }\n    }\n    cout << \"NA\" << endl;\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nVector Cross_Point(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tVector base = p4 - p3;\n\n\tVector v1 = p1 - p3;\n\tVector v2 = p2 - p3;\n\n\tlong double d1 = fabsl(cross(base, v1));\n\tlong double d2 = fabsl(cross(base, v2));\n\n\tlong double t = d1 / (d1 + d2);\n\n\treturn p1 + ((p2 - p1) * t);\n}\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X, Y;\n\n\tvector<Vector> Plane;\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X >> Y;\n\n\t\tPlane.push_back(Vector(X, Y));\n\t}\n\n\tif (N % 2 == 1)\n\t{\n\t\tcout << \"NA\" << endl;\n\t}\n\telse\n\t{\n\t\tVector C;\n\n\t\tfor (int i = 0; i < N / 2; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N / 2; j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint l1 = i;\n\t\t\t\t\tint r1 = i + N / 2;\n\t\t\t\t\tint l2 = j;\n\t\t\t\t\tint r2 = j + N / 2;\n\n\t\t\t\t\tC = Cross_Point(Plane[l1], Plane[r1], Plane[l2], Plane[r2]);\n\n\t\t\t\t\tif ((Plane[l1] + Plane[r1]) / 2 != C)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"NA\" << endl;\n\n\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9f %.9f\\n\", C.x, C.y);\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn abs(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nVector Cross_Point(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tVector base = p4 - p3;\n\n\tVector v1 = p1 - p3;\n\tVector v2 = p2 - p3;\n\n\tlong double d1 = fabsl(cross(base, v1));\n\tlong double d2 = fabsl(cross(base, v2));\n\n\tlong double t = d1 / (d1 + d2);\n\n\treturn p1 + ((p2 - p1) * t);\n}\n\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X, Y;\n\n\tvector<Vector> Plane;\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X >> Y;\n\n\t\tPlane.push_back(Vector(X, Y));\n\t}\n\n\tif (N % 2 == 1)\n\t{\n\t\tcout << \"NA\" << endl;\n\t}\n\telse\n\t{\n\t\tVector C;\n\n\t\tfor (int i = 0; i < N / 2; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N / 2; j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint l1 = i;\n\t\t\t\t\tint r1 = i + N / 2;\n\t\t\t\t\tint l2 = j;\n\t\t\t\t\tint r2 = j + N / 2;\n\n\t\t\t\t\tC = Cross_Point(Plane[l1], Plane[r1], Plane[l2], Plane[r2]);\n\n\t\t\t\t\tif ((Plane[l1] + Plane[r1]) / 2 != C)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"NA\" << endl;\n\n\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9f %.9f\\n\", C.x, C.y);\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\n#include <complex>\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\n\n#define X real()\n#define Y imag()\n\nconst D EPS = 1e-9;\nconst D INF = 1e12;\n\n#define EQ(n,m) (abs((n) - (m)) < EPS)\n#define EX P(INF,INF)\n\nD cs(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\n\nD dt(P a, P b) {\n\treturn (conj(a) * b).X;\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a, c -= a;\n\tif (cs(b, c) > EPS)return 1;\n\tif (cs(b, c) < -EPS)return -1;\n\tif (dt(b, c) < -EPS)return +2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nP cpLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cs(b2 - b1, b1 - a1);\n\tD d2 = cs(b2 - b1, a2 - a1);\n\tif (EQ(d2, 0))return EX;\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\nbool isor(P a1, P a2, P b1, P b2) {\n\treturn EQ(dt(a1 - a2, b1 - b2), 0.0);\n}\nbool ispa(P a1, P a2, P b1, P b2) {\n\treturn EQ(cs(a1 - a2, b1 - b2), 0.0);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tVP v;\n\tD tx = 0.0, ty = 0.0;\n\trep(i, n) {\n\t\tD x, y;\n\t\tcin >> x >> y;\n\t\tv.push_back(P(x, y));\n\t\ttx += x; ty += y;\n\t}\n\ttx /= double(n), ty /= double(n);\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\tint h = n / 2;\n\trep(i, h) {\n\t\tL l0 = L(v[i], v[i + 1]);\n\t\tL l1 = L(v[(i + h) % n], v[(i + h + 1) % n]);\n\t\t\n\t\tdouble dist0 = abs(l0.first - l0.second);\n\t\tdouble dist1 = abs(l1.first - l1.second);\n\n\t\tif (!EQ(dist0, dist1) ||\n\t\t\t!ispa(l0.first, l0.second, l1.first, l1.second)) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << fixed << setprecision(30) << tx << \" \" << ty << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-10)<b&&b<a+(1e-10);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else cout<<a.f<<\" \"<<a.s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <math.h>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t}\n\tcx = (p[0][0] + p[n/2][0]) /2;\n\tcy = (p[0][1] + p[n/2][1]) /2;\n\tif(n%2) f=1;\n\telse for(i = 1; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) /2 - cx) <= 0.0001 && fabs((p[i][1] + p[i + n/2][1]) /2 - cy) <= 0.0001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse cout << cx << \" \" << cy << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint main(){\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tvector<double> X(N), Y(N);\n\tint Xsum = 0, Ysum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lf%lf\", &X[i], &Y[i]);\n\t\tXsum += X[i];\n\t\tYsum += Y[i];\n\t\tX[i] *= N;\n\t\tY[i] *= N;\n\t}\n\tif(N % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tfor(i = 0; i < N / 2; i++){\n\t\tif((X[i] + X[i + N / 2]) != 2 * Xsum || (Y[i] + Y[i + N / 2]) != 2 * Ysum){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.10lf %.10lf\\n\", (double)Xsum / N, (double)Ysum / N);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P, P> L;\n\nconst long double INF = 1e+9;\nconst long double EPS = 1e-5;\n\nbool equal(long double a, long double b){ return fabs(a-b) < EPS;}\nlong double dot(P a, P b){ return real(conj(a)*b); }\nlong double cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nP crossPoint(L l, L m){\n  long double A = cross(l.second - l.first, m.second - m.first);\n  long double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\nlong double area(vector<P> v){\n  long double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\nbool equal(P a, P b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n\nint n;\nvector<P> v;\n\nlong double binary_search(bool is_h){\n  L l;\n  long double le = -INF, ri = INF, mid;\n  vector<P> cut_v;\n\n  while(ri - le > EPS/1000.0){\n    mid = (ri + le) / 2.0;\n    if(is_h) l = L(P(-INF, mid), P(INF, mid));\n    else l = L(P(mid, INF), P(mid, -INF));\n    cut_v = convex_cut(v, l);\n    if(area(v) > area(cut_v) * 2.0) ri = mid;\n    else le = mid;\n  }\n\n  return (ri + le) / 2.0;\n}\n\nP solve(){\n  P res = P(binary_search(false), binary_search(true));\n  bool f = true;\n\n  if(n % 2 == 1) f = false;\n  else {\n    for(int i=0;i<n/2;i++){\n      if(!equal(v[i] - res, res - v[i+n/2])){\n        f = false;\n        break;\n      }\n    }\n  }\n\n  if(f) return res;\n  else return P(INF, INF);\n}\n\nint main(){\n  long double x, y;\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      v.push_back(P(x, y));\n    }\n    P res = solve();\n    if(equal(res, P(INF, INF))) cout << \"NA\" << endl;\n    else printf(\"%.6Lf %.6Lf\\n\",res.real(),res.imag());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nstruct Point {\n    Point(ll x, ll y)\n    {\n        if (x < 0) {\n            dx = -x;\n            dy = -y;\n        } else if (x == 0 and y < 0) {\n            dx = -x;\n            dy = -y;\n        }\n    }\n\n    bool operator<(const Point& p) const\n    {\n        return (dx != p.dx) ? dx < p.dx : dy < p.dy;\n    }\n    bool operator==(const Point& p) const\n    {\n        return dx == p.dx and dy == p.dy;\n    }\n\n    ll dx;\n    ll dy;\n};\n\nint main()\n{\n    int N;\n    cin >> N;\n    ll xsum = 0;\n    ll ysum = 0;\n    vector<ll> x(N);\n    vector<ll> y(N);\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n        xsum += x[i];\n        ysum += y[i];\n    }\n    vector<Point> p;\n    for (int i = 0; i < N; i++) {\n        p.push_back(Point(xsum - N * x[i], ysum - N * y[i]));\n    }\n    sort(p.begin(), p.end());\n    p.erase(unique(p.begin(), p.end()), p.end());\n    if (N % 2 == 0 and p.size() == N / 2) {\n        cout << fixed << setprecision(10) << (long double)(xsum) / N << \" \" << (long double)(ysum) / N << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,long double> C;\n\nconst long double PI = acos(-1);\n\nlong double rabs(long double a,long double b){\n  return abs(a-b)/(a*b);\n}\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nlong double dot(P x,P y){return real(conj(x)*y);}\n\nlong double cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,long double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\nlong double arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nlong double arg(long double a,long double b,long double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nP line_cp(L a,L b){\n  long double A = cross(b.sc-b.fs,b.fs-a.fs);\n  long double B = cross(b.sc-b.fs,a.sc-a.fs);\n  if(abs(A) < EPS){\n    if(abs(B) < EPS)return a.fs; //same line\n    //else assert(false);\n  }\n  return a.fs+(a.sc-a.fs)*A/B;\n}\n\n//for polygon\n\n//all vertex is already sorted.\nlong double area(Poly p){\n  if(p.size()<3)return 0;\n  long double res = cross(p[p.size()-1],p[0]);\n  for(int i=1;i<p.size();i++)res += cross(p[i-1],p[i]);\n  return res/2;\n}\n\n//all vertex is already sorted.\nPoly convex_cut(Poly p,L l){\n  Poly res;\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    int nxt = (i+1)%n;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  Poly p;\n\n  scanf(\"%d\",&n);\n  p.resize(n);\n  for(int i=0;i<n;i++)scanf(\"%Lf%Lf\",&p[i].real(),&p[i].imag());\n  long double s = area(p)/2;\n\n  P a[2];\n  long double lx = p[0].real(), ux = p[0].real(), ly = p[0].imag();\n  for(int i=1;i<n;i++){\n    lx = min(lx,p[i].real());\n    ux = max(ux,p[i].real());\n    ly = min(ly,p[i].imag());\n  }\n  a[0] = P(lx,ly-1e6); a[1] = P(ux,ly-1e6);\n\n  L line[2];\n  for(int i=0;i<2;i++){\n    long double l = 0,r = PI,mid;\n    P u = P(1,0);\n\n    for(int j=0;j<1000;j++){\n      mid = (l+r)/2;\n      L tmp = L(a[i],a[i]+rotate(u,mid));\n      long double cut = area(convex_cut(p,tmp));\n      if(cut + EPS < s)r = mid;\n      else l = mid;\n    }\n    line[i] = L(a[i],a[i]+rotate(u,l));\n  }\n  \n  P res = line_cp(line[0],line[1]);\n  \n  for(int i=0;i<n;i++){\n    L tmp = L(res,p[i]);\n    Poly hoge = convex_cut(p,tmp);\n    //printf(\"%.20Lf\\n\",area(convex_cut(p,tmp)));\n    if(rabs(s, area(convex_cut(p,tmp))) > EPS){\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.8Lf %.8Lf\\n\",res.real(),res.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; x = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; y = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  x = y = 0.0;\n  for(int i = 0; i < N; ++i) {\n    x += ps[i].real();\n    y += ps[i].imag();\n  }\n  x /= N;\n  y /= N;\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 100000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-4)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint x[51];\nint y[51];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tif(a%2){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t}\n\tx[a]=x[0];\n\ty[a]=y[0];\n\tbool ok=true;\n\tfor(int i=0;i<a/2;i++){\n\t\tint ax=x[i+1]-x[i];\n\t\tint ay=y[i+1]-y[i];\n\t\tint bx=x[i+a/2+1]-x[i+a/2];\n\t\tint by=y[i+a/2+1]-y[i+a/2];\n\t\tif(ax+bx||ay+by)ok=false;\n\t}\n\tif(!ok)printf(\"NA\\n\");\n\telse{\n\t\tdouble X=0;\n\t\tdouble Y=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tX+=x[i];\n\t\t\tY+=y[i];\n\t\t}\n\t\tprintf(\"%f %f\\n\",X/a,Y/a);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\ntypedef complex<double> P;\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    int j = (i + N / 2) % N;\n    ok &= !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N]));\n  }\n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                  友利奈緒ぱわーでACしてくれ！！！！！！！！！！！！\n                  Charlotteまだ見てない人は見ような！！！！！！！\n\n                  ／　 /:／　　　　　　　　　　　 　 ＼:ヽ　＼\n  　　　　　　　 /　　／　　　　　　 　 　 　 　 　 　 　 ＼　　ヽ\n  　　　　　＼__L 彡　　　　　　　　　　　　　　　　　　　 ヽ　　',\n  　　　　　　　ﾌ /　　　/　　/　 /　　　,　　 　 　 　 ヽ　　', 　ｊ\n  　　　　　　　ﾚ　　　 /　　/ 　/　 　 　 　 　 　 　 　 ', 　ヽ　j\n  　　　 　 　 // 　 　 !　/_l＿/__ノ 　　{ ＼}　　　　 　 ',　　',/\n  　　　　　　i ﾊ 　 　 {　从j　ﾊ　i　　　 ',　 ト-､}　 i i　 }　　jj\n  　　　　　　( ﾊ　　　(　 川　ハ ﾊ　 !　 '　ﾊ　 ﾊ　j j　,' 　 八\n  　　　 ＜＿,ｨ∧　　　斗芹ﾃミxハ ﾊ　 ﾚ　} /__ﾚﾚ　/ 　 ∧ ＼　ﾉ\n  　　　 　 　 ∨　＼ 　ゝ　辷:ソ　　 　)　芹ﾚ心ヾレ′　/ ト--　´\n  　　　＼ｰ‐'　ﾉ　　 ＼ゝ　　　　　　 　 　 ゞ:_ソ \"/ 　／ 　ヽ\n  　　　　 　 フ　　　　i八 \" \"　　　,　　　　　　　ム彡　　　　＼\n  　　　　 　/　　/　　j　 ト　　　　　　 　 　 \" \"イト＜　 　 　 ＼＼\n  　　　　 /　　/　　　j　/／ヽ､ 　 ∩　　 　 イ　{ {　　￣ フフへ ＼＼\n  　　　　(　／　　　 ,/ / 　　i　＞――＜ニニニﾆ┐　 〃／: : ヽ　ヽヽ\n  　　　　／　　ィT´/ /┌―　￣￣ /::: , ,)　 　 　 〃／／: : : : : :}　ヽヽ)\n  　　　/ /　 ∧ヾi┌― { {￣　　　 ﾉ:::トﾟ<　 　 　 ∥//: : : : : : : : i　 ﾉ ﾉ\n  . 　　( 人　 {:ヽヾi∨　∧V　　　 /:::/　､ヽ　　　 ∥/: : : : : : : : : :}　/\n  　　　V　( ∧: :＼'∨　∧V　　 ﾉ:::/　 ∧ 〉＿__∥: : : : : :／: : : :ﾚ\n  　　 　 　 /∧: : : : ∨　∧V┬ｲ:::ﾉ　 〈 TT　|　|{{: : : : ／: : : : : ∧　　 ﾉ\n  　　　 　 (　ハ: : : : :∨'T∧Vi　i (　 　 V　!　!　{{: : ／ : : : : : : /　ｰ　ノ\n  　　　　　V　ハ: : : : :∨ﾍ∧V　i ゝゝ　 i／⌒＼{／ : : : : : : : /ｰ― ´\n  　　　　　 ∨　ヽ: : : : :∨ﾍ∧∨i　〉 〉 /　/二　 ): : : : : : : : :/\n\n          (https://seesaawiki.jp/asciiart/d/Charlotte より)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n// #define int ll\n// #define DEBUG 42\ninline void nprint(){}\ntemplate <class Head, class... Tail>\ninline void nprint(Head &&head, Tail &&... tail) {\n    cout << head << endl;\n    nprint(move(tail)...);\n}\n#ifdef DEBUG\n  #define eprint(...) nprint(__VA_ARGS__)\n#else\n  #define eprint(...) if(0==1) cout << 1 << endl;\n#endif\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << endl\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << endl\n#define POSSIBLE(a) cout << (a ? \"POSSIBLE\" : \"IMPOSSIBLE\") << endl\nusing cmp = complex<double>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORS(i,a,b) FOR(i,a,b+1)\n#define REPS(i,n) REP(i,n+1)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPS(i,n) RREP(i,n+1)\n#define RFORS(i,a,b) RFOR(i,a,b+1)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define PERM(c) sort(ALL(c)); for(bool cp = true;cp;cp = next_permutation(ALL(c)))\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconstexpr ll MOD = 1E9+7;\nconstexpr int dx[] = {1,0,-1,0}; constexpr int dy[] = {0,1,0,-1};\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p){\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\n\ndouble add(double l, double r){\n\tif(abs(l+r)<EPS*(abs(l)+abs(r))) return 0;\n\treturn l+r;\n}\nstruct pt{\n\tdouble x, y;\n\tpt(double xx=0, double yy=0){x=xx; y=yy;}\n\t// pt(pt z):x(z.x),y(z.y){}\n\tpt& operator+=(const pt &rhs){\n\t\tx = add(x,rhs.x); y = add(y,rhs.y); return *this;\n\t}\n\tpt& operator-=(const pt &rhs){\n\t\tx = add(x,-rhs.x); y = add(y,-rhs.y); return *this;\n\t}\n\tpt& operator*=(const double &rhs){\n\t\tx *= rhs; y *= rhs; return *this;\n\t}\n\tpt& operator/=(const double &rhs){\n\t\tx /= rhs; y /= rhs; return *this;\n\t}\n\tpt operator+(const pt &that) const { return pt(*this) += that; }\n  pt operator-(const pt &that) const { return pt(*this) -= that; }\n  pt operator*(const double &that) const { return pt(*this) *= that; }\n  pt operator/(const double &that) const { return pt(*this) /= that; }\n\tpt operator+(){return *this;}\n\tpt operator-(){y=-y; return *this;}\n\n\n\tbool operator==(const pt &rhs){\n\t\treturn add(x,-rhs.x)==0 && add(y,-rhs.y)==0;\n\t}\n\tbool operator!=(const pt &rhs){return !(*this==rhs);}\n\tbool operator<(const pt &rhs){\n\t\treturn add(x,-rhs.x)!=0 ? x<rhs.x : add(y,-rhs.y)<0;\n\t}\n\tbool operator>(const pt &rhs){return add(x,-rhs.x)!=0 ? x>rhs.x : add(y,-rhs.y)>0;}\n\tbool operator<=(const pt &rhs){return !(*this>rhs);}\n\tbool operator>=(const pt &rhs){return !(*this<rhs);}\n\tfriend istream& operator>>(istream& is, pt& z)noexcept{\n\t\treturn is >> z.x >> z.y;\n\t}\n\tfriend ostream& operator<<(ostream &os, pt &p) { return os << p.x << \" \" << p.y; }\n\tdouble norm(){return add(x*x,y*y);}\n\tdouble abs(){return sqrt(this->norm());}\n};\ndouble dot(pt a, pt b){return add(a.x*b.x,a.y*b.y);}\ndouble cross(pt a, pt b){return add(a.x*b.y,-a.y*b.x);}\n\nstruct line{\n\tpt a, b;\n\tline(pt a=pt(0,0), pt b=pt(0,0)):a(a),b(b){}\n};\npt crosspoint(const line &l, const line &m){\n\tdouble A = cross(l.b - l.a, m.b - m.a);\n\tdouble B = cross(l.b - l.a, l.b - m.a);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n\treturn m.a + (m.b - m.a) * B / A;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\tint n;\n\tcin >> n;\n\tV<pt> ps(n);\n\tcin >> ps;\n\tif(n&1){\n\t\tnprint(\"NA\");\n\t\treturn 0;\n\t}\n\tpt ans = (ps[0]+ps[n/2])/2;\n\tbool ok = true;\n\tREP(i,n/2){\n\t\tok &= (ps[i]-ans + ps[i+(n/2)]-ans)==pt(0,0);\n\t}\n\tif(!ok) nprint(\"NA\");\n\telse cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!(abs(a[i]+abs(a[(i+n/2)%n]))/2-c)<=0.0001||!(abs(b[i]+abs(b[(i+n/2)%n]))/2-c)<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint X[60], Y[60];\nint main() {\n    int N; scanf(\"%d\", &N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n    }\n\n    if(N % 2) {\n        printf(\"NA\\n\");\n    }\n    else {\n        int px = X[0] + X[N/2], py = Y[0] + Y[N/2];\n        bool ok = true;\n        for(int i=0; i<N; i++) {\n            int tx = X[i] + X[(i+N/2)%N];\n            int ty = Y[i] + Y[(i+N/2)%N];\n            ok &= (px == tx && py == ty);\n        }\n        if(!ok) printf(\"NA\\n\");\n        else {\n            double ans_x = px / 2.0, ans_y = py / 2.0;\n            printf(\"%.12f %.12f\\n\", ans_x, ans_y);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\n\nstruct L : public vector<P>{\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nbool intersectLL(L l,L m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps||abs(cross(l[1]-l[0],m[0]-l[0]))<eps;\n}\n\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nint n;\nP ps[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  rep(i,n){\n    D x,y;\n    cin>>x>>y;\n    ps[i]=P(x,y);\n  }\n  if(n%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  rep(i,n/2){\n    if(abs(norm(ps[i]-ps[i+1])-norm(ps[(i+n/2)%n]-ps[(i+n/2+1)%n]))>eps){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n    if(intersectLL(L(ps[i],ps[i+1]),L(ps[(i+n/2)%n],ps[(i+n/2+1)%n]))){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  P res=crosspoint(L(ps[0],ps[n/2]),L(ps[1],ps[n/2+1]));\n  printf(\"%.10Lf %.10Lf\\n\", res.X,res.Y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\nusing namespace std;\n#define EPS 1e-10\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n};\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nint n;\nint x[51],y[51];\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tif(n%2==1){\n\t\tprintf(\"NA\\n\");\n\t}else{\n\t\tP p=P((x[0]+x[n/2])/2.0,(y[0]+y[n/2])/2.0);\n\t\tbool flag=true;\n\t\tfor(int i=1;i<n/2;i++){\n\t\t\tP p2=P((x[i]+x[i+n/2])/2.0,(y[i]+y[i+n/2])/2.0);\n\t\t\tif(add(p.x,-p2.x)!=0.0 || add(p.y,-p2.y)!=0.0)flag=false;\n\t\t}\n\t\tif(flag)printf(\"%.9f %.9f\\n\",p.x,p.y);\n\t\telse printf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  avgx/=N;avgy/=N;\n  P avgp=P(avgx,avgy);\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  bool ok=false;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(EQV(ps[i],ps2[j])){\n\tfor(int k=0;k<N;k++){\n\t  int a=(k+j)%N;\n\t  int b=(k+i)%N;\n\t  if(!EQV(ps[a],ps2[b])){\n\t    cout<<\"NA\"<<endl;\n\t    return 0;\n\t  }\n\t}\n\tok=true;\n\tbreak;\n      }\n    }\n    if(ok)break;\n  }\n  if(ok)\n    printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  else\n    cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\ndouble x[100];\ndouble y[100];\ndouble gx, gy;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tif (N % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\trep(i, N) {\n\t\tcin >> x[i] >> y[i];\n\t\tgx += x[i];\n\t\tgy += y[i];\n\t}\n\tgx = gx / N;\n\tgy = gy / N;\n\trep(i, N) {\n\t\tx[i] -= gx;\n\t\ty[i] -= gy;\n\t}\n\trep(i, N/2) {\n\t\tif (x[i] != -x[i+N/2] || y[i] != -y[i+N/2]) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << fixed << setprecision(12) << gx << \" \" << gy << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n \ntypedef complex<double> P;\ntypedef vector<P> polygon;\n \ndouble const eps = 1e-7;\n \npolygon poly;\n \nstruct line : public vector<P> {\n  line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n \ndouble dot(P a, P b) {\n  return real(conj(a) * b);\n}\n \ndouble cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n \nint ccw(P const& p, P a, P b) {\n  a -= p, b -= p;\n  if(cross(a, b) > eps) return +1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n \nP crosspoint(line const& a, line const& b) {\n  auto va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < eps) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n \npolygon convex_cut(polygon const& g, line const& l) {\n  polygon ret;\n  int n = g.size();\n  rep(i, n) {\n    auto curr = g[i % n], next = g[(i + 1) % n];\n    if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n    if(ccw(l[0], l[1], curr) * ccw(l[0], l[1], next) < 0) {\n      ret.push_back(crosspoint(line(curr, next), l));\n    }\n  }\n  return ret;\n}\n \ndouble area(polygon const& g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i + 1) % g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n \nbool ok(P const& p) {\n  double ph = area(poly) / 2.0;\n  for(double rad = 0.0; rad < 2 * cos(-1); rad += 0.01) {\n    line l = line(p, p + polar(1.0, rad));\n    auto k = convex_cut(poly, l);\n    if(abs((area(k) - ph) / ph) > eps) return false;\n  }\n  return true;\n}\n \nint main() {\n  int N; cin >> N;\n  P g;\n  rep(i, N) {\n    double x, y; cin >> x >> y;\n    poly.push_back(P(x, y));\n    g += P(x, y);\n  }\n  g /= N;\n  if(N % 2 || !ok(g)) cout << \"NA\" << endl;\n  else printf(\"%.10f %.10f\\n\", g.real(), g.imag());"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n\nint main(void){\n    int n;\n    cin>>n;\n    if(n%2){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    \n    vector<pii> v(n);\n    double xtotal=0,ytotal=0;\n    rep(i,n){\n        cin>>v[i].fs>>v[i].sc;\n        xtotal+=v[i].fs;\n        ytotal+=v[i].sc;\n    }\n    rep(i,n/2){\n        int a=i,b=i+1,c=i+n/2,d=(i+n/2+1)%n;\n        \n        if(hypot(v[a].fs-v[b].fs, v[a].sc-v[b].sc ) != hypot(v[c].fs-v[d].fs, v[c].sc-v[d].sc) || hypot(v[a].fs-v[d].fs, v[a].sc-v[d].sc ) != hypot(v[b].fs-v[c].fs, v[b].sc-v[c].sc )){\n            cout<<\"NA\"<<endl;\n            return 0;\n        }\n    }\n    cout<<fixed<<setprecision(5)<<xtotal/n<<\" \"<<ytotal/n<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <complex>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\ntypedef complex<double> P;\n#define EPS (1e-9)\n\ninline double dot(const P& a, const P& b) { return real(conj(a)*b); }\ninline double cross(const P& a, const P& b) { return imag(conj(a)*b); }\nP crosspoint(const P& l0, const P& l1, const P& m0, const P& m1) {\n    const double A = cross(l1-l0, m1-m0);\n    const double B = cross(l1-l0, l1-m0);\n    if (abs(A) < EPS && abs(B) < EPS) return m0;\n    return m0 + B/A*(m1-m0);\n}\n\nbool ok(const vector<P>& ps) {\n    const int m = ps.size();\n    if (m%2) return false;\n    rep (i, m/2) {\n        if (fabs(cross(ps[i+1]-ps[i], ps[(m/2+i+1)%m]-ps[m/2+i])) > EPS) {\n            return false;\n        }\n    }\n    const P cp = crosspoint(ps[0], ps[m/2], ps[1], ps[m/2+1]);\n    rep (i, m/2) if (i) {\n        const P p = crosspoint(ps[0], ps[m/2], ps[i], ps[m/2+i]);\n        if (abs(p-cp) > EPS) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    vector<P> ps;\n    rep (i, n) {\n        double x, y;\n        scanf(\"%lf%lf\", &x, &y);\n        ps.push_back(P(x, y));\n    }\n    if (ok(ps)) {\n        const int m = ps.size();\n        const P cp = crosspoint(ps[0], ps[m/2], ps[1], ps[m/2+1]);\n        printf(\"%.12f %.12f\\n\", cp.real(), cp.imag());\n    }\n    else {\n        puts(\"NA\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\n\n\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tREP(i, v.size()) { if (i)os << \" \"; os << v[i]; }return os;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) {\n\tREP(i, v.size()) { if (i)os << endl; os << v[i]; }return os;\n}\n\n//誤差修正用\nconst double EPS = 1e-1;\n\n//円周率\nconst double PI = acos(-1);\n\n//double型の値が等しいか\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//点に関する構造体\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() {}\n\n\tPoint(double x, double y) : x(x), y(y) {}\n\n\t//加減、スカラー倍、乗算など\n\tPoint operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n\tPoint operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n\tPoint operator*(const double b) const { return Point(x * b, y * b); }\n\n\tPoint operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n\tPoint operator/(const double b) const { return Point(x / b, y / b); }\n\n\tbool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n\tbool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n\t//大きさの二乗\n\tdouble norm() { return x * x + y * y; }\n\n\t//逆正接（x軸正方向からの反時計回り回転角）\n\tdouble arg() { return atan2(x, y); }\n\n\t//大きさ\n\tdouble abs() { return sqrt(norm()); }\n\n\t//反時計回りにθ回転\n\tPoint rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n\t//反時計回りにπ/2回転\n\tPoint rotate90() { return Point(-y, x); }\n\n\tfriend ostream &operator<<(ostream &os, Point &p) { return os << p.x << \" \" << p.y; }\n\n\tfriend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n};\n\n//外積\ndouble cross(const Point &a, const Point &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n//内積\ndouble dot(const Point &a, const Point &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//直線に関する構造体\n//直線が通る2点で表す\nstruct Line\n{\n\tPoint a, b;\n\n\tLine() {};\n\n\tLine(Point a, Point b) : a(a), b(b) {};\n\n\tvoid set(Point a, Point b) {\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n\tfriend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n};\n\n//多角形\ntypedef vector< Point > Polygon;\n\n//3点の位置関係を判定\nint ccw(const Point &a, Point b, Point c)\n{\n\tb = b - a, c = c - a;\n\n\t//a→bで反時計回りの方向にc\n\tif (cross(b, c) > EPS) return +1;\n\n\t//a→bで時計回りの方向にc\n\tif (cross(b, c) < -EPS) return -1;\n\n\t//c→a→bで一直線\n\tif (dot(b, c) < 0) return +2;\n\n\t//a→b→cで一直線\n\tif (b.norm() < c.norm()) return -2;\n\n\t//a→c→bで一直線\n\treturn 0;\n}\n\n//2直線の平行判定\nbool IsParallel(const Line& a, const Line& b) {\n\treturn abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\n//点集合（多角形）の凸包を求める\n//Andrew's Monotone Chain\n//O(NlogN)（ソート依存）\nPolygon Convex_Hull(Polygon& p) {\n\tint n = p.size(), k = 0;\n\tif (n >= 3) {\n\t\tsort(p.begin(), p.end());\n\t\tvector< Point > ch(2 * n);\n\t\tfor (int i = 0; i < n; ch[k++] = p[i++]) {\n\t\t\tREP(i, ch.size()) {\n\t\t\t\t//cout << ch[i] << endl;\n\t\t\t}\n\t\t\t//cout << k << endl << i << endl << endl;\n\t\t\twhile (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n\t\t\twhile (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tch.resize(k - 1);\n\t\treturn ch;\n\t}\n\telse {\n\t\treturn p;\n\t}\n}\n\n//2直線の交差判定\nbool Intersect(const Line &l, const Line &m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\n//2直線の交点\nPoint Crosspoint(const Line &l, const Line &m)\n{\n\tdouble A = cross(l.b - l.a, m.b - m.a);\n\tdouble B = cross(l.b - l.a, l.b - m.a);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n\treturn m.a + (m.b - m.a) * B / A;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n//凸多角形の切断\n//直線に対して左側にある部分（交点を含む）を返す\nPolygon ConvexCut(Polygon &U, Line l)\n{\n\tPolygon ret;\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tPoint now = curr(U, i), nxt = next(U, i);\n\t\tif (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n\t\tif (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n\t\t\tret.push_back(Crosspoint(Line(now, nxt), l));\n\t\t}\n\t}\n\treturn (ret);\n}\n\n//多角形の面積\n//ただし返り値は求めたい値の2倍になっている\ndouble Area2(const Polygon &p)\n{\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i) {\n\t\tA += cross(p[i], p[(i + 1) % p.size()]);\n\t}\n\treturn A;\n}\n\n\nint xcomp(pair<ll,ll>& a, pair<ll,ll>& b) {\n\tif (a.first == b.first) {\n\t\treturn a.second<b.second;\n\t}\n\treturn a.first < b.first;\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nll mod = 1000000007;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tPolygon polygon;\n\n\tREP(i, n) {\n\t\tPoint point;\n\t\tcin >> point;\n\n\t\tpolygon.push_back(point);\n\t}\n\n\tdouble Sall = Area2(polygon)/2.0;\n\n\tLine linecut1;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tLine line(polygon[0], polygon[i]);\n\t\t\tdouble Scut = Sall-Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i - 1] + (polygon[i] - polygon[i - 1])*ratio;\n\t\t\t\tlinecut1.set(polygon[0], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tLine linecut2;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = n-2; i >= 0; --i) {\n\t\t\tLine line(polygon[n-1], polygon[i]);\n\t\t\tdouble Scut = Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i + 1] + (polygon[i] - polygon[i + 1])*(1-ratio);\n\t\t\t\tlinecut2.set(polygon[n-1], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tPoint crosspoint = Crosspoint(linecut1, linecut2);\n\n\tbool flag = true;\n\n\tREP(i, 100) {\n\t\trandom_device rnd;     // 非決定的な乱数生成器を生成\n\t\tmt19937 mt(rnd());     //  メルセンヌ・ツイスタの32ビット版、引数は初期シード値\n\t\tuniform_int_distribution<> rand1000000(0, 1000000);        // [0, 99] 範囲の一様乱数\n\n\t\tPoint randompoint(rand1000000(mt), rand1000000(mt));\n\n\t\tLine randomline(crosspoint, randompoint);\n\n\t\tdouble Srandomcut = Area2(ConvexCut(polygon, randomline)) / 2.0;\n\n\t\tif (!eq(Sall, Srandomcut*2.0)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag) {\n\t\tcout << crosspoint << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=a.f,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,long double> C;\n\nconst long double PI = acos(-1);\n\nlong double rabs(long double a,long double b){\n  return abs(a-b)/a;\n}\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nlong double dot(P x,P y){return real(conj(x)*y);}\n\nlong double cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,long double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\nlong double arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\nlong double arg(long double a,long double b,long double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nP line_cp(L a,L b){\n  long double A = cross(b.sc-b.fs,b.fs-a.fs);\n  long double B = cross(b.sc-b.fs,a.sc-a.fs);\n  if(abs(A) < EPS){\n    if(abs(B) < EPS)return a.fs; //same line\n    //else assert(false);\n  }\n  return a.fs+(a.sc-a.fs)*A/B;\n}\n\n//for polygon\n\n//all vertex is already sorted.\nlong double area(Poly p){\n  if(p.size()<3)return 0;\n  long double res = cross(p[p.size()-1],p[0]);\n  for(int i=1;i<p.size();i++)res += cross(p[i-1],p[i]);\n  return res/2;\n}\n\n//all vertex is already sorted.\nPoly convex_cut(Poly p,L l){\n  Poly res;\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    int nxt = (i+1)%n;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  Poly p;\n\n  scanf(\"%d\",&n);\n  p.resize(n);\n  for(int i=0;i<n;i++)scanf(\"%Lf%Lf\",&p[i].real(),&p[i].imag());\n  long double s = area(p)/2;\n\n  P a[2];\n  long double lx = p[0].real(), ux = p[0].real(), ly = p[0].imag();\n  for(int i=1;i<n;i++){\n    lx = min(lx,p[i].real());\n    ux = max(ux,p[i].real());\n    ly = min(ly,p[i].imag());\n  }\n  a[0] = P(lx,ly-1e6); a[1] = P(ux,ly-1e6);\n\n  L line[2];\n  for(int i=0;i<2;i++){\n    long double l = 0,r = PI,mid;\n    P u = P(1,0);\n\n    for(int j=0;j<1000;j++){\n      mid = (l+r)/2;\n      L tmp = L(a[i],a[i]+rotate(u,mid));\n      long double cut = area(convex_cut(p,tmp));\n      if(cut + EPS < s)r = mid;\n      else l = mid;\n    }\n    line[i] = L(a[i],a[i]+rotate(u,l));\n  }\n  \n  P res = line_cp(line[0],line[1]);\n  \n  for(int i=0;i<n;i++){\n    L tmp = L(res,p[i]);\n    Poly hoge = convex_cut(p,tmp);\n    //printf(\"%.20Lf\\n\",area(convex_cut(p,tmp)));\n    if(rabs(s, area(convex_cut(p,tmp))) > EPS){\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.8Lf %.8Lf\\n\",res.real(),res.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint N;\nint x[50],y[50];\n\nlong long sqr(long long l){\n  return l*l;\n}\n\nlong long s(int i){\n  return sqr(x[(i+1)%N]-x[i])+sqr(y[(i+1)%N]-y[i]);\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  bool f=false;\n  for(int i=0;i+N/2<N;i++){\n    f|=s(i)!=s(i+N/2);\n  }\n  if(N%2==1||f){\n    cout<<\"NA\"<<endl;\n  }else{\n    cout<<(x[0]*1.+x[N/2])/2<<' '<<(y[0]*1.+y[N/2])/2<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol const& pol){\n    int n=pol.size();\n    if(n&1) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok=true;\n    rep(i,n/2){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-6){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        Pol pol(n);\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            pol[i]=P(x,y);\n        }\n        P ans=solve(pol);\n        if(ans == NA){\n            puts(\"NA\");\n        } else {\n            printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n\nclass Point {\npublic:\n\tPoint();\n\tPoint(int x_in, int y_in);\n\n\tPoint  operator+(const Point& obj);\n\tPoint  operator-(const Point& obj);\n\tPoint  operator*(const double n);\n\tPoint  operator/(const double n);\n\n\tvoid set(int x_in, int y_in);\n\n\tdouble x;\n\tdouble y;\n};\n\nPoint::Point() {\n\tx = 0;\n\ty = 0;\n}\n\nPoint::Point(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\nPoint Point::operator+(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x + obj.x;\n\ttemp.y = y + obj.y;\n\treturn temp;\n}\n\nPoint Point::operator-(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x - obj.x;\n\ttemp.y = y - obj.y;\n\treturn temp;\n}\n\nPoint Point::operator*(const double n) {\n\tPoint temp;\n\ttemp.x = x * n;\n\ttemp.y = y * n;\n\treturn temp;\n}\n\nPoint Point::operator/(const double n) {\n\tPoint temp;\n\ttemp.x = x / n;\n\ttemp.y = y / n;\n\treturn temp;\n}\n\nvoid Point::set(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\ndouble abs(Point point) {\n\treturn sqrt(point.x * point.x + point.y * point.y);\n}\n\nint N;\nPoint V[50];\n\nstd::string solve() {\n\tif (N % 2 != 0) return \"NA\";\n\tPoint center = (V[0] + V[N / 2]) / 2;\n\tfor (int i = 1; i < N / 2; i++) {\n\t\tPoint median = (V[i] + V[i + N / 2]) / 2;\n\t\tPoint dist = center - median;\n\t\tif (abs(dist) >= 0.00001) {\n\t\t\treturn \"NA\";\n\t\t}\n\t}\n\tstd::ostringstream str;\n\tstr << center.x << \" \" << center.y;\n\treturn str.str();\n}\n\nint main() {\n\t//入力\n\tstd::cin >> N;\n\tint x, y;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> x >> y;\n\t\tV[i].set(x, y);\n\t}\n\t//演算\n\tstd::string answer = solve();\n\t//出力\n\tstd::cout << answer << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  avgx/=N;avgy/=N;\n  // for(int i=0;i<N;i++){\n  //   double d1=abs(ps[(i+1)%N]-ps[i]);\n  //   double d2=abs(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n  //   // P p1=(ps[(i+1)%N]-ps[i]);\n  //   // P p2=(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n  //   //cout<<d1<<\" \"<<d2<<endl;\n  //   //cout<<p1<<\" \"<<p2<<endl;\n  //   //if(!EQV(p1,p2)){\n  //   if(!EQ(d1,d2)){\n  //     cout<<\"NA\"<<endl;\n  //     return 0;\n  //   }\n  // }\n  P avgp=P(avgx,avgy);\n  // printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  bool ok=false;\n  for(int j=0;j<N;j++){\n    if(EQV(ps[0],ps2[j])){\n      for(int k=0;k<N;k++){\n\tint a=(k+j)%N;\n\tint b=k;\n\tif(!EQV(ps[a],ps2[b])){\n\t  cout<<\"NA\"<<endl;\n\t  return 0;\n\t}\n      }\n      ok=true;\n      break;\n    }\n  }\n  if(ok)printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  else cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <chrono>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n/*\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\ng[from].push_back((Edge) { from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\nint n = p.size(), m = s.size();\nGraph g(n);\nREP(i, m) {\nvector<pair<ld, int>> vec;\nREP(j, n) if (isis_sp(s[i], p[j]))\nvec.emplace_back(abs(s[i].a - p[j]), j);\nsort(ALL(vec));\nREP(j, vec.size() - 1) {\nint from = vec[j].second, to = vec[j + 1].second;\nadd_edge(g, from, to, abs(p[from] - p[to]));\n}\n}\nreturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\nint n = p.size(), m = c.size();\nGraph g(n);\nREP(i, m) {\nvector<pair<ld, int>> vec;\nREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\nvec.emplace_back(arg(c[i].p - p[j]), j);\nsort(ALL(vec));\nREP(j, vec.size() - 1) {\nint from = vec[j].second, to = vec[j + 1].second;\nld angle = vec[j + 1].first - vec[j].first;\nadd_edge(g, from, to, angle * c[i].r);\n}\nif (vec.size() >= 2) {\nint from = vec.back().second, to = vec.front().first;\nld angle = vec.front().first - vec.back().first;\nadd_edge(g, from, to, angle * c[i].r);\n}\n}\nreturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\nint N = p.size();\npolygon.clear();\nREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\nvector<vector<tuple<ld, int, bool>>> tup(N);\nREP(i, s.size()) {\nint a = -1, b = -1;\nREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\nREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\nassert(a >= 0 && b >= 0);\ntup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\ntup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n}\nREP(i, N) sort(ALL(tup[i]));\nREP(i, N) {\nREP(j, tup[i].size()) {\nld angle; int pos = j, from = i, to; bool flag;\ntie(angle, to, flag) = tup[i][j];\nif (flag) continue;\nvector<int> ps;\nwhile (!flag) {\nps.push_back(from);\nget<2>(tup[from][pos]) = true;\nseg2p[from][to].push_back(polygon.size());\nseg2p[to][from].push_back(polygon.size());\nangle += pi + eps;\nif (angle > pi) angle -= 2 * pi;\nauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\nif (it == tup[to].end()) it = tup[to].begin();\nfrom = to; tie(angle, to, flag) = *it;\npos = it - tup[from].begin();\n}\npolygon.push_back(ps);\n}\n}\nGraph g(polygon.size());\nREP(i, N) REP(j, i) {\nif (seg2p[i][j].size() == 2) {\nint from = seg2p[i][j][0], to = seg2p[i][j][1];\ng[from].push_back((Edge) { from, to });\ng[to].push_back((Edge) { to, from });\n}\n}\nreturn g;\n}*/\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\ntypedef long long ll;\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvector<Point> ps(N);\n\tfor (int i = 0;i < N;i++)\n\t\tps[i] = input_point();\n\tvector<Line> ls;\n\tfor (int i = 0;i < N;i++)\n\t\tls.push_back(Line(ps[i], ps[(i + 1) % N]));\n\tbool ok = true;\n\tPoint ans = is_ll(Line(ls[0].a, ls[N / 2].a), Line(ls[0].b, ls[N / 2].b));\n\tfor (int i = 0;i < N;i++) {\n\t\t/*if (isis_ll(ls[i], ls[(i + N / 2) % N]) || N % 2 == 1)\n\t\t\tok = false;\n\t\t*/if (abs(abs(ls[i].a - ls[i].b) - abs(ls[(i + N / 2) % N].a - ls[(i + N / 2) % N].b)) > eps)\n\t\t\tok = false;\n\t\tPoint now = is_ll(Line(ls[i].a, ls[(i + N / 2) % N].a), Line(ls[i].b, ls[(i + N / 2) % N].b));\n\t\tif (abs(now - ans) > eps)\n\t\t\tok = false;\n\t}\n\tif (!ok)\n\t\tcout << \"NA\" << endl;\n\telse {\n\t\tprintf(\"%.10f %.10f\\n\", real(ans), imag(ans));\n\t}\n\treturn 0;\n}\n/*\n4\n1000000 1000000\n0 1000000\n0 0\n1000000 0\n*/"
  },
  {
    "language": "C++",
    "code": "//-------------\n//| ConvexCut |\n//| H28.03.12 |\n//-------------\n\n//---includes---//\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//---defines---//\n#define MAX_N 100000\n#define EPS 1e-6\n#define INF 1e14\n#define INF2 1e12\n\n//---ints---//\nint Q;\nvector<pair<long double, long double>>vec;\nlong double X[MAX_N], Y[MAX_N];\nlong double X1[MAX_N], X2[MAX_N], X3[MAX_N], X4[MAX_N];\nlong double Y1[MAX_N], Y2[MAX_N], Y3[MAX_N], Y4[MAX_N];\n\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; \n\txp[0] = X1 - X2; yp[0] = Y1 - Y2; \n\txp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }\n\tif (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }\n\tif ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }\n\treturn false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { \n\t\treturn make_pair(INF, INF); \n\t}\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }\n\tif (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }\n\tif (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }\n\tlong double XP[4], YP[4], ZP[4];\n\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2;\n\tXP[1] = X3 - X4; YP[1] = Y3 - Y4; \n\tZP[0] = YP[0] / XP[0]; \n\tZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1];\n\tlong double K = (Y5 - Y1) / (ZP[0] - ZP[1]); \n\tlong double L = K*ZP[0]; \n\treturn make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; \n\t\tX2[i] = X[(i + Q / 2) % Q]; \n\t\tY2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { \n\t\tlong double X_1 = vec[i].first, X_2 = vec[i + 1].first;\n\t\tlong double Y_1 = vec[i].second, Y_2 = vec[i + 1].second;\n\t\tif ((X_1 < INF2 || Y_1 < INF2) && (X_2 < INF2 || Y_2 < INF2)) {\n\t\t\tif (fabs(X_1 - X_2) > EPS || fabs(Y_1 - Y_2)>EPS) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << vec[0].first << ' ';\n\tcout << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { \n\tcin >> Q; \n\tfor (int i = 0; i < Q; i++) { \n\t\tcin >> X[i] >> Y[i]; \n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    vector<int> x(n),y(n);\n    rep (i,n) cin >> x[i] >> y[i];\n\n    if (n%2 == 1) quit(\"NA\");\n    int m = n/2;\n    int xx = x[0] + x[m], yy = y[0] + y[m];\n    rep (i,m) {\n        if (xx != x[i] + x[m+i]) quit(\"NA\");\n        if (yy != y[i] + y[m+i]) quit(\"NA\");\n    }\n    cout << double(xx)/2 << \" \" << double(yy)/2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 10000000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\n\nP crossPoint(L l, L m){\n   long double A = cross(l.second - l.first, m.second - m.first);\n   long double B = cross(l.second - l.first, l.second - m.first);\n   if(abs(A) < EPS && abs(B) < EPS) return m.first;\n   else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n   long double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n   theta = theta * M_PI / 180.0;\n   long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t long double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      long double l = miny;\n      long double r = maxy;\n      long double all = area(v);\n      L yoko, tate;\n      while(1){\n\t long double mid = (l + r) / 2.0;\n\t long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   yoko = L(P(-INF,mid),P(INF,mid));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t long double mid = (l + r) / 2.0;\n\t long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   tate = L(P(mid,-INF),P(mid,INF));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n      //printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n\n      for(int i=0;i<v.size();i++){\n\t//L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\tL line = L(v[i], (ans + (ans-v[i])*INF));\n\tlong double half = area(convex_cut(v,line));\n\tif(!equal(half*2.0,all)){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst double EPS = 1e-8;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n//????§???¢???(0,0)???????????¨???????????¢\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//????§???¢?????????\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\n\nsigned main() {\n\tcout << fixed << setprecision(6);\n\tint N; cin >> N;\n\tPolygon P(N);\n\trep(i, 0, N)cin >> P[i];\n\tPoint c = center(P);\n\tfor (auto &p : P)p = p - c;\n\tPolygon Q = rotate(P, rad(180));\n\tsort(all(P));\n\tsort(all(Q));\n\tif (P == Q)cout << c << endl;\n\telse cout << \"NA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  cout << fixed << setprecision(4);\n  int N;\n  cin >> N;\n  vector<int> X(N), Y(N);\n  for (int i = 0; i < N; i++){\n    cin >> X[i] >> Y[i];\n  }\n  if (N % 2 == 1){\n    cout << \"NA\" << endl;\n  } else {\n    int Px = 0, Py = 0;\n    for (int i = 0; i < N; i++){\n      Px += X[i];\n      Py += Y[i];\n    }\n    set<pair<int, int>> st;\n    for (int i = 0; i < N; i++){\n      st.insert(make_pair(X[i] * N, Y[i] * N));\n    }\n    bool ok = true;\n    for (auto P : st){\n      int x = P.first;\n      int y = P.second;\n      if (!st.count(make_pair(Px * 2 - x, Py * 2 - y))){\n        ok = false;\n      }\n    }\n    if (!ok){\n      cout << \"NA\" << endl;\n    } else {\n      cout << (double) Px / N << ' ' << (double) Py / N << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol const& pol){\n    int n=pol.size();\n    if(n&2) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok=true;\n    rep(i,n/2){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-8){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Pol pol(n);\n    rep(i,n){\n        double x,y;cin>>x>>y;\n        pol[i]=P(x,y);\n    }\n    P ans=solve(pol);\n    if(ans == NA){\n        puts(\"NA\");\n    } else {\n        printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nconstexpr double E = 1e-8;\n\nint main() {\n    int n;\n    std::vector<std::pair<int, int>> v;\n    std::pair<int, int> upperLeft(0, 0), bottomRight(0, 0);\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, y; std::cin >> x >> y;\n        v.push_back(std::make_pair(x, y));\n\n\n        upperLeft.first = std::min(upperLeft.first, x);\n        upperLeft.second = std::max(upperLeft.second, y);\n        bottomRight.first = std::max(bottomRight.first, x);\n        bottomRight.second = std::min(bottomRight.second, y);\n    }\n\n    if (n % 2) {\n        std::cout << \"NA\" << std::endl;\n        return 0;\n    }\n\n    // 重心計算\n    std::pair<double, double> center((upperLeft.first + bottomRight.first) / 2.0, (upperLeft.second + bottomRight.second) / 2.0);\n\n    // 平行移動\n    for (auto& x : v) {\n        x.first -= center.first;\n        x.second -= center.second;\n    }\n\n    // 点対称か調べる\n    bool isOk = true;\n    for (int i = 0; i < v.size(); i++) {\n        const auto& base = v[i];\n        bool isThereCompatiblePoint = false;\n        for (int j = 0; j < v.size(); j++) {\n            if (i != j && std::abs(v[j].first + base.first) < E && std::abs(v[j].second + base.second) < E) {\n                isThereCompatiblePoint = true;\n                break;\n            }\n        }\n        isOk &= isThereCompatiblePoint;\n    }\n\n    if (!isOk) {\n        std::cout << \"NA\" << std::endl;\n    }\n    else {\n        std::cout << std::fixed << std::setprecision(8) << center.first << \" \" << center.second << std::endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nint main() {\n\n\tint N, x, y;\n\txy_t P[60];\n\n\tcin >> N;\n\n\tfor ( int i = 0; i < N; i++ ) {\n\n\t\tcin >> x >> y;\n\t\tP[i] = xy_t( x, y );\n\n\t}\n\n\tif ( N % 2 ) { cout << \"NA\" << endl; }\n\t\n\txy_t a = ( P[0] + P[N/2] ) * 0.5;\n\n\tfor ( int i = 1; i < N / 2; i++) {\n\n\t\txy_t b = ( P[i] + P[i+N/2] ) * 0.5;\n\t\t\n\t\tif ( abs( a - b ) < 1e-4 ) { \n\t\t\n\t\t\tprintf( \"%.5f %.5f\\n\", a.real(), a.imag() );\n\t\t\t\n\t\t\treturn 0;\n\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n\n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[i] - sumx;\n    double ay = y[i] - sumy;\n    double bx = x[(i+1)%n] - sumx;\n    double by = y[(i+1)%n] - sumy;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n\n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n;\n\tcin>>n;\n\tG g(n);\n\trep(i,n)g[i]=pin();\n\tif(n%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tG t;\n\trep(i,n/2)loop(j,i+1,n/2)t.pb(crosspointLL(L(g[i],g[i+n/2]),L(g[j],g[j+n/2])));\n\tsort(all(t));\n\tif(abs(t[0]-t[t.size()-1])<EPS)cout<<shosu(9)<<t[0].real()<<\" \"<<t[0].imag()<<endl;\n\telse cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nint main(){\n    int N; cin>>N;\n    vec V[N];\n    for(auto& v:V) cin>>v.x>>v.y;\n    if(N%2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    vec M[N/2];\n    for(int i=0;i<N/2;i++){\n        M[i]=(V[i]+V[N/2+i])*0.5;\n    }\n    for(int i=1;i<N/2;i++){\n        if((M[0]-M[i]).norm()>1e-4){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    for(int i=1;i<N/2;i++){\n        M[0]=M[0]+M[i];\n    }\n    M[0]=M[0]*(1.0/(N/2));\n    cout << M[0].x << \" \" << M[0].y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> P3;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e4 + 5);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    int n;\n    double cx=0.0,cy=0.0,x[50],y[50];\n    bool used[50]{}, ok = true;\n    cin >> n;\n    REP(i,n){\n        cin >> x[i] >> y[i];\n        cx += double(x[i]);\n        cy += double(y[i]);\n    }\n    cx /= double(n);\n    cy /= double(n);\n    REP(i,n){\n        x[i] -= cx;\n        y[i] -= cy;\n        if(x[i] < -EPS){\n            x[i] *= -1.0;\n            y[i] *= -1.0;\n        }\n    }\n    REP(i,n){\n        if(used[i])continue;\n        REP(j,n){\n            if(used[j] || i==j)continue;\n            if(abs(x[i]-x[j])<EPS && abs(y[i]-y[j])<EPS){\n                used[i] = used[j] = true;\n            }\n        }\n    }\n    REP(i,n) ok &= used[i];\n    if(ok){\n        printf(\"%.8lf %.8lf\\n\",cx,cy);\n    }\n    else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\ntypedef complex<double> po;\nvector<po>vec;\n\nint main(){\n    int N;\n    cin>>N;\n    if(N%2==1){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<N;i++){\n        double x,y;\n        cin>>x>>y;\n        vec.push_back(po(x,y));\n    }\n    int fini=1;\n    for(int i=0;i<N/2;i++){\n        double l1=abs(vec[i]-vec[(i+1)%N]);\n        double l2=abs(vec[N/2+i]-vec[(N/2+i+1)%N]);\n        double d1=abs(vec[i]-vec[(i+N/2)%N]);\n        double d2=abs(vec[i+1]-vec[(i+N/2+1)%N]);\n        if(abs(l1-l2)>=1e-5&&abs(d1-d2)>=1e-5){\n            fini=0;\n            break;\n        }\n    }\n    if(fini==0)\n        cout<<\"NA\"<<endl;\n    else{\n        double x=0,y=0;\n        for(int i=0;i<N;i++){\n            x+=vec[i].real();\n            y+=vec[i].imag();\n        }\n        cout<<x/N<<\" \"<<y/N<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<math.h>\nusing namespace std;\n\ntypedef complex<double> po;\nvector<po>vec;\n\nint main(){\n    int N;\n    cin>>N;\n    if(N%2==1){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<N;i++){\n        double x,y;\n        cin>>x>>y;\n        vec.push_back(po(x,y));\n    }\n    int fini=1;\n    for(int i=0;i<N/2;i++){\n        double l1=abs(vec[i]-vec[(i+1)%N]);\n        double l2=abs(vec[N/2+i]-vec[(N/2+i+1)%N]);\n        double d1=abs(vec[i]-vec[(i+N/2+1)%N]);\n        double d2=abs(vec[i+1]-vec[(i+N/2)%N]);\n        if(abs(l1-l2)>=1e-5||abs(d1-d2)>=1e-5){\n            fini=0;\n            break;\n        }\n    }\n    if(fini==0)\n        cout<<\"NA\"<<endl;\n    else{\n        double x=0,y=0;\n        for(int i=0;i<N;i++){\n            x+=vec[i].real();\n            y+=vec[i].imag();\n        }\n        cout<<x/N<<\" \"<<y/N<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n  Circle() {;}\n  Circle(Point p, double r) : p(p), r(r) {;}\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nint n;\nPolygon poly;\nPoint center;\n\nint main() {\n  while (scanf(\"%d\", &n) > 0) {\n    poly.clear();\n    center = Point(0, 0);\n    REP(i, n) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      poly.push_back(Point(x, y));\n      center += Point(x, y);\n    }\n    center /= (double)n;\n    REP(i, n) {\n      Point vect = poly[i] - center;\n      Point need = center - vect;\n      REP(j, n) {\n        if (abs(poly[j] - need) <= EPS) { goto ok; }\n      }\n      puts(\"NA\");\n      goto end;\nok:;\n    }\n    printf(\"%.10f %.10f\\n\", center.real(), center.imag());\nend:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//-------------\n//| ConvexCut |\n//| H28.03.12 |\n//-------------\n\n//---includes---//\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//---defines---//\n#define MAX_N 100000\n#define EPS 1e-10\n#define INF 1e14\n#define INF2 1e12\n\n//---ints---//\nint Q;\nvector<pair<long double, long double>>vec;\nlong double X[MAX_N], Y[MAX_N];\nlong double X1[MAX_N], X2[MAX_N], X3[MAX_N], X4[MAX_N];\nlong double Y1[MAX_N], Y2[MAX_N], Y3[MAX_N], Y4[MAX_N];\n\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; \n\txp[0] = X1 - X2; yp[0] = Y1 - Y2; \n\txp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }\n\tif (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }\n\tif ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }\n\treturn false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { \n\t\treturn make_pair(INF, INF); \n\t}\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }\n\tif (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }\n\tif (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }\n\tlong double XP[4], YP[4], ZP[4];\n\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2;\n\tXP[1] = X3 - X4; YP[1] = Y3 - Y4; \n\tZP[0] = YP[0] / XP[0]; \n\tZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1];\n\tlong double K = (Y5 - Y1) / (ZP[0] - ZP[1]); \n\tlong double L = K*ZP[0]; \n\treturn make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; \n\t\tX2[i] = X[(i + Q / 2) % Q]; \n\t\tY2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { \n\t\tlong double X_1 = vec[i].first, X_2 = vec[i + 1].first;\n\t\tlong double Y_1 = vec[i].second, Y_2 = vec[i + 1].second;\n\t\tif ((X_1 < INF2 || Y_1 < INF2) && (X_2 < INF2 || Y_2 < INF2)) {\n\t\t\tif (fabs(X_1 - X_2) > EPS || fabs(Y_1 - Y_2)>EPS) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << vec[0].first << ' ';\n\tcout << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { \n\tcin >> Q; \n\tfor (int i = 0; i < Q; i++) { \n\t\tcin >> X[i] >> Y[i]; \n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??´???\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const P &p,const P &q){\n  return abs(p - q) ;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\ndouble calc_triangle(P a,P b,P c){\n  P ba = (b - a);\n  P ca = (c - a);\n  return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n}\ndouble calc_area(const G &g){\n  double res = 0;\n  rep(i,g.size()-2){\n    res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n  }\n  return res;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nG convex_cut(G &g, L &l) {\n  G h;\n  rep(i, (int)g.size()) {\n    P p = curr(g, i), q = next(g, i);\n    if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n      if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n      else return G{};                        // p -- l.b -- l.a -- q\n    }\n    if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n    if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n      h.emplace_back(crosspoint(L(p, q), l));\n  }\n  return h;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  G g;\n  P gp = P(0,0);\n  double x,y;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n    gp = gp + P(x,y);\n  }\n  gp = gp / (1.0 * n);\n  random_device rnd;\n  mt19937 mt(rnd());\n  REP(i,0,n * n){\n    P a(mt() % 1000000,mt() % 1000000);\n    /* std::cout << a << std::endl; */\n    L ab(a,gp),ba(gp,a);\n    G t = convex_cut(g,ab);\n    /* rep(j,t.size()){                  */\n    /*   std::cout << t[j] << std::endl; */\n    /* }                                 */\n    /* cout << endl;                     */\n    G u = convex_cut(g,ba);\n    /* rep(j,u.size()){                  */\n    /*   std::cout << u[j] << std::endl; */\n    /* }                                 */\n    /* cout << endl;                     */\n    double T = calc_area(t),U = calc_area(u);\n    /* fcout(10) << T << ' ' << U << endl; */\n    if(abs(T - U) >= EPS){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  fcout(10) << real(gp) << ' ' << imag(gp) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint m;\n\tcin>>m;\n\tif(m%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tm/=2;\n\tint a[50],a1[50],b[50],b1[50];\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a[i]>>b[i];\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a1[i]>>b1[i];\n\t}\n\tint ans1=a[0]+a1[0],ans2=b[0]+b1[0];\n\tfor(int i=1;i<m;++i){\n\t\tif(a[i]+a1[i]!=ans1){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(b[i]+b1[i]!=ans2){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%f %f\",ans1/2.0,ans2/2.0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { int x, y; };\nstruct line { point p1, p2; };\n\nbool parallel(line l1, line l2) {\n  int s1 = (l1.p1.y - l1.p2.y) * (l2.p1.x - l2.p2.x);\n  int s2 = (l1.p1.x - l1.p2.x) * (l2.p1.y - l2.p2.y);\n  return s1 == s2;\n}\n\nint N, X[50], Y[50];\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  if(N % 2) {\n    cout << \"NA\" << endl;\n  } else {\n    bool ans = true;\n    REP(i, 0, N / 2) {\n      line l1 = (line) {\n        (point) { X[i], Y[i] },\n        (point) { X[i + 1], Y[i + 1] },\n      };\n      line l2 = (line) {\n        (point) { X[i + N / 2], Y[i + N / 2] },\n        (point) { X[(i + N / 2) % N], Y[(i + N / 2) % N] },\n      };\n      if(!parallel(l1, l2)) ans = false;\n    }\n    if(!ans) cout << \"NA\" << endl;\n    else {\n      double cx = (X[0] + X[N / 2]) / 2.0;\n      double cy = (Y[0] + Y[N / 2]) / 2.0;\n      printf(\"%.8lf %.8lf\\n\", cx, cy);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 20000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF/abs(ans-v[i])));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\nusing namespace std;\nint n;\ndouble x[50],y[50];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tif(n%2)cout<<\"NA\"<<endl;\n\telse\n\t{\n\t\tn=n/2;bool f=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tf&=x[i+1]-x[i]==x[n+i]-x[(n+i+1)%(n*2)];\n\t\t\tf&=y[i+1]-y[i]==y[n+i]-y[(n+i+1)%(n*2)];\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tcout<<setprecision(9)<<(x[0]+x[n])/2.<<\" \"<<(y[0]+y[n])/2.<<endl;\n\t\t}\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nconstexpr double eps = 1e-10;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<double> x(N), y(N);\n    for(int i=0; i<N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    if(N % 2 == 1) {\n        cout << \"NA\" << endl;\n    } else {\n        double px = (x[0] + x[N/2]) / 2, py = (y[0] + y[N/2]) / 2;\n        bool ok = true;\n        for(int i=0; i<N; ++i) {\n            double vx = px - x[i], vy = py - y[i];\n            ok &= fabs(px + vx - x[(i+N/2) % N]) < eps && fabs(py + vy - y[(i+N/2)%N]) < eps;\n        }\n        if(ok) {\n            cout << fixed << setprecision(10) << px << \" \" << py << endl;\n        } else {\n            cout << \"NA\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef pair<P, P> Line;\nbool eq(double x, double y){\n  if(abs(x - y) < EPS) return true;\n  else return false;\n}\nbool eq(P a, P b){\n  if(eq(a.X, b.X) && eq(a.Y, b.Y)) return true;\n  else return false;\n}\nbool isok(vector<Line> L){\n  int N = L.size();\n  if(N % 2 != 0) return false;\n  for(int i = 0; i < N / 2; i++){\n    if(!eq(L[i].second - L[i].first, L[i + N/2].first - L[i + N/2].second)) return false;\n  }\n  return true;\n}\nint main(){\n  int N;\n  while(cin>>N){\n    vector<P> points;\n    REP(i, N){\n      double x, y;\n      cin>>x>>y;\n      points.push_back(P(x, y));\n    }\n    vector<Line> lines;\n    REP(i, N) lines.push_back(Line(points[i], points[(i + 1) % N]));\n    if(isok(lines)){\n      double ansX, ansY;\n      ansX = (points[0].X + points[0 + N/2].X)/2;\n      ansY = (points[0].Y + points[0 + N/2].Y)/2;\n      printf(\"%.5lf %.5lf\\n\", ansX, ansY);\n    }else{\n      cout<<\"NA\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n\n  bool ok = true;\n  P center = (ps[0] + ps[N/2]) * 0.5;\n  REP(i, N / 2){\n    ok &= abs(center - (ps[i] + ps[N/2 + i]) * 0.5) < EPS;\n  }\n  \n  if(ok && N % 2 == 0){\n    printf(\"%.9f %.9f\\n\", center.real(), center.imag());\n  }else{\n    cout << \"NA\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N & 1) {\n\t\tcout << \"NA\\n\";\n\t\treturn 0;\n\t}\n\t\tvector<pair<double, double>>v(N);\n\t\tfor (auto &i : v)cin >> i.first >> i.second;\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tif (v[i].first + v[i + N / 2].first != v[0].first + v[N / 2].first|| v[i].second + v[i + N / 2].second != v[0].second + v[N / 2].second) {\n\t\t\t\tcout << \"NA\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcout <<setprecision(20)<< (v[0].first + v[N / 2].first) / 2 << \" \" << (v[0].second + v[N / 2].second) / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<ld> X(N), Y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\tif (N & 1) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tld posX = (X[0] + X[N / 2]) / 2, posY = (Y[0] + Y[N / 2]) / 2;\n\tbool ng = false;\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tld px = (X[i] + X[i + N / 2]) / 2, py = (X[i] + X[i + N / 2]) / 2;\n\t\tif (hypotl(px - posX, py - posY) >= 1e10) {\n\t\t\tng = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ng) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tcout << fixed << setprecision(8) << posX << ' ' << posY << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n \nclass Point {\npublic:\n    Point();\n    Point(double x_in, double y_in);\n \n    Point  operator+(const Point& obj);\n    Point  operator-(const Point& obj);\n    Point  operator*(const double n);\n    Point  operator/(const double n);\n \n    void set(double x_in, double y_in);\n \n    double x;\n    double y;\n};\n \nPoint::Point() {\n    x = 0;\n    y = 0;\n}\n \nPoint::Point(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \nPoint Point::operator+(const Point& obj) {\n    Point temp;\n    temp.x = x + obj.x;\n    temp.y = y + obj.y;\n    return temp;\n}\n \nPoint Point::operator-(const Point& obj) {\n    Point temp;\n    temp.x = x - obj.x;\n    temp.y = y - obj.y;\n    return temp;\n}\n \nPoint Point::operator*(const double n) {\n    Point temp;\n    temp.x = x * n;\n    temp.y = y * n;\n    return temp;\n}\n \nPoint Point::operator/(const double n) {\n    Point temp;\n    temp.x = x / n;\n    temp.y = y / n;\n    return temp;\n}\n \nvoid Point::set(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \ndouble abs(Point point) {\n    return sqrt(point.x * point.x + point.y * point.y);\n}\n \nint N;\nPoint V[50];\n \nstd::string solve() {\n    if (N % 2 != 0) return \"NA\";\n    Point center = (V[0] + V[N / 2]) / 2;\n    for (int i = 1; i < N / 2; i++) {\n        Point median = (V[i] + V[i + N / 2]) / 2;\n        Point dist = center - median;\n        if (abs(dist) >= 0.00001) {\n            return \"NA\";\n        }\n    }\n    std::ostringstream str;\n    str << center.x << \" \" << center.y;\n    return str.str();\n}\n \nint main() {\n    //入力\n    std::cin >> N;\n    double x, y;\n    for (int i = 0; i < N; i++) {\n        std::cin >> x >> y;\n        V[i].set(x, y);\n    }\n    //演算\n    std::string answer = solve();\n    //出力\n    std::cout << answer << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<P> points;\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        points.push_back(P(x,y));\n    }\n\n    P center = P(0,0);\n    vector<double> sub;\n    for (int i = 0; i < N; i++) {\n        center += points[i];\n        sub.push_back(abs(points[(N + i - 1) % N] - points[i]));\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (sub[i] != sub[(i+N/2)%N]) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n\n    printf(\"%.12f %.12f\\n\", center.real() / N, center.imag() / N);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<cstdlib>\n#include<sstream>\n#define EPS 1e-10\n#define F first\n#define pb push_back\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nusing namespace std;\ntypedef pair<long double,long double> P;\n\n\nint N;\n/*\ncout << setiosflags(ios::fixed) << setprecision(5) << ans.F << \" \" << ans.S << endl;\n*/\n\nclass Point{\npublic:\n  long double x,y;\n\n  Point (long double x=0,long double y=0):x(x),y(y){}\n\n  Point operator + (Point p) {return Point(x+p.x,y+p.y); }\n  Point operator - (Point p) {return Point(x-p.x,y-p.y); }\n  Point operator * (long double p) {return Point(x*p,y*p); } \n  Point operator / (long double p) {return Point(x/p,y/p); }\n\n  bool operator < (const Point &p) const {\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n};\n\nlong double norm(long double x,long double y){\n  return x*x+y*y;\n}\n\nlong double abs(long double x,long double y){\n  return sqrt(norm(x,y));\n}\n\nlong double dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nlong double det(Point a,Point b){\n  return a.x*b.y-a.y*b.x;\n}\n\n\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(det(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nvector<Point> Pvec;\nvector<Segment> Svec;\nPoint ans;\n\nvoid makeSvec(){\n  rep(i,Pvec.size()){\n    Segment s;\n    if(i == Pvec.size()-1){\n      s.p1 = Pvec[i];\n      s.p2 = Pvec[0];\n    }else{\n    s.p1 = Pvec[i];\n    s.p2 = Pvec[i+1];\n    }\n    Svec.pb(s);\n  }\n}\n\nvoid input(){\n  ans.x = 0;ans.y = 0;\n cin >> N;  \n  rep(i,N){\n    Point pos;\n    cin >> pos.x >> pos.y;\n    ans.x = ans.x+pos.x; ans.y = ans.y+pos.y; \n    Pvec.pb(pos);\n  }\n  ans.x = ans.x/N;\n  ans.y = ans.y/N;\n  makeSvec();\n}\n\n\nint main(){\n  input();\n  if(N%2 != 0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  rep(i,N){\n    bool fin = false;\n    rep(j,N){\n      if(i == j)continue;\n      if(isParallel(Svec[i],Svec[j]))fin = true;\n    }\n    if(!fin){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  cout << setiosflags(ios::fixed) << setprecision(5) << ans.x << \" \" << ans.y << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nint main(){\n  int n;cin>>n;\n  Polygon g,v;\n  int i;\n  g.resize(n);\n  for(i=0;i<n;i++) cin >> g[i].x >> g[i].y;\n  bool f=true;\n  if(n%2) f=false;\n  else{\n    for(i=0;i<n/2;i++) v.push_back((g[i]+g[i+n/2])/2);\n    v.erase(unique(v.begin(),v.end()),v.end());\n    if(v.size()!=1) f=false;\n  }\n  if(f) printf(\"%.8f %.8f\\n\",v[0].x,v[0].y);\n  else cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(getdis(a,p[i])!=getdis(a,p[n/2+i]))an=0;\n  }\n  double x=a.f,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long double EPS = 1e-7;\n\nstruct point {\n\tlong double x, y;\n\tpoint(long double x = 0.0, long double y = 0.0):x(x), y(y) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(long double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n};\n\nlong double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nlong double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst long double t = cross(b, c);\n\tif(t > EPS) return 1;\n\tif(t < -EPS) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\npoint rotate(const point &p, long double theta) {\n\tconst long double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\npoint crosspoint(const line &a, const line &b) {\n\tconst long double t = cross(a.b - a.a, b.b - b.a);\n\tif(abs(t) < EPS) return a.a;\n\treturn b.a + (b.b - b.a) * cross(a.b - a.a, a.a - b.a) * (1 / t);\n}\n\ntypedef vector<point> polygon;\n\nlong double area(const polygon &p) {\n\tconst int n = p.size();\n\tif(n < 3) return 0.0;\n\n\tlong double res = cross(p[n - 1], p[0]);\n\tfor(int i = 1; i < n; ++i) {\n\t\tres += cross(p[i - 1], p[i]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\npolygon convex_cut(const polygon &p, const line &l) {\n\tconst int n = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int next = (i + 1) % n;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1) res.emplace_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0) {\n\t\t\tres.emplace_back(crosspoint(l, line(p[i], p[next])));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool ok(const point &g, const polygon &p) {\n\tconst long double S_half = area(p) / 2.0;\n\tfor(long double theta = 0; theta < M_PI; theta += 0.01) {\n\t\tconst long double  S = area(convex_cut(p, line(g, g + rotate(point(10, 0), theta))));\n\t\tif(abs((S_half - S) / S_half) > EPS) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(5);\n\tcout.flags(ios::fixed);\n\n\tint n;\n\tcin >> n;\n\n\tpoint g(0, 0);\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.emplace_back(x, y);\n\t\tg = g + p[i];\n\t}\n\n\tg = g * (1.0 / n);\n\tcerr << g.x << \" \" << g.y << endl;\n\n\tif(ok(g, p)) {\n\t\tcout << g.x << \" \" << g.y << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\n\n// ?????\\??????????????´???????????\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // ???????????§?????????????£°?????\\??????\ntypedef vector <P> Pol;\n\n// ??§????????????????????§?????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// ???????????¬?¬??????????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// ??????\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base ????????¢???\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //??????a?????¨??????b???????????±??´??§??¨?????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a?????¨b????????±?£??????????????£?????????????\n}\n\n// ??±?£???? ??¶??´??±???\n\t// ???????????¨??¶??´??±?£???????????±¬\n\t// ???????????¨??±?£?????????????????±¬\n\t// ??¶??´??±?£??????¶??´??±?£???????????±¬\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ????????????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£??????????????????????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// ???????????¨??¶??´??±?£??????±?£??????¢??¢?¨???£?????????????±¬\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// ??????\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2?????????????????????????????????\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// ??????????¬???\\??±???\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// ??????????????±?¨??£??£???±???\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//?????±?¨??£?????¬???\\??±???\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// ?????±?¨??£????????£???±???\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//?¬???\\????????§???????????¨?????§????£???±???\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\n// ?????????\n\n// ????????§????????¢\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// ????????§????????¢?????????????????????????£?????(??????????????§????????¢??§??????)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// ??§??¢????????????????????????\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/*\n\n// now developing\nvector<L> merge_L(vector<L>){\n\n}\n\n\n\nPol normalize_polygon(Pol pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+2)%n],pol[(i+1)%n])==MID)\n\t\t\t// remove pol[(i+1)%n]\n\t\t\tn--;\n\t}\n}\n*/\n\n#define F first\n#define S second\n\nint main(void){\n    for(int n; cin >> n;){\n        VP p(n);\n        for(auto && pp : p){\n            int x, y; cin >> x >> y;\n            pp = P(x, y);\n        }\n\n        if(n % 2 == 1){\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        int offset = n / 2;\n        bool ok = true;\n        P res;\n\n        rep(i, offset){\n            L l1(mp(p[i], p[i + 1])), \n              l2(mp(p[offset + i], p[(offset + i + 1) % n]));\n\n            if(iLL(l1, l2) || sqr(l1.S.X - l1.F.X) + sqr(l1.S.Y - l1.F.Y) - (sqr(l2.S.X - l2.F.X) + sqr(l2.S.Y - l2.F.Y)) > eps){\n                ok = false;\n                break;\n            }\n        }\n\n        if(ok){\n            res = P((p[0].X + p[offset].X) / 2.0, (p[0].Y + p[offset].Y) / 2.0);\n            printf(\"%.7Lf %.7Lf\\n\", res.X, res.Y);\n        }\n        else cout << \"NA\" << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// 以下 幾何部分\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P> Pol;\n\n// ソートのキー\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);}\nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  aとbの線分判定はこれ\n}\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP points(n);\n\trep(i,n) cin >> points[i].X  >> points[i].Y;\n\n\n\tif(n&1){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tbool ok=true;\n\tVL lines(n);\n\trep(i,n) lines[i]=mp(points[i],points[(i+1)%n]);\n\n\trep(i,n/2){\n\t\tif(!ipar(lines[i],lines[i+n/2]))\n\t\t\tok=false;\n\t\tif(abs(vec(lines[i]))!=abs((vec(lines[i+n/2]))))\n\t\t\tok=false;\n\t}\n\n\tif(ok){\n\t\tcout.precision(10);\n\t\tP ans=(points[0]+points[n/2])/P(2.0,0.0);\n\t\tcout << fixed << ans.X << \" \" << ans.Y << endl;\n\t}else\n\t\tcout << \"NA\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nint N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N & 1) {\n\t\tcout << \"NA\\n\";\n\t\treturn 0;\n\t}\n\t\tvector<pair<double, double>>v(N);\n\t\tfor (auto &i : v)cin >> i.first >> i.second;\n\t\tfor (int i = 0; i < N / 2; i++) {\n\t\t\tif (v[i].first + v[i + N / 2].first != v[0].first + v[N / 2].first|| v[i].second + v[i + N / 2].second != v[0].second + v[N / 2].second) {\n\t\t\t\tcout << \"NA\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcout << (v[0].first + v[N / 2].first) / 2 << \" \" << (v[0].second + v[N / 2].second) / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n \nclass Point {\npublic:\n    Point();\n    Point(double x_in, double y_in);\n \n    Point  operator+(const Point& obj);\n    Point  operator-(const Point& obj);\n    Point  operator*(const double n);\n    Point  operator/(const double n);\n \n    void set(double x_in, double y_in);\n \n    double x;\n    double y;\n};\n \nPoint::Point() {\n    x = 0;\n    y = 0;\n}\n \nPoint::Point(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \nPoint Point::operator+(const Point& obj) {\n    Point temp;\n    temp.x = x + obj.x;\n    temp.y = y + obj.y;\n    return temp;\n}\n \nPoint Point::operator-(const Point& obj) {\n    Point temp;\n    temp.x = x - obj.x;\n    temp.y = y - obj.y;\n    return temp;\n}\n \nPoint Point::operator*(const double n) {\n    Point temp;\n    temp.x = x * n;\n    temp.y = y * n;\n    return temp;\n}\n \nPoint Point::operator/(const double n) {\n    Point temp;\n    temp.x = x / n;\n    temp.y = y / n;\n    return temp;\n}\n \nvoid Point::set(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \ndouble abs(Point point) {\n    return sqrt(point.x * point.x + point.y * point.y);\n}\n \nint N;\nPoint V[50];\n \nstd::string solve() {\n    if (N % 2 != 0) return \"NA\";\n    Point center = (V[0] + V[N / 2]) / 2.0;\n    for (int i = 1; i < N / 2; i++) {\n        Point median = (V[i] + V[i + N / 2]) / 2.0;\n        Point dist = center - median;\n        if (abs(dist) >= 0.00001) {\n            return \"NA\";\n        }\n    }\n    std::ostringstream str;\n    str.setf(std::ios::fixed, std::ios::floatfield);\n    str << center.x << \" \" << center.y;\n    return str.str();\n}\n \nint main() {\n    //入力\n    std::cin >> N;\n    double x, y;\n    for (int i = 0; i < N; i++) {\n        std::cin >> x >> y;\n        V[i].set(x, y);\n    }\n    //演算\n    std::string answer = solve();\n    //出力\n    std::cout << answer << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t\tcx += p[i][0];\n\t\tcy += p[i][1];\n\t}\n\tcx /= n;\n\tcy /= n;\n\tif(n%2) f=1;\n\telse for(i = 0; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) /2 - cx) <= 0.0001 && fabs((p[i][1] + p[i + n/2][1]) /2 - cy) <= 0.0001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse cout << cx << \" \" << cy << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS=1e-6;\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<P> G(n);\n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    G[i]=P(x,y);\n  }\n  if(n%2){cout<<\"NA\"<<endl;return 0;}  \n  double len=abs(G[0]-G[1]);\n  for(int i=0;i<n/2;i++){\n    double a=abs(G[i]-G[(i+1)]);\n    double b=abs(G[i+n/2]-G[(i+n/2+1)%n]);\n    if(abs(a-b)>EPS){cout<<\"NA\"<<endl;return 0;}\n  }\n  P ans=crossPoint(L(G[0],G[n/2]),L(G[1],G[n/2+1]));\n  printf(\"%lf %lf\\n\",real(ans),imag(ans));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    if (n % 2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    int xa = x[0]+x[n/2], ya = y[0]+y[n/2];\n    bool f = 1;\n    REP(i,n/2){\n        if (x[i]+x[n/2+i] != xa || y[i]+y[n/2+i] != ya) f = 0;\n    }\n    if (f) printf(\"%.10f %.10f\\n\", xa/2.0, ya/2.0);\n    else cout << \"NA\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n?????????????????¨?????????????????¨????????????\n????±???¨?????????????????????????????¨????????????????????¨???????????´??????????????°???????????¶???????????°??¢\n*/\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n;???cin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\tvector<double> len(n);\n\trep(i, n - 1){\n\t\tdouble tmp = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tlen.push_back(tmp);\n\t}\n\tdouble tmp = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tlen.push_back(tmp);\n\tsort(all(len));\n\tif(len[n - 1] - len[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//????±???¨????????????????????????????±???????\n\tvector<double> Px;\n\tvector<double> Py;\n\trep(i, n / 2){\n\t\tdouble x = (point[i].fi + point[i + n / 2].fi) / 2.0;\n\t\tPx.push_back(x);\n\t\tdouble y = (point[i].se + point[i + n / 2].se) / 2.0;\n\t\tPy.push_back(y);\n\t}\n\n\t//?????§?±???????????±???¨??????????????????????????????????????§??????????????¨?°?????????????????????´??????????????°??????????±???§??????\n\tsort(all(Px));\n\tif(Px[n / 2 - 1] - Px[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(Py));\n\tif(Py[n / 2 - 1] - Py[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"%.9f %.9f\\n\", Px[0], Py[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<double, double> P;\n\n#define INF 1000000000\n#define EPS 1e-8\n#define EQ(x,y) fabs((x)-(y))<EPS\n\ndouble x[50];\ndouble y[50];\n\nint main(){\n  int n;\n  cin>>n;\n\n  vector<P> points(n);\n  rep(i,n){\n    scanf(\"%lf %lf\", &x[i], &y[i]);\n  }\n\n  if(n%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n\n  double cx, cy; //candidate x,y\n  cx = (x[0]+x[n/2])/2.0;\n  cy = (y[0]+y[n/2])/2.0;\n\n  repl(i,1,n/2){\n    if(EQ((x[i]+x[n/2+i])/2.0, cx) &&\n       EQ((y[i]+y[n/2+i])/2.0, cy)){\n      continue;\n    } else {\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n\n  printf(\"%.5f %.5f\\n\", cx, cy);\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  cout<<a<<\" \"<<b<<endl;\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=(double)a.s,y=(double)a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<std::pair<double, double>> points;\n\tpoints.reserve(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\tpoints.push_back({ x, y });\n\t}\n\n\t// ??????????±???????\n\tdouble center_x = 0;\n\tdouble center_y = 0;\n\tfor (auto& p : points) {\n\t\tcenter_x += p.first;\n\t\tcenter_y += p.second;\n\t}\n\tcenter_x /= points.size();\n\tcenter_y /= points.size();\n\n\t// ????????????????????¢\n\tdouble distance = std::abs(points[0].first - center_x) + std::abs(points[0].second - center_y);\n\tfor (auto iter = points.begin() + 1; iter != points.end(); iter++) {\n\t\tauto& p = *iter;\n\t\tdouble pd = std::abs(p.first - center_x) + std::abs(p.second - center_y);\n\n\t\tif (std::abs(distance - pd) > 0.0001) {\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstd::cout << std::fixed << std::setprecision(5) << center_x << \" \" << center_y << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ccomplex>\n#include <vector>\n#include <cassert>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n#include <list>\n#include <time.h>\n#include <stack>\n#include <locale>\n#include <clocale>\n#include <ctype.h>\n#include <wchar.h>\n#include <random>\n#include <vector>\n\n\n\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tREP(i, v.size()) { if (i)os << \" \"; os << v[i]; }return os;\n}\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) {\n\tREP(i, v.size()) { if (i)os << endl; os << v[i]; }return os;\n}\n\n//誤差修正用\nconst double EPS = 1e-1;\n\n//円周率\nconst double PI = acos(-1);\n\n//double型の値が等しいか\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\n//点に関する構造体\nstruct Point\n{\n\tdouble x, y;\n\n\tPoint() {}\n\n\tPoint(double x, double y) : x(x), y(y) {}\n\n\t//加減、スカラー倍、乗算など\n\tPoint operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n\tPoint operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n\tPoint operator*(const double b) const { return Point(x * b, y * b); }\n\n\tPoint operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n\tPoint operator/(const double b) const { return Point(x / b, y / b); }\n\n\tbool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n\tbool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n\t//大きさの二乗\n\tdouble norm() { return x * x + y * y; }\n\n\t//逆正接（x軸正方向からの反時計回り回転角）\n\tdouble arg() { return atan2(x, y); }\n\n\t//大きさ\n\tdouble abs() { return sqrt(norm()); }\n\n\t//反時計回りにθ回転\n\tPoint rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n\t//反時計回りにπ/2回転\n\tPoint rotate90() { return Point(-y, x); }\n\n\tfriend ostream &operator<<(ostream &os, Point &p) { return os << p.x << \" \" << p.y; }\n\n\tfriend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n};\n\n//外積\ndouble cross(const Point &a, const Point &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n//内積\ndouble dot(const Point &a, const Point &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n//直線に関する構造体\n//直線が通る2点で表す\nstruct Line\n{\n\tPoint a, b;\n\n\tLine() {};\n\n\tLine(Point a, Point b) : a(a), b(b) {};\n\n\tvoid set(Point a, Point b) {\n\t\tthis->a = a;\n\t\tthis->b = b;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n\tfriend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n};\n\n//多角形\ntypedef vector< Point > Polygon;\n\n//3点の位置関係を判定\nint ccw(const Point &a, Point b, Point c)\n{\n\tb = b - a, c = c - a;\n\n\t//a→bで反時計回りの方向にc\n\tif (cross(b, c) > EPS) return +1;\n\n\t//a→bで時計回りの方向にc\n\tif (cross(b, c) < -EPS) return -1;\n\n\t//c→a→bで一直線\n\tif (dot(b, c) < 0) return +2;\n\n\t//a→b→cで一直線\n\tif (b.norm() < c.norm()) return -2;\n\n\t//a→c→bで一直線\n\treturn 0;\n}\n\n//2直線の平行判定\nbool IsParallel(const Line& a, const Line& b) {\n\treturn abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\n//点集合（多角形）の凸包を求める\n//Andrew's Monotone Chain\n//O(NlogN)（ソート依存）\nPolygon Convex_Hull(Polygon& p) {\n\tint n = p.size(), k = 0;\n\tif (n >= 3) {\n\t\tsort(p.begin(), p.end());\n\t\tvector< Point > ch(2 * n);\n\t\tfor (int i = 0; i < n; ch[k++] = p[i++]) {\n\t\t\tREP(i, ch.size()) {\n\t\t\t\t//cout << ch[i] << endl;\n\t\t\t}\n\t\t\t//cout << k << endl << i << endl << endl;\n\t\t\twhile (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n\t\t\twhile (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 2]) < 0) --k;\n\t\t}\n\t\tch.resize(k - 1);\n\t\treturn ch;\n\t}\n\telse {\n\t\treturn p;\n\t}\n}\n\n//2直線の交差判定\nbool Intersect(const Line &l, const Line &m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\n//2直線の交点\nPoint Crosspoint(const Line &l, const Line &m)\n{\n\tdouble A = cross(l.b - l.a, m.b - m.a);\n\tdouble B = cross(l.b - l.a, l.b - m.a);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n\treturn m.a + (m.b - m.a) * B / A;\n}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n//凸多角形の切断\n//直線に対して左側にある部分（交点を含む）を返す\nPolygon ConvexCut(Polygon &U, Line l)\n{\n\tPolygon ret;\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tPoint now = curr(U, i), nxt = next(U, i);\n\t\tif (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n\t\tif (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n\t\t\tret.push_back(Crosspoint(Line(now, nxt), l));\n\t\t}\n\t}\n\treturn (ret);\n}\n\n//多角形の面積\n//ただし返り値は求めたい値の2倍になっている\ndouble Area2(const Polygon &p)\n{\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i) {\n\t\tA += cross(p[i], p[(i + 1) % p.size()]);\n\t}\n\treturn A;\n}\n\n\nint xcomp(pair<ll,ll>& a, pair<ll,ll>& b) {\n\tif (a.first == b.first) {\n\t\treturn a.second<b.second;\n\t}\n\treturn a.first < b.first;\n}\n\n#define XSORT(c) sort((c).begin(),(c).end(),xcomp)\n\n#define ALL(x) (x).begin(),(x).end()\nll mod = 1000000007;\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tPolygon polygon;\n\n\tREP(i, n) {\n\t\tPoint point;\n\t\tcin >> point;\n\n\t\tpolygon.push_back(point);\n\t}\n\n\tdouble Sall = Area2(polygon)/2.0;\n\n\tLine linecut1;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tLine line(polygon[0], polygon[i]);\n\t\t\tdouble Scut = Sall-Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i - 1] + (polygon[i] - polygon[i - 1])*ratio;\n\t\t\t\tlinecut1.set(polygon[0], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tLine linecut2;\n\t{\n\t\tdouble Sprev = 0;\n\n\t\tfor (int i = n-2; i >= 0; --i) {\n\t\t\tLine line(polygon[n-1], polygon[i]);\n\t\t\tdouble Scut = Area2(ConvexCut(polygon, line)) / 2.0;\n\n\t\t\tif (Sall / 2.0 < Scut) {\n\t\t\t\tdouble ratio = (Sall / 2.0 - Sprev) / (Scut - Sprev);\n\t\t\t\tPoint pointcut = polygon[i + 1] + (polygon[i] - polygon[i + 1])*ratio;\n\t\t\t\tlinecut2.set(polygon[n-1], pointcut);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSprev = Scut;\n\t\t}\n\t}\n\n\tPoint crosspoint = Crosspoint(linecut1, linecut2);\n\n\tbool flag = true;\n\n\tREP(i, 1000) {\n\t\trandom_device rnd;     // 非決定的な乱数生成器を生成\n\t\tmt19937 mt(rnd());     //  メルセンヌ・ツイスタの32ビット版、引数は初期シード値\n\t\tuniform_int_distribution<> rand1000000(0, 1000000);        // [0, 99] 範囲の一様乱数\n\n\t\tPoint randompoint(rand1000000(mt), rand1000000(mt));\n\n\t\tLine randomline(crosspoint, randompoint);\n\n\t\tdouble Srandomcut = Area2(ConvexCut(polygon, randomline)) / 2.0;\n\n\t\tif (!eq(Sall, Srandomcut*2.0)) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag) {\n\t\tcout << crosspoint << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  cout<<a<<\" \"<<b<<endl;\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=a.s,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<math.h>\n#include<stdio.h>\nusing namespace std;\n\ntypedef complex<double> po;\nvector<po>vec;\n\nint main(){\n    int N;\n    cin>>N;\n    if(N%2==1){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    for(int i=0;i<N;i++){\n        double x,y;\n        cin>>x>>y;\n        vec.push_back(po(x,y));\n    }\n    int fini=1;\n    for(int i=0;i<N/2;i++){\n        double l1=abs(vec[i]-vec[(i+1)%N]);\n        double l2=abs(vec[N/2+i]-vec[(N/2+i+1)%N]);\n        double d1=abs(vec[i]-vec[(i+N/2+1)%N]);\n        double d2=abs(vec[i+1]-vec[(i+N/2)%N]);\n        if(abs(l1-l2)>=1e-5||abs(d1-d2)>=1e-5){\n            fini=0;\n            break;\n        }\n    }\n    if(fini==0)\n        cout<<\"NA\"<<endl;\n    else{\n        double x=0,y=0;\n        for(int i=0;i<N;i++){\n            x+=vec[i].real();\n            y+=vec[i].imag();\n        }\n        printf(\"%.6f %.6f\\n\",x/N,y/N);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std; vector<pair<long double, long double>>vec; long double X[100000], Y[100000], X1[100000], X2[100000], X3[100000], X4[100000], Y1[100000], Y2[100000], Y3[100000], Y4[100000], INF = 1e+14, EPS = 1e-14; int Q;\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; xp[0] = X1 - X2; yp[0] = Y1 - Y2; xp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }if (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }if ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }return false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { return make_pair(INF, INF); }\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }if (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }if (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }long double XP[4], YP[4], ZP[4];\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2; XP[1] = X3 - X4; YP[0] = Y1 - Y2; YP[1] = Y3 - Y4; ZP[0] = YP[0] / XP[0]; ZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1], K = (Y5 - Y1) / (ZP[0] - ZP[1]); long double L = K*ZP[0]; return make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; X2[i] = X[(i + Q / 2) % Q]; Y2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { if (fabs(vec[i].first - vec[i + 1].first) < EPS && fabs(vec[i].second - vec[i + 1].second) < EPS && vec[i].first < sqrtl(INF)) { cout << \"NA\" << endl; return; } }cout << fixed << setprecision(15) << vec[0].first << ' ' << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define equals(a,b) (abs(a-b)<1e-9)\n\nint main() {\n\tint n; cin >> n;\n\tvector<double> x(n), y(n);\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i];\n\tbool f = !(n & 1);\n\tdouble px = (x[0] + x[n / 2]) / 2, py = (y[0] + y[n / 2]) / 2;\n\tfor (int i = 1; i < n / 2; ++i) {\n\t\tif (!equals(px, (x[i] + x[n / 2 + i]) / 2)) f = false;\n\t\tif (!equals(py, (y[i] + y[n / 2 + i]) / 2)) f = false;\n\t}\n\tif (f) printf(\"%.10f %.10f\\n\", px, py);\n\telse cout << \"NA\" << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr long double EPS = 1e-10;\n\nclass Point{\n    public: \n    long double x,y;\n    Point(long double x = 0.0, long double y = 0.0): x(x), y(y) {}\n    Point operator + (const Point &p) const { return Point(x+p.x, y+p.y); }\n    Point operator - (const Point &p) const { return Point(x-p.x, y-p.y); }\n    Point operator * (const long double &a) const { return Point(x*a, y*a); }\n    Point operator / (const long double &a) const { return Point(x/a, y/a); }\n    Point operator += (const Point &p) {\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n    Point operator /= (const long double &a) {\n        x /= a;\n        y /= a;\n        return *this;\n    }\n    bool operator < (const Point &p) const { return (x != p.x ? x < p.x : y < p.y); }\n    bool operator == (const Point &p) const { return fabsl(x - p.x) < EPS && fabsl(y - p.y) < EPS; }\n    bool operator != (const Point &p) const { return !(*this == p);}\n    long double abs() const { return sqrt(norm()); }\n    long double norm() const { return x*x + y*y; }\n    long double dot(Point &p) const { return x*p.x + y*p.y; }\n    long double cross(Point &p) const { return x*p.y - y*p.x; }   \n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int n;\n    cin >> n;\n    Polygon poly(n);\n    Point center;\n    for(int i=0;i<n;++i){\n        cin >> poly[i].x >> poly[i].y;\n        center.x += poly[i].x;\n        center.y += poly[i].y;\n    }\n    center.x /= n;\n    center.y /= n;\n\n    if(n % 2) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    for(int i=0;i<n/2;++i) {\n        int j = i + n/2;\n        if((poly[i]-center) != (center - poly[j])) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n\n    cout << setprecision(10) << fixed << center.x << \" \" << center.y << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-12;\n\ntypedef complex<double> P;\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n\n  bool ok = true;\n  P p = (ps[0] + ps[N/2]) * 0.5;\n  REP(i, N / 2){\n    ok &= abs(p - (ps[i] + ps[N/2 + i]) * P(0.5)) < EPS;\n  }\n  \n  if(ok && N % 2 == 0){\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-3;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n\n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[i] - sumx;\n    double ay = y[i] - sumy;\n    double bx = x[(i+1)%n] - sumx;\n    double by = y[(i+1)%n] - sumy;\n    \n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n  \n  if(ok && ~n%2 && n<7) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n\n#include <complex>\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\n\n#define X real()\n#define Y imag()\n\nconst D EPS = 1e-9;\nconst D INF = 1e12;\n\n#define EQ(n,m) (abs((n) - (m)) < EPS)\n#define EX P(INF,INF)\n\nD cs(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\n\nD dt(P a, P b) {\n\treturn (conj(a) * b).X;\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a, c -= a;\n\tif (cs(b, c) > EPS)return 1;\n\tif (cs(b, c) < -EPS)return -1;\n\tif (dt(b, c) < -EPS)return +2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nP cpLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cs(b2 - b1, b1 - a1);\n\tD d2 = cs(b2 - b1, a2 - a1);\n\tif (EQ(d2, 0))return EX;\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\nVP cvcut(const VP &ps, P a, P b) {\n\tint n = ps.size();\n\tVP r;\n\trep(i, n) {\n\t\tint cc = ccw(a, b, ps[i]);\n\t\tif (cc != -1)r.push_back(ps[i]);\n//\t\tint cn = ccw(a, b, ps[(i + 1) % n]);\n//\t\tif (cc * cn == -1)r.push_back(cpLL(a, b, ps[i], ps[(i + 1) % n]));\n\t}\n\treturn r;\n}\n\nbool compare(VP &a, VP &b) {\n\tint n = a.size();\n\tif (b.size() != n)return false;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[j] != b[(i + j) % n]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok)return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tVP v;\n\tD maX = 0, maY = 0;\n\tD miX = INF, miY = INF;\n\n\trep(i, n) {\n\t\tD x, y;\n\t\tcin >> x >> y;\n\t\tmaX = max(maX, x);\n\t\tmaY = max(maY, y);\n\t\tmiX = min(miX, x);\n\t\tmiY = min(miY, y);\n\t\tv.push_back(P(x, y));\n\t}\n\tD tx = (maX - miX) / 2.0, ty = (maY - miY) / 2.0;\n\trep(i, n) {\n\t\tv[i] = P(v[i].X - tx, v[i].Y - ty);\n\t}\n\tmaX -= tx, miX -= tx, maY -= ty, miY -= ty;\n\n\t//????????????\n\t{\n\t\tP sp(miX, 0), tp(maX, 0);\n\t\tauto tv = cvcut(v, sp, tp);\n\t\tVP t;\n\t\tfor (auto p : tv) {\n\t\t\tt.push_back(P(p.X, -p.Y));\n\t\t}\n\t\treverse(t.begin(), t.end());\n\t\tfor (auto p : t) {\n\t\t\ttv.push_back(p);\n\t\t}\n\t\tif (compare(v,tv) == false) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//????????????\n\t{\n\t\tP sp(0, miY), tp(0, maY);\n\t\tauto tv = cvcut(v, sp, tp);\n\t\tVP t;\n\t\tfor (auto p : tv) {\n\t\t\tt.push_back(P(-p.X, p.Y));\n\t\t}\n\t\treverse(t.begin(), t.end());\n\t\tfor (auto p : t) {\n\t\t\ttv.push_back(p);\n\t\t}\n\t\tif (compare(v, tv) == false) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(30) << tx << \" \" << ty << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define EPS (1e-7)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)cout<<gx<<' '<<gy<<endl;\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<double,double> P;\n\nint main() {\n  int n;\n  cin >> n;\n  P a[n];\n  for(int i=0; i<n; i++) cin >> a[i].first >> a[i].second;\n  P p=P(a[0].first+a[n/2].first,a[0].second+a[n/2].second);\n  bool ok=1;\n  for(int i=1; i<n/2; i++) {\n    if(p!=P(a[i].first+a[i+n/2].first,a[i].second+a[i+n/2].second)) ok=0;\n  }\n  if(!ok || n%2) cout << \"NA\" << endl;\n  else printf(\"%.10f %.10f\\n\",p.first/2,p.second/2);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n  double norm() { return x * x + y * y; }\n  double abs() { return sqrt(norm()); }\n};\nstruct l_t{\n\tp_t a, b;\n};\n\ndouble cross(p_t p,p_t q);\np_t line(p_t p,p_t q);\n\nbool asc(p_t left,p_t right) {\n    return left.x == right.x ? left.y < right.y : left.x < right.x;\n}\np_t Crosspoint(l_t l,l_t m);\n\nint main(){\n  int n;\n  cin>>n;\n  vector<p_t> a;\n  p_t z;\n  for(int i=0;i<n;i++){\n    cin>>z.x>>z.y;\n    a.push_back(z);\n  }\n  if((n&1)==0){\n    z.x=(a[0].x+a[n/2].x)/2;\n    z.y=(a[0].y+a[n/2].y)/2;\n    int i;\n    for(i=2;i<n/2;i++){\n      if(eq(z.x,(a[i].x+a[i+n/2].x)/2)==0) break;\n      if(eq(z.y,(a[i].y+a[i+n/2].y)/2)==0) break;\n    }\n    if(i==n/2){\n      cout<<fixed<<z.x<<\" \"<<fixed<<z.y<<endl;\n      return 0;\n    }\n  }\n  cout<<\"NA\"<<endl;\n  return 0;\n}\n\n\np_t line(p_t p,p_t q){\n  p_t z;\n  z.x=q.x-p.x;\n  z.y=q.y-p.y;\n  return z;\n}\n\n\ndouble cross(p_t p,p_t q){\n  return p.x*q.y-p.y*q.x;\n}\n\np_t Crosspoint(l_t l,l_t m){\n  p_t aa,bb,cc,dd,ee;\n  aa.x=l.b.x-l.a.x;\n  aa.y=l.b.y-l.a.y;\n  bb.x=m.b.x-m.a.x;\n  bb.y=m.b.y-m.a.y;\n  cc=aa;\n  dd.x=l.b.x-m.a.x;\n  dd.y=l.b.y-m.a.y;\n\tdouble A = cross(aa,bb);\n\tdouble B = cross(cc,dd);\n\tif (abs(A) < EPS && abs(B) < EPS) return m.a;\n  ee.x=m.a.x+(m.b.x-m.a.x)*B/A;\n  ee.y=m.a.y+(m.b.y-m.a.y)*B/A;\n\treturn ee;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nint main(){\n    int n; cin>>n;\n    vector<double> x(n), y(n);\n    for(int i=0; i<n; i++) cin>>x[i]>>y[i];\n\n    vector<double> length;\n    for(int i=0; i<n; i++){\n        double dist = sqrt(abs(x[i] - x[(i+1)%n]) * abs(x[i] - x[(i+1)%n]) + abs(y[i] - y[(i+1)%n]) * abs(y[i] - y[(i+1)%n]));\n        length.emplace_back(dist);\n    }\n\n    if(n % 2 == 1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    bool valid = true;\n    for(int i=0; i<n/2; i++){\n        if(!equals(length[i], length[i+n/2])) valid = false;\n    }\n\n    if(valid){\n        double ansx = (x[0] + x[n/2]) / 2;\n        double ansy = (y[0] + y[n/2]) / 2;\n        printf(\"%.10f %.10f\\n\", ansx, ansy);\n    }\n    else{\n        cout << \"NA\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double INF = 1e+9;\nconst double EPS = 1e-6;\n\nbool equal(double a, double b){ return fabs(a-b) < EPS;}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\nbool equal(P a, P b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n\nint n;\nvector<P> v;\n\ndouble binary_search(bool is_h){\n  L l;\n  double le = -INF, ri = INF, mid;\n  vector<P> cut_v;\n\n  while(ri - le > EPS/100.0){\n    mid = (ri + le) / 2.0;\n    if(is_h) l = L(P(-INF, mid), P(INF, mid));\n    else l = L(P(mid, INF), P(mid, -INF));\n    cut_v = convex_cut(v, l);\n    if(area(v) > area(cut_v) * 2.0) ri = mid;\n    else le = mid;\n  }\n\n  return (ri + le) / 2.0;\n}\n\nP solve(){\n  P res = P(binary_search(false), binary_search(true));\n  bool f = true;\n\n \n  if(equal(area(v), area(convex_cut(v, L(res, res+P(1.0, 1.0)))) * 2.0) &&\n     equal(area(v), area(convex_cut(v, L(res, res+P(1.0, -1.0)))) * 2.0)) return res;\n  else return P(INF, INF);\n \n\n  if(n % 2) f = false;\n  else {\n    for(int i=0;i<n/2;i++){\n      if(!equal(v[i] - res, res - v[i+n/2])){\n        f = false;\n        break;\n      }\n    }\n  }\n\n  if(f) return res;\n  else return P(INF, INF);\n}\n\nint main(){\n  double x, y;\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      cin >> x >> y;\n      v.push_back(P(x, y));\n    }\n    P res = solve();\n    if(equal(res, P(INF, INF))) cout << \"NA\" << endl;\n    else printf(\"%.5f %.5f\\n\",res.real(),res.imag());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n//????§???¢???(0,0)???????????¨???????????¢\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//????§???¢?????????\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\n\nsigned main() {\n\tcout << fixed << setprecision(6);\n\tint N; cin >> N;\n\tPolygon P(N);\n\trep(i, 0, N)cin >> P[i];\n\tPoint c = center(P);\n\tfor (auto &p : P)p = p - c;\n\tPolygon Q = rotate(P, rad(180));\n\tsort(all(P));\n\tsort(all(Q));\n\tif (P == Q)cout << c << endl;\n\telse cout << \"NA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nll SUM(VI& V){\n  return accumulate(ALL(V), 0LL);\n}\n\nvoid print_vector(VI& V){\n  ll n = V.size();\n  rep(i, n){\n    if(i) cout << ' ';\n    cout << V[i];\n  }\n  cout << endl;\n}\n\nll gcd(ll a,ll b){\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n    ll g = gcd(a,b);\n    return a / g * b;\n}\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N; \n    cin>>N;\n\n    if(N%2==1){\n      p(\"NA\"); return 0;\n    }\n\n    vector<Point> P(N);\n    Point center;\n    rep(i,N){\n      cin>>P[i].x>>P[i].y;\n\n      center.x += P[i].x;\n      center.y += P[i].y;\n    }\n\n    center.x /= N;\n    center.y /= N;\n\n    rep(i, N/2){\n      Point a = P[i];\n      Point b = P[i+N/2];\n\n      Point v = a-center;\n      Point w = b-center;\n      w = w * -1.0;\n\n      auto diff = (v-w).abs();\n      if(!equals(0, diff)){\n        p(\"NA\"); return 0;\n      }\n    }\n\n    cout << setprecision(20);\n    p2(center.x, center.y);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<long double, long double> Point;\n\nconst long double EPS = 1e-15;\n\nlong double cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\nlong double dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b) - 0.0) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a = Point(input[i+1].first - input[i].first, input[i+1].second - input[i].second);\n    Point b = Point(input[(i+input.size()/2+1)%input.size()].first - input[i+input.size()/2].first,\n                    input[(i+input.size()/2+1)%input.size()].second - input[i+input.size()/2].second);\n    if(!isParallel(a, b)) return false;\n    if(!(abs(dist(a, Point(0.0, 0.0)) - dist(b, Point(0.0, 0.0))) < EPS)) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  \n  ans = Point((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else cout << ans.first << ' ' << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> xy_t;\n\nint main() {\n\n\tint N, x, y;\n\txy_t P[60];\n\n\tcin >> N;\n\n\tfor ( int i = 0; i < N; i++ ) {\n\n\t\tcin >> x >> y;\n\t\tP[i] = xy_t( x, y );\n\n\t}\n\n\tif ( N % 2 == 0 ) {\n\t\n\t\txy_t a = ( P[0] + P[N/2] ) * 0.5;\n\n\t\tfor ( int i = 1; i < N / 2; i++) {\n\n\t\t\txy_t b = ( P[i] + P[i+N/2] ) * 0.5;\n\t\t\n\t\t\tif ( abs( a - b ) < 1e-4 ) { \n\t\t\n\t\t\t\tprintf( \"%.5f %.5f\\n\", a.real(), a.imag() );\n\t\t\t\n\t\t\t\treturn 0;\n\t\t\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tcout << \"NA\" << endl;\n\t\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> polygon;\n\ndouble const eps = 1e-7;\n\npolygon poly;\n\nstruct line : public vector<P> {\n  line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ndouble dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\ndouble cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nint ccw(P const& p, P a, P b) {\n  a -= p, b -= p;\n  if(cross(a, b) > eps) return +1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nP crosspoint(line const& a, line const& b) {\n  auto va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < eps) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n\npolygon convex_cut(polygon const& g, line const& l) {\n  polygon ret;\n  int n = g.size();\n  rep(i, n) {\n    auto curr = g[i % n], next = g[(i + 1) % n];\n    if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n    if(ccw(l[0], l[1], curr) * ccw(l[0], l[1], next) < 0) {\n      ret.push_back(crosspoint(line(curr, next), l));\n    }\n  }\n  return ret;\n}\n\ndouble area(polygon const& g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i + 1) % g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\nbool ok(P const& p) {\n  double ph = area(poly) / 2.0;\n  for(double rad = 0.0; rad < 2 * cos(-1); rad += 0.01) {\n    line l = line(p, p + polar(1.0, rad));\n    auto k = convex_cut(poly, l);\n    if(abs((area(k) - ph) / ph) > eps) return false;\n  }\n  return true;\n}\n\nint main() {\n  int N; cin >> N;\n  P g;\n  rep(i, N) {\n    double x, y; cin >> x >> y;\n    poly.push_back(P(x, y));\n    g += P(x, y);\n  }\n  g /= N;\n  if(N % 2 || !ok(g)) cout << \"NA\" << endl;\n  else printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(3.14,0);\n        cerr << p << \" \" << find_opposite_point(ver,p,i) << endl;\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n    //[0,pi]\n    return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n    return a + (b - a) * (cross(d - c, c - a) /\n                          cross(d - c, b - a));\n}\n\nlong long n;\nvector<CP> points;\nCP ans(0,0);\n\nvoid solve();\n\nint main() {\n    cout << fixed << setprecision(10);\n  cin >> n;\n  for(int i = 0;i < n;++i){\n      long double x,y;\n      cin >> x >> y;\n      points.push_back(CP(x,y));\n  }\n  solve();\n  if(ans == CP(-1,-1))cout <<\"NA\" << endl;\n  else cout << ans.X << \" \" << ans.Y << endl;\n  return 0;\n}\n\n\nvoid solve(){\n    if(n % 2){\n        ans = CP(-1,-1);\n        return;\n    }\n    ans = (points[0] + points[n/2]);\n    ans /= 2;\n    for(int i = 0;i < n/2;++i){\n        CP now = (points[i] + (points[n/2+i]));\n        now /= 2;\n        if(abs(ans - now) > EPS){\n            ans = CP(-1,-1);\n            return;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n;\n\tcin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°?????¨??????????§°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\tvector<double> len(n);\n\trep(i, n - 1){\n\t\tdouble tmp = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tlen.push_back(tmp);\n\t}\n\tdouble tmp = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tlen.push_back(tmp);\n\tsort(all(len));\n\tif(len[n - 1] - len[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//????±???¨???????????????????±???????\n\tvector<double> Px;\n\tvector<double> Py;\n\trep(i, n / 2){\n\t\tdouble x = (point[i].fi + point[i + n / 2].fi) / 2.0;\n\t\tPx.push_back(x);\n\t\tdouble y = (point[i].se + point[i + n / 2].se) / 2.0;\n\t\tPy.push_back(y);\n\t\t//printf(\"%f %f %f\\n\", x, y, Py[i]);\n\t}\n\n\tsort(all(Px));\n\tif(Px[n / 2 - 1] - Px[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(Py));\n\tif(Py[n / 2 - 1] - Py[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n/*\n\t\n\trep(i, n / 2){\n\t\tprintf(\"%f %f\\n\", Px[i], Py[i]);\n\t}\n*/\t\n\n\tprintf(\"%.9f %.9f\\n\", Px[0], Py[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-10;\n\ndouble cross(Point a, Point b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b) - 0.0) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a = input[i+1] - input[i];\n    Point b = input[(i+input.size()/2+1)%input.size()] - input[i+input.size()/2];\n    if(!isParallel(a, b)) return false;\n    if(!(abs(abs(a) - abs(b)) < EPS)) return false;\n  }\n  ans = (input[0] - input[1]) + (input[input.size()/2] - input[input.size()/2+1]) / 2.0;\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.real() >> in.imag();\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else printf(\"%.5f %.5f\\n\", ans.real(), ans.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\n\nint main(){\n    int n;\n    cin>>n;\n    vector<P> p(n);    \n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        p[i]=P(x,y);\n    }\n    if(n%2){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    P res=P(0.5,0)*(p[0]+p[n/2]);\n    bool isok=true;\n    for(int i=0;i<n/2;i++){\n        isok&=(abs((p[i]+p[i+n/2])/P(2,0)-res)<1e-7);\n    }\n    if(isok){\n        cout<<setprecision(10)<<fixed;\n        cout<<res.real()<<\" \"<<res.imag()<<endl;\n    }\n    else{\n        cout<<\"NA\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ninline double SQ(double a){\n\treturn a * a;\n}\n\ninline bool EQ(double a, double b){\n\treturn abs(a - b) < EPS;\n}\n\ninline bool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\ninline bool LEQ(double a, double b){\n\treturn a - b < EPS;\n}\n\ninline bool GT(double a, double b){\n\treturn LT(b, a);\n}\n\ninline bool GEQ(double a, double b){\n\treturn LEQ(b, a);\n}\n\nusing Point = complex<double>;\n\n#define x() real()\n#define y() imag()\n\nnamespace std {\n\nbool operator < (const Point &a, const Point &b){\n\treturn a.x() != b.x() ? a.x() < b.x() : a.y() < b.y();\n}\n\ninline istream& operator >> (istream &is, Point &p){\n\tdouble x, y;\n\tis >> x >> y;\n\tp = Point(x, y);\n\treturn is;\n}\n\ninline ostream& operator << (ostream &os, const Point &p){\n\treturn os << p.x() << \" \" << p.y();\n}\n\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nusing Segment = Line;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\nusing Polygon = vector<Point>;\n\ndouble norm(const Point &a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\n\ndouble dot(const Point &a, const Point &b){\n\treturn (conj(a) * b).x();\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn (conj(a) * b).y();\n}\n\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(const Line &l, const Point &p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????§?????? or ????????´???\nbool intersectLL(const Line &l, const Line &m){\n\tPoint va = l.p2 - l.p1, vb = m.p2 - l.p1;\n\treturn !parallel(l, m) || EQ(cross(va, vb), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\tPoint va = l.p2 - l.p1, vb = s.p1 - l.p1, vc = s.p2 - l.p1;\n\treturn LEQ(cross(va, vb) * cross(va, vc), 0.0);\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\tPoint va = l.p1 - p, vb = l.p2 - p;\n\treturn EQ(cross(va, vb), 0.0);\n}\n\nbool intersectSS(const Segment &s, const Segment &t){\n\tPoint a = s.p1, b = s.p2, c = t.p1, d = t.p2;\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0\n\t\t&& ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn ccw(s.p1, s.p2, p) == ON_SEGMENT;\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tPolygon g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> g[i];\n\t}\n\t\n\tbool res = true;\n\t\n\tif (n & 1) res = false;\n\t\n\tfor (int i = 0; i < n / 2; i++){\n\t\tSegment s = {g[i], g[i + 1]};\n\t\tSegment t = {g[i + n / 2], (g[(i + n / 2 + 1) % g.size()])};\n\t\tif (!EQ(abs(s.p1 - s.p2), abs(t.p1 - t.p2))) res = false;\n\t\tif (!parallel(s, t)) res = false;\n\t}\n\t\n\tif (res){\n\t\tcout << (g[0] + g[n / 2]) / 2.0 << endl;\n\t}\n\telse {\n\t\tputs(\"NA\");\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout << fixed << setprecision(20);\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<long double, long double> Point;\n\nconst long double EPS = 1e-5;\n\nlong double cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\nlong double dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b) - 0.0) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a = Point(input[i+1].first - input[i].first, input[i+1].second - input[i].second);\n    Point b = Point(input[(i+input.size()/2+1)%input.size()].first - input[i+input.size()/2].first,\n                    input[(i+input.size()/2+1)%input.size()].second - input[i+input.size()/2].second);\n    if(!isParallel(a, b)) return false;\n    if(!(abs(dist(a, Point(0.0, 0.0)) - dist(b, Point(0.0, 0.0))) < EPS)) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  long double tmp = 0.0;\n  if(abs(a.first + b.first) < EPS) tmp = 333.0;\n  if(abs(a.second + b.second) < EPS) tmp = 333.0;\n  ans = Point((a.first+tmp + b.first+tmp) / 2.0, (a.second+tmp + b.second+tmp) / 2.0);\n  ans.first -= tmp;\n  ans.second -= tmp;\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else cout << ans.first << ' ' << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N;\n  cin>>N;\n  float x[N],y[N];\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  float tx,ty;\n  tx=(x[0]+x[N/2])/2;\n  ty=(y[0]+y[N/2])/2;\n\n  for(int i=0;N/2+i<N;i++){\n    int a,b,c,d;\n    a=i;\n    b=N/2+i-1;\n    c=N/2+i;\n    d=i-1;\n    if(d==-1) d=N-1;\n    if(!((x[d]-x[a]==x[c]-x[b])&&(y[d]-y[a]==y[c]-y[b]))){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  printf(\"%f %f\\n\",tx,ty);\n  return 0;\n}\n/*\nint main(){\n  int N;\n  cin>>N;\n  float x[N],y[N];\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  float tx,ty;\n  tx=(x[0]+x[N/2])/2;\n  ty=(y[0]+y[N/2])/2;\n  //cout<<\" \"<<\" \"<<tx<<\" \"<<ty<<endl;\n  for(int i=0;i<N/2;i++){\n    float dx=(x[i]+x[i+N/2])/2,dy=(y[i]+y[i+N/2])/2;\n    if(max(abs(dy-ty),abs(dx-tx))>0.0001){\n      cout<<\"NA\"<<endl;\n  //    cout<<dx<<\" \"<<dy<<\" \"<<tx<<\" \"<<ty<<endl;\n      return 0;\n    }\n  }\n  float k=pow(abs(x[i+1]-x[i]),2)+pow(abs(y[i+1]-y[i]),2);\n  float l=pow(abs(x[1]-x[0]),2)+pow(abs(y[1]-y[0]),2);\n  for(int i=0;i<N-1;i++){\n    if(abs(l-k)>=1){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  printf(\"%f %f\\n\",tx,ty);\n  return 0;\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  cout<<a<<\" \"<<b<<endl;\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=a.s,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n\nclass Point {\npublic:\n\tPoint();\n\tPoint(int x_in, int y_in);\n\n\tPoint  operator+(const Point& obj);\n\tPoint  operator-(const Point& obj);\n\tPoint  operator*(const double n);\n\tPoint  operator/(const double n);\n\n\tvoid set(int x_in, int y_in);\n\n\tdouble x;\n\tdouble y;\n};\n\nPoint::Point() {\n\tx = 0;\n\ty = 0;\n}\n\nPoint::Point(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\nPoint Point::operator+(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x + obj.x;\n\ttemp.y = y + obj.y;\n\treturn temp;\n}\n\nPoint Point::operator-(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x - obj.x;\n\ttemp.y = y - obj.y;\n\treturn temp;\n}\n\nPoint Point::operator*(const double n) {\n\tPoint temp;\n\ttemp.x = x * n;\n\ttemp.y = y * n;\n\treturn temp;\n}\n\nPoint Point::operator/(const double n) {\n\tPoint temp;\n\ttemp.x = x / n;\n\ttemp.y = y / n;\n\treturn temp;\n}\n\nvoid Point::set(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\ndouble abs(Point point) {\n\treturn sqrt(point.x * point.x + point.y * point.y);\n}\n\nint N;\nPoint V[50];\n\nstd::string solve() {\n\tif (N % 2 != 0) return \"NA\";\n\tPoint center = (V[0] + V[N / 2]) / 2;\n\tfor (int i = 1; i < N / 2; i++) {\n\t\tPoint median = (V[i] + V[i + N / 2]) / 2;\n\t\tPoint dist = center - median;\n\t\tif (abs(dist) >= 0.0001) {\n\t\t\treturn \"NA\";\n\t\t}\n\t}\n\tstd::ostringstream str;\n\tstr << center.x << \" \" << center.y;\n\treturn str.str();\n}\n\nint main() {\n\t//入力\n\tstd::cin >> N;\n\tint x, y;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> x >> y;\n\t\tV[i].set(x, y);\n\t}\n\t/*for (int i = 0; i < N; i++) {\n\t\tstd::cout << V[i].x * 2 << \" \" << V[i].y * 2 << std::endl;\n\t}*/\n\t//演算\n\tstd::string answer = solve();\n\t//出力\n\tstd::cout << answer << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //??????\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //??????\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //??????\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //??????\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //?????????\n\tdouble abs() { return sqrt(norm()); }   //??§??????\n\tvoid normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}\t//??£??????\n};\nstruct C{P p;double r;};    //???\nstruct S{P p1,p2;};         //??????\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\ntypedef S L;                //??´???\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<P> pol,pol2;\n\tP min1=P(INF,INF),min2=P(INF,INF);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpol.pb(P(x,y));\n\t\tpol2.pb(P(-x,-y));\n\t\tmin1 = min(min1,P(x,y));\n\t\tmin2 = min(min2,P(-x,-y));\n\t}\n\t\n\trep(i,n){\n\t\tpol2[i]=pol2[i]+(min1-min2);\n\t}\n\t\n\tP cent;\n\trep(i,n)cent=cent+pol[i];\n\tcent=cent/n;\n\t\n\tsort(all(pol)),sort(all(pol2));\n\t\n\tbool f = true;\n\trep(i,n)if(abs(pol[i].x-pol2[i].x)>1e-9&&abs(pol[i].y-pol2[i].y)>1e-9)f=false;\n\tif(f)printf(\"%.20lf %.20lf\\n\",cent.x,cent.y);\n\telse cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint sqr(int x) { return x * x; }\n\nstruct Point { int x, y; };\n\nvoid putd(double d) { cout << setprecision(9) << setiosflags(ios::fixed) << d; }\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tvector< Point > vp(N);\n\t\n\tfor_(i,0,N) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tvp[i] = Point{x, y};\n\t}\n\t\n\tbool is_collect = (N % 2 == 0);\n\tint collect_dst = -1;\n\t\n\tfor_(i,0,N) {\n\t\tPoint a = vp[i], b = vp[(i + 1) % N];\n\t\tint dst = sqr(a.x - b.x) + sqr(a.y - b.y);\n\t\t\n\t\tif (collect_dst == -1) collect_dst = dst;\n\t\telse is_collect &= (collect_dst == dst);\n\t}\n\t\n\tif (!is_collect) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tdouble cx = 0, cy = 0;\n\t\n\tfor_(i,0,N) {\n\t\tcx += vp[i].x;\n\t\tcy += vp[i].y;\n\t}\n\t\n\tputd(cx / (double)N);\n\tcout << \" \";\n\tputd(cy / (double)N);\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(getdis(a,p[i])!=getdis(a,p[n/2+i]))an=0;\n  }\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else cout<<a.f<<\" \"<<a.s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-5)<b&&b<a+(1e-5);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2==1)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",a.f,a.s);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-8)\n\nint n;\n\nbool EQ(double a, double b){\n  if(fabs(a - b) < EPS){\n    return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> n){\n    vector<P> pol;\n\n    for(int i = 0; i < n; i++){\n      P p;\n      cin >> p.real() >> p.imag();\n      pol.push_back(p);\n    }\n\n    if(n % 2 != 0){\n      cout << \"NA\\n\";\n      continue;\n    }\n\n    bool flg = true;\n\n    for(int i = 0; i < n; i++){\n      int j = (i + n / 2) % n;\n\n      P va = pol[i] - pol[(i + 1) % n];\n      P vb = pol[(j + 1) % n] - pol[j];\n\n      if(!EQ(va.real(), vb.real()) || !EQ(va.imag(), vb.imag())){\n        flg = false;\n        break;\n      }\n    }\n\n    if(!flg){\n      cout << \"NA\\n\";\n    }\n    else{\n      P ans = (pol[0] + pol[n / 2]) / 2.0;\n      printf(\"%.10f %.10f\\n\", ans.real(), ans.imag());\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cout.precision(16);\n    cout.setf(ios::fixed);\n    \n    int N; cin >> N;\n    vector<double> X(N), Y(N);\n    for(int i=0; i<N; i++)\n        cin >> X[i] >> Y[i];\n    \n    bool ok = true;\n    for(int i=0; i<N/2; i++){\n        int dx = X[i+1] - X[i] + X[(i+1+N/2)%N] - X[i+N/2];\n        int dy = Y[i+1] - Y[i] + Y[(i+1+N/2)%N] - Y[i+N/2];\n        if(dx != 0 || dy != 0)\n            ok = false;\n    }\n    \n    if(ok){\n        cout << (X[0]+X[N/2])/2 << \" \" << (Y[0]+Y[N/2])/2 << endl;;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, X[50], Y[50], sx, sy; double gx, gy;\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &X[i], &Y[i]);\n\t\tsx += X[i];\n\t\tsy += Y[i];\n\t}\n\tgx = 1.0 * sx / N;\n\tgy = 1.0 * sy / N;\n\tif(N % 2 == 1) {\n\t\tprintf(\"NA\\n\");\n\t}\n\telse {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < N / 2; i++) {\n\t\t\tflag = flag && ((gx - X[i]) * 2 == (X[N / 2 + i] - X[i]) && (gy - Y[i]) * 2 == (Y[N / 2 + i] - Y[i]));\n\t\t}\n\t\tif(flag) {\n\t\t\tprintf(\"%.9f %.9f\\n\", gx, gy);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-4;\nconst double INF = 1000000001.0;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\nbool isInter(L s1, L s2){\n   return ( ccw(s1.first ,s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 &&\n\t    ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nP crossPoint(L l, L m){\n   double A = cross(l.second - l.first, m.second - m.first);\n   double B = cross(l.second - l.first, l.second - m.first);\n   if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n   else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\ndouble area(vector<P> v){\n   double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\nvector<P> convex_cut(vector<P> G, L l){\n   vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\nbool equal(double a, double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, double theta){\n   theta = theta * M_PI / 180.0;\n   double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      double l = miny;\n      double r = maxy;\n      double all = area(v);\n      L yoko, tate;\n      while(1){\n//\t cout << l << ' ' << r << endl;\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(-INF,mid),P(INF,mid))));\n\t if(equal(half*2.0, all)){\n\t    yoko = L(P(-INF,mid),P(INF,mid));\n\t    break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(mid,INF),P(mid,-INF))));\n\t if(equal(half*2.0, all)){\n\t    tate = L(P(mid,-INF),P(mid,INF));\n\t    break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n//      printf(\"%.5f %.5f  \",real(ans),imag(ans));\n\n      for(double i=0.0;i<180.0;i+=1.0){\n\t L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\t double half = area(convex_cut(v,line));\n\t if(!equal(half*2.0,all)){\n//\t    printf(\"%.5f %.5f \",half*2.0, all);\n\t    f = false;\n\t    break;\n\t }\n      }\n      if(f) printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5,0);\n        point op = find_opposite_point(ver,p,i);\n        cerr << p << \" \" << op << endl;\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                cerr << p << endl;\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\nline half_line(vector<point> &g, int t){\n\tpoint p = g[t];\n\tdouble half = area(g)/2.0;\n\tdouble sum = 0.0;\n\tint i;\n\tdouble s;\n\tint n = g.size();\n\tfor(i=0;i<g.size();i++){\n\t\t s = cross(g[(i+t+1)%n]-p,g[(i+t+2)%n]-p)/2.0;\n\t\tif(s+sum+EPS>half)break;\n\t\telse sum+= s;\n\t}\n\t//cout<<t<<\": \"<<i+t+1<<' '<<half-sum<<' '<<s+sum-half<<endl;\n\tpoint a= g[(i+t+1)%n]*(s-half+sum) ,b= g[(i+t+2)%n]*(half-sum);\n\tpoint p2 = a+b;\n\tp2 = p2/s;\n\treturn  make(p,p2);\n}\npoint err = point(1e9,1e9);\npoint solve(vector<point> &g){\n\tdouble S =  area(g);\n\tdouble half = S/2.0;\n\tint n = g.size();\n\tvector<line>  l(n);\n\tfor(int i= 0;i<n;i++) l[i] = half_line(g,i);\n\tvector<point> ps(n);\n\tbool f = false;\n\tfor(int i=0;i<n;i++) ps[i] =  crosspoint(l[i],l[(i+1)%n] );\n\t//for(int i=0;i<n;i++) cout<<i<<\":  \"<<l[i].e.x<<' '<<l[i].e.y<<endl;\n\tfor(int i=0;i<n;i++)if(ps[i] == ps[(i+1)%n] ){\n\n\t}else{\n\t\treturn err;\n\t}\n\n\treturn ps[0];\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<point> g(n);\n\tfor(int i=0;i<n;i++) g[i] = make();\n\tpoint ans = solve(g);\n\tif(ans == err||n==3){\n\t\tcout<<\"NA\"<<endl;\n\t}else{\n\t\t//cout<<ans.x<<' '<<ans.y<<endl;\n\t\tprintf(\"%0.6lf %0.6lf\\n\",ans.x,ans.y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nusing P = pair<double,double>;\nP merge(P a,P b){\n  return P((a.first+b.first)/2,(a.second+b.second)/2);\n}\n\nbool check(P a,P b){\n  return max(abs(a.first-b.first),abs(a.second-b.second)) < 0.00001;\n}\n\nint main(){\n  int n = in();\n  if(n&1){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  vector<P> line(n);\n  foreach(i,line)cin>>i;\n  vector<P> mids;\n  rep(i,n/2){\n    mids.emplace_back(merge(line[i],line[i+n/2]));\n  }\n  rep(i,n/2){\n    rep(j,n/2){\n      if(!check(mids[i],mids[j])){\n        cout << \"NA\" << endl;\n        return 0;\n      }\n    }\n  }\n  printf(\"%.20lf %.20lf\\n\",mids[0].first,mids[0].second);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nP centroidG(G g) {\n    int n = g.size();\n    double x = 0, y = 0;\n    rep(i, n) {\n        x += g[i].real();\n        y += g[i].imag();\n    }\n    return P(x / n, y / n);\n}\n\n// rot p around q by theta (counter-clockwise)\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nG rotG(G g, P p, double theta) {\n    rep(i, g.size()) {\n        g[i] = rotP(g[i], p, theta);\n    }\n    return g;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG() {\n    int n;\n    cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nbool EQ(double a, double b) {\n    return abs(a - b) < EPS;\n}\n\nbool EqP(P p, P q) {\n    return EQ(p.real(), q.real()) && EQ(p.imag(), q.imag());\n}\n\nbool EqG(G g, G h) {\n    if (g.size() != h.size()) return false;\n    rep(k, g.size()) {\n        bool flag = true;\n        rep(i, g.size()) {\n            if (!EqP(g[(i + k) % g.size()], h[i])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// void printG(G g) {\n//     rep(i, g.size()) {\n//         cout << g[i].real() << \" \" << g[i].imag() << endl;\n//     }\n//     cout << endl;\n// }\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    G g = readG();\n    P c = centroidG(g);\n    // cout << fixed << setprecision(10) << c.real() << \" \" << c.imag() << endl;\n    // cout << endl;\n\n    G h = rotG(g, c, PI);\n    // printG(g);\n    // printG(h);\n\n    if (EqG(g, h)) {\n        cout << fixed << setprecision(10) << c.real() << \" \" << c.imag() << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Info{\n\tPoint p1,p2;\n};\n\ndouble calc_len(Info info){\n\treturn sqrt((info.p1.x-info.p2.x)*(info.p1.x-info.p2.x)+(info.p1.y-info.p2.y)*(info.p1.y-info.p2.y));\n}\n\ndouble calc_slope(Info info){\n\tif(fabs(info.p1.x-info.p2.x) < EPS){\n\t\treturn DBL_MAX;\n\t}else{\n\t\treturn (info.p2.y-info.p1.y)/(info.p2.x-info.p1.x);\n\t}\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\tif(N%2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\tInfo info[N];\n\tPoint point[N];\n\tscanf(\"%lf %lf\",&info[0].p1.x,&info[0].p1.y);\n\tpoint[0].x = info[0].p1.x;\n\tpoint[0].y = info[0].p1.y;\n\n\tfor(int i = 1; i <= N-1; i++){\n\t\tscanf(\"%lf %lf\",&info[i-1].p2.x,&info[i-1].p2.y);\n\t\tinfo[i].p1.x = info[i-1].p2.x;\n\t\tinfo[i].p1.y = info[i-1].p2.y;\n\n\t\tpoint[i].x = info[i-1].p2.x;\n\t\tpoint[i].y = info[i-1].p2.y;\n\n\t}\n\tinfo[N-1].p2.x = info[0].p1.x;\n\tinfo[N-1].p2.y = info[0].p1.y;\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < N/2; i++){\n\t\tif(calc_len(info[i]) != calc_len(info[i+N/2])){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}\n\t\tif(calc_slope(info[i]) != calc_slope(info[i+N/2])){\n\t\t\tFLG = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(FLG){\n\t\tprintf(\"%.10lf %.10lf\\n\",(point[0].x+point[N/2].x)/2.0,(point[0].y+point[N/2].y)/2.0);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline long double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline long double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tlong double res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\ninline point middle(const point& a, const point& b) {\n\treturn (a + b) / 2.0;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tif(n & 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(point(x, y));\n\t}\n\n\tconst line l1(middle(p[0], p[1]), middle(p[2], p[3]));\n\tconst line l2(middle(p[1], p[2]), middle(p[3], p[(3 + 1) % n]));\n\n\tconst point ans = crosspoint(l1, l2);\n\tprintf(\"%.10lf %.10lf\\n\", ans.x, ans.y);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tvector<Point> ps;\n\tbool f = true;\n\tif (n % 2) f = false;\n\tREP(i,n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tps.push_back(Point(x, y));\n\t}\n\tvector<Line> v, w;\n\tREP(i, n / 2)\n\t{\n\t\tv.push_back(Line(ps[i], ps[i + 1]));\n\t\tw.push_back(Line(ps[i + n / 2], ps[(i + n / 2 + 1) % n]));\n\t}\n\tREP(i, n / 2)\n\t{\n\t\tif (abs(v[i].a - v[i].b) != abs(w[i].a - w[i].b) || isis_ll(v[i], w[i])) f = false;\n\t}\n\tif (f)\n\t{\n\t\tLine l1(ps[0], ps[n / 2]), l2(ps[1], ps[n / 2 + 1]);\n\t\tPoint p = is_ll(l1, l2);\n\t\tcout << D10 << p.real() << \" \" << p.imag() << endl;\n\t}\n\telse puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<double,double> pd;\n\nconst double eps=1e-8;\nint main()\n{\n    int n;\n    cin >>n;\n\n    vector<pd> p(n);\n    rep(i,n) scanf(\" %lf %lf\", &p[i].fi, &p[i].se);\n\n    if(n%2==1)\n    {\n        printf(\"NA\\n\");\n        return 0;\n    }\n\n    //gravity point\n    pd g=pd(0,0);\n    rep(i,n)\n    {\n        g.fi+=p[i].fi;\n        g.se+=p[i].se;\n    }\n    g.fi/=n;\n    g.se/=n;\n\n    bool valid=true;\n    rep(i,n/2)\n    {\n        pd v1=pd(p[i].fi-g.fi,p[i].se-g.se);\n        pd v2=pd(p[i+n/2].fi-g.fi,p[i+n/2].se-g.se);\n\n        if(fabs(v1.fi+v2.fi)>=eps || fabs(v1.se+v2.se)>=eps)\n        {\n            valid=false;\n            break;\n        }\n    }\n\n    if(valid) printf(\"%lf %lf\\n\",g.fi,g.se);\n    else printf(\"NA\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define EPS 1e-10\n#define PI acos(-1)\n\nbool isParallel(P a, P b)\n{\n\tdouble aa = arg(a);\n\tif (aa < 0) aa = arg(-a);\n\tif (aa < EPS) aa = PI;\n\n\tdouble ba = arg(b);\n\tif (ba < 0) ba = arg(-b);\n\tif (ba < EPS) ba = PI;\n\n\tif (abs(aa - ba) < EPS)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main()\n{\n\tint N; cin >> N;\n\tif (N % 2 == 1)\n\t{\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tvector<P> xy(N);\n\trep(i, 0, N)\n\t{\n\t\tdouble x, y; cin >> x >> y;\n\t\txy[i] = P(x, y);\n\t}\n\n\trep(i, 0, N / 2 - 1)\n\t{\n\t\tP va = xy[i] - xy[i + 1];\n\t\tP vb = xy[i + N / 2] - xy[i + N / 2 + 1];\n\n\t\tif (!(abs(abs(va) - abs(vb)) < EPS))\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!isParallel(va, vb))\n\t\t{\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble ans_x = (real(xy[0]) + real(xy[N / 2])) / 2.0;\n\tdouble ans_y = (imag(xy[0]) + imag(xy[N / 2])) / 2.0;\n\n\tprintf(\"%.10f %.10f\\n\", ans_x, ans_y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; x = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; y = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-4)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(getdis(a,p[i])!=getdis(a,p[n/2+i]))an=0;\n  }\n  double x=a.f,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 20000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n        if(n % 2 == 1){\n            cout << \"NA\" << endl;\n            continue;\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half*2.0 > all) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF/abs(ans-v[i])));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2442.cc: ConvexCut\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50;\nconst int ITL = 100;\n\nconst double DELTA = 1.0e-4;\nconst double DINF = 1e18;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n\n/* global variables */\n\n/* subroutines */\n\nbool cross_lines(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  double op01 = av.cross(bv);\n  //if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  if (op01 == 0.0) {\n    pt v = bp - ap;\n    if (v.cross(av) != 0.0) return false;\n\n    pt a1 = ap + av;\n    pt b1 = bp + bv;\n\n    return\n      ((bp - ap).dot(b1 - ap) <= 0.0 ||\n       (bp - a1).dot(b1 - a1) <= 0.0 ||\n       (ap - bp).dot(a1 - bp) <= 0.0 ||\n       (ap - b1).dot(a1 - b1) <= 0.0);\n  }\n\n  pt v = bp - ap;\n  double op0 = v.cross(av);\n  double op1 = v.cross(bv);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = bv * t1 + bp;\n  cl.t0 = t0;\n  cl.t1 = t1;\n\n  return true;\n  //return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\nvoid convex_cut(const vpt& scpol, vpt& dcpol, const pt& p0, const pt& p1) {\n  int n = scpol.size();\n  pt pv = p1 - p0;\n  dcpol.clear();\n\n  for (int i = 0; i < n; i++) {\n    const pt& cp0 = scpol[i];\n    double cr0 = pv.cross(cp0 - p0);\n    if (cr0 >= 0.0) dcpol.push_back(cp0);\n    \n    const pt& cp1 = scpol[(i + 1) % n];\n    double cr1 = pv.cross(cp1 - p0);\n    if (cr0 * cr1 < 0.0) {\n      CL cl;\n      cross_lines(p0, pv, cp0, cp1 - cp0, cl);\n      dcpol.push_back(cl.p);\n    }\n  }\n}\n\ndouble calc_area(const vpt& cpol) {\n  int nc = cpol.size();\n  if (nc < 3) return 0.0;\n\n  double area = 0.0;\n  for (int i = 0; i < nc; i++) {\n    const pt &p0 = cpol[i], &p1 = cpol[(i + 1) % nc];\n    area += p0.cross(p1);\n  }\n\n  return (area / 2);\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  vpt pol;\n  double minx = DINF, maxx = -DINF, miny = DINF, maxy = -DINF;\n\n  \n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    pol.push_back(pt(x, y));\n    if (minx > x) minx = x;\n    if (maxx < x) maxx = x;\n    if (miny > y) miny = y;\n    if (maxy < y) maxy = y;\n  }\n\n  double pah = calc_area(pol) / 2;\n  //printf(\"pah=%.6lf\\n\", pah);\n\n  double cx0 = minx, cx1= maxx;\n  for (int i = 0; i < ITL; i++) {\n    double cx = (cx0 + cx1) / 2;\n    pt p0(cx, miny), p1(cx, maxy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cx=%.6lf => ca=%.6lf\\n\", cx, ca);\n    \n    if (ca < pah) cx0 = cx;\n    else cx1 = cx;\n  }\n  //printf(\"cx0=%.6lf, cx1=%.6lf\\n\", cx0, cx1);\n\n  double cy0 = miny, cy1= maxy;\n  for (int i = 0; i < ITL; i++) {\n    double cy = (cy0 + cy1) / 2;\n    pt p0(minx, cy), p1(maxx, cy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cy=%.6lf => ca=%.6lf\\n\", cy, ca);\n\n    if (ca > pah) cy0 = cy;\n    else cy1 = cy;\n  }\n  //printf(\"cy0=%.6lf, cy1=%.6lf\\n\", cy0, cy1);\n\n  bool ok = true;\n  pt cp0(cx0, cy0);\n\n  for (int i = 0; i < n; i++) {\n    vpt cpol;\n    convex_cut(pol, cpol, cp0, pol[i]);\n    double ca = calc_area(cpol);\n\n    double d = abs(pah - ca) / pah;\n    if (d > DELTA) {\n      //printf(\"d=%.6lf\\n\", d);\n      ok = false;\n      break;\n    }\n  }\n  \n  if (ok) printf(\"%.6lf %.6lf\\n\", cx0, cy0);\n  else cout << \"NA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  vector<P> v;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n    v.push_back(ps[i]);\n  }\n  avgx/=N;avgy/=N;\n  P avgp=P(avgx,avgy);\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  for(int i=0;i<N;i++){\n    int cnt=0;\n    for(int j=0;j<N;j++)\n      if(EQV(ps[i],ps2[j]))cnt++;\n    if(cnt!=1){\n      cout<<\"NA\"<<endl;\n      return 0;\n    }\n  }\n  printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\nline half_line(vector<point> &g, int t){\n\tpoint p = g[t];\n\tdouble half = area(g)/2.0;\n\tdouble sum = 0.0;\n\tint i;\n\tdouble s;\n\tint n = g.size();\n\tfor(i=0;i<g.size();i++){\n\t\t s = cross(g[(i+t+1)%n]-p,g[(i+t+2)%n]-p)/2.0;\n\t\tif(s+sum+EPS>half)break;\n\t\telse sum+= s;\n\t}\n\t//cout<<t<<\": \"<<i+t+1<<' '<<half-sum<<' '<<s+sum-half<<endl;\n\tpoint a= g[(i+t+1)%n]*(s-half+sum) ,b= g[(i+t+2)%n]*(half-sum);\n\tpoint p2 = a+b;\n\tp2 = p2/s;\n\treturn  make(p,p2);\n}\npoint err = point(1e9,1e9);\npoint solve(vector<point> &g){\n\tdouble S =  area(g);\n\tdouble half = S/2.0;\n\tint n = g.size();\n\tvector<line>  l(n);\n\tfor(int i= 0;i<n;i++) l[i] = half_line(g,i);\n\tvector<point> ps(n);\n\tbool f = false;\n\tfor(int i=0;i<n;i++) ps[i] =  crosspoint(l[i],l[(i+n/4+1)%n] );\n\t//for(int i=0;i<n;i++) cout<<i<<\":  \"<<l[i].e.x<<' '<<l[i].e.y<<endl;\n\t//for(int i=0;i<n;i++) printf(\"%d: %0.6lf %0.6lf\\n\",i,ps[i].x,ps[i].y);\n\tfor(int i=0;i<n;i++)if(abs(ps[i]-ps[(i+1)%n] ) <1e-6 ){\n\n\t}else{\n\t\treturn err;\n\t}\n\n\treturn ps[0];\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<point> g(n);\n\tfor(int i=0;i<n;i++) g[i] = make();\n\tpoint ans = solve(g);\n\tif(ans == err||n==3){\n\t\tcout<<\"NA\"<<endl;\n\t}else{\n\t\t//cout<<ans.x<<' '<<ans.y<<endl;\n\t\tprintf(\"%0.6lf %0.6lf\\n\",ans.x,ans.y);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int N; scanf(\"%d\", &N);\n  int *X = new int[N];\n  int *Y = new int[N];\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d%d\", X+i, Y+i);\n  }\n  if(N%2) {\n    printf(\"NA\\n\");\n    return 0;\n  }\n  int x = X[0] + X[N/2];\n  int y = Y[0] + Y[N/2];\n  for(int i = 1; i < N/2; i++) {\n    if(x != X[i] + X[i+N/2] ||\n       y != Y[i] + Y[i+N/2]) {\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.5f %.5f\\n\", x/2.0, y/2.0);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-6;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{\n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  \n  bool operator < (Point p)const{return (p.x!=x)?x<p.x:y<p.y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n  if (b.cross(c) > 0) return +1; // counter clockwise\n  if (b.cross(c) < 0) return -1; // clockwise\n  if (b.dot(c) < 0) return +2; // c--a--b on line\n  if (b.norm() < c.norm()) return -2; // a--b--c on line\n  return 0; // a--c--b on line\n}\n\nstruct Line{\n  Point a,b;\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n};\n\nstruct Segment: public Line{\n  Segment(){}\n  Segment(Point a,Point b):Line(a,b){}\n  bool on(Point c){return ccw(a,b,c)==0;}\n  bool on(Line l){return l.on(a)&&l.on(b);}\n  bool overlap(Segment s){\n    return isParallel(s) && (on(s.a)||on(s.b)||s.on(a)||s.on(b));\n  }\n  bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n  Real dist(Point c){\n    if((b-a).dot(c-a)<EPS)return c.dist(a);\n    if((a-b).dot(c-b)<EPS)return c.dist(b);\n    return abs((b-a).cross(c-a))/b.dist(a);\n  }\n\n  bool isIntersection(Line l){\n    return (ccw(l.a,l.b,a)*ccw(l.a,l.b,b)<0);\n  }\n\n  bool isIntersection(Segment s){\n    return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n\t    ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n  }\n\n  Point intersectionPoint(Segment s){\n    Point q=s.b-s.a;\n    Real d1=abs(q.cross(a-s.a));\n    Real d2=abs(q.cross(b-s.a));\n    Real t=d1/(d1+d2);\n    return a+(b-a)*t;\n  }\n  \n  Point intersectionPoint(Line l){\n    if(isIntersection(l)){\n      return intersectionPoint(Segment(l.a,l.b));\n    }\n    cout << \"came\" << endl;\n  }\n};\n\n\nstruct Polygon{\n  vector<Point>v;\n  Polygon(){}\n  Polygon(int n){v.resize(n);}\n  Polygon(vector<Point>v):v(v){}\n\n  void resize(int n){\n    v.resize(n);\n  }\n\n  Real area(){\n    Real area=0;\n    for(int i=0;i<v.size();i++)\n      area+=(curr(v,i).x-next(v,i).x)*(curr(v,i).y+next(v,i).y);\n    return abs(area)/2.0;\n  }\n\n  Polygon convexCut(Line l){\n    vector<Point>res;\n    for(int i=0;i<v.size();i++){\n      Point a=curr(v,i),b=next(v,i),p=l.b-l.a;\n      if(ccw(l.a,l.b,a)!=-1)res.push_back(a);\n      if(sgn(p.cross(a-l.a)*p.cross(b-l.a))<0)\n\tres.push_back(Segment(a,b).intersectionPoint(l));\n    }\n    return res;\n  }\n};\n\nReal maxx,maxy;\nPolygon pol;\n\nReal f(Real x){\n  Polygon l=pol.convexCut(Line(Point(x,0),Point(x,maxy)));\n  Polygon r=pol.convexCut(Line(Point(x,maxy),Point(x,0)));\n  return abs(l.area()-r.area());\n}\n\nReal f2(Real y){\n  Polygon l=pol.convexCut(Line(Point(0,y),Point(maxx,y)));\n  Polygon r=pol.convexCut(Line(Point(maxx,y),Point(0,y)));\n  return abs(l.area()-r.area());\n}\n\nconst int maxLoop=72;\nReal searchX(Real l,Real r){\n  for(int loop=0;loop<maxLoop;loop++){\n    if(f((l*2+r)/3)>f((l+r*2)/3))r=(l+r*2)/3;\n    else l=(l*2+r)/3;\n  }\n  return (l+r)/4;\n}\n\nReal searchY(Real l,Real r){\n  for(int loop=0;loop<maxLoop;loop++){\n    if(f2((l*2+r)/3)>f2((l+r*2)/3))r=(l+r*2)/3;\n    else l=(l*2+r)/3;\n  }\n  return (l+r)/4;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n  pol.resize(n);\n  for(int i=0;i<n;i++){\n    cin >> pol.v[i].x >> pol.v[i].y;\n    maxx=max(maxx,pol.v[i].x);\n    maxy=max(maxy,pol.v[i].y);\n  }\n\n  Point res=Point(searchX(0,maxx),searchY(0,maxy));\n  bool can=true;\n  for(int i=0;i<1000;i++){\n    for(int j=0;j<<pol.v.size();j++){\n      pol.v[j]=pol.v[j].rotate(0.0001,res);\n    }\n    can&=f(res.x)<EPS;\n  }\n\n  if(can)printf(\"%.5f %.5f\\n\",res.x,res.y);\n  else cout << \"NA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline long double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline long double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tlong double res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\ninline point middle(const point& a, const point& b) {\n\treturn (a + b) / 2.0;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tif(n & 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(x, y);\n\t}\n\n\tconst line l1 = line(middle(p[0], p[1]), middle(p[2], p[3]));\n\tconst line l2 = line(middle(p[1], p[2]), middle(p[3], p[(3 + 1) % n]));\n\n\tconst point ans = crosspoint(l1, l2);\n\tprintf(\"%.10lf %.10lf\\n\", ans.x, ans.y);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n    int size = g.size() / 2;\n    if(size % 2) return Point{INF,INF};\n\n    set<Point> s;\n    rep(i,size){\n        rep(j,size){\n            if(i == j) continue;\n            s.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n        }\n    }\n    if(size > 1) return Point{INF,INF};\n    return *s.begin();\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g(n);\n    rep(i,n){\n        double x, y;\n        cin >> x >> y;\n        g[i] = Point(x,y);\n    }\n    if(n % 2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    Point ans = pointSymmetry(g);\n    if(ans.imag() == INF &&  ans.real() == INF) cout << \"NA\" << endl;\n    else cout <<fixed << setprecision(5)<< ans.real() << ' ' << ans.imag() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double R;\ntypedef complex<R> P;\nconst R EPS = 1e-9;\n\nbool near(R x1, R y1, R x2, R y2) {\n    return abs(P(x1, y1)-P(x2, y2)) < EPS;\n}\n\nconst int MN = 55;\nR x[MN], y[MN];\n\nint main() {\n    int n;\n    cin >> n;\n    if (n % 2) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    R X = 0, Y = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        X += x[i]; Y += y[i];\n    }\n    X /= n;\n    Y /= n;\n    for (int i = 0; i < n; i++) {\n        if (!near(X*2, Y*2, x[i]+x[(i+n/2)%n], y[i]+y[(i+n/2)%n])) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    printf(\"%Lf %Lf\\n\", X, Y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  cout << fixed << setprecision(15);\n  \n  int N, X[50], Y[50];\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i];\n  }\n\n  bool flag = N % 2;\n  auto x = X[0] + X[N / 2], y = Y[0] + Y[N / 2];\n  for(int i = 1; i < N / 2; i++) {\n    flag |= x != X[i] + X[i + N / 2];\n    flag |= y != Y[i] + Y[i + N / 2];\n  }\n  if(flag) cout << \"NA\" << endl;\n  else cout << x / 2.0 << \" \" << y / 2.0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n?????????????????¨?????????????????¨????????????\n????±???¨?????????????????????????????¨????????????????????¨???????????´??????????????°???????????¶???????????°??¢\n*/\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n\nconst double EPS = 1e-14;\nint main(void){\n\tll n; cin >> n;\n\tvector<pair<double, double> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%lf %lf\", &point[i].fi, &point[i].se);\n\n\t//n????\\???°??????????????????\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\tvector<double> len(n);\n\trep(i, n - 1){\n\t\tdouble tmp = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tlen.push_back(tmp);\n\t}\n\tdouble tmp = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tlen.push_back(tmp);\n\tsort(all(len));\n\tif(len[n - 1] - len[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//????±???¨????????????????????????????±???????\n\tvector<double> Px;\n\tvector<double> Py;\n\trep(i, n / 2){\n\t\tdouble x = (point[i].fi + point[i + n / 2].fi) / 2.0;\n\t\tPx.push_back(x);\n\t\tdouble y = (point[i].se + point[i + n / 2].se) / 2.0;\n\t\tPy.push_back(y);\n\t}\n\n\t//?????§?±???????????±???¨??????????????????????????????????????§??????????????¨?°?????????????????????´??????????????°??????????±???§??????\n\tsort(all(Px));\n\tif(Px[n / 2 - 1] - Px[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tsort(all(Py));\n\tif(Py[n / 2 - 1] - Py[0] > EPS){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\tprintf(\"%.9f %.9f\\n\", Px[0], Py[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto & it:v)\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\n#define IL inline\n#define X real()\n#define Y imag()\nIL D dot(P a,P b){\n    return a.X*b.X+a.Y*b.Y;\n}\nIL D cross(P a,P b){\n    return a.X*b.Y-a.Y*b.X;\n}\n\n\nIL D ccw(P a,P b,P c){\n    return cross(b-a,c-a);\n}\n\n\nIL D convex_area(Poly pp){\n    D res=0;\n    for(int i=2,n=pp.size();i<n;i++)\n\tres+=abs(ccw(pp[0],pp[i-1],pp[i]))/2,0;\n    return res;\n}\n\nstruct INIT{\n    INIT(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout<<fixed;\n\tcout<<setprecision(10);\n    }\n}init;\n\nIL P convex_gravity_point(Poly& pp){\n    P g(0,0);\n    D s=0;\n    for(int i=2,n=pp.size();i<n;i++){\n\tD t=convex_area({pp[0],pp[i-1],pp[i]});\n\tg+=t*(pp[0]+pp[i-1]+pp[i])/3.0;\n\ts+=t;\n    }\n    return g/s;\n}\nint main(){\n    int N;\n    cin>>N;\n    Poly p(N);\n    rep(i,N){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i]=P(x,y);\n    }\n    auto g=convex_gravity_point(p);\n    if(N&1)cout<<\"NA\"<<endl;\n    else{\n\tint M=N/2;\n\trep(i,M){\n\t    auto a=p[i]-g,b=g-p[i+M];\n\t    if(abs(a.X-b.X)>1e-8||abs(a.Y-b.Y)>1e-8){\n\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t    }\n\t}\n\tcout<<g.X<<\" \"<<g.Y<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!(abs(a[i]+a[(i+n/2)%n])/2-c)<=0.0001||!(abs(b[i]+b[(i+n/2)%n])/2-c)<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\n#define VN(v) # v\n#define print(a) cout << a << \"#\" << VN(a) << endl;\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    vld x(n), y(n); rep(i, x.size()) cin >> x[i] >> y[i];\n    if (n % 2) { cout << \"NA\" << endl; return 0; }\n    ld xc = x[0] + x[n/2], yc = y[0] + y[n/2];\n    rep(i, n/2) {\n        if (abs(xc - (x[i] + x[i+n/2])) > EPS || abs(yc - (y[i] + y[i+n/2])) > EPS) {\n            cout << \"NA\" << endl; \n            return 0;\n        }\n        xc = (x[i] + x[i+n/2]);\n        yc = (y[i] + y[i+n/2]);\n    }\n\n    cout << ldout << xc/2 << \" \" << yc/2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define EPS 1e-10\n#define PI acos(-1)\n\nint main()\n{\n\tint N; cin >> N;\n\tif (N != 4)\n\t{\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tvector<P> xy(N);\n\trep(i, 0, N)\n\t{\n\t\tdouble x, y; cin >> x >> y;\n\t\txy[i] = P(x, y);\n\t}\n\n\tdouble ad = abs(xy[0] - xy[1]);\n\tdouble bd = abs(xy[2] - xy[3]);\n\tif (!(abs(ad - bd) < EPS))\n\t{\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tdouble aa = arg(xy[0] - xy[1]);\n\tif (aa < 0) aa = arg(xy[1] - xy[0]);\n\tif (aa < EPS) aa = PI;\n\tdouble ba = arg(xy[2] - xy[3]);\n\tif (ba < 0) ba = arg(xy[3] - xy[2]);\n\tif (ba < EPS) ba = PI;\n\tif (!(abs(aa - ba) < EPS))\n\t{\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tdouble ans_x = (real(xy[0]) + real(xy[2])) / 2.0;\n\tdouble ans_y = (imag(xy[0]) + imag(xy[2])) / 2.0;\n\n\tprintf(\"%.10f %.10f\\n\", ans_x, ans_y);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2442&lang=jp\n// references:http://purple-jwl.hatenablog.com/entry/20121013/1350099039\ntypedef pair<int, int> Point;\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<Point> P(N);\n\tfor (int i = 0; i < N;i++) {\n\t\tint X, Y; cin >> X >> Y;\n\t\tP[i] = { X,Y };\n\t}\n\tif (N % 2 != 0) { cout << \"NA\" << endl; return 0; }\n\n\tint H = N / 2;\n\tfor (int i = 0; i < H;i++) {\n\t\tint l1 = pow(P[i].first - P[(i + 1) % N].first, 2) + pow(P[i].second - P[(i + 1) % N].second, 2);\n\t\tint l2 = pow(P[i + H].first - P[(i + 1 + H) % N].first, 2) + pow(P[i + H].second - P[(i + 1 + H) % N].second, 2);\n\t\tint l3 = pow(P[i].first - P[(i + 1 + H) % N].first, 2) + pow(P[i].second - P[(i + 1 + H) % N].second, 2);\n\t\tint l4 = pow(P[(i + 1)%N].first - P[i + H].first, 2) + pow(P[(i + 1)%N].second - P[i + H].second, 2);\n\t\tif (l1 == l2 && l3 == l4) continue;\n\t\telse cout << \"NA\" << endl; return 0;\n\t}\n\n\tdouble gx, gy; gx = gy = 0;\n\tfor (int i = 0; i < N;i++) {\n\t\tgx += (double)P[i].first;\n\t\tgy += (double)P[i].second;\n\t}\n\tgx /= (double)N;\n\tgy /= (double)N;\n\tcout << fixed << setprecision(20) << gx << \" \" << gy << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-3;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n\n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[i] - sumx;\n    double ay = y[i] - sumy;\n    double bx = x[(i+1)%n] - sumx;\n    double by = y[(i+1)%n] - sumy;\n    \n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n\n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\nint main(){\n    int N; cin>>N;\n    vec V[N];\n    for(auto& v:V) cin>>v.x>>v.y;\n    if(N%2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    vec M[N/2];\n    for(int i=0;i<N/2;i++){\n        M[i]=(V[i]+V[N/2+i])*0.5;\n    }\n    for(int i=1;i<N/2;i++){\n        if((M[0]-M[i]).norm()>1e-4){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << M[0].x << \" \" << M[0].y << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\ndouble arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nP line_cp(L a,L b){\n  double A = cross(b.sc-b.fs,b.fs-a.fs);\n  double B = cross(b.sc-b.fs,a.sc-a.fs);\n  if(abs(A) < EPS){\n    if(abs(B) < EPS)return a.fs; //same line\n    //else assert(false);\n  }\n  return a.fs+(a.sc-a.fs)*A/B;\n}\n\n//for polygon\n\n//all vertex is already sorted.\ndouble area(Poly p){\n  if(p.size()<3)return 0;\n  double res = cross(p[p.size()-1],p[0]);\n  for(int i=1;i<p.size();i++)res += cross(p[i-1],p[i]);\n  return res/2;\n}\n\n//all vertex is already sorted.\nPoly convex_cut(Poly p,L l){\n  Poly res;\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    int nxt = (i+1)%n;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      //cout << line_cp(l, L(p[i],p[nxt]) ) << endl;\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n;\n  Poly p;\n\n  scanf(\"%d\",&n);\n  p.resize(n);\n  for(int i=0;i<n;i++)scanf(\"%lf%lf\",&p[i].real(),&p[i].imag());\n  double s = area(p)/2;\n\n  double ux=p[0].real(),lx=p[0].real(),ly=p[0].imag();\n\n  for(int i=1;i<n;i++){\n    ux = max(ux,p[i].real());\n    lx = min(lx,p[i].real());\n    ly = min(ly,p[i].imag());\n  }\n  ux += 1e-2; lx -= 1e-2; ly -= 1e-2;\n\n  P a[2];\n  a[0] = P(ux,ly); a[1] = P(lx,ly);\n  L line[2];\n\n  for(int i=0;i<2;i++){\n    double l,r,mid;\n    if(i==0){l = PI/2; r = PI;}\n    else{l= 0; r = PI/2;}\n    for(int j=0;j<100;j++){\n      mid = (l+r)/2;\n      L tmp = L(a[i],a[i]+rotate(P(1,0),mid));\n      double cut = area(convex_cut(p,tmp));\n      if(cut + EPS < s)r = mid;\n      else l = mid;\n    }\n    line[i] = L(a[i],a[i]+rotate(P(1,0),r));\n  }\n\n  P res = line_cp(line[0],line[1]);\n  for(int i=0;i<n;i++){\n    L tmp = L(res,p[i]);\n    Poly hoge = convex_cut(p,tmp);\n    //for(int i=0;i<hoge.size();i++)cout << hoge[i] << endl;\n    //printf(\"%.10lf\\n\",s-area(hoge));\n    if(abs(s - area(convex_cut(p,tmp))) > 1e-5){\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.8lf %.8lf\\n\",res.real(),res.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\n//????§???¢??????????±???¨??????????????§?¨?\nPoint pointSymmetry(Polygon g){\n    int size = g.size() / 2;\n    if(g.size() % 2) return Point{INF,INF};\n\n    set<Point> s;\n    rep(i,size){\n        rep(j,size){\n            if(i == j) continue;\n            s.insert(intersectionLs(g[i], g[i + size], g[j], g[j + size]));\n        }\n    }\n    if(s.size() > 1) return Point{INF,INF};\n    return *s.begin();\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    Polygon g(n);\n    rep(i,n){\n        double x, y;\n        cin >> x >> y;\n        g[i] = Point(x,y);\n    }\n    if(n % 2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    Point ans = pointSymmetry(g);\n    if(ans.imag() == INF &&  ans.real() == INF) cout << \"NA\" << endl;\n    else cout <<fixed << setprecision(5)<< ans.real() << ' ' << ans.imag() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll x[100],y[100];;\n\nll len(int a,int b){\n  return (x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]);\n}\n\nbool para(int a1,int a2,int b1, int b2){\n  return (x[a1]-x[a2])*(y[b1]-y[b2]) - (x[b1]-x[b2])*(y[a1]-y[a2]) == 0;\n}\n\nint main(){\n  ll cx=0,cy=0;\n\n  scanf(\"%d\",&n);\n  for(int i=0;i<n;i++){\n    scanf(\"%lld%lld\",&x[i],&y[i]);\n    cx += x[i]; cy += y[i];\n  }\n\n  if(n&1){\n    printf(\"NA\\n\"); return 0;\n  }\n\n  for(int i=0;i<n/2;i++){\n    int op = i + n/2, nx = i+1, opnx = (op+1)%n;\n    if(len(i,nx) != len(op,opnx) || !para(i,nx,op,opnx)){\n      printf(\"NA\\n\"); return 0;\n    }\n  }\n  printf(\"%.8lf %.8lf\\n\",(double)cx/n,(double)cy/n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<pint> vpint;\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(ll i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tvector<pair<int, int> > point(n);//fi???;x??§?¨???? se ;y??§?¨?\n\trep(i, n) scanf(\"%d %d\", &point[i].fi, &point[i].se);\n\n\tif(n % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\n\t//???????????§??????\n\trep(i, n - 2){\n\t\tdouble len1 = pow(point[i + 1].fi - point[i].fi, 2) + pow(point[i + 1].se - point[i].se, 2);\n\t\tdouble len2 = pow(point[i + 2].fi - point[i + 1].fi, 2) + pow(point[i + 2].se - point[i + 1].se, 2);\n\t\tif(abs(len2 - len1) > 0.00001){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tdouble len0 = pow(point[0].fi - point[n - 1].fi, 2) + pow(point[0].se - point[n - 1].se, 2);\n\tdouble lenf = pow(point[n - 1].fi - point[n - 2].fi, 2) + pow(point[n - 1].se - point[n - 2].se, 2);\n\tif(len0 - lenf > 0.00001){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tdouble x1 = ((double)point[0].fi + (double)point[n / 2].fi) / 2.0;\n\tdouble y1 = ((double)point[0].se + (double)point[n / 2].se) / 2.0;\n\n\treps(i, 1, n / 2){\n\t\tdouble x2 = ((double)point[i].se + (double)point[i + n / 2].se) / 2.0;\n\t\tdouble y2 = ((double)point[i].se + (double)point[i + n / 2].se) / 2.0;\n\t\tif(abs(x1 - x2) > 0.00001 || abs(y1 - y2) > 0.00001){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\tprintf(\"%.9f %.9f\\n\", x1, y1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nstruct Point{double x,y;};\n\nint main(void){\n    int N;\n    bool NA = false;\n    cin>>N;\n    vector<Point> p(N);\n    rep(i,N)cin>>p[i].x>>p[i].y;\n    NA = N&1;\n    Point G = {(p[0].x+p[N/2].x)/2.0 , (p[0].y+p[N/2].y)/2.0};\n    rep1(i,N/2-1) NA |= ((p[i].x+p[i+N/2].x)/2.0!=G.x || (p[i].y+p[i+N/2].y)/2.0!=G.y);\n    if(NA)cout<<\"NA\"<<endl;\n    else printf(\"%.5f %.5f\\n\",G.x,G.y);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef double Real;\n\nReal eps = 1e-12;\n\nReal add(Real a, Real b) {\n    if (abs(a+b) < eps * (abs(a)+abs(b))) return 0;\n    return a+b;\n}\n\nbool equal(Real a, Real b) {\n    return add(a, -b) == 0;\n}\n\nstruct P {\n    Real x, y;\n    P() {}\n    P(Real x, Real y) : x(x), y(y) {}\n    P operator+(P p) const {return P(add(x, p.x), add(y, p.y));}\n    P operator-(P p) const {return P(add(x, -p.x), add(y, -p.y));}\n    P operator*(Real d) const {return P(x*d, y*d);}\n    Real dot(P p) const {return add(x*p.x, y*p.y);} // ??????\n    Real det(P p) const {return add(x*p.y, -y*p.x);} // ??????\n    Real dist(P p) const {return sqrt((x-p.x)*(x-p.x) + (y-p.y)*(y-p.y));} // ?????¢\n    void normalize() {Real d = sqrt(x*x+y*y); x /= d; y /= d;} // ??£??????\n    bool operator<(const P& rhs) const {\n        if (x != rhs.x) return x < rhs.x;\n        return y < rhs.y;\n    }\n    bool operator==(const P& rhs) const {\n        return equal(x, rhs.x) && equal(y, rhs.y);\n    }\n};\n\n// ??????p1-p2?????????q???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n    return (p1-q).det(p2-q) == 0 && (p1-q).dot(p2-q) <= 0;\n}\n\n// ??´???p1-p2??¨??´???q1-q2??????????????????????????????\nbool parallel(P p1, P p2, P q1, P q2) {\n    P a = p2-p1;\n    P b = q2-q1;\n    return a.det(b) == 0;\n}\n\nconst int MAXN = 55;\nP pnts[MAXN];\nint n;\n\nvoid solve() {\n    if (n % 2 == 1) {\n        cout << \"NA\" << endl;\n        return;\n    }\n    double ax = 0, ay = 0;\n    for (int i = 0; i < n; i++) {\n        ax += pnts[i].x;\n        ay += pnts[i].y;\n    }\n    ax /= n; ay /= n;\n    P a(ax, ay);\n    for (int i = 0; i < n/2; i++) {\n        if (!on_seg(pnts[i], pnts[i+n/2], a) || a.dist(pnts[i]) != a.dist(pnts[i+n/2])) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    cout << ax << \" \" << ay << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> pnts[i].x >> pnts[i].y;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-6;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\nP interpoint_s(P a1 , P a2 , P b1 , P b2){\n  P b=b2-b1;\n  double d1=fabs(cross(b , a1-b1));\n  double d2=fabs(cross(b , a2-b1));\n  double t=d1 / (d1 + d2);\n  P a=a2-a1;\n  P v=a*t;\n  return a1+v;\n}\n\nbool diff(P p, P q){\n  return abs(p.x - q.x) >= EPS || abs(p.y - q.y) >= EPS;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<P> ps(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y;\n\n  bool ok = true;\n  P p;\n  if(N < 4 || N%2) ok = false;\n  else{\n\tint D = N / 2;\n\tp = interpoint_s(ps[0], ps[D], ps[1], ps[D+1]);\n\tfor(int i=1;i<D;++i){\n\t  P q = interpoint_s(ps[0], ps[D], ps[i], ps[i+D]);\n\t  if(diff(p,q)){\n\t\tok = false; break;\n\t  }\n\t}\n  }\n  if(!ok) cout << \"NA\" << endl;\n  else cout << fixed << setprecision(9) << p.x << \" \" << p.y << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(const vector<P>& G, L l){\n  vector<P> ans;\n  for(int i=0;i<(int)G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\ndouble getAngle(P a,P b){\n  return atan2(b.real()-a.real(),b.imag()-a.imag());\n}\n\ndouble getDeg(double a){\n  return 180/M_PI*a;\n}\n\nbool eq(P a,P b){\n  if( abs(a-b) < 1E-6 ) return true;\n  return false;\n}\n\nint N;\nvector<P> V;\n\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin >> x >> y;\n    V.push_back( P(x,y) );\n  }\n\n  double ar = area(V);\n  if( ar < 0.0 ){\n    reverse(V.begin(),V.end());\n    ar = abs(ar);\n  }\n\n  vector<L> seg;\n  for(int i=0;i<N;i++){\n    int pr = (i+N-1)%N;\n    int nd = (i+1)%N;\n    double st = getAngle(V[i],V[pr]);\n    double ed = getAngle(V[i],V[nd]);\n    // cout << V[pr] << \" \"<< V[i] << \" \"<< V[nd] << endl;\n    //cout << getDeg(st) << \" \"<< getDeg(ed) << endl;\n    if( st > ed ) ed += 2.0*M_PI;\n    //cout << getDeg(st) << \" \"<< getDeg(ed) << endl;\n    while( abs(ed-st)>EPS ){\n      double h = (st+ed)/2.0;\n\n\n      P c = P(V[i].real()+sin(h),V[i].imag()+cos(h));\n      L s = L(V[i],c);\n      vector<P> r = convex_cut(V,s);\n      double ret = area(r);\n      //cout << s.first << \" \"<< s.second << endl;    \n          \n      //cout << \"ret = \"<< ret<< endl;\n      if( ret < ar/2.0  ){\n        st = h;\n      }  else {\n        ed = h;\n      }\n    }\n    P c = P(V[i].real()+sin(st),V[i].imag()+cos(st));\n    //cout << V[i] << \" \"<< c << endl;\n    seg.push_back( L(V[i],c) );\n  }\n  vector<P> poin;\n  for(int i=0;i<(int)seg.size();i++){\n    for( int j=0;j<(int)seg.size();j++){\n      if( i == j ) continue;\n      poin.push_back( crossPoint(seg[i],seg[j]) );\n    }\n  }\n  bool f = true;\n  for(int i=0;i+1<(int)poin.size();i++){\n    //    cout << poin[i] <<\" \"<< eq(poin[i],poin[i+1]) << endl;\n    if( !eq(poin[i],poin[i+1]) ) f = false;\n  }\n  if( f ) printf(\"%.10lf %.10lf\\n\",poin[0].real() , poin[0].imag() );\n  else cout << \"NA\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-12;\n\ntypedef complex<long double> P;\nlong double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nlong double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  long double A = cross(l[1] - l[0], m[1] - m[0]);\n  long double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    int j = (i + N / 2) % N;\n    ok &= !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N]));\n  }\n  \n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\n#define repi(i,j,n) for (int i = (j); i < (n); ++i)\n#define rep(i,n) repi(i,0,n)\n#define INF 1e9\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n/**************************** Geometry short ver ********************************/\n\nclass P {\npublic:\n  double x, y;\n  P(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n  P operator + (P p) {\n    return P(x + p.x, y + p.y);\n  }\n  P operator - (P p) {\n    return P(x - p.x, y - p.y);\n  }\n  P operator * (double c) {\n    return P(c * x, c * y);\n  }\n  P operator / (double c) {\n    return P(x / c, y / c);\n  }\n  bool operator < (const P &p) const {\n    return (x != p.x ? x < p.x : y < p.y);\n  }\n  bool operator == (const P &p) const {\n    return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n  }\n  bool operator != (const P &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n  }\n  double norm() {\n    return (x * x + y * y);\n  }\n\n  double abs() {\n    return sqrt(norm());\n  }\n};\n\ntypedef P V;\n\ndouble dot(V a, V b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(V a, V b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(V a) {\n  return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(V a) {\n  return sqrt(norm(a));\n}\n\nclass S {\npublic:\n  P s, e; // start, end\n  S(P s = P(), P e = P()) : s(s), e(e) {}\n};\n\ntypedef S L;\n\ntypedef vector<P> Polygon;\n\ndouble dP(P a, P b) {\n  return (a - b).abs();\n}\n\ndouble dL(L l, P p) {\n  return abs(cross(l.e - l.s, p - l.s) / abs(l.e - l.s));\n}\n\ndouble dS(S s, P p) {\n  if (dot(s.e - s.s, p - s.s) < 0.0) return abs(p - s.s);\n  if (dot(s.s - s.e, p - s.e) < 0.0) return abs(p - s.e);\n  return dL(s, p);\n}\n\nconst int CCW = 1, CW = -1, OB = 2, OF = -2, OS = 0;\n\nint ccw(P x, P y, P z) {\n  V a = y - x, b = z - x;\n\n  if (cross(a, b) > EPS) return CCW;\n  if (cross(a, b) < -EPS) return CW;\n  if (dot(a, b) < -EPS) return OB;\n  if (a.norm() < b.norm()) return OF;\n  return OS;\n}\n\nbool intersect(P a, P b, P c, P d) {\n  return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(S a, S b) {\n  return intersect(a.s, a.e, b.s, b.e);\n}\n\ndouble dSS(S a, S b) {\n  if (intersect(a, b)) return 0.0;\n  return min(min(dS(a, b.s), dS(a, b.e)), min(dS(b, a.s), dS(b, a.e)));\n}\n\nP crossP(S a, S b) {\n  V base = b.e - b.s;\n  double d1 = abs(cross(base, a.s - b.s));\n  double d2 = abs(cross(base, a.e - b.s));\n  double t = d1 / (d1 + d2);\n  return a.s + (a.e - a.s) * t;\n}\n\n/* IN 2, ON 1, OUT 0*/\nint contains(Polygon g, P p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nint n, x, y;\nvector<P> v;\n\nP solve() {\n    int a = n / 2;\n    double len = 0.0, tmpl;\n    P points, tmpp;\n\n    len = dP(v[0], v[a]);\n    points = P((v[0].x + v[a].x) / 2.0, (v[0].y + v[a].y) / 2.0);\n\n    repi(i,1,n/2) {\n        tmpl = dP(v[i], v[i + a]);\n        tmpp = P((v[i].x + v[i + a].x) / 2.0, (v[i].y + v[i + a].y) / 2.0);\n\n        if (tmpp != points || len != tmpl) {\n            return P(INF, INF);\n        }\n    }\n\n    return points;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n\n    rep(i,n) {\n        cin >> x >> y;\n        v.push_back(P(x, y));\n    }\n\n    if (n % 2) cout << \"NA\" << endl;\n    else {\n        P ans = solve();\n        if (ans.x == INF) cout << \"NA\" << endl;\n        else cout << ans.x << \" \" << ans.y << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-3;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n  \n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[(i+1)%n] - x[i];\n    double ay = y[(i+1)%n] - y[i];\n    double bx = x[(i+1+n/2)%n] - x[(i+n/2)%n];\n    double by = y[(i+1+n/2)%n] - y[(i+n/2)%n];\n    ok &= abs(ax*by - bx*ay) < EPS;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    continue;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n  \n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <math.h>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t}\n\tcx = (p[0][0] + p[n/2][0]) / 2;\n\tcy = (p[0][1] + p[n/2][1]) / 2;\n\tif(n%2) f=1;\n\telse for(i = 1; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) / 2 - cx) <= 0.0000001 && fabs((p[i][1] + p[i + n/2][1]) / 2 - cy) <= 0.0000001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse cout << cx << \" \" << cy << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-5;\nconst long double INF = 10000000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\n\nP crossPoint(L l, L m){\n   long double A = cross(l.second - l.first, m.second - m.first);\n   long double B = cross(l.second - l.first, l.second - m.first);\n   if(abs(A) < EPS && abs(B) < EPS) return m.first;\n   else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n   long double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n   theta = theta * M_PI / 180.0;\n   long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t long double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      long double l = miny;\n      long double r = maxy;\n      long double all = area(v);\n      L yoko, tate;\n      while(1){\n\t long double mid = (l + r) / 2.0;\n\t long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   yoko = L(P(-INF,mid),P(INF,mid));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t long double mid = (l + r) / 2.0;\n\t long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   tate = L(P(mid,-INF),P(mid,INF));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n      //printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n\n      for(int i=0;i<v.size();i++){\n\t//L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\tL line = L(v[i], (ans + (ans-v[i])*INF));\n\tlong double half = area(convex_cut(v,line));\n\tif(!equal(half*2.0,all)){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) printf(\"%.5Lf %.5Lf\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint main() {\n  int N;\n  cin >> N;\n  \n  vector<P> vec;\n  for (int i = 0; i < N; i++) {\n    double x, y;\n    cin >> x >> y;\n    vec.push_back(P(x, y));\n  }\n\n  vector<double> dist(N);\n  for (int i = 0; i < N; i++) {\n    \n    dist[i] = abs(vec[i] - vec[(N + i - 1) % N]);\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (dist[0] != dist[i]) {\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n\n  P p(0, 0);\n  for (int i = 0; i < N; i++) {\n    p = p + vec[i];\n  }\n\n  p = P(p.real() / N, p.imag() / N);\n\n  printf(\"%.12f %.12f\\n\", p.real(), p.imag());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nPoint a[50];\nint main(){\n\tcout << fixed << setprecision(10);\n\tint n; cin >> n;\n\trep(i, n) {\n\t\tld x, y; cin >> x >> y;\n\t\ta[i] = { x,y };\n\t}\n\tbool out = true;\n\tPoint ans;\n\tif (n % 2)out = false;\n\telse {\n\t\tint d = n / 2;\n\t\tans = a[0] + a[d];\n\t\tans = { real(ans) / 2.0,imag(ans) / 2.0 };\n\t\trep(i, d) {\n\t\t\tPoint mid = a[i] + a[i + d];\n\t\t\tmid = { real(mid) / 2.0,imag(mid) / 2.0 };\n\t\t\tif (abs(mid - ans) > eps)out = false;\n\t\t}\n\t}\n\tif (!out) {\n\t\tcout << \"NA\" << endl;\n\t}\n\telse {\n\t\tcout << real(ans) << \" \" << imag(ans) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#ifdef MBP\n#include \"stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define REP(i, n) for (long long int i = 0, i##_len = (n); i < i##_len; ++i)\n#define REP1(i, n) for (long long int i = 1, i##_len = (n); i <= i##_len; ++i)\n#define REP_R(i, n) for (long long int i = (n - 1); i >= 0; --i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((long long int)(x).size())\n#define BIT(n) (1LL << (n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\n//#define DEBUG\n\n#ifdef DEBUG\n#define OUT(x) std::cout << (x) << std::endl\n#define OUT2(x, y) std::cout << (x) << \",\" << (y) << std::endl\n#define OUT3(x, y, z) std::cout << (x) << \",\" << (y) << \",\" << (z) << std::endl\n#define OUTSP(x) std::cout << (x) << \" \";\n#define OUTLF std::cout << std::endl\n#define OUTPA(p) OUT2(p.first, p.second)\n#else\n#define OUT(x) NULL\n#define OUT2(x, y) NULL\n#define OUT3(x, y, z) NULL\n#define OUTPA(p) NULL\n#define OUTSP(p) NULL\n#define OUTLF NULL\n#endif\n\n#define INF INT_MAX\n#define INFLL LLONG_MAX\n#define PB push_back\n#define MOD 1000000007LL\n\n#define LSB(x) __builtin_ctzll(x)\n#define MSB(x) 64LL - __builtin_clzll(x) - 1LL\n#define MSBINT(x) 32LL - __builtin_clz(x)\n#define BITCNT(x) __builtin_popcountll(x)\n\nusing namespace std;\nusing uif = uint_fast64_t;\nusing ll = long long int;\nusing vec = vector<ll>;\nusing mat = vector<vector<ll>>;\nusing pa = pair<ll, ll>;\nusing tTree = __gnu_pbds::tree<ll, __gnu_pbds::null_type, less<ll>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate <class T>\ninline void input(T &arr)\n{\n  ll n = arr.size();\n  REP(i, n)\n  cin >> arr[i];\n}\ntemplate <class T>\ninline void input2(T &arr1, T &arr2)\n{\n  ll n = arr1.size();\n  REP(i, n)\n  cin >> arr1[i] >> arr2[i];\n}\ntemplate <class T>\ninline void inputPA(T &arr)\n{\n  ll n = arr.size();\n  REP(i, n)\n  cin >> arr[i].first >> arr[i].second;\n}\ntemplate <class T>\ninline void outArr(T &arr)\n{\n  for (auto x : arr)\n  {\n    OUTSP(x);\n  }\n  OUTLF;\n}\n\ntemplate <class T>\nusing PQ = priority_queue<T>;\ntemplate <class T>\nusing PQG = priority_queue<T, vector<T>, greater<T>>;\n\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, 1, 0, -1};\nconst ll dx8[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy8[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\ntemplate <class T>\nbool chmax(T &, const T &);\ntemplate <class T>\nbool chmin(T &, const T &);\n\nll qp(ll a, ll b);\nll qp(ll a, ll b, ll mo);\n\nll mod_pow(ll, ll);\nll mod_add(ll, ll);\nll mod_mul(ll, ll);\nll mod_div(ll, ll);\nvoid make_fact(ll);\nvoid make_invfact(ll);\nvoid init_fact();\n\nll combination(ll, ll);\n\n#define FACSIZE 200002LL\n\nll invfac[FACSIZE];\nll fac[FACSIZE];\n\nbool near(double a, double b, double c, double d)\n{\n\n  double eps = 1e-10;\n\n  return (a - b) * (a - b) + (c - d) * (c - d) < eps;\n}\n\nbool isPsym(ll n, vec &X, vec &Y)\n{\n  double x = 0.0;\n  double y = 0.0;\n  REP(i, n)\n  {\n    x += X[i];\n    y += Y[i];\n  }\n  x /= n;\n  y /= n;\n\n  unordered_map<ll, ll> um;\n\n  REP(i, n)\n  {\n    double x1 = X[i];\n    double y1 = Y[i];\n    REP(j, n)\n    {\n      if (i == j)\n        continue;\n      double x2 = X[j];\n      double y2 = Y[j];\n\n      double xc = (x1 + x2) / 2;\n      double yc = (y1 + y2) / 2;\n\n      if (near(x, xc, y, yc))\n      {\n        um[i] = j;\n        break;\n      }\n    }\n  }\n\n  for (auto p : um)\n  {\n    OUTPA(p);\n  }\n\n  return um.size() == n;\n}\n\nint main(void)\n{\n  ll n;\n  cin >> n;\n  vec X(n);\n  vec Y(n);\n  REP(i, n)\n  cin >> X[i] >> Y[i];\n  if (n % 2 != 0)\n  {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  double x = 0.0;\n  double y = 0.0;\n\n  if (!isPsym(n, X, Y))\n  {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n\n  REP(i, n)\n  {\n    x += X[i];\n    y += Y[i];\n  }\n  x /= n;\n  y /= n;\n  cout << std::setprecision(20) << x << \" \" << y << endl;\n\n  return 0;\n}\n\ntemplate <class T>\nbool chmax(T &a, const T &b)\n{\n  if (a < b)\n  {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b)\n{\n  if (b < a)\n  {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\nll qp(ll a, ll b)\n{\n  ll ans = 1LL;\n  do\n  {\n    if (b & 1LL)\n      ans = 1LL * mod_mul(ans, a) % MOD;\n    a = 1LL * mod_mul(a, a) % MOD;\n  } while (b >>= 1LL);\n  return ans;\n}\nll qp(ll a, ll b, ll mo)\n{\n  ll ans = 1LL;\n  do\n  {\n    if (b & 1LL)\n      ans = 1LL * (ans % mo) * (a % mo);\n    a = 1LL * (a % mo) * (a % mo);\n  } while (b >>= 1LL);\n  return ans;\n}\n\nll mod_pow(ll x, ll r)\n{\n  if (r == 0)\n    return 1;\n  else if (r == 1)\n    return x % MOD;\n  else if (r % 2 == 0)\n  {\n    ll t = mod_pow(x, r / 2) % MOD;\n    return t * t % MOD;\n  }\n  else\n  {\n    ll t = mod_pow(x, r / 2) % MOD;\n    ll k = t * t % MOD;\n    return k * x % MOD;\n  }\n}\nll mod_add(ll a, ll b)\n{\n  return (a + b) % MOD;\n}\n\nll mod_mul(ll a, ll b)\n{\n  return (a * b) % MOD;\n}\n\nll mod_div(ll a, ll b)\n{\n  return mod_mul(a, mod_pow(b, MOD - 2));\n}\n\nvoid make_fact(ll n)\n{\n  fac[0] = 1;\n  REP(i, n)\n  {\n    fac[i + 1] = mod_mul(fac[i], i + 1);\n  }\n}\n\nvoid make_invfact(ll n)\n{\n  invfac[n] = mod_pow(fac[n], MOD - 2);\n  REP_R(i, n)\n  {\n    invfac[i] = mod_mul(invfac[i + 1], i + 1);\n  }\n}\n\nvoid init_fact()\n{\n  make_fact(FACSIZE - 1);\n  make_invfact(FACSIZE - 1);\n}\n\nll combination(ll n, ll c)\n{\n\n  return mod_mul(fac[n], mod_mul(invfac[c], invfac[n - c]));\n}\n///////////////fact\n/*\n  init_fact();\n  cout << fac[5] << endl;\n  cout << invfac[5] << endl;\n  cout << combination(8, 4) << endl;\n  cout << combination(31, 8) << endl;\n  //*/\n///////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L; //Line, Segment\n\nconst int SPLIT = 10000;\nconst double EPS = 1e-9;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; \n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(const vector<P>& G, L l){\n  vector<P> ans;\n  for(int i=0;i<(int)G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\ndouble getAngle(P a,P b){\n  return atan2(b.real()-a.real(),b.imag()-a.imag());\n}\n\ndouble getDeg(double a){\n  return 180/M_PI*a;\n}\n\nbool eq(double a,double b){\n  int k = (int)max(log10(a),log10(b));\n  for(int i=0;i<k;i++){\n    a/=10.0; b/=10.0;\n  }\n  if( abs(a-b) < 1E-6 ) return true;\n  return false;\n}\nint N;\nvector<P> V;\n\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin >> x >> y;\n    V.push_back( P(x,y) );\n  }\n\n  double ar = area(V);\n  if( ar < 0.0 ){\n    reverse(V.begin(),V.end());\n    ar = abs(ar);\n  }\n\n  vector<L> seg;\n  for(int i=0;i<N;i++){\n    int pr = (i+N-1)%N;\n    int nd = (i+1)%N;\n    P st = V[pr];\n    P ed = V[nd];\n    if( ccw(st,V[i],ed) != 1 ) continue;\n    //cout << getDeg(st) << \" \"<< getDeg(ed) << endl;\n    for(int j=0;j<SPLIT;j++){\n      P h = (st+ed)/(double)2.0;\n\n      L s = L(V[i],h);\n      vector<P> r = convex_cut(V,s);\n      double ret = area(r);\n\n      //      cout << V[i] << \" ->\" << h << \" \"<< ret << endl;\n\n      if( ret < ar/2.0 - EPS  ){\n        st = h;\n      }  else if( ret > ar/2.0 + EPS ){\n        ed = h;\n      } else {\n        st = h; break;\n      }\n    }\n    //        cout << V[i] << \" -> \" << st << endl;\n    seg.push_back( L(V[i],st) );\n    if( seg.size() == 2 ) continue;\n  }\n  P poin = crossPoint(seg[0],seg[1]);\n\n  // cout << poin << endl;\n\n  bool f = true;\n  for(int i=0;i<N;i++){\n    P p = V[i];\n    P nex = V[(i+1)%N];\n    P ks = (nex-p)/(double)SPLIT;\n    for(int j=0;j<SPLIT;j++,p+=ks){\n      L s = L(p,poin);\n      vector<P> r = convex_cut(V,s);\n      //     printf(\"%.10lf %.10lf\\n\",area(r), ar/2.0 );\n      if( !eq(area(r),ar/2.0) ) f = false;\n      if(!f) break;\n    }\n    if(!f) break;\n  }\n\n  if( f ) printf(\"%.10lf %.10lf\\n\",poin.real() , poin.imag() );\n  else cout << \"NA\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        xor128();\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5+1,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(ver.size() % 2 == 0 and cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<ll, ll>;\n    vector<P> p(N);\n    for (int i = 0; i < N; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n    if (N % 2 == 1) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    sort(p.begin(), p.end());\n    ll xsum = p[0].first + p[N - 1].first;\n    ll ysum = p[0].second + p[N - 1].second;\n    for (int i = 1; i < N / 2; i++) {\n        if (xsum != p[i].first + p[N - 1 - i].first or ysum != p[i].second + p[N - 1 - i].second) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed << setprecision(10) << (long double)(2 * xsum) / N << \" \" << (long double)(2 * ysum) / N << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n;\n  cin >> n;\n  vector<int> x,y;\n  int ansx2,ansy2;\n  REP(i,n){\n    int tmp;\n    cin >> tmp;\n    x.push_back(tmp);\n    cin >> tmp;\n    y.push_back(tmp);\n  }\n  REP(i,n){\n    bool flag=true;\n    ansx2=x[0]+x[i];\n    ansy2=y[0]+y[i];\n    REP(j,n){\n      bool tmpflag=false;\n      REP(k,n){\n\tif(x[j]+x[k]==ansx2 && y[j]+y[k]==ansy2){\n\t  tmpflag=true;\n\t  break;\n\t}\n      }\n      if(!tmpflag){\n\tflag=false;\n\tbreak;\n      }\n    }\t\n    if(flag){\n      cout << ansx2/2.0 << ' ' << ansy2/2.0 << endl;\n      return 0;\n    }\n  }\n  cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[50], y[50], t[50];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = x[0]*x[0]+y[0]*y[0];\n\t\telse{\n\t\t\tdouble d = x[i]*x[i]+y[i]*y[i];\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n-1) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\tif(i == 0){ \n\t\t\n\t\t} else{\n\t\t\ta = t[i]-t[i-1];\n\t\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n/**************************************************************/\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// ???\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double c) {\n\t\treturn Point(c * x, c * y);\n\t}\n\tPoint operator / (double c) {\n\t\treturn Point(x / c, y / c);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n\t}\n\n\t// ?????????\n\tdouble norm() {\n\t\treturn (x * x + y * y);\n\t}\n\t// ??§??????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\n\n// ????????????\ntypedef Point Vector;\n\n// ??????\ndouble dot(Vector a, Vector b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\n// ??????\ndouble cross(Vector a, Vector b) {\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// ?????????\ndouble norm(Vector a) {\n\treturn (a.x * a.x + a.y * a.y);\n}\n\n// ??§??????\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\n// ??????\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\n// ??????(Parallel)????????????\nbool isParal(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParal(a1 - a2, b1 - b2);\n}\n\n// ?????????????????????????????????!!\nbool isParal(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// ?????¨???????????¢\ndouble distP(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\nint n;\nvector<Point> v;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tcin >> n;\n\tv.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> v[i].x >> v[i].y;\n\t}\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\t//cout << v.size() << endl;\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tSegment s(v[i], v[i+1]), t(v[(n/2+i)%n], v[(n/2+i+1)%n]);\n\t\t//cout << v[i].x << \" \" << v[i].y << \" \" << v[i+1].x << \" \" << v[i+1].y << endl;\n\t\t//cout << v[i+n/2].x << \" \" << v[i+n/2].y << \" \" << v[(i+n/2+1)%n].x << \" \" << v[(i+n/2+1)%n].y << endl;\n\t\t//cout << isParal(s, t) << endl;\n\t\t//cout << (s.p2 - s.p1).norm() << \" \" << (t.p2 - t.p1).norm() << endl;\n\t\tif (!isParal(s, t) || (s.p2 - s.p1).norm() != (t.p2 - t.p1).norm()) {\n\t\t\t//cout << i << endl;\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tPoint ans;\n\tif (v[n/2] < v[0]) {\n\t\tans = Point((v[0].x - v[n/2].x)/2, (v[0].y - v[n/2].y)/2);\n\t}\n\telse {\n\t\tans = Point((v[n/2].x - v[0].x)/2, (v[n/2].y - v[0].y)/2);\n\t}\n\t\n\tcout << ans.x << \" \" << ans.y << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<P> points;\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        points.push_back(P(x,y));\n    }\n\n    P center = P(0,0);\n    vector<double> sub;\n    for (int i = 0; i < N; i++) {\n        center += points[i];\n        sub.push_back(abs(points[(N + i - 1) % N] - points[i]));\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (sub[i] != sub[(i+N/2)%N]) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n\n    cout << center.real() / N << \" \" << center.imag() / N << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nint N;\nPol pol;\nD s;\nL edges[50];\nD eps=1e-50;\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\nD aPol(Pol p){\n\tD ret=0;\n\trep(i,N) ret+=cro(p[i],p[(i+1)%N])/2;\n\treturn ret;\n}\nP gpol(Pol p){\n\tP g;\n\ts=aPol(p);\n\trep(i,N){\n\t\tD ds=cro(p[i],p[(i+1)%N])/2;\n\t\tg+=ds/3*(p[i]+p[(i+1)%N]);\n\t}\n\treturn g/s;\n}\nbool iLS(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nD pi=acos(-1.0);\nvector<D> args,thetas;\nint main(){\n\tcin>>N;\n\trep(i,N){\n\t\tD x,y;\n\t\tcin>>x>>y;\n\t\tpol.pb(P(x,y));\n\t}\n\trep(i,N){\n\t\tedges[i]=L(pol[i],pol[(i+1)%N]);\n\t}\n\tP g=gpol(pol);\n\trep(i,N){\n\t\targs.pb(arg(pol[i]-g));\n\t}\n\trep(i,N) rep(j,i+1){\n\t\tthetas.pb((args[i]+args[j])/2+1e-9);\n\t\tthetas.pb((args[i]+args[j])/2-1e-9);\n\t}\n\tfor(D theta:thetas){\n\t\tL l=L(g,g+polar(1.0,theta));\n\t\tPol npol;\n\t\trep(i,N){\n\t\t\tif(iLS(l,edges[i])){\n\t\t\t\tnpol.pb(intLL(edges[i],l));\n\t\t\t\tnpol.pb(pol[(i+1)%N]);\n\t\t\t\tfor(int j=i+1;;j++){\n\t\t\t\t\tif(j==N) j=0;\n\t\t\t\t\tif(iLS(l,edges[j])){\n\t\t\t\t\t\tnpol.pb(intLL(edges[j],l));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnpol.pb(pol[(j+1)%N]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(abs(aPol(npol)*2-s)>1e-9){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.12f %.12f\\n\",g.real(),g.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x = 0.0, double y = 0.0):x(x), y(y) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n};\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double t = cross(b, c);\n\tif(t > EPS) return 1;\n\tif(t < -EPS) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\npoint rotate(const point &p, double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\npoint crosspoint(const line &a, const line &b) {\n\tconst double t = cross(a.b - a.a, b.b - b.a);\n\tif(abs(t) < EPS) return a.a;\n\treturn b.a + (b.b - b.a) * cross(a.b - a.a, a.a - b.a) * (1 / t);\n}\n\ntypedef vector<point> polygon;\n\ndouble area(const polygon &p) {\n\tconst int n = p.size();\n\tif(n < 3) return 0.0;\n\n\tdouble res = cross(p[n - 1], p[0]);\n\tfor(int i = 1; i < n; ++i) {\n\t\tres += cross(p[i - 1], p[i]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\npolygon convex_cut(const polygon &p, const line &l) {\n\tconst int n = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int next = (i + 1) % n;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1) res.emplace_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0) {\n\t\t\tres.emplace_back(crosspoint(l, line(p[i], p[next])));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool ok(const point &g, const polygon &p) {\n\tconst double S_half = area(p) / 2.0;\n\tfor(double theta = 0; theta < M_PI; theta += 1.0) {\n\t\tconst double S = area(convex_cut(p, line(g, g + rotate(point(1, 0), theta))));\n\t\tif(abs(S_half - S) > EPS) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(5);\n\tcout.flags(ios::fixed);\n\n\tint n;\n\tcin >> n;\n\n\tpoint g(0, 0);\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.emplace_back(x, y);\n\t\tg = g + p[i];\n\t}\n\n\tg = g * (1.0 / n);\n\n\tif(ok(g, p)) {\n\t\tcout << g.x << \" \" << g.y << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS=1e-8;\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<P> G(n);\n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    G[i]=P(x,y);\n  }\n  if(n%2){cout<<\"NA\"<<endl;return 0;}  \n  double len=abs(G[0]-G[1]);\n  for(int i=0;i<n;i++)\n    if(abs(len-abs(G[i]-G[(i+1)%n]))>EPS){cout<<\"NA\"<<endl;return 0;}\n  \n  P ans=crossPoint(L(G[0],G[n/2]),L(G[1],G[n/2+1]));\n  printf(\"%lf %lf\\n\",real(ans),imag(ans));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nint N;\nint x[50],y[50];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n    x[i]*=2;\n    y[i]*=2;\n  }\n  set<pair<int,int> >s;\n  for(int i=0;i+N/2<N;i++){\n    s.insert(make_pair((x[i]+x[i+N/2])/2,(y[i]+y[i+N/2])/2));\n  }\n  if(N%2==1||s.size()>1){\n    cout<<\"NA\"<<endl;\n  }else{\n    auto p=*begin(s);\n    cout<<p.first/2.<<' '<<p.second/2.<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(3.14,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nint main()\n{\n\tint n;\n\tstd::cin >> n;\n\n\tstd::vector<std::pair<double, double>> points;\n\tpoints.reserve(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\tpoints.push_back({ x, y });\n\t}\n\n\t// ??????????±???????\n\tdouble center_x = 0;\n\tdouble center_y = 0;\n\tfor (auto& p : points) {\n\t\tcenter_x += p.first;\n\t\tcenter_y += p.second;\n\t}\n\tcenter_x /= points.size();\n\tcenter_y /= points.size();\n\n\t// ????????????????????¢\n\tdouble distance = std::abs(points[0].first - center_x) + std::abs(points[0].second - center_y);\n\tfor (auto iter = points.begin() + 1; iter != points.end(); iter++) {\n\t\tauto& p = *iter;\n\t\tdouble pd = std::abs(p.first - center_x) + std::abs(p.second - center_y);\n\n\t\tif (std::abs(distance - pd) > 0.0001) {\n\t\t\tstd::cout << \"NA\" << std::endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstd::cout << std::fixed << std::setprecision(5) << center_x << \" \" << center_y << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n\ndouble cross(P a, P b) {\n\treturn (a.real()*b.imag() - a.imag()*b.real());\n}\n\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b2));\n\tdouble t = d1 / (d1+d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\nint main() {\n\tint N, X, Y;\n\tcin >> N;\n\tvector<P> points(N);\n\tREP(i, N) {\n\t\tcin >> X >> Y;\n\t\tpoints[i] = P(X, Y);\n\t}\n\n\tREP(i, N) {\n\t\tif(!is_parallel(points[i], points[(i+1)%N], points[(i+N/2)%N], points[(i+N/2+1)%N])) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(!EQ(abs(points[i]-points[(i+1)%N]), abs(points[(i+N/2)%N]-points[(i+N/2+1)%N]))) {\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tP ans = intersection_ls(points[0], points[N/2], points[1], points[N/2+1]);\n\tprintf(\"%.6f %.6f\\n\", ans.real(), ans.imag());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-6)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考 \n*/\n\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n/*\n\trep (i, n - 2 ){\n\t\tdouble sk = area2((point<double>)G[n-1], (point<double>)G[i], (point<double>)G[i+1] );\n\t\tS += sk;\n\t\tg.x += (G[i].x+G[i+1].x-2.*G[n-1].x)*sk;\n\t\tg.y += (G[i].y+G[i+1].y-2.*G[n-1].y)*sk;\n\t} // end rep\n\tg.x /= 3.*S;\n\tg.y /= 3.*S;\n*/\t\n\treturn g;\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n*/\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2442-2\", \"r\", stdin );\n\tint n;\n\tscanf (\"%d\", &n );\n\tint x, y;\n\tpolygon<double> G(n );\n\trep (i, n ) scanf (\"%d %d\", &x, &y ), G[i].x=(double)x, G[i].y=(double)y;\n\t\n\tpoint<double> cg = centerG(G );\n//\tcerr << \"cg:(\"<< cg.x << ',' << cg.y << ')' << endl;\n\tbool ok = true;\n\trep (i, n ){\n\t\tpoint<double> rp = symmetry_point (G[i], cg );\n\t\tbool good = false;\n\t\trep (j, n ){\n\t\t\tif (abs(rp-G[j])<EPS ){\n\t\t\t\tgood = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end rep\n\t\tif (!good ){\n\t\t\tok = false; break; \n\t\t} // end if\n\t} // end rep\n\tif (ok ){\n\t\tprintf (\"%.5lf %.5lf\\n\", cg.x, cg.y );\n\t}else{\n\t\tprintf (\"NA\\n\" );\n\t} // end if\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<long double> P;\ntypedef pair<P,P> L;\nconst long double EPS = 1e-6;\nconst long double INF = 10000000001.0;\n\nlong double dot(P a, P b){ return real(conj(a)*b);}\nlong double cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return 1;\n    if(cross(b,c) < -EPS) return -1;\n    if(dot(b,c) < -EPS) return 2;\n    if(norm(b) < norm(c)) return -2;\n    return 0;\n}\n\nP crossPoint(L l, L m){\n    long double A = cross(l.second - l.first, m.second - m.first);\n    long double B = cross(l.second - l.first, l.second - m.first);\n    if(abs(A) < EPS && abs(B) < EPS) return m.first;\n    else if(abs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nlong double area(vector<P> v){\n    long double sum = 0.0;\n    int n = v.size();\n    for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n    return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n    vector<P> ans;\n    for(int i=0;i<G.size();i++){\n        P A = G[i];\n        P B = G[(i+1)%G.size()];\n        if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n        if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n    }\n    return ans;\n}\n\nbool equal(long double a, long double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, long double theta){\n    theta = theta * M_PI / 180.0;\n    long double x = real(p) * cos(theta) - imag(p) * sin(theta);\n    long double y = real(p) * sin(theta) + imag(p) * cos(theta);\n    return P(x,y);\n}\n\nint main(){\n    int n;\n    while(cin >> n){\n        vector<P> v;\n        long double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n        for(int i=0;i<n;i++){\n            long double a,b;\n            cin >> a >> b;\n            v.push_back(P(a,b));\n            minx = min(minx,a);\n            maxx = max(maxx,a);\n            miny = min(miny,b);\n            maxy = max(maxy,b);\n        }\n\n        long double l = miny;\n        long double r = maxy;\n        long double all = area(v);\n        L yoko, tate;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n            if(equal(half, all/2.0)){\n                yoko = L(P(-INF,mid),P(INF,mid));\n                break;\n            } else if(half > all/2.0) r = mid;\n            else l = mid;\n        }\n\n        l = minx;\n        r = maxx;\n        while(1){\n            long double mid = (l + r) / 2.0;\n            long double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n            if(equal(half, all/2.0)){\n                tate = L(P(mid,-INF),P(mid,INF));\n                break;\n            } else if(half > all/2.0) r = mid;\n            else l = mid;\n        }\n\n        P ans = crossPoint(yoko,tate);\n        bool f = true;\n\n        for(int i=0;i<v.size();i++){\n            L line = L(v[i], (ans + (ans-v[i])*INF));\n            long double half = area(convex_cut(v,line));\n            if(!equal(half*2.0,all)){\n                f = false;\n                break;\n            }\n        }\n        if(f) printf(\"%.6Lf %.6Lf\\n\",real(ans),imag(ans));\n        else cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nll n;\nld x[51];\nld y[51];\nld c_x;\nld c_y;\nld eps = 1e-10;\n\nint main(){\n  cin >> n;\n  for(ll i = 0;i < n;i++) cin >> x[i] >> y[i];\n\n  if(n%2 != 0){\n    cout << \"NA\" << endl;\n    exit(0);\n  }\n  c_x = (*min_element(x,x+n)+*max_element(x,x+n))/2;\n  c_y = (*min_element(y,y+n)+*max_element(y,y+n))/2;\n  // cerr << c_x << \" \" << c_y << endl;\n  for(ll i = 0;i < n;i++){\n    // cerr << i << \" \";\n    // cerr << x[i] << \" \" ;\n    // cerr << (x[i]-c_x) << \" \" << (c_x-x[(i+n/2)%n]) << endl;\n    if(abs((x[i]-c_x) - (c_x-x[(i+n/2)%n])) < eps && abs((y[i]-c_y)-(c_y-y[(i+n/2)%n])) < eps){\n\n    }else{\n      cout << \"NA\" << endl;\n      exit(0);\n    }\n  }\n  cout << c_x << \" \" << c_y << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long double EPS = 1e-8;\n\nstruct point {\n\tlong double x, y;\n\tpoint(long double x = 0.0, long double y = 0.0):x(x), y(y) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(long double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n};\n\nlong double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nlong double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst long double t = cross(b, c);\n\tif(t > EPS) return 1;\n\tif(t < -EPS) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\npoint rotate(const point &p, long double theta) {\n\tconst long double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\npoint crosspoint(const line &a, const line &b) {\n\tconst long double t = cross(a.b - a.a, b.b - b.a);\n\tif(abs(t) < EPS) return a.a;\n\treturn b.a + (b.b - b.a) * cross(a.b - a.a, a.a - b.a) * (1 / t);\n}\n\ntypedef vector<point> polygon;\n\nlong double area(const polygon &p) {\n\tconst int n = p.size();\n\tif(n < 3) return 0.0;\n\n\tlong double res = cross(p[n - 1], p[0]);\n\tfor(int i = 1; i < n; ++i) {\n\t\tres += cross(p[i - 1], p[i]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\npolygon convex_cut(const polygon &p, const line &l) {\n\tconst int n = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int next = (i + 1) % n;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1) res.emplace_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0) {\n\t\t\tres.emplace_back(crosspoint(l, line(p[i], p[next])));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool ok(const point &g, const polygon &p) {\n\tconst long double S_half = area(p) / 2.0;\n\tfor(long double theta = 0; theta < M_PI; theta += 1.0) {\n\t\tconst long double  S = area(convex_cut(p, line(g, g + rotate(point(1, 0), theta))));\n\t\tif(abs(S_half - S) > EPS) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(5);\n\tcout.flags(ios::fixed);\n\n\tint n;\n\tcin >> n;\n\n\tpoint g(0, 0);\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.emplace_back(x, y);\n\t\tg = g + p[i];\n\t}\n\n\tg = g * (1.0 / n);\n\n\tif(ok(g, p)) {\n\t\tcout << g.x << \" \" << g.y << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#Include<iostream>\n#include<cmath>\n#define EPS (1e-8)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(min(abs(px-x[j]),abs(py-y[j]))<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)cout<<gx<<' '<<gy<<endl;\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol const& pol){\n    int n=pol.size();\n    if(n&1) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok=true;\n    rep(i,n/2){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-6){\n            ok = false;\n            break;\n        }\n        cout << i << endl;\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Pol pol(n);\n    rep(i,n){\n        double x,y;cin>>x>>y;\n        pol[i]=P(x,y);\n    }\n    P ans=solve(pol);\n    if(ans == NA){\n        puts(\"NA\");\n    } else {\n        printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(ver.size() % 2 == 0 and cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0,double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p     )const{ return P( x+p.x , y+p.y ); }  //??????\n\tP operator - (const P &p     )const{ return P( x-p.x , y-p.y ); }  //??????\n\tP operator * (const double k )const{ return P( x*k   , y*k    ); } //??????\n\tP operator / (const double k )const{ return P( x/k   , y/k    ); } //??????\n\t\n\tbool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n\t\n\tdouble norm(){ return x*x+y*y; }        //?????????\n\tdouble abs() { return sqrt(norm()); }   //??§??????\n\tvoid normalize() {double d = sqrt(x*x+y*y); x /= d; y /= d;}\t//??£??????\n};\nstruct C{P p;double r;};    //???\nstruct S{P p1,p2;};         //??????\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\ntypedef S L;                //??´???\n\ndouble norm (P p)               { return p.norm(); }\ndouble abs  (P p)               { return p.abs(); }\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(S a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<P> pol,pol2;\n\tP min1=P(INF,INF),min2=P(INF,INF);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpol.pb(P(x,y));\n\t\tpol2.pb(P(-x,-y));\n\t\tmin1 = min(min1,P(x,y));\n\t\tmin2 = min(min2,P(-x,-y));\n\t}\n\t\n\trep(i,n){\n\t\tpol2[i]=pol2[i]+(min1-min2);\n\t}\n\t\n\tP cent;\n\trep(i,n)cent=cent+pol[i];\n\tcent=cent/n;\n\t\n\tsort(all(pol)),sort(all(pol2));\n\t\n\tbool f = true;\n\trep(i,n)if(pol[i].x!=pol2[i].x&&pol[i].y!=pol2[i].y)f=false;\n\tif(f)printf(\"%.10lf %.10lf\\n\",cent.x,cent.y);\n\telse cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2442.cc: ConvexCut\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50;\nconst int ITL = 100;\n\nconst double DELTA = 1.0e-4;\nconst double DINF = 1e18;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n\n/* global variables */\n\n/* subroutines */\n\nbool cross_lines(const pt& ap, const pt av, const pt& bp, const pt bv, CL& cl) {\n  double op01 = av.cross(bv);\n  //if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  if (op01 == 0.0) {\n    pt v = bp - ap;\n    if (v.cross(av) != 0.0) return false;\n\n    pt a1 = ap + av;\n    pt b1 = bp + bv;\n\n    return\n      ((bp - ap).dot(b1 - ap) <= 0.0 ||\n       (bp - a1).dot(b1 - a1) <= 0.0 ||\n       (ap - bp).dot(a1 - bp) <= 0.0 ||\n       (ap - b1).dot(a1 - b1) <= 0.0);\n  }\n\n  pt v = bp - ap;\n  double op0 = v.cross(av);\n  double op1 = v.cross(bv);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = bv * t1 + bp;\n  cl.t0 = t0;\n  cl.t1 = t1;\n\n  return true;\n  //return (0.0 <= cl.t0 && cl.t0 <= 1.0 && 0.0 <= cl.t1 && cl.t1 <= 1.0);\n}\n\nvoid convex_cut(const vpt& scpol, vpt& dcpol, const pt& p0, const pt& p1) {\n  int n = scpol.size();\n  pt pv = p1 - p0;\n  dcpol.clear();\n\n  for (int i = 0; i < n; i++) {\n    const pt& cp0 = scpol[i];\n    double cr0 = pv.cross(cp0 - p0);\n    if (cr0 >= 0.0) dcpol.push_back(cp0);\n    \n    const pt& cp1 = scpol[(i + 1) % n];\n    double cr1 = pv.cross(cp1 - p0);\n    if (cr0 * cr1 < 0.0) {\n      CL cl;\n      cross_lines(p0, pv, cp0, cp1 - cp0, cl);\n      dcpol.push_back(cl.p);\n    }\n  }\n}\n\ndouble calc_area(const vpt& cpol) {\n  int nc = cpol.size();\n  if (nc < 3) return 0.0;\n\n  const pt& p0 = cpol[0];\n  pt v0 = cpol[1] - p0;\n  double area = 0.0;\n  \n  for (int i = 2; i < nc; i++) {\n    pt v1 = cpol[i] - p0;\n    area += v0.cross(v1);\n    v0 = v1;\n  }\n\n  return (area / 2);\n}\n\n/* main */\n\nint main() {\n  int n;\n  cin >> n;\n\n  vpt pol;\n  double minx = DINF, maxx = -DINF, miny = DINF, maxy = -DINF;\n\n  \n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    pol.push_back(pt(x, y));\n    if (minx > x) minx = x;\n    if (maxx < x) maxx = x;\n    if (miny > y) miny = y;\n    if (maxy < y) maxy = y;\n  }\n\n  double pah = calc_area(pol) / 2;\n  //printf(\"pah=%.6lf\\n\", pah);\n\n  double cx0 = minx, cx1= maxx;\n  for (int i = 0; i < ITL; i++) {\n    double cx = (cx0 + cx1) / 2;\n    pt p0(cx, miny), p1(cx, maxy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cx=%.6lf => ca=%.6lf\\n\", cx, ca);\n    \n    if (ca < pah) cx0 = cx;\n    else cx1 = cx;\n  }\n  //printf(\"cx0=%.6lf, cx1=%.6lf\\n\", cx0, cx1);\n\n  double cy0 = miny, cy1= maxy;\n  for (int i = 0; i < ITL; i++) {\n    double cy = (cy0 + cy1) / 2;\n    pt p0(minx, cy), p1(maxx, cy);\n    vpt cpol;\n\n    convex_cut(pol, cpol, p0, p1);\n    double ca = calc_area(cpol);\n    //printf(\"  cy=%.6lf => ca=%.6lf\\n\", cy, ca);\n\n    if (ca > pah) cy0 = cy;\n    else cy1 = cy;\n  }\n  //printf(\"cy0=%.6lf, cy1=%.6lf\\n\", cy0, cy1);\n\n  bool ok = true;\n  pt cp0(cx0, cy0);\n\n  for (int i = 0; i < pol.size(); i++) {\n    vpt cpol;\n    convex_cut(pol, cpol, cp0, pol[i]);\n    double ca = calc_area(cpol);\n\n    if (abs(pah - ca) > DELTA) {\n      ok = false;\n      break;\n    }\n  }\n  \n  if (ok) printf(\"%.6lf %.6lf\\n\", cx0, cy0);\n  else cout << \"NA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n\n\nint main(){\n\n  int n;\n  cin >> n;\n  vector<complex<double> > p(n);\n  rep(i,n){\n    double x,y;\n    cin >> x >> y;\n    p[i] = complex<double>(x,y);\n  }\n  if(n%2!=0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  complex<double> c,cb;\n  cb = (p[0]+p[n/2])/2.0;\n  for(int i=1;i<n/2;i++){\n    c = (p[i]+p[i+n/2])/2.0;\n    if(c.real()!=cb.real()||c.imag()!=cb.imag()){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  cout << setprecision(9) << cb.real() << \" \" << cb.imag() << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\n#define repi(i,j,n) for (int i = (j); i < (n); ++i)\n#define rep(i,n) repi(i,0,n)\n#define INF 1e9\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n/**************************** Geometry short ver ********************************/\n\nclass P {\npublic:\n  double x, y;\n  P(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n  P operator + (P p) {\n    return P(x + p.x, y + p.y);\n  }\n  P operator - (P p) {\n    return P(x - p.x, y - p.y);\n  }\n  P operator * (double c) {\n    return P(c * x, c * y);\n  }\n  P operator / (double c) {\n    return P(x / c, y / c);\n  }\n  bool operator < (const P &p) const {\n    return (x != p.x ? x < p.x : y < p.y);\n  }\n  bool operator == (const P &p) const {\n    return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n  }\n  bool operator != (const P &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n  }\n  double norm() {\n    return (x * x + y * y);\n  }\n\n  double abs() {\n    return sqrt(norm());\n  }\n};\n\ntypedef P V;\n\ndouble dot(V a, V b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(V a, V b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(V a) {\n  return (a.x * a.x + a.y * a.y);\n}\n\ndouble abs(V a) {\n  return sqrt(norm(a));\n}\n\nclass S {\npublic:\n  P s, e; // start, end\n  S(P s = P(), P e = P()) : s(s), e(e) {}\n};\n\ntypedef S L;\n\ntypedef vector<P> Polygon;\n\ndouble dP(P a, P b) {\n  return (a - b).abs();\n}\n\ndouble dL(L l, P p) {\n  return abs(cross(l.e - l.s, p - l.s) / abs(l.e - l.s));\n}\n\ndouble dS(S s, P p) {\n  if (dot(s.e - s.s, p - s.s) < 0.0) return abs(p - s.s);\n  if (dot(s.s - s.e, p - s.e) < 0.0) return abs(p - s.e);\n  return dL(s, p);\n}\n\nconst int CCW = 1, CW = -1, OB = 2, OF = -2, OS = 0;\n\nint ccw(P x, P y, P z) {\n  V a = y - x, b = z - x;\n\n  if (cross(a, b) > EPS) return CCW;\n  if (cross(a, b) < -EPS) return CW;\n  if (dot(a, b) < -EPS) return OB;\n  if (a.norm() < b.norm()) return OF;\n  return OS;\n}\n\nbool intersect(P a, P b, P c, P d) {\n  return (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(S a, S b) {\n  return intersect(a.s, a.e, b.s, b.e);\n}\n\ndouble dSS(S a, S b) {\n  if (intersect(a, b)) return 0.0;\n  return min(min(dS(a, b.s), dS(a, b.e)), min(dS(b, a.s), dS(b, a.e)));\n}\n\nP crossP(S a, S b) {\n  V base = b.e - b.s;\n  double d1 = abs(cross(base, a.s - b.s));\n  double d2 = abs(cross(base, a.e - b.s));\n  double t = d1 / (d1 + d2);\n  return a.s + (a.e - a.s) * t;\n}\n\n/* IN 2, ON 1, OUT 0*/\nint contains(Polygon g, P p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    P a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nint n, x, y;\nvector<P> v;\n\nP solve() {\n    int a = n / 2;\n    double len = 0.0, tmpl;\n    P points, tmpp;\n\n    len = dP(v[0], v[a]);\n    points = P((v[0].x + v[a].x) / 2.0, (v[0].y + v[a].y) / 2.0);\n\n    repi(i,1,n/2) {\n        tmpl = dP(v[i], v[i + a]);\n        tmpp = P((v[i].x + v[i + a].x) / 2.0, (v[i].y + v[i + a].y) / 2.0);\n\n        if (tmpp != points || len != tmpl) {\n            return P(-1, -1);\n        }\n    }\n\n    return points;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n\n    rep(i,n) {\n        cin >> x >> y;\n        v.push_back(P(x, y));\n    }\n\n    if (n % 2) cout << \"NA\" << endl;\n    else {\n        P ans = solve();\n        if (ans.x == -1) cout << \"NA\" << endl;\n        else cout << ans.x << \" \" << ans.y << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nld getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(getdis(a,p[i])!=getdis(a,p[n/2+i]))an=0;\n  }\n  double x=a.f,y=a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    int N;\n    cin >> N;\n    using P = pair<ll, ll>;\n    vector<P> p(N);\n    for (int i = 0; i < N; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n    if (N % 2 == 1) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    sort(p.begin(), p.end());\n    ll xsum = p[0].first + p[N - 1].first;\n    ll ysum = p[0].second + p[N - 1].second;\n    for (int i = 1; i < N / 2; i++) {\n        if (xsum != p[i].first + p[N - 1 - i].first or ysum != p[i].second + p[N - 1 - i].second) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed << setprecision(10) << (long double)(xsum) / 2 << \" \" << (long double)(ysum) / 2 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\n \nconst double eps = 1e-10;\n \nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n \ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n \nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n \nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n  double x = 0, y = 0;\n  for(int i = 0; i < N; ++i) {\n    x += ps[i].real();\n    y += ps[i].imag();\n  }\n  x /= N;\n  y /= N;\n  P g(x, y);\n  bool flag = true;\n  srand(time(NULL));\n  for(int k = 0; k < 100000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-4)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nll n;\nld x[51];\nld y[51];\nld c_x;\nld c_y;\nld eps = 1e-10;\n\nint main(){\n  cin >> n;\n  for(ll i = 0;i < n;i++) cin >> x[i] >> y[i];\n\n  if(n%2 != 0){\n    cout << \"NA\" << endl;\n    exit(0);\n  }\n  c_x = (*min_element(x,x+n)+*max_element(x,x+n))/2;\n  c_y = (*min_element(y,y+n)+*max_element(y,y+n))/2;\n  // cerr << c_x << \" \" << c_y << endl;\n  for(ll i = 0;i < n;i++){\n    // cerr << i << \" \";\n    // cerr << x[i] << \" \" ;\n    // cerr << (x[i]-c_x) << \" \" << (c_x-x[(i+n/2)%n]) << endl;\n    if(abs((x[i]-c_x) - (c_x-x[(i+n/2)%n])) < eps && abs((y[i]-c_y)-(c_y-y[(i+n/2)%n])) < eps){\n\n    }else{\n      cout << \"NA\" << endl;\n      exit(0);\n    }\n  }\n  cout << setprecision(17);\n  cout << c_x << \" \" << c_y << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nstruct Vector2{\n    double x, y;\n    Vector2(){};\n    Vector2(double x, double y) : x(x), y(y){};\n\n    double cross(const Vector2& p){\n        return x*p.y - y*p.x;\n    }\n\n    const Vector2 medPoint(const Vector2& v){\n        return {(x + v.x) / 2.0, (y + v.y) / 2.0};\n    }\n\n    const bool operator == (const Vector2& v){\n        return abs(x - v.x) < EPS && abs(y - v.y) < EPS;\n    }\n    const bool operator != (const Vector2& v){\n        return !(*this==(v));\n    }\n};\n\nint main(){\n\tint n;\n    cin>>n;\n    vector<Vector2> v;\n    rep(i, n){\n        double x, y;\n        cin>>x>>y;\n        v.pb({x, y});\n    }\n    bool f = n & 1;\n    Vector2 a = v[0].medPoint(v[n/2]);\n    for(int i = 1; i < n /2; i++){\n        f |= a != v[i].medPoint(v[i + n/2]);\n    }\n    if(f) cout<<\"NA\"<<endl;\n    else printf(\"%.15lf %.15lf\\n\", a.x, a.y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> P3;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e4 + 5);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    int n;\n    double cx=0.0,cy=0.0,x[55],y[55];\n    bool used[55]{}, ok = true;\n    cin >> n;\n    REP(i,n){\n        cin >> x[i] >> y[i];\n        cx += x[i];\n        cy += y[i];\n    }\n    cx /= double(n);\n    cy /= double(n);\n    REP(i,n){\n        x[i] -= cx;\n        y[i] -= cy;\n    }\n    REP(i,n){\n        if(used[i])continue;\n        REP(j,n){\n            if(used[j] || i==j)continue;\n            if(abs(x[i]+x[j])<EPS && abs(y[i]+y[j])<EPS){\n                used[i] = used[j] = true;\n            }\n        }\n    }\n    REP(i,n) ok &= used[i];\n    if(ok){\n        printf(\"%.8lf %.8lf\\n\",cx,cy);\n    }\n    else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n/**************************************************************/\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI acos(-1)\n#define rad(t) double(t)*PI/180.0\n\n// ???\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double c) {\n\t\treturn Point(c * x, c * y);\n\t}\n\tPoint operator / (double c) {\n\t\treturn Point(x / c, y / c);\n\t}\n\tbool operator < (const Point &p) const {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) const {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n\t}\n\n\t// ?????????\n\tdouble norm() {\n\t\treturn (x * x + y * y);\n\t}\n\t// ??§??????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\n\n// ????????????\ntypedef Point Vector;\n\n// ??????\ndouble dot(Vector a, Vector b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\n// ??????\ndouble cross(Vector a, Vector b) {\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// ?????????\ndouble norm(Vector a) {\n\treturn (a.x * a.x + a.y * a.y);\n}\n\n// ??§??????\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\n// ??????\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\n// ??????(Parallel)????????????\nbool isParal(Vector a, Vector b) {\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParal(a1 - a2, b1 - b2);\n}\n\n// ?????????????????????????????????!!\nbool isParal(Segment s1, Segment s2) {\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// ?????¨???????????¢\ndouble distP(Point a, Point b) {\n\treturn (a - b).abs();\n}\n\nint n;\nvector<Point> v;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tcin >> n;\n\tv.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> v[i].x >> v[i].y;\n\t}\n\tif (n % 2) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\t//cout << v.size() << endl;\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tSegment s(v[i], v[i+1]), t(v[(n/2+i)%n], v[(n/2+i+1)%n]);\n\t\t//cout << v[i].x << \" \" << v[i].y << \" \" << v[i+1].x << \" \" << v[i+1].y << endl;\n\t\t//cout << v[i+n/2].x << \" \" << v[i+n/2].y << \" \" << v[(i+n/2+1)%n].x << \" \" << v[(i+n/2+1)%n].y << endl;\n\t\t//cout << isParal(s, t) << endl;\n\t\t//cout << (s.p2 - s.p1).norm() << \" \" << (t.p2 - t.p1).norm() << endl;\n\t\tif (!isParal(s, t) || (s.p2 - s.p1).norm() != (t.p2 - t.p1).norm()) {\n\t\t\t//cout << i << endl;\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << (v[0].x - v[n/2].x) / 2 << \" \" << (v[0].y - v[n/2].y) / 2 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,x[50],y[50];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tif(n%2)cout<<\"NA\"<<endl;\n\telse\n\t{\n\t\tn=n/2;bool f=1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tf&=x[i+1]-x[i]==x[n+i]-x[(n+i+1)%(n*2)];\n\t\t\tf&=y[i+1]-y[i]==y[n+i]-y[(n+i+1)%(n*2)];\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tcout<<(x[0]+x[n])/2.<<\" \"<<(y[0]+y[n])/2.<<endl;\n\t\t}\n\t\telse cout<<\"NA\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint x[50],y[50];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\tif(n%2==1){ puts(\"NA\"); return 0; }\n\n\tdouble gx=0,gy=0;\n\trep(i,n) gx+=x[i], gy+=y[i];\n\tgx/=n;\n\tgy/=n;\n\n\trep(i,n){\n\t\tif(abs((x[i]+x[(i+n/2)%n])/2.0-gx)<EPS\n\t\t&& abs((y[i]+y[(i+n/2)%n])/2.0-gy)<EPS);\n\t\telse{\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"%.9f %.9f\\n\",gx,gy);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n\n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[i] - sumx;\n    double ay = y[i] - sumy;\n    double bx = x[(i+1)%n] - sumx;\n    double by = y[(i+1)%n] - sumy;\n    double EPS=1e-9;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n\n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol pol){\n    int n=pol.size();\n    if(n&2) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok = true;\n    rep(i,n/2){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-8){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        Pol pol(n);\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            pol[i]=P(x,y);\n        }\n        P ans=solve(pol);\n        if(ans == NA){\n            puts(\"NA\");\n        } else {\n            printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2==1)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",a.f,a.s);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\n// Line\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  VP vp;\n  REP(i,n){\n    ld x,y;\n    cin>>x>>y;\n    vp.emplace_back(x,y);\n  }\n  if (n%2) {\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  L l1(vp[0],vp[n/2]), l2(vp[1],vp[n/2+1]);\n  P p = is_ll(l1, l2);\n  bool ok = true;\n  REP(i,n/2) if (!EQ(p-vp[i],vp[n/2+i]-p)) ok = false;\n  if (!ok)\n    cout << \"NA\"<< endl;\n  else\n    cout <<setprecision(10)<<fixed<< real(p) <<' '<<imag(p) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b, double eps = 1e-8) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; !equals(l, r);) {\n    x = (l+r) / 2.0;\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; !equals(l, r);) {\n    y = (l+r) / 2.0;\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  P g(x, y);\n\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-4)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.5f %.5f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline point rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\ninline point rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ninline double angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\ninline bool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\ninline bool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ninline bool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\ninline bool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline bool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\ninline bool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\ninline bool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ninline double dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ninline double dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ninline double dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ninline double dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ninline double dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\ninline double dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline point crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\ninline vector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\ninline vector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ninline long double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn fabs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline long double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tlong double res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn res * 0.5;\n}\n\n// L.aからL.bの方向を見た場合に，点aが左側に来る．\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\n// L.aからL.bを向いた時の左側を残して切断する．\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nvector<point> tangent(const circle& c, const point& p) {\n\tconst double x = norm(p - c.c);\n\tdouble d = x - c.r * c.r;\n\tif(d < -EPS) return vector<point>();\n\td = max(d, 0.0);\n\tconst point q1 = (p - c.c) * (c.r * c.r / x);\n\tconst point q2 = rotate90((p - c.c) * (-c.r * sqrt(d) / x));\n\tvector<point> res;\n\tres.push_back(c.c + q1 - q2);\n\tres.push_back(c.c + q1 + q2);\n\treturn res;\n}\n\nvector<line> tangent(const circle &a, const circle& b) {\n\tvector<line> res;\n\tif(abs(a.r - b.r) < EPS) {\n\t\tpoint dir = b.c - a.c;\n\t\tdir = rotate90(dir * (a.r / abs(dir)));\n\t\tres.push_back(line(a.c + dir, b.c + dir));\n\t\tres.push_back(line(a.c - dir, b.c - dir));\n\t}\n\telse {\n\t\tpoint p = a.c * (-b.r) + b.c * a.r;\n\t\tp = p * (1.0 / (a.r - b.r));\n\t\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\t\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\t\tres.push_back(line(ps[i], qs[i]));\n\t}\n\n\tpoint p = a.c * b.r + b.c * a.r;\n\tp = p * (1.0 / (a.r + b.r));\n\tvector<point> ps = tangent(a, p), qs = tangent(b, p);\n\tfor(int i = 0; i < min<int>(ps.size(), qs.size()); ++i)\n\t\tres.push_back(line(ps[i], qs[i]));\n\n\treturn res;\n}\n\nconst int INF = 1000001;\n\nlong double cut_area(const polygon& p, double x1, double y1, double x2, double y2) {\n\treturn area(convex_cut(p, line(point(x1, y1), point(x2, y2))));\n}\n\nbool contain(const polygon& p, const point& a) {\n\tconst int n = p.size();\n\n\tconst segment s = segment(point(a.x - INF, a.y), point(a.x, a.y));\n\tint cnt = 0;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst segment seg = segment(p[i], p[(i + 1) % n]);\n\t\tif(intersect(s, seg)) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\treturn cnt == 1;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint mnX = INF, mnY = INF, mxX = -INF, mxY = INF;\n\tpolygon original;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tchmin(mnX, x);\n\t\tchmin(mnY, y);\n\t\tchmax(mxX, x);\n\t\tchmax(mxY, y);\n\n\t\toriginal.push_back(point(x, y));\n\t}\n\n\tconst long double originalS = area(original);\n\tdouble lowX = mnX + 0.5, highX = mxX - 0.5;\n\tif(cut_area(original, lowX, -INF, lowX, INF) > cut_area(original, highX, -INF, highX, INF))\n\t\tswap(lowX, highX);\n\n\tfor(int i = 0; i < 100; ++i) {\n\t\tconst double mid = (lowX + highX) / 2;\n\t\tconst long double cutS = cut_area(original, mid, -INF, mid, INF);\n\n\t\tif(originalS < cutS * 2)\n\t\t\thighX = mid;\n\t\telse\n\t\t\tlowX = mid;\n\t}\n\n\tdouble lowY = mnY + 0.5, highY = mxY - 0.5;\n\tif(cut_area(original, -INF, lowY, INF, lowY) > cut_area(original, -INF, highY, INF, highY))\n\t\tswap(lowY, highY);\n\n\tfor(int i = 0; i < 100; ++i) {\n\t\tconst double mid = (lowY + highY) / 2;\n\t\tconst long double cutS = cut_area(original, -INF, mid, INF, mid);\n\n\t\tif(originalS < cutS * 2)\n\t\t\thighY = mid;\n\t\telse\n\t\t\tlowY = mid;\n\t}\n\n\tconst point candidate(lowX, lowY);\n\tfor(int i = 0; i < 360; ++i) {\n\t\tconst double arg = M_PI * i / 180.0;\n\t\tconst line l(candidate, candidate + point(cos(arg), sin(arg)));\n\t\tconst long double cutS = area(convex_cut(original, l));\n\t\tif((originalS - cutS - cutS) > EPS) {\n\t\t\tputs(\"NA\");\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\t\t\t\n\t}\n\n\tprintf(\"%.5lf %.5lf\\n\", lowX, lowY);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N;\n  cin>>N;\n  int x[N],y[N];\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  float tx,ty;\n  tx=(x[0]+x[N/2])/2;\n  ty=(y[0]+y[N/2])/2;\n  //cout<<\" \"<<\" \"<<tx<<\" \"<<ty<<endl;\n  for(int i=0;i<N/2;i++){\n    float dx=(x[i]+x[i+N/2])/2,dy=(y[i]+y[i+N/2])/2;\n    if(max(abs(dy-ty),abs(dx-tx))>0.0001){\n      cout<<\"NA\"<<endl;\n  //    cout<<dx<<\" \"<<dy<<\" \"<<tx<<\" \"<<ty<<endl;\n      return 0;\n    }\n  }\n  printf(\"%f %f\\n\",tx,ty);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n\n\nint main(){\n\n  int n;\n  cin >> n;\n  vector<complex<int> > p(n);\n  rep(i,n){\n    int x,y;\n    cin >> x >> y;\n    p[i] = complex<int>(x,y);\n  }\n  if(n%2!=0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  complex<double> c,cb;\n  cb = (p[0]+p[n/2])/2;\n  for(int i=1;i<n/2;i++){\n    c = (p[i]+p[i+n/2])/2;\n    if(c.real()!=cb.real()||c.imag()!=cb.imag()){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  cout << setprecision(9) << cb.real() << \" \" << cb.imag() << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-15\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[51], y[51], t[51];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = sqrt(x[0]*x[0]+y[0]*y[0]);\n\t\telse{\n\t\t\tdouble d = sqrt(x[i]*x[i]+y[i]*y[i]);\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tx[n] = x[0]; y[n] = y[0]; t[n] = t[0];\n\trep(i,n) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\ta = t[i+1]-t[i];\n\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool EQ(double a, double b) {\n    return abs(a - b) < EPS;\n  }\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    return EQ(a.real(), b.real()) && EQ(a.imag(), b.imag());\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??´???\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const P &p,const P &q){\n  return abs(p - q) ;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\ndouble calc_triangle(P a,P b,P c){\n  P ba = (b - a);\n  P ca = (c - a);\n  return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n}\ndouble calc_area(const G &g){\n  double res = 0;\n  rep(i,g.size()-2){\n    res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n  }\n  return res;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nG convex_cut(G &g, L &l) {\n  G h;\n  rep(i, (int)g.size()) {\n    P p = curr(g, i), q = next(g, i);\n    if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n      if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n      else return G{};                        // p -- l.b -- l.a -- q\n    }\n    if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n    if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n      h.emplace_back(crosspoint(L(p, q), l));\n  }\n  return h;\n}\nP center(const G &g){\n  int n = g.size();\n  P p(0,0);\n  rep(i,n){\n    p = p + g[i];\n  }\n  return p / (1.0 * n);\n}\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nG rotG(G g, P &p, double theta) {\n    rep(i, g.size()) {\n        g[i] = rotP(g[i], p, theta);\n    }\n    return g;\n}\nbool EqG(G &g, G &h) {\n    if (g.size() != h.size()) return false;\n    rep(k, g.size()) {\n        bool flag = true;\n        rep(i, g.size()) {\n            if (!same(g[(i + k) % g.size()], h[i])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  G g;\n  double x,y;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  P gp = center(g);\n  G h = rotG(g, gp, PI);\n  if(EqG(g,h))\n    fcout(10) << real(gp) << ' ' << imag(gp) << endl;\n  else\n    cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std; vector<pair<long double, long double>>vec; long double X[100000], Y[100000], X1[100000], X2[100000], X3[100000], X4[100000], Y1[100000], Y2[100000], Y3[100000], Y4[100000], INF = 1e+14, EPS = 1e-14; int Q;\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; xp[0] = X1 - X2; yp[0] = Y1 - Y2; xp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }if (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }if ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }return false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { return make_pair(INF, INF); }\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }if (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }if (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }long double XP[4], YP[4], ZP[4];\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2; XP[1] = X3 - X4; YP[0] = Y1 - Y2; YP[1] = Y3 - Y4; ZP[0] = YP[0] / XP[0]; ZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1], K = (Y5 - Y1) / (ZP[0] - ZP[1]); long double L = K*ZP[0]; return make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { X1[i] = X[i]; Y1[i] = Y[i]; X2[i] = Y[(i + Q / 2) % Q]; Y2[i] = Y[(i + Q / 2) % Q]; vec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); }\n\tsort(vec.begin(), vec.end()); for (int i = 0; i < vec.size() - 1; i++) { if (fabs(vec[i].first - vec[i + 1].first) < EPS && fabs(vec[i].second - vec[i + 1].second) < EPS && vec[i].first < sqrtl(INF)) { cout << \"NA\" << endl; return; } }cout << fixed << setprecision(15) << vec[0].first << ' ' << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cstdio>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef complex<long long> P;\n\nint main() {\n  long long n;\n  cin >> n;\n  if (n == -1) {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  P p[n];\n  rep (i, n) cin >> p[i].real() >> p[i].imag();\n  P g = 0;\n  rep (i, n) g += p[i];\n  rep (i, n / 2) {\n    if ((p[i] + p[i + n / 2]) * n / 2LL != g) {\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  printf(\"%.12lf %.12lf\\n\", (double)g.real() / n, (double)g.imag() / n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-7)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  avgx/=N;avgy/=N;\n  // for(int i=0;i<N;i++){\n  //   double d1=abs(ps[(i+1)%N]-ps[i]);\n  //   double d2=abs(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n  //   // P p1=(ps[(i+1)%N]-ps[i]);\n  //   // P p2=(ps[(i+N/2+1)%N]-ps[(i+N/2)%N]);\n  //   //cout<<d1<<\" \"<<d2<<endl;\n  //   //cout<<p1<<\" \"<<p2<<endl;\n  //   //if(!EQV(p1,p2)){\n  //   if(!EQ(d1,d2)){\n  //     cout<<\"NA\"<<endl;\n  //     return 0;\n  //   }\n  // }\n  P avgp=P(avgx,avgy);\n  // printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  bool ok=false;\n  for(int j=0;j<N;j++){\n    if(EQV(ps[0],ps2[j])){\n      for(int k=0;k<N;k++){\n\tint a=(k+j)%N;\n\tint b=k;\n\tif(!EQV(ps[a],ps2[b])){\n\t  cout<<\"NA\"<<endl;\n\t  return 0;\n\t}\n      }\n      ok=true;\n      break;\n    }\n  }\n  if(ok)printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  else cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double EPS = 1e-8;\n\ndouble cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\ndouble dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b)) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a1 = input[i+1];\n    Point a2 = input[i];\n    Point b1 = input[(input.size()/2+i+1)%input.size()];\n    Point b2 = input[input.size()/2+i];\n    if(!isParallel(Point(a1.first-a2.first, a1.second-a2.second), \n                   Point(b1.first-b2.first, b1.second-b2.second))) return false;\n    if(abs(dist(a1, a2) - dist(b1, b2)) >= EPS) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  /*long double tmp = 0.0;\n  if(abs(a.first + b.first) < EPS) tmp = 333.0;\n  if(abs(a.second + b.second) < EPS) tmp = 333.0;\n  ans = Point((a.first+tmp + b.first+tmp) / 2.0, (a.second+tmp + b.second+tmp) / 2.0);\n  ans.first -= tmp;\n  ans.second -= tmp;*/\n  ans = Point((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else printf(\"%.8f %.8f\\n\", ans.first, ans.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn x<-EPS?-1:x<EPS?0:1;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\nPoint operator/(Point p,double c){\n\treturn Point(p.x/c,p.y/c);\n}\nstruct LessX{\n\tbool operator()(Point a,Point b){\n\t\treturn abs(a.x-b.x)>EPS?a.x<b.x-EPS:a.y<b.y-EPS;\n\t}\n};\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\ntypedef Line Segment;\n\nPoint Proj(Line l,Point p){\n\tPoint a=p-l.pos,b=l.dir;\n\treturn l.pos+Dot(a,b)/Abs2(b)*b;\n}\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\n\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\nbool IntersectLL(Line a,Line b){\n\treturn abs(Cross(a.dir,b.dir))>EPS || abs(Cross(a.dir,b.pos-a.pos))<EPS;\n}\nbool IntersectLS(Line l,Segment s){\n\tPoint a=s.pos-l.pos,b=s.pos+s.dir-l.pos;\n\treturn Signum(Cross(l.dir,a))*Signum(Cross(l.dir,b))<=0;\n}\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\nbool IntersectSP(Segment s,Point p){\n\treturn CCW(s.pos,s.pos+s.dir,p)==0;\n}\n\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS)\n\t\treturn a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\nPoint InterPointLS(Line l,Segment s){\n\treturn InterPointLL(s,l);\n}\nPoint InterPointSS(Segment a,Segment b){\n\tif(abs(Cross(a.dir,b.dir))<EPS){\n\t\tif(IntersectSP(b,a.pos)) return a.pos;\n\t\tif(IntersectSP(b,a.pos+a.dir)) return a.pos+a.dir;\n\t\tif(IntersectSP(a,b.pos)) return b.pos;\n\t\tif(IntersectSP(a,b.pos+b.dir)) return b.pos+b.dir;\n\t}\n\treturn InterPointLL(a,b);\n}\n\ndouble Area(const vector<Point>& ps){\n\tdouble res=0;\n\trepi(i,2,ps.size())\n\t\tres+=Cross(ps[i-1]-ps[0],ps[i]-ps[0]);\n\treturn res;\n}\n\nvector<Point> ConvexCut(const vector<Point>& ps,Line l){\n\tint n=ps.size();\n\tvector<Point> res;\n\trep(i,n){\n\t\tint c1=CCW(l.pos,l.pos+l.dir,ps[i]);\n\t\tint c2=CCW(l.pos,l.pos+l.dir,ps[(i+1)%n]);\n\t\tif(c1!=-1)\n\t\t\tres.push_back(ps[i]);\n\t\tif(c1*c2==-1)\n\t\t\tres.push_back(InterPointLS(l,Segment(ps[i],ps[(i+1)%n]-ps[i])));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Point> ps(n);\n\t\trep(i,n) cin>>ps[i].x>>ps[i].y;\n\t\t\n\t\tdouble area=Area(ps);\n\t\t\n\t\tLine ls[2];\n\t\trep(i,2){\n\t\t\tPoint p=ps[i],a=ps[(i+1)%n]-p,b=ps[(i+n-1)%n]-p;\n\t\t\tdouble lo=atan2(a.y,a.x),hi=atan2(b.y,b.x);\n\t\t\tif(lo>hi) hi+=2*PI;\n\t\t\trep(_,60){\n\t\t\t\tdouble mi=(lo+hi)/2;\n\t\t\t\tLine l(p,Rot(Point(1,0),mi));\n\t\t\t\tif(Area(ConvexCut(ps,l))<area/2)\n\t\t\t\t\thi=mi;\n\t\t\t\telse\n\t\t\t\t\tlo=mi;\n\t\t\t}\n\t\t\tls[i]=Line(p,Rot(Point(1,0),lo));\n\t\t}\n\t\t\n\t\tPoint ip=InterPointLL(ls[0],ls[1]);\n\t\t\n\t\tbool ok=true;\n\t\trep(i,5){\n\t\t\tdouble t=rand()*2*PI/RAND_MAX;\n\t\t\tdouble a=Area(ConvexCut(ps,Line(ip,Rot(Point(1,0),t))));\n\t\t\tok&=abs(a-area/2)/(area/2)<EPS;\n\t\t}\n\t\tif(ok) printf(\"%f %f\\n\",ip.x,ip.y);\n\t\telse   puts(\"NA\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef complex<double> P;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n;\nP p[50];\n\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> p[i].real() >> p[i].imag();\n\tif(n % 2){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\trep(i, n) if(p[i] - p[(i + 1) % n] != p[(i + n / 2 + 1) % n] - p[(i + n / 2) % n]){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\tP g;\n\trep(i, n) g += p[i];\n\tprintf(\"%.9f %.9f\\n\", g.real() / n, g.imag() / n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble compute_area(vector<Point>& points){\n  double area = 0;\n  for(int i = 0; i < points.size(); i++){\n    area += (points[i].real() - points[(i + 1) % points.size()].real())\n      * (points[i].imag() + points[(i + 1) % points.size()].imag());\n  }\n  return 1.0/2.0 * abs(area);\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nPoint reflection(const Line &l, const Point &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLS(const Line &l, const Line &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble distanceLL(const Line &l, const Line &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<Point> points;\n    double high,low,lhs,rhs;\n\n    high = rhs = numeric_limits<double>::min();\n    low = lhs = numeric_limits<double>::max();\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      points.push_back(Point(x,y));\n      low = min(low,y);\n      high = max(high,y);\n\n      lhs = min(lhs,x);\n      rhs= max(rhs,x);\n    }\n    vector<Line> lines;\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      lines.push_back(Line(points[pos_i],points[(pos_i+1) % N]));\n    }\n\n    double area_target;\n    //horizontal line\n    for(int round = 0; round < 50; round++){\n      double mid = low + (high - low) / 2.0;\n      Line horizontal_line(Point(-1000000.0,mid),Point(1000000.0,mid));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(horizontal_line,lines[line_i])){\n          Point p = crosspoint(horizontal_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n      vector<Point> top,bottom;\n      top.push_back(div[0]);\n      top.push_back(div[1]);\n      bottom.push_back(div[0]);\n      bottom.push_back(div[1]);\n\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS <= points[pos_i].imag()){\n          top.push_back(points[pos_i]);\n        }\n        if(mid + EPS >= points[pos_i].imag()){\n          bottom.push_back(points[pos_i]);\n        }\n      }\n      top = compute_convex_hull(top);      \n      bottom = compute_convex_hull(bottom);      \n      double area_top = compute_area(top);\n      double area_bottom = compute_area(bottom);\n      double whole = area_top + area_bottom;\n\n      if(area_top >= area_bottom){\n        low = mid;\n        area_target = area_top;\n      }\n      else{\n        high = mid;\n      }\n    }\n\n    //vertical line\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Line vertical_line(Point(mid,-10000000.0),Point(mid,10000000.0));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(vertical_line,lines[line_i])){\n          Point p = crosspoint(vertical_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n\n      vector<Point> left,right;\n      left.push_back(div[0]);\n      right.push_back(div[0]);\n      left.push_back(div[1]);\n      right.push_back(div[1]);\n\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS >= points[pos_i].real()){\n          left.push_back(points[pos_i]);\n        }\n        if(mid + EPS <= points[pos_i].real()){\n          right.push_back(points[pos_i]);\n        }\n      }\n\n      left = compute_convex_hull(left);\n      right = compute_convex_hull(right);\n      double area_left = compute_area(left);\n      double area_right = compute_area(right);\n      double whole = area_left + area_right;\n\n      if(area_right >= area_left){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n    \n    //check\n    Line check_line(Point(lhs,low),Point(lhs + 1.0,low + 1.0));\n    vector<Point> div;\n    int first = -1;\n    int last = -1;\n    for(int line_i = 0; line_i < lines.size(); line_i++){\n      if(intersectLS(check_line,lines[line_i])){\n        Point p = crosspoint(check_line,lines[line_i]);\n        div.push_back(p);\n        if(first == -1) first = line_i;\n        else if(last == -1) last = line_i;\n      }\n    }\n    \n    vector<Point> half;\n    half.push_back(div[0]);\n\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      if(first <= pos_i && pos_i <= last){\n        half.push_back(points[pos_i]);\n      }\n    }\n    half.push_back(div[1]);\n    double area_half = compute_area(half);\n    if(abs(area_half - area_target) > EPS){\n      cout << \"NA\" << endl;\n    }\n    else{\n      printf(\"%.7lf %.7lf\\n\",lhs,low);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <math.h>\n#include <stdio.h>\n#define eps 1e-9\n\nusing namespace std;\n\nint n;\ndouble x[55], y[55];\ndouble distPP(double x, double y, double x2, double y2)\n{\n\treturn sqrt((x-x2)*(x-x2) + (y-y2)*(y-y2));\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tif(n % 2){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tdouble mx = (x[0]+x[n/2])/2, my = (y[0]+y[n/2])/2;\n\tfor(int i = 0; i < n; i++){\n\t\tif(distPP(mx, my, (x[i]+x[(n/2+i)%n])/2, (y[i]+y[(n/2+i)%n])/2) > eps){\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.11f %.11f\\n\", mx, my);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct P{\n  double x;\n  double y;\n\n  P(){\n  }\n\n  P(const double &s , const double &e)\n  { x=s; y=e;}\n\n  P operator - (const P &t) const\n  { return P(x-t.x , y-t.y); }\n\n  P operator + (const P &t) const\n  { return P(x+t.x , y+t.y); }\n\n  P operator * (const double &d) const\n  { return P(x*d , y*d); }\n\n};\ndouble cross(P a,P b){\n  return (a.x*b.y-a.y*b.x);\n}\nP interpoint_s(P a1 , P a2 , P b1 , P b2){\n  P b=b2-b1;\n  double d1=fabs(cross(b , a1-b1));\n  double d2=fabs(cross(b , a2-b1));\n  double t=d1 / (d1 + d2);\n  P a=a2-a1;\n  P v=a*t;\n  return a1+v;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  vector<P> ps(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y;\n\n  if(N != 4) cout << \"NA\" << endl;\n  else{\n\tP p = interpoint_s(ps[0], ps[2], ps[1], ps[3]);\n\tcout << fixed << setprecision(9) << p.x << \" \" << p.y << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,x[55],y[55];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tif(n%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\trep(i,n)cin>>x[i]>>y[i],x[i]*=2,y[i]*=2;\n\tint cx=x[0]+x[n/2],cy=y[0]+y[n/2];\n\trep(i,n/2)if(x[i]+x[i+n/2]!=cx || y[i]+y[i+n/2]!=cy){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<cx/4.<<\" \"<<cy/4.<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[51], y[51], t[51];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = sqrt(x[0]*x[0]+y[0]*y[0]);\n\t\telse{\n\t\t\tdouble d = sqrt(x[i]*x[i]+y[i]*y[i]);\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tx[n] = x[0]; y[n] = y[0]; t[n] = t[0];\n\trep(i,n) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\ta = t[i+1]-t[i];\n\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n//#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<complex<long double>> inputs;\n    REP(i, n) {\n        long double a, b;\n        cin >> a >> b;\n        inputs.push_back(complex<long double>{a, b});\n    }\n    if (n % 2 == 1) {\n        cout << \"NA\" << endl;\n        return;\n    }\n    complex<long double> ans = (inputs[0] + inputs[n / 2]) / 2.0L;\n    REP(i, n/2) {\n        complex<long double> now = (inputs[i] + inputs[n / 2 + i]) / 2.0L;\n        if (abs(now - ans) > eps) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    cout << ans.real() << \" \" << ans.imag() << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint x[50],y[50];\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>x[i]>>y[i];\n\n    if(N&1){\n        puts(\"NA\");\n        return 0;\n    }\n\n    bool ok=true;\n    rep(i,N/2){\n        if(x[i+1]-x[i]!=-(x[(i+1+N/2)%N]-x[i+N/2]))ok=false;\n        if(y[i+1]-y[i]!=-(y[(i+1+N/2)%N]-y[i+N/2]))ok=false;\n    }\n\n    if(ok)printf(\"%.20f %.20f\\n\",(x[N/2]+x[0])/2.0,(y[N/2]+y[0])/2.0);\n    else puts(\"NA\");\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L; //Line, Segment\n\nconst int SPLIT = 10000;\nconst double EPS = 1e-9;\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\n\nnamespace std {\n  bool operator < (const L& a, const L& b){\n    return abs(a.first-a.second) < abs(b.first-b.second);\n  }\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; \n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(const vector<P>& G, L l){\n  vector<P> ans;\n  for(int i=0;i<(int)G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\ndouble getAngle(P a,P b){\n  return atan2(b.real()-a.real(),b.imag()-a.imag());\n}\n\ndouble getDeg(double a){\n  return 180/M_PI*a;\n}\n\nbool eq(double a,double b){\n  int k = (int)max(log10(a),log10(b));\n  for(int i=0;i<k;i++){\n    a/=10.0; b/=10.0;\n  }\n  //x  printf(\"%.6lf %.6lf\\n\",a , b );\n  if( abs(a-b) < 1E-5 ) return true;\n  return false;\n}\nint N;\nvector<P> V;\n\n\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++){\n    int x,y;\n    cin >> x >> y;\n    V.push_back( P(x,y) );\n  }\n\n  double ar = area(V);\n  if( ar < 0.0 ){\n    reverse(V.begin(),V.end());\n    ar = abs(ar);\n  }\n\n  vector<L> seg;\n  for(int i=0;i<N;i++){\n    int pr = (i+N-1)%N;\n    int nd = (i+1)%N;\n    P st = V[pr];\n    P ed = V[nd];\n    if( ccw(st,V[i],ed) != 1 ) continue;\n    //cout << getDeg(st) << \" \"<< getDeg(ed) << endl;\n    for(int j=0;j<SPLIT;j++){\n      P h = (st+ed)/(double)2.0;\n\n      L s = L(V[i],h);\n      vector<P> r = convex_cut(V,s);\n      double ret = area(r);\n\n      //      cout << V[i] << \" ->\" << h << \" \"<< ret << endl;\n\n      if( ret < ar/2.0 - EPS  ){\n        st = h;\n      }  else if( ret > ar/2.0 + EPS ){\n        ed = h;\n      } else {\n        st = h; break;\n      }\n    }\n    //      cout << V[i] << \" -> \" << st << endl;\n    seg.push_back( L(V[i],st) );\n  }\n\n sort(seg.rbegin(),seg.rend());\n P poin;\n P v1 = (seg[0].second - seg[0].first); \n v1 = v1 / abs(v1);\n for(int i=1;i<(int)seg.size();i++){ \n   P v2 = (seg[i].second - seg[i].first);\n   v2 = v2 / abs(v2);\n   if( !( (eq(v1.real(),v2.real()) && eq(v1.imag(),v2.imag())) ||\n          (eq(v1.real(),-v2.real()) && eq(v1.imag(),-v2.imag())) ) ){\n     poin = crossPoint(seg[0],seg[i]);\n     break;\n   }\n }\n //x    cout << poin << endl;\n\n  bool f = true;\n  for(int i=0;i<N;i++){\n    P p = V[i];\n    P nex = V[(i+1)%N];\n    P ks = (nex-p)/(double)SPLIT;\n    for(int j=0;j<SPLIT;j++,p+=ks){\n      L s = L(p,poin);\n      vector<P> r = convex_cut(V,s);\n      //     printf(\"%.10lf %.10lf\\n\",area(r), ar/2.0 );\n      if( !eq(area(r),ar/2.0) ) f = false;\n      if(!f) break;\n    }\n    if(!f) break;\n  }\n\n  if( f ) printf(\"%.10lf %.10lf\\n\",poin.real() , poin.imag() );\n  else cout << \"NA\" << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<long double, long double> Point;\n\nconst long double EPS = 1e-5;\n\nlong double cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\nlong double dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b) - 0.0) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a = Point(input[i+1].first - input[i].first, input[i+1].second - input[i].second);\n    Point b = Point(input[(i+input.size()/2+1)%input.size()].first - input[i+input.size()/2].first,\n                    input[(i+input.size()/2+1)%input.size()].second - input[i+input.size()/2].second);\n    if(!isParallel(a, b)) return false;\n    if(!(abs(dist(a, Point(0.0, 0.0)) - dist(b, Point(0.0, 0.0))) < EPS)) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  \n  ans = Point((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else cout << ans.first << ' ' << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n \nusing namespace std;\n \n/* ??????????????¬ */\n#include <complex>\n \ntypedef long double ld;\ntypedef complex<ld> Point;//????´???°\n \nconst ld eps = 1e-9, pi = acos(-1.0);\n \nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\n \n// ????????\\???\nPoint input_point() {\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n \n// ????????????????????????\nbool eq(ld a, ld b) {\n    return (abs(a - b) < eps);\n}\n \n// ??????\nld dot(Point a, Point b) {\n    return real(conj(a) * b);//conj::??±???????´???°\n}\n \n// ??????\nld cross(Point a, Point b) {\n    return imag(conj(a) * b);\n}\n \n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n \n/*int main(){\nPoint a(1,1),b(2,2);\nLine l(a,b);\n}*/\n \n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n \n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n    if (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n    if (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n    if (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n    return 0;                          // a,c,b???????????´???????????¶\n}\n \n \n/* ???????????? */\n \n// ??´?????¨??´??????????????????\n//l::??´??????s::??????\nbool isis_ll(Line l, Line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n \n// ??´?????¨????????????????????? *slide??????\nbool isis_ls(Line l, Line s) {\n    return isis_ll(l, s) &&\n        (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n \n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n        ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n \n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n \n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n \n// ??????????¶?\nPoint proj(Line l, Point p) {\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    //norm::??¶?????????2???\n    return l.a + t * (l.a - l.b);\n}\n \n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n \n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n    return abs(p - proj(l, p));\n}\n \n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n \n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n \n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n \n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n    if (isis_ss(s, t)) return 0;\n    return min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n \n \n/* ??? */\n \n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps) dfr = 0.0;\n    else if (dfr < 0.0) return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n \n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps) {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n \n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p)) res.push_back(p);\n    return res;\n}\n \n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l)) { return ret; }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps) return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n \n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps) {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n \n \n/* ????§???¢ */\n \ntypedef vector<Point> Polygon;\n \n// ??¢???\nld area(const Polygon &p) {\n    ld res = 0;\n    int n = p.size();\n    REP(j, n) res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n \n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n) {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n \n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p)) return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n \n// ??????\nPolygon convex_hull(vector<Point> ps) {\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n    ch.resize(k - 1);\n    return ch;\n}\n \n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n    int n = ps.size();\n    Polygon Q;\n    REP(i, n) {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n \ntypedef pair<ld, ld> P;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n \n    int n;cin>>n;\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n        ld x,y;cin>>x>>y;\n        v[i]=P(x,y);\n    }\n    ld ma=0;\n    P mid;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            ld len= (v[i].first-v[j].first)*(v[i].first-v[j].first)+(v[i].second-v[j].second)*(v[i].second-v[j].second);\n            if(len>ma){\n                ma=len;\n                mid= P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n            }\n        }\n    }\n//    cout<<mid.first<<\" \"<<mid.second<<endl;\n//    cout<<ma<<endl;\n    if(ma==0) cout<<\"NA\"<<endl;\n    else{\n        for(int i=0;i<n;i++){\n            bool flag=false;\n            for(int j=0;j<n;j++){\n                P mi=P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n                if(eq(mi.first,mid.first)&&eq(mi.second,mid.second)){\n                    flag=true;break;\n                }\n            }\n            if(!flag){\n                cout<<\"NA\"<<endl;\n                return 0;\n            }\n        }\n         \n        cout<<fixed<<setprecision(10)<<mid.first<<\" \"<<mid.second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nint main(){\n    int n;cin>>n;\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n        double x,y;cin>>x>>y;\n        v[i]=P(x,y);\n    }\n    double cx,cy,ma=-1;\n    for(int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            double x1=v[i].first,y1=v[i].second,x2=v[j].first,y2=v[j].second;\n            double tmp=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\n            if(tmp>ma){\n                ma=tmp;\n                cx=(x1+x2)/2;cy=(y1+y2)/2;\n            }\n        }\n    }\n    bool flag=true;\n    for(int i=0;i<n;i++){\n        double x1=v[i].first,y1=v[i].second;\n        bool ftmp=false;\n        for(int j=0;j<n;j++){\n            double x2=v[j].first,y2=v[j].second;\n            if(cx==(x1+x2)/2 && cy==(y1+y2)/2) ftmp=true;\n        }\n        flag&=ftmp;\n    }\n    if(flag)cout<<fixed<<setprecision(10)<<cx<<\" \"<<cy<<endl;\n    else cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long double ld;\n\nstruct Point {\n    ld x, y;\n    Point(ld x=0, ld y=0) : x(x), y(y) {}\n    bool operator==(const Point &o) const {\n        return x == o.x && y == o.y;\n    }\n    Point operator+(const Point &o) const {\n        return Point(x + o.x, y + o.y);\n    }\n    Point operator/(int n) const {\n        return Point(x/n, y/n);\n    }\n    Point operator+=(const Point &o) {\n        x += o.x;\n        y += o.y;\n        return Point(x, y);\n    }\n    Point operator/=(int n) {\n        x /= n;\n        y /= n;\n        return Point(x, y);\n    }\n    string to_s() {\n        char buf[1024];\n        sprintf(buf, \"%7llf %7llf\", x, y);\n        return string(buf);\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    if (n % 2 == 1) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    vector<Point> vs(n);\n    Point g(0, 0); // 重心\n    for (int i = 0; i < n; i++) {\n        ld x, y;\n        cin >> x >> y;\n        vs[i] = Point(x, y);\n        g += vs[i];\n    }\n    g /= n;\n\n    for (int i = 0; i < n/2; i++) {\n        if (not(vs[i] + vs[i+n/2] == g + g)) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << g.to_s() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\n//////////////////////////////////////////////////////\nusing Real=double;\nusing Point=complex<Real>;\nconst Real EPS=1e-10;\nconst Real pi=acosl(-1);\n//入出力補助\nistream &operator>>(istream &is,Point &p){\n    Real a,b;\n    is>>a>>b;\n    p=Point(a,b);\n    return is;\n}\nostream &operator<<(ostream &os,Point &p){\n    return os<<fixed<<setprecision(12)<<p.real()<<' '<<p.imag();\n}\n \ninline bool eq(Real a,Real b){\n    return fabs(a-b)<EPS;\n}\nPoint operator*(const Point &p,const Real &d){\n    return Point(real(p)*d,imag(p)*d);\n}\nstruct Line{\n    Point p1,p2;\n    Line()=default;\n    Line(Point p1,Point p2):p1(p1),p2(p2){}\n \n    //Ax + By = C\n    Line(Real A,Real B,Real C){\n       if(eq(A,0))     p1=Point(0,C/B),p2=Point(1,C/B);\n       else if(eq(B,0))p1=Point(C/A,0),p2=Point(C/A,1);\n       else            p1=Point(0,C/B),p2=Point(C/A,0);\n    }\n};\nstruct Segment:Line{\n   Segment()=default;\n   Segment(Point p1,Point p2):Line(p1,p2){}\n};\nstruct Circle{\n    Point center;\n    Real r;\n    Circle()=default;\n    Circle(Point center,Real r):center(center),r(r){}\n};\n/////////////////////////////////////////////////////////\n \n \n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta,const Point &p) {\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\n \nReal radian_to_degree(Real r){\n    return r*180.0/pi;\n}\n \nReal degree_to_radian(Real d){\n    return d*pi/180.0;\n}\n \n//三角形の面積，サラスの公式\nReal area_triangle(Point a,Point b,Point c){\n    Point x=b-a,y=c-a;\n    return fabs(x.real()*y.imag()-x.imag()*y.real())/2;\n}\n \n//v\n//外積\nReal cross(Point a,Point b){\n    return real(a)*imag(b)-imag(a)*real(b);\n}\n//v\n//内積\nReal dot(Point a,Point b) {\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n \n//v\n//平行判定，外積0かをみる\nbool parallel(Line a,Line b){\n    return eq(cross(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n//v\n//垂直判定，内積0かをみる\nbool orthogonal(Line a,Line b){\n    return eq(dot(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n \n//v\n//正射影，pからlに下した垂線の足を求める\nPoint projection(Line l,Point p){\n    //ベクトルl上のどの位置に垂線の足が来るか求める\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\nPoint projection(Segment l,Point p){\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\n \n//v\n//反射，直線lに関し点pと線対称な点を返す\nPoint reflection(Line l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\nPoint reflection(Segment l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\n \n//二点間の距離\nReal dis(Point a,Point b){\n    return abs(a-b);\n} \n//点と直線の距離\nReal dis(Line l,Point p){\n    return abs(p-projection(l,p));\n}\n \n//v\n//COUNTER CLOCKWISE，返す値は↓を参照\n//https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_C\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS)       return  1;//COUNTER CLOCKWISE\n    else if(cross(b,c)<-EPS) return -1;//CLOCKWISE\n    else if(dot(b,c)<0)      return  2;//c--a--b ONLINE BACK\n    else if(norm(b)<norm(c)) return -2;//a--b--c ONLINE FRONT\n    else                     return  0;//a--c--b ON SEGMENT\n}\n \n//v\n//3点が作る三角形の外心\n//面積0の三角形を渡すと分母に面積があるので壊れるかも\nPoint circumcenter(Point A,Point B,Point C){\n    Real S=area_triangle(A,B,C);\n    Real a=dis(B,C),b=dis(A,C),c=dis(A,B);\n    return A*(a*a*(b*b+c*c-a*a)/(16*S*S))+B*(b*b*(c*c+a*a-b*b)/(16*S*S))+C*(c*c*(a*a+b*b-c*c)/(16*S*S));\n}\n \n//交差判定\n//直線状に乗るか\nbool intersect(Line l,Point p){\n    return abs(ccw(l.p1,l.p2,p))!=1;\n}\n//直線の交差判定，外積\nbool intersect(Line l1,Line l2){\n    return abs(cross(l1.p2-l1.p1,l2.p2-l2.p1))>EPS or\n        abs(cross(l1.p2-l1.p1,l2.p2-l1.p1))<EPS;\n}\n//線分に点が乗るかの判定，ccw\nbool intersect(Segment s,Point p){\n    return ccw(s.p1,s.p2,p)==0;\n}\n//直線と線分の交差判定\nbool intersect(Line l,Segment s){\n    return cross(l.p2-l.p1,s.p1-l.p1)*cross(l.p2-l.p1,s.p2-l.p1)<EPS;\n}\n//円と直線の交差判定\nbool intersect(Circle c,Line l){\n    return dis(l,c.center)<=c.r+EPS;\n}\n//円上かどうか，内部かどうかではない\nbool intersect(Circle c,Point p){\n    return abs(abs(p-c.center)-c.r)<EPS;\n}\n//v\n//線分と線分の交差判定\nbool intersect(Segment s,Segment t){\n    return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <=0 and\n        ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;\n}\n//線分と円の交差判定，交点の個数を返す\nint intersect(Circle c,Segment l){\n    Point h=projection(l,c.center);\n    //直線まるっと円の外側\n    if(norm(h-c.center)-c.r*c.r>EPS)    return 0;\n    Real d1=abs(c.center-l.p1),d2=abs(c.center-l.p2);\n    //線分が円内\n    if(d1<c.r+EPS and d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS and d2>c.r+EPS) or (d2<c.r-EPS and d1>c.r+EPS)) return 1;\n    //円の外部にまるまるはみ出ていないか\n    if(dot(l.p1-h,l.p2-h)<0) return 2;\n    return 0;\n}\n//円と円の位置関係，共通接線の個数を返す\nint intersect(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    Real d=abs(c1.center-c2.center);\n    //2円が離れている\n    if(c1.r+c2.r<d)     return 4;\n    //2円が外接する\n    if(eq(c1.r+c2.r,d)) return 3;\n    //2円が交わる\n    if(c1.r-c2.r<d)     return 2;\n    //円が内接する\n    if(eq(c1.r-c2.r,d)) return 1;\n    //内包\n                        return 0;\n}\n \n//交点\n//線分の交点はintersectをチェックしてokなら直線の交点をやる\n//intersectをチェックすること\n//v\nPoint crosspoint(Line l,Line m){\n    Real A=cross(m.p2-m.p1,m.p1-l.p1);\n    Real B=cross(m.p2-m.p1,l.p2-l.p1);\n    if(eq(A,0) and eq(B,0)) return l.p1;\n    if(eq(B,0))             throw \"NAI\";\n    return l.p1+A/B*(l.p2-l.p1);    \n}\nPoint crosspoint(Segment l,Segment m){\n    return crosspoint(Line(l),Line(m));\n}\nvector<Point> crosspoint(Circle c,Line l){\n    vector<Point> ret;\n    Point h=projection(l,c.center);\n    Real d=sqrt(c.r*c.r-norm(h-c.center));\n    Point e=(l.p2-l.p1)*(1/abs(l.p2-l.p1));\n    if(c.r*c.r+EPS<norm(h-c.center)) return ret;\n    if(eq(dis(l,c.center),c.r)){\n        ret.push_back(h);\n        return ret;\n    }\n    ret.push_back(h+e*d);ret.push_back(h-e*d);\n    return ret;\n}\n//要verify，\nvector<Point> crosspoint(Circle c,Segment s){\n    Line l=Line(s.p1,s.p2);\n    int ko=intersect(c,s);\n    if(ko==2) return crosspoint(c,l);\n    vector<Point> ret;\n    if(ko==0) return ret;\n    ret=crosspoint(c,l);\n    if(ret.size()==1) return ret;\n    vector<Point> rret;\n    //交点で挟める方を返す\n    if(dot(s.p1-ret[0],s.p2-ret[0])<0)  rret.push_back(ret[0]);\n    else                                rret.push_back(ret[1]);\n    return rret;\n}\n//v\nvector<Point> crosspoint(Circle c1,Circle c2){\n    vector<Point> ret;\n    int isec=intersect(c1,c2);\n    if(isec==0 or isec==4) return ret;\n    Real d=abs(c1.center-c2.center);\n    Real a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    Real t=atan2(c2.center.imag()-c1.center.imag(),c2.center.real()-c1.center.real());\n    ret.push_back(c1.center+Point(cos(t+a)*c1.r,sin(t+a)*c1.r));\n    ret.push_back(c1.center+Point(cos(t-a)*c1.r,sin(t-a)*c1.r));\n    return ret;\n}\n \n//v\n//点pから引いた円cの接線の接点を返す\nvector<Point> tangent(Circle c,Point p){\n    return crosspoint(c,Circle(p,sqrt(norm(c.center-p)-c.r*c.r)));\n}\n//v\n//二円の共通接線，Lineの2点は接点を表す\nvector<Line> tangent(Circle c1,Circle c2){\n    vector<Line> ret;\n    if(c1.r<c2.r) swap(c1,c2);\n    Real g=norm(c1.center-c2.center);\n    //中心が一致するならない\n    if(eq(g,0)) return ret;\n    Point u=(c2.center-c1.center)/sqrt(g);\n    Point v=rotate(pi*0.5,u);\n    for(int s:{-1,1}){\n        Real h=(c1.r+s*c2.r)/sqrt(g);\n        if(eq(1-h*h,0)){\n            ret.push_back(Line(c1.center+u*c1.r,c1.center+(u+v)*c1.r));\n        }\n        else if(1-h*h>0){\n            Point uu=u*h,vv=v*sqrt(1-h*h);\n            ret.push_back(Line(c1.center+(uu+vv)*c1.r,c2.center-(uu+vv)*c2.r*s));\n            ret.push_back(Line(c1.center+(uu-vv)*c1.r,c2.center-(uu-vv)*c2.r*s));\n        }\n    }\n    return ret;\n}\n \n//v\n//最小包含円を返す　計算量は期待値O(n)\nCircle MinimumBoundingCircle(vector<Point> v){\n    int n=v.size();\n  \n    //ランダムシャッフル．いぢわるされたくないもんだ\n    mt19937 mt(time(0));\n    shuffle(v.begin(),v.end(),mt);\n    Circle ret(0,0);\n    //2点で円を作る\n    auto make_circle2=[&](Point a,Point b){\n        return Circle((a+b)*0.5,dis(a,b)/2);\n    };\n    //3点で円を作る\n    auto make_circle3=[&](Point A,Point B,Point C){\n        Point cent=circumcenter(A,B,C);\n        return Circle(cent,dis(cent,A));\n    };\n    auto isIn=[&](Point a){\n        return dis(ret.center,a)<ret.r+EPS;\n    };\n \n    ret=make_circle2(v[0],v[1]);\n    for(int i=2;i<n;i++){\n        //v[i]が円に入っていないなら\n        if(!isIn(v[i])){\n            //円内にないなら点v[i]は必ず円周上に来る\n            ret=make_circle2(v[0],v[i]);\n            for(int j=1;j<i;j++){\n                if(!isIn(v[j])){\n                    //この時iとjが円周上を考える\n                    ret=make_circle2(v[i],v[j]);\n                    //最後の1点の決定\n                    for(int k=0;k<j;k++){\n                        if(!isIn(v[k])){\n                            ret=make_circle3(v[i],v[j],v[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n \n// v\n// 最近点対\nReal closest_pair(vector<Point> ps){\n    sort(ALL(ps),[&](Point a,Point b){\n        return real(a)<real(b);\n    });\n \n    function<Real(int,int)> rec=[&](int l,int r){\n        if(r-l<=1) return 1e18;\n        int m=(l+r)/2;\n        Real x=real(ps[m]);\n        Real ret=min(rec(l,m),rec(m,r));\n        inplace_merge(begin(ps)+l,begin(ps)+m,begin(ps)+r,[&](Point a,Point b){\n            return imag(a)<imag(b);\n        });\n        // 分割を跨いで最小距離があるか調べる\n        vector<Point> b;\n        for(int i=l;i<r;i++){\n            if(abs(real(ps[i])-x)>=ret) continue;\n            for(int j=(int)b.size()-1;j>=0;j--){\n                if(abs(imag(ps[i]-b[j]))>=ret) break;\n                ret=min(ret,abs(ps[i]-b[j]));\n            }\n            b.push_back(ps[i]);\n        }\n        return ret;\n    };\n    return rec(0,(int)ps.size());\n}\n\n\nsigned main(){\n    int n;cin>>n;\n    vector<Point> v(n);\n    cin>>v;\n    if(n%2){\n        cout<<\"NA\"<<endl;\n        return 0;\n    }\n    Point res=Point(0,0);\n    rep(i,n)res+=v[i];\n    res/=(0.0+n);\n    rep(i,n/2){\n        Point x=(v[i]+v[i+n/2])/2.0;\n        if(!eq(real(x),real(res)) or !eq(imag(x),imag(res))){\n            cout<<\"NA\"<<endl;\n            return 0;\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\n\nP p[55];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  REP(i, n) cin >> p[i];\n\n  if(n%2) {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n\n  bool flag = true;\n  REP(i, n) {\n    // p[i]-p[i+1] と p[i+n/2]-p[i+n/2+1] について\n    L l1(p[i], p[(i+1)%n]), l2(p[(i+n/2)%n], p[(i+n/2+1)%n]);\n    if(!parallel(l1, l2) || sgn(abs(vec(l1))-abs(vec(l2))) != 0) {\n      flag = false;\n    }\n  }\n\n  cout << fixed << setprecision(9) << endl;\n  if(flag) cout << (p[0].real()+p[n/2].real())/2.0 << \" \" << (p[0].imag()+p[n/2].imag())/2.0 << endl;\n  else cout << \"NA\" << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nstruct point { int x, y; };\nstruct line { point p1, p2; };\n\nbool parallel(line l1, line l2) {\n  int s1 = (l1.p1.y - l1.p2.y) * (l2.p1.x - l2.p2.x);\n  int s2 = (l1.p1.x - l1.p2.x) * (l2.p1.y - l2.p2.y);\n  return s1 == s2;\n}\n\nint N, X[50], Y[50];\n\nint main(void) {\n  cin >> N;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n\n  if(N % 2) {\n    cout << \"NA\" << endl;\n  } else {\n    bool ans = true;\n    REP(i, 0, N / 2) {\n      line l1 = (line) {\n        (point) { X[i], Y[i] },\n        (point) { X[i + 1], Y[i + 1] },\n      };\n      line l2 = (line) {\n        (point) { X[i + N / 2], Y[i + N / 2] },\n        (point) { X[(i + N / 2 + 1) % N], Y[(i + N / 2 + 1) % N] },\n      };\n      if(!parallel(l1, l2)) ans = false;\n    }\n    if(!ans) cout << \"NA\" << endl;\n    else {\n      double cx = (X[0] + X[N / 2]) / 2.0;\n      double cy = (Y[0] + Y[N / 2]) / 2.0;\n      printf(\"%.8lf %.8lf\\n\", cx, cy);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nll n;\nld x[51];\nld y[51];\nld c_x;\nld c_y;\nld eps = 0.000001;\n\nint main(){\n  cin >> n;\n  for(ll i = 0;i < n;i++) cin >> x[i] >> y[i];\n\n  if(n%2 != 0){\n    cout << \"NA\" << endl;\n    exit(0);\n  }\n  c_x = (*min_element(x,x+n)+*max_element(x,x+n))/2;\n  c_y = (*min_element(y,y+n)+*max_element(y,y+n))/2;\n  // cerr << c_x << \" \" << c_y << endl;\n  for(ll i = 0;i < n;i++){\n    // cerr << i << \" \";\n    // cerr << x[i] << \" \" ;\n    // cerr << (x[i]-c_x) << \" \" << (c_x-x[(i+n/2)%n]) << endl;\n    if(abs((x[i]-c_x) - (c_x-x[(i+n/2)%n])) < eps && abs((y[i]-c_y)-(c_y-y[(i+n/2)%n])) < eps){\n\n    }else{\n      cout << \"NA\" << endl;\n      exit(0);\n    }\n  }\n  cout << c_x << \" \" << c_y << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint n;\nint x[50], y[50];\n\nint main() {\n\tint i;\n\t\n\tcin >> n; if (n % 2) { cout << \"NA\" << endl; return 0; }\n\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tif (x[(i + 1) % n] - x[i] != x[(n/2 + i) % n] - x[(n/2 + i + 1) % n]) break;\n\t\tif (y[(i + 1) % n] - y[i] != y[(n/2 + i) % n] - y[(n/2 + i + 1) % n]) break;\n\t}\n\tif (i < n) { cout << \"NA\" << endl; }\n\telse { printf(\"%.14f %.14f\\n\", (x[0] + x[n/2]) * 0.5, (y[0] + y[n/2]) * 0.5); }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> polygon;\n\ndouble const eps = 1e-7;\n\npolygon poly;\n\nstruct line : public vector<P> {\n  line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ndouble dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\ndouble cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nint ccw(P const& p, P a, P b) {\n  a -= p, b -= p;\n  if(cross(a, b) > eps) return +1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nP crosspoint(line const& a, line const& b) {\n  auto va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < eps) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n\npolygon convex_cut(polygon const& g, line const& l) {\n  polygon ret;\n  int n = g.size();\n  rep(i, n) {\n    auto curr = g[i % n], next = g[(i + 1) % n];\n    if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n    if(ccw(l[0], l[1], curr) * ccw(l[0], l[1], next) < 0) {\n      ret.push_back(crosspoint(line(curr, next), l));\n    }\n  }\n  return ret;\n}\n\ndouble area(polygon const& g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i + 1) % g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\nbool ok(P const& p) {\n  for(double rad = 0.0; rad < 2 * cos(-1); rad += 0.01) {\n    line l = line(p, p + polar(1.0, rad));\n    auto k = convex_cut(poly, l);\n    if(abs(area(k) - area(poly) / 2.0) > eps) return false;\n  }\n  return true;\n}\n\nint main() {\n  int N; cin >> N;\n  P g;\n  rep(i, N) {\n    double x, y; cin >> x >> y;\n    poly.push_back(P(x, y));\n    g += P(x, y);\n  }\n  g /= N;\n  if(N % 2 || !ok(g)) cout << \"NA\" << endl;\n  else printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=200005,INF=1<<20;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<pair<double,double>> S(N);\n    for(int i=0;i<N;i++){\n        cin>>S[i].first>>S[i].second;\n    }\n    \n    if(N%2){\n        cout<<\"NA\"<<endl;\n    }else{\n        double x=(S[0].first+S[N/2].first)/2.0,y=(S[0].second+S[N/2].second)/2.0;\n        \n        for(int i=1;i<N/2;i++){\n            double xx=(S[i].first+S[i+N/2].first)/2.0,yy=(S[i].second+S[i+N/2].second)/2.0;\n            \n            if(x!=xx||y!=yy){\n                cout<<\"NA\"<<endl;\n                return 0;\n            }\n        }\n        cout<<setprecision(25)<<x<<\" \"<<y<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nusing namespace std;\n\ntypedef double Real;\n\nReal EPS = 1e-8;\nconst Real PI = acos(-1);\n\nint sgn(Real a, Real b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\nReal sqr(Real a){return sqrt(max(a,(Real)0));}\n\nstruct Point{\n  Real add(Real a, Real b){\n    if(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n    return a+b;\n  }\n  Real x, y;\n  Point(){}\n  Point(Real x,Real y) : x(x) , y(y){}\n  Point operator + (Point p){return Point(add(x,p.x), add(y,p.y));}\n  Point operator - (Point p){return Point(add(x,-p.x), add(y,-p.y));}\n  Point operator * (Real d){return Point(x*d,y*d);}\n  Point operator / (Real d){return Point(x/d,y/d);}\n  bool operator == (Point p){return !sgn(dist(p));}\n  \n  bool operator < (Point p)const{return (p.x!=x)?x<p.x:y<p.y;}\n  Real norm(){return sqr(x*x+y*y);}\n  Real dist(Point a){return (*this-a).norm();}\n  Real dot(Point a){return x*a.x+y*a.y;}\n  Real cross(Point a){return x*a.y-y*a.x;}\n  Point rotate(Real r,Point p = Point(0,0)){\n    Real ta=cos(r)*(x-p.x)-sin(r)*(y-p.y)+p.x;\n    Real tb=sin(r)*(x-p.x)+cos(r)*(y-p.y)+p.y;\n    return Point(ta,tb);\n  }\n  Real arg(){\n    if(sgn(x)>0)return atan(y/x);\n    if(sgn(x)<0)return atan(y/x)+PI;\n    if(sgn(y)>0)return PI/2;\n    if(sgn(y)<0)return 3*PI/2;\n    return 0;\n  }\n};\n//a -> b -> c\nint ccw(Point a, Point b, Point c) {\n  b = b-a; c = c-a;\n  if (b.cross(c) > 0) return +1; // counter clockwise\n  if (b.cross(c) < 0) return -1; // clockwise\n  if (b.dot(c) < 0) return +2; // c--a--b on line\n  if (b.norm() < c.norm()) return -2; // a--b--c on line\n  return 0; // a--c--b on line\n}\n\nstruct Line{\n  Point a,b;\n  Line(){}\n  Line(Point a,Point b):a(a),b(b){}\n  bool on(Point c){return abs(ccw(a,b,c))!=1;}\n  Real dist(Point c){return abs((b-a).cross(c-a))/(b-a).norm();}\n  bool isOrthogonal(Line l){return (a-b).dot(l.a-l.b)==0.0;}\n  bool isParallel(Line l){return (a-b).cross(l.a-l.b)==0.0;}\n  bool isIntersection(Line l){return !((a-b).cross(l.a-l.b)==0.0);}\n};\n\nstruct Segment: public Line{\n  Segment(){}\n  Segment(Point a,Point b):Line(a,b){}\n  bool on(Point c){return ccw(a,b,c)==0;}\n  bool on(Line l){return l.on(a)&&l.on(b);}\n  bool overlap(Segment s){\n    return isParallel(s) && (on(s.a)||on(s.b)||s.on(a)||s.on(b));\n  }\n  bool isParallel(Segment s){return (a-b).cross(s.a-s.b)==0.0;}\n  Real dist(Point c){\n    if((b-a).dot(c-a)<EPS)return c.dist(a);\n    if((a-b).dot(c-b)<EPS)return c.dist(b);\n    return abs((b-a).cross(c-a))/b.dist(a);\n  }\n\n  bool isIntersection(Line l){\n    return (ccw(l.a,l.b,a)*ccw(l.a,l.b,b)<0);\n  }\n\n  bool isIntersection(Segment s){\n    return (ccw(a,b,s.a)*ccw(a,b,s.b)<=0 &&\n\t    ccw(s.a,s.b,a)*ccw(s.a,s.b,b)<=0);\n  }\n\n  Point intersectionPoint(Segment s){\n    Point q=s.b-s.a;\n    Real d1=abs(q.cross(a-s.a));\n    Real d2=abs(q.cross(b-s.a));\n    Real t=d1/(d1+d2);\n    return a+(b-a)*t;\n  }\n  \n  Point intersectionPoint(Line l){\n    if(isIntersection(l)){\n      return intersectionPoint(Segment(l.a,l.b));\n    }\n    cout << \"came\" << endl;\n  }\n};\n\n\nstruct Polygon{\n  vector<Point>v;\n  Polygon(){}\n  Polygon(int n){v.resize(n);}\n  Polygon(vector<Point>v):v(v){}\n\n  void resize(int n){\n    v.resize(n);\n  }\n\n  Real area(){\n    Real area=0;\n    for(int i=0;i<v.size();i++)\n      area+=(curr(v,i).x-next(v,i).x)*(curr(v,i).y+next(v,i).y);\n    return abs(area)/2.0;\n  }\n\n  Polygon convexCut(Line l){\n    vector<Point>res;\n    for(int i=0;i<v.size();i++){\n      Point a=curr(v,i),b=next(v,i),p=l.b-l.a;\n      if(ccw(l.a,l.b,a)!=-1)res.push_back(a);\n      if(sgn(p.cross(a-l.a)*p.cross(b-l.a))<0)\n\tres.push_back(Segment(a,b).intersectionPoint(l));\n    }\n    return res;\n  }\n};\n\nReal maxx,maxy;\nPolygon pol;\n\nReal f(Real x){\n  Polygon l=pol.convexCut(Line(Point(x,0),Point(x,maxy)));\n  Polygon r=pol.convexCut(Line(Point(x,maxy),Point(x,0)));\n  return abs(l.area()-r.area());\n}\n\nReal f2(Real y){\n  Polygon l=pol.convexCut(Line(Point(0,y),Point(maxx,y)));\n  Polygon r=pol.convexCut(Line(Point(maxx,y),Point(0,y)));\n  return abs(l.area()-r.area());\n}\n\nconst int maxLoop=72;\nReal searchX(Real l,Real r){\n  for(int loop=0;loop<maxLoop;loop++){\n    if(f((l*2+r)/3)>f((l+r*2)/3))r=(l+r*2)/3;\n    else l=(l*2+r)/3;\n  }\n  return (l+r)/4;\n}\n\nReal searchY(Real l,Real r){\n  for(int loop=0;loop<maxLoop;loop++){\n    if(f2((l*2+r)/3)>f2((l+r*2)/3))r=(l+r*2)/3;\n    else l=(l*2+r)/3;\n  }\n  return (l+r)/4;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n  pol.resize(n);\n  for(int i=0;i<n;i++){\n    cin >> pol.v[i].x >> pol.v[i].y;\n    maxx=max(maxx,pol.v[i].x);\n    maxy=max(maxy,pol.v[i].y);\n  }\n\n  Point res=Point(searchX(0,maxx),searchY(0,maxy));\n  bool can=true;\n  for(int i=0;i<1000;i++){\n    for(int j=0;j<<pol.v.size();j++){\n      pol.v[j]=pol.v[j].rotate(0.0001,res);\n    }\n    can&=f(res.x)<EPS;\n  }\n\n  if(can)printf(\"%.5f %.5f\\n\",res.x,res.y);\n  else cout << \"NA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-11;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) > total_area/2-EPS){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    assert(\"nyan\");\n}\n\n// 角からには未対応\npoint find_opposite_point_myan(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size()-1;i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) > total_area/2-EPS){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n}\n\n\nvoid cerr_line(line l){\n    cerr << l.first << \" \" << l.second << endl;\n}\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i];\n        point op = find_opposite_point_myan(ver,p,i);\n        chop.push_back(line(p,op));\n        cerr_line(line(p,op));\n    }\n\n    bool ok = true;\n    bool first = true;\n    point ret;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                cerr << p << endl;\n                if(first){\n                    ret = p;\n                    first = false;\n                }else{\n                    if(abs(p-ret) > EPS) ok = false;\n                }\n            }\n        }\n    }\n\n    if(ok){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  double a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!abs((a[i]+a[(i+n/2)%n])/2-c)<=0.0001||!abs((b[i]+b[(i+n/2)%n])/2-c))<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n#include <stdio.h>\n \nclass Point {\npublic:\n    Point();\n    Point(double x_in, double y_in);\n \n    Point  operator+(const Point& obj);\n    Point  operator-(const Point& obj);\n    Point  operator*(const double n);\n    Point  operator/(const double n);\n \n    void set(double x_in, double y_in);\n \n    double x;\n    double y;\n};\n \nPoint::Point() {\n    x = 0;\n    y = 0;\n}\n \nPoint::Point(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \nPoint Point::operator+(const Point& obj) {\n    Point temp;\n    temp.x = x + obj.x;\n    temp.y = y + obj.y;\n    return temp;\n}\n \nPoint Point::operator-(const Point& obj) {\n    Point temp;\n    temp.x = x - obj.x;\n    temp.y = y - obj.y;\n    return temp;\n}\n \nPoint Point::operator*(const double n) {\n    Point temp;\n    temp.x = x * n;\n    temp.y = y * n;\n    return temp;\n}\n \nPoint Point::operator/(const double n) {\n    Point temp;\n    temp.x = x / n;\n    temp.y = y / n;\n    return temp;\n}\n \nvoid Point::set(double x_in, double y_in) {\n    x = x_in;\n    y = y_in;\n}\n \ndouble abs(Point point) {\n    return sqrt(point.x * point.x + point.y * point.y);\n}\n \nint N;\nPoint V[50];\n \nstd::string solve() {\n    if (N % 2 != 0) return \"NA\";\n    Point center = (V[0] + V[N / 2]) / 2.0;\n    for (int i = 1; i < N / 2; i++) {\n        Point median = (V[i] + V[i + N / 2]) / 2.0;\n        Point dist = center - median;\n        if (abs(dist) >= 0.00001) {\n            return \"NA\";\n        }\n    }\n    char str[128];\n    sprintf(str, \"%.5f %.5f\", center.x, center.y);\n    return str;\n}\n \nint main() {\n    //入力\n    std::cin >> N;\n    double x, y;\n    for (int i = 0; i < N; i++) {\n        std::cin >> x >> y;\n        V[i].set(x, y);\n    }\n    //演算\n    std::string answer = solve();\n    //出力\n    std::cout << answer << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n  P g;\n  for(int i = 0; i < N; ++i) {\n    g += ps[i];\n  }\n  g /= N;\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.5f %.5f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint m;\n\tcin>>m;\n\tif(m%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tm/=2;\n\tint a[50],a1[50],b[50],b1[50];\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a[i]>>b[i];\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tcin>>a1[i]>>b1[i];\n\t}\n\tint ans1=a[0]+a1[0],ans2=b[0]+b1[0];\n\tfor(int i=1;i<m;++i){\n\t\tif(a[i]+a1[i]!=ans1){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(b[i]+b1[i]!=ans2){\n\t\t\tcout<<\"NA\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%f %f\",ans1/2.0,ans2/2.0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n#include<queue>\n#include<iomanip>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define EPS 1e-10\n\nusing namespace std;\ntypedef pair<long double,long double> P;\nint N;\nvector<P> p;\n\nint main(){\n  long double x,y;\n  P ans = P(0.0,0.0);\n  cin >> N ;\n  rep(i,N){\n    cin >> x >> y;\n    p.pb(P(x,y));\n    ans.F += x;\n    ans.S += y;\n\n  }\n  if(p.size()%2 != 0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n\n\n  ans.F /= (long double)N;\n  ans.S /= (long double)N;\n\n\n\n  rep(i,N){\n   \n    P dif = P(p[i].F-ans.F,p[i].S-ans.S);\n    P pre = P(ans.F-dif.F,ans.S-dif.S);\n\n    //cout << setiosflags(ios::fixed) << setprecision(3) << \"dif = \" << dif.F << \" \" << dif.S << endl;\t\n\n    //cout << setiosflags(ios::fixed) << setprecision(3) << \"pre = \" << pre.F << \" \" << pre.S << endl;\n\n bool fin = true;\n\n    rep(j,N){\n      if(i == j)continue;\n      if(p[j].F-pre.F < EPS && p[j].S-pre.S < EPS){\n\t//cout << \"NA\" << endl;\n\t//cout << setiosflags(ios::fixed) << setprecision(3) << \"p = \" << p[j].F << \" \" << p[j].S << endl;\t\n\tfin = false;\n      }\n      //else {\n      //cout << setiosflags(ios::fixed) << setprecision(3) << \"now dif = \" << p[j].F-pre.F << \" \" << p[j].S-pre.S << endl;\n      //}     \n\n\n      \n    }\n    if(fin){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(5) << ans.F << \" \" << ans.S << endl;\n\n  return 0;\n}\n\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define INF 1e9\n#define equal(a,b) (fabs(a-b) < EPS)\n \nstruct Point{\n    double x,y;\n \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n \ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n \ntypedef Point Vector;\n \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nbool isParallelSS(const Segment &s1,const Segment &s2){\n    Vector a = s1.t-s1.s;\n    Vector b = s2.t-s2.s;\n    return equal(cross(a,b),0);\n}\n \nPoint getPoint(vector<Point> &p,int N){\n    for(int i = 0 ; i < N/2 ; i++){\n\tSegment a = Segment(p[i],p[i+1]);\n\tSegment b = Segment(p[N/2+i],p[(N/2+i+1)%N]);\n\tif(!isParallelSS(a,b)) return Point(INF,INF);\n\tif(!equal(dist(a.s,a.t),dist(b.s,b.t))){\n\t    return Point(INF,INF);\n\t}\n    }\n    return (p[0]+p[N/2])/2;\n}\n \nint main(){\n    int N;\n    cin >> N;\n    vector<Point> p(N);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> p[i];\n    }\n    if(N&1){\n\tcout << \"NA\" << endl;\n    }else{\n\tPoint res = getPoint(p,N);\n\tif(res.x == INF && res.y == INF){\n\t    cout << \"NA\" << endl;\n\t}else{\n\t    printf(\"%.8f %.8f\\n\",res.x,res.y);\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-3;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n  \n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[(i+1)%n] - x[i];\n    double ay = y[(i+1)%n] - y[i];\n    double bx = x[(i+1+n/2)%n] - x[(i+n/2)%n];\n    double by = y[(i+1+n/2)%n] - y[(i+n/2)%n];\n    ok &= abs(ax*by - bx*ay) < EPS;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    continue;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n  \n  if(ok && ~n%2 && n<7) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol pol){\n    int n=pol.size();\n    if(n&2) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok = true;\n    rep(i,n/2){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-10){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        Pol pol(n);\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            pol[i]=P(x,y);\n        }\n        P ans=solve(pol);\n        if(ans == NA){\n            puts(\"NA\");\n        } else {\n            printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nconstexpr double E = 1e-8;\n\nint main() {\n    int n;\n    std::vector<std::pair<int, int>> v;\n    std::pair<int, int> upperLeft(0, 0), bottomRight(0, 0);\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        int x, y; std::cin >> x >> y;\n        v.push_back(std::make_pair(x, y));\n\n\n        upperLeft.first = std::min(upperLeft.first, x);\n        upperLeft.second = std::max(upperLeft.second, y);\n        bottomRight.first = std::max(bottomRight.first, x);\n        bottomRight.second = std::min(bottomRight.second, y);\n    }\n\n    if (n % 2) {\n        std::cout << \"NA\" << std::endl;\n        return 0;\n    }\n\n    // 重心計算\n    std::pair<double, double> center((upperLeft.first + bottomRight.first) / 2.0, (upperLeft.second + bottomRight.second) / 2.0);\n\n    // 平行移動\n    for (auto& x : v) {\n        x.first -= center.first;\n        x.second -= center.second;\n    }\n\n    // 点対称か調べる\n    bool isOk = true;\n    for (int i = 0; i < v.size(); i++) {\n        const auto& base = v[i];\n        bool isThereCompatiblePoint = false;\n        for (int j = 0; j < v.size(); j++) {\n            if (i != j && v[j].first + base.first < E && v[j].second + base.second < E) {\n                isThereCompatiblePoint = true;\n                break;\n            }\n        }\n        isOk &= isThereCompatiblePoint;\n    }\n\n    if (!isOk) {\n        std::cout << \"NA\" << std::endl;\n    }\n    else {\n        std::cout << std::fixed << std::setprecision(8) << center.first << \" \" << center.second << std::endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define rep(i, a) for (int i = 0; (i) < (int) (a); (i)++)\n#define reps(i, a, b) for (int i = (int) (a); (i) < (int) (b); (i)++)\n#define rrep(i, a) for (int i = (int) a-1; (i) >= 0; (i)--)\n#define rreps(i, a, b) for (int i = (int) (a)-1; (i) >= (int) (b); (i)--)\n#define MP(a, b) make_pair((a), (b))\n#define PB(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n#define PRINT(f) if((f)){cout << (TRUE__) << endl;}else{cout << FALSE__ << endl;}\n#define TRUE__ \"Yes\"\n#define FALSE__ \"No\"\n#define PERM(v) next_permutation(all(v))\n#define UNIQUE(v) sort(all(v));(v).erase(unique(all(v)), v.end())\n#define CIN(type, x) type x;cin >> x\n\n#ifdef LOCAL\n\t#define lcout(a) cout << a;\n\t#define lcoutln(a) cout << a << endl;\n\t#define lcerr(a) cerr << a;\n\t#define lcerrln(a) cerr << a << endl;\n#else\n\t#define lcout(a) \n\t#define lcoutln(a) \n\t#define lcerr(a) \n\t#define lcerrln(a) \n#endif\n\nvector<vector<pair<int, int> > > v(100001);\nstring s;\nint n, m;\n\nbool comp(pair<int, int> p1, pair<int, int> p2)\n{\n\tint l1 = p1.first;\n\tint r1 = p1.second;\n\tint l2 = p2.first;\n\treps(i, l1, r1) {\n\t\tif (s[i] < s[l2]) return true;\n\t\tif (s[i] > s[l2]) return false;\n\t\tl2++;\n\t}\n\treturn false;\n}\n\nbool comp2(pair<int, int> p1, pair<int, int> p2)\n{\n\tint l1 = p1.first;\n\tint r1 = p1.second;\n\tint l2 = p2.first;\n\treps(i, l1, r1) {\n\t\tif (s[i] != s[l2]) return false;\n\t\tl2++;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tcin >> n >> m >> s;\n\tint l = 0;\n\tint r = 1;\n\tint ma = 0;\n\trep(i, m) {\n\t\tCIN(string, st);\n\t\tif (st[0] == 'R') {\n\t\t\tif (st[1] == '+') {\n\t\t\t\tr++;\n\t\t\t} else {\n\t\t\t\tr--;\n\t\t\t}\n\t\t} else if (st[0] == 'L') {\n\t\t\tif (st[1] == '+') {\n\t\t\t\tl++;\n\t\t\t} else {\n\t\t\t\tl--;\n\t\t\t}\n\t\t}\n\t\tv[r-l].PB(MP(l, r));\n\t\tma = max(ma, r-l);\n\t}\n\tint res = 0;\n\treps(i, 1, ma+1) {\n\t\tsort(all(v[i]));\n\t\tv[i].erase(unique(all(v[i])), v[i].end());\n\t\tsort(all(v[i]), comp);\n\t\tv[i].erase(unique(all(v[i]), comp2), v[i].end());\n\t\tres += v[i].size();\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <string>\n#include <tuple>\n#include <random>\n#include <map>\n#include <queue>\n#include <set>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <numeric>\n#include <chrono>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;\n\tif (cross(b, c) < -eps) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n/*\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\ng[from].push_back((Edge) { from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\nint n = p.size(), m = s.size();\nGraph g(n);\nREP(i, m) {\nvector<pair<ld, int>> vec;\nREP(j, n) if (isis_sp(s[i], p[j]))\nvec.emplace_back(abs(s[i].a - p[j]), j);\nsort(ALL(vec));\nREP(j, vec.size() - 1) {\nint from = vec[j].second, to = vec[j + 1].second;\nadd_edge(g, from, to, abs(p[from] - p[to]));\n}\n}\nreturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\nint n = p.size(), m = c.size();\nGraph g(n);\nREP(i, m) {\nvector<pair<ld, int>> vec;\nREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\nvec.emplace_back(arg(c[i].p - p[j]), j);\nsort(ALL(vec));\nREP(j, vec.size() - 1) {\nint from = vec[j].second, to = vec[j + 1].second;\nld angle = vec[j + 1].first - vec[j].first;\nadd_edge(g, from, to, angle * c[i].r);\n}\nif (vec.size() >= 2) {\nint from = vec.back().second, to = vec.front().first;\nld angle = vec.front().first - vec.back().first;\nadd_edge(g, from, to, angle * c[i].r);\n}\n}\nreturn g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\nint N = p.size();\npolygon.clear();\nREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\nvector<vector<tuple<ld, int, bool>>> tup(N);\nREP(i, s.size()) {\nint a = -1, b = -1;\nREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\nREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\nassert(a >= 0 && b >= 0);\ntup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\ntup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n}\nREP(i, N) sort(ALL(tup[i]));\nREP(i, N) {\nREP(j, tup[i].size()) {\nld angle; int pos = j, from = i, to; bool flag;\ntie(angle, to, flag) = tup[i][j];\nif (flag) continue;\nvector<int> ps;\nwhile (!flag) {\nps.push_back(from);\nget<2>(tup[from][pos]) = true;\nseg2p[from][to].push_back(polygon.size());\nseg2p[to][from].push_back(polygon.size());\nangle += pi + eps;\nif (angle > pi) angle -= 2 * pi;\nauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\nif (it == tup[to].end()) it = tup[to].begin();\nfrom = to; tie(angle, to, flag) = *it;\npos = it - tup[from].begin();\n}\npolygon.push_back(ps);\n}\n}\nGraph g(polygon.size());\nREP(i, N) REP(j, i) {\nif (seg2p[i][j].size() == 2) {\nint from = seg2p[i][j][0], to = seg2p[i][j][1];\ng[from].push_back((Edge) { from, to });\ng[to].push_back((Edge) { to, from });\n}\n}\nreturn g;\n}*/\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\ntypedef long long ll;\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvector<Point> ps(N);\n\tfor (int i = 0;i < N;i++)\n\t\tps[i] = input_point();\n\tvector<Line> ls;\n\tfor (int i = 0;i < N;i++)\n\t\tls.push_back(Line(ps[i], ps[(i + 1) % N]));\n\tbool ok = true;\n\tPoint ans = is_ll(Line(ls[0].a, ls[N / 2].a), Line(ls[0].b, ls[N / 2].b));\n\tfor (int i = 0;i < N;i++) {\n\t\tif (N % 2 == 1)\n\t\t\tok = false;\n\t\tif (abs(abs(ls[i].a - ls[i].b) - abs(ls[(i + N / 2) % N].a - ls[(i + N / 2) % N].b)) > eps)\n\t\t\tok = false;\n\t\tPoint now = is_ll(Line(ls[i].a, ls[(i + N / 2) % N].a), Line(ls[i].b, ls[(i + N / 2) % N].b));\n\t\tif (abs(now - ans) > eps)\n\t\t\tok = false;\n\t}\n\tif (!ok)\n\t\tcout << \"NA\" << endl;\n\telse {\n\t\tprintf(\"%.10f %.10f\\n\", real(ans), imag(ans));\n\t}\n\treturn 0;\n}\n/*\n4\n1000000 1000000\n0 1000000\n0 0\n1000000 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  avgx/=N;avgy/=N;\n  //cout<<avgx<<\" \"<<avgy<<endl;\n  avgx=(ps[0]+ps[N/2]).real()/2;\n  avgy=(ps[0]+ps[N/2]).imag()/2;\n  //cout<<avgx<<\" \"<<avgy<<endl;\n  \n  P avgp=P(avgx,avgy);\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  bool ok=false;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(EQV(ps[i],ps2[j])){\n\tfor(int k=0;k<N;k++){\n\t  int a=(k+j)%N;\n\t  int b=(k+i)%N;\n\t  if(!EQV(ps[a],ps2[b])){\n\t    cout<<\"NA\"<<endl;\n\t    return 0;\n\t  }\n\t}\n\tok=true;\n\tbreak;\n      }\n    }\n    if(ok)break;\n  }\n  if(ok)printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  else cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint sqr(int x) { return x * x; }\n\nstruct Point { int x, y; };\n\nvoid putd(double d) { cout << setprecision(9) << setiosflags(ios::fixed) << d; }\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tvector< Point > vp(N);\n\t\n\tfor_(i,0,N) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tvp[i] = Point{x, y};\n\t}\n\t\n\tbool is_collect = true;\n\tint collect_dst = -1;\n\t\n\tfor_(i,0,N) {\n\t\tPoint a = vp[i], b = vp[(i + 1) % N];\n\t\tint dst = sqr(a.x - b.x) + sqr(a.y - b.y);\n\t\t\n\t\tif (collect_dst == -1) collect_dst = dst;\n\t\telse is_collect &= (collect_dst == dst);\n\t}\n\t\n\tif (!is_collect) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tdouble cx = 0, cy = 0;\n\t\n\tfor_(i,0,N) {\n\t\tcx += vp[i].x;\n\t\tcy += vp[i].y;\n\t}\n\t\n\tputd(cx / (double)N);\n\tcout << \" \";\n\tputd(cy / (double)N);\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; !equals(l, r);) {\n    x = (l+r) / 2.0;\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; !equals(l, r);) {\n    y = (l+r) / 2.0;\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-5)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.5f %.5f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble cross(P a, P b){\n  return a.X*b.Y - a.Y*b.X;\n}\n\nbool solve(Poly p){\n  int n = p.size();\n  for(int i = 0; i < n/2; ++i){\n    if(abs(cross(p[i+1]-p[i], p[(n/2+1+i)%n]-p[(n/2+i)%n])) > EPS ||\n       abs(norm(p[i+1]-p[i]) - norm(p[(n/2+1+i)%n]-p[(n/2+i)%n])) > EPS){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  double x, y;\n  Poly p;\n  for(int i = 0; i < N; ++i){\n    cin >> x >> y;\n    p.push_back(P(x,y));\n  }\n  if(N%2){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  P m = (p[0]+p[N/2])/2.0;\n  if(solve(p)) printf(\"%.10lf %.10lf\\n\", m.X, m.Y);\n  else cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nusing Polygon = vector<Point>;\n\nint main() {\n    int n;\n    cin >> n;\n    Polygon v(n);\n    for(auto &&i : v) cin >> i;\n    Point Q = (v[0]+v[n/2])/2;\n    for (int j = 0; j < n; ++j) {\n        Point R = (v[j]+v[(j+n/2)%n])/2;\n        if(abs(Q-R) > EPS){\n            puts(\"NA\");\n            return 0;\n        }\n    }\n    printf(\"%.10lf %.10lf\\n\", Q.x, Q.y);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing ld= long double;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n#define EPS 1e-10\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<ll> x(n),y(n);\n\tld sumx=0,sumy=0;\n\tREP(i,n) {\n\t\tcin>>x[i]>>y[i];\n\t\tsumx+=x[i];\n\t\tsumy+=y[i];\n\t}\n\tsumx/=n;\n\tsumy/=n;\n\tif(n&1){cout<<\"NA\"<<endl;return 0;}\n\tbool ok=true;\n\tREP(i,n/2) {\n\t\tif(abs(sumx*2-(x[i]+x[i+n/2]))>EPS)ok=false;\n\t\tif(abs(sumy*2-(y[i]+y[i+n/2]))>EPS)ok=false;\n\t}\n\tif(ok)cout<<fixed<<setprecision(10)<<sumx<<\" \"<<sumy<<endl;\n\telse cout<<\"NA\"<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "//-------------\n//| ConvexCut |\n//| H28.03.12 |\n//-------------\n\n//---includes---//\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//---defines---//\n#define MAX_N 100000\n#define EPS 1e-14\n#define INF 1e14\n#define INF2 1e12\n\n//---ints---//\nint Q;\nvector<pair<long double, long double>>vec;\nlong double X[MAX_N], Y[MAX_N];\nlong double X1[MAX_N], X2[MAX_N], X3[MAX_N], X4[MAX_N];\nlong double Y1[MAX_N], Y2[MAX_N], Y3[MAX_N], Y4[MAX_N];\n\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; \n\txp[0] = X1 - X2; yp[0] = Y1 - Y2; \n\txp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }\n\tif (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }\n\tif ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }\n\treturn false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { \n\t\treturn make_pair(INF, INF); \n\t}\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }\n\tif (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }\n\tif (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }\n\tlong double XP[4], YP[4], ZP[4];\n\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2;\n\tXP[1] = X3 - X4; YP[1] = Y3 - Y4; \n\tZP[0] = YP[0] / XP[0]; \n\tZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1];\n\tlong double K = (Y5 - Y1) / (ZP[0] - ZP[1]); \n\tlong double L = K*ZP[0]; \n\treturn make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; \n\t\tX2[i] = X[(i + Q / 2) % Q]; \n\t\tY2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { \n\t\tlong long X_1 = vec[i].first, X_2 = vec[i + 1].first;\n\t\tlong double Y_1 = vec[i].second, Y_2 = vec[i + 1].second;\n\t\tif ((X_1 < INF2 || Y_1 < INF2) && (X_2 < INF2 || Y_2 < INF2)) {\n\t\t\tif (fabs(X_1 - X_2) > EPS && fabs(Y_1 - Y_2)>EPS) {\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << vec[0].first << ' ';\n\tcout << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ninline double SQ(double a){\n\treturn a * a;\n}\n\ninline bool EQ(double a, double b){\n\treturn abs(a - b) < EPS;\n}\n\ninline bool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\ninline bool LEQ(double a, double b){\n\treturn a - b < EPS;\n}\n\ninline bool GT(double a, double b){\n\treturn LT(b, a);\n}\n\ninline bool GEQ(double a, double b){\n\treturn LEQ(b, a);\n}\n\nusing Point = complex<double>;\n\n#define x() real()\n#define y() imag()\n\nnamespace std {\n\nbool operator < (const Point &a, const Point &b){\n\treturn a.x() != b.x() ? a.x() < b.x() : a.y() < b.y();\n}\n\ninline istream& operator >> (istream &is, Point &p){\n\tdouble x, y;\n\tis >> x >> y;\n\tp = Point(x, y);\n\treturn is;\n}\n\ninline ostream& operator << (ostream &os, const Point &p){\n\treturn os << p.x() << \" \" << p.y();\n}\n\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nusing Segment = Line;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\nusing Polygon = vector<Point>;\n\ndouble norm(const Point &a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\n\ndouble dot(const Point &a, const Point &b){\n\treturn (conj(a) * b).x();\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn (conj(a) * b).y();\n}\n\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(const Line &l, const Point &p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????§?????? or ????????´???\nbool intersectLL(const Line &l, const Line &m){\n\tPoint va = l.p2 - l.p1, vb = m.p2 - l.p1;\n\treturn !parallel(l, m) || EQ(cross(va, vb), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\tPoint va = l.p2 - l.p1, vb = s.p1 - l.p1, vc = s.p2 - l.p1;\n\treturn LEQ(cross(va, vb) * cross(va, vc), 0.0);\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\tPoint va = l.p1 - p, vb = l.p2 - p;\n\treturn EQ(cross(va, vb), 0.0);\n}\n\nbool intersectSS(const Segment &s, const Segment &t){\n\tPoint a = s.p1, b = s.p2, c = t.p1, d = t.p2;\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0\n\t\t&& ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn ccw(s.p1, s.p2, p) == ON_SEGMENT;\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tPolygon g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> g[i];\n\t}\n\t\n\tbool res = true;\n\t\n\tif (n & 1) res = false;\n\t\n\tfor (int i = 0; i < n / 2; i++){\n\t\tSegment s = {g[i], g[i + 1]};\n\t\tSegment t = {g[i + n / 2], (g[(i + n / 2 + 1) % g.size()])};\n\t\tif (!EQ(abs(s.p1 - s.p2), abs(t.p1 - t.p2))) res = false;\n\t\tif (!parallel(s, t)) res = false;\n\t}\n\t\n\tif (res){\n\t\tcout << (g[0] + g[n / 2]) / 2.0 << endl;\n\t}\n\telse {\n\t\tputs(\"NA\");\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout << fixed << setprecision(20);\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-4;\nconst double INF = 1000000001.0;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\nbool isInter(L s1, L s2){\n   return ( ccw(s1.first ,s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 &&\n\t    ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nP crossPoint(L l, L m){\n   double A = cross(l.second - l.first, m.second - m.first);\n   double B = cross(l.second - l.first, l.second - m.first);\n   if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n   else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\ndouble area(vector<P> v){\n   double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\nvector<P> convex_cut(vector<P> G, L l){\n   vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\nbool equal(double a, double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, double theta){\n   theta = theta * M_PI / 180.0;\n   double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      double l = miny;\n      double r = maxy;\n      double all = area(v);\n      L yoko, tate;\n      while(1){\n//\t cout << l << ' ' << r << endl;\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(-INF,mid),P(INF,mid))));\n\t if(equal(half*2.0, all) || equal(l,r) || l > r){\n\t    yoko = L(P(-INF,mid),P(INF,mid));\n\t    break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(mid,INF),P(mid,-INF))));\n\t if(equal(half*2.0, all) || equal(l,r) || l > r){\n\t    tate = L(P(mid,-INF),P(mid,INF));\n\t    break;\n\t } else if(half*2.0 > all) l = mid;\n\t else r = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n//      printf(\"%.5f %.5f  \",real(ans),imag(ans));\n\n      for(double i=0.0;i<180.0;i+=1.0){\n\t L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\t double half = area(convex_cut(v,line));\n\t if(!equal(half*2.0,all)){\n//\t    printf(\"%.5f %.5f \",half*2.0, all);\n\t    f = false;\n\t    break;\n\t }\n      }\n      if(f) printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n\nconst double EPS = 1e-8;\nusing P = complex<double>;\nusing G = vector<P>;\n\nsigned main(){\n  int n; cin >> n;\n  G g(n);\n  rep(i,n){\n    double x, y; cin >> x >> y;\n    g[i].real(x);\n    g[i].imag(y);\n  }\n\n  if(n & 1){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n\n  P res = (g[0] + g[n/2]) * 0.5;\n  FOR(i,1,n/2){\n    P tmp = (g[i] + g[n/2 + i]) * 0.5;\n    if(abs(res - tmp) > EPS){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  printf(\"%.10lf %.10lf\\n\",res.real(),res.imag());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n  if(points.size()==1)return false;\n  vector<P> v;\n  for(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n  int sign=0;\n  for(int i=1;i<=(int)v.size();i++){\n    int prv=(i-1+v.size())%v.size();\n    int cur=i%v.size();\n    double c=cross(v[prv],v[cur]);\n    if(EQ(c,0))continue;\n    else if(sign==0){\n      if(c>0)sign=1;\n      else sign=-1;\n    }\n    else{\n      if(sign==-1&&c>0)return false;\n      else if(sign==1&&c<0)return false;\n    }\n  }\n  return true;\n}\nstruct Rec{\n  vector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  // 線分が平行な場合は重なっていないことにする\n  if(abs(cross(a2-a1,b2-b1)) < EPS){\n    return 0;\n  }\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n    ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n  // aの各頂点がbの中に存在しているかチェック\n  for(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n  // 逆\n  for(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n  // 各辺が他方のどれかの辺と接しているか\n  for(int i=0;i<4;i++){\n    int curi=i;\n    int prvi=(i-1+4)%4;\n    for(int j=0;j<4;j++){\n      int curj=j;\n      int prvj=(j-1+4)%4;\n      if(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n    }\n  }\n  return false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n  return p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n  return P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n  P e=P(-tmp.imag(),tmp.real());\n  e/=abs(e);\n  return e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n  return P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < (int)p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return abs(sum/2);\n}\n\nP ps[101];\nP ps2[101];\nint main(){\n  int N;\n  cin>>N;\n  double avgx=0,avgy=0;\n  for(int i=0;i<N;i++){\n    double x,y;\n    cin>>x>>y;\n    avgx+=x;\n    avgy+=y;\n    ps[i]=P(x,y);\n  }\n  if(N%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  avgx/=N;avgy/=N;\n  P avgp=P(avgx,avgy);\n  for(int i=0;i<N;i++)ps[i]-=avgp;\n  for(int i=0;i<N;i++)ps2[i]=roundPoint(ps[i],PI);\n  bool ok=false;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(EQV(ps[i],ps2[j])){\n\tfor(int k=0;k<N;k++){\n\t  int a=(k+j)%N;\n\t  int b=(k+i)%N;\n\t  if(!EQV(ps[a],ps2[b])){\n\t    cout<<\"NA\"<<endl;\n\t    return 0;\n\t  }\n\t}\n\tok=true;\n\tbreak;\n      }\n    }\n    if(ok)break;\n  }\n  if(ok)printf(\"%.10f %.10f\\n\",avgp.real(),avgp.imag());\n  else cout<<\"NA\"<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, X[50], Y[50], sx, sy;\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &X[i], &Y[i]);\n\t\tsx += X[i];\n\t\tsy += Y[i];\n\t}\n\tif(N % 2 == 1) printf(\"NA\\n\");\n\telse {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < N / 2; i++) {\n\t\t\tflag = flag && ((1.0 * sx / N - X[i]) * 2 == (X[N / 2 + i] - X[i]) && (1.0 * sy / N - Y[i]) * 2 == (Y[N / 2 + i] - Y[i]));\n\t\t}\n\t\tif(flag) {\n\t\t\tprintf(\"%.9f %.9f\\n\", 1.0 * sx / N, 1.0 * sy / N);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef complex<double> point;\ntypedef pair<point,point> line;\nbool equal(const double x1,const double x2){ return abs(x1-x2)<eps; }\nbool equal(const point& a,const point& b){ return equal(a.real(),b.real()) and equal(a.imag(),b.imag()); }\ndouble length(const point& a){ return abs(a); }\ndouble distance(const point& a,const point& b){ return abs(a-b); }\ndouble dot(const point& a,const point& b){ return a.real()*b.real()+a.imag()*b.imag(); }\ndouble cross(const point& a,const point& b){ return a.real()*b.imag()-a.imag()*b.real(); }\nbool is_orthogonal(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(dot(a1-a2,b1-b2),0.0); }\nbool is_orthogonal(const line& l,const line& m){ return is_orthogonal(l.first,l.second,m.first,m.second); }\nbool is_parallel(const point& a1,const point& a2,const point& b1,const point& b2){ return equal(cross(a1-a2, b1-b2),0.0); }\nbool is_parallel(const line& l,const line& m){ return is_parallel(l.first,l.second,m.first,m.second); }\nint ccw(point a,point b,point c) {\n    b-=a; c-=a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nbool intersectLL(const line& l, const line& m){\n    return abs(cross(l.second-l.first, m.second-m.first)) > eps || // non-parallel\n           abs(cross(l.second-l.first, m.first-l.first)) < eps;   // same line\n}\nbool intersectLS(const line& l, const line& s){\n    return cross(l.second-l.first, s.first-l.first)*       // s.first is left of l\n           cross(l.second-l.first, s.second-l.first) < eps; // s.second is right of l\n}\nbool intersectLP(const line& l, const point& p){\n    return abs(cross(l.second-p, l.first-p)) < eps;\n}\nbool intersectSS(const line& s, const line& t){\n    return ccw(s.first,s.second,t.first)*ccw(s.first,s.second,t.second) <= 0 &&\n           ccw(t.first,t.second,s.first)*ccw(t.first,t.second,s.second) <= 0;\n}\nbool intersectSP(const line& s, const point& p){\n    return abs(s.first-p)+abs(s.second-p)-abs(s.second-s.first) < eps; // triangle inequality\n}\npoint projection(const line& l, const point& p) {\n    double t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n    return l.first + t*(l.first-l.second);\n}\npoint reflection(const line& l, const point& p){\n    return p+point((projection(l, p) - p).real()*2,(projection(l, p) - p).imag()*2);\n}\ndouble distanceLP(const line &l, const point& p){\n    return abs(p - projection(l, p));\n}\ndouble distanceLL(const line &l, const line &m){\n    return intersectLL(l, m) ? 0 : distanceLP(l, m.first);\n}\ndouble distanceLS(const line &l, const line &s){\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s.first), distanceLP(l, s.second));\n}\ndouble distanceSP(const line &s, const point& p) {\n    const point r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s.first - p), abs(s.second - p));\n}\ndouble distanceSS(const line &s, const line &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t.first), distanceSP(s, t.second)),\n             min(distanceSP(t, s.second), distanceSP(t, s.second)));\n}\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\npoint intersection_l(const point& a1,const point& a2,const point& b1,const point& b2) {\n  const point& a=a2-a1,b=b2-b1;\n  return a1+a*cross(b, b1-a1)/cross(b, a);\n}\npoint intersection_l(const line& l,const line& m){\n    return intersection_l(l.first,l.second,m.first,m.second);\n}\n// ????§???¢????¬?????????¢???\ndouble area(const vector<point>& pol){\n    double s=0;\n    rep(i,0,pol.size()) s+=cross(pol[i],pol[(i+1)%pol.size()]);\n    return s/2;\n}\n\nvector<point> convex_cut(const vector<point>& ps, const line& l) {\n    vector<point> res;\n    for (int i = 0; i < ps.size(); ++i) {\n        point a = ps[i], b = ps[(i+1)%ps.size()];\n        if (ccw(l.first, l.second, a) != -1) res.push_back(a);\n        if (ccw(l.first, l.second, a)*ccw(l.first, l.second, b) < 0) res.push_back(intersection_l(line(a, b), l));\n    }\n    return res;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<point> ps(n);\n    for(point& p:ps){\n        double x,y;\n        cin >> x >> y;\n        p=point(x,y);\n        p*=point(cos(eps),sin(eps));\n    }\n\n    const double s=area(ps);\n    auto opt=[&](){\n        double left=inf,right=-inf;\n        for(const auto& p:ps){\n            if(p.real()<left) left=p.real();\n            if(p.real()>right) right=p.real();\n        }\n        line l(point(left,0),point(left,1));\n        double lb=0,ub=distanceLP(l,point(right,0));\n        rep(i,0,50){\n            double mid=(lb+ub)/2;\n            l=line(point(left+mid,0),point(left+mid,1));\n            if(area(convex_cut(ps,l))<=s/2) lb=mid;\n            else ub=mid;\n        }\n        return l;\n    };\n\n    line l1=opt();\n    for(auto& p:ps) p*=point(0,1);\n    line l2=opt();\n    l2=line(l2.first*point(0,-1),l2.second*point(0,-1));\n    for(auto& p:ps) p*=point(0,-1);\n    point ans=intersection_l(l1,l2);\n    bool ok=true;\n    const double pi=3.14159265;\n    rep(i,0,100000){\n        const point tmp=ans+point(1,0)*point(cos(2*pi*i/100000),sin(2*pi*i/100000));\n        if(abs(area(convex_cut(ps,line(ans,tmp)))-s/2)>eps){\n            ok=false;\n            break;\n        }\n    }\n    if(ok) cout << ans.real() << \" \" << ans.imag() << endl;\n    else cout << \"NA\" << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8) << endl;\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\nconst double EPS=1e-6;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) FLL(a,0)\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\ntemplate<class T,class U> ostream& operator<< (ostream& o, const pair<T,U>& v){return o << \"(\" << v.F << \", \" << v.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& o, const vector<T>& v){o << \"{\";rep(i,SZ(v)) o << (i?\", \":\"\") << v[i];return o << \"}\";}\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\nint geti(){int n;scanf(\"%d\", &n);return n;}\n\nint x[100],y[100];\n\n\n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n\n  double sumx = 0;\n  double sumy = 0;\n  for(int i = 0; i < n; ++i){\n    cin >> x[i] >> y[i];\n    sumx += x[i];\n    sumy += y[i];\n  }\n  sumx /= n;\n  sumy /= n;\n\n  bool ok = true;\n  for(int i = 0; i < n; ++i){\n    double ax = x[i] - sumx;\n    double ay = y[i] - sumy;\n    double bx = x[(i+1)%n] - sumx;\n    double by = y[(i+1)%n] - sumy;\n    double EPS=1e-4;\n    ok &= abs(ax*ax+ay*ay-(bx*bx + by*by)) < EPS;\n    ok &= abs((ax*bx+ay*by)/sqrt(ax*ax+ay*ay)/sqrt(bx*bx+by*by)-\n              cos(acos(-1)*2/n)) < EPS;\n  }\n\n  if(ok && ~n%2) printf(\"%.10f %.10f\\n\", sumx, sumy);\n  else cout << \"NA\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n\n\nint main(){\n\n  int n;\n  cin >> n;\n  vector<complex<int> > p(n);\n  rep(i,n){\n    int x,y;\n    cin >> x >> y;\n    p[i] = complex<int>(x,y);\n  }\n  if(n%2!=0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  complex<double> c,cb;\n  cb = (double)(p[0]+p[n/2])/2;\n  for(int i=1;i<n/2;i++){\n    c = (double)(p[i]+p[i+n/2])/2;\n    if(c.real()!=cb.real()||c.imag()!=cb.imag()){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  cout << setprecision(9) << cb.real() << \" \" << cb.imag() << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> P;\nint n;\nP p[50];\n\nbool equal(ld a,ld b){\n  cout<<a<<\" \"<<b<<endl;\n  return a-(1e-5)<=b&&b<=a+(1e-5);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  ld a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    ld k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  double x=(double)a.s,y=(double)a.s;\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else printf(\"%.8f %.8f\\n\",x,y);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint n,x[55],y[55];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tif(n%2){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\trep(i,n)cin>>x[i]>>y[i],x[i]*=2,y[i]*=2;\n\tint cx=x[0]+x[n/2],cy=y[0]+y[n/2];\n\trep(i,n/2)if(x[i]+x[i+n/2]!=cx || y[i]+y[i+n/2]!=cy){\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<fixed<<setprecision(16)<<cx/4.<<\" \"<<cy/4.<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-12;\n\ntypedef complex<long double> P;\nlong double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nlong double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  long double A = cross(l[1] - l[0], m[1] - m[0]);\n  long double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    bool f = false;\n    REP(j, N)if(i != j){\n      f |=\n        !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N])) &&\n        abs(abs(ps[i] - ps[(i+1) %N]) - abs(ps[j] - ps[(j+1) % N])) < EPS;\n    }\n    ok &= f;\n  }\n  \n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double EPS = 1e-8;\n\ndouble cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\ndouble dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b)) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a1 = input[i+1];\n    Point a2 = input[i];\n    Point b1 = input[(input.size()/2+i+1)%input.size()];\n    Point b2 = input[input.size()/2+i];\n    if(!isParallel(Point(a1.first-a2.first, a1.second-a2.second), \n                   Point(b1.first-b2.first, b1.second-b2.second))) return false;\n    if(abs(dist(a1, a2) - dist(b1, b2)) >= EPS) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  ans = Point((a.first + b.first) / 2.0, (a.second + b.second) / 2.0);\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else printf(\"%.8f %.8f\\n\", ans.first, ans.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI\t3.1415926535897932384626433832795028841971\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\n\nint n;\ndouble x[51], y[51], t[51];\ndouble ax = 0.0, ay = 0.0;\ndouble dist, ag;\n\nint main(){\n\tcin >> n;\n\tif(n%2 == 1){\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\trep(i,n){\n\t\tcin >> x[i] >> y[i];\n\t\tax += x[i]; ay += y[i];\n\t}\n\tax /= n; ay /= n;\n\trep(i,n){\n\t\tx[i] -= ax; y[i] -= ay;\n\t\tt[i] = atan2(y[i],x[i]);\n\t\tif(i == 0) dist = x[0]*x[0]+y[0]*y[0];\n\t\telse{\n\t\t\tdouble d = x[i]*x[i]+y[i]*y[i];\n\t\t\tif(dist > d+EPS || d > dist+EPS){\n\t\t\t\tputs(\"NA\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tx[n] = x[0]; y[n] = y[0]; t[n] = t[0];\n\trep(i,n) if(t[i] > t[i+1]) t[i+1] += 2*PI;\n\tag = t[1]-t[0];\n\trep(i,n){\n\t\tdouble a;\n\t\ta = t[i+1]-t[i];\n\t\tif(a+EPS < ag || ag+EPS < a){\n\t\t\tputs(\"NA\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.9f %.9f\\n\", ax, ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint Convexcut(Polygon p){\n  Point res(inf,inf),tmp;\n  int n=p.size();\n  for(int i=0;i<n/2;i++){\n    if(res.x==inf){\n      res=median_Point(p[i],p[i+n/2]);\n    }\n    else {\n      tmp=median_Point(p[i],p[i+n/2]);\n      if((res.x-tmp.x)>eps || (res.y-tmp.y)>eps)return Point(inf,inf);\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n  Polygon p;\n\n  cin>>n;\n  p.resize(n);\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  if(n%2==1){\n    cout<<\"NA\"<<endl;\n  }else {\n    Point ans=Convexcut(p);\n    if(ans.x==inf)cout<<\"NA\"<<endl;\n    else printf(\"%.10f %.10f\\n\",ans.x,ans.y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble compute_area(vector<Point>& points){\n  double area = 0;\n  for(int i = 0; i < points.size(); i++){\n    area += (points[i].real() - points[(i + 1) % points.size()].real())\n      * (points[i].imag() + points[(i + 1) % points.size()].imag());\n  }\n  return 1.0/2.0 * abs(area);\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nPoint reflection(const Line &l, const Point &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLS(const Line &l, const Line &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const Line &s, const Point &p) {\n  const Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const Line &s, const Line &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble distanceLL(const Line &l, const Line &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<Point> points;\n    double high,low,lhs,rhs;\n\n    high = rhs = numeric_limits<double>::min();\n    low = lhs = numeric_limits<double>::max();\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      points.push_back(Point(x,y));\n      low = min(low,y);\n      high = max(high,y);\n\n      lhs = min(lhs,x);\n      rhs= max(rhs,x);\n    }\n    vector<Line> lines;\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      lines.push_back(Line(points[pos_i],points[(pos_i+1) % N]));\n    }\n\n    double area_target;\n    //horizontal line\n    for(int round = 0; round < 50; round++){\n      double mid = low + (high - low) / 2.0;\n      Line horizontal_line(Point(-1000000.0,mid),Point(1000000.0,mid));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(horizontal_line,lines[line_i])){\n          Point p = crosspoint(horizontal_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n\n      vector<Point> top,bottom;\n      top.push_back(div[0]);\n      top.push_back(div[1]);\n\n      bottom.push_back(div[0]);\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS <= points[pos_i].imag()){\n          top.push_back(points[pos_i]);\n        }\n        if(mid + EPS >= points[pos_i].imag()){\n          bottom.push_back(points[pos_i]);\n        }\n      }\n      bottom.push_back(div[1]);\n\n      double area_top = compute_area(top);\n      double area_bottom = compute_area(bottom);\n      double whole = area_top + area_bottom;\n\n      if(area_top >= area_bottom){\n        low = mid;\n        area_target = area_top;\n      }\n      else{\n        high = mid;\n      }\n    }\n\n    //vertical line\n    for(int round = 0; round < 50; round++){\n      double mid = lhs + (rhs - lhs) / 2.0;\n      Line vertical_line(Point(mid,-10000000.0),Point(mid,10000000.0));\n\n      vector<Point> div;\n      for(int line_i = 0; line_i < lines.size(); line_i++){\n        if(intersectLS(vertical_line,lines[line_i])){\n          Point p = crosspoint(vertical_line,lines[line_i]);\n          div.push_back(p);\n        }\n      }\n\n      vector<Point> left,right;\n      left.push_back(div[0]);\n      right.push_back(div[0]);\n      for(int pos_i = 0; pos_i < N; pos_i++){\n        if(mid - EPS >= points[pos_i].real()){\n          left.push_back(points[pos_i]);\n        }\n        if(mid + EPS <= points[pos_i].real()){\n          right.push_back(points[pos_i]);\n        }\n      }\n      left.push_back(div[1]);\n      right.push_back(div[1]);\n\n      double area_left = compute_area(left);\n      double area_right = compute_area(right);\n      double whole = area_left + area_right;\n\n      if(area_right >= area_left){\n        lhs = mid;\n      }\n      else{\n        rhs = mid;\n      }\n    }\n    \n    //check\n    Line check_line(Point(lhs,low),Point(lhs + 1.0,low + 1.0));\n    vector<Point> div;\n    int first = -1;\n    int last = -1;\n    for(int line_i = 0; line_i < lines.size(); line_i++){\n      if(intersectLS(check_line,lines[line_i])){\n        Point p = crosspoint(check_line,lines[line_i]);\n        div.push_back(p);\n        if(first == -1) first = line_i;\n        else if(last == -1) last = line_i;\n      }\n    }\n    \n    vector<Point> half;\n    half.push_back(div[0]);\n    for(int pos_i = 0; pos_i < N; pos_i++){\n      if(first <= pos_i && pos_i <= last){\n        half.push_back(points[pos_i]);\n      }\n    }\n    half.push_back(div[1]);\n    \n    double area_half = compute_area(half);\n    if(abs(area_half - area_target) > EPS){\n      cout << \"NA\" << endl;\n    }\n    else{\n      printf(\"%.7lf %.7lf\\n\",lhs,low);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <math.h>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t}\n\tcx = (p[0][0] + p[n/2][0]) / 2;\n\tcy = (p[0][1] + p[n/2][1]) / 2;\n\tif(n%2) f=1;\n\telse for(i = 1; i < n/2; i++){\n\t\tif(fabs((p[i][0] + p[i + n/2][0]) / 2 - cx) <= 0.0000001 && fabs((p[i][1] + p[i + n/2][1]) / 2 - cy) <= 0.0000001) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse printf(\"%.9lf %.9lf\\n\", cx , cy);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\n/* ??????????????¬ */\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;//????´???°\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);//conj::??±???????´???°\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\n/*int main(){\nPoint a(1,1),b(2,2);\nLine l(a,b);\n}*/\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\n//l::??´??????s::??????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨????????????????????? *slide??????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\t//norm::??¶?????????2???\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\ntypedef pair<ld, ld> P;\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int n;cin>>n;\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n        ld x,y;cin>>x>>y;\n        v[i]=P(x,y);\n    }\n    ld ma=0;\n    P mid;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            ld len= (v[i].first-v[j].first)*(v[i].first-v[j].first)+(v[i].second-v[j].second)*(v[i].second-v[j].second);\n            if(len>ma){\n                ma=len;\n                mid= P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n            }\n        }\n    }\n//    cout<<mid.first<<\" \"<<mid.second<<endl;\n//    cout<<ma<<endl;\n    if(ma==0) cout<<\"NA\"<<endl;\n    else{\n        for(int i=0;i<n;i++){\n            bool flag=false;\n            for(int j=0;j<n;j++){\n                P mi=P((v[i].first+v[j].first)/2,(v[i].second+v[j].second)/2);\n                if(eq(mi.first,mid.first)&&eq(mi.second,mid.second)){\n                    flag=true;break;\n                }\n            }\n            if(!flag){\n                cout<<\"NA\"<<endl;\n                return 0;\n            }\n        }\n        cout<<mid.first<<\" \"<<mid.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-10;\n\nbool equals(double a, double b, double eps = 1e-10) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < ps.size(); ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\nint main() {\n  int N; cin >> N;\n  vector<P> ps(N);\n  for(int i = 0; i < N; ++i) {\n    cin >> ps[i].real() >> ps[i].imag();\n  }\n\n  if(getArea(ps) < 0) reverse(ps.begin(), ps.end());\n  double S = getArea(ps);\n\n  double x, y;\n  for(double l = 0.0, r = 1000000.0; x = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(x,0), P(x,1))) < S/2.0) {\n      l = x;\n    } else {\n      r = x;\n    }\n  }\n  for(double l = 0.0, r = 1000000.0; y = (l+r) / 2.0, !equals(l, r);) {\n    if(getArea(convex_cut(ps, P(0,y), P(1,y))) < S/2.0) {\n      r = y;\n    } else {\n      l = y;\n    }\n  }\n  P g(x, y);\n  bool flag = true;\n  for(int k = 0; k < 1000; ++k) {\n    double rad = (double)rand()/(double)RAND_MAX * (double)M_PI;\n    P t = g + P(cos(rad), sin(rad));\n    if(!equals(getArea(convex_cut(ps, g, t)), S/2.0, 1e-6)) {\n      flag = false;\n      break;\n    }\n  }\n  if(flag) {\n    printf(\"%.5f %.5f\\n\", g.real(), g.imag());\n  } else {\n    printf(\"NA\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double EPS = 1e-9;\nint N;\nint X[50], Y[50];\n\nbool equal(double x, double y) {\n  return abs(x-y) < EPS;\n}\n\ndouble calc(double x, double y) {\n  return (x+y)/2.0;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> N;\n  for (int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i];\n  }\n  if (N & 1) {\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  double px = calc(X[0], X[N/2]);\n  double py = calc(Y[0], Y[N/2]);\n  for (int i = 0; i < N / 2; i++) {\n    if (equal(calc(X[i], X[i+N/2]), px) && equal(calc(Y[i], Y[i+N/2]), py)) continue;\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  cout << px << \" \" << py << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\n\ndouble p[60][2];\ndouble cx = 0, cy = 0;\nint f;\n\nint main(void){\n\tint n, i;\n\tcin >> n;\n\tfor(i = 0; i < n; i++){\n\t\tcin >> p[i][0] >> p[i][1];\n\t\tcx += p[i][0];\n\t\tcy += p[i][1];\n\t}\n\tcx /= n;\n\tcy /= n;\n\tif(n%2) f=1;\n\telse for(i = 0; i < n/2; i++){\n\t\tif((p[i][0] + p[i + n/2][0]) /2 - cx < 0.01 && (p[i][1] + p[i + n/2][1]) /2 - cy < 0.01) continue;\n\t\tf = 1;\n\t\tbreak;\n\t}\n\tif(f) cout << \"NA\" << endl;\n\telse cout << cx << \" \" << cy << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<ld> x(N), y(N);\n    for(int i=0; i<N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    if(N & 1) {\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    bool ok = true;\n    ld cx = (x[0] + x[N/2]) / 2, cy = (y[0] + y[N/2]) / 2;\n    for(int i=0; i<N; ++i) {\n        ok &= (x[i] + x[(N/2+i)%N]) / 2 == cx && (y[i] + y[(N/2+i)%N])/2 == cy;\n    }\n    if(ok) {\n        cout << fixed << setprecision(10) << cx << ' ' << cy << endl;\n    } else {\n        cout << \"NA\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<long double, long double> Point;\n\nconst long double EPS = 1e-10;\n\nlong double cross(Point a, Point b){\n  return a.first * b.second - a.second * b.first;\n}\n\nlong double dist(Point a, Point b){\n  return (a.first - b.first) * (a.first - b.first) - (a.second - b.second) * (a.second - b.second);\n}\n\nbool isParallel(Point a, Point b){\n  return abs(cross(a, b) - 0.0) < EPS;\n}\n\nint n;\nvector<Point> input;\nPoint ans;\n\nbool solve(){\n  if(input.size() % 2) return false;\n  bool f = true;\n  for(int i=0;i<input.size()/2;i++){\n    Point a = Point(input[i+1].first - input[i].first, input[i+1].second - input[i].second);\n    Point b = Point(input[(i+input.size()/2+1)%input.size()].first - input[i+input.size()/2].first,\n                    input[(i+input.size()/2+1)%input.size()].second - input[i+input.size()/2].second);\n    if(!isParallel(a, b)) return false;\n    if(!(abs(dist(a, Point(0.0, 0.0)) - dist(b, Point(0.0, 0.0))) < EPS)) return false;\n  }\n  Point a = input[0];\n  Point b = input[input.size()/2];\n  long double tmp = 0.0;\n  if(abs(a.first + b.first) < EPS) tmp = 333.0;\n  if(abs(a.second + b.second) < EPS) tmp = 333.0;\n  ans = Point((a.first+tmp + b.first+tmp) / 2.0, (a.second+tmp + b.second+tmp) / 2.0);\n  ans.first -= tmp;\n  ans.second -= tmp;\n  return true;\n}\n\nmain(){\n  cin >> n;\n  for(int i=0;i<n;i++){\n    Point in;\n    cin >> in.first >> in.second;\n    input.push_back(in);\n  }\n  if(!solve()) printf(\"NA\\n\");\n  else cout << ans.first << ' ' << ans.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define var auto\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << setprecision(15) << fixed;\n    int n;\n    cin >> n;\n    double ySum = 0, xSum = 0;\n    vector<pair<double, double>> a;\n    for (int i = 0; i < n; i++){\n        double y, x;\n        cin >> y >> x;\n        ySum += y;\n        xSum += x;\n        a.push_back(make_pair(y, x));\n    }\n    double EPS = 0.0000001;\n    var midY = ySum / n, midX = xSum / n;\n    for (int i = 0; i < n; i++){\n        bool flag = false;\n        double oppositeY = midY * 2 - a[i].first, oppositeX = midX * 2 - a[i].second;\n        for (int j = 0; j < n; j++){\n            if (abs(a[j].first - oppositeY) < EPS && abs(a[j].second - oppositeX) < EPS) flag = true;\n        }\n        if (!flag) {\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << midY << \" \" << midX << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint x[50],y[50];\n\nbool check(int i1, int i2, int j1, int j2) {\n  if (x[i1]-x[i2] != x[j2]-x[j1]) return 0;\n  if (y[i1]-y[i2] != y[j2]-y[j1]) return 0;\n  return 1;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i,n) cin >> x[i] >> y[i];\n  if (n&1) {\n    puts(\"NA\");\n    return 0;\n  }\n  REP(i,n/2) {\n    if (!check(i,(i+1)%n,(i+n/2)%n,(i+n/2+1)%n)) {\n      puts(\"NA\");\n      return 0;\n    }\n  }\n  double ax = double(x[0]+x[n/2])/2;\n  double ay = double(y[0]+y[n/2])/2;\n  printf(\"%.10f %.10f\\n\", ax,ay);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 1, 1, -1, -1};\nint dx[]={1, -1, 0, 0, 1, -1, -1, 1};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define mp make_pair\n#define fi first\n#define sc second\n\ntypedef double R;//double long double の切り替え cmathの関数はオーバーロードに対応しているので問題ない\ntypedef complex<R> Point;\ntypedef pair<Point , Point> Line;\ntypedef pair<Point ,R > Circle;\ntypedef vector<Point> Poly;\n\n#define EPS (1e-10)//誤差\n#define EQ(a,b) (abs((a)-(b)) < EPS)//２つの実数が等しいか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )//２つのベクトルが等しいか\n#define ft first\n#define sd second\n#define pb push_back\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nR dot(Point a,Point b){//内積ok\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nR cross(Point a,Point b){//外積ok\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n\n\n\nbool is_orthogonal(Line a,Line b){//2直線の直行判定ok\n    return EQ(dot(a.ft - a.sd,b.ft - b.sd),0.0);\n}\nbool is_parallel(Line a,Line b){//2直線の並行判定ok\n    return EQ(cross(a.ft - a.sd,b.ft - b.sd),0.0);\n}\n\n\n\n////////////////////交差判定\nint ccw(Point a,Point b,Point c){//ok\n    b -= a; c -= a;\n    if(cross(b,c) > EPS) return 1;//a→bで反時計周りに折れてb→c\n    if(cross(b,c) < -EPS) return -1;//a→bで時計周りに折れてb→c\n    if(dot(b,c) < -EPS) return 2;//c--a--b on same line\n    if(norm(c) - norm(b) > EPS) return -2;//a--b--c(absじゃなくて二乗するのは差が出やすいから?)\n    return 0;//a--c--bまたはb==c\n}\n\nbool is_intersection_ll(Line l,Line m){//２つの直線が交わるかok\n    return abs(cross(l.sd - l.ft,m.sd - m.ft)) > EPS || //平行でない\n        abs(cross(l.sd - l.ft,m.ft - l.ft)) < EPS; //平行だが同じ線\n}\n\nbool is_intersection_ls(Line l,Line s){//直線lと線分sが交わるか\n    return cross(l.sd - l.ft, s.ft-l.ft)*       // s[0] is left of l\n        cross(l.sd - l.ft, s.sd - l.ft) < EPS; // s[1] is right of l\n}\n\nbool is_intersection_lp(Line l,Point p){//直線lと点pが交わるか\n    return abs(cross(l.sd - p,l.ft - p));\n}\n\nbool is_intersection_ss(Line a,Line b){//２つの線分が交わるかok\n    return ccw(a.ft,a.sd,b.ft)*ccw(a.ft,a.sd,b.sd) <= 0 && ccw(b.ft,b.sd,a.ft)*ccw(b.ft,b.sd,a.sd) <= 0;\n}\n\nbool is_intersection_sp(Line s,Point p){//線分と点の交差判定 三角不等式の利用\n    return abs(s.ft - p) + abs(s.sd - p) - abs(s.ft - s.sd) < EPS;\n}\n\n\nbool intersection_cc(Circle c1,Circle c2){//２つの円の交差判定ok\n    return abs(c1.ft - c2.ft) - (c1.sd + c2.sd) < -EPS;\n}\n\n\n/////////////距離\nR dis_lp(Line l,Point p){//直線lと点pの距離ok\n    return abs(cross(l.sd - l.ft,p - l.ft)) / abs(l.sd - l.ft);\n}\n\nR dis_ll(Line l,Line m){//２つの直線の距離\n    return is_intersection_ll(l,m) ? 0.0 : dis_lp(l,m.ft);\n}\n\nR dis_ls(Line l,Line s){//直線lと線分sの距離\n    if(is_intersection_ls(l,s)) return 0.0;\n    return min(dis_lp(l,s.ft),dis_lp(l,s.sd));\n}\n\nR dis_sp(Line s,Point p){//線分sと点pの距離ok\n    if(dot(s.sd - s.ft,p - s.ft) < EPS) return abs(p - s.ft);\n    if(dot(s.ft - s.sd,p - s.sd) < EPS) return abs(p - s.sd);\n    return dis_lp(s,p);\n}\n\nR dis_ss(Line s,Line t){//２つの線分の距離ok\n    if(is_intersection_ss(s,t)) return 0.0;\n    return min(min(dis_sp(s,t.ft),dis_sp(s,t.sd)),\n            min(dis_sp(t,s.ft),dis_sp(t,s.sd)));\n}\n\n\n\n//////////////射影と反射\nPoint projection(Line l,Point p){//射影を求めるok\n    R t = dot(p - l.ft,l.ft - l.sd) / norm(l.ft - l.sd);\n    return l.ft + t * (l.ft - l.sd);\n}\n\nPoint reflection(Line l,Point p){//反射を求めるok\n    return p + (R)2.0 * (projection(l,p) - p);\n}\n\n\n\n\n//////////////交点(交差する保証してないときは交差判定してからつかってね)\n\nPoint intersection_ll(Line l,Line m){//交差判定してるなら線分にも使えるok\n    R A = cross(l.sd - l.ft,m.sd - m.ft);\n    R B = cross(l.sd - l.ft,l.sd - m.ft);\n    if(abs(A) < EPS && abs(B) < EPS) return m.ft;//同じ線\n    //if(abs(A) < EPS)assert(false);//並行で交点なし\n    return m.ft + B / A * (m.sd - m.ft);\n}\n\nLine intersection_of_two_circles(Circle c1,Circle c2){//ok ２つの円の交点をLineに入れて返す(r1 + r2 > sqrt((x1 - x2) ^ 2 + (y1 - y2) ^ 2))を満たす必要があるok\n    R a =  abs(c2.ft - c1.ft);\n    R b = c1.sd;\n    R c = c2.sd;\n\n    R rc = (a  * a + b * b - c * c) / (2.0 * a);\n    R rs = sqrt(b * b - rc * rc);//C++ ではオーバーロードが可能であるため、sqrt または float 型を受け取る long double のオーバーロードを呼び出すことができます。 C プログラムでは、sqrt は常に double を受け取って返します。\n    Point diff = (c2.ft - c1.ft) / a;\n\n    Line p ;\n    p.ft = c1.ft + diff * rc + diff * Point(0,1) * rs;\n    p.sd = c1.ft + diff * rc + diff * Point(0,-1) * rs;\n\n    return p;\n}\n\n\n/////////////////////////polygon\n\n#define currP(P,i) P[(i) % P.size()]//今の頂点\n#define nextP(P,i) P[((i) + 1)%P.size()]//次の頂点\n\nint is_contains_p_in_Poly(Poly po,Point p){//点が多角形の内部(1)、境界(-1)、外部(0)のどこにあるかを判定ok\n    bool in = false;\n    REP(i,po.size()){\n        Point a = currP(po,i) - p,b = nextP(po,i) - p;\n        if(a.imag() > b.imag())swap(a,b);\n        if(a.imag() < EPS && EPS < b.imag())\n            if(cross(a,b) < -EPS) in = !in;\n        if(EQ(cross(a,b),0.0) && dot(a,b) < EPS)return  -1;\n    }\n    return in;\n}\n\nR area2(Poly po){//多角形の面積の二倍を求めるok\n    R A = 0.0;\n    REP(i,po.size())\n        A += cross(currP(po,i),nextP(po, i));\n    return A;\n}\n\n\n\n\n///////////////////////////凸\n\nbool comp_complex_real(Point a,Point b){//x→yの辞書順ok\n    if(EQ(a.real(),b.real()))\n        return b.imag() - a.imag() > EPS;\n    return b.real() - a.real() > EPS;\n}\n\nPoly convex_hull(Poly ps){//凸包ok\n    int n = ps.size(),k = 0;\n    sort(ps.begin(),ps.end(),comp_complex_real);\n    Poly ch(2*n);\n    for(int i = 0;i < n;ch[k++] = ps[i++])// lower-hull\n        while(k >= 2 && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//３つ目の条件は180度を含むときのみ必要\n    for(int i = n - 2,t = k + 1;i >= 0;ch[k++] = ps[i--])//upper-hull\n        while(k >= t && ccw(ch[k - 2],ch[k - 1],ps[i]) <= 0 && ccw(ch[k - 2],ch[k - 1],ps[i]) > -2) --k;//上に同じ\n    ch.resize(k - 1);\n    return ch;\n}\n#define prevP(P, i) P[(i+P.size()-1) % P.size()]\nbool isconvex(Poly P){//凸性判定時計回り反時計周りに対応\n    bool cl = false,ccl = false;\n    for(int i = 0;i < P.size();++i){\n        int c = ccw(prevP(P,i),currP(P,i),nextP(P,i));\n        if(c == -2)continue;//180度を含むときのみ　360度も含むときはc == -2 || c == 0\n        if(c == 1)ccl = true;\n        else if(c == 2)cl = true;\n        else return false;\n    }\n    return !(cl && ccl);\n}\n\n\nll n;\n\nPoint p[100];\nLine l[100];\n\nint main(){\n\tcin >> n;\n\n\n\tREP(i,n) {\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x,y);\n\t}\n\tif(n % 2 == 1) {\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\tREP(i,n) {\n\t\tl[i] = Line(p[(i+1)%n],p[i]);\n\t}\n\n\tbool f = true;\n\tREP(i,n/2) {\n\t\tif(!is_parallel(l[i],l[i+n/2])) {\n\t\t\tf = false;\n\t\t}\n\t\tif(abs(abs(l[i].ft - l[i].sc) - abs(l[i+n/2].ft-l[i+n/2].sc)) > EPS) {\n\t\t\tf = false;\n\t\t}\n\t}\n\n\tif(!f){\n\t\tcout << \"NA\" << endl;\n\t\treturn 0;\n\t}\n\n\t\n\tPoint ans = intersection_ll(Line(p[0],p[n/2]),Line(p[1],p[n/2+1]));\n\tprintf(\"%.10f %.10f\\n\",ans.real(),ans.imag());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS=1e-6;\n \ndouble cross(P a, P b){ return imag(conj(a)*b); }\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n \nint main(){\n  int n;\n  cin>>n;\n  vector<P> G(n);\n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    G[i]=P(x,y);\n  }\n  if(n%2){cout<<\"NA\"<<endl;return 0;}  \n  double len=abs(G[0]-G[1]);\n  for(int i=0;i<n/2;i++){\n    double a=abs(G[i]-G[(i+1)]);\n    double b=abs(G[i+n/2]-G[(i+n/2+1)%n]);\n    if(abs(a-b)>EPS){cout<<\"NA\"<<endl;return 0;}\n  }\n  P ans=crossPoint(L(G[0],G[n/2]),L(G[1],G[n/2+1]));\n  printf(\"%lf %lf\\n\",real(ans),imag(ans));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> X(N), Y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> X[i] >> Y[i];\n\t}\n\tif (N & 1) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tint posX = X[0] + X[N / 2], posY = Y[0] + Y[N / 2];\n\tbool ng = false;\n\tfor (int i = 0; i < N / 2; i++) {\n\t\tint px = X[i] + X[i + N / 2], py = Y[i] + Y[i + N / 2];\n\t\tif (px == posX && py == posY) {\n\t\t\tng = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ng) {\n\t\tputs(\"NA\");\n\t\treturn 0;\n\t}\n\tcout << fixed << setprecision(8) << posX / 2.0 << ' ' << posY / 2.0 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nusing ld= long double;\n#define REP(i,n) for(ll i=0;i<ll(n);i++)\n#define ALL(v) v.begin(),v.end()\n#define EPS 1e-10\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<ll> x(n),y(n);\n\tld sumx=0,sumy=0;\n\tREP(i,n) {\n\t\tcin>>x[i]>>y[i];\n\t\tsumx+=x[i];\n\t\tsumy+=y[i];\n\t}\n\tsumx/=n;\n\tsumy/=n;\n\tif(n&1){cout<<\"NA\"<<endl;return 0;}\n\tbool ok=true;\n\tREP(i,n/2) {\n\t\tif(abs(sumx*2-(x[i]+x[i+n/2]))>EPS)ok=false;\n\t\tif(abs(sumy*2-(y[i]+y[i+n/2]))>EPS)ok=false;\n\t}\n\tif(ok)cout<<fixed<<setprecision(10)<<sumx<<\" \"<<sumy<<endl;\n\telse cout<<\"NA\"<<endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic double eps = 1e-9;\n\nint main(){\n    int N;\n    cin>>N;\n    double x[50+10],y[50+10];\n    for(int i=0; i<N; i++) cin>>x[i]>>y[i];\n\n    bool check = true;\n    if(N % 2 != 0) check = false;\n\n    double px,py;\n    px = (x[0] + x[N/2]) / 2;\n    py = (y[0] + y[N/2]) / 2;\n\n    for(int i=0; i<N; i++){\n        double nx,ny,difx,dify;\n        nx = px - x[i];\n        ny = py - y[i];\n        difx = px + nx - x[(i+N/2)%N];\n        dify = py + ny - y[(i+N/2)%N];\n        if(fabs(difx) > eps || fabs(difx) > eps) check = false;\n    }\n\n    if(check){\n        cout<<setprecision(8)<<fixed;\n        cout<<px<<\" \"<<py<<endl;\n    }\n\n    else cout<<\"NA\"<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef complex<double> P;\ntypedef vector<P> polygon;\n\ndouble const eps = 1e-7;\n\npolygon poly;\n\nstruct line : public vector<P> {\n  line(P const& a, P const& b) {\n    push_back(a), push_back(b);\n  }\n};\n\ndouble dot(P a, P b) {\n  return real(conj(a) * b);\n}\n\ndouble cross(P a, P b) {\n  return imag(conj(a) * b);\n}\n\nint ccw(P const& p, P a, P b) {\n  a -= p, b -= p;\n  if(cross(a, b) > eps) return +1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nP crosspoint(line const& a, line const& b) {\n  auto va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < eps) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n\npolygon convex_cut(polygon const& g, line const& l) {\n  polygon ret;\n  int n = g.size();\n  rep(i, n) {\n    auto curr = g[i % n], next = g[(i + 1) % n];\n    if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n    if(ccw(l[0], l[1], curr) * ccw(l[0], l[1], next) < 0) {\n      ret.push_back(crosspoint(line(curr, next), l));\n    }\n  }\n  return ret;\n}\n\ndouble area(polygon const& g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i + 1) % g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\nbool ok(P const& p) {\n  double ph = area(poly) / 2.0;\n  for(double rad = 0.0; rad < 2 * cos(-1); rad += 0.01) {\n    line l = line(p, p + polar(1.0, rad));\n    auto k = convex_cut(poly, l);\n    if(abs((area(k) - ph) / ph) > eps) return false;\n  }\n  return true;\n}\n\nint main() {\n  int N; cin >> N;\n  P g;\n  rep(i, N) {\n    double x, y; cin >> x >> y;\n    poly.push_back(P(x, y));\n    g += P(x, y);\n  }\n  g /= N;\n  if(N % 2 || !ok(g)) cout << \"NA\" << endl;\n  else printf(\"%.10f %.10f\\n\", g.real(), g.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nFOR(it,t) os << *it << endl; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false){\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t};\n\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\t\n\t\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n;\nmain(){\n\tcin >> n;\n\tG g;\n\tg.resize(n);\n\tREP(i, n) cin >> g[i];\n\tif(![&](){\n\t\tif(g.size() & 1) return 0;\n\t\telse{\n\t\t\tREP(i, n/2){\n\t\t\t\tif(sig(outp(g.edge(i).dir(), -g.edge((i+n/2)%n).dir()))) return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}()) puts(\"NA\");\n\telse{\n\t\tP p = (g[0] + g[n/2]) / 2.;\n\t\tprintf(\"%.5f %.5f\\n\", p.X, p.Y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <sstream>\n\nclass Point {\npublic:\n\tPoint();\n\tPoint(int x_in, int y_in);\n\n\tPoint  operator+(const Point& obj);\n\tPoint  operator-(const Point& obj);\n\tPoint  operator*(const double n);\n\tPoint  operator/(const double n);\n\n\tvoid set(int x_in, int y_in);\n\n\tdouble x;\n\tdouble y;\n};\n\nPoint::Point() {\n\tx = 0;\n\ty = 0;\n}\n\nPoint::Point(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\nPoint Point::operator+(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x + obj.x;\n\ttemp.y = y + obj.y;\n\treturn temp;\n}\n\nPoint Point::operator-(const Point& obj) {\n\tPoint temp;\n\ttemp.x = x - obj.x;\n\ttemp.y = y - obj.y;\n\treturn temp;\n}\n\nPoint Point::operator*(const double n) {\n\tPoint temp;\n\ttemp.x = x * n;\n\ttemp.y = y * n;\n\treturn temp;\n}\n\nPoint Point::operator/(const double n) {\n\tPoint temp;\n\ttemp.x = x / n;\n\ttemp.y = y / n;\n\treturn temp;\n}\n\nvoid Point::set(int x_in, int y_in) {\n\tx = x_in;\n\ty = y_in;\n}\n\ndouble abs(Point point) {\n\treturn sqrt(point.x * point.x + point.y * point.y);\n}\n\nint N;\nPoint V[50];\n\nstd::string solve() {\n\tif (N % 2 != 0) return \"NA\";\n\tPoint center = (V[0] + V[N / 2]) / 2;\n\tfor (int i = 1; i < N / 2; i++) {\n\t\tPoint median = (V[i] + V[i + N / 2]) / 2;\n\t\tPoint dist = center - median;\n\t\tif (abs(dist) >= 0.001) {\n\t\t\treturn \"NA\";\n\t\t}\n\t}\n\tstd::ostringstream str;\n\tstr << center.x << \" \" << center.y;\n\treturn str.str();\n}\n\nint main() {\n\t//入力\n\tstd::cin >> N;\n\tint x, y;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> x >> y;\n\t\tV[i].set(x, y);\n\t}\n\t//演算\n\tstd::string answer = solve();\n\t//出力\n\tstd::cout << answer << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8, PI = acos(-1);\n\n// 実数同士の比較\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\ninline bool eq(Point a, Point b){ return eq(a.real(), b.real()) && eq(a.imag(), b.imag()); } \n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\n// 入力\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\n// 出力\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\n// 原点を中心として, 点 p を θ 回転すた点を返す\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアンを度数に変換\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\n// 度数をラジアンに変換\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\n// ∠BAC をラジアンで取得\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - a);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\n// x軸, y軸の順にソート\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n// 直線\n// 2 点を通る直線\n// Ax + By = C  \nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\n// 線分\n// 2 点を結ぶ\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n// 円\n// 中心と半径\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;   // 注意!! 凸多角形は反時計回りに与える.(保証されない場合は面積が負なら reverse をかける)\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\n// 外積\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\n// 内積\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n\n//          +1\n//          \n//  +2   a   0   b  -2\n//\n//          -1\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n\n// 2 直線が平行か\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// 2 直線が垂直か\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// 直線 l に 点 p から垂線を下ろして,交わる点を返す\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 同じ\n// 直線として扱われそう\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 直線 l に対して, 点 p と線対称な位置にある点を返す.\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\n// 直線上に点が乗るかどうか\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n// 直線 l と直線 m の交差判定\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\n// 線分上に点があるかどうか\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\n// 直線 l と 線分 s の交差判定\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\n// 点 p と 直線 l との距離\nReal distance(const Line &l, const Point &p);\n\n// 円 c と直線 l との交差判定\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\n// 点 p が 円 c 上にあるかどうか\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n\n// 線分同士の交差判定\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 円 c と 線分 l との交差判定\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// 円同士の交差判定\n// 4 := 離れている\n// 3 := 外接する\n// 2 := 交わる\n// 1 := 内接する\n// 0 := 内包する\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\n// 点と点の距離\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\n// 直線と点の距離\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\n// 直線と直線の距離 (もちろん交わってたら 0)\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\n// 線分と点の距離\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分同士の距離\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\n// 直線と線分の距離\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\n// 直線同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// 線分同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n\n// 円と直線の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\n\n// 円と線分の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// 円同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// 点 p から円 C へ接戦を引いた時の、接点を返す\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// 円と円の共通接線を複数返す\n// 0 ~ 4 つの可能性がある\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// 多角形が凸かどうかを判定\n// 与えられる多角形は反時計回りなことが要請される\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// 凸包に含まれる点上および辺上の頂点からなる多角形を返す.\n// 多角形の開始位置は特に指定がない.\n// 反時計回りに返されることは保証されていそう\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// 多角形 Q と点 p との関係を返す\n// 0 := OUT\n// 1 := ON\n// 2 := IN\n// 多角形は反時計回りに渡す\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// TODO よくわからん\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// TODO よくわからん\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n\n// 直線の進行方向の右側を残す\n// Polygon は反時計回りに与える\n// Line には一応向きがあるわけで\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n\n// 多角形の面積\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// 多角形と円の共通部分の面積\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// 凸多角形 g の直径を求めよ。ただし、凸多角形の直径とはその最遠頂点対間距離のことである.\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n\n// 平面上の n 個の点について、最も近い２点の距離.\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\nsigned main(){\n    \n    int n; cin >> n;\n    Polygon poly(n);\n    for(int i = 0; i < n; i++) cin >> poly[i];\n    if(n & 1){\n        return !printf(\"NA\\n\");\n    }else{\n        Point p = {(poly[0].real() + poly[n / 2].real()) / 2, (poly[0].imag() + poly[n / 2].imag()) / 2};\n        bool ok = true;\n        for(int i = 1; i < n / 2 - 1; i++){\n            Point q = {(poly[i].real() + poly[i + n / 2].real()) / 2, (poly[i].imag() + poly[i + n / 2].imag()) / 2};\n            if(!eq(p, q)) ok = false;\n        }\n        if(ok) printf(\"%.10f %.10f\\n\", p.real(), p.imag());\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___STD_GEOMETRY\n#define ___STD_GEOMETRY\n\n#include <cmath>\n\n#define EPS 1e-13L\n\n#endif\n\n#ifndef ___Class_Point\n#define ___Class_Point\n\nclass Point\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tPoint() : x(0), y(0) { }\n\n\texplicit Point(long double x, long double y) : x(x), y(y) { }\n\n\n\t// ------ Operator ------ //\n\n\tfriend bool operator==(Point& p1, Point& p2) { return p1.x == p2.x && p1.y == p2.y; }\n\tfriend bool operator!=(Point& p1, Point& p2) { return p1.x != p2.x || p1.y != p2.y; }\n};\n\nlong double distance(const Point& p1, const Point& p2)\n{\n\treturn sqrtl((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n}\n\n#endif\n\n#ifndef ___Class_Vector\n#define ___Class_Vector\n\nclass Vector\n{\npublic:\n\n\t// ------ Variable ------ //\n\n\tlong double x, y;\n\n\n\t// ------ Constructor ------ //\n\n\tVector() : x(0), y(0) { }\n\n\texplicit Vector(long double x, long double y) : x(x), y(y) { }\n\n\texplicit Vector(Point p1, Point p2) : x(p2.x - p1.x), y(p2.y - p1.y) { }\n\n\texplicit Vector(long double sx, long double tx, long double sy, long double ty) : x(tx - sx), y(ty - sy) { }\n\n\n\t// ------ Operator ------ //\n\n\tVector operator+() const { return Vector(+x, +y); }\n\tVector operator-() const { return Vector(-x, -y); }\n\n\tVector& operator+=(const Vector& v) { x += v.x; y += v.y; return *this; }\n\tVector& operator-=(const Vector& v) { x -= v.x; y -= v.y; return *this; }\n\n\tfriend bool operator==(const Vector& v1, const Vector& v2) { return -EPS < v1.x - v2.x && v1.x - v2.x < EPS && -EPS < v1.y - v2.y && v1.y - v2.y < EPS; }\n\tfriend bool operator!=(const Vector& v1, const Vector& v2) { return !(v1 == v2); }\n\n\tfriend Vector operator+(const Vector& v1, const Vector& v2) { return Vector(v1.x + v2.x, v1.y + v2.y); }\n\tfriend Vector operator-(const Vector& v1, const Vector& v2) { return Vector(v1.x - v2.x, v1.y - v2.y); }\n\n\tfriend Vector operator*(double d, const Vector& v) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator*(const Vector& v, double d) { return Vector(d * v.x, d * v.y); }\n\tfriend Vector operator/(const Vector& v, double d) { return Vector(v.x / d, v.y / d); }\n\n\n\t// ------ Function ------ //\n\n\tlong double norm() { return x * x + y * y; }\n\n\tlong double abs() { return sqrtl(x * x + y * y); }\n\n\tlong double angle() { return atan2l(y, x); }\n};\n\nlong double angle(const Vector& v1, const Vector& v2)\n{\n\tlong double A = atan2l(v2.y, v2.x) - atan2l(v1.y, v1.x);\n\n\tif (180.0L - EPS < A && A < 180.0L + EPS) { return 180.0L; }\n\n\tif (-180.0L - EPS < A && A < -180.0L + EPS) { return 180.0L; }\n\n\tif (A > 180.0L - EPS) { return A - 360.0L; }\n\n\tif (A < -180.0L + EPS) { return A + 360.0L; }\n\n\treturn A;\n}\n\nlong double norm(const Vector& v1)\n{\n\treturn v1.x * v1.x + v1.y * v1.y;\n}\n\nlong double abs(const Vector& v1)\n{\n\treturn sqrt(norm(v1));\n}\n\nlong double cross(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\nlong double dot(const Vector& v1, const Vector& v2)\n{\n\treturn v1.x * v2.x + v1.y * v2.y;\n}\n\nlong double distance(const Vector& v1, const Vector& v2)\n{\n\treturn sqrtl((v2.x - v1.x) * (v2.x - v1.x) + (v2.y - v1.y) * (v2.y - v1.y));\n}\n\n#endif\n\nVector Cross_Point(Vector p1, Vector p2, Vector p3, Vector p4)\n{\n\tVector base = p4 - p3;\n\n\tVector v1 = p1 - p3;\n\tVector v2 = p2 - p3;\n\n\tlong double d1 = fabsl(cross(base, v1));\n\tlong double d2 = fabsl(cross(base, v2));\n\n\tlong double t = d1 / (d1 + d2);\n\n\treturn p1 + ((p2 - p1) * t);\n}\n\n#include <vector>\n#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, X, Y;\n\n\tvector<Vector> Plane;\n\n\tcin >> N;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> X >> Y;\n\n\t\tPlane.push_back(Vector(X, Y));\n\t}\n\n\tif (N % 2 == 1)\n\t{\n\t\tcout << \"NA\" << endl;\n\t}\n\telse\n\t{\n\t\tVector C;\n\n\t\tfor (int i = 0; i < N / 2; i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < N / 2; j++)\n\t\t\t{\n\t\t\t\tif (i != j)\n\t\t\t\t{\n\t\t\t\t\tint l1 = i;\n\t\t\t\t\tint r1 = i + N / 2;\n\t\t\t\t\tint l2 = j;\n\t\t\t\t\tint r2 = j + N / 2;\n\n\t\t\t\t\tC = Cross_Point(Plane[l1], Plane[r1], Plane[l2], Plane[r2]);\n\t\t\t\t\t\n\t\t\t\t\tif ((Plane[l1] + Plane[r1]) / 2 != C)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"NA\" << endl;\n\n\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.9Lf %.9Lf\\n\", C.x, C.y);\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-6;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    assert(\"nyan\");\n}\n\n\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        xor128();\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5+1,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(ver.size() % 2 == 0 and cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef set<int> S;\ntypedef complex<double> P;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\n\nint main(){\n    int n;\n    cin >> n;\n    vector<P> v;\n    rep(i, n) {\n        double x, y;\n        cin >> x >> y;\n        v.pb(P(x, y));\n    }\n\n    if (n % 2) {\n        cout << \"NA\" << endl;\n    } else {\n        vector<P> center;\n        int d = n / 2;\n        rep(i, d) {\n            center.pb((v[i] + v[i + d]) / 2.0);\n        }\n        bool ok = true;\n        rep(i, d - 1)repl(j, i + 1, d) if (abs(center[i] - center[j]) > 1e-4) ok = false;\n\n        if (ok) printf(\"%.5f %.5f\\n\", center[0].real(), center[0].imag());\n        else cout << \"NA\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\nint main(){\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tvector<double> X(N), Y(N);\n\tint Xsum = 0, Ysum = 0;\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lf%lf\", &X[i], &Y[i]);\n\t\tXsum += X[i];\n\t\tYsum += Y[i];\n\t\tX[i] *= N;\n\t\tY[i] *= N;\n\t}\n\tif(N % 2 == 1){\n\t\tprintf(\"NA\\n\");\n\t\treturn 0;\n\t}\n\tfor(i = 0; i < N / 2; i++){\n\t\tif((X[i] + X[i + N / 2]) != 2 * Xsum || (Y[i] + Y[i + N / 2]) != 2 * Ysum){\n\t\t\tprintf(\"NA\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%.10lf %.10lf\\n\", (double)Xsum / N, (double)Ysum / N);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF 1e9\n#define equal(a,b) (fabs(a-b) < EPS)\n\nstruct Point{\n  double x,y;\n\n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n\n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n  bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\ntypedef Point Vector;\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isParallelSS(const Segment &s1,const Segment &s2){\n  Vector a = s1.t-s1.s;\n  Vector b = s2.t-s2.s;\n  return equal(cross(a,b),0);\n}\n\nPoint getPoint(vector<Point> &p,int N){\n  for(int i = 0 ; i < N/2 ; i++){\n    Segment a = Segment(p[i],p[i+1]);\n    Segment b = Segment(p[N/2+i],p[(N/2+i+1)%N]);\n    if(!isParallelSS(a,b)){ return Point(INF,INF); }\n    if(!equal(dist(a.s,a.t),dist(b.s,b.t))){\n      return Point(INF,INF);\n    }\n  }\n  return (p[0]+p[N/2])/2;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<Point> p(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> p[i];\n  }\n  if(N&1){\n    cout << \"NA\" << endl;\n  }else{\n    Point res = getPoint(p,N);\n    if(res.x == INF && res.y == INF){\n      cout << \"NA\" << endl;\n    }else{\n      printf(\"%.8f %.8f\\n\",res.x,res.y);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n\n\nint main(){\n\n  int n;\n  cin >> n;\n  vector<complex<double> > p(n);\n  rep(i,n){\n    int x,y;\n    cin >> x >> y;\n    p[i] = complex<double>(x,y);\n  }\n  if(n%2!=0){\n    cout << \"NA\" << endl;\n    return 0;\n  }\n  complex<double> c,cb;\n  cb = (p[0]+p[n/2])/2;\n  for(int i=1;i<n/2;i++){\n    c = (p[i]+p[i+n/2])/2;\n    if(c.real()!=cb.real()||c.imag()!=cb.imag()){\n      cout << \"NA\" << endl;\n      return 0;\n    }\n  }\n  cout << setprecision(9) << cb.real() << \" \" << cb.imag() << endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    bool operator!=(const Point& p) const{\n        return y != p.y || x != p.x;\n    }\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    if(n % 2 == 1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    for(int i=0; i<n/2; ++i){\n        Point q1 = p[i] - p[i+1];\n        Point q2 = p[(n/2+i+1)%n] - p[n/2+i];\n        if(q1 != q2){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n\n    Point q = p[0] + p[n/2];\n    printf(\"%.10f %.10f\\n\", (q.x / 2.0), (q.y / 2.0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<double,double> P;\nint n;\nP p[50];\n\nbool equal(double a,double b){\n  return a-(1e-12)<b&&b<a+(1e-12);\n}\n\ndouble getdis(P a,P b){\n  return (a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s);\n}\n\nP cal(){\n  double a=0,cx=0,cy=0;\n  for (int i=n,u=0;i-->0;u=i) {\n    double k=p[i].f*p[u].s-p[u].f*p[i].s;\n    a+=k;\n    cx+=k*(p[u].f+p[i].f);\n    cy+=k*(p[u].s+p[i].s);\n  }\n  cx/=3*a;\n  cy/=3*a;\n  return P(cx,cy);\n}\n\nint main(){\n  bool an=1;\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>p[i].f>>p[i].s;\n  P a=cal();\n  for(int i=0;i<n/2;i++){\n    if(!equal(getdis(a,p[i]),getdis(a,p[n/2+i])))an=0;\n  }\n  if(!an||n%2)cout<<\"NA\"<<endl;\n  else cout<<a.f<<\" \"<<a.s<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-6;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n        np = v[one] + u*lower;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        xor128();\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(xor128()%5+1,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(ver.size() % 2 == 0 and cnt == ver.size()*(ver.size()-1)/2){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!abs((a[i]+a[(i+n/2)%n])/2.0-c)<=0.00001||!abs((b[i]+b[(i+n/2)%n])/2.0-c)<=0.00001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto & it:v)\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\n#define IL inline\n#define X real()\n#define Y imag()\nIL D dot(P a,P b){\n    return a.X*b.X+a.Y*b.Y;\n}\nIL D cross(P a,P b){\n    return a.X*b.Y-a.Y*b.X;\n}\n\n\nIL D ccw(P a,P b,P c){\n    return cross(b-a,c-a);\n}\n\n\nIL D convex_area(Poly pp){\n    D res=0;\n    for(int i=2,n=pp.size();i<n;i++)\n\tres+=abs(ccw(pp[0],pp[i-1],pp[i]))/2,0;\n    return res;\n}\n\nstruct INIT{\n    INIT(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout<<fixed;\n\tcout<<setprecision(10);\n    }\n}init;\n\nIL P convex_gravity_point(Poly& pp){\n    P g(0,0);\n    D s=0;\n    for(int i=2,n=pp.size();i<n;i++){\n\tD t=convex_area({pp[0],pp[i-1],pp[i]});\n\tg+=t*(pp[0]+pp[i-1]+pp[i])/3.0;\n\ts+=t;\n    }\n    return g/s;\n}\nint main(){\n    int N;\n    cin>>N;\n    Poly p(N);\n    rep(i,N){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i]=P(x,y);\n    }\n    auto g=convex_gravity_point(p);\n    if(N&1)cout<<\"NA\"<<endl;\n    else{\n\tint M=N/2;\n\trep(i,M){\n\t    auto a=p[i]-g,b=g-p[i+M];\n\t    if(abs(a.X-b.X)>1e-8||abs(a.Y-b.Y)>1e-8){\n\t    cout<<a<<b<<endl;\n\t\tcout<<\"NA\"<<endl;\n\t\treturn 0;\n\t    }\n\t}\n\tcout<<g.X<<\" \"<<g.Y<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n;\n    cin >> n;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    if (n % 2){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    int xa = x[0]+x[n/2], ya = y[0]+y[n/2];\n    bool f = 1;\n    REP(i,n/2){\n        if (x[i]+x[n/2+i] != xa || y[i]+y[n/2+i] != ya) f = 0;\n    }\n    if (f) cout << xa/2.0 << \" \" << ya/2.0 << endl;\n    else cout << \"NA\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x7FFFFFFF\nconst double EPS = 1e-10;\n\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS;}\n\nstruct p_t{\n  double x;\n  double y;\n};\n\n\nint main(){\n  int n;\n  cin>>n;\n  vector<p_t> a;\n  p_t z;\n  for(int i=0;i<n;i++){\n    cin>>z.x>>z.y;\n    a.push_back(z);\n  }\n  if((n&1)==0){\n    z.x=(a[0].x+a[n/2].x)/2;\n    z.y=(a[0].y+a[n/2].y)/2;\n    int i;\n    for(i=2;i<n/2;i++){\n      if(eq(z.x,(a[i].x+a[i+n/2].x)/2)==0) break;\n      if(eq(z.y,(a[i].y+a[i+n/2].y)/2)==0) break;\n    }\n    if(i==n/2){\n      cout<<fixed<<z.x<<\" \"<<fixed<<z.y<<endl;\n      return 0;\n    }\n  }\n  cout<<\"NA\"<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ninline double SQ(double a){\n\treturn a * a;\n}\n\ninline bool EQ(double a, double b){\n\treturn abs(a - b) < EPS;\n}\n\ninline bool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\ninline bool LEQ(double a, double b){\n\treturn a - b < EPS;\n}\n\ninline bool GT(double a, double b){\n\treturn LT(b, a);\n}\n\ninline bool GEQ(double a, double b){\n\treturn LEQ(b, a);\n}\n\ntypedef complex<double> Point;\n\n#define x() real()\n#define y() imag()\n\nnamespace std {\n\nbool operator < (const Point &a, const Point &b){\n\treturn a.x() != b.x() ? a.x() < b.x() : a.y() < b.y();\n}\n\ninline istream& operator >> (istream &is, Point &p){\n\tdouble x, y;\n\tis >> x >> y;\n\tp = Point(x, y);\n\treturn is;\n}\n\ninline ostream& operator << (ostream &os, const Point &p){\n\treturn os << p.x() << \" \" << p.y();\n}\n\n}\n\nstruct Line {\n\tPoint p1, p2;\n};\n\ntypedef Line Segment;\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\ndouble norm(const Point &a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\n\ndouble dot(const Point &a, const Point &b){\n\treturn (conj(a) * b).x();\n}\n\ndouble cross(const Point &a, const Point &b){\n\treturn (conj(a) * b).y();\n}\n\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(const Line &l, const Point &p){\n\tPoint base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tPoint a = p1 - p0;\n\tPoint b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n// ????????§?????? or ????????´???\nbool intersectLL(const Line &l, const Line &m){\n\tPoint va = l.p2 - l.p1, vb = m.p2 - l.p1;\n\treturn !parallel(l, m) || EQ(cross(va, vb), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\tPoint va = l.p2 - l.p1, vb = s.p1 - l.p1, vc = s.p2 - l.p1;\n\treturn LEQ(cross(va, vb) * cross(va, vc), 0.0);\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\tPoint va = l.p1 - p, vb = l.p2 - p;\n\treturn EQ(cross(va, vb), 0.0);\n}\n\nbool intersectSS(const Segment &s, const Segment &t){\n\tPoint a = s.p1, b = s.p2, c = t.p1, d = t.p2;\n\treturn ccw(a, b, c) * ccw(a, b, d) <= 0\n\t\t&& ccw(c, d, a) * ccw(c, d, b) <= 0;\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn ccw(s.p1, s.p2, p) == ON_SEGMENT;\n}\n\nvoid solve()\n{\n\tint n;\n\tcin >> n;\n\tPolygon g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> g[i];\n\t}\n\t\n\tbool res = true;\n\t\n\tif (n & 1) res = false;\n\t\n\tfor (int i = 0; i < n / 2; i++){\n\t\tSegment s = {g[i], g[i + 1]};\n\t\tSegment t = {g[i + n / 2], (g[(i + n / 2 + 1) % g.size()])};\n\t\tif (!EQ(abs(s.p1 - s.p2), abs(t.p1 - t.p2))) res = false;\n\t\tif (!parallel(s, t)) res = false;\n\t}\n\t\n\tif (res){\n\t\tcout << (g[0] + g[n / 2]) / 2.0 << endl;\n\t}\n\telse {\n\t\tputs(\"NA\");\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout << fixed << setprecision(20);\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 55;\nll X[MAXN], Y[MAXN];\nint n;\n\nll square(ll x) {return x*x;}\n\nvoid solve() {\n    if (n % 2 == 1) {\n        cout << \"NA\" << endl;\n        return;\n    }\n    vector<ll> d(n), dd(n);\n    for (int i = 0; i < n; i++) {\n        int ni = (i+1)%4;\n        d[i] = (square(X[i]-X[ni])+square(Y[i]-Y[ni]));\n    }\n    for (int i = 0; i < n; i++) {\n        int ni = (i+1)%n, nni = (i+2)%n;\n        ll dx0 = X[ni]-X[i], dy0 = Y[ni]-Y[i];\n        ll dx1 = X[nni]-X[ni], dy1 = Y[nni]-Y[ni];\n        dd[i] = dx0*dx1 + dy0*dy1;\n    }\n    for (int i = 0; i < n-1; i++) {\n        if (d[i] != d[i+1] || dd[i] != dd[i+1]) {\n            cout << \"NA\" << endl;\n            return;\n        }\n    }\n    double ax = 0, ay = 0;\n    for (int i = 0; i < n; i++) {\n        ax += X[i];\n        ay += Y[i];\n    }\n    cout << ax/n << \" \" << ay/n << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> X[i] >> Y[i];\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n  int a[50],b[50],n;\n  cin>>n;\n    double c=0,d=0;\n    r(i,n){\n      cin>>a[i]>>b[i];\n      c+=a[i],d+=b[i];\n    }\n    c/=n,d/=n;\n    if(n%2)goto L;\n    r(i,n/2)if(!abs((a[i]+a[(i+n/2)%n])/2.0-c)<=0.0001||!abs((b[i]+b[(i+n/2)%n])/2.0-c))<=0.0001)goto L;\n    printf(\"%.11f %.11f\\n\",c,d);\n    if(0)L:cout<<\"NA\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\nusing namespace std; vector<pair<long double, long double>>vec; long double X[100000], Y[100000], X1[100000], X2[100000], X3[100000], X4[100000], Y1[100000], Y2[100000], Y3[100000], Y4[100000], INF = 1e+14, EPS = 1e-14; int Q;\nbool paralel(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tlong double xp[4], yp[4]; xp[0] = X1 - X2; yp[0] = Y1 - Y2; xp[1] = X3 - X4; yp[1] = Y3 - Y4;\n\tif (yp[0] == 0 && yp[1] == 0) { return true; }if (yp[0] == 0 && yp[1] != 0) { return false; }\n\tif (yp[0] != 0 && yp[1] == 0) { return false; }if ((xp[0] / yp[0]) == (xp[1] / yp[1])) { return true; }return false;\n}\npair<long double, long double>kouten(long double X1, long double Y1, long double X2, long double Y2, long double X3, long double Y3, long double X4, long double Y4) {\n\tif (paralel(X1, Y1, X2, Y2, X3, Y3, X4, Y4) == true) { return make_pair(INF, INF); }\n\tif (fabs(X1 - X2) < EPS) { X1 -= EPS; }if (fabs(X3 - X4) < EPS) { X3 -= EPS; }\n\tif (fabs(Y1 - Y2) < EPS) { Y1 -= EPS; }if (fabs(Y3 - Y4) < EPS) { Y3 -= EPS; }long double XP[4], YP[4], ZP[4];\n\tXP[0] = X1 - X2; YP[0] = Y1 - Y2; XP[1] = X3 - X4; YP[0] = Y1 - Y2; YP[1] = Y3 - Y4; ZP[0] = YP[0] / XP[0]; ZP[1] = YP[1] / XP[1];\n\tlong double X5 = X1, Y5 = Y3 - (X3 - X1)*ZP[1], K = (Y5 - Y1) / (ZP[0] - ZP[1]); long double L = K*ZP[0]; return make_pair(X1 + K, Y1 + L);\n}\nvoid solve() {\n\tfor (int i = 0; i < Q; i++) { \n\t\tX1[i] = X[i]; Y1[i] = Y[i]; X2[i] = X[(i + Q / 2) % Q]; Y2[i] = Y[(i + Q / 2) % Q]; \n\t\tvec.push_back(kouten(X[0], Y[0], X[Q / 2], Y[Q / 2], X1[i], Y1[i], X2[i], Y2[i])); \n\t}\n\tsort(vec.begin(), vec.end()); \n\tfor (int i = 0; i < vec.size() - 1; i++) { if (fabs(vec[i].first - vec[i + 1].first) < EPS && fabs(vec[i].second - vec[i + 1].second) < EPS && vec[i].first < sqrtl(INF)) { cout << \"NA\" << endl; return; } }cout << fixed << setprecision(15) << vec[0].first << ' ' << fixed << setprecision(15) << vec[0].second << endl;\n}\nint main() { cin >> Q; for (int i = 0; i < Q; i++) { cin >> X[i] >> Y[i]; }solve(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\ntypedef complex<double> Point;\n\nbool EQ(const Point& p,const Point& q){\n  if(abs(p.imag() - q.imag()) <= EPS\n     && abs(p.real() - q.real()) <= EPS) return true;\n  return false;\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<Point> points;\n\n    Point center_of_gravity(0,0);\n    for(int point_i = 0; point_i < N; point_i++){\n      double x,y;\n      scanf(\"%lf %lf\",&x,&y);\n      points.push_back(Point(x,y));\n      center_of_gravity += Point(x,y);\n    }\n    center_of_gravity /= N;\n\n    bool isok = true;\n    for(int point_i = 0; point_i < N; point_i++){\n      Point g = (points[point_i] + points[(point_i + N/2) % N]) / 2.0;\n      if(!EQ(center_of_gravity,g)){\n        isok = false;\n        break;\n      }\n    }\n    if(isok){\n      printf(\"%.7lf %.7lf\\n\",\n             center_of_gravity.real(),\n             center_of_gravity.imag());\n    }\n    else{\n      printf(\"NA\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol pol){\n    int n=pol.size();\n    if(n&2) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok = true;\n    rep(i,n){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-8){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        Pol pol(n);\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            pol[i]=P(x,y);\n        }\n        P ans=solve(pol);\n        if(ans == NA){\n            puts(\"NA\");\n        } else {\n            printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-8;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b){\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// a1,a2を通る直線 と b1,b2を通る直線 が平行かどうか返す.\nbool is_parallel(P a1, P a2, P b1, P b2){\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1,a2を通る直線 と b1,b2を通る直線の交点計算\nP intersection(P a1, P a2, P b1, P b2){\n\tP a = a2 - a1;\n\tP b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tvector<P> vp(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tvp[i] = P(x,y);\n\t}\n\t// used[i] := 辺 i について平行で長さが等しい辺が存在するかどうか\n\tbool used[51] = {false};\n\tfor(int i=0 ; i < n/2 ; i++ ){\n\t\tif( used[i] ) continue;\n\t\tint j = i + n/2;\n\t\t// 辺の長さ\n\t\tdouble a = abs(vp[i] - vp[(i+1)%n]);\n\t\tdouble b = abs(vp[j] - vp[(j+1)%n]);\n\t\tbool flag = is_parallel( vp[i], vp[(i+1)%n], vp[j], vp[(j+1)%n]);\n\t\tif( flag && equal(a,b) ){\n\t\t\tused[i] = used[j] = true;\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ){\n\t\t\tk++;\n\t\t}\n\t}\n\t// 頂点数が奇数 かつ すべての辺について平行で長さの等しい辺が存在するときは点Pが存在する.\n\tif( n%2 == 1 ){\n\t\tprintf(\"NA\\n\");\n\t}else if( k == n ){\n\t\tP p = intersection(vp[0], vp[n/2], vp[1], vp[n/2+1]);\n\t\tprintf(\"%.6f %.6f\\n\", p.X, p.Y);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, X[50], Y[50], sx, sy;\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &X[i], &Y[i]);\n\t\tsx += X[i];\n\t\tsy += Y[i];\n\t}\n\tif(N % 2 == 1) {\n\t\tprintf(\"NA\\n\");\n\t}\n\telse {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < N / 2; i++) {\n\t\t\tflag = flag && ((1.0 * sx / N - X[i]) * 2 == (X[N / 2 + i] - X[i]) && (1.0 * sy / N - Y[i]) * 2 == (Y[N / 2 + i] - Y[i]));\n\t\t}\n\t\tif(flag) {\n\t\t\tprintf(\"%.9f %.9f\\n\", gx, gy);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Input parallel\ntemplate<typename T>\nvoid input_at(size_t idx, T& a) {\n    cin >> a[idx];\n}\ntemplate<typename T, typename... Ts>\nvoid input_at(size_t idx, T& a, Ts&... ts) {\n    input_at<T>(idx, a);\n    input_at<T>(idx, ts...);\n}\ntemplate<typename T>\nvoid input_parallel(T& a) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<T>(idx, a);\n    }\n}\ntemplate<typename T, typename...Ts>\nvoid input_parallel(T& a, Ts&... ts) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<Ts...>(idx, a, ts...);\n    }\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\n\nint main()\n{\n    int n; cin >> n;\n    vector<double> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    if (n & 1) {\n        printf(\"NA\\n\");\n        return 0;\n    }\n\n    double cx = (x[0] + x[n/2]) / 2,\n           cy = (y[0] + y[n/2]) / 2;\n\n    bool ans = true;\n    for (int i = 1; i < n/2; ++i) {\n        if (abs((x[i] + x[i + n/2]) / 2 - cx) < EPS &&\n            abs((y[i] + y[i + n/2]) / 2 - cy) < EPS) {\n            continue;\n        }\n        ans = false;\n        break;\n    }\n\n    if (ans) {\n        printf(\"%.7lf %.7lf\\n\", cx, cy);\n    } else {\n        printf(\"NA\\n\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\n int x[60],y[60];\n     signed main(){\nint n;\n cin>>n;\n     \tif(n%2) {\n     \tcout<<\"NA\"<<endl;\n     \t\treturn 0;\n     \t}\n     \tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n     \t\n     \tint d=n/2;\n     \t\n     \tdouble gx=(x[0]+x[0+d]+0.0)/2.0;\n     \tdouble gy=(y[0]+y[0+d]+0.0)/2.0;\n     \tbool bo=true;\n     \tfor(int i=1;i<d;i++){\n     \t\tif(abs(gx-(x[i]+x[i+d]+0.0)/2.0)>0.00001)bo=false;\n     \t\tif(abs(gy-(y[i]+y[i+d]+0.0)/2.0)>0.00001)bo=false;\n     \t}\n     \tif(bo) printf(\"%.10lf %.10lf\\n\",gx,gy);\n     \telse cout<<\"NA\"<<endl;\n \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "//ConvexCut\n#include <iostream>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <tuple>\nusing namespace std;\ntypedef complex<double> xy_t;\n\ndouble dot_product(xy_t a, xy_t b) { return (conj(a) * b).real(); }\ndouble cross_product(xy_t a, xy_t b) { return (conj(a) * b).imag(); }\nxy_t projection(xy_t p, xy_t b) { return b * dot_product(p, b) / norm(b); }\nxy_t MiddlePoint(xy_t a, xy_t b) { return xy_t((a.real() + b.real()) / 2, (a.imag() + b.imag()) / 2); }\n\nstd::tuple<bool, double, double> ConvexCut(vector<xy_t> Point)\n{\n    int n = Point.size();\n\n    xy_t answer;\n    bool flag = 1;\n    if (n % 2 == 0)\n    {\n        for (int i = 0; i < n / 2; i++)\n        {\n            if (i == 0)\n            {\n                answer = MiddlePoint(Point.at(i), Point.at((i + n / 2) % n));\n            }\n            else\n            {\n                if (answer != MiddlePoint(Point.at(i), Point.at((i + n / 2) % n)))\n                {\n                    flag = 0;\n                }\n            }\n        }\n    }\n    else\n    {\n        flag = 0;\n    }\n\n    return forward_as_tuple(flag, answer.real(), answer.imag());\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<xy_t> P(n);\n    for (int i = 0; i < n; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        P.at(i) = xy_t(x, y);\n    }\n\n    bool answer_flag;\n    double answer_real, answer_imag;\n    tie(answer_flag, answer_real, answer_imag) = ConvexCut(P);\n    if (answer_flag)\n    {\n        printf(\"%.6f %.6f\\n\", answer_real,answer_imag);\n        //cout << answer_real << \" \" << answer_imag << endl;\n    }\n    else\n    {\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define MP make_pair\ntypedef pair<double, double> P;\ntypedef complex<double> xy_t;\nint n;\nxy_t p[50];\n// 図 (1) 内積: a.x*b.x +a.y*b.y\ndouble dot_product(xy_t a, xy_t b) { return (conj(a)*b).real(); }\n// 図 (2) クロス (外) 積, ベクトル a,b が作る三角形の符号付き面積の二倍: a.x*b.y- b.x*a.y\ndouble cross_product(xy_t a, xy_t b) { return (conj(a)*b).imag(); }\n// (対応図なし) 投影 原点と b を結ぶ直線に点 p を投影\nxy_t projection(xy_t p, xy_t b) { return b*dot_product(p,b)/norm(b); }\n\nvoid solve(){\n    if(n % 2){\n        printf(\"NA\\n\");\n        return;\n    }\n    xy_t a = (p[0] + p[n / 2]) * 0.5; \n    for (int i = 1; i < n / 2; ++i) {\n        xy_t b = (p[i] + p[i + n / 2]) * 0.5;\n        if(abs(a - b) > 0.0001){\n            printf(\"NA\\n\");\n            return;\n        }\n    }\n     printf(\"%.5f %.5f\\n\", a.real(), a.imag());\n}\nint main(){\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        double x, y;\n        cin >> x >> y;\n        p[i] = xy_t(x, y);\n    }\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    for(int i=0; i<n; i++){\n        cin >> p[i].first >> p[i].second;\n    }\n    if(n&1){\n        cout << \"NA\" << endl;\n        return 0;\n    }\n    int ax, ay;\n    for(int i=0; i*2 < n; i++){\n        int j = n/2 + i;\n        if(i == 0){\n            ax = p[i].first + p[j].first;\n            ay = p[i].second + p[j].second;\n        }\n        if(ax != p[i].first + p[j].first || ay != p[i].second + p[j].second){\n            cout << \"NA\" << endl;\n            return 0;\n        }\n    }\n    cout << fixed << setprecision(20) << 1.*ax/2. << \" \" << 1.*ay/2. << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);++(i))\nusing namespace std;\n\nconst double EPS=1e-10;\ndouble add(double l, double r){\n    if(abs(l+r)<EPS*(abs(l)+abs(r))) return 0;\n    return l+r;\n}\n//l-r は add(l,-r)\n//l==r は add(l,-r)==0\nstruct Pt{\n    double x, y;\n    Pt(double xx=0, double yy=0){x=xx; y=yy;}\n    Pt& operator=(const Pt &rhs){\n        x=rhs.x; y=rhs.y; return *this;\n    }\n    Pt& operator+=(const Pt &rhs){\n        x = add(x,rhs.x); y = add(y,rhs.y); return *this;\n    }\n    Pt& operator-=(const Pt &rhs){\n        x = add(x,-rhs.x); y = add(y,-rhs.y); return *this;\n    }\n    Pt& operator*=(const double &rhs){\n        x *= rhs; y *= rhs; return *this;\n    }\n    Pt& operator/=(const double &rhs){\n        x /= rhs; y /= rhs; return *this;\n    }\n};\nPt operator+(const Pt &a){return a;}\nPt operator-(const Pt &a){return Pt(-a.x,-a.y);}\nPt operator+(const Pt &lhs, const Pt &rhs){\n    Pt ans=lhs; ans += rhs; return ans;\n}\nPt operator-(const Pt &lhs, const Pt &rhs){\n    Pt ans=lhs; ans -= rhs; return ans;\n}\nPt operator*(const Pt &lhs, const double &rhs){\n    Pt ans=lhs; ans *= rhs; return ans;\n}\nPt operator*(const double &lhs, const Pt &rhs){\n    Pt ans=rhs; ans *= lhs; return ans;\n}\nPt operator/(const Pt &lhs, const double &rhs){\n    Pt ans=lhs; ans /= rhs; return ans;\n}\nbool operator==(const Pt &lhs, const Pt &rhs){\n    return add(lhs.x,-rhs.x)==0 && add(lhs.y,-rhs.y)==0;\n}\nbool operator!=(const Pt &lhs, const Pt &rhs){return !(lhs==rhs);}\nbool operator<(const Pt &lhs, const Pt &rhs){\n    return add(lhs.x,-rhs.x)!=0 ? add(lhs.x,-rhs.x)<0 : add(lhs.y,-rhs.y)<0;\n}\nbool operator>(const Pt &lhs, const Pt &rhs){return rhs<lhs;}\nbool operator<=(const Pt &lhs, const Pt &rhs){return !(lhs>rhs);}\nbool operator>=(const Pt &lhs, const Pt &rhs){return !(lhs<rhs);}\nistream& operator>>(istream &is, Pt &rhs){\n    double x, y;\n    is >> x >> y;\n    rhs=Pt(x,y);\n    return is;\n}\nostream& operator<<(ostream &os, const Pt &rhs){\n    os << rhs.x << \" \" << rhs.y;\n    return os;\n}\ndouble norm(const Pt &a){return add(a.x*a.x,a.y*a.y);}\ndouble abs(const Pt &a){return sqrt(norm(a));}\ndouble dot(Pt a, Pt b){return add(a.x*b.x,a.y*b.y);}\ndouble cross(Pt a, Pt b){return add(a.x*b.y,-a.y*b.x);}\nint ccw(Pt a, Pt b, Pt c) {\n    b -= a; c -= a;\n    if(cross(b, c)>0) return +2;  // counter clockwise\n    if(cross(b, c)<0) return -2;  // clockwise\n    if(dot(b, c)<0) return +1;        // c--a--b on line\n    if(norm(c)<norm(b)) return -1;    // b--c--a on line\n    return 0;                         // a--b--c on line\n}\nint main(){\n  ll n;\n  cin>>n;\n  vector<Pt> rec;\n  Pt centroid=0;\n  rep(i,n){\n    Pt tmp;\n    cin>>tmp;\n    rec.push_back(tmp);\n    centroid+=tmp;\n  }\n  if(n%2==1){\n    cout<<\"NA\"<<endl;\n    return 0;\n  }\n  centroid/=n;\n  bool f=true;\n  rep(i,n){\n    if(ccw(rec[i%n],centroid,rec[(i+n/2)%n])!=0 && f){\n      cout<<\"NA\"<<endl;\n      f=false;\n    }\n  }\n  cout<<fixed<<setprecision(10);\n  if(f)cout<<centroid<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-5;\nconst double INF = 1000000001.0;\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\nint ccw(P a, P b, P c){\n   b -= a;\n   c -= a;\n   if(cross(b,c) > EPS) return 1;\n   if(cross(b,c) < -EPS) return -1;\n   if(dot(b,c) < -EPS) return 2;\n   if(norm(b) < norm(c)) return -2;\n   return 0;\n}\n\nP crossPoint(L l, L m){\n   double A = cross(l.second - l.first, m.second - m.first);\n   double B = cross(l.second - l.first, l.second - m.first);\n   if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n   else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\ndouble area(vector<P> v){\n   double sum = 0.0;\n   int n = v.size();\n   for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n   return fabs(sum) / 2.0;\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n   for(int i=0;i<G.size();i++){\n      P A = G[i];\n      P B = G[(i+1)%G.size()];\n      if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n      if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0) ans.push_back(crossPoint(L(A,B), l));\n   }\n   return ans;\n}\n\nbool equal(double a, double b){ return (fabs(a-b) < EPS);}\nP rotate(P p, double theta){\n   theta = theta * M_PI / 180.0;\n   double x = real(p) * cos(theta) - imag(p) * sin(theta);\n   double y = real(p) * sin(theta) + imag(p) * cos(theta);\n   return P(x,y);\n}\n\nint main(){\n   int n;\n   while(cin >> n){\n      vector<P> v;\n      double minx=INF,miny=INF,maxx=-INF,maxy=-INF;\n      for(int i=0;i<n;i++){\n\t double a,b;\n\t cin >> a >> b;\n\t v.push_back(P(a,b));\n\t minx = min(minx,a);\n\t maxx = max(maxx,a);\n\t miny = min(miny,b);\n\t maxy = max(maxy,b);\n      }\n\n      double l = miny;\n      double r = maxy;\n      double all = area(v);\n      L yoko, tate;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(INF,mid),P(-INF,mid))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   yoko = L(P(-INF,mid),P(INF,mid));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      l = minx;\n      r = maxx;\n      while(1){\n\t double mid = (l + r) / 2.0;\n\t double half = area(convex_cut(v, L(P(mid,-INF),P(mid,INF))));\n\t if(equal(half*2.0, all)){\n\t   //cout << l << ' ' << r << ' ' << mid << ' ' << endl;\n\t   tate = L(P(mid,-INF),P(mid,INF));\n\t   break;\n\t } else if(half*2.0 > all) r = mid;\n\t else l = mid;\n      }\n\n      P ans = crossPoint(yoko,tate);\n      bool f = true;\n      //printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n\n      for(int i=0;i<v.size();i++){\n\t//L line = L(rotate(P(-INF,0.0),i)+ans,rotate(P(INF,0.0),i)+ans);\n\tL line = L(v[i], (ans + (ans-v[i])*INF));\n\tdouble half = area(convex_cut(v,line));\n\tif(!equal(half*2.0,all)){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f) printf(\"%.5f %.5f\\n\",real(ans),imag(ans));\n      else cout <<\"NA\" << endl;\n   }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n\n  vector<int> x(n), y(n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n  }\n\n  if(n%2){\n    puts(\"NA\");\n  }else{\n    set< pair<int,int> > med;\n    for(int i=0;i<n/2;i++){\n      med.insert( make_pair( x[i]+x[i+n/2], y[i]+y[i+n/2] ) );\n    }\n    if(med.size() != 1){\n      puts(\"NA\");\n    }else{\n      pair<int,int> ans = *med.begin();\n      printf(\"%.2f %.2f\\n\",ans.first/2.0,ans.second/2.0);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<int> x(n), y(n);\n  for(int i=0;i<n;i++){\n    cin >> x[i] >> y[i];\n    x[i] *= 2; y[i] *= 2;\n  }\n\n  if(n%2){\n    cout << \"NA\" << endl;\n  }else{\n    set< pair<int,int> > med;\n    for(int i=0;i<n/2;i++){\n      med.insert( make_pair( (x[i]+x[i+n/2])/2, (y[i]+y[i+n/2])/2 ) );\n    }\n    if(med.size() != 1){\n      cout << \"NA\" << endl;\n    }else{\n      pair<int,int> ans = *med.begin();\n      cout << ans.first/2.0 << \" \" << ans.second/2.0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nPoint Convexcut(Polygon p){\n  Point res(-1,-1),tmp;\n  int n=p.size();\n  for(int i=0;i<n/2;i++){\n    if(res.x==-1){\n      res=median_Point(p[i],p[i+n/2]);\n    }\n    else {\n      tmp=median_Point(p[i],p[i+n/2]);\n      if((res.x-tmp.x)>eps || (res.y-tmp.y)>eps)return Point(-1,-1);\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n  Polygon p;\n\n  cin>>n;\n  p.resize(n);\n  for(int i=0;i<n;i++)cin>>p[i].x>>p[i].y;\n\n  if(n%2==1){\n    cout<<\"NA\"<<endl;\n  }else {\n    Point ans=Convexcut(p);\n    if(ans.x==-1)cout<<\"NA\"<<endl;\n    else printf(\"%.10f %.10f\\n\",ans.x,ans.y);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<list>\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\ntypedef pair<P,double> C;\n\nconst double PI = acos(-1);\n\n//for vector\nP unit(P p){return p / abs(p);}\n\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//rotate a point counter-clockwise on the origin\nP rotate(P v,double s){\n  return P(real(v)*cos(s) - imag(v)*sin(s), real(v)*sin(s) + imag(v)*cos(s) );\n}\n\n//return seta A\ndouble arg(P a,P b,P c){return acos(dot(b-a,c-a)/(abs(b-a)*abs(c-a)));}\ndouble arg(double a,double b,double c){return acos( (b*b+c*c-a*a)/(2*b*c) );}\n\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nP line_cp(L a,L b){\n  double A = cross(b.sc-b.fs,b.fs-a.fs);\n  double B = cross(b.sc-b.fs,a.sc-a.fs);\n  if(abs(A) < EPS){\n    if(abs(B) < EPS)return a.fs; //same line\n    //else assert(false);\n  }\n  return a.fs+(a.sc-a.fs)*A/B;\n}\n\n//for polygon\n\n//all vertex is already sorted.\ndouble area(Poly p){\n  if(p.size()<3)return 0;\n  double res = cross(p[p.size()-1],p[0]);\n  for(int i=1;i<p.size();i++)res += cross(p[i-1],p[i]);\n  return res/2;\n}\n\n//all vertex is already sorted.\nPoly convex_cut(Poly p,L l){\n  Poly res;\n  int n = p.size();\n  for(int i=0;i<n;i++){\n    int nxt = (i+1)%n;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  Poly p;\n\n  scanf(\"%d\",&n);\n  p.resize(n);\n  for(int i=0;i<n;i++)scanf(\"%lf%lf\",&p[i].real(),&p[i].imag());\n  double s = area(p)/2;\n\n  P a[2];\n  double lx = p[0].real(), ux = p[0].real(), ly = p[0].imag();\n  for(int i=1;i<n;i++){\n    lx = min(lx,p[i].real());\n    ux = max(ux,p[i].real());\n    ly = min(ly,p[i].imag());\n  }\n  a[0] = P(lx,ly-1e2); a[1] = P(ux,ly-1e2);\n\n  L line[2];\n  for(int i=0;i<2;i++){\n    double l = 0,r = PI,mid;\n    P u = P(1,0);\n\n    for(int j=0;j<100;j++){\n      mid = (l+r)/2;\n      L tmp = L(a[i],a[i]+rotate(u,mid));\n      double cut = area(convex_cut(p,tmp));\n      if(cut + EPS < s)r = mid;\n      else l = mid;\n    }\n    line[i] = L(a[i],a[i]+rotate(u,l));\n  }\n  \n  P res = line_cp(line[0],line[1]);\n  for(int i=0;i<n;i++){\n    L tmp = L(res,p[i]);\n    Poly hoge = convex_cut(p,tmp);\n    if(abs(s - area(convex_cut(p,tmp))) > EPS){\n      printf(\"NA\\n\");\n      return 0;\n    }\n  }\n  printf(\"%.8lf %.8lf\\n\",res.real(),res.imag());\n}"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class T, class U>\nusing Pair = std::pair<T, U>;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <size_t N>\nusing Bits = std::bitset<N>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\nusing Polygon = std::vector<Point>;\n\nBool operator<(const Point& a, const Point& b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n}\n\nconstexpr Real EPS = 1e-10;\n\n// 宇宙船演算子\nInt compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\nReal dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\n\nvoid fail() {\n    std::cout << \"NA\" << std::endl;\n    std::exit(0);\n}\n\nint main() {\n    Int n;\n    std::cin >> n;\n    if (n % 2) fail();\n\n    Polygon g(n);\n    for (auto& p : g) std::cin >> p;\n\n    Vector<Point> center;\n    for (Int i = 0; i < n / 2; ++i) {\n        center.push_back((g[i] + g[i + n / 2]) / Real(2));\n    }\n\n    for (auto p : center) {\n        for (auto q : center) {\n            if (compare(dist(p, q), 0) > 0) fail();\n        }\n    }\n\n    std::cout << Fout(5)\n              << center.front().real() << ' '\n              << center.front().imag() << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, X[50], Y[50], sx, sy;\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &X[i], &Y[i]);\n\t\tsx += X[i];\n\t\tsy += Y[i];\n\t}\n\tif(N % 2 == 1) {\n\t\tprintf(\"NA\\n\");\n\t}\n\telse {\n\t\tbool flag = true;\n\t\tfor(int i = 0; i < N / 2; i++) {\n\t\t\tflag = flag && ((1.0 * sx / N - X[i]) * 2 == (X[N / 2 + i] - X[i]) && (1.0 * sy / N - Y[i]) * 2 == (Y[N / 2 + i] - Y[i]));\n\t\t}\n\t\tif(flag) {\n\t\t\tprintf(\"%.9f %.9f\\n\", 1.0 * sx / N, 1.0 * sy / N);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-8;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\t\n\tvector<P> vp(n);\n\tvector<Line> vl(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tvp[i] = P(x,y);\n\t\tvl[i] = Line(vp[i], vp[(i+1)%n]);\n\t}\n\t// used[i] := 辺 i について平行で長さが等しい辺が存在するかどうか\n\tbool used[51] = {false};\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) continue;\n\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\t// 辺の長さ\n\t\t\tdouble a = abs(vp[i] - vp[(i+1)%n]);\n\t\t\tdouble b = abs(vp[j] - vp[(j+1)%n]);\n\t\t\tif( vl[i].parallel( vl[j] ) && equal(a,b) ){\n\t\t\t\tused[i] = used[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tif( used[i] ) k++;\n\t}\n\t// すべての辺について平行で長さの等しい辺が存在するときは点Pが存在する.\n\tif( k == n ){\n\t\tLine l1(vp[0], vp[n/2]);\n\t\tLine l2(vp[1], vp[n/2+1]);\n\t\tP p;\n\t\tl1.intersection(l2, p);\n\t\tprintf(\"%.6f %.6f\\n\", p.X, p.Y);\n\t}else{\n\t\tprintf(\"NA\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef double frac;\nconst double EPS=1e-10;\ndouble add(double l, double r){\n    if(abs(l+r)<EPS*(abs(l)+abs(r))) return 0;\n    return l+r;\n}\ntypedef double frac;\nstruct Pt{\n    frac x, y;\n    Pt(frac xx=0, frac yy=0){x=xx; y=yy;}\n    Pt& operator=(const Pt &rhs){\n        x=rhs.x; y=rhs.y; return *this;\n    }\n    Pt& operator+=(const Pt &rhs){\n        x = add(x,rhs.x); y = add(y,rhs.y); return *this;\n    }\n    Pt& operator-=(const Pt &rhs){\n        x = add(x,-rhs.x); y = add(y,-rhs.y); return *this;\n    }\n    Pt& operator*=(const frac &rhs){\n        x *= rhs; y *= rhs; return *this;\n    }\n    Pt& operator/=(const frac &rhs){\n        x /= rhs; y /= rhs; return *this;\n    }\n};\nPt operator+(const Pt &lhs, const Pt &rhs){\n    Pt sum=lhs; sum += rhs; return sum;\n}\nPt operator-(const Pt &lhs, const Pt &rhs){\n    Pt sum=lhs; sum -= rhs; return sum;\n}\nPt operator*(const Pt &lhs, const frac &rhs){\n    Pt sum=lhs; sum *= rhs; return sum;\n}\nPt operator*(const frac &lhs, const Pt &rhs){\n    Pt sum=rhs; sum *= lhs; return sum;\n}\nPt operator/(const Pt &lhs, const frac &rhs){\n    Pt sum=lhs; sum /= rhs; return sum;\n}\nbool operator==(const Pt &lhs, const Pt &rhs){return lhs.x==rhs.x && lhs.y==rhs.y;}\nbool operator!=(const Pt &lhs, const Pt &rhs){return !(lhs==rhs);}\nbool operator<(const Pt &lhs, const Pt &rhs){return lhs.x!=rhs.x ? lhs.x<rhs.x : lhs.y<rhs.y;}\nbool operator>(const Pt &lhs, const Pt &rhs){return rhs<lhs;}\nbool operator<=(const Pt &lhs, const Pt &rhs){return !(lhs>rhs);}\nbool operator>=(const Pt &lhs, const Pt &rhs){return !(lhs<rhs);}\nbool operator<(Pt lhs, Pt rhs){\n    return lhs.x!=rhs.x ? lhs.x<rhs.x : lhs.y<rhs.y;\n}\nistream& operator>>(istream &is, Pt &rhs){\n    double x, y;\n    is >> x >> y;\n    rhs=Pt(x,y);\n    return is;\n}\nostream& operator<<(ostream &os, Pt rhs){\n    os << rhs.x << \" \" << rhs.y;\n    return os;\n}\nfrac dot(Pt a, Pt b){return a.x*b.x+a.y*b.y;}//内積\nfrac cross(Pt a, Pt b){return a.x*b.y-a.y*b.x;}//外積\n//qが線分p1-p2上にあればtrue\nbool on_seg(Pt p1, Pt p2, Pt q){\n    return cross(p1-q,p2-q)==0 && dot(p1-q,p2-q)<=0;\n}\n//intersection　交点を求める\nPt insec(Pt p1, Pt p2, Pt q1, Pt q2){\n    return p1+(cross(q2-q1,q1-p1)/cross(q2-q1,p2-p1))*(p2-p1);\n}\nint main(){\n\tint n;  cin >> n;\n    vector<Pt> p(n+1);\n    for(int i=0; i<n; i++) cin >> p[i];\n    p[n]=p[0];\n\n    bool flg=1;\n    if(n%2==1){\n        flg=0;\n    }else{\n        for(int i=0, j=n/2; i<n/2; ++i,++j){\n            if(p[i]-p[i+1]!=-1*(p[j]-p[j+1])){\n                flg=0;\n                break;\n            }\n        }\n    }\n\n    if(flg){\n        cout << fixed << setprecision(5);\n        cout << (p[0]+p[n/2])/2 << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr long double EPS = 1e-8;\n\nstruct point {\n\tlong double x, y;\n\tpoint(long double x = 0.0, long double y = 0.0):x(x), y(y) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(long double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n};\n\nlong double dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong double cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nlong double norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst long double t = cross(b, c);\n\tif(t > EPS) return 1;\n\tif(t < -EPS) return -1;\n\tif(dot(b, c) < 0) return 2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\npoint rotate(const point &p, long double theta) {\n\tconst long double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nstruct line {\n\tpoint a, b;\n\tline(const point &a_, const point &b_):a(a_), b(b_) {}\n};\n\npoint crosspoint(const line &a, const line &b) {\n\tconst long double t = cross(a.b - a.a, b.b - b.a);\n\tif(abs(t) < EPS) return a.a;\n\treturn b.a + (b.b - b.a) * cross(a.b - a.a, a.a - b.a) * (1 / t);\n}\n\ntypedef vector<point> polygon;\n\nlong double area(const polygon &p) {\n\tconst int n = p.size();\n\tif(n < 3) return 0.0;\n\n\tlong double res = cross(p[n - 1], p[0]);\n\tfor(int i = 1; i < n; ++i) {\n\t\tres += cross(p[i - 1], p[i]);\n\t}\n\treturn abs(res) * 0.5;\n}\n\npolygon convex_cut(const polygon &p, const line &l) {\n\tconst int n = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int next = (i + 1) % n;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1) res.emplace_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0) {\n\t\t\tres.emplace_back(crosspoint(l, line(p[i], p[next])));\n\t\t}\n\t}\n\n\treturn res;\n}\n\nbool ok(const point &g, const polygon &p) {\n\tconst long double S_half = area(p) / 2.0;\n\tfor(long double theta = 0; theta < M_PI; theta += 0.01) {\n\t\tconst long double  S = area(convex_cut(p, line(g, g + rotate(point(1, 0), theta))));\n\t\tif(abs(S_half - S) > EPS) return false;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(5);\n\tcout.flags(ios::fixed);\n\n\tint n;\n\tcin >> n;\n\n\tpoint g(0, 0);\n\tpolygon p;\n\tp.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp.emplace_back(x, y);\n\t\tg = g + p[i];\n\t}\n\n\tg = g * (1.0 / n);\n\n\tif(ok(g, p)) {\n\t\tcout << g.x << \" \" << g.y << endl;\n\t}\n\telse {\n\t\tcout << \"NA\" << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<point,point> line;\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\n\n// ベクタの長さ\ndouble vector_length(point a){\n    return abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n    return abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n    return a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n    point n1 = a * point(0,1);\n    point n2 = a * point(0,-1);\n    return make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n    return abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(line la,line lb) {\n    point a1=la.first,a2=la.second;\n    point b1=lb.first,b2=lb.second;\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// みけんしょう\nbool is_orthogonal(line a,line b) {\n  return dot(a.first-a.second, b.first-b.second) < EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n// みけんしょう\nbool is_parallel(line a,line b) {\n    return cross(a.first-a.second,b.first-b.second) < EPS;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_l(line la,line lb) {\n    return not is_parallel(la,lb);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_l(line la,line lb) {\n    point a1 = la.first,a2=la.second;\n    point b1 = lb.first,b2=lb.second;\n    point a = a2 - a1,b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n    b -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\ntypedef vector<point> vertex;\n\n// 多角形の面積\ndouble vertex_area(vertex v){\n    double ret = 0;\n    for(int i=0;i<v.size();i++){\n        ret += cross(v[i],v[(i+1)%v.size()]);\n    }\n    return ret/2;\n}\n\n\n// 角からには未対応\npoint find_opposite_point(vertex v,point p,int where_is_point){\n    double total_area = vertex_area(v);\n    vertex alr;\n    alr.push_back(p);\n    for(int i=1;i<v.size();i++){\n        int one = (where_is_point+i) % v.size();\n        int two = (where_is_point+i+1) % v.size();\n        alr.push_back(v[one]);\n\n        point vec;\n        vec = v[two] - v[one];\n        point u = unit_vector(vec);\n        double len = abs(vec);\n\n        double upper = len;\n        double lower = 0;\n        for(int j=0;j<100;j++){\n            // np is on one-two.\n            double mid = (upper + lower)/2;\n            point np = v[one] + u * mid;\n            alr.push_back(np);\n            if(vertex_area(alr) >= total_area/2){\n                upper = mid;\n            }else{\n                lower = mid;\n            }\n            alr.pop_back();\n        }\n        point np = v[one] + u*upper;\n        alr.push_back(np);\n        if(abs(vertex_area(alr)-total_area/2) < EPS){\n            return np;\n        }\n        alr.pop_back();\n    }\n    return point(-1,-1);\n}\n\nint main(){\n    cout << fixed << setprecision(10);\n    int N;\n    cin >> N;\n    vertex ver;\n    for(int i=0;i<N;i++){\n        int X,Y;\n        cin >> X >> Y;\n        ver.push_back(point(X,Y));\n    }\n    vector<line> chop;\n    for(int i=0;i<ver.size();i++){\n        point p = ver[i] + (ver[(i+1)%ver.size()] - ver[i])/point(3.14,0);\n        point op = find_opposite_point(ver,p,i);\n        chop.push_back(line(p,op));\n    }\n    point ret;\n    int cnt = 0;\n    for(int i=0;i<chop.size();i++){\n        for(int j=i+1;j<chop.size();j++){\n            if(is_intersected_linesegment(chop[i],chop[j])){\n                point p = intersection_point_linesegment(chop[i],chop[j]);\n                if(cnt == 0){\n                    ret = p;\n                    cnt = 1;\n                }else{\n                    if(abs(p-ret) < EPS) cnt++;\n                }\n            }\n        }\n    }\n    if(cnt == ver.size()){\n        cout << ret.real() << \" \" << ret.imag() << endl;\n    }else{\n        cout << \"NA\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\nint N;\nint x[50],y[50];\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  set<pair<int,int> >s;\n  for(int i=0;i+N/2<N;i++){\n    s.insert(make_pair(x[i]+x[i+N/2],y[i]+y[i+N/2]));\n  }\n  if(N%2==1||s.size()>1){\n    cout<<\"NA\"<<endl;\n  }else{\n    auto p=*begin(s);\n    cout<<fixed<<p.first/2.<<' '<<p.second/2.<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-12;\n\ntypedef complex<long double> P;\nlong double cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nlong double dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nP crosspoint(const L &l, const L &m) {\n  long double A = cross(l[1] - l[0], m[1] - m[0]);\n  long double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int N;\n  cin >> N;\n  vector<P> ps(N);\n  REP(i, N) cin >> ps[i].real() >> ps[i].imag();\n  \n  bool ok = true;\n  REP(i, N){\n    bool f = false;\n    REP(j, N)if(i != j){\n      f |=\n        !intersectLL(L(ps[i], ps[(i+1)%N]), L(ps[j], ps[(j+1)%N])) &&\n        abs(abs(ps[i] - ps[(i+1) %N]) - abs(ps[j] - ps[(j+1) % N])) < EPS;\n    }\n    ok &= f;\n  }\n  \n  if(ok){\n    P p = crosspoint(L(ps[0], ps[N/2]), L(ps[1], ps[N/2+1]));\n    cout << fixed << setprecision(20) << p.imag() << \" \" << p.real() << endl;\n  }else{\n    cout << \"NA\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\ntypedef long double DD;\n\nconst DD INF = 1LL<<60;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\nvector<Point> convexhull(vector<Point> ps) {\n    int n = ps.size();\n    vector<Point> res(2*n);\n    sort(ps.begin(), ps.end());\n    int k = 0;\n    for (int i = 0; i < n; ++i) {\n        if (k >= 2) {\n            while (cross(res[k-1] - res[k-2], ps[i] - res[k-2]) < EPS) {\n                --k;\n                if (k < 2) break;\n            }\n        }\n        res[k] = ps[i]; ++k;\n    }\n    int t = k+1;\n    for (int i = n-2; i >= 0; --i) {\n        if (k >= t) {\n            while (cross(res[k-1] - res[k-2], ps[i] - res[k-2]) < EPS) {\n                --k;\n                if (k < t) break;\n            }\n        }\n        res[k] = ps[i]; ++k;\n    }\n    res.resize(k-1);\n    return res;\n}\n\n\n\nint n;\ndouble x, y;\nvector<Point> ps;\n\nint main() {\n    cout << fixed << setprecision(10) << endl;\n    while (cin >> n) {\n        ps.clear();\n        ps.resize(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        vector<Point> pol = convexhull(ps);\n        \n        if (n & 1) { puts(\"NA\"); continue; }\n        \n        bool ok = true;\n        Point res = (pol[0] + pol[n/2]) / 2;\n        for (int i = 0; i < n/2; ++i) {\n            if ( !eq( (pol[i] + pol[i+n/2]) / 2, res ) ) ok = false;\n        }\n        \n        if (ok) cout << res.x << \" \" << res.y << endl;\n        else puts(\"NA\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,n) loop(i,0,n)\n\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> Pol;\n\nP NA(1e10,1e10);\n\nP solve(Pol pol){\n    int n=pol.size();\n    if(n&2) return NA;\n\n    P m = (pol[0]+pol[n/2])/2.;\n    bool ok = true;\n    rep(i,n){\n        P t((pol[i]+pol[(i+n/2)%n])/2.);\n        if(abs(m-t) > 1e-10){\n            ok = false;\n            break;\n        }\n    }\n    return ok ? m : NA;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        Pol pol(n);\n        rep(i,n){\n            double x,y;cin>>x>>y;\n            pol[i]=P(x,y);\n        }\n        P ans=solve(pol);\n        if(ans == NA){\n            puts(\"NA\");\n        } else {\n            printf(\"%.10lf %.10lf\\n\",ans.real(),ans.imag());\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define N 50\nusing namespace std;\nint n,x[N],y[N],flag=1;\ndouble gx,gy;\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    gx+=x[i]; gy+=y[i];\n  }\n  gx/=n; gy/=n;\n  for(int i=0;i<n;i++){\n    double px=gx+(gx-x[i]),py=gy+(gy-y[i]);\n    int f=0;\n    for(int j=0;j<n;j++)\n      if(abs(px-x[j])<EPS&&abs(py-y[j])<EPS)f=1;\n    if(!f)flag=0;\n  }\n  if(flag)printf(\"%.8f %.8f\\n\",gx,gy);\n  else cout<<\"NA\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??´???\n  L(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(const L &ab,const L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const P &p,const P &q){\n  return abs(p - q) ;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector(const P &a,const P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\ndouble calc_triangle(P a,P b,P c){\n  P ba = (b - a);\n  P ca = (c - a);\n  return (real(ba) * imag(ca) - imag(ba) * real(ca))/2.0;\n}\ndouble calc_area(const G &g){\n  double res = 0;\n  rep(i,g.size()-2){\n    res += calc_triangle(g[0],g[(i+1) % g.size()],g[(i+2) % g.size()]);\n  }\n  return res;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nG convex_cut(G &g, L &l) {\n  G h;\n  rep(i, (int)g.size()) {\n    P p = curr(g, i), q = next(g, i);\n    if (ccw(p, q, l[0]) == 0 && ccw(p, q, l[1]) == 0) {\n      if (ccw(p, l[1], l[0]) == 0) return g;    // p -- l.a -- l.b -- q\n      else return G{};                        // p -- l.b -- l.a -- q\n    }\n    if (ccw(l[0], l[1], p) != -1) h.emplace_back(p);\n    if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0)\n      h.emplace_back(crosspoint(L(p, q), l));\n  }\n  return h;\n}\nP center(const G &g){\n  int n = g.size();\n  P p(0,0);\n  rep(i,n){\n    p = p + g[i];\n  }\n  return p / (1.0 * n);\n}\nP rotP(P p, P q, double theta) {\n    p -= q;\n    double x = p.real(), y = p.imag();\n    p = P(x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta));\n    p += q;\n    return p;\n}\n\nG rotG(G &g, P &p, double theta) {\n    rep(i, g.size()) {\n        g[i] = rotP(g[i], p, theta);\n    }\n    return g;\n}\nbool EqG(G &g, G &h) {\n    if (g.size() != h.size()) return false;\n    rep(k, g.size()) {\n        bool flag = true;\n        rep(i, g.size()) {\n            if (!same(g[(i + k) % g.size()], h[i])) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >> n;\n  G g;\n  double x,y;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  P gp = center(g);\n  G h = rotG(g, gp, PI);\n  if(EqG(g,h))\n    fcout(10) << real(gp) << ' ' << imag(gp) << endl;\n  else\n    cout << \"NA\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\n \ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \nvector<P> C_cp(C a,C b){\n\tvector<P> ret;\n\tdouble L = abs(a.p-b.p);\n \n\t/* anma dekitenai */\n\tif(\tL-a.r-b.r > EPS || (abs(a.p-b.p)<EPS && fabs(a.r-b.r)<EPS) || \n\t\tabs(a.p-b.p) < abs(a.r-b.r)\n\t)return ret;\n \n\tdouble theta = atan2(b.p.imag()-a.p.imag(),b.p.real()-a.p.real());\n\tdouble c = (L*L+a.r*a.r-b.r*b.r)/(2*L*a.r);\n\tret.push_back(\n\t\tP(a.p.real()+a.r*cos(theta+acos(c)),\n\t\t  a.p.imag()+a.r*sin(theta+acos(c)))\n\t);\n\tif(fabs(L-a.r-b.r) > EPS)\n\t\tret.push_back(\n\t\t\tP(a.p.real()+a.r*cos(theta-acos(c)),\n\t\t\t  a.p.imag()+a.r*sin(theta-acos(c)))\n\t\t);\n\treturn ret;\n}\n \n \nP getPedal(L l, P p){\n\tdouble A;\n\tif(abs(l[1].real()-l[0].real()) < EPS){\n\t\treturn P(l[1].real(),p.imag()); // important\n\t}else{\n\t\tA = (l[1].imag()-l[0].imag())/(l[1].real()-l[0].real());\n\t}\n\tdouble a = -A , b = 1 , c = A*l[0].real() - l[0].imag();\n\tdouble t = (a*p.real() + b*p.imag() + c)/(a*a+b*b);\n\treturn p-t * P(a,b);\n}\n \nvector<P> crosspointCL(const L l, const C c){\n\tvector<P> ret;\n\tP p = getPedal(l,c.p);\n\tif(\tabs(p-c.p) > c.r+EPS)return ret;\n\tP e = P((l[1]-l[0])/abs(l[1]-l[0]));\n\tdouble S = sqrt(c.r*c.r-abs(p-c.p)*abs(p-c.p));\n\tret.push_back(p+S*e);\n\tret.push_back(p-S*e);\n\treturn ret;\n}\n \nP getCircumcenter(P a,P b,P c){\n\tdouble A1 = 2 * ( b.real() - a.real() );\n\tdouble B1 = 2 * ( b.imag() - a.imag() );\n\tdouble C1 = pow(a.real(),2)-pow(b.real(),2) + pow(a.imag(),2)-pow(b.imag(),2);\n\tdouble A2 = 2 * ( c.real() - a.real() );\n\tdouble B2 = 2 * ( c.imag() - a.imag() );\n\tdouble C2 = pow(a.real(),2)-pow(c.real(),2) + pow(a.imag(),2)-pow(c.imag(),2);\n\tdouble X = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1);\n\tdouble Y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1);\n\treturn P(X,Y);\n}\n \ndouble AreaOfPolygon(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*???????§???¢?????¢?????¬??? (???????¨????????????´???) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\n\nint main(){\n\tP gr;\n\tint N;\n\tcin >> N;\n\tG g,g2;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tg.push_back(P(x,y));\n\t\tgr += P(x,y);\n\t}\n\tgr /= N;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tg[i] -= gr;\n\t}\n\tg2 = g;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tg2[i] *= exp(P(0,acos(-1)));\n\t\t//cout << g2[i] << endl;\n\t}\n\tsort(g2.begin(),g2.end());\n\tsort(g.begin(),g.end());\n\tfor(int i = 0 ; i < N ; i++)\n\t\tif( abs(g[i]-g2[i]) > 1e-6 ){\n\t\t\tcout << \"NA\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\tprintf(\"%.10lf %.10lf\\n\",gr.real(),gr.imag());\n\t\n\t\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,X[99],Y[99],i,j;\ndouble x=0,y=0;\n#define ll long long\nll d(int a,int b)\n{\n\tll e,f;\n\treturn (e=abs(X[a]-X[b]))*e==(f=abs(Y[a]-Y[b]))*f;\n}\n\nint ch()\n{\n\tint i,j;\n\tif(N%2)return 0;\n\tfor(i=0;i<N/2;i++)\n\t\tif(!d(i,i+N/2))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",X+i,Y+i);\n\t\tx+=X[i];\n\t\ty+=Y[i];\n\t}\n\tch()?printf(\"%lf %lf\\n\",x/N,y/N):puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])/2\nfloat x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0),i=1;\n\t\ti++<n/2&&fabsf(Z(x,i)-X)<1e-7&&fabsf(Z(y,i)-Y)<1e-7;\n\t);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])\nx[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%d %d\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0);++i<n/2&&Z(x,i)==X&&Z(y,i)==Y;);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X/2.0,Y/2.0);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])\nint x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%d %d\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0);\n\t\ti<n/2&&Z(x,i)==X&&Z(y,i)==Y;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X/2.0,Y/2.0);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\ndouble x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%lf %lf\",x+n,y+n);n++);\n\tif(!(n&1))for(X=(x[0]+x[n/2])/2,Y=(y[0]+y[n/2])/2,i=1;\n\t\ti<n/2&&fabs((x[i]+x[n/2+i])/2-X)<1e-7&&fabs((y[i]+y[n/2+i])/2-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "double x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%lf %lf\",x+n,y+n);n++);\n\tif(!(n&1))for(X=(x[0]+x[n/2])/2,Y=(y[0]+y[n/2])/2,i=1;\n\t\ti<n/2&&fabs((x[i]+x[n/2+i])/2-X)<1e-7&&fabs((y[i]+y[n/2+i])/2-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])\nfloat x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0);\n\t\ti<n/2&&fabsf(Z(x,i)-X)<1e-7&&fabsf(Z(y,i)-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X/2,Y/2);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])/2\nfloat x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0);\n\t\ti<n/2&&fabsf(Z(x,i)-X)<1e-7&&fabsf(Z(y,i)-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\ndouble x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%lf %lf\",x+n,y+n);n++);\n\tif(!(n&1))for(X=(x[0]+x[n/2])/2,Y=(y[0]+y[n/2])/2,i=1;i<n/2;i++){\n\t\tif(fabs((x[i]+x[n/2+i])/2-X)>0.0000001||fabs((y[i]+y[n/2+i])/2-Y)>0.0000001)break;}\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <math.h>\ndouble x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%lf %lf\",x+n,y+n);n++);\n\tif(!(n&1))for(X=(x[0]+x[n/2])/2,Y=(y[0]+y[n/2])/2;\n\t\ti++<n/2&&fabs((x[i]+x[n/2+i])/2-X)<1e-7&&fabs((y[i]+y[n/2+i])/2-Y)<1e-7;\n\t);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,X[99],Y[99],i,j;\ndouble x=0,y=0;\n#define ll long long\nll d(int a,int b)\n{\n\tll e,f;\n\treturn (e=abs(X[a]-X[b]))*e+(f=abs(Y[a]-Y[b]))*f;\n}\n\nint ch()\n{\n\tint i,j;\n\tif(N%2)return 0;\n\tfor(i=0;i<N/2;i++)\n\t\tfor(j=0;j<N/2;j++)\n\t\t{\n\t\t\tif(d(i,i+N/2)!=d(j,j+N/2))return 0;\n\t\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",X+i,Y+i);\n\t\tx+=X[i];\n\t\ty+=Y[i];\n\t}\n\tch()?printf(\"%lf %lf\\n\",x/N,y/N):puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])/2\nfloat x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0),i=0;\n\t\ti++<n/2&&fabsf(Z(x,i)-X)<1e-7&&fabsf(Z(y,i)-Y)<1e-7;\n\t);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2442: ConvexCut\n// 2017.11.17 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint x[51], y[51];\n\nlong long norm(int dx, int dy)\n{\n\treturn (long long)dx*dx + (long long)dy*dy;\n}\n\nint parallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\treturn (long long)(y2-y1)*(long long)(x4-x3) == (long long)(x2-x1)*(long long)(y4-y3);\n}\n\nint main()\n{\n\tint n, n2, i, j;\n\n\tscanf(\"%d\", &n);\n\tif (n & 1) goto na;\n\tn2 = n >> 1;\n\tfor (i = 0; i < n; i++) scanf(\"%d%d\", x+i, y+i);\n\tx[n] = x[0], y[n] = y[0];\n\tfor (j = n2, i = 0; i < n2; i++, j++) {\n\t\tif (norm(x[i]-x[i+1], y[i]-y[i+1]) != norm(x[j]-x[j+1], y[j]-y[j+1])) goto na;\n\t\tif (!parallel(x[i], y[i], x[i+1], y[i+1], x[j], y[j], x[j+1], y[j+1])) goto na;\n\t}\n\tprintf(\"%.10lf %.10lf\\n\", (x[0]+x[n2])/2.0, (y[0]+y[n2])/2.0);\n\treturn 0;\nna: puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,X[99],Y[99],i,j;\ndouble x=0,y=0;\n\nint d(int a,int b)\n{\n\tint e,f;\n\treturn (e=abs(X[a]-X[b]))*e+(f=abs(Y[a]-Y[b]))*f;\n}\n\nint ch()\n{\n\tint i,j;\n\tif(N%2)return 0;\n\tfor(i=0;i<N/2;i++)\n\t\tfor(j=0;j<N/2;j++)\n\t\t{\n\t\t\tif(d(i,i+N/2)!=d(j,j+N/2))return 0;\n\t\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",X+i,Y+i);\n\t\tx+=X[i];\n\t\ty+=Y[i];\n\t}\n\tch()?printf(\"%lf %lf\\n\",x/N,y/N):puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint N,X[99],Y[99],i,j;\ndouble x=0,y=0;\n#define ll long long\ndouble d(int a,int b)\n{\n\tdouble e,f;\n\treturn sqrt((e=(double)abs(X[a]-X[b]))*e+(f=(double)abs(Y[a]-Y[b]))*f);\n}\n\ndouble c(int a)\n{\n\tdouble l1=d((a-1+N)%N,a);\n\tdouble l2=d(a,(a+1)%N);\n\tdouble l3=d((a-1+N)%N,(a+1)%N);\n\tdouble t1=pow(l3,2)-pow(l1,2)-pow(l2,2);\n\treturn (t1)/((-2)*l1*l2);\n}\n\nint ch()\n{\n\tint i,j;\n\tif(N%2)return 0;\n\tfor(i=0;i<N/2;i++)\n\t{\n\t\tdouble a=c(i);\n\t\tdouble b=c(i+N/2);\n\t\tif(c(i)!=c(i+N/2))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(i=0;i<N;i++)\n\t{\n\t\tscanf(\"%d%d\",X+i,Y+i);\n\t\tx+=X[i];\n\t\ty+=Y[i];\n\t}\n\tch()?printf(\"%lf %lf\\n\",x/N,y/N):puts(\"NA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define Z(x,i)(x[i]+x[n/2+i])/2\nfloat x[99],y[99],X,Y;\nn;main(i){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=Z(x,0),Y=Z(y,0);\n\t\ti<n/2&&fabsf(Z(x,i)-X)<1e-7&&fabsf(Z(y,i)-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "C",
    "code": "float x[99],y[99],X,Y;\nn,i;main(){\n\tfor(gets(x);~scanf(\"%f %f\",x+n,y+n);n++);\n\tif(!(n&1))for(X=(x[0]+x[n/2])/2,Y=(y[0]+y[n/2])/2,i=1;\n\t\ti<n/2&&fabsf((x[i]+x[n/2+i])/2-X)<1e-7&&fabsf((y[i]+y[n/2+i])/2-Y)<1e-7;\n\ti++);\n\tprintf(i==n/2?\"%f %f\\n\":\"NA\\n\",X,Y);exit(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tPoint2D[] points = new Point2D[N];\n    \tfor(int i = 0; i < N; i++){\n    \t\tpoints[i] = new Point2D(sc.nextInt(), sc.nextInt());\n    \t}\n    \t\n    \tif(N % 2 != 0){\n    \t\tSystem.out.println(\"NA\");\n    \t\treturn;\n    \t}\n    \t\n    \tPoint2D first = Point2D.interpoint_s(points[0], points[0 + N/2], points[1], points[1 + N/2]);\n    \t\n    \tfor(int i = 3; i < N/2; i++){\n    \t\tif(!first.equals(Point2D.interpoint_s(points[0], points[0 + N/2], points[i], points[i + N/2]))){\n    \t\t\tSystem.out.println(\"NA\");\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(first.x + \" \" + first.y);\n    }\n     \n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-6;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn x + \",\" + y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Point2D){\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(this.x - EPS > another.x && this.x + EPS < another.x &&\n\t\t\t\tthis.y - EPS > another.y && this.y + EPS < another.y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t//return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y - y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double pld(Point2D start, Point2D end){\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))/end.sub(start).dist_o());\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2, double r2){\n\t\tdouble dis = p1.dist(p2);\n\t\t\n\t\tif(r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS){\n\t\t\treturn new Point2D[0]; //same\n\t\t}\n\t\t\n\t\t\n\t\tif(dis - EPS < r1 + r2 && dis + EPS > r1 + r2){\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis + EPS > r1 + r2){\n\t\t\treturn new Point2D[0]; //out\n\t\t}\n\t\t\n\t\tdouble dis_m = Math.abs(r1-r2);\n\t\t\n\t\t\n\t\tif(dis_m + EPS > dis && dis_m - EPS < dis){\n\t\t\tPoint2D tmp = null;\n\t\t\tif(r1 > r2){\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t}else{\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Math.min(r1, r2);\n\t\t\t\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\t\t\t\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis_m + EPS > dis){\n\t\t\treturn new Point2D[0]; //inner\n\t\t}else{\n\t\t\tPoint2D ret[] = new Point2D[2];\n\t\t\t\n\t\t\tdouble theta = Math.acos((dis*dis + r1*r1 - r2*r2)/(2*dis*r1));\n\t\t\tdouble a = Math.atan2(p2.y-p1.y, p2.x-p1.x);\n\t\t\t\n\t\t\tret[0] = new Point2D(r1*Math.cos(a+theta) + p1.x, r1*Math.sin(a+theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1*Math.cos(a-theta) + p1.x, r1*Math.sin(a-theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\t\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start , Point2D end , Point2D c , double r , Point2D ans[]){\n\t\tif(c.pld(start , end) > r + EPS) return;\n\t\tPoint2D v= end.sub(start).unit();\n\t\tdouble delta=v.dot(start.sub(c))*v.dot(start.sub(c))-start.dist(c)*start.dist(c)+r*r;\n\t\tdouble t=-v.dot(start.sub(c));\n\t\tdouble s= Math.sqrt(delta);\n\t\tans[0]=start.add(v.mul(t+s));\n\t\tans[1]=start.add(v.mul(t+s));\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p,Point2D a,Point2D b){\n\t\tPoint2D v= b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ?  new Point2D(v.y,(-1)*v.x) : new Point2D((-1)*v.y , v.x);\n\t\treturn v.mul(p.pld(a,b));\n\t}\n\t\n\tpublic double area(Point2D a,Point2D b,Point2D c){\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a)))*0.5);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tPoint2D[] points = new Point2D[N];\n    \tfor(int i = 0; i < N; i++){\n    \t\tpoints[i] = new Point2D(sc.nextInt(), sc.nextInt());\n    \t}\n    \t\n    \tif(N % 2 != 0){\n    \t\tSystem.out.println(\"NA\");\n    \t\treturn;\n    \t}\n    \t\n    \tPoint2D first = Point2D.interpoint_s(points[0], points[0 + N/2], points[1], points[1 + N/2]);\n    \t\n    \tfor(int i = 3; i < N/2; i++){\n    \t\tif(!first.equals(Point2D.interpoint_s(points[0], points[0 + N/2], points[i], points[i + N/2]))){\n    \t\t\tSystem.out.println(\"NA\");\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(first.x + \" \" + first.y);\n    }\n     \n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-9;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn x + \",\" + y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Point2D){\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(this.x - EPS > another.x && this.x + EPS < another.x &&\n\t\t\t\tthis.y - EPS > another.y && this.y + EPS < another.y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t//return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y - y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double pld(Point2D start, Point2D end){\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))/end.sub(start).dist_o());\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2, double r2){\n\t\tdouble dis = p1.dist(p2);\n\t\t\n\t\tif(r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS){\n\t\t\treturn new Point2D[0]; //same\n\t\t}\n\t\t\n\t\t\n\t\tif(dis - EPS < r1 + r2 && dis + EPS > r1 + r2){\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis + EPS > r1 + r2){\n\t\t\treturn new Point2D[0]; //out\n\t\t}\n\t\t\n\t\tdouble dis_m = Math.abs(r1-r2);\n\t\t\n\t\t\n\t\tif(dis_m + EPS > dis && dis_m - EPS < dis){\n\t\t\tPoint2D tmp = null;\n\t\t\tif(r1 > r2){\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t}else{\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Math.min(r1, r2);\n\t\t\t\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\t\t\t\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis_m + EPS > dis){\n\t\t\treturn new Point2D[0]; //inner\n\t\t}else{\n\t\t\tPoint2D ret[] = new Point2D[2];\n\t\t\t\n\t\t\tdouble theta = Math.acos((dis*dis + r1*r1 - r2*r2)/(2*dis*r1));\n\t\t\tdouble a = Math.atan2(p2.y-p1.y, p2.x-p1.x);\n\t\t\t\n\t\t\tret[0] = new Point2D(r1*Math.cos(a+theta) + p1.x, r1*Math.sin(a+theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1*Math.cos(a-theta) + p1.x, r1*Math.sin(a-theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\t\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start , Point2D end , Point2D c , double r , Point2D ans[]){\n\t\tif(c.pld(start , end) > r + EPS) return;\n\t\tPoint2D v= end.sub(start).unit();\n\t\tdouble delta=v.dot(start.sub(c))*v.dot(start.sub(c))-start.dist(c)*start.dist(c)+r*r;\n\t\tdouble t=-v.dot(start.sub(c));\n\t\tdouble s= Math.sqrt(delta);\n\t\tans[0]=start.add(v.mul(t+s));\n\t\tans[1]=start.add(v.mul(t+s));\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p,Point2D a,Point2D b){\n\t\tPoint2D v= b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ?  new Point2D(v.y,(-1)*v.x) : new Point2D((-1)*v.y , v.x);\n\t\treturn v.mul(p.pld(a,b));\n\t}\n\t\n\tpublic double area(Point2D a,Point2D b,Point2D c){\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a)))*0.5);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tif (N % 2 != 0) {\n\t\t\tSystem.out.println(\"NA\");\n\t\t\treturn;\n\t\t}\n\t\tint[] X = new int[N];\n\t\tint[] Y = new int[N];\n\t\tint sx = 0;\n\t\tint sy = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = sc.nextInt() * N;\n\t\t\tY[i] = sc.nextInt() * N;\n\t\t\tsx += X[i];\n\t\t\tsy += Y[i];\n\t\t}\n\t\tsx /= N;\n\t\tsy /= N;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint dx = X[i] - sx;\n\t\t\tint dy = Y[i] - sy;\n\t\t\tif (X[(i + N / 2) % N] != sx - dx || Y[(i + N / 2) % N] != sy - dy) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((1.0 * sx / N) + \" \" + (1.0 * sy / N));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tPoint2D[] points = new Point2D[N];\n    \tfor(int i = 0; i < N; i++){\n    \t\tpoints[i] = new Point2D(sc.nextInt(), sc.nextInt());\n    \t}\n    \t\n    \tif(N % 2 != 0){\n    \t\tSystem.out.println(\"NA\");\n    \t\treturn;\n    \t}\n    \t\n    \tPoint2D first = Point2D.interpoint_s(points[0], points[0 + N/2], points[1], points[1 + N/2]);\n    \t\n    \tfor(int i = 2; i < N/2; i++){\n    \t\tif(!first.equals(Point2D.interpoint_s(points[0], points[0 + N/2], points[i], points[i + N/2]))){\n    \t\t\tSystem.out.println(\"NA\");\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(first.x + \" \" + first.y);\n    }\n     \n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-6;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn x + \",\" + y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Point2D){\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(this.x - EPS > another.x && this.x + EPS < another.x &&\n\t\t\t\tthis.y - EPS > another.y && this.y + EPS < another.y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t//return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y - y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double pld(Point2D start, Point2D end){\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))/end.sub(start).dist_o());\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2, double r2){\n\t\tdouble dis = p1.dist(p2);\n\t\t\n\t\tif(r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS){\n\t\t\treturn new Point2D[0]; //same\n\t\t}\n\t\t\n\t\t\n\t\tif(dis - EPS < r1 + r2 && dis + EPS > r1 + r2){\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis + EPS > r1 + r2){\n\t\t\treturn new Point2D[0]; //out\n\t\t}\n\t\t\n\t\tdouble dis_m = Math.abs(r1-r2);\n\t\t\n\t\t\n\t\tif(dis_m + EPS > dis && dis_m - EPS < dis){\n\t\t\tPoint2D tmp = null;\n\t\t\tif(r1 > r2){\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t}else{\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Math.min(r1, r2);\n\t\t\t\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\t\t\t\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis_m + EPS > dis){\n\t\t\treturn new Point2D[0]; //inner\n\t\t}else{\n\t\t\tPoint2D ret[] = new Point2D[2];\n\t\t\t\n\t\t\tdouble theta = Math.acos((dis*dis + r1*r1 - r2*r2)/(2*dis*r1));\n\t\t\tdouble a = Math.atan2(p2.y-p1.y, p2.x-p1.x);\n\t\t\t\n\t\t\tret[0] = new Point2D(r1*Math.cos(a+theta) + p1.x, r1*Math.sin(a+theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1*Math.cos(a-theta) + p1.x, r1*Math.sin(a-theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\t\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start , Point2D end , Point2D c , double r , Point2D ans[]){\n\t\tif(c.pld(start , end) > r + EPS) return;\n\t\tPoint2D v= end.sub(start).unit();\n\t\tdouble delta=v.dot(start.sub(c))*v.dot(start.sub(c))-start.dist(c)*start.dist(c)+r*r;\n\t\tdouble t=-v.dot(start.sub(c));\n\t\tdouble s= Math.sqrt(delta);\n\t\tans[0]=start.add(v.mul(t+s));\n\t\tans[1]=start.add(v.mul(t+s));\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p,Point2D a,Point2D b){\n\t\tPoint2D v= b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ?  new Point2D(v.y,(-1)*v.x) : new Point2D((-1)*v.y , v.x);\n\t\treturn v.mul(p.pld(a,b));\n\t}\n\t\n\tpublic double area(Point2D a,Point2D b,Point2D c){\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a)))*0.5);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// ConvexCut\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tdouble EPS=1e-6;\n\n\tint n;\n\tP[] ps;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tps=new P[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x=sc.nextInt();\n\t\t\tint y=sc.nextInt();\n\t\t\tps[i]=new P(x, y);\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tP g=new P();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tg=g.add(ps[i]);\n\t\t}\n\t\tg=g.div(n);\n\t\tboolean ok=true;\n\t\tdouble full=area(ps);\n\t\tRandom rand=new Random();\n\t\tfor(int i=0; i<2*n; i++){\n\t\t\tP cut=inDiv(ps[i%n], ps[(i+1)%n], rand.nextDouble(),\n\t\t\t\t\trand.nextDouble());\n\t\t\tP[] qs=convexCut(ps, cut, g);\n\t\t\tdouble area=area(qs);\n\t\t\tok&=reEq(full/2, area);\n\t\t}\n\t\tprintln(ok?(g.x+\" \"+g.y):\"NA\");\n\t}\n\n\tP inDiv(P p, P q, double m, double n){\n\t\treturn p.mul(n).add(q.mul(m)).div(m+n);\n\t}\n\n\t// relative error\n\tboolean reEq(double a, double b){\n\t\tif(a==0){\n\t\t\treturn abs(b)<EPS;\n\t\t}else{\n\t\t\treturn abs((a-b)/a)<EPS;\n\t\t}\n\t}\n\n\tdouble area(P[] ps){\n\t\tdouble area=0;\n\t\tfor(int i=1; i<ps.length-1; i++){\n\t\t\tdouble a=ps[0].sub(ps[i]).abs();\n\t\t\tdouble b=ps[0].sub(ps[i+1]).abs();\n\t\t\tdouble c=ps[i].sub(ps[i+1]).abs();\n\t\t\tdouble s=(a+b+c)/2;\n\t\t\tarea+=sqrt(s*(s-a)*(s-b)*(s-c));\n\t\t}\n\t\treturn area;\n\t}\n\n\tP[] convexCut(P[] ps, P p1, P p2){\n\t\tint n=ps.length;\n\t\tArrayList<P> res=new ArrayList<P>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint d1=(int)signum(p2.sub(p1).det(ps[i].sub(p1)));\n\t\t\tint d2=(int)signum(p2.sub(p1).det(ps[(i+1)%n].sub(p1)));\n\t\t\tif(d1>=0)\n\t\t\t\tres.add(ps[i]);\n\t\t\tif(d1*d2<0)\n\t\t\t\tres.add(isLL(p1, p2, ps[i], ps[(i+1)%n]));\n\t\t}\n\t\treturn res.toArray(new P[0]);\n\t}\n\n\tP isLL(P p1, P p2, P q1, P q2){\n\t\tdouble d=q2.sub(q1).det(p2.sub(p1));\n\t\tif(abs(d)<EPS)\n\t\t\treturn null;\n\t\treturn p1.add(p2.sub(p1).mul(q2.sub(q1).det(q1.sub(p1))/d));\n\t}\n\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\n\t\tP(){\n\t\t\tthis(0, 0);\n\t\t}\n\n\t\tP(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\tP add(P p){\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tP sub(P p){\n\t\t\treturn new P(x-p.x, y-p.y);\n\t\t}\n\n\t\tP mul(double m){\n\t\t\treturn new P(x*m, y*m);\n\t\t}\n\n\t\tP div(double d){\n\t\t\treturn new P(x/d, y/d);\n\t\t}\n\n\t\tdouble abs(){\n\t\t\treturn sqrt(abs2());\n\t\t}\n\n\t\tdouble abs2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\n\t\tdouble arg(){\n\t\t\treturn atan2(y, x);\n\t\t}\n\n\t\tdouble dot(P p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\n\t\tdouble det(P p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\n\t\tdouble ang(P p){\n\t\t\treturn atan2(det(p), dot(p));\n\t\t}\n\n\t\tP rot90(){\n\t\t\treturn new P(y, -x);\n\t\t}\n\n\t\tP rot(double d){\n\t\t\treturn new P(cos(d)*x-sin(d)*y, sin(d)*x+cos(d)*y);\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P p){\n\t\t\tif(x!=p.x)\n\t\t\t\treturn Double.compare(x, p.x);\n\t\t\telse\n\t\t\t\treturn Double.compare(y, p.y);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\", \"+y+\")\";\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/2156-input.txt\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tprivate final int SORT_TYPE_X = 1;\n\tprivate final int SORT_TYPE_Y = 2;\n\t\n\tprivate int points_sort_type = -1;\n\tprivate double EPS = 1e-9;\n\t\n\tdouble dadd(double a, double b) {\n\t\tif (Math.abs(a + b) < EPS * (Math.abs(a) + Math.abs(b))) return 0;\n\t\treturn a + b;\n\t}\n\t\n\tclass SortTypeUndefinedException extends Exception {\n\t\t\n\t}\n\t\n\tclass Point implements Comparable<Point> {\n\t\tdouble x;\n\t\tdouble y;\n\t\t\n \t\tPoint(double x, double y) {\n \t\t\tthis.x = x;\n \t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\tPoint add(double sx, double sy) {\n\t\t\treturn new Point(dadd(x, sx), dadd(y, sy));\n\t\t}\n\t\t\n\t\tPoint add(Point p) {\n\t\t\treturn add(p.x, p.y);\n\t\t}\n\t\t\n\t\tPoint sub(double sx, double sy) {\n\t\t\treturn new Point(dadd(x, -sx), dadd(y, -sy));\t\t\t\n\t\t}\n\t\t\n\t\tPoint sub(Point p) {\n\t\t\treturn sub(p.x, p.y);\n\t\t}\n\t\t\n\t\tPoint mult(double k) {\n\t\t\treturn new Point(x * k, y * k);\n\t\t}\n\t\t\n\t\tdouble dot(Point p) {\n\t\t\treturn dadd(x * p.x, y * p.y);\n\t\t}\n\n\t\tdouble det(Point p) {\n\t\t\treturn dadd(x * p.y, y * p.x);\n\t\t}\n\t\t\t\t\n\t\tdouble sin(Point p) {\n\t\t\tdouble cosVal = cos(p);\n\t\t\treturn Math.sqrt(1 - cosVal * cosVal);\n\t\t}\n\t\t\n\t\tdouble cos(Point p) {\n\t\t\tdouble res = dot(p) / (abs() * p.abs());\n\t\t\tif (res > 1) return res - EPS;\n\t\t\tif (res < -1) return res + EPS;\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tdouble abs() {\n\t\t\treturn Math.sqrt(dadd(x * x, y * y));\n\t\t}\n\t\t\n\t\tpublic int compareTo(Point s) {\n\t\t\ttry {\n\t\t\t\tswitch (points_sort_type) {\n\t\t\t\tcase SORT_TYPE_X :\n\t\t\t\t\tif (x == s.x) return Double.compare(y, s.y);\n\t\t\t\t\treturn Double.compare(x, s.x);\n\t\t\t\tcase SORT_TYPE_Y :\n\t\t\t\t\tif (y == s.y) return Double.compare(x, s.x);\n\t\t\t\t\treturn Double.compare(y, s.y);\n\t\t\t\tdefault :\n\t\t\t\t\tthrow new SortTypeUndefinedException();\n\t\t\t\t}\n\t\t\t} catch (SortTypeUndefinedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \")]\";\n\t\t}\n\t}\n\t\n\tPolygon getConvexHull(Point[] ps) {\n\t\tpoints_sort_type = SORT_TYPE_Y;\n\t\tArrays.sort(ps);\n\t\tint k = 0, n = ps.length;\n\t\tPoint[] qs = new Point[n * 2];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (k > 1 && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) <= 0) k--;\n\t\t\t\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t\t\n\t\tfor (int i = n - 2, t = k; i >= 0; i--) {\n\t\t\twhile (k > t && qs[k-1].sub(qs[k-2]).det(ps[i].sub(qs[k-1])) <= 0) k--;\n\t\t\t\n\t\t\tqs[k++] = ps[i];\n\t\t}\n\t\tqs = Arrays.copyOf(qs, k - 1);\n\t\t\n\t\treturn new Polygon(qs);\n\t}\n\t\n\tclass Polygon {\n\t\tPoint[] ps;\n\t\t\n\t\tPolygon(Point[] ps) {\n\t\t\tthis.ps = ps;\n\t\t}\n\t\t\n\t\tint getSize() {\n\t\t\treturn ps.length;\n\t\t}\n\t\t\n\t\tdouble getArea() {\n\t\t\tint n = getSize();\n\t\t\tdouble res = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres += (ps[(i + 1) % n].y + ps[i].y) * (ps[i].x - ps[(i + 1) % n].x) / 2.0;    \n\t\t    }\n\t\t\treturn Math.abs(res);\n\t\t}\n\t\t\n\t\tdouble getDistance() {\n\t\t\tint n = getSize();\n\t\t\tdouble res = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres += ps[i].sub(ps[(i+1)%n]).abs();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tPoint calcCenterOfGravity() {\n\t\t\tPoint res = new Point(0, 0);\n\t\t\tint n = getSize();\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = res.add(ps[i]);\n\t\t\t}\n\t\t\t\n\t\t\tres = res.mult(1.0 / n);\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tres.append(\"Polygon : \" + ps.length + \" <\");;\n\t\t\tfor (Point p : ps) {\n\t\t\t\tres.append(p.toString() + \", \");\n\t\t\t}\n\t\t\tres.append(\">\\n\");\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\t\n\tpublic void solve() {\t\n\t\tint n = in.nextInt();\n\t\tif (n % 2 == 1) {\n\t\t\tSystem.out.println(\"NA\");\n\t\t\treturn;\n\t\t}\n\t\tPoint[] ps = new Point[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tps[i] = new Point(in.nextDouble(), in.nextDouble());\n\t\t}\n\t\tPolygon pol = new Polygon(ps);\n\n\t\tdouble cx = ps[0].x + ps[n/2].x;\n\t\tdouble cy = ps[0].y + ps[n/2].y;\n\t\tfor (int i = 1; i < n/2; i++) {\n\t\t\tdouble cx2 = ps[i].x + ps[n/2+i].x;\n\t\t\tdouble cy2 = ps[i].y + ps[n/2+i].y;\n\t\t\tif (!(cx == cx2 && cy == cy2)) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPoint pg = pol.calcCenterOfGravity();\n\t\tSystem.out.println(pg.x + \" \" + pg.y);\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tfor(int j = i + 2; j < n; j++){\n\t\t\t\t\t\tif(i== 0 && j == n-1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(issame(ans, now)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdouble EPS = 1.0e-08;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// debug\n\t\t\t\tSystem.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\ts.push(new Num(min(255, (a.lo*b.lo)), min(255,(a.hi*b.hi)), z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\tSystem.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo/b.hi)), max(0, (a.hi/b.lo)), a.zero));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tif(n % 2 != 0){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n / 2; i++){\n\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[i + (n / 2)]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans.distance(now) > EPS){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(dot(p1, p2)) < EPS && Math.abs(dot(p3,p4)) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-04;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tif(n % 2 != 0){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n / 2; i++){\n\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[i + (n / 2)]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(issame(ans, now)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(dot(p1, p2)) < EPS && Math.abs(dot(p3,p4)) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-08;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tdouble midx = 0, midy = 0;\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t\tmidx += plist[i].getX();\n\t\t\t\t\tmidy += plist[i].getY();\n\t\t\t\t}\n\t\t\t\tmidx = midx / n;\n\t\t\t\tmidy = midy / n;\n\t\t\t\tif(n % 2 != 0){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n / 2; i++){\n\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[i + (n / 2)]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans.distance(now) > EPS){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(midx - ans.getX()) < EPS && Math.abs(midy - ans.getY()) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-04;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tfor(int j = i + 2; j < n; j++){\n\t\t\t\t\t\tif(i== 0 && j == n-1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(issame(ans, now)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(dot(p1, p2)) < EPS && Math.abs(dot(p3,p4)) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-08;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tstatic boolean EQ(double x, double y) {\n\t\treturn Math.abs(x - y) < 1.0e-9;\n\t}\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tint n = sc.nextInt();\n\t\t\tdouble[] xs = new double[n], ys = new double[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\txs[i] = sc.nextInt();\n\t\t\t\tys[i] = sc.nextInt();\n\t\t\t}\n\t\t\tif(n % 2 == 0) {\n\t\t\t\tint c = n/2;\n\t\t\t\tdouble x0 = (xs[0] + xs[c])/2;\n\t\t\t\tdouble y0 = (ys[0] + ys[c])/2;\n\t\t\t\tfor(int i = 1; i < c; i++) {\n\t\t\t\t\tdouble x = (xs[i] + xs[c+i])/2;\n\t\t\t\t\tdouble y = (ys[i] + ys[c+i])/2;\n\t\t\t\t\tif(!EQ(x0, x) || !EQ(y0 , y)) {\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"%.6f %.6f\", x0, y0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tif(n % 2 != 0){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n / 2; i++){\n\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[i + (n / 2)]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans.distance(now) > EPS){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(dot(p1, p2)) < EPS && Math.abs(dot(p3,p4)) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-04;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tPoint2D[] points = new Point2D[N];\n    \tfor(int i = 0; i < N; i++){\n    \t\tpoints[i] = new Point2D(sc.nextInt(), sc.nextInt());\n    \t}\n    \t\n    \tif(N % 2 != 0){\n    \t\tSystem.out.println(\"NA\");\n    \t\treturn;\n    \t}\n    \t\n    \tPoint2D first = Point2D.interpoint_s(points[0], points[0 + N/2], points[1], points[1 + N/2]);\n    \t\n    \tfor(int i = 2; i < N/2; i++){\n    \t\tif(!first.equals(Point2D.interpoint_s(points[0], points[0 + N/2], points[i], points[i + N/2]))){\n    \t\t\tSystem.out.println(\"NA\");\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(first.x + \" \" + first.y);\n    }\n     \n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-6;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn x + \",\" + y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Point2D){\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(this.x - EPS < another.x && this.x + EPS > another.x &&\n\t\t\t\tthis.y - EPS < another.y && this.y + EPS > another.y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t//return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y - y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double pld(Point2D start, Point2D end){\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))/end.sub(start).dist_o());\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2, double r2){\n\t\tdouble dis = p1.dist(p2);\n\t\t\n\t\tif(r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS){\n\t\t\treturn new Point2D[0]; //same\n\t\t}\n\t\t\n\t\t\n\t\tif(dis - EPS < r1 + r2 && dis + EPS > r1 + r2){\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis + EPS > r1 + r2){\n\t\t\treturn new Point2D[0]; //out\n\t\t}\n\t\t\n\t\tdouble dis_m = Math.abs(r1-r2);\n\t\t\n\t\t\n\t\tif(dis_m + EPS > dis && dis_m - EPS < dis){\n\t\t\tPoint2D tmp = null;\n\t\t\tif(r1 > r2){\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t}else{\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Math.min(r1, r2);\n\t\t\t\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\t\t\t\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis_m + EPS > dis){\n\t\t\treturn new Point2D[0]; //inner\n\t\t}else{\n\t\t\tPoint2D ret[] = new Point2D[2];\n\t\t\t\n\t\t\tdouble theta = Math.acos((dis*dis + r1*r1 - r2*r2)/(2*dis*r1));\n\t\t\tdouble a = Math.atan2(p2.y-p1.y, p2.x-p1.x);\n\t\t\t\n\t\t\tret[0] = new Point2D(r1*Math.cos(a+theta) + p1.x, r1*Math.sin(a+theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1*Math.cos(a-theta) + p1.x, r1*Math.sin(a-theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\t\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start , Point2D end , Point2D c , double r , Point2D ans[]){\n\t\tif(c.pld(start , end) > r + EPS) return;\n\t\tPoint2D v= end.sub(start).unit();\n\t\tdouble delta=v.dot(start.sub(c))*v.dot(start.sub(c))-start.dist(c)*start.dist(c)+r*r;\n\t\tdouble t=-v.dot(start.sub(c));\n\t\tdouble s= Math.sqrt(delta);\n\t\tans[0]=start.add(v.mul(t+s));\n\t\tans[1]=start.add(v.mul(t+s));\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p,Point2D a,Point2D b){\n\t\tPoint2D v= b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ?  new Point2D(v.y,(-1)*v.x) : new Point2D((-1)*v.y , v.x);\n\t\treturn v.mul(p.pld(a,b));\n\t}\n\t\n\tpublic double area(Point2D a,Point2D b,Point2D c){\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a)))*0.5);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tif (n%2==1) {\n\t\t\tSystem.out.println(\"NA\");\n\t\t\treturn;\n\t\t}\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tint cx2 = x[0]+x[n/2];\n\t\tint cy2 = y[0]+y[n/2];\n\t\tfor (int i=1;i<n/2;i++) {\n\t\t\tint cx = x[i]+x[n/2+i];\n\t\t\tint cy = y[i]+y[n/2+i];\n\t\t\tif (!(cx2==cx && cy2==cy)) {\n\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\treturn;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((double) cx2/2 + \" \" + (double) cy2/2 );\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \t\n    \tPoint2D[] points = new Point2D[N];\n    \tfor(int i = 0; i < N; i++){\n    \t\tpoints[i] = new Point2D(sc.nextInt(), sc.nextInt());\n    \t}\n    \t\n    \tif(N % 2 != 0){\n    \t\tSystem.out.println(\"NA\");\n    \t\treturn;\n    \t}\n    \t\n    \tPoint2D first = Point2D.interpoint_s(points[0], points[0 + N/2], points[1], points[1 + N/2]);\n    \t\n    \tfor(int i = 2; i < N/2; i++){\n    \t\tif(!first.equals(Point2D.interpoint_s(points[0], points[0 + N/2], points[i], points[i + N/2]))){\n    \t\t\tSystem.out.println(\"NA\");\n    \t\t\treturn;\n    \t\t}\n    \t}\n    \t\n    \tSystem.out.println(first.x + \" \" + first.y);\n    }\n     \n}\n\nclass Point2D {\n\tpublic double x;\n\tpublic double y;\n\t\n\tpublic static final double EPS = 1e-6;\n\t\n\tpublic Point2D(double x, double y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tpublic Point2D(Point2D point){\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn x + \",\" + y;\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Point2D){\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(this.x - EPS < another.x && this.x + EPS > another.x &&\n\t\t\t\tthis.y - EPS > another.y && this.y + EPS > another.y){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t//return this.x == another.x && this.y == another.y;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(double x, double y){\n\t\treturn new Point2D(this.x + x, this.y + y);\n\t}\n\t\n\tpublic Point2D sub(double x, double y){\n\t\treturn add(-x, -y);\n\t}\n\t\n\tpublic Point2D add(Point2D another){\n\t\treturn add(another.x, another.y);\n\t}\n\t\n\tpublic Point2D sub(Point2D another){\n\t\treturn sub(another.x, another.y);\n\t}\n\t\n\tpublic Point2D mul(double d){\n\t\treturn new Point2D(this.x * d, this.y * d);\n\t}\n\t\n\tpublic Point2D div(double d){\n\t\treturn new Point2D(this.x / d, this.y / d);\n\t}\n\t\n\tpublic double dot(double x, double y){\n\t\treturn this.x * x + this.y * y; \n\t}\n\t\n\tpublic double dot(Point2D another){\n\t\treturn dot(another.x, another.y);\n\t}\n\t\n\tpublic double cross(double x, double y){\n\t\treturn this.x * y - this.y * x; \n\t}\n\t\n\tpublic double cross(Point2D another){\n\t\treturn cross(another.x, another.y);\n\t}\n\t\n\tpublic double dist(double x, double y){\n\t\treturn Math.sqrt((this.x - x)*(this.x - x) + (this.y - y) * (this.y - y));\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn dist(another.x, another.y);\n\t}\n\t\n\tpublic double dist_o(){\n\t\treturn dist(0, 0);\n\t}\n\t\n\tpublic Point2D unit(){\n\t\treturn div(dist_o());\n\t}\n\t\n\tpublic boolean pol(Point2D start, Point2D end){\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\t\n\tpublic boolean pos(Point2D start, Point2D end){\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\t\n\tpublic double pld(Point2D start, Point2D end){\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))/end.sub(start).dist_o());\n\t}\n\t\n\tpublic double psd(Point2D start, Point2D end){\n\t\tif(end.sub(start).dot(this.sub(start)) < EPS){\n\t\t\treturn this.dist(start);\n\t\t}else if(start.sub(end).dot(this.sub(end)) < EPS){\n\t\t\treturn this.dist(end);\n\t\t}else{\n\t\t\treturn end.sub(start).cross(this.sub(start)) / end.dist(start);\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn (a2.sub(a1).cross(b1.sub(a1)) * a2.sub(a1).cross(b2.sub(a1)) < EPS) && (b2.sub(b1).cross(a1.sub(b1)) * b2.sub(b1).cross(a2.sub(b1)) < EPS);\n\t}\n\t\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\t\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1, Point2D b2){\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\t\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2, double r2){\n\t\tdouble dis = p1.dist(p2);\n\t\t\n\t\tif(r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS){\n\t\t\treturn new Point2D[0]; //same\n\t\t}\n\t\t\n\t\t\n\t\tif(dis - EPS < r1 + r2 && dis + EPS > r1 + r2){\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis + EPS > r1 + r2){\n\t\t\treturn new Point2D[0]; //out\n\t\t}\n\t\t\n\t\tdouble dis_m = Math.abs(r1-r2);\n\t\t\n\t\t\n\t\tif(dis_m + EPS > dis && dis_m - EPS < dis){\n\t\t\tPoint2D tmp = null;\n\t\t\tif(r1 > r2){\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t}else{\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\t\t\t\n\t\t\tdouble min = Math.min(r1, r2);\n\t\t\t\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\t\t\t\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t}else if(dis_m + EPS > dis){\n\t\t\treturn new Point2D[0]; //inner\n\t\t}else{\n\t\t\tPoint2D ret[] = new Point2D[2];\n\t\t\t\n\t\t\tdouble theta = Math.acos((dis*dis + r1*r1 - r2*r2)/(2*dis*r1));\n\t\t\tdouble a = Math.atan2(p2.y-p1.y, p2.x-p1.x);\n\t\t\t\n\t\t\tret[0] = new Point2D(r1*Math.cos(a+theta) + p1.x, r1*Math.sin(a+theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1*Math.cos(a-theta) + p1.x, r1*Math.sin(a-theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\t\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start , Point2D end , Point2D c , double r , Point2D ans[]){\n\t\tif(c.pld(start , end) > r + EPS) return;\n\t\tPoint2D v= end.sub(start).unit();\n\t\tdouble delta=v.dot(start.sub(c))*v.dot(start.sub(c))-start.dist(c)*start.dist(c)+r*r;\n\t\tdouble t=-v.dot(start.sub(c));\n\t\tdouble s= Math.sqrt(delta);\n\t\tans[0]=start.add(v.mul(t+s));\n\t\tans[1]=start.add(v.mul(t+s));\n\t}\n\t\n\tpublic Point2D normal_vector(Point2D p,Point2D a,Point2D b){\n\t\tPoint2D v= b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ?  new Point2D(v.y,(-1)*v.x) : new Point2D((-1)*v.y , v.x);\n\t\treturn v.mul(p.pld(a,b));\n\t}\n\t\n\tpublic double area(Point2D a,Point2D b,Point2D c){\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a)))*0.5);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew B();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tif(n % 2 != 0){\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n / 2; i++){\n\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[i + (n / 2)]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ans.distance(now) > EPS){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(n == 4){\n\t\t\t\t\tPoint2D p1 = sub(plist[0], plist[1]);\n\t\t\t\t\tPoint2D p2 = sub(plist[0], plist[3]);\n\t\t\t\t\tPoint2D p3 = sub(plist[2], plist[1]);\n\t\t\t\t\tPoint2D p4 = sub(plist[3], plist[2]);\n\t\t\t\t\tif(Math.abs(dot(p1, p2)) < EPS && Math.abs(dot(p3,p4)) < EPS){\n\t\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprivate double dot(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getX() + p1.getY() * p2.getY();\n\t\t\treturn res;\n\t\t}\n\t\tdouble EPS = 1.0e-04a;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nERROR = 1e-10\ninclude Math\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tdef include?(x, y)\n\t\t(@a * x + @b * y - c).abs < ERROR && \n\t\t(x - @x1) * (x - @x2) <= ERROR &&\n\t\t(y - @y1) * (y - @y2) <= ERROR\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tdef r\n\t\thypot(@x1 - @x2, @y1 - @y2)\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nn = gets.to_i\npoints = (1..n).map{ gets.split.map(&:to_i) }\nvecs = (points + [points[0]]).each_cons(2).map do |(x1, y1), (x2, y2)|\n\tVector[x2 - x1, y2 - y1]\nend\n\nR = vecs.map(&:r).inject(:+)\n\nlines = []\n\nget_bisection = -> do\n\torg = Vector[*points[0]]\n\thalfs = []\n\tr = 0\n\tuntil r >= R / 2\n\t\thalfs << vecs[halfs.size]\n\t\tr += halfs[-1].r\n\tend\n\td = halfs[-1].r\n\thalfs[-1] *= (d - (r - R / 2)) / d\n\tvecs << vecs.shift\n\tpoints << points.shift\n\tLine.through_two_points(*org.to_a, *halfs.inject(org, &:+))\nend\n\ncx, cy = get_bisection[].cross_point(get_bisection[])\nok = (3..n).all? do\n\tl = get_bisection[]\n\tl.include?(cx, cy) && (hypot(points[0][0] - cx, points[0][1] - cy) - l.r / 2) < ERROR\nend\n\nputs ok ? [cx, cy] * \" \" : 'NA'"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nERROR = 1e-5\ninclude Math\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tdef include?(x, y)\n\t\t(@a * x + @b * y - c).abs < ERROR && \n\t\t(x - @x1) * (x - @x2) <= ERROR &&\n\t\t(y - @y1) * (y - @y2) <= ERROR\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tdef r\n\t\thypot(@x1 - @x2, @y1 - @y2)\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nn = gets.to_i\npoints = (1..n).map{ gets.split.map(&:to_i) }\nvecs = (points + [points[0]]).each_cons(2).map do |(x1, y1), (x2, y2)|\n\tVector[x2 - x1, y2 - y1]\nend\n\nR = vecs.map(&:r).inject(:+)\n\nlines = []\n\nget_bisection = -> do\n\torg = Vector[*points[0]]\n\thalfs = []\n\tr = 0\n\tuntil r >= R / 2\n\t\thalfs << vecs[halfs.size]\n\t\tr += halfs[-1].r\n\tend\n\td = halfs[-1].r\n\thalfs[-1] *= (d - (r - R / 2)) / d\n\tvecs << vecs.shift\n\tpoints << points.shift\n\tLine.through_two_points(*org.to_a, *halfs.inject(org, &:+))\nend\n\ncx, cy = get_bisection[].cross_point(get_bisection[])\nok = (3..n).all? do\n\tl = get_bisection[]\n\tl.include?(cx, cy) && (hypot(points[0][0] - cx, points[0][1] - cy) - l.r / 2) < ERROR\nend\n\nputs ok ? [cx, cy] * \" \" : 'NA'"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nERROR = 1e-5\ninclude Math\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nn = gets.to_i\npoints = (1..n).map{ gets.split.map(&:to_i) }\nvecs = (points + [points[0]]).each_cons(2).map do |(x1, y1), (x2, y2)|\n\tVector[x2 - x1, y2 - y1]\nend\n\nR = vecs.map(&:r).inject(:+)\n\nlines = []\n\nget_bisection = -> do\n\torg = Vector[*points[0]]\n\thalfs = []\n\tr = 0\n\tuntil r >= R / 2\n\t\thalfs << vecs[halfs.size]\n\t\tr += halfs[-1].r\n\tend\n\td = halfs[-1].r\n\thalfs[-1] *= (d - (r - R / 2)) / d\n\tvecs << vecs.shift\n\tpoints << points.shift\n\tLine.through_two_points(*org.to_a, *halfs.inject(org, &:+))\nend\n\ncx, cy = get_bisection[].cross_point(get_bisection[])\nok = (1..n).all? do\n\tl = get_bisection[]\n\thypot(cx - (l.x1 + l.x2) / 2, cy - (l.y1 + l.y2) / 2) < ERROR\nend\n\nputs ok ? [cx, cy] * \" \" : 'NA'"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nERROR = 1e-5\ninclude Math\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nn = gets.to_i\npoints = (1..n).map{ gets.split.map(&:to_i) }\nvecs = (points + [points[0]]).each_cons(2).map do |(x1, y1), (x2, y2)|\n\tVector[x2 - x1, y2 - y1]\nend\n\nR = vecs.map(&:r).inject(:+)\n\nlines = []\n\nget_bisection = -> do\n\torg = Vector[*points[0]]\n\thalfs = []\n\tr = 0\n\tuntil r >= R / 2\n\t\thalfs << vecs[halfs.size]\n\t\tr += halfs[-1].r\n\tend\n\td = halfs[-1].r\n\thalfs[-1] *= (d - (r - R / 2)) / d\n\tvecs << vecs.shift\n\tpoints << points.shift\n\tLine.through_two_points(*org.to_a, *halfs.inject(org, &:+))\nend\n\ncx, cy = get_bisection[].cross_point(get_bisection[])\nok = (1..n).all? do\n\tl = get_bisection[]\n\thypot(cx - (l.x1 + l.x2) / 2, cy - (l.y1 + l.y2) / 2) < ERROR\nend\n\nputs ok ? sprintf(\"%.6f %.6f\", cx, cy) : 'NA'"
  },
  {
    "language": "Python",
    "code": "n = input()\nP = set()\ngx = gy = 0\nfor i in xrange(n):\n    x, y = map(int, raw_input().split())\n    P.add((n*x, n*y))\n    gx += x; gy += y\nok = 1\nfor x, y in P:\n    x += 2*(gx - x)\n    y += 2*(gy - y)\n    if (x, y) not in P:\n        ok = 0\nif ok:\n    print \"%.08f %.08f\" % (gx/float(n), gy/float(n))\nelse:\n    print \"NA\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN = input()\nlst = []\n\nfor i in range(N):\n    X, Y = map(int, raw_input().split())\n    lst.append((X, Y))\n\nif N % 2 != 0:\n    print \"NA\"\n    exit()\n\nansx = lst[0][0] + lst[N / 2][0]\nansy = lst[0][1] + lst[N / 2][1]\n\nfor i in range(N / 2):\n    x = lst[i][0] + lst[i + N / 2][0]\n    y = lst[i][1] + lst[i + N / 2][1]\n    if x != ansx or y != ansy:\n        print \"NA\"\n        exit()\n\nprint str(ansx / 2.0) + \" \" + str(ansy / 2.0)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef area(xy):\n    xy = sorted(xy)\n    x = [xy[i][0] - xy[0][0] for i in range(3)]\n    y = [xy[i][1] - xy[0][1] for i in range(3)]\n    return abs(x[1]*y[2] - x[2]*y[1]) / 2\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    k = 0\n    ps.sort()\n    ch = [None] * (n*2)\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n\n    return ch[:k-1]\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi + eps:\n        mm = (ma+mi) / 2.0\n        if f(mm):\n            mi = mm + eps\n        else:\n            ma = mm\n    if f(mm):\n        return mm + eps\n    return mm\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    if delta == 0:\n        return None\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    n = I()\n    a = convex_hull([LI() for _ in range(n)])\n    n = len(a)\n    a = a + a + a\n    s = 0\n    for i in range(1,n-1):\n        s += area([a[0],a[i],a[i+1]])\n    def f(i, fk):\n        t = 0\n        tj = i + 1\n        ra = [a[i+1][j] - a[i][j] for j in range(2)]\n        ap = [a[i][j] + ra[j] * fk for j in range(2)]\n        for j in range(i+1, i+n):\n            u = area([ap, a[j], a[j+1]])\n            if t + u >= s / 2:\n                tj = j\n                break\n            t += u\n        ts = s / 2 - t\n        sa = [a[tj+1][j] - a[tj][j] for j in range(2)]\n        def _f(k):\n            b = [a[tj][j] + sa[j] * k for j in range(2)]\n            fs = area([a[i], a[tj], b])\n            return fs < ts\n        bk = bs(_f, 0, 1)\n        return [ap, [a[tj][j] + sa[j] * bk for j in range(2)]]\n\n    ls = [f(i//5, random.random()) for i in range(n*5)]\n    ll = len(ls)\n    kts = []\n    sx = 0\n    sy = 0\n    for i in range(ll):\n        for j in range(i+1,ll):\n            t = intersection(ls[i][0], ls[i][1], ls[j][0], ls[j][1])\n            if t is None:\n                return 'NA'\n            kts.append(t)\n            sx += t[0]\n            sy += t[1]\n    mx = sx / len(kts)\n    my = sy / len(kts)\n    keps = 1.0 / 10**5\n    for i in range(len(kts)):\n        if abs(mx-t[0]) > keps or abs(my-t[1]) > keps:\n            return 'NA'\n    return '{} {}'.format(mx, my)\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef area(xy):\n    xy = sorted(xy)\n    x = [xy[i][0] - xy[0][0] for i in range(3)]\n    y = [xy[i][1] - xy[0][1] for i in range(3)]\n    return abs(x[1]*y[2] - x[2]*y[1]) / 2\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    k = 0\n    ps.sort()\n    ch = [None] * (n*2)\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n\n    return ch[:k-1]\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi + eps:\n        mm = (ma+mi) / 2.0\n        if f(mm):\n            mi = mm + eps\n        else:\n            ma = mm\n    if f(mm):\n        return mm + eps\n    return mm\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    if delta == 0:\n        return None\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    n = I()\n    a = convex_hull([LI() for _ in range(n)])\n    n = len(a)\n    a = a + a + a\n    s = 0\n    for i in range(1,n-1):\n        s += area([a[0],a[i],a[i+1]])\n    def f(i, fk):\n        t = 0\n        tj = i + 1\n        ra = [a[i+1][j] - a[i][j] for j in range(2)]\n        ap = [a[i][j] + ra[j] * fk for j in range(2)]\n        for j in range(i+1, i+n):\n            u = area([ap, a[j], a[j+1]])\n            if t + u >= s / 2:\n                tj = j\n                break\n            t += u\n        ts = s / 2 - t\n        sa = [a[tj+1][j] - a[tj][j] for j in range(2)]\n        def _f(k):\n            b = [a[tj][j] + sa[j] * k for j in range(2)]\n            fs = area([a[i], a[tj], b])\n            return fs < ts\n        bk = bs(_f, 0, 1)\n        return [ap, [a[tj][j] + sa[j] * bk for j in range(2)]]\n\n    ls = [f(i//5, random.random()) for i in range(n*5)]\n    ll = len(ls)\n    kts = []\n    sx = 0\n    sy = 0\n    for i in range(ll):\n        for j in range(i+1,ll):\n            t = intersection(ls[i][0], ls[i][1], ls[j][0], ls[j][1])\n            if t is None:\n                return 'NA'\n            kts.append(t)\n            sx += t[0]\n            sy += t[1]\n    mx = sx / len(kts)\n    my = sy / len(kts)\n    keps = 1.0 / 10**5\n    for i in range(len(kts)):\n        if abs(mx-t[0]) > keps or abs(my-t[1]) > keps:\n            return 'NA'\n    return '{:.9f} {:.9f}'.format(mx, my)\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(lis,N):\n    x=(lis[0][0]+lis[N//2][0])\n    y=(lis[0][1]+lis[N//2][1])\n    for i in range(1,N//2):\n        if (lis[i][0]+lis[i+N//2][0])!=x or (lis[i][1]+lis[i+N//2][1])!=y:\n            return \"NA\"\n    return str(x/2)+\" \"+str(y/2)\n\nN=int(input())\nif N%2==1:\n    print(\"NA\")\nelse:\n    lis=[]\n    for i in range(N):\n        lis.append(tuple(map(int,input().split())))\n    ans=solve(lis,N)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\neps=0.0001\nn=int(input())\nx_sum=0\ny_sum=0\ndata=[]\nfor i in range(n):\n    x,y=map(int,input().split())\n    x_sum+=x\n    y_sum+=y\n    data.append((x,y))\nx_sum/=n\ny_sum/=n\nif n%2!=0:\n    print('NA')\n    exit()\n\nfor i in range(n//2):\n    if abs(((data[i][0]-x_sum)**2+(data[i][1]-y_sum)**2)**0.5\\\n    -((data[i+n//2][0]-x_sum)**2+(data[i+n//2][1]-y_sum)**2)**0.5)<=eps:\n        pass\n    else:\n        print('NA')\n        exit()\n\nprint(x_sum,y_sum)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef area(xy):\n    xy = sorted(xy)\n    x = [xy[i][0] - xy[0][0] for i in range(3)]\n    y = [xy[i][1] - xy[0][1] for i in range(3)]\n    return abs(x[1]*y[2] - x[2]*y[1]) / 2\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    k = 0\n    ps.sort()\n    ch = [None] * (n*2)\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n\n    return ch[:k-1]\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi + eps:\n        mm = (ma+mi) / 2.0\n        if f(mm):\n            mi = mm + eps\n        else:\n            ma = mm\n    if f(mm):\n        return mm + eps\n    return mm\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    if delta == 0:\n        return None\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    n = I()\n    a = convex_hull([LI() for _ in range(n)])\n    n = len(a)\n    a = a + a + a\n    s = 0\n    for i in range(1,n-1):\n        s += area([a[0],a[i],a[i+1]])\n    def f(i, fk):\n        t = 0\n        tj = i + 1\n        ra = [a[i+1][j] - a[i][j] for j in range(2)]\n        ap = [a[i][j] + ra[j] * fk for j in range(2)]\n        for j in range(i+1, i+n):\n            u = area([ap, a[j], a[j+1]])\n            if t + u >= s / 2:\n                tj = j\n                break\n            t += u\n        ts = s / 2 - t\n        sa = [a[tj+1][j] - a[tj][j] for j in range(2)]\n        def _f(k):\n            b = [a[tj][j] + sa[j] * k for j in range(2)]\n            fs = area([a[i], a[tj], b])\n            return fs < ts\n        bk = bs(_f, 0, 1)\n        return [ap, [a[tj][j] + sa[j] * bk for j in range(2)]]\n\n    ls = [f(i//5, random.random()) for i in range(n*5)]\n    ll = len(ls)\n    kts = []\n    sx = 0\n    sy = 0\n    for i in range(ll):\n        for j in range(i+1,ll):\n            t = intersection(ls[i][0], ls[i][1], ls[j][0], ls[j][1])\n            if t is None:\n                return 'NA'\n            kts.append(t)\n            sx += t[0]\n            sy += t[1]\n    mx = sx / len(kts)\n    my = sy / len(kts)\n    keps = 1.0 / 10**5\n    for i in range(len(kts)):\n        if abs(mx-t[0]) > keps or abs(my-t[1]) > keps:\n            return 'NA'\n    return '{} {}'.format(mx, my)\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "N = input()\nlst = []\n\nfor i in range(N):\n    X, Y = map(int, raw_input().split())\n    lst.append((X, Y))\n\nif N % 2 != 0:\n    print \"NA\"\n    exit()\n\nansx = lst[0][0] + lst[N / 2][0]\nansy = lst[0][1] + lst[N / 2][1]\n\nfor i in range(N / 2):\n    x = lst[i][0] + lst[i + N / 2][0]\n    y = lst[i][1] + lst[i + N / 2][1]\n    if x != ansx or y != ansy:\n        print \"NA\"\n        exit()\n\nprint str(ansx / 2.0) + \" \" + str(ansy / 2.0)\n"
  },
  {
    "language": "Python",
    "code": "from sys import exit\nEPS = 1e-6\n\n#外積\ndef OuterProduct(one, two):\n\ttmp = one.conjugate() * two\n\treturn tmp.imag\n\n#内積\ndef InnerProduct(one, two):\n\ttmp = one.conjugate() * two\n\treturn tmp.real\n\n#点が線分上にあるか\ndef IsOnSegment(point, begin, end):\n\tif abs(OuterProduct(begin-point, end-point)) <= EPS and InnerProduct(begin-point, end-point) <= EPS:\n\t\treturn True\n\telse:\n\t\treturn False\n\n#直線の交点，平行の場合はNoneを返す\ndef Crosspoint(a, b, c, d):\n\tif abs(OuterProduct(b-a, d-c)) <= EPS:\n\t\treturn None\n\telse:\n\t\tu = OuterProduct(c-a, d-a) / OuterProduct(b-a, d-c)\n\t\treturn (1-u)*a + u*b\n\nn = int(input())\nd = []\nfor _ in range(n):\n\tx, y = map(int, input().split())\n\td.append(complex(x, y))\n\nif n%2 == 1:\n\tprint(\"NA\")\n\texit()\n\nok = True\nans = Crosspoint(d[0], d[n//2], d[1], d[n//2+1])\n#print(ans)\n\nfor i in range(n//2):\n\tif IsOnSegment(ans, d[i], d[n//2+i]) == False or IsOnSegment(ans, d[i+1], d[(n//2+i+1)%n]) == False:\n\t\tok = False\n\tif abs(ans - d[i]) != abs(ans - d[n//2+i]):\n\t\tok = False\n\tif abs(ans - d[i+1]) != abs(ans - d[(n//2+i+1)%n]):\n\t\tok = False\n\nif ok:\n\tprint(ans.real, ans.imag)\nelse:\n\tprint(\"NA\")\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef area(xy):\n    xy = sorted(xy)\n    x = [xy[i][0] - xy[0][0] for i in range(3)]\n    y = [xy[i][1] - xy[0][1] for i in range(3)]\n    return abs(x[1]*y[2] - x[2]*y[1]) / 2\n\ndef ccw(a, b, c):\n    ax = b[0] - a[0]\n    ay = b[1] - a[1]\n    bx = c[0] - a[0]\n    by = c[1] - a[1]\n    t = ax*by - ay*bx;\n    if t > 0:\n        return 1\n    if t < 0:\n        return -1\n    if ax*bx + ay*by < 0:\n        return 2\n    if ax*ax + ay*ay < bx*bx + by*by:\n        return -2\n    return 0\n\ndef convex_hull(ps):\n    n = len(ps)\n    k = 0\n    ps.sort()\n    ch = [None] * (n*2)\n    for i in range(n):\n        while k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n    t = k + 1\n    for i in range(n-2,-1,-1):\n        while k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0:\n            k -= 1\n        ch[k] = ps[i]\n        k += 1\n\n    return ch[:k-1]\n\ndef bs(f, mi, ma):\n    mm = -1\n    while ma > mi + eps:\n        mm = (ma+mi) / 2.0\n        if f(mm):\n            mi = mm + eps\n        else:\n            ma = mm\n    if f(mm):\n        return mm + eps\n    return mm\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    if delta == 0:\n        return None\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    n = I()\n    a = convex_hull([LI() for _ in range(n)])\n    n = len(a)\n    a = a + a + a\n    s = 0\n    for i in range(1,n-1):\n        s += area([a[0],a[i],a[i+1]])\n    def f(i, fk):\n        t = 0\n        tj = i + 1\n        ra = [a[i+1][j] - a[i][j] for j in range(2)]\n        ap = [a[i][j] + ra[j] * fk for j in range(2)]\n        for j in range(i+1, i+n):\n            u = area([ap, a[j], a[j+1]])\n            if t + u >= s / 2:\n                tj = j\n                break\n            t += u\n        ts = s / 2 - t\n        sa = [a[tj+1][j] - a[tj][j] for j in range(2)]\n        def _f(k):\n            b = [a[tj][j] + sa[j] * k for j in range(2)]\n            fs = area([a[i], a[tj], b])\n            return fs < ts\n        bk = bs(_f, 0, 1)\n        return [ap, [a[tj][j] + sa[j] * bk for j in range(2)]]\n\n    ls = [f(i//5, random.random()) for i in range(n*5)]\n    ll = len(ls)\n    kts = []\n    sx = 0\n    sy = 0\n    for i in range(ll):\n        for j in range(i+1,ll):\n            t = intersection(ls[i][0], ls[i][1], ls[j][0], ls[j][1])\n            if t is None:\n                return 'NA'\n            kts.append(t)\n            sx += t[0]\n            sy += t[1]\n    mx = sx / len(kts)\n    my = sy / len(kts)\n    keps = 1.0 / 10**5\n    for i in range(len(kts)):\n        if abs(mx-t[0]) > keps or abs(my-t[1]) > keps:\n            return 'NA'\n    return '{:.9f} {:.9f}'.format(mx, my)\n\n\n\nprint(main())\n\n"
  }
]