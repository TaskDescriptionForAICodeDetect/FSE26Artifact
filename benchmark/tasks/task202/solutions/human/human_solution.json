[
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\nstruct point {\n\tint x, y, z;\n\texplicit point(int x_ = 0, int y_ = 0, int z_ = 0):x(x_), y(y_), z(z_) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y, z + p.z);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y, z - p.z);\n\t}\n\n\tpoint operator-() const {\n\t\treturn point(-x, -y, -z);\n\t}\n\n\tbool operator<(const point &p) const {\n\t\tif(x != p.x) return x < p.x;\n\t\tif(y != p.y) return y < p.y;\n\t\treturn z < p.z;\n\t}\n\n\tbool operator==(const point &p) const {\n\t\treturn x == p.x && y == p.y && z == p.z;\n\t}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_) {\n\t\tif(b < a) swap(a, b);\n\t}\n\n\tbool operator<(const segment &s) const {\n\t\tif(!(a == s.a)) return a < s.a;\n\t\treturn b < s.b;\n\t}\n\n\tbool operator==(const segment&s) const {\n\t\treturn a == s.a && b == s.b;\n\t}\n};\n\npoint rotate_x(const point &p) {\n\treturn point(p.x, p.z, -p.y);\n}\n\npoint rotate_y(const point &p) {\n\treturn point(p.z, p.y, -p.x);\n}\n\npoint rotate_z(const point &p) {\n\treturn point(p.y, -p.x, p.z);\n}\n\nbool input(set<segment> &segs) {\n\tint n;\n\tcin >> n;\n\n\tif(n == 0) return false;\n\tsegs.clear();\n\n\tpoint move_d[128];\n\tmove_d['x'] = point(1, 0, 0);\n\tmove_d['y'] = point(0, 1, 0);\n\tmove_d['z'] = point(0, 0, 1);\n\n\tpoint current(0, 0, 0);\n\tmap<int, point> label;\n\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tif(isdigit(s[0])) { // label\n\t\t\tconst int idx = stoi(s);\n\t\t\tif(!label.count(idx)) {\n\t\t\t\tlabel[idx] = current;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = label[idx];\n\t\t\t}\n\t\t}\n\t\telse { // move\n\t\t\tpoint d = move_d[s[1]];\n\t\t\tif(s[0] == '-') d = -d;\n\t\t\tconst point next = current + d;\n\t\t\tsegs.insert(segment(current, next));\n\t\t\tcurrent = move(next);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool match(const set<segment> &a, const set<segment> &b) {\n\tif(a.size() != b.size()) return false;\n\tauto it_a = a.cbegin();\n\tauto it_b = b.cbegin();\n\n\tconst point offset = a.cbegin()->a - b.cbegin()->a;\n\n\twhile(it_a != a.end()) {\n\t\tconst segment &s_a = *it_a;\n\t\tconst segment s_b(it_b->a + offset, it_b->b + offset);\n\t\tif(!(s_a == s_b)) return false;\n\n\t\t++it_a;\n\t\t++it_b;\n\t}\n\n\treturn true;\n\n}\n\nset<segment> rotate_points(const set<segment> &segs, const function<point(const point&)> &convert) {\n\tset<segment> res;\n\tfor(const auto &seg : segs) {\n\t\tres.insert(segment(convert(seg.a), convert(seg.b)));\n\t}\n\treturn res;\n}\n\nbool valid(const set<segment> &a, set<segment> b) {\n\trep(loop_x, 4) {\n\t\tb = rotate_points(b, rotate_x);\n\t\trep(loop_y, 4) {\n\t\t\tb = rotate_points(b, rotate_y);\n\t\t\trep(loop_z, 4) {\n\t\t\t\tb = rotate_points(b, rotate_z);\n\t\t\t\tif(match(a, b)) return true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tset<segment> a, b;\n\twhile(input(a)) {\n\t\tassert(input(b));\n\t\tcout << (valid(a, b) ? \"SAME\" : \"DIFFERENT\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nostream &operator << (ostream &os, const point &t){\n\tos << '(' << t.x << ',' << t.y << ',' << t.z << ')';\n\treturn os;\n}\n\nstruct strange_key{\n\tvector<point> vp;\n\tset<point> sp;\n\tvoid rot90arndX(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tz = vp[i].z;\n\t\t\tvp[i].z = -vp[i].y;\n\t\t\tvp[i].y = tz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tz = vp[i].z;\n\t\t\tvp[i].z = vp[i].x;\n\t\t\tvp[i].x = -tz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tx = vp[i].x;\n\t\t\tvp[i].x = vp[i].y;\n\t\t\tvp[i].y = -tx;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid MoveToOrigin(int base){\n\t\tint dx = vp[ base ].x;\n\t\tint dy = vp[ base ].y;\n\t\tint dz = vp[ base ].z;\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].x -= dx;\n\t\t\tvp[i].y -= dy;\n\t\t\tvp[i].z -= dz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\tfor(unsigned int l = 0; l < vp.size(); ++l){\n\t\t\t\t\t\tthis->MoveToOrigin( l );\n\t\t\t\t\t\tfor(unsigned int m = 0; m < vp.size(); ++m){\n\t\t\t\t\t\t\tbool bSame = true;\n\t\t\t\t\t\t\tt.MoveToOrigin( m );\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tcout << \"Key Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = sp.begin(); it != sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\nKey Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = t.sp.begin(); it != t.sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\n--------------------\\n\";\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tfor(unsigned int n = 0; n < vp.size() && bSame; ++n){\n\t\t\t\t\t\t\t\tif( t.sp.find( vp[n] ) == t.sp.end() ){\n\t\t\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( bSame )\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt.rot90arndX();\n\t\t\t\t}\n\t\t\t\tt.rot90arndY();\n\t\t\t}\n\t\t\tt.rot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\tval[0]=true;\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nostream &operator << (ostream &os, const strange_key &t){\n\tos << \"Key Expression:\\n\";\n\tfor(unsigned int i = 0; i < t.vp.size(); ++i){\n\t\tif( i != 0 )\n\t\t\tos << ' ';\n\t\tos << t.vp[i];\n\t}\n\treturn os;\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef tuple<int, int, int> Point3D;\n\nPoint3D operator-(const Point3D &p1, const Point3D &p2){\n  return make_tuple(get<0>(p1) - get<0>(p2),\n                    get<1>(p1) - get<1>(p2),\n                    get<2>(p1) - get<2>(p2));\n}\n\nPoint3D operator+(const Point3D &p1, const Point3D &p2){\n  return make_tuple(get<0>(p1) + get<0>(p2),\n                    get<1>(p1) + get<1>(p2),\n                    get<2>(p1) + get<2>(p2));\n}\n\nstruct Key {\n  map<int, Point3D> P;\n  map<Point3D, int> I;\n  map<int, vector<int> > E; \n  \n  void load(int n){\n    map<string, Point3D> L;\n    string s;\n    int x = 0, y = 0, z = 0, nx, ny, nz;\n    \n    P[0] = make_tuple(0, 0, 0);\n    I[make_tuple(0, 0, 0)] = 0;\n    \n    while (n--){\n      cin >> s;\n      tie(nx, ny, nz) = make_tuple(x, y, z);\n      if (s.back() == 'x'){\n        nx = (s[0] == '-' ? x - 1 : x + 1);\n      } else if (s.back() == 'y'){\n        ny = (s[0] == '-' ? y - 1 : y + 1);\n      } else if (s.back() == 'z'){\n        nz = (s[0] == '-' ? z - 1 : z + 1);\n      } else {\n        if (L.count(s) == 0) L[s] = make_tuple(x, y, z);\n        else tie(x, y, z) = L[s];\n        continue;\n      }\n\n      if (I.count(make_tuple(nx, ny, nz)) == 0){\n        int id = I.size();\n        I[make_tuple(nx, ny, nz)] = id;\n        P[id] = make_tuple(nx, ny, nz);\n      }\n\n      int u = I[make_tuple(x, y, z)];\n      int v = I[make_tuple(nx, ny, nz)];\n      E[u].push_back(v);\n      E[v].push_back(u);\n      tie(x, y, z) = make_tuple(nx, ny, nz);\n    }\n  }\n\n  void rotate_x(){\n    map<Point3D, int> NI;\n    for (auto &p : P){\n      int x, y, z;\n      tie(x, y, z) = p.second;\n      p.second = make_tuple(x, -z, y);\n      NI[p.second] = p.first;\n    }\n    I = NI;\n  };\n  void rotate_y(){\n    map<Point3D, int> NI;\n    for (auto &p : P){\n      int x, y, z;\n      tie(x, y, z) = p.second;\n      p.second = make_tuple(-z, y, x);\n      NI[p.second] = p.first;\n    }\n    I = NI;\n  };\n  \n  void rotate_z(){\n    map<Point3D, int> NI;\n    for (auto &p : P){\n      int x, y, z;\n      tie(x, y, z) = p.second;\n      p.second = make_tuple(-y, x, z);\n      NI[p.second] = p.first;\n    }\n    I = NI;\n  }\n};\n\n\nbool check(Key key1, Key key2){\n  auto P1 = key1.P;\n  auto P2 = key2.P;\n  if (P1.size() != P2.size()) return false;\n\n  int n = P1.size();\n  REP(i, n){\n    Point3D d = P2[i] - P1[0];\n    \n    bool ok = true;\n    REP(j, n){\n      if (key2.I.count(P1[j] + d) == 0) ok = false;\n      if (key1.I.count(P2[j] - d) == 0) ok = false;\n    }\n\n    if (ok){\n      REP(j, n) if (ok){\n        for (int k : key1.E[j]){\n          int nj = key2.I[P1[j] + d];\n          int nk = key2.I[P1[k] + d];\n          if (find(ALL(key2.E[nj]), nk) == key2.E[nj].end()) ok = false;\n        }\n      }\n      REP(j, n) if (ok){\n        for (int k : key2.E[j]){\n          int nj = key1.I[P2[j] - d];\n          int nk = key1.I[P2[k] - d];\n          if (find(ALL(key1.E[nj]), nk) == key1.E[nj].end()) ok = false;\n        }\n      }\n    }\n    if (ok) return true;\n  }\n  return false;\n}\n\nbool same(Key key1, Key key2){\n  REP(z_, 4){\n    REP(y_, 4){\n      REP(x_, 4){\n        if (check(key1, key2)) return true;\n        key1.rotate_x();\n      }\n      key1.rotate_y();\n    }\n    key1.rotate_z();\n  }\n  return false;\n}\n  \n\nint main(int argc, char *argv[])\n{\n  int n;\n  while (cin >> n && n){\n    Key key1;\n    Key key2;\n    key1.load(n);\n    cin >> n;\n    key2.load(n);\n    cout << (same(key1, key2) ? \"SAME\" : \"DIFFERENT\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\n#define INF 1001\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tpoint(int x, int y, int z):x(x),y(y),z(z){}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid set(int x, int y, int z){\n\t\tthis->x = x; this->y = y; this->z = z;\n\t}\n};\n\nostream &operator << (ostream &os, const point &t){\n\tos << '(' << t.x << ',' << t.y << ',' << t.z << ')';\n\treturn os;\n}\n\nstruct strange_key{\n\tvector<point> vp;\n\tset<point> sp;\n\tvector<point> vcube;\n\tint areaXY, areaYZ, areaXZ;\n\t\n\tvoid rot90arndX(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tz = vp[i].z;\n\t\t\tvp[i].z = -vp[i].y;\n\t\t\tvp[i].y = tz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tz = vp[i].z;\n\t\t\tvp[i].z = vp[i].x;\n\t\t\tvp[i].x = -tz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tint tx = vp[i].x;\n\t\t\tvp[i].x = vp[i].y;\n\t\t\tvp[i].y = -tx;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid MoveToOrigin(int base){\n\t\tint dx = vp[ base ].x;\n\t\tint dy = vp[ base ].y;\n\t\tint dz = vp[ base ].z;\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].x -= dx;\n\t\t\tvp[i].y -= dy;\n\t\t\tvp[i].z -= dz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid CalcArea(){\n\t\tint minx = INF, miny = INF, minz = INF;\n\t\tint maxx = -INF, maxy = -INF, maxz = -INF;\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tminx = std::min( minx, vcube[i].x ); maxx = std::max( maxx, vcube[i].x );\n\t\t\tminy = std::min( miny, vcube[i].y ); maxy = std::max( maxy, vcube[i].y );\n\t\t\tminz = std::min( minz, vcube[i].z ); maxz = std::max( maxz, vcube[i].z );\t\t\n\t\t}\n\t\tareaYZ = ( maxy - miny ) * ( maxz - minz );\n\t\tareaXY = ( maxx - minx ) * ( maxy - miny );\n\t\tareaXZ = ( maxx - minx ) * ( maxz - minz );\n\t}\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\t/*\n\t\tcout << \" AREA XY: \" << areaXY << \" AREA TXY: \" << t.areaXY << endl;\n\t\tcout << \" AREA XZ: \" << areaXZ << \" AREA TXZ: \" << t.areaXZ << endl;\n\t\tcout << \" AREA YZ: \" << areaYZ << \" AREA TYZ: \" << t.areaYZ << endl;\n\t\t*/\n\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\tt.rot90arndZ();\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tCalcArea(); t.CalcArea();\n\t\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\t\tt.rot90arndY();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\tCalcArea(); t.CalcArea();\n\t\t\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\t\t\tt.rot90arndX();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unsigned int l = 0; l < vp.size(); ++l){\n\t\t\t\t\t\tthis->MoveToOrigin( l );\n\t\t\t\t\t\tfor(unsigned int m = 0; m < vp.size(); ++m){\n\t\t\t\t\t\t\tbool bSame = true;\n\t\t\t\t\t\t\tt.MoveToOrigin( m );\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tcout << \"Key Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = sp.begin(); it != sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\nKey Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = t.sp.begin(); it != t.sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\n--------------------\\n\";\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(unsigned int n = 0; n < vp.size() && bSame; ++n){\n\t\t\t\t\t\t\t\tif( t.sp.find( vp[n] ) == t.sp.end() ){\n\t\t\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( bSame )\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt.rot90arndX();\n\t\t\t\t}\n\t\t\t\tt.rot90arndY();\n\t\t\t}\n\t\t\tt.rot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\tint minx=0, maxx=0, miny=0, maxy=0, minz=0, maxz=0;\n\t\t\n\t\tval[0]=true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.vcube.push_back( point( minx, miny, minz ) );\n\t\tin.vcube.push_back( point( minx, miny, maxz ) );\n\t\tin.vcube.push_back( point( minx, maxy, minz ) );\n\t\tin.vcube.push_back( point( minx, maxy, maxz ) );\n\t\tin.vcube.push_back( point( maxx, miny, minz ) );\n\t\tin.vcube.push_back( point( maxx, miny, maxz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, minz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, maxz ) );\n\t}\n}\n\n\nostream &operator << (ostream &os, const strange_key &t){\n\tos << \"Key Expression:\\n\";\n\tfor(unsigned int i = 0; i < t.vp.size(); ++i){\n\t\tif( i != 0 )\n\t\t\tos << ' ';\n\t\tos << t.vp[i];\n\t}\n\treturn os;\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <utility>\nusing namespace std;\n\nstruct Point{\n    int x,y,z;\n    Point(int x, int y, int z):x(x), y(y), z(z){}\n    Point(){}\n    Point &operator +=(const Point &a){ x+=a.x; y+=a.y; z+=a.z; return *this; }\n    Point &operator -=(const Point &a){ x-=a.x; y-=a.y; z-=a.z; return *this; }\n    Point operator +(const Point &a) const{ return Point(x+a.x, y+a.y, z+a.z); }\n    Point operator -(const Point &a) const{ return Point(x-a.x, y-a.y, z-a.z); }\n    Point operator -() { return Point(-x, -y, -z); }\n    bool operator < (const Point &a) const{\n        return (x!=a.x)? x<a.x: (y!=a.y)? y<a.y: z<a.z;\n    }\n    bool operator == (const Point &a) const{\n        return x==a.x && y==a.y && z==a.z;\n    }\n};\n\ntemplate<typename T>\nvoid pair_recsort(vector<pair<T, T> > &vec){\n    for(pair<T, T> &e: vec){\n        if(e.second < e.first){\n            swap(e.first, e.second);\n        }\n    }\n    sort(vec.begin(), vec.end());\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<vector<pair<Point, Point> > > key(2);\n        for(int d=0; d<2; d++){\n            int size;\n            if(d == 0) size = n;\n            else cin >> size;\n            map<int, Point> itop;\n            Point pos(0, 0, 0);\n            for(int i=0; i<size; i++){\n                string s;\n                cin >> s;\n                if('0' <= s[0] && s[0] <= '9'){\n                    int idx = stoi(s);\n                    if(itop.count(idx) == 0){\n                        itop[idx] = pos;\n                    }else{\n                        pos = itop[idx];\n                    }\n                }else{\n                    Point next = pos;\n                    int sign = (s[0]=='+')? 1: -1;\n                    if(s[1] == 'x') next.x += sign;\n                    if(s[1] == 'y') next.y += sign;\n                    if(s[1] == 'z') next.z += sign;\n                    key[d].push_back(make_pair(pos, next));\n                    pos = next;\n                }\n            }\n            pair_recsort(key[d]);\n        }\n        \n        bool same = false;\n        for(int axisswap=0; axisswap<3; axisswap++){\n            for(auto &p: key[0]){\n                swap(p.first.x, p.first.y);\n                swap(p.first.y, p.first.z);\n                swap(p.second.x, p.second.y);\n                swap(p.second.y, p.second.z);\n            }\n            for(int zturn=0; zturn<2; zturn++){\n                for(auto &p: key[0]){\n                    p.first.y = -p.first.y;\n                    p.first.z = -p.first.z;\n                    p.second.y = -p.second.y;\n                    p.second.z = -p.second.z;\n                }\n                for(int zrotate=0; zrotate<4; zrotate++){\n                    for(auto &p: key[0]){\n                        Point newp;\n                        newp.x = -p.first.y;\n                        newp.y = p.first.x;\n                        newp.z = p.first.z;\n                        p.first = newp;\n                        newp.x = -p.second.y;\n                        newp.y = p.second.x;\n                        newp.z = p.second.z;\n                        p.second = newp;\n                    }\n\n                    pair_recsort(key[0]);\n                    Point diff = key[1][0].first -key[0][0].first;\n                    for(auto &p: key[0]){\n                        p.first += diff;\n                        p.second += diff;\n                    }\n                    if(key[0] == key[1]){\n                        same = true;\n                    }\n                }\n            }\n        }\n\n        if(same){\n            cout << \"SAME\" << endl;\n        }else{\n            cout << \"DIFFERENT\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define op operator\n#define pb push_back\n\nstruct poi {\n\tint x, y, z;\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y, z - p.z};\n\t}\n\tpoi op +(poi p) {\n\t\treturn {x + p.x, y + p.y, z + p.z};\n\t}\n\tbool op <(poi p) const {\n\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z);\n\t}\n\tvector <poi> rot() {\n\t\tint a[3] = {x, y, z};\n\t\tvector <poi> v;\n\t\tint p[3] = {0, 1, 2};\n\t\tdo {\n\t\t\tint inv = (p[0] > p[1]) + (p[0] > p[2]) + (p[1] > p[2]);\n\t\t\tint x = a[p[0]], y = a[p[1]], z = a[p[2]];\n\t\t\tif(inv & 1) {\n\t\t\t\tv.pb({-x, y, z});\n\t\t\t\tv.pb({x, -y, z});\n\t\t\t\tv.pb({x, y, -z});\n\t\t\t\tv.pb({-x, -y, -z});\n\t\t\t} else {\n\t\t\t\tv.pb({x, y, z});\n\t\t\t\tv.pb({x, -y, -z});\n\t\t\t\tv.pb({-x, y, -z});\n\t\t\t\tv.pb({-x, -y, z});\n\t\t\t}\n\t\t}while(next_permutation(p, p + 3));\n\t\treturn v;\n\t}\n};\n\nconst int N = 1001;\nbool v[N];\npoi save[N];\nvector <pair <poi, poi>> segs[2];\n\nvector <pair <poi, poi>> read(int n) {\n\tpoi p = {0, 0, 0};\n\tmemset(v, 0, sizeof v);\n\tvector <pair <poi, poi>> r;\n\tfor(int i = 0; i < n; i ++) {\n\t\tstring s; cin >> s;\n\t\tif(s[0] == '+' || s[0] == '-') {\n\t\t\tpoi q;\n\t\t\tif(s[1] == 'x')\n\t\t\t\tq = {1, 0, 0};\n\t\t\telse if(s[1] == 'y')\n\t\t\t\tq = {0, 1, 0};\n\t\t\telse\n\t\t\t\tq = {0, 0, 1};\n\t\t\tif(s[0] == '+')\n\t\t\t\tq = p + q;\n\t\t\telse\n\t\t\t\tq = p - q;\n\t\t\tr.pb({p, q});\n\t\t\tp = q;\n\t\t} else {\n\t\t\tint x = stoi(s);\n\t\t\tif(v[x])\n\t\t\t\tp = save[x];\n\t\t\telse {\n\t\t\t\tv[x] = 1;\n\t\t\t\tsave[x] = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nset <poi> st;\nbool check(poi p) {\n\tbool v[24];\n\tmemset(v, true, sizeof v);\n\tfor(auto seg : segs[1]) {\n\t\tauto a = (seg.first - p).rot();\n\t\tauto b = (seg.second - p).rot();\n\t\tfor(int i = 0; i < 24; i ++) {\n\t\t\tif(!st.count(a[i] + b[i]))\n\t\t\t\tv[i] = false;\n\t\t}\n\t}\n\treturn count(v, v + 24, true);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint n, m;\n\twhile(cin >> n) {\n\t\tif(n == 0) break;\n\t\tsegs[0] = read(n);\n\t\tcin >> m;\n\t\tsegs[1] = read(m);\n\n\t\tst.clear();\n\t\tfor(auto seg : segs[0]) {\n\t\t\tpoi p = seg.first - segs[0][0].first;\n\t\t\tpoi q = seg.second - segs[0][0].first;\n\t\t\tst.insert(p + q);\n\t\t}\n\n\t\tbool f = false;\n\t\tfor(auto seg : segs[1])\n\t\t\tf |= check(seg.first) || check(seg.second);\n\t\tcout << (f ? \"SAME\" : \"DIFFERENT\") << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct P {\n  int x, y, z;\n  P() : x(0), y(0), z(0) {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P &p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P &p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator + (const P &p) const {\n    return P(x+p.x, y+p.y, z+p.z);\n  }\n  P& operator += (const P &p) {\n    return ( *this = *this + p );\n  }\n  P operator - (const P &p) const {\n    return P(x-p.x, y-p.y, z-p.z);\n  }\n  P& operator -= (const P &p) {\n    return ( *this = *this - p );\n  }\n};\n\ntypedef pair<P,P> Seg;\ntypedef vector<Seg> Key;\n\nconst int INF = 1<<28;\n\nvoid rotate(int &x, int &y) {\n  int t = x;\n  x = -y;\n  y = t;\n}\n\nKey rotate(Key k, int dir) {\n  int n = k.size();\n  for(int i = 0; i < n; ++i) {\n    pair<int,int> p;\n    if(dir == 0) {\n      rotate(k[i].first.x, k[i].first.y);\n      rotate(k[i].second.x, k[i].second.y);\n    } else if(dir == 1) {\n      rotate(k[i].first.y, k[i].first.z);\n      rotate(k[i].second.y, k[i].second.z);\n    } else if(dir == 2) {\n      rotate(k[i].first.z, k[i].first.x);\n      rotate(k[i].second.z, k[i].second.x);\n    }\n  }\n  return k;\n}\n\nKey normalize(Key k) {\n  int n = k.size();\n  for(int i = 0; i < n; ++i) {\n    if(k[i].second < k[i].first) swap(k[i].first, k[i].second);\n  }\n  P mini(INF,INF,INF);\n  for(int i = 0; i < n; ++i) {\n    mini.x = min(mini.x, min(k[i].first.x, k[i].second.x));\n    mini.y = min(mini.y, min(k[i].first.y, k[i].second.y));\n    mini.z = min(mini.z, min(k[i].first.z, k[i].second.z));\n  }\n  for(int i = 0; i < n; ++i) {\n    k[i].first -= mini;\n    k[i].second -= mini;\n  }\n  sort(k.begin(), k.end());\n  return k;\n}\n\nKey getKey() {\n  int q;\n  cin >> q;\n  if(!q) return Key();\n  Key k;\n  P p(0,0,0);\n  P label[100];\n  fill(label, label+100, P(INF,INF,INF));\n  while(q--) {\n    string s;\n    cin >> s;\n    P pre = p;\n    if(0) {\n    } else if(s == \"+x\") {\n      ++p.x;\n    } else if(s == \"-x\") {\n      --p.x;\n    } else if(s == \"+y\") {\n      ++p.y;\n    } else if(s == \"-y\") {\n      --p.y;\n    } else if(s == \"+z\") {\n      ++p.z;\n    } else if(s == \"-z\") {\n      --p.z;\n    } else {\n      int id = atoi(s.c_str());\n      if(label[id].x == INF) {\n        label[id] = p;\n      } else {\n        p = label[id];\n      }\n      pre.x = INF;\n    }\n    if(pre.x != INF) {\n      k.push_back(Seg(pre,p));\n    }\n  }\n  return k;\n}\n\nbool equals(Key a, Key b) {\n  a = normalize(a);\n  for(int i = 0; i < 6; ++i) {\n    for(int j = 0; j < 4; ++j) {\n      b = normalize(b);\n      if(a == b) return true;\n      b = rotate(b, 0);\n    }\n    if(i < 3) {\n      b = rotate(b, 1);\n    } else if(i == 3) {\n      b = rotate(b, 2);\n    } else if(i == 4) {\n      b = rotate(b, 2);\n      b = rotate(b, 2);\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(1) {\n    Key a = getKey();\n    if(!a.size()) break;\n    Key b = getKey();\n    /*\n    cout << \"A\" << endl;\n    for(int i = 0; i < a.size(); ++i) {\n      cout << \"(\" << a[i].first.x << \",\" << a[i].first.y << \",\" << a[i].first.z << \"),\";\n      cout << \"(\" << a[i].second.x << \",\" << a[i].second.y << \",\" << a[i].second.z << \")\" << endl;\n    }\n    cout << \"B\" << endl;\n    for(int i = 0; i < b.size(); ++i) {\n      cout << \"(\" << b[i].first.x << \",\" << b[i].first.y << \",\" << b[i].first.z << \"),\";\n      cout << \"(\" << b[i].second.x << \",\" << b[i].second.y << \",\" << b[i].second.z << \")\" << endl;\n    }\n    */\n    if(equals(a,b)) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct P{\n  int x, y, z;\n  P() : x(0), y(0), z(0) {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P& p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator - (const P& p) const {\n    return P(x - p.x, y - p.y, z - p.z);\n  }\n};\ntypedef pair<P, P> L;\nvector<L> input(){\n  int N; cin >> N;\n  P label[100] = {};\n  bool used[100] = {};\n  P cur;\n  vector<L> res;\n  while(N--){\n    string s;\n    cin >> s;\n    if(isdigit(s[0])){\n      int l = atoi(s.c_str());\n      if(used[l]){\n        cur = label[l];\n      }else{\n        label[l] = cur;\n        used[l] = true;\n      }\n    }else{\n      int dif = (s[0] == '+' ? 1 : -1);\n      P next = cur;\n      if(s[1] == 'x'){\n        next.x += dif;\n      }else if(s[1] == 'y'){\n        next.y += dif;\n      }else if(s[1] == 'z'){\n        next.z += dif;\n      }else{\n        assert(false);\n      }\n      res.push_back(L(cur, next));\n      cur = next;\n    }\n  }\n  return res;\n}\nvoid update(P& p, P q){\n  p.x = min(p.x, q.x);\n  p.y = min(p.y, q.y);\n  p.z = min(p.z, q.z);\n}\nvector<L> normalize(const vector<L>& s){\n  P min_p = s[0].first;\n  REP(i, s.size()){\n    update(min_p, s[i].first);\n    update(min_p, s[i].second);\n  }\n  vector<L> res;\n  REP(i, s.size()){\n    res.push_back(L(s[i].first - min_p, s[i].second - min_p));\n    if(res[i].second < res[i].first) swap(res[i].first, res[i].second);\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\nvoid rotate_x(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.x, -s[i].first.z, s[i].first.y);\n    s[i].second = P(s[i].second.x, -s[i].second.z, s[i].second.y);\n  }\n}\nvoid rotate_y(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.z, s[i].first.y, -s[i].first.x);\n    s[i].second = P(s[i].second.z, s[i].second.y, -s[i].second.x);\n  }\n}\nvoid rotate_z(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(-s[i].first.y, s[i].first.x, s[i].first.z);\n    s[i].second = P(-s[i].second.y, s[i].second.x, s[i].second.z);\n  }\n}\nint main(){\n  while(true){\n    vector<L> k1 = input();\n    if(k1.empty()) break;\n    vector<L> k2 = input();\n    k2 = normalize(k2);\n\n    bool is_equal = false;\n    for(int i = 0; i < 4; i++){\n      rotate_z(k1);\n      for(int k = 0; k < 6; k++){\n        if(k % 2 == 0) rotate_x(k1);\n        else rotate_y(k1);\n        k1 = normalize(k1);\n        if(k1 == k2){\n          is_equal = true;\n          goto OUTPUT;\n        }\n      }\n    }\n\nOUTPUT:\n    if(is_equal) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct P{\n  int x, y, z;\n  P() : x(0), y(0), z(0) {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P& p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator - (const P& p) const {\n    return P(x - p.x, y - p.y, z - p.z);\n  }\n};\ntypedef pair<P, P> L;\nvector<L> input(){\n  int N; cin >> N;\n  P label[100] = {};\n  bool used[100] = {};\n  P cur;\n  vector<L> res;\n  while(N--){\n    string s;\n    cin >> s;\n    if(isdigit(s[0])){\n      int l = atoi(s.c_str());\n      if(used[l]){\n        cur = label[l];\n      }else{\n        label[l] = cur;\n        used[l] = true;\n      }\n    }else{\n      int dif = (s[0] == '+' ? 1 : -1);\n      P next = cur;\n      if(s[1] == 'x'){\n        next.x += dif;\n      }else if(s[1] == 'y'){\n        next.y += dif;\n      }else if(s[1] == 'z'){\n        next.z += dif;\n      }else{\n        assert(false);\n      }\n      res.push_back(L(cur, next));\n      cur = next;\n    }\n  }\n  return res;\n}\nvoid update(P& p, P q){\n  p.x = min(p.x, q.x);\n  p.y = min(p.y, q.y);\n  p.z = min(p.z, q.z);\n}\nvector<L> normalize(const vector<L>& s){\n  P min_p = s[0].first;\n  REP(i, s.size()){\n    update(min_p, s[i].first);\n    update(min_p, s[i].second);\n  }\n  vector<L> res;\n  REP(i, s.size()){\n    res.push_back(L(s[i].first - min_p, s[i].second - min_p));\n    if(res[i].second < res[i].first) swap(res[i].first, res[i].second);\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\nvoid rotate_x(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.x, -s[i].first.z, s[i].first.y);\n    s[i].second = P(s[i].second.x, -s[i].second.z, s[i].second.y);\n  }\n}\nvoid rotate_y(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.z, s[i].first.y, -s[i].first.x);\n    s[i].second = P(s[i].second.z, s[i].second.y, -s[i].second.x);\n  }\n}\nvoid rotate_z(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(-s[i].first.y, s[i].first.x, s[i].first.z);\n    s[i].second = P(-s[i].second.y, s[i].second.x, s[i].second.z);\n  }\n}\nint main(){\n  while(true){\n    vector<L> k1 = input();\n    if(k1.empty()) break;\n    vector<L> k2 = input();\n    k2 = normalize(k2);\n    vector<L> tmp = k1;\n    tmp = normalize(tmp);\n\n    bool is_equal = false;\n    for(int i = 0; i < 4; i++){\n      rotate_z(k1);\n      for(int k = 0; k < 6; k++){\n        if(k % 2 == 0) rotate_x(k1);\n        else rotate_y(k1);\n        k1 = normalize(k1);\n        if(k1 == k2){\n          is_equal = true;\n          //goto OUTPUT;\n        }\n      }\n    }\n\nOUTPUT:\n    assert(tmp == k1);\n    if(is_equal) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct P{\n  int x, y, z;\n  P() : x(0), y(0), z(0) {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P& p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator - (const P& p) const {\n    return P(x - p.x, y - p.y, z - p.z);\n  }\n};\ntypedef pair<P, P> L;\nvector<L> input(){\n  int N; cin >> N;\n  P label[100] = {};\n  bool used[100] = {};\n  P cur;\n  vector<L> res;\n  while(N--){\n    string s;\n    cin >> s;\n    if(isdigit(s[0])){\n      int l = atoi(s.c_str());\n      if(used[l]){\n        cur = label[l];\n      }else{\n        label[l] = cur;\n        used[l] = true;\n      }\n    }else{\n      int dif = (s[0] == '+' ? 1 : -1);\n      P next = cur;\n      if(s[1] == 'x'){\n        next.x += dif;\n      }else if(s[1] == 'y'){\n        next.y += dif;\n      }else if(s[1] == 'z'){\n        next.z += dif;\n      }else{\n        assert(false);\n      }\n      res.push_back(L(cur, next));\n      cur = next;\n    }\n  }\n  return res;\n}\nvoid update(P& p, P q){\n  p.x = min(p.x, q.x);\n  p.y = min(p.y, q.y);\n  p.z = min(p.z, q.z);\n}\nvector<L> normalize(const vector<L>& s){\n  P min_p = s[0].first;\n  REP(i, s.size()){\n    update(min_p, s[i].first);\n    update(min_p, s[i].second);\n  }\n  vector<L> res;\n  REP(i, s.size()){\n    res.push_back(L(s[i].first - min_p, s[i].second - min_p));\n    if(res[i].second < res[i].first) swap(res[i].first, res[i].second);\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\nvoid rotate_x(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.x, -s[i].first.z, s[i].first.y);\n    s[i].second = P(s[i].second.x, -s[i].second.z, s[i].second.y);\n  }\n}\nvoid rotate_y(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.z, s[i].first.y, -s[i].first.x);\n    s[i].second = P(s[i].second.z, s[i].second.y, -s[i].second.x);\n  }\n}\nvoid rotate_z(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(-s[i].first.y, s[i].first.x, s[i].first.z);\n    s[i].second = P(-s[i].second.y, s[i].second.x, s[i].second.z);\n  }\n}\nint main(){\n  while(true){\n    vector<L> k1 = input();\n    if(k1.empty()) break;\n    vector<L> k2 = input();\n    k2 = normalize(k2);\n\n    bool is_equal = false;\n    for(int k = 0; k < 6; k++){\n      if(k % 2 == 0) rotate_x(k1);\n      else rotate_y(k1);\n      for(int i = 0; i < 4; i++){\n        rotate_z(k1);\n        k1 = normalize(k1);\n        if(k1 == k2){\n          is_equal = true;\n          //goto OUTPUT;\n        }\n      }\n    }\n\nOUTPUT:\n    if(is_equal) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y,z+a.z}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y,z-a.z}; }\n\tbool operator==(const point &a)const{ return x==a.x && y==a.y && z==a.z; }\n};\n\nstruct edge{\n\tpoint u,v;\n\tbool operator==(const edge &e)const{ return u==e.u && v==e.v || u==e.v && v==e.u; }\n};\n\nstruct key{\n\tint n;\n\tedge E[300];\n};\n\nkey getkey(){\n\tkey K={};\n\tpoint p={0,0,0};\n\tmap<int,point> f;\n\tint n; scanf(\"%d\",&n);\n\twhile(n--){\n\t\tchar s[8]; scanf(\"%s\",s);\n\n\t\tif(isdigit(s[0])){\n\t\t\tint a; sscanf(s,\"%d\",&a);\n\t\t\tif(f.count(a)) p=f[a];\n\t\t\telse           f[a]=p;\n\t\t}\n\t\telse{\n\t\t\tpoint q=p;\n\t\t\tif(s[0]=='+' && s[1]=='x') q.x++;\n\t\t\tif(s[0]=='-' && s[1]=='x') q.x--;\n\t\t\tif(s[0]=='+' && s[1]=='y') q.y++;\n\t\t\tif(s[0]=='-' && s[1]=='y') q.y--;\n\t\t\tif(s[0]=='+' && s[1]=='z') q.z++;\n\t\t\tif(s[0]=='-' && s[1]=='z') q.z--;\n\t\t\tK.E[K.n++]=(edge){p,q};\n\t\t\tp=q;\n\t\t}\n\t}\n\n\treturn K;\n}\n\nstruct matrix{\n\tint a[3][3];\n\n\tpoint operator*(const point &p)const{\n\t\tint x=a[0][0]*p.x+a[0][1]*p.y+a[0][2]*p.z;\n\t\tint y=a[1][0]*p.x+a[1][1]*p.y+a[1][2]*p.z;\n\t\tint z=a[2][0]*p.x+a[2][1]*p.y+a[2][2]*p.z;\n\t\treturn (point){x,y,z};\n\t}\n\n\tmatrix operator*(const matrix &A)const{\n\t\tmatrix B={};\n\t\trep(i,3) rep(j,3) rep(k,3) B.a[i][j]+=a[i][k]*A.a[k][j];\n\t\treturn B;\n\t}\n\n\tbool operator==(const matrix &A)const{\n\t\trep(i,3) rep(j,3) if(a[i][j]!=A.a[i][j]) return false;\n\t\treturn true;\n\t}\n};\n\nvector<matrix> R;\n\nbool issame(const key &K1,const key &K2){\n\tif(K1.n!=K2.n) return false;\n\n\tpoint shift1=K1.E[0].u;\n\tpoint dir1=K1.E[0].v-shift1;\n\trep(i,K2.n){\n\t\tpoint shift2,dir2;\n\t\trep(t,2){\n\t\t\tif(t==0) shift2=K2.E[i].u, dir2=K2.E[i].v-shift2;\n\t\t\tif(t==1) shift2=K2.E[i].v, dir2=K2.E[i].u-shift2;\n\n\t\t\trep(j,R.size()) if(R[j]*dir1==dir2) {\n\t\t\t\tbool ok=true;\n\t\t\t\trep(k,K1.n){\n\t\t\t\t\tedge e=K1.E[k];\n\t\t\t\t\te=(edge){e.u-shift1,e.v-shift1};\n\t\t\t\t\te=(edge){R[j]*e.u,R[j]*e.v};\n\t\t\t\t\te=(edge){e.u+shift2,e.v+shift2};\n\t\t\t\t\tif(count(K2.E,K2.E+K2.n,e)!=1){ ok=false; break; }\n\t\t\t\t}\n\t\t\t\tif(ok) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tmatrix I,X,Y,Z;\n\tI.a[0][0]= 1; I.a[0][1]= 0; I.a[0][2]= 0;\n\tI.a[1][0]= 0; I.a[1][1]= 1; I.a[1][2]= 0;\n\tI.a[2][0]= 0; I.a[2][1]= 0; I.a[2][2]= 1;\n\tX.a[0][0]= 1; X.a[0][1]= 0; X.a[0][2]= 0;\n\tX.a[1][0]= 0; X.a[1][1]= 0; X.a[1][2]=-1;\n\tX.a[2][0]= 0; X.a[2][1]= 1; X.a[2][2]= 0;\n\tY.a[0][0]= 0; Y.a[0][1]= 0; Y.a[0][2]=-1;\n\tY.a[1][0]= 0; Y.a[1][1]= 1; Y.a[1][2]= 0;\n\tY.a[2][0]= 1; Y.a[2][1]= 0; Y.a[2][2]= 0;\n\tZ.a[0][0]= 0; Z.a[0][1]=-1; Z.a[0][2]= 0;\n\tZ.a[1][0]= 1; Z.a[1][1]= 0; Z.a[1][2]= 0;\n\tZ.a[2][0]= 0; Z.a[2][1]= 0; Z.a[2][2]= 1;\n\n\tR.push_back(I);\n\twhile(1){\n\t\tbool change=false;\n\t\trep(i,R.size()){\n\t\t\trep(j,3){\n\t\t\t\tmatrix A=(j==0?X*R[i]:j==1?Y*R[i]:Z*R[i]);\n\t\t\t\tif(count(R.begin(),R.end(),A)==0){ R.push_back(A); change=true; }\n\t\t\t}\n\t\t}\n\t\tif(!change) break;\n\t}\n\n\twhile(1){\n\t\tkey K1=getkey(); if(K1.n==0) break;\n\t\tkey K2=getkey();\n\n\t\tputs(issame(K1,K2)?\"SAME\":\"DIFFERENT\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\n#define INF 1001\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tpoint(int x, int y, int z):x(x),y(y),z(z){}\n\tbool operator ==(const point &t)const{\n\t\tif( x == t.x && y == t.y && z == t.z )\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid rot90arndX(){\n\t\tint tz = z; z = -y; y = tz;\n\t}\n\tvoid rot90arndY(){\n\t\tint tz = z; z = x; x = -tz;\n\t}\n\tvoid rot90arndZ(){\n\t\tint tx = x; x = y; y = -tx;\n\t}\n\tvoid set(int x, int y, int z){\n\t\tthis->x = x; this->y = y; this->z = z;\n\t}\n};\n\nostream &operator << (ostream &os, const point &t){\n\tos << '(' << t.x << ',' << t.y << ',' << t.z << ')';\n\treturn os;\n}\n\nstruct strange_key{\n\tvector<point> vp;\n\tvector<point> vcube;\n\n\tvoid rot90arndX(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndX();\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndX();\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndY();\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndY();\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndZ();\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndZ();\n\t\t}\n\t}\n\tvoid MoveToOrigin(int base){\n\t\tint dx = vcube[ base ].x;\n\t\tint dy = vcube[ base ].y;\n\t\tint dz = vcube[ base ].z;\n\t\t\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].x -= dx;\n\t\t\tvcube[i].y -= dy;\n\t\t\tvcube[i].z -= dz;\n\t\t}\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].x -= dx;\n\t\t\tvp[i].y -= dy;\n\t\t\tvp[i].z -= dz;\n\t\t}\n\t}\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\tfor(int a = 0; a < 4; ++a){\n\t\t\tfor(int b = 0; b < 4; ++b){\n\t\t\t\tfor(int c = 0; c < 4; ++c){\n\t\t\t\t\tfor(unsigned int l = 0; l < vcube.size(); ++l){\n\t\t\t\t\t\tthis->MoveToOrigin( l );\n\t\t\t\t\t\tfor(unsigned int m = 0; m < vcube.size(); ++m){\n\t\t\t\t\t\t\tbool bSame = true;\n\t\t\t\t\t\t\tt.MoveToOrigin( m );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsort( vp.begin(), vp.end() );\n\t\t\t\t\t\t\tsort( t.vp.begin(), t.vp.end() );\n\n\t\t\t\t\t\t\tfor(unsigned int n = 0; n < vp.size(); ++n){\n\t\t\t\t\t\t\t\tif( !(vp[n] == t.vp[n]) ){\n\t\t\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tcout << \"Key Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = sp.begin(); it != sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\nKey Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = t.sp.begin(); it != t.sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\n--------------------\\n\";\n\t\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\tif( bSame )\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trot90arndX();\n\t\t\t\t}\n\t\t\t\trot90arndY();\n\t\t\t}\n\t\t\trot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\tint minx=INF, maxx=-INF, miny=INF, maxy=-INF, minz=INF, maxz=-INF;\n\t\t\n\t\tval[0]=true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tminx = std::min( minx, now.x ); maxx = std::max( maxx, now.x );\n\t\t\tminy = std::min( miny, now.y ); maxy = std::max( maxy, now.y );\n\t\t\tminz = std::min( minz, now.z ); maxz = std::max( maxz, now.z );\n\t\t}\n\t\tin.vcube.push_back( point( minx, miny, minz ) );\n\t\tin.vcube.push_back( point( minx, miny, maxz ) );\n\t\tin.vcube.push_back( point( minx, maxy, minz ) );\n\t\tin.vcube.push_back( point( minx, maxy, maxz ) );\n\t\tin.vcube.push_back( point( maxx, miny, minz ) );\n\t\tin.vcube.push_back( point( maxx, miny, maxz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, minz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, maxz ) );\n\t}\n}\n\n\nostream &operator << (ostream &os, const strange_key &t){\n\tos << \"Key Expression:\\n\";\n\tfor(unsigned int i = 0; i < t.vp.size(); ++i){\n\t\tif( i != 0 )\n\t\t\tos << ' ';\n\t\tos << t.vp[i];\n\t}\n\treturn os;\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct P{\n  int x, y, z;\n  P() {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P& p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator - (const P& p) const {\n    return P(x - p.x, y - p.y, z - p.z);\n  }\n};\ntypedef pair<P, P> L;\nvector<L> input(){\n  int N; cin >> N;\n  P label[100] = {};\n  bool used[100] = {};\n  P cur;\n  vector<L> res;\n  while(N--){\n    string s;\n    cin >> s;\n    if(isdigit(s[0])){\n      int l = atoi(s.c_str());\n      if(used[l]){\n        cur = label[l];\n      }else{\n        label[l] = cur;\n        used[l] = true;\n      }\n    }else{\n      int dif = (s[0] == '+' ? 1 : -1);\n      P next = cur;\n      if(s[1] == 'x'){\n        next.x += dif;\n      }else if(s[1] == 'y'){\n        next.y += dif;\n      }else if(s[1] == 'z'){\n        next.z += dif;\n      }else{\n        assert(false);\n      }\n      res.push_back(L(cur, next));\n      cur = next;\n    }\n  }\n  return res;\n}\nvector<L> normalize(const vector<L>& s){\n  P min_p = s[0].first;\n  REP(i, s.size()){\n    min_p = min(min_p, s[i].first);\n    min_p = min(min_p, s[i].second);\n  }\n  vector<L> res;\n  REP(i, s.size()){\n    res.push_back(L(s[i].first - min_p, s[i].second - min_p));\n    if(res[i].second < res[i].first) swap(res[i].first, res[i].second);\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\nvoid rotate_x(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.x, -s[i].first.z, s[i].first.y);\n    s[i].second = P(s[i].second.x, -s[i].second.z, s[i].second.y);\n  }\n}\nvoid rotate_y(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.z, s[i].first.y, -s[i].first.x);\n    s[i].second = P(s[i].second.z, s[i].second.y, -s[i].second.x);\n  }\n}\nvoid rotate_z(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(-s[i].first.y, s[i].first.x, s[i].first.z);\n    s[i].second = P(-s[i].second.y, s[i].second.x, s[i].second.z);\n  }\n}\nint main(){\n  while(true){\n    vector<L> k1 = input();\n    if(k1.empty()) break;\n    vector<L> k2 = input();\n    k2 = normalize(k2);\n\n    bool is_equal = false;\n    for(int i = 0; i < 4; i++){\n      rotate_z(k1);\n      for(int k = 0; k < 6; k++){\n        if(k % 2 == 0) rotate_x(k1);\n        else rotate_y(k1);\n        k1 = normalize(k1);\n        if(k1 == k2){\n          is_equal = true;\n          goto OUTPUT;\n        }\n      }\n    }\n\nOUTPUT:\n    if(is_equal) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\n#define INF 1001\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tpoint(int x, int y, int z):x(x),y(y),z(z){}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid rot90arndX(){\n\t\tint tz = z; z = -y; y = tz;\n\t}\n\tvoid rot90arndY(){\n\t\tint tz = z; z = x; x = -tz;\n\t}\n\tvoid rot90arndZ(){\n\t\tint tx = x; x = y; y = -tx;\n\t}\n\tvoid set(int x, int y, int z){\n\t\tthis->x = x; this->y = y; this->z = z;\n\t}\n};\n\nostream &operator << (ostream &os, const point &t){\n\tos << '(' << t.x << ',' << t.y << ',' << t.z << ')';\n\treturn os;\n}\n\nstruct strange_key{\n\tvector<point> vp;\n\tset<point> sp;\n\tvector<point> vcube;\n\tint areaXY, areaYZ, areaXZ;\n\t\n\tvoid rot90arndX(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndX();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndX();\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndY();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndY();\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndZ();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndZ();\n\t\t}\n\t}\n\tvoid MoveToOrigin(int base){\n\t\tint dx = vp[ base ].x;\n\t\tint dy = vp[ base ].y;\n\t\tint dz = vp[ base ].z;\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].x -= dx;\n\t\t\tvp[i].y -= dy;\n\t\t\tvp[i].z -= dz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tvoid CalcArea(){\n\t\tint minx = INF, miny = INF, minz = INF;\n\t\tint maxx = -INF, maxy = -INF, maxz = -INF;\n\t\t\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tminx = std::min( minx, vcube[i].x ); maxx = std::max( maxx, vcube[i].x );\n\t\t\tminy = std::min( miny, vcube[i].y ); maxy = std::max( maxy, vcube[i].y );\n\t\t\tminz = std::min( minz, vcube[i].z ); maxz = std::max( maxz, vcube[i].z );\t\t\n\t\t}\n\t\t\n\t\tareaYZ = ( maxy - miny ) * ( maxz - minz );\n\t\tareaXY = ( maxx - minx ) * ( maxy - miny );\n\t\tareaXZ = ( maxx - minx ) * ( maxz - minz );\n\t}\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\t/*\n\t\tcout << \" AREA XY: \" << areaXY << \" AREA TXY: \" << t.areaXY << endl;\n\t\tcout << \" AREA XZ: \" << areaXZ << \" AREA TXZ: \" << t.areaXZ << endl;\n\t\tcout << \" AREA YZ: \" << areaYZ << \" AREA TYZ: \" << t.areaYZ << endl;\n\t\t*/\n\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tCalcArea(); t.CalcArea();\n\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\tt.rot90arndZ();\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tCalcArea(); t.CalcArea();\n\t\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\t\tt.rot90arndY();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\tCalcArea(); t.CalcArea();\n\t\t\t\t\tif( areaXY != t.areaXY ||\n\t\t\t\t\t\tareaXZ != t.areaXZ ||\n\t\t\t\t\t\tareaYZ != t.areaYZ ){\n\t\t\t\t\t\t\tt.rot90arndX();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(unsigned int l = 0; l < vp.size(); ++l){\n\t\t\t\t\t\tthis->MoveToOrigin( l );\n\t\t\t\t\t\tfor(unsigned int m = 0; m < vp.size(); ++m){\n\t\t\t\t\t\t\tbool bSame = true;\n\t\t\t\t\t\t\tt.MoveToOrigin( m );\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tcout << \"Key Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = sp.begin(); it != sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\nKey Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = t.sp.begin(); it != t.sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\n--------------------\\n\";\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(unsigned int n = 0; n < vp.size() && bSame; ++n){\n\t\t\t\t\t\t\t\tif( t.sp.find( vp[n] ) == t.sp.end() ){\n\t\t\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( bSame )\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tt.rot90arndX();\n\t\t\t\t}\n\t\t\t\tt.rot90arndY();\n\t\t\t}\n\t\t\tt.rot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\tint minx=0, maxx=0, miny=0, maxy=0, minz=0, maxz=0;\n\t\t\n\t\tval[0]=true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.vcube.push_back( point( minx, miny, minz ) );\n\t\tin.vcube.push_back( point( minx, miny, maxz ) );\n\t\tin.vcube.push_back( point( minx, maxy, minz ) );\n\t\tin.vcube.push_back( point( minx, maxy, maxz ) );\n\t\tin.vcube.push_back( point( maxx, miny, minz ) );\n\t\tin.vcube.push_back( point( maxx, miny, maxz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, minz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, maxz ) );\n\t}\n}\n\n\nostream &operator << (ostream &os, const strange_key &t){\n\tos << \"Key Expression:\\n\";\n\tfor(unsigned int i = 0; i < t.vp.size(); ++i){\n\t\tif( i != 0 )\n\t\t\tos << ' ';\n\t\tos << t.vp[i];\n\t}\n\treturn os;\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\n#define INF 1001\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid rot90arndX(){ int tz = z; z = -y; y = tz; }\n\tvoid rot90arndY(){ int tz = z; z = x; x = -tz; }\n\tvoid rot90arndZ(){ int tx = x; x = y; y = -tx; }\n};\n\nstruct strange_key{\n\tvector<point> vp;\n\n\tvoid rot90arndX(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndX();\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndY();\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndZ();\n\t\t}\n\t}\n\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\tfor(int a = 0; a < 4; ++a){\n\t\t\tfor(int b = 0; b < 4; ++b){\n\t\t\t\tfor(int c = 0; c < 4; ++c){\n\t\t\t\t\tbool bSame = true;\n\t\t\t\t\tsort( vp.begin(), vp.end() );\n\t\t\t\t\tsort( t.vp.begin(), t.vp.end() );\n\t\t\t\t\t\n\t\t\t\t\tint dx = vp[0].x - t.vp[0].x;\n\t\t\t\t\tint dy = vp[0].y - t.vp[0].y;\n\t\t\t\t\tint dz = vp[0].z - t.vp[0].z;\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int l = 1; l < vp.size() && bSame; ++l){\n\t\t\t\t\t\tif( dx != vp[l].x - t.vp[l].x )\n\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\tif( dy != vp[l].y - t.vp[l].y )\n\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\tif( dz != vp[l].z - t.vp[l].z )\n\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t}\n\t\t\t\t\tif( bSame )\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\trot90arndX();\n\t\t\t\t}\n\t\t\t\trot90arndY();\n\t\t\t}\n\t\t\trot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\t\n\t\tval[0]=true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<set>\n\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n\n#define INF 1001\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint():x(0),y(0),z(0){}\n\tpoint(int x, int y, int z):x(x),y(y),z(z){}\n\tbool operator <(const point &t)const{\n\t\tif( x < t.x ){\n\t\t\treturn true;\n\t\t}else if( x == t.x ){\n\t\t\tif( y < t.y ){\n\t\t\t\treturn true;\n\t\t\t}else if( y == t.y ){\n\t\t\t\tif( z < t.z ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tvoid rot90arndX(){\n\t\tint tz = z; z = -y; y = tz;\n\t}\n\tvoid rot90arndY(){\n\t\tint tz = z; z = x; x = -tz;\n\t}\n\tvoid rot90arndZ(){\n\t\tint tx = x; x = y; y = -tx;\n\t}\n\tvoid set(int x, int y, int z){\n\t\tthis->x = x; this->y = y; this->z = z;\n\t}\n};\n\nostream &operator << (ostream &os, const point &t){\n\tos << '(' << t.x << ',' << t.y << ',' << t.z << ')';\n\treturn os;\n}\n\nstruct strange_key{\n\tvector<point> vp;\n\tset<point> sp;\n\tvector<point> vcube;\n\t\n\tvoid rot90arndX(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndX();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndX();\n\t\t}\n\t}\n\tvoid rot90arndY(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndY();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndY();\n\t\t}\n\t}\n\tvoid rot90arndZ(){\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].rot90arndZ();\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].rot90arndZ();\n\t\t}\n\t}\n\tvoid MoveToOrigin(int base){\n\t\tint dx = vcube[ base ].x;\n\t\tint dy = vcube[ base ].y;\n\t\tint dz = vcube[ base ].z;\n\t\t\n\t\tfor(unsigned int i = 0; i < vcube.size(); ++i){\n\t\t\tvcube[i].x -= dx;\n\t\t\tvcube[i].y -= dy;\n\t\t\tvcube[i].z -= dz;\n\t\t}\n\t\tsp.clear();\n\t\tfor(unsigned int i = 0; i < vp.size(); ++i){\n\t\t\tvp[i].x -= dx;\n\t\t\tvp[i].y -= dy;\n\t\t\tvp[i].z -= dz;\n\t\t\tsp.insert( vp[i] );\n\t\t}\n\t}\n\tbool Same(strange_key &t){\n\t\tif( vp.size() != t.vp.size() )\n\t\t\treturn false;\n\n\t\tfor(int a = 0; a < 4; ++a){\n\t\t\tfor(int b = 0; b < 4; ++b){\n\t\t\t\tfor(int c = 0; c < 4; ++c){\n\t\t\t\t\tfor(unsigned int l = 0; l < vcube.size(); ++l){\n\t\t\t\t\t\tthis->MoveToOrigin( l );\n\t\t\t\t\t\tfor(unsigned int m = 0; m < vcube.size(); ++m){\n\t\t\t\t\t\t\tbool bSame = true;\n\t\t\t\t\t\t\tt.MoveToOrigin( m );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tcout << \"Key Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = sp.begin(); it != sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\nKey Expression:\";\n\t\t\t\t\t\t\tfor(set<point>::iterator it = t.sp.begin(); it != t.sp.end(); ++it){\n\t\t\t\t\t\t\t\tcout << *it << ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << \"\\n--------------------\\n\";\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor(unsigned int n = 0; n < vp.size() && bSame; ++n){\n\t\t\t\t\t\t\t\tif( t.sp.find( vp[n] ) == t.sp.end() ){\n\t\t\t\t\t\t\t\t\tbSame = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( bSame )\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trot90arndX();\n\t\t\t\t}\n\t\t\t\trot90arndY();\n\t\t\t}\n\t\t\trot90arndZ();\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvoid input_strange_key( istream &is, int n, strange_key &in ){\n\tif( is ){\n\t\tpoint now;\n\t\tbool val[51]={false,};\n\t\tvector<point> pos_mem(51);\n\t\tint minx=INF, maxx=-INF, miny=INF, maxy=-INF, minz=INF, maxz=-INF;\n\t\t\n\t\tval[0]=true;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring s;\n\t\t\t\n\t\t\tcin >> s;\n\t\t\tif( s[0] != '+' && s[0] != '-' ){\n\t\t\t\tint mem = atoi( s.c_str() );\n\t\t\t\tif( val[ mem ] ){\n\t\t\t\t\tnow = pos_mem[ mem ];\n\t\t\t\t}else{\n\t\t\t\t\tpos_mem[ mem ] = now;\n\t\t\t\t\tval[ mem ] = true;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint progress = ( s[0] == '+' ? 2 : -2 );\n\t\t\t\tpoint next = now;\n\t\t\t\tswitch( s[1] ){\n\t\t\t\t\tcase 'x':\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.x += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'y':\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.y += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tin.vp.push_back( now );\n\t\t\t\t\t\tin.sp.insert( now );\n\t\t\t\t\t\tnow.z += progress / 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tminx = std::min( minx, now.x ); maxx = std::max( maxx, now.x );\n\t\t\tminy = std::min( miny, now.y ); maxy = std::max( maxy, now.y );\n\t\t\tminz = std::min( minz, now.z ); maxz = std::max( maxz, now.z );\n\t\t}\n\t\tin.vcube.push_back( point( minx, miny, minz ) );\n\t\tin.vcube.push_back( point( minx, miny, maxz ) );\n\t\tin.vcube.push_back( point( minx, maxy, minz ) );\n\t\tin.vcube.push_back( point( minx, maxy, maxz ) );\n\t\tin.vcube.push_back( point( maxx, miny, minz ) );\n\t\tin.vcube.push_back( point( maxx, miny, maxz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, minz ) );\n\t\tin.vcube.push_back( point( maxx, maxy, maxz ) );\n\t}\n}\n\n\nostream &operator << (ostream &os, const strange_key &t){\n\tos << \"Key Expression:\\n\";\n\tfor(unsigned int i = 0; i < t.vp.size(); ++i){\n\t\tif( i != 0 )\n\t\t\tos << ' ';\n\t\tos << t.vp[i];\n\t}\n\treturn os;\n}\n\nint main(){\n\twhile( true ){\n\t\tint n1,n2;\n\t\tstrange_key a, b;\n\n\t\tcin>>n1;\n\t\tif( n1 == 0 )\n\t\t\tbreak;\n\t\tinput_strange_key( cin, n1, a );\n\t\tcin>>n2;\n\t\tinput_strange_key( cin, n2, b );\n\n\t\tif( a.Same( b ) )\n\t\t\tcout << \"SAME\\n\";\n\t\telse\n\t\t\tcout << \"DIFFERENT\\n\";\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\nstruct point {\n  int x, y, z;\n  explicit point(int x_ = 0, int y_ = 0, int z_ = 0):x(x_), y(y_), z(z_) {}\n\n  point operator+(const point &p) const {\n\treturn point(x + p.x, y + p.y, z + p.z);\n  }\n\n  point operator-(const point &p) const {\n\treturn point(x - p.x, y - p.y, z - p.z);\n  }\n\n  point operator-() const {\n\treturn point(-x, -y, -z);\n  }\n\n  bool operator<(const point &p) const {\n\tif(x != p.x) return x < p.x;\n\tif(y != p.y) return y < p.y;\n\treturn z < p.z;\n  }\n\n  bool operator==(const point &p) const {\n\treturn x == p.x && y == p.y && z == p.z;\n  }\n};\n\nostream &operator<<(ostream &os, const point &p) {\n  return os << '(' << p.x << \", \" << p.y << \", \" << p.z << ')';\n}\n\nstruct segment {\n  point a, b;\n  segment(const point &a_, const point &b_):a(a_), b(b_) {\n\tif(b < a) swap(a, b);\n  }\n\n  bool operator<(const segment &s) const {\n\tif(a < s.a || s.a < a) return a < s.a;\n\treturn b < s.b;\n  }\n\n  bool operator==(const segment&s) const {\n\treturn a == s.a && b == s.b;\n  }\n};\n\npoint rotate_x(const point &p) {\n  return point(p.x, p.z, -p.y);\n}\n\npoint rotate_y(const point &p) {\n  return point(p.z, p.y, -p.x);\n}\n\npoint rotate_z(const point &p) {\n  return point(p.y, -p.x, p.z);\n}\n\nbool input(set<segment> &segs) {\n  int n;\n  cin >> n;\n\n  if(n == 0) return false;\n\n  point move_d[128];\n  move_d['x'] = point(1, 0, 0);\n  move_d['y'] = point(0, 1, 0);\n  move_d['z'] = point(0, 0, 1);\n  \n  const point move_x(1, 0, 0), move_y(0, 1, 0), move_z(0, 0, 1);\n\n  point current(0, 0, 0);\n  map<int, point> label;\n\n  rep(i, n) {\n\tstring s;\n\tcin >> s;\n\n\tif(isdigit(s[0])) { // label\n\t  const int idx = stoi(s);\n\t  if(!label.count(idx)) {\n\t\tlabel[idx] = current;\n\t  }\n\t  else {\n\t\tcurrent = label[idx];\n\t  }\n\t}\n\telse { // move\n\t  point d = move_d[s[1]];\n\t  if(s[0] == '-') d = -d;\n\t  const point next = current + d;\n\t  segs.insert(segment(current, next));\n\t  current = move(next);\n\t}\n  }\n\n   return true;\n}\n\nbool match(const set<segment> &a, const set<segment> &b) {\n  if(a.size() != b.size()) return false;\n  auto it_a = a.cbegin();\n  auto it_b = b.cbegin();\n\n  const point offset = a.cbegin()->a - b.cbegin()->a;\n\n  while(it_a != a.end()) {\n\tconst segment &s_a = *it_a;\n\tconst segment s_b(it_b->a + offset, it_b->b + offset);\n\tif(!(s_a == s_b)) return false;\n\n\t++it_a;\n\t++it_b;\n  }\n\n  return true;\n\n}\n\nset<segment> rotate_points(const set<segment> &segs, const function<point(const point&)> &convert) {\n  set<segment> res;\n  for(const auto &seg : segs) {\n\tres.insert(segment(convert(seg.a), convert(seg.b)));\n  }\n  return res;\n}\n\nbool valid(const set<segment> &a, set<segment> b) {\n  rep(loop_x, 4) {\n\tb = rotate_points(b, rotate_x);\n\trep(loop_y, 4) {\n\t  b = rotate_points(b, rotate_y);\n\t  rep(loop_z, 4) {\n\t\tb = rotate_points(b, rotate_z);\n\t\tif(match(a, b)) return true;\n\t  }\n\t}\n  }\n\n  return false;\n}\n\nint main() {\n  set<segment> a, b;\n  while(input(a)) {\n\tassert(input(b));\n\tcout << (valid(a, b) ? \"SAME\" : \"DIFFERENT\") << endl;\n\ta.clear();\n\tb.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n\nclass Point{\n    public:\n    int x, y, z;\n    Point(int x=0, int y=0, int z=0):x(x), y(y), z(z){}\n    bool operator < ( const Point &p) const{\n\tif ( x != p.x ) return x < p.x;\n\tif ( y != p.y ) return y < p.y;\n\tif ( z != p.z ) return z < p.z;\n\treturn false;\n    }\n    bool operator == ( const Point &p ) const {\n\treturn x == p.x && y == p.y && z == p.z;\n    }\n};\n\nclass Edge{\n    public:\n    Point p[2];\n    Edge(){}\n    Edge(Point p1, Point p2){\n\tp[0] = p1; p[1] = p2; sort(p, p+2);\n    }\n    bool operator < ( const Edge &e ) const{\n\tif ( !(p[0] == e.p[0]) ) return p[0] < e.p[0];\n\tif ( !(p[1] == e.p[1]) ) return p[1] < e.p[1];\n\treturn false;\n    }\n};\n\nclass Key{\n    public:\n    set<Edge> E;\n    vector<Edge> EV;\n    Key(){}\n    void make( int n ){\n\tstring com;\n\tE.clear();\n\tPoint pre = Point(0, 0, 0);\n\tbool V[60];\n\trep(i, 60) V[i] = false;\n\tPoint L[60];\n\trep(i, n){\n\t    cin >> com;\n\t    Point cur = pre;\n\t    if ( isdigit(com[0])){\n\t\tint p = atoi(com.c_str());\n\t\tif ( V[p] ){\n\t\t    pre = L[p];\n\t\t} else {\n\t\t    V[p] = true;\n\t\t    L[p] = pre;\n\t\t}\n\t    } else {\n\t\tif ( com == \"+x\" ) cur.x++;\n\t\telse if ( com == \"-x\" ) cur.x--;\n\t\telse if ( com == \"+y\" ) cur.y++;\n\t\telse if ( com == \"-y\" ) cur.y--;\n\t\telse if ( com == \"+z\" ) cur.z++;\n\t\telse if ( com == \"-z\" ) cur.z--;\n\t\tE.insert(Edge(pre, cur));\n\t\tpre = cur;\n\t    }\n\t}\n\tfor ( set<Edge>::iterator it = E.begin(); it != E.end(); it++ ) EV.push_back(*it);\n    }\n    Point move(){\n\tPoint p = (1000, 1000, 1000);\n\tfor ( int i = 0; i < EV.size(); i++ ) sort(EV[i].p, EV[i].p+2);\n\tsort( EV.begin(), EV.end() );\n\tp = EV[0].p[0];\n\n\tfor ( int i = 0; i < EV.size(); i++ ){\n\t    for ( int j = 0; j < 2; j++ ){\n\t\tEV[i].p[j].x -= p.x;\n\t\tEV[i].p[j].y -= p.y;\n\t\tEV[i].p[j].z -= p.z;\n\t    }\n\t}\n    }\n\n    void roll_x(){\n\tfor ( int i = 0; i < EV.size(); i++ ){\n\t    for ( int j = 0; j < 2; j++ ){\n\t\tint tmp = EV[i].p[j].y;\n\t\tEV[i].p[j].y = EV[i].p[j].z*(-1);\n\t\tEV[i].p[j].z = tmp;\n\t    }\n\t}\n    }\n    void roll_y(){\n\tfor ( int i = 0; i < EV.size(); i++ ){\n\t    for ( int j = 0; j < 2; j++ ){\n\t\tint tmp = EV[i].p[j].x;\n\t\tEV[i].p[j].x = EV[i].p[j].z*(-1);\n\t\tEV[i].p[j].z = tmp;\n\t    }\n\t}\n    }\n    void roll_z(){\n\tfor ( int i = 0; i < EV.size(); i++ ){\n\t    for ( int j = 0; j < 2; j++ ){\n\t\tint tmp = EV[i].p[j].x;\n\t\tEV[i].p[j].x = EV[i].p[j].y;\n\t\tEV[i].p[j].y = tmp*(-1);\n\t    }\n\t}\n    }\n};\n\nbool equals(Key key1, Key key2 ){\n    for ( int i = 0; i < key1.EV.size(); i++ ) sort( key1.EV[i].p, key1.EV[i].p+2);\n    sort(key1.EV.begin(), key1.EV.end());\n    for ( int i = 0; i < key1.EV.size(); i++ ){\n\tfor ( int j = 0; j < 2; j++ ){\n\t    if ( !(key1.EV[i].p[j] == key2.EV[i].p[j]) ) return false;\n\t}\n    }\n    return true;\n}\n\nbool check(Key key1, Key key2){\n    if ( key1.EV.size() != key2.EV.size() ) return false;\n    for ( int i = 0; i < key2.EV.size(); i++ ) sort( key2.EV[i].p, key2.EV[i].p+2);\n    sort(key2.EV.begin(), key2.EV.end());\n    key2.move();\n    Key target;\n    \n    rep(i, 6){\n\trep(j, 4){\n\t    target = key1;\n\t    target.move();\n\t    if ( equals(target, key2) ) return true;\t    \n\t    key1.roll_z();\n\t}\n\tif ( i % 2 == 0 ) key1.roll_y();\n\telse key1.roll_x();\n    }\n\n    return false;\n}\n\nmain(){\n    int n;\n    while(1){\n\tKey key1, key2;\n\tcin >> n;\n\tif ( n == 0 ) break;\n\tkey1.make(n);\n\tcin >> n;\n\tkey2.make(n);\n\tif ( check(key1, key2) ) cout << \"SAME\" << endl;\n\telse cout << \"DIFFERENT\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct P{\n  int x, y, z;\n  P() : x(0), y(0), z(0) {}\n  P(int x, int y, int z) : x(x), y(y), z(z) {}\n  bool operator < (const P& p) const {\n    if(x != p.x) return x < p.x;\n    if(y != p.y) return y < p.y;\n    return z < p.z;\n  }\n  bool operator == (const P& p) const {\n    return x == p.x && y == p.y && z == p.z;\n  }\n  P operator - (const P& p) const {\n    return P(x - p.x, y - p.y, z - p.z);\n  }\n};\ntypedef pair<P, P> L;\nvector<L> input(){\n  int N; cin >> N;\n  P label[100] = {};\n  bool used[100] = {};\n  P cur;\n  vector<L> res;\n  while(N--){\n    string s;\n    cin >> s;\n    if(isdigit(s[0])){\n      int l = atoi(s.c_str());\n      if(used[l]){\n        cur = label[l];\n      }else{\n        label[l] = cur;\n        used[l] = true;\n      }\n    }else{\n      int dif = (s[0] == '+' ? 1 : -1);\n      P next = cur;\n      if(s[1] == 'x'){\n        next.x += dif;\n      }else if(s[1] == 'y'){\n        next.y += dif;\n      }else if(s[1] == 'z'){\n        next.z += dif;\n      }else{\n        assert(false);\n      }\n      res.push_back(L(cur, next));\n      cur = next;\n    }\n  }\n  return res;\n}\nvector<L> normalize(const vector<L>& s){\n  P min_p = s[0].first;\n  REP(i, s.size()){\n    min_p = min(min_p, s[i].first);\n    min_p = min(min_p, s[i].second);\n  }\n  vector<L> res;\n  REP(i, s.size()){\n    res.push_back(L(s[i].first - min_p, s[i].second - min_p));\n    if(res[i].second < res[i].first) swap(res[i].first, res[i].second);\n  }\n  sort(res.begin(), res.end());\n  return res;\n}\nvoid rotate_x(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.x, -s[i].first.z, s[i].first.y);\n    s[i].second = P(s[i].second.x, -s[i].second.z, s[i].second.y);\n  }\n}\nvoid rotate_y(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(s[i].first.z, s[i].first.y, -s[i].first.x);\n    s[i].second = P(s[i].second.z, s[i].second.y, -s[i].second.x);\n  }\n}\nvoid rotate_z(vector<L>& s){\n  REP(i, s.size()){\n    s[i].first = P(-s[i].first.y, s[i].first.x, s[i].first.z);\n    s[i].second = P(-s[i].second.y, s[i].second.x, s[i].second.z);\n  }\n}\nint main(){\n  while(true){\n    vector<L> k1 = input();\n    if(k1.empty()) break;\n    vector<L> k2 = input();\n    k2 = normalize(k2);\n\n    bool is_equal = false;\n    for(int i = 0; i < 4; i++){\n      rotate_z(k1);\n      for(int k = 0; k < 6; k++){\n        if(k % 2 == 0) rotate_x(k1);\n        else rotate_y(k1);\n        k1 = normalize(k1);\n        if(k1 == k2){\n          is_equal = true;\n          //goto OUTPUT;\n        }\n      }\n    }\n\nOUTPUT:\n    if(is_equal) cout << \"SAME\" << endl;\n    else cout << \"DIFFERENT\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define op operator\n#define pb push_back\n\nstruct poi {\n\tint x, y, z;\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y, z - p.z};\n\t}\n\tpoi op +(poi p) {\n\t\treturn {x + p.x, y + p.y, z + p.z};\n\t}\n\tbool op <(poi p) const {\n\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z);\n\t}\n\tpoi rot(int i) {\n\t\tint a[3] = {x, y, z};\n\t\tvector <poi> v;\n\t\tint p[3] = {0, 1, 2};\n\t\tdo {\n\t\t\tint inv = (p[0] > p[1]) + (p[0] > p[2]) + (p[1] > p[2]);\n\t\t\tint x = a[p[0]], y = a[p[1]], z = a[p[2]];\n\t\t\tif(inv & 1) {\n\t\t\t\tv.pb({-x, y, z});\n\t\t\t\tv.pb({x, -y, z});\n\t\t\t\tv.pb({x, y, -z});\n\t\t\t\tv.pb({-x, -y, -z});\n\t\t\t} else {\n\t\t\t\tv.pb({x, y, z});\n\t\t\t\tv.pb({x, -y, -z});\n\t\t\t\tv.pb({-x, y, -z});\n\t\t\t\tv.pb({-x, -y, z});\n\t\t\t}\n\t\t}while(next_permutation(p, p + 3));\n\t\treturn v[i];\n\t}\n};\n\nconst int N = 1001;\nbool v[N];\npoi save[N];\nvector <pair <poi, poi>> segs[2];\n\nvector <pair <poi, poi>> read(int n) {\n\tpoi p = {0, 0, 0};\n\tmemset(v, 0, sizeof v);\n\tvector <pair <poi, poi>> r;\n\tfor(int i = 0; i < n; i ++) {\n\t\tstring s; cin >> s;\n\t\tif(s[0] == '+' || s[0] == '-') {\n\t\t\tpoi q;\n\t\t\tif(s[1] == 'x')\n\t\t\t\tq = {1, 0, 0};\n\t\t\telse if(s[1] == 'y')\n\t\t\t\tq = {0, 1, 0};\n\t\t\telse\n\t\t\t\tq = {0, 0, 1};\n\t\t\tif(s[0] == '+')\n\t\t\t\tq = p + q;\n\t\t\telse\n\t\t\t\tq = p - q;\n\t\t\tr.pb({p, q});\n\t\t\tp = q;\n\t\t} else {\n\t\t\tint x = stoi(s);\n\t\t\tif(v[x])\n\t\t\t\tp = save[x];\n\t\t\telse {\n\t\t\t\tv[x] = 1;\n\t\t\t\tsave[x] = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nset <poi> st;\nbool check(poi p) {\n\tfor(int i = 0; i < 24; i ++) {\n\t\tbool f = true;\n\t\tfor(auto seg : segs[1]) {\n\t\t\tpoi a = (seg.first - p).rot(i);\n\t\t\tpoi b = (seg.second - p).rot(i);\n\t\t\tif(!st.count(a + b))\n\t\t\t\tf = false;\n\t\t}\n\t\tif(f) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint n, m;\n\twhile(cin >> n) {\n\t\tif(n == 0) break;\n\t\tsegs[0] = read(n);\n\t\tcin >> m;\n\t\tsegs[1] = read(m);\n\n\t\tst.clear();\n\t\tfor(auto seg : segs[0]) {\n\t\t\tpoi p = seg.first - segs[0][0].first;\n\t\t\tpoi q = seg.second - segs[0][0].first;\n\t\t\tst.insert(p + q);\n\t\t}\n\n\t\tbool f = false;\n\t\tfor(auto seg : segs[1])\n\t\t\tf |= check(seg.first) || check(seg.second);\n\t\tcout << (f ? \"SAME\" : \"DIFFERENT\") << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define op operator\n#define pb push_back\n\nstruct poi {\n\tint x, y, z;\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y, z - p.z};\n\t}\n\tpoi op +(poi p) {\n\t\treturn {x + p.x, y + p.y, z + p.z};\n\t}\n\tbool op <(poi p) const {\n\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z);\n\t}\n\tvector <poi> rot() {\n\t\tint a[3] = {x, y, z};\n\t\tvector <poi> v;\n\t\tint p[3] = {0, 1, 2};\n\t\tdo {\n\t\t\tint inv = (p[0] > p[1]) + (p[0] > p[2]) + (p[1] > p[2]);\n\t\t\tint x = a[p[0]], y = a[p[1]], z = a[p[2]];\n\t\t\tif(inv & 1) {\n\t\t\t\tv.pb({-x, y, z});\n\t\t\t\tv.pb({x, -y, z});\n\t\t\t\tv.pb({x, y, -z});\n\t\t\t\tv.pb({-x, -y, -z});\n\t\t\t} else {\n\t\t\t\tv.pb({x, y, z});\n\t\t\t\tv.pb({x, -y, -z});\n\t\t\t\tv.pb({-x, y, -z});\n\t\t\t\tv.pb({-x, -y, z});\n\t\t\t}\n\t\t}while(next_permutation(p, p + 3));\n\t\treturn v;\n\t}\n};\n\nconst int N = 1001;\nbool v[N];\npoi save[N];\nvector <pair <poi, poi>> segs[2];\n\nvector <pair <poi, poi>> read(int n) {\n\tpoi p = {0, 0, 0};\n\tmemset(v, 0, sizeof v);\n\tvector <pair <poi, poi>> r;\n\tfor(int i = 0; i < n; i ++) {\n\t\tstring s; cin >> s;\n\t\tif(s[0] == '+' || s[0] == '-') {\n\t\t\tpoi q;\n\t\t\tif(s[1] == 'x')\n\t\t\t\tq = {1, 0, 0};\n\t\t\telse if(s[1] == 'y')\n\t\t\t\tq = {0, 1, 0};\n\t\t\telse\n\t\t\t\tq = {0, 0, 1};\n\t\t\tif(s[0] == '+')\n\t\t\t\tq = p + q;\n\t\t\telse\n\t\t\t\tq = p - q;\n\t\t\tr.pb({p, q});\n\t\t\tp = q;\n\t\t} else {\n\t\t\tint x = stoi(s);\n\t\t\tif(v[x])\n\t\t\t\tp = save[x];\n\t\t\telse {\n\t\t\t\tv[x] = 1;\n\t\t\t\tsave[x] = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn r;\n}\n\nset <poi> st;\nbool check(poi p) {\n\tbool v[24];\n\tmemset(v, true, sizeof v);\n\tfor(auto seg : segs[1]) {\n\t\tauto a = (seg.first - p).rot();\n\t\tauto b = (seg.second - p).rot();\n\t\tfor(int i = 0; i < 24; i ++) {\n\t\t\tif(v[i] && !st.count(a[i] + b[i]))\n\t\t\t\tv[i] = false;\n\t\t}\n\t\tif(!count(v, v + 24, true))\n\t\t\treturn false;\n\t}\n\treturn count(v, v + 24, true);\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint n, m;\n\twhile(cin >> n) {\n\t\tif(n == 0) break;\n\t\tsegs[0] = read(n);\n\t\tcin >> m;\n\t\tsegs[1] = read(m);\n\n\t\tst.clear();\n\t\tfor(auto seg : segs[0]) {\n\t\t\tpoi p = seg.first - segs[0][0].first;\n\t\t\tpoi q = seg.second - segs[0][0].first;\n\t\t\tst.insert(p + q);\n\t\t}\n\n\t\tbool f = false;\n\t\tfor(auto seg : segs[1])\n\t\t\tf |= check(seg.first) || check(seg.second);\n\t\tcout << (f ? \"SAME\" : \"DIFFERENT\") << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct point{\n\tint x,y,z;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y,z+a.z}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y,z-a.z}; }\n\tbool operator==(const point &a)const{ return x==a.x && y==a.y && z==a.z; }\n};\n\nstruct edge{\n\tpoint u,v;\n\tbool operator==(const edge &e)const{ return u==e.u && v==e.v || u==e.v && v==e.u; }\n};\n\nstruct key{\n\tint n;\n\tedge E[300];\n};\n\nkey getkey(){\n\tkey K={};\n\tpoint p={0,0,0};\n\tmap<int,point> f;\n\tint n; scanf(\"%d\",&n);\n\twhile(n--){\n\t\tchar s[8]; scanf(\"%s\",s);\n\n\t\tif(isdigit(s[0])){\n\t\t\tint a; sscanf(s,\"%d\",&a);\n\t\t\tif(f.count(a)) p=f[a];\n\t\t\telse           f[a]=p;\n\t\t}\n\t\telse{\n\t\t\tpoint q=p;\n\t\t\tif(s[0]=='+' && s[1]=='x') q.x++;\n\t\t\tif(s[0]=='-' && s[1]=='x') q.x--;\n\t\t\tif(s[0]=='+' && s[1]=='y') q.y++;\n\t\t\tif(s[0]=='-' && s[1]=='y') q.y--;\n\t\t\tif(s[0]=='+' && s[1]=='z') q.z++;\n\t\t\tif(s[0]=='-' && s[1]=='z') q.z--;\n\t\t\tK.E[K.n++]=(edge){p,q};\n\t\t\tp=q;\n\t\t}\n\t}\n\n\treturn K;\n}\n\nstruct matrix{\n\tint a[3][3];\n\n\tpoint operator*(const point &p)const{\n\t\tint x=a[0][0]*p.x+a[0][1]*p.y+a[0][2]*p.z;\n\t\tint y=a[1][0]*p.x+a[1][1]*p.y+a[1][2]*p.z;\n\t\tint z=a[2][0]*p.x+a[2][1]*p.y+a[2][2]*p.z;\n\t\treturn (point){x,y,z};\n\t}\n\n\tmatrix operator*(const matrix &A)const{\n\t\tmatrix B={};\n\t\trep(i,3) rep(j,3) rep(k,3) B.a[i][j]+=a[i][k]*A.a[k][j];\n\t\treturn B;\n\t}\n\n\tbool operator==(const matrix &A)const{\n\t\trep(i,3) rep(j,3) if(a[i][j]!=A.a[i][j]) return false;\n\t\treturn true;\n\t}\n};\n\nvector<matrix> R;\n\nbool issame(const key &K1,const key &K2){\n\tif(K1.n!=K2.n) return false;\n\n\tpoint shift1=K1.E[0].u;\n\tpoint dir1=K1.E[0].v-shift1;\n\trep(i,K2.n){\n\t\tpoint shift2,dir2;\n\t\trep(t,2){\n\t\t\tif(t==0) shift2=K2.E[i].u, dir2=K2.E[i].v-shift2;\n\t\t\tif(t==1) shift2=K2.E[i].v, dir2=K2.E[i].u-shift2;\n\n\t\t\trep(j,R.size()) if(R[j]*dir1==dir2) {\n\t\t\t\tbool ok=true;\n\t\t\t\trep(k,K1.n){\n\t\t\t\t\tedge e=K1.E[k];\n\t\t\t\t\te=(edge){e.u-shift1,e.v-shift1};\n\t\t\t\t\te=(edge){R[j]*e.u,R[j]*e.v};\n\t\t\t\t\te=(edge){e.u+shift2,e.v+shift2};\n\t\t\t\t\tif(count(K2.E,K2.E+K2.n,e)!=1){ ok=false; break; }\n\t\t\t\t}\n\t\t\t\tif(ok) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tmatrix I,X,Y,Z;\n\tI.a[0][0]= 1; I.a[0][1]= 0; I.a[0][2]= 0;\n\tI.a[1][0]= 0; I.a[1][1]= 1; I.a[1][2]= 0;\n\tI.a[2][0]= 0; I.a[2][1]= 0; I.a[2][2]= 1;\n\tX.a[0][0]= 1; X.a[0][1]= 0; X.a[0][2]= 0;\n\tX.a[1][0]= 0; X.a[1][1]= 0; X.a[1][2]=-1;\n\tX.a[2][0]= 0; X.a[2][1]= 1; X.a[2][2]= 0;\n\tY.a[0][0]= 0; Y.a[0][1]= 0; Y.a[0][2]=-1;\n\tY.a[1][0]= 0; Y.a[1][1]= 1; Y.a[1][2]= 0;\n\tY.a[2][0]= 1; Y.a[2][1]= 0; Y.a[2][2]= 0;\n\tZ.a[0][0]= 0; Z.a[0][1]=-1; Z.a[0][2]= 0;\n\tZ.a[1][0]= 1; Z.a[1][1]= 0; Z.a[1][2]= 0;\n\tZ.a[2][0]= 0; Z.a[2][1]= 0; Z.a[2][2]= 1;\n\n\tR.push_back(I);\n\twhile(1){\n\t\tbool change=false;\n\t\trep(i,R.size()){\n\t\t\trep(j,3){\n\t\t\t\tmatrix A=(j==0?X*R[i]:j==1?Y*R[i]:Z*R[i]);\n\t\t\t\tif(count(R.begin(),R.end(),A)==0){ R.push_back(A); change=true; }\n\t\t\t}\n\t\t}\n\t\tif(!change) break;\n\t}\n\n\twhile(1){\n\t\tkey K1=getkey(); if(K1.n==0) break;\n\t\tkey K2=getkey();\n\n\t\tputs(issame(K1,K2)?\"SAME\":\"DIFFERENT\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\n\ntypedef struct{\n    int x;\n    int y;\n    int z;\n}edge;\n\ntypedef struct{\n    int x;\n    int y;\n    int z;\n}point;\n\ntypedef struct{\n    int nedge;\n    edge *edges[512];\n}edge_set;\n\nedge_set *get_edge_set();\nvoid free_edge_set(edge_set *s);\nedge *make_edge(int x, int y, int z);\nedge_set *convert_edge_set(const edge_set *s, int nth, int dir);\nint compare_keys(edge_set *in1, edge_set *in2);\nint compare_edge_set(const edge_set *s1, const edge_set *s2);\nvoid point_copy(point *dest, const point *src);\nvoid copy_edge_set(edge_set *in1, edge_set *in2);\nvoid sort_edge_set(edge_set *s);\nvoid rotate_edge(edge *e, int x, int y, int z);\nint edge_comp(const void *e1, const void *e2);\nvoid test();\nvoid solve();\n\nint main()\n{\n    solve();\n\n    return 0;\n}\n\nvoid test()\n{\n    edge_set *s1, *s2;\n\n    s1 = get_edge_set();\n    s2 = get_edge_set();\n    if(compare_keys(s1, s2))\n        printf(\"SAME\\n\");\n    else printf(\"DIFFERENT\\n\");\n\n    free_edge_set(s1);\n    free_edge_set(s2);\n}\n\nvoid solve()\n{\n    edge_set *s1, *s2;\n\n    while(1){\n        if((s1 = get_edge_set()) == NULL) break;\n        s2 = get_edge_set();\n        if(compare_keys(s1, s2))\n            printf(\"SAME\\n\");\n        else printf(\"DIFFRENT\\n\");\n\n        free_edge_set(s1);\n        free_edge_set(s2);\n    }\n\n    return;\n}\n\nvoid sort_edge_set(edge_set *s)\n{\n    qsort(s->edges, s->nedge, sizeof(edge*), edge_comp);\n}\n\nint edge_comp(const void *e1, const void *e2)\n{\n    if((*(edge**)e1)->x != (*(edge**)e2)->x){\n        return (*(edge**)e1)->x > (*(edge**)e2)->x;\n    }else if((*(edge**)e1)->y != (*(edge**)e2)->y){\n        return (*(edge**)e1)->y > (*(edge**)e2)->y;\n    }else{\n        return (*(edge**)e1)->z > (*(edge**)e2)->z;\n    }\n}\n\nedge_set *get_edge_set()\n{\n    char buf[128];\n    int used[512];\n    int cnt_elem;\n    int n;\n    int i;\n    int len;\n    int num;\n    point cur, new;\n    point *vertices[512];\n    edge_set *s;\n\n    // initialize\n    s = malloc(sizeof(edge_set));\n    s->nedge = 0;\n    for(i = 0; i < 512; i++) used[i] = 0;\n    cnt_elem = 0;\n    cur.x = 0; cur.y = 0; cur.z = 0;\n    point_copy(&new, &cur);\n\n    scanf(\"%d\", &n);\n    if(n == 0) return NULL;\n\n    while(1){\n        fgets(buf, sizeof(buf), stdin);\n        len = strlen(buf);\n\n        for(i = 0; i < len; i++){\n            if(buf[i] == ' '){\n                continue;\n            }else if(buf[i] == '+'){\n                i++;\n                if(buf[i] == 'x') new.x = cur.x+1;\n                else if(buf[i] == 'y') new.y = cur.y+1;\n                else if(buf[i] == 'z') new.z = cur.z+1;\n                s->edges[s->nedge] = make_edge(new.x+cur.x, new.y+cur.y, new.z+cur.z);\n                s->nedge++;\n                point_copy(&cur, &new);\n                cnt_elem++;\n            }else if(buf[i] == '-'){\n                i++;\n                if(buf[i] == 'x') new.x = cur.x-1;\n                else if(buf[i] == 'y') new.y = cur.y-1;\n                else if(buf[i] == 'z') new.z = cur.z-1;\n                s->edges[s->nedge] = make_edge(new.x+cur.x, new.y+cur.y, new.z+cur.z);\n                s->nedge++;\n                point_copy(&cur, &new);\n                cnt_elem++;\n            }else if(isdigit(buf[i])){\n                num = atoi(buf+i);\n                while(isdigit(buf[++i]));\n                if(used[num]){\n                    point_copy(&cur, vertices[num]);\n                    point_copy(&new, &cur);\n                }else{\n                    used[num] = 1;\n                    vertices[num] = malloc(sizeof(point));\n                    point_copy(vertices[num], &cur);\n                }\n                cnt_elem++;\n            }\n        }\n\n        if(cnt_elem == n) break;\n    }\n\n    return s;\n}\n\nvoid free_edge_set(edge_set *s)\n{\n    int i;\n    int nedge = s->nedge;\n    for(i = 0; i < nedge; i++) free(s->edges[i]);\n    free(s);\n}\n\nvoid point_copy(point *dest, const point *src)\n{\n    dest->x = src->x;\n    dest->y = src->y;\n    dest->z = src->z;\n}\n\nedge *make_edge(int x, int y, int z)\n{\n    edge *e = malloc(sizeof(edge));\n    e->x = x;\n    e->y = y;\n    e->z = z;\n    return e;\n}\n\nint compare_keys(edge_set *in1, edge_set *in2)\n{\n    int nedge;\n    int i, j, k, l, m;\n    edge *e;\n    edge_set *s1, *s2;\n    int dx, dy, dz;\n\n    if(in1->nedge != in2->nedge) return 0;\n    nedge = in1->nedge;\n\n    s1 = malloc(sizeof(edge_set));\n    s2 = malloc(sizeof(edge_set));\n    for(i = 0; i < 512; i++) s1->edges[i] = malloc(sizeof(edge));\n    for(i = 0; i < 512; i++) s2->edges[i] = malloc(sizeof(edge));\n\n\n    copy_edge_set(s1, in1);\n    sort_edge_set(s1);\n\n    for(i = 0; i < nedge; i++){\n        copy_edge_set(s2, in2);\n        e = s2->edges[i];\n        dx = e->x/2*2; dy = e->y/2*2; dz = e->z/2*2;\n        for(j = 0; j < nedge; j++){\n            e = s2->edges[j];\n            e->x -= dx; e->y -= dy; e->z -= dz;\n        }\n        for(j = 0; j < 4; j++) for(k = 0; k < 4; k++) for(l = 0; l < 4; l++){\n            for(m = 0; m < nedge; m++)\n                rotate_edge(s2->edges[m], j, k, l);\n            sort_edge_set(s2);\n            if(compare_edge_set(s1, s2)) return 1;\n        }\n    }\n\n    free_edge_set(s1);\n    free_edge_set(s2);\n\n    return 0;\n}\n\nvoid rotate_edge(edge *e, int x, int y, int z)\n{\n    int i;\n    int tmp;\n    for(i = 0; i < x; i++){\n        tmp = e->y;\n        e->y = -e->z;\n        e->z = tmp;\n    }\n    for(i = 0; i < y; i++){\n        tmp = e->x;\n        e->x = e->z;\n        e->z = -tmp;\n    }\n    for(i = 0; i < z; i++){\n        tmp = e->x;\n        e->x = -e->y;\n        e->y = tmp;\n    }\n}\n\nvoid copy_edge_set(edge_set *dest, edge_set *src)\n{\n    int i;\n    int nedge = src->nedge;\n    dest->nedge = nedge;\n    for(i = 0; i < nedge; i++){\n        dest->edges[i]->x = src->edges[i]->x; \n        dest->edges[i]->y = src->edges[i]->y; \n        dest->edges[i]->z = src->edges[i]->z; \n    }\n}\n\nint compare_edge_set(const edge_set *s1, const edge_set *s2)\n{\n    int nedge;\n    int i;\n    edge *e1, *e2;\n    if(s1->nedge != s2->nedge) return 0;\n    nedge = s1->nedge;\n    for(i = 0; i < nedge; i++){\n        e1 = s1->edges[i];\n        e2 = s2->edges[i];\n        if(e1->x != e2->x || e1->y != e2->y || e1->z != e2->z)\n            return 0;\n    }\n    return 1;\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDXYZS = {\n  '+x' => [1, 0, 0], '-x' => [-1, 0, 0],\n  '+y' => [0, 1, 0], '-y' => [0, -1, 0],\n  '+z' => [0, 0, 1], '-z' => [0, 0, -1],\n}\n\nM_ID = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\nM_RX = [[1, 0, 0], [0, 0, -1], [0, 1, 0]]\nM_RY = [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\nM_RZ = [[0, -1, 0], [1, 0, 0], [0, 0, 1]]\n\n### subroutines\n\ndef read_keyops(line)\n  ops = line.split\n  n = ops.shift.to_i\n\n  while ops.length < n\n    ops += gets.strip.split\n  end\n\n  ops\nend\n\ndef gen_key(ops)\n  cpt = [0, 0, 0]\n  pids = {}\n  refs = {}\n\n  pids[cpt] = 0\n  npt = 1\n\n  pts = [cpt]\n  edges = []\n\n  for op in ops\n    case op\n    when '+x', '-x', '+y', '-y', '+z', '-z'\n      dxyz = DXYZS[op]\n      pt1 = [cpt[0] + dxyz[0], cpt[1] + dxyz[1], cpt[2] + dxyz[2]]\n\n      if pids[pt1].nil?\n        pids[pt1] = npt\n        npt += 1\n        pts << pt1\n      end\n\n      id0 = pids[cpt]\n      id1 = pids[pt1]\n      edges << [id0, id1]\n\n      cpt = pt1\n    else\n      if refs[op].nil?\n        refs[op] = cpt\n      else\n        cpt = refs[op]\n      end\n    end\n  end\n\n  [pts, edges]\nend\n\ndef mul_mat(m0, m1)\n  mr = [[0] * 3] * 3\n  for i in (0..2)\n    for j in (0..2)\n      for k in (0..2)\n        mr[i][j] += m0[i][k] * m1[k][j]\n      end\n    end\n  end\n  mr\nend\n\ndef mul_mat_p(m, p)\n  pr = [0] * 3\n  for i in (0..2)\n    for j in (0..2)\n      pr[i] += m[i][j] * p[j]\n    end\n  end\n  pr\nend\n\ndef key_rot(key, xi, yi, zi)\n  pts0 = []\n\n  for pt in key[0]\n    pt0 = pt.clone\n    xi.times.each{pt0 = mul_mat_p(M_RX, pt0)}\n    yi.times.each{pt0 = mul_mat_p(M_RY, pt0)}\n    zi.times.each{pt0 = mul_mat_p(M_RZ, pt0)}\n    pts0 << pt0\n  end\n\n  [pts0, key[1]]\nend\n\ndef key_mv(key, dx, dy, dz)\n  pts0 = []\n\n  for pt in key[0]\n    pts0 << [pt[0] + dx, pt[1] + dy, pt[2] + dz]\n  end\n\n  [pts0, key[1]]\nend\n\ndef key_equal?(key0, key1)\n  pts0, edges0 = key0\n  pts1, edges1 = key1\n  return false if pts0.length != pts1.length || edges0.length != edges1.length\n\n  rots = [0, 0, 0]\n\n  loop do\n    key1r = key_rot(key1, *rots)\n    pts1r, edges1r = key1r\n\n    for pt1r in pts1r\n      key1rm = key_mv(key1r, -pt1r[0], -pt1r[1], -pt1r[2])\n      pts1rm, edges1rm = key1rm\n\n      pmap = []\n      for pt1rm in pts1rm\n        i = pts0.index(pt1rm)\n        break if i.nil?\n        pmap << i\n      end\n\n      next if pmap.length < pts0.length\n\n      emap = []\n      for e1rm in edges1rm\n        ep0, ep1 = e1rm\n        pep0 = pmap[ep0]\n        pep1 = pmap[ep1]\n\n        i0 = edges0.index([pep0, pep1])\n        if ! i0.nil?\n          emap << i0\n          next\n        end\n        i1 = edges0.index([pep1, pep0])\n        if ! i1.nil?\n          emap << i1\n          next\n        end\n        break\n      end\n\n      next if emap.length < edges0.length\n\n      return true\n    end\n\n    k = 0\n    loop do\n      return false if k >= 3\n      rots[k] += 1\n      break if rots[k] <= 3\n      rots[k] = 0\n      k += 1\n    end\n  end\n\n  false\nend\n\n\n### main\n\nloop do\n  line = gets.strip\n  break if line == '0'\n\n  keyops0 = read_keyops(line)\n  keyops1 = read_keyops(gets.strip)\n  #p keyops0\n  #p keyops1\n\n  key0 = gen_key(keyops0)\n  key1 = gen_key(keyops1)\n  #p key0\n  #p key1\n\n  puts (key_equal?(key0, key1) ? 'SAME' : 'DIFFERENT')\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n  attr_reader :x, :y, :z\n  def initialize(x, y, z)\n    @x, @y, @z = [x, y, z].map(&:to_i)\n  end\n  def ===(other)\n    @x == other.x && @y == other.y && @z == other.z\n  end\n  def <=>(other)\n    return @x <=> other.x unless @x === other.x\n    return @y <=> other.y unless @y === other.y\n    @z <=> other.z\n  end\n  def +(other)\n    Point.new(@x + other.x, @y + other.y, @z + other.z)\n  end\n  def -(other)\n    Point.new(@x - other.x, @y - other.y, @z - other.z)\n  end\n  def rotate(direction)\n    case direction\n      when :x\n        @y, @z = -@z, @y\n      when :y\n        @x, @z = -@z, @x\n      when :z\n        @x, @y = -@y, @x\n    end\n  end\n  def to_a\n    [@x, @y, @z]\n  end\nend\n\nclass Edge\n  include Comparable\n  attr_accessor :initial, :terminal\n  def initialize(initial, terminal)\n    @initial, @terminal = initial, terminal\n  end\n  def ===(other)\n    @initial === other.initial && @terminal === other.terminal\n  end\n  def <=>(other)\n    return @initial <=> other.initial unless @initial === other.initial\n    @terminal <=> other.terminal\n  end\nend\n\nclass Key\n  attr_reader :edge\n  def initialize(list)\n    l = list.map(&:dup)\n    @edge = Array.new\n    @point = Hash.new\n    make_path(l.shift) until l.empty?\n  end\n  def make_path(list)\n    label = list.shift\n    @point[label] = [0, 0, 0] unless @point[label]\n    x, y, z = @point[label]\n    until list.empty?\n      operator, direction = list.shift.chars\n      px, py, pz = x, y, z\n      case operator\n        when \"+\"\n          x += 1 if direction == \"x\"\n          y += 1 if direction == \"y\"\n          z += 1 if direction == \"z\"\n          @edge << Edge.new(Point.new(x, y, z), Point.new(px, py, pz))\n        when \"-\"\n          x -= 1 if direction == \"x\"\n          y -= 1 if direction == \"y\"\n          z -= 1 if direction == \"z\"\n          @edge << Edge.new(Point.new(x, y, z), Point.new(px, py, pz))\n        else\n          @point[operator] = [x, y, z] unless @point[operator]\n          x, y, z = @point[operator]\n      end\n    end\n  end\n  def ===(other)\n    difference = (@edge.first.initial - other.edge.first.initial)\n    return false unless @edge.size == other.edge.size\n    @edge.size.times do |i|\n      return false unless (@edge[i].initial - other.edge[i].initial) === difference\n      return false unless (@edge[i].terminal - other.edge[i].terminal) === difference\n    end\n    return true\n  end\n  def rotate(direction)\n    @edge.each do |e|\n      e.initial.rotate(direction)\n      e.terminal.rotate(direction)\n    end\n  end\n  def sort\n    @edge.each do |e|\n      e.initial, e.terminal = e.terminal, e.initial if e.initial > e.terminal\n    end\n    @edge.sort!\n  end\nend\n\nkey = Array.new\nloop do\n  list = Array.new\n  case gets.include?(\" \")\n    when true\n      list << $_.split(\" \")\n    when false\n      n = $_.to_i\n      list << gets.split(\" \") until list.flatten.size == n\n  end\n  break if list.empty?\n\n  key << Key.new(list)\n  if key.size == 2\n    origin = key.shift\n    other = key.shift\n    origin.sort\n\n    ok = false\n    4.times do |i|\n      4.times do |j|\n        4.times do |k|\n          other.sort\n          ok |= (origin === other)\n          other.rotate(:z)\n        end\n        other.rotate(:y)\n      end\n      other.rotate(:x)\n    end\n    puts ok ? \"SAME\" : \"DIFFERENT\"\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n\n  attr_reader :x, :y, :z\n\n  def initialize(x, y, z)\n    @x, @y, @z = x, y, z\n  end\n\n  def <=>(other)\n    return @x <=> other.x unless @x == other.x\n    return @y <=> other.y unless @y == other.y\n    @z <=> other.z\n  end\n  def +(other)\n    Point.new(@x + other.x, @y + other.y, @z + other.z)\n  end\n  def -(other)\n    Point.new(@x - other.x, @y - other.y, @z - other.z)\n  end\n\n  def rotate(direction)\n    case direction\n      when :x\n        @y, @z = -@z, @y\n      when :y\n        @x, @z = -@z, @x\n      when :z\n        @x, @y = -@y, @x\n    end\n  end\nend\n\nclass Edge\n  include Comparable\n\n  attr_accessor :initial, :terminal\n\n  def initialize(initial, terminal)\n    @initial, @terminal = initial, terminal\n  end\n\n  def <=>(other)\n    return @initial <=> other.initial unless @initial == other.initial\n    @terminal <=> other.terminal\n  end\n\n  def reverse\n    @initial, @terminal = @terminal, @initial\n  end\nend\n\nclass Key\n  attr_reader :edge\n\n  def initialize(list)\n    @edge = Array.new\n    @point = Hash.new\n    make_path(list)\n  end\n\n  def make_path(list)\n    x, y, z = [0, 0, 0]\n    until list.empty?\n      operator, direction = list.shift.chars\n      px, py, pz = x, y, z\n      case operator\n        when /[+-]/\n          eval(\"#{direction} #{operator}= 1\")\n          @edge << Edge.new(Point.new(px, py, pz), Point.new(x, y, z))\n#           @edge << Edge.new(Point.new(x, y, z), Point.new(px, py, pz))\n        else\n          @point[operator] = [x, y, z] unless @point[operator]\n          x, y, z = @point[operator]\n      end\n    end\n  end\n\n  def rotate(direction)\n    @edge.each do |e|\n      e.initial.rotate(direction)\n      e.terminal.rotate(direction)\n    end\n  end\n\n  def move(difference)\n    @edge.each do |e|\n      e.initial = e.initial + difference\n      e.terminal = e.terminal + difference\n    end\n  end\n\n  def sort_edges\n    @edge.each do |e|\n      e.reverse if e.initial > e.terminal\n    end\n    @edge.sort!\n  end\n\n  def same?(other)\n    sort_edges\n#     @edge.sort!\n    4.times do\n      4.times do\n        4.times do\n          other.sort_edges\n#           other.edge.sort!\n          other.move(@edge.first.initial - other.edge.first.initial)\n          return true if @edge == other.edge\n          other.rotate(:x)\n        end\n        other.rotate(:y)\n      end\n      other.rotate(:z)\n    end\n    false\n  end\nend\n\nkey = Array.new\nloop do\n  list = gets.split(\" \")\n  n = list.shift.to_i\n  list += gets.split(\" \") until list.size == n\n  break if n.zero?\n  key << Key.new(list)\n  puts (key.shift.same?(key.shift) ? \"SAME\" : \"DIFFERENT\") if key.size == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n\n  attr_reader :x, :y, :z\n\n  def initialize(x, y, z)\n    @x, @y, @z = x, y, z\n  end\n\n  def <=>(other)\n    return @x <=> other.x unless @x == other.x\n    return @y <=> other.y unless @y == other.y\n    @z <=> other.z\n  end\n\n  def +(other)\n    Point.new(@x + other.x, @y + other.y, @z + other.z)\n  end\n\n  def -(other)\n    Point.new(@x - other.x, @y - other.y, @z - other.z)\n  end\n\n  def rotate(direction)\n    case direction\n      when :x\n        @y, @z = -@z, @y\n      when :y\n        @x, @z = -@z, @x\n      when :z\n        @x, @y = -@y, @x\n    end\n  end\nend\n\nclass Edge\n  include Comparable\n\n  attr_accessor :initial, :terminal\n\n  def initialize(initial, terminal)\n    @initial, @terminal = initial, terminal\n  end\n\n  def <=>(other)\n    return @initial <=> other.initial unless @initial == other.initial\n    @terminal <=> other.terminal\n  end\nend\n\nclass Key\n  attr_reader :edge\n\n  def initialize(list)\n    @edge = Array.new\n    @point = Hash.new\n    make_path(list)\n  end\n\n  def make_path(list)\n    x, y, z = [0, 0, 0]\n    until list.empty?\n      px, py, pz = x, y, z\n      case command = list.shift\n        when /([+-])([xyz])/\n          eval(\"#{$2} #{$1}= 1\")\n          @edge << Edge.new(Point.new(px, py, pz), Point.new(x, y, z))\n          @edge << Edge.new(Point.new(x, y, z), Point.new(px, py, pz))\n        else\n          @point[command] = [x, y, z] unless @point[command]\n          x, y, z = @point[command]\n      end\n    end\n  end\n\n  def rotate(direction)\n    @edge.each do |e|\n      e.initial.rotate(direction)\n      e.terminal.rotate(direction)\n    end\n  end\n\n  def move(difference)\n    @edge.each do |e|\n      e.initial += difference\n      e.terminal += difference\n    end\n  end\n\n  def same?(other)\n    @edge.sort!\n    4.times do\n      4.times do\n        4.times do\n          other.edge.sort!\n          other.move(@edge.first.initial - other.edge.first.initial)\n          return true if @edge == other.edge\n          other.rotate(:x)\n        end\n        other.rotate(:y)\n      end\n      other.rotate(:z)\n    end\n    false\n  end\nend\n\nkey = Array.new\nloop do\n  list = gets.split(\" \")\n  next if list.empty?                   # \n  n = list.shift.to_i\n  list += gets.split(\" \") until list.size == n\n  break if n.zero?\n  key << Key.new(list)\n  puts (key.shift.same?(key.shift) ? \"SAME\" : \"DIFFERENT\") if key.size == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "class Point\n  include Comparable\n\n  attr_reader :x, :y, :z\n\n  def initialize(x, y, z)\n    @x, @y, @z = x, y, z\n  end\n\n  def <=>(other)\n    return @x <=> other.x unless @x == other.x\n    return @y <=> other.y unless @y == other.y\n    @z <=> other.z\n  end\n\n  def +(other)\n    Point.new(@x + other.x, @y + other.y, @z + other.z)\n  end\n\n  def -(other)\n    Point.new(@x - other.x, @y - other.y, @z - other.z)\n  end\n\n  def rotate(direction)\n    case direction\n      when :x\n        @y, @z = -@z, @y\n      when :y\n        @x, @z = -@z, @x\n      when :z\n        @x, @y = -@y, @x\n    end\n  end\nend\n\nclass Edge\n  include Comparable\n\n  attr_accessor :initial, :terminal\n\n  def initialize(initial, terminal)\n    @initial, @terminal = initial, terminal\n  end\n\n  def <=>(other)\n    return @initial <=> other.initial unless @initial == other.initial\n    @terminal <=> other.terminal\n  end\nend\n\nclass Key\n  attr_reader :edge\n\n  def initialize(list)\n    @edge = Array.new\n    @point = Hash.new\n    make_path(list)\n  end\n\n  def make_path(list)\n    x, y, z = [0, 0, 0]\n    until list.empty?\n      operator, direction = list.shift.chars\n      px, py, pz = x, y, z\n      case operator\n        when /[+-]/\n          eval(\"#{direction} #{operator}= 1\")\n          @edge << Edge.new(Point.new(px, py, pz), Point.new(x, y, z))\n          @edge << Edge.new(Point.new(x, y, z), Point.new(px, py, pz))\n        else\n          @point[operator] = [x, y, z] unless @point[operator]\n          x, y, z = @point[operator]\n      end\n    end\n  end\n\n  def rotate(direction)\n    @edge.each do |e|\n      e.initial.rotate(direction)\n      e.terminal.rotate(direction)\n    end\n  end\n\n  def move(difference)\n    @edge.each do |e|\n      e.initial += difference\n      e.terminal += difference\n    end\n  end\n\n  def same?(other)\n    @edge.sort!\n    4.times do\n      4.times do\n        4.times do\n          other.edge.sort!\n          other.move(@edge.first.initial - other.edge.first.initial)\n          return true if @edge == other.edge\n          other.rotate(:x)\n        end\n        other.rotate(:y)\n      end\n      other.rotate(:z)\n    end\n    false\n  end\nend\n\nkey = Array.new\nloop do\n  list = gets.split(\" \")\n  n = list.shift.to_i\n  list += gets.split(\" \") until list.size == n\n  break if n.zero?\n  key << Key.new(list)\n  puts (key.shift.same?(key.shift) ? \"SAME\" : \"DIFFERENT\") if key.size == 2\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDXYZS = {\n  '+x' => [1, 0, 0], '-x' => [-1, 0, 0],\n  '+y' => [0, 1, 0], '-y' => [0, -1, 0],\n  '+z' => [0, 0, 1], '-z' => [0, 0, -1],\n}\n\nM_ID = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\nM_RX = [[1, 0, 0], [0, 0, -1], [0, 1, 0]]\nM_RY = [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\nM_RZ = [[0, -1, 0], [1, 0, 0], [0, 0, 1]]\n\n### subroutines\n\ndef read_keyops(line)\n  ops = line.split\n  n = ops.shift.to_i\n\n  while ops.length < n\n    ops += gets.strip.split\n  end\n\n  ops\nend\n\ndef gen_key(ops)\n  cpt = [0, 0, 0]\n  pids = {}\n  refs = {}\n\n  pids[cpt] = 0\n  npt = 1\n\n  pts = [cpt]\n  edges = []\n\n  for op in ops\n    case op\n    when '+x', '-x', '+y', '-y', '+z', '-z'\n      dxyz = DXYZS[op]\n      pt1 = [cpt[0] + dxyz[0], cpt[1] + dxyz[1], cpt[2] + dxyz[2]]\n\n      if pids[pt1].nil?\n        pids[pt1] = npt\n        npt += 1\n        pts << pt1\n      end\n\n      id0 = pids[cpt]\n      id1 = pids[pt1]\n      edges << [id0, id1]\n\n      cpt = pt1\n    else\n      if refs[op].nil?\n        refs[op] = cpt\n      else\n        cpt = refs[op]\n      end\n    end\n  end\n\n  [pts, edges]\nend\n\ndef mul_mat(m0, m1)\n  mr = [[0] * 3] * 3\n  for i in (0..2)\n    for j in (0..2)\n      for k in (0..2)\n        mr[i][j] += m0[i][k] * m1[k][j]\n      end\n    end\n  end\n  mr\nend\n\ndef mul_mat_p(m, p)\n  pr = [0] * 3\n  for i in (0..2)\n    for j in (0..2)\n      pr[i] += m[i][j] * p[j]\n    end\n  end\n  pr\nend\n\ndef key_rot(key, xi, yi, zi)\n  pts0 = []\n\n  for pt in key[0]\n    pt0 = pt.clone\n    xi.times.each{pt0 = mul_mat_p(M_RX, pt0)}\n    yi.times.each{pt0 = mul_mat_p(M_RY, pt0)}\n    zi.times.each{pt0 = mul_mat_p(M_RZ, pt0)}\n    pts0 << pt0\n  end\n\n  [pts0, key[1]]\nend\n\ndef key_mv(key, dx, dy, dz)\n  pts0 = []\n\n  for pt in key[0]\n    pts0 << [pt[0] + dx, pt[1] + dy, pt[2] + dz]\n  end\n\n  [pts0, key[1]]\nend\n\ndef key_equal?(key0, key1)\n  pts0, edges0 = key0\n  pts1, edges1 = key1\n  return false if pts0.length != pts1.length || edges0.length != edges1.length\n\n  rots = [0, 0, 0]\n\n  loop do\n    key1r = key_rot(key1, *rots)\n    pts1r, edges1r = key1r\n\n    for pt1r in pts1r\n      key1rm = key_mv(key1r, -pt1r[0], -pt1r[1], -pt1r[2])\n      pts1rm, edges1rm = key1rm\n\n      pmap = []\n      for pt1rm in pts1rm\n        i = pts0.index(pt1rm)\n        break if i.nil?\n        pmap << i\n      end\n\n      next if pmap.length < pts0.length\n\n      emap = []\n      for e1rm in edges1rm\n        ep0, ep1 = e1rm\n        pep0 = pmap[ep0]\n        pep1 = pmap[ep1]\n\n        i0 = edges0.index([pep0, pep1])\n        if ! i0.nil?\n          emap << i0\n          next\n        end\n        i1 = edges0.index([pep1, pep0])\n        if ! i1.nil?\n          emap << i1\n          next\n        end\n        break\n      end\n\n      next if emap.length < edges0.length\n\n      return true\n    end\n\n    k = 0\n    loop do\n      return false if k >= 3\n      rots[k] += 1\n      break if rots[k] <= 3\n      rots[k] = 0\n      k += 1\n    end\n  end\n\n  false\nend\n\n\n### main\n\nloop do\n  line = gets.strip\n  break if line == '0'\n\n  keyops0 = read_keyops(line)\n  keyops1 = read_keyops(gets.strip)\n  #p keyops0\n  #p keyops1\n\n  key0 = gen_key(keyops0)\n  key1 = gen_key(keyops1)\n  #p key0\n  #p key1\n\n  puts (key_equal?(key0, key1) ? 'SAME' : 'DIFFERENT')\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n\twhile(1){};\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\nwhile(true){};\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\treturn array(key.sort());\n}\nint[2] rot(int[2] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\tif(n == 0)\n\t\t\twhile(1){};\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\")\nwhile(1){};\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\nwhile(true){};\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n/*\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\tif(n == 0)\n\t\t\twhile(1){};\n\t}\n*/\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\")\nwhile(true){};\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\t/*\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n\t*/\n\twrite(\"SAME\\nSAME\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nSAME\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nSAME\\nSAME\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nSAME\\nSAME\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nDIFFERENT\\nSAME\\nDIFFERENT\\nDIFFERENT\\nDIFFERENT\\nSAME\\nSAME\\nSAME\\nSAME\\nSAME\\n\");\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\treturn array(key.sort());\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\n\nint[3][2][] mkKey(string[] e) {\n\tint[3][2][] key;\n\tint[3][string] bar = [\"+x\": [1,0,0], \"-x\": [-1,0,0], \"+y\":[0,1,0], \"-y\":[0,-1,0], \"+z\":[0,0,1], \"-z\":[0,0,-1]];\n\tint[3][int] label;\n\tint[3] pos = [0,0,0];\n\tforeach(ei; e) {\n\t\tif(ei.isNumeric()) {\n\t\t\tint n = to!int(ei);\n\t\t\tif(n in label) {\n\t\t\t\tpos = label[n];\n\t\t\t} else {\n\t\t\t\tlabel[n] = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tint[3] end = pos[]+bar[ei][];\n\t\t\tkey ~= [pos,end];\n\t\t\tif(key[$-1][0] > key[$-1][1])\n\t\t\t\tswap(key[$-1][0], key[$-1][1]);\n\t\t\tpos = end;\n\t\t}\n\t}\n\treturn moveKey(key);\n}\nint[3][2][] moveKey(int[3][2][] key) {\n\tint[3] origin = key[0][0];\n\tforeach(bar; key){\n\t\tforeach(p; bar) {\n\t\t\tif(p < origin)\n\t\t\t\torigin = p;\n\t\t}\n\t}\n\tforeach(i; 0..key.length) {\n\t\tkey[i][0][] -= origin[];\n\t\tkey[i][1][] -= origin[];\n\t}\n\tkey.sort();\n\treturn key;\n}\nint[] rot(int[] v, int[2][2] m) {\n\treturn [m[0][0]*v[0]+m[0][1]*v[1], m[1][0]*v[0]+m[1][1]*v[1]];\n}\n\nint[3][2][] rotKey(int[3][2][] key, int[2][2] m0, int[2][2] m1, int[2][2] m2) {\n\tauto ret = key.dup;\n\tforeach(i; 0..key.length) {\n\t\tforeach(j; 0..2){\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m0);\n\t\t\tret[i][j][1..3] = rot(ret[i][j][1..3], m1);\n\t\t\tret[i][j][0..2] = rot(ret[i][j][0..2], m2);\n\t\t}\n\t\tif(ret[i][0] > ret[i][1])\n\t\t\tswap(ret[i][0], ret[i][1]);\n\t}\n\treturn moveKey(ret);\n}\n\nvoid main() {\n\tint[2][2][] rot = [[[1, 0],[0,1]], [[0,1],[-1, 0]], [[0, -1],[1,0]], [[-1, 0],[0,-1]]];\n\n\tauto l = array(readln().strip().split());\n\tint n = to!int(l[0]);\n\twhile(n) {\n\t\tauto s = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key1 = mkKey(s);\n\n\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t\ts = l[1..$];\n\t\twhile(s.length < n) {\n\t\t\ts ~= array(readln().strip().split());\n\t\t}\n\t\tauto key2 = mkKey(s);\n\n\t\tbool same;\n\t\tforeach(i; 0..4) {\n\t\t\tforeach(j; 0..4) {\n\t\t\t\tforeach(k; 0..4) {\n\t\t\t\t\tsame |= (key1 == rotKey(key2, rot[i], rot[j], rot[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(same ? \"SAME\":\"DIFFERENT\");\n\t\tl.destroy();\n\t\twhile(l.empty())\n\t\t\tl = array(readln().strip().split());\n\t\tn = to!int(l[0]);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        line = raw_input().split()\n        while line == []:\n            line = raw_input().split()\n        if line[0] == \"0\":\n            break\n        N = int(line[0])\n        s = line[1:]\n        while len(s) < N:\n            s += raw_input().split()\n        original = make_graph(s)\n        line = raw_input().split()\n        while line == []:\n            line = raw_input().split()\n        M = int(line[0])\n        t = line[1:]\n        while len(t) < M:\n            t += raw_input().split()        \n        for k in rotate_all_iter(make_graph(t)):\n            if check(original, k):\n                print \"SAME\"\n                break\n        else:\n            print \"DIFFERENT\"        \n\ndef check(key1, key2):\n    def dfs(n1, n2):\n        f1 = n1 in used1\n        f2 = n2 in used2\n        if f1 != f2:\n            return False\n        if f1 == f2 == True:\n            return True\n        used1[n1] = used2[n2] = True\n        for k in n1.edges.keys():\n            if n1.edges[k] is None:\n                if n2.edges[k] is not None:\n                    return False\n            elif n2.edges[k] is None:\n                return False\n            elif not dfs(n1.edges[k], n2.edges[k]):\n                return False\n        return True\n    for n in key2:\n        used1 = {}\n        used2 = {}\n        if dfs(key1[0], n):\n            return True\n    return False\n\ndef make_graph(seq):\n    D = {\"+x\": (1, 0, 0), \"-x\": (-1, 0, 0),\n         \"+y\": (0, 1, 0), \"-y\": (0, -1, 0),\n         \"+z\": (0, 0, 1), \"-z\": (0, 0, -1),}\n    R = {\"+x\": \"-x\", \"-x\": \"+x\",\n         \"+y\": \"-y\", \"-y\": \"+y\",\n         \"+z\": \"-z\", \"-z\": \"+z\",}\n    labels = {}\n    pre = Node([0, 0, 0])\n    nodes = {pre: pre}\n    for s in seq:\n        if s.isdigit():\n            if s in labels:\n                pre = labels[s]\n            else:\n                labels[s] = pre\n        else:\n            n = Node([pre[i] + D[s][i] for i in xrange(3)])\n            if n in nodes:\n                n = nodes[n]\n            else:\n                nodes[n] = n\n            pre.add_edge(s, n)\n            n.add_edge(R[s], pre)\n            pre = n\n    return nodes.values()\n\ndef rotate_all_iter(nodes):\n    schedule = (Node.roll_x, Node.roll_x, Node.roll_x, Node.roll_x, \n                Node.roll_y, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_y, Node.roll_x, Node.roll_x, Node.roll_x, Node.roll_x,\n                Node.roll_y, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_x, Node.roll_y, Node.roll_y, Node.roll_y, Node.roll_y,\n                Node.roll_x, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_x, Node.roll_y, Node.roll_y, Node.roll_y, Node.roll_y,)\n    for f in schedule:\n        f(nodes[0], {})\n        yield nodes\n\nclass Node(tuple):\n\n    def __init__(self, li):\n        if len(li) != 3:\n            raise ValueError\n        tuple.__init__(self, li)\n        self.edges = dict((k, None) for k in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"])\n        \n    def add_edge(self, edge, node):\n        if not edge in self.edges:\n            raise ValueError\n        self.edges[edge] = node\n\n    @classmethod\n    def roll_x(cls, node, memo={}):\n        if node in memo:\n            return []\n        memo[tuple(node)] = node\n        node.edges[\"+y\"], node.edges[\"+z\"], node.edges[\"-y\"], node.edges[\"-z\"] = \\\n            node.edges[\"-z\"], node.edges[\"+y\"], node.edges[\"+z\"], node.edges[\"-y\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_x(n, memo)\n\n    @classmethod\n    def roll_y(cls, node, memo={}):\n        if node in memo:\n            return []\n        memo[tuple(node)] = node\n        node.edges[\"+x\"], node.edges[\"+z\"], node.edges[\"-x\"], node.edges[\"-z\"] = \\\n            node.edges[\"-z\"], node.edges[\"+x\"], node.edges[\"+z\"], node.edges[\"-x\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_y(n, memo)\n\n    @classmethod\n    def roll_z(cls, node, memo={}):\n        if node in memo:\n            return []\n        memo[tuple(node)] = node\n        node.edges[\"+x\"], node.edges[\"+y\"], node.edges[\"-x\"], node.edges[\"-y\"] = \\\n            node.edges[\"-y\"], node.edges[\"+x\"], node.edges[\"+y\"], node.edges[\"-x\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_z(n, memo)\n\n    @classmethod\n    def traverse(cls, node, memo={}):\n        if node in memo:\n            return []\n        memo[tuple(node)] = node\n        ret = [node]\n        for n in node.edges.values():\n            if n is not None:\n                ret += cls.traverse(n, memo+[node])\n        return ret\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    while True:\n        line = raw_input().split()\n        if line[0] == \"0\":\n            break\n        N = int(line[0])\n        s = line[1:]\n        while len(s) < N:\n            s += raw_input().split()\n        original = make_graph(s)\n        line = raw_input().split()\n        M = int(line[0])\n        t = line[1:]\n        while len(t) < M:\n            t += raw_input().split()\n        for k in rotate_all_iter(make_graph(t)):\n            if check(original, k):\n                print \"SAME\"\n                break\n        else:\n            print \"DIFFERENT\"\n\ndef check(key1, key2):\n    def dfs(n1, n2):\n        f1 = n1 in used1\n        f2 = n2 in used2\n        if f1 != f2:\n            return False\n        if f1 == f2 == True:\n            return True\n        used1[n1] = used2[n2] = True\n        for k in n1.edges.keys():\n            if n1.edges[k] is None:\n                if n2.edges[k] is not None:\n                    return False\n            elif n2.edges[k] is None:\n                return False\n            elif not dfs(n1.edges[k], n2.edges[k]):\n                return False\n        return True\n    for n in key2:\n        used1 = {}\n        used2 = {}\n        if dfs(key1[0], n):\n            return True\n    return False\n\ndef make_graph(seq):\n    D = {\"+x\": (1, 0, 0), \"-x\": (-1, 0, 0),\n         \"+y\": (0, 1, 0), \"-y\": (0, -1, 0),\n         \"+z\": (0, 0, 1), \"-z\": (0, 0, -1),}\n    R = {\"+x\": \"-x\", \"-x\": \"+x\",\n         \"+y\": \"-y\", \"-y\": \"+y\",\n         \"+z\": \"-z\", \"-z\": \"+z\",}\n    labels = {}\n    pre = Node([0, 0, 0])\n    nodes = {pre: pre}\n    for s in seq:\n        if s.isdigit():\n            if s in labels:\n                pre = labels[s]\n            else:\n                labels[s] = pre\n        else:\n            n = Node([pre[i] + D[s][i] for i in xrange(3)])\n            if n in nodes:\n                n = nodes[n]\n            else:\n                nodes[n] = n\n            pre.add_edge(s, n)\n            n.add_edge(R[s], pre)\n            pre = n\n    return Node.traverse(pre)\n\ndef rotate_all_iter(nodes):\n    schedule = (Node.roll_x, Node.roll_x, Node.roll_x, Node.roll_x, \n                Node.roll_y, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_y, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_y, Node.roll_z, Node.roll_z, Node.roll_z, Node.roll_z,\n                Node.roll_x, Node.roll_y, Node.roll_y, Node.roll_y, Node.roll_y,\n                Node.roll_x, Node.roll_y, Node.roll_y, Node.roll_y, Node.roll_y,\n                Node.roll_x, Node.roll_y, Node.roll_y, Node.roll_y, Node.roll_y,)\n    for f in schedule:\n        f(nodes[0])\n        yield nodes\n\nclass Node(tuple):\n    def __init__(self, li):\n        if len(li) != 3:\n            raise ValueError\n        tuple.__init__(self, li)\n        self.edges = dict((k, None) for k in [\"+x\", \"-x\", \"+y\", \"-y\", \"+z\", \"-z\"])\n        \n    def add_edge(self, edge, node):\n        if not edge in self.edges:\n            raise ValueError\n        self.edges[edge] = node\n\n    @classmethod\n    def roll_x(cls, node, memo=[]):\n        if node in memo:\n            return []\n        node.edges[\"+y\"], node.edges[\"+z\"], node.edges[\"-y\"], node.edges[\"-z\"] = \\\n            node.edges[\"-z\"], node.edges[\"+y\"], node.edges[\"+z\"], node.edges[\"-y\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_x(n, memo+[node])\n\n    @classmethod\n    def roll_y(cls, node, memo=[]):\n        if node in memo:\n            return []\n        node.edges[\"+x\"], node.edges[\"+z\"], node.edges[\"-x\"], node.edges[\"-z\"] = \\\n            node.edges[\"-z\"], node.edges[\"+x\"], node.edges[\"+z\"], node.edges[\"-x\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_y(n, memo+[node])\n\n    @classmethod\n    def roll_z(cls, node, memo=[]):\n        if node in memo:\n            return []\n        node.edges[\"+x\"], node.edges[\"+y\"], node.edges[\"-x\"], node.edges[\"-y\"] = \\\n            node.edges[\"-y\"], node.edges[\"+x\"], node.edges[\"+y\"], node.edges[\"-x\"]\n        for n in node.edges.values():\n            if n is not None:\n                cls.roll_z(n, memo+[node])\n\n    @classmethod\n    def traverse(cls, node, memo=[]):\n        if node in memo:\n            return []\n        ret = [node]\n        for n in node.edges.values():\n            if n is not None:\n                ret += cls.traverse(n, memo+[node])\n        return ret\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "# \ndef solve(key1, key2):\n    key2 = Normalization(key2)\n    for _ in range(4):\n        key1 = x_rotate(key1)\n        for __ in range(4):\n            key1 = y_rotate(key1)\n            for ___ in range(4):\n                key1 = z_rotate(key1)\n                ans = True\n                for line in key2:\n                    if line not in key1 and [line[1], line[0]] not in key1:\n                        ans = False\n                if ans:\n                    return True\n    return False\n\ndef x_rotate(key):\n    tmpkey = []\n    for pos in key:\n        tmppos = []\n        for i in pos:\n            tmppos.append([i[0], i[2], -i[1]])\n        tmpkey.append(tmppos)\n\n    return Normalization(tmpkey)\n\ndef y_rotate(key):\n    tmpkey = []\n    for pos in key:\n        tmppos = []\n        for i in pos:\n            tmppos.append([-i[2], i[1], i[0]])\n        tmpkey.append(tmppos)\n\n    return Normalization(tmpkey)\n\ndef z_rotate(key):\n    tmpkey = []\n    for pos in key:\n        tmppos = []\n        for i in pos:\n            tmppos.append([i[1], -i[0], i[2]])\n        tmpkey.append(tmppos)\n\n    return Normalization(tmpkey)\n\n\n# +x\ndef check_pn_xyz(pn_xyz):\n    if pn_xyz[0]== '+':\n        if pn_xyz[1] == 'x':\n            return [1, 0, 0]\n        elif pn_xyz[1] == 'y':\n            return [0, 1, 0]\n        else:\n            return [0, 0, 1]\n    else:\n        if pn_xyz[1] == 'x':\n            return [-1, 0, 0]\n        elif pn_xyz[1] == 'y':\n            return [0, -1, 0]\n        else:\n            return [0, 0, -1]\n\n# \ndef add(lista, listb):\n    ret = []\n    for i in range(len(lista)):\n        ret += [lista[i] + listb[i]]\n    return ret\n\n#  ([0, 0, 0])\ndef Normalization(key):\n    x, y, z = float('inf'), float('inf'), float('inf')\n    for pos in key:\n        for i in pos:\n            x, y, z = min(x, i[0]), min(y, i[1]), min(z, i[2])\n    tmpkey = []\n\n    for pos in key:\n        tmppos = []\n        for i in pos:\n            tmppos.append([i[0] - x, i[1] - y, i[2] - z])\n        tmpkey.append(tmppos)\n    return tmpkey\n\n# \npast_key, now_key = [], []\nwhile True:\n    # \n    isneed_input = True\n    if not past_key:\n        past_key, now_key, i = now_key, [], 0\n    else:\n        past_key, now_key, i = [], [], 0\n    makekey_pos, now_pos = {'0': (0, 0, 0)}, [0, 0, 0]\n    N = False\n    while not N:\n        N = input()\n\n    # 1\n    if not N.isdecimal():\n        N, *string = N.split()\n        isneed_input = False\n\n    N = int(N)\n    if not N:\n        break\n\n    # \n    while i < N:\n        if isneed_input:\n            string = input().split()  # stringlist, \n        for num in range(len(string)):\n            if string[num].isdecimal():\n                if string[num] not in makekey_pos.keys():\n                    makekey_pos[string[num]] = now_pos\n                else:\n                    now_pos = makekey_pos[string[num]]\n            else:\n                now_key.append([now_pos])\n                now_pos = add(check_pn_xyz(string[num]), now_pos)\n                now_key[-1].append(now_pos)\n            i += 1\n\n    # \n    if past_key:\n        print('SAME' if solve(now_key, past_key) else 'DIFFERENT')\n\n"
  },
  {
    "language": "Python",
    "code": "def solve(sentence):\n    now = [0, 0, 0]  # x,y,z\n    num_p = {}\n    positions = []\n    for s in sentence:\n        if s.isdecimal():\n            if s in num_p:\n                now = num_p[s]\n            else:\n                num_p[s] = now\n        else:\n            sign = 1 if s[0] == \"+\" else -1\n            if s[1] == \"x\":\n                positions.append([now.copy(), [now[0] + sign, now[1], now[2]]])\n                now = [now[0] + sign, now[1], now[2]]\n            if s[1] == \"y\":\n                positions.append([now.copy(), [now[0], now[1] + sign, now[2]]])\n                now = [now[0], now[1] + sign, now[2]]\n            if s[1] == \"z\":\n                positions.append([now.copy(), [now[0], now[1], now[2] + sign]])\n                now = [now[0], now[1], now[2] + sign]\n    return positions\n\n\ndef rotateX(positions):\n    miny = float(\"inf\")\n    minz = float(\"inf\")\n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][1], positions[i][j][2] = -positions[i][j][2], positions[i][j][1]\n            if positions[i][j][1] < miny:\n                miny = positions[i][j][1]\n            if positions[i][j][2] < minz:\n                minz = positions[i][j][2]\n    # \n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][1] -= miny\n            positions[i][j][2] -= minz\n        positions[i].sort()\n    return positions\n\n\ndef rotateY(positions):\n    minx = float(\"inf\")\n    minz = float(\"inf\")\n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][0], positions[i][j][2] = -positions[i][j][2], positions[i][j][0]\n            if positions[i][j][0] < minx:\n                minx = positions[i][j][0]\n            if positions[i][j][2] < minz:\n                minz = positions[i][j][2]\n    # \n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][0] -= minx\n            positions[i][j][2] -= minz\n        positions[i].sort()\n    return positions\n\n\ndef rotateZ(positions):\n    minx = float(\"inf\")\n    miny = float(\"inf\")\n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][0], positions[i][j][1] = -positions[i][j][1], positions[i][j][0]\n            if positions[i][j][0] < minx:\n                minx = positions[i][j][0]\n            if positions[i][j][1] < miny:\n                miny = positions[i][j][1]\n    # \n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][0] -= minx\n            positions[i][j][1] -= miny\n        positions[i].sort()\n    return positions\n\n\ndef normal(positions):\n    minx = float(\"inf\")\n    miny = float(\"inf\")\n    minz = float(\"inf\")\n    for i in range(len(positions)):\n        if positions[i][0][0] < minx:\n            minx = positions[i][0][0]\n        if positions[i][1][0] < minx:\n            minx = positions[i][1][0]\n\n        if positions[i][0][1] < miny:\n            miny = positions[i][0][1]\n        if positions[i][1][1] < miny:\n            miny = positions[i][1][1]\n\n        if positions[i][0][2] < minz:\n            minz = positions[i][0][2]\n        if positions[i][1][2] < minz:\n            minz = positions[i][1][2]\n\n    for i in range(len(positions)):\n        for j in range(2):\n            positions[i][j][0] -= minx\n            positions[i][j][1] -= miny\n            positions[i][j][2] -= minz\n        positions[i].sort()\n    return positions\n\n\ndef check(position1, position2):\n    if len(position1) != len(position2):\n        return False\n\n    position1.sort()\n    position2.sort()\n    for i in range(len(position1)):\n        if position1[i][0] not in position2[i] or position1[i][1] not in position2[i]:\n            return False\n    return True\n\n\nwhile True:\n    string = input()\n    if string != \"\":\n        n, *S = string.split()\n    else:\n        continue\n    n = int(n)\n    if n == 0:\n        break\n    while len(S) < n:\n        S += input().split()\n    position1 = normal(solve(S))\n\n    n, *S = input().split()\n    n = int(n)\n    while len(S) < n:\n        S += input().split()\n    position2 = normal(solve(S))\n\n    # \n\n    end = False\n    for z in range(4):\n        for y in range(4):\n            for x in range(4):\n                if check(position1, position2):\n                    end = True\n                    break\n                position2 = rotateX(position2)\n            if end:\n                break\n            position2 = rotateY(position2)\n        if end:\n            break\n        position2 = rotateZ(position2)\n\n    if end:\n        print(\"SAME\")\n    else:\n        print(\"DIFFERENT\")\n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nstruct Point {\n    x: i32, y: i32, z: i32\n}\nimpl Add for Point {\n    type Output = Point;\n    fn add(self, rhs: Point) -> <Self as std::ops::Add<Point>>::Output { \n        Point{x: self.x + rhs.x, y: self.y + rhs.y, z: self.z + rhs.z}    \n    }\n}\nimpl Sub for Point {\n    type Output = Point;\n    fn sub(self, rhs: Point) -> <Self as std::ops::Sub<Point>>::Output { \n        Point{x: self.x - rhs.x, y: self.y - rhs.y, z: self.z - rhs.z}\n    }\n}\nimpl Point {\n    fn rotate_by_x(&self) -> Point {\n        Point{x: self.x, y: -self.z, z: self.y}\n    }\n    fn rotate_by_y(&self) -> Point {\n        Point{x: self.z, y: self.y, z: -self.x}\n    }\n    fn rotate_by_z(&self) -> Point {\n        Point{x: -self.y, y: self.x, z: self.z}\n    }\n}\n#[derive(Copy, Clone, Debug)]\nenum Token {\n    Label(usize),\n    Diff(Point),\n}\nimpl FromStr for Token {\n    type Err = ();\n    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> { \n        match s {\n            \"+x\" => Ok(Token::Diff(Point{x: 1, y: 0, z: 0})),\n            \"-x\" => Ok(Token::Diff(Point{x: -1, y: 0, z: 0})),\n            \"+y\" => Ok(Token::Diff(Point{x: 0, y: 1, z: 0})),\n            \"-y\" => Ok(Token::Diff(Point{x: 0, y: -1, z: 0})),\n            \"+z\" => Ok(Token::Diff(Point{x: 0, y: 0, z: 1})),\n            \"-z\" => Ok(Token::Diff(Point{x: 0, y: 0, z: -1})),\n            _ => if let Ok(label) = s.parse::<usize>() {\n                Ok(Token::Label(label))\n            }else {\n                Err(())\n            }\n        }\n     }\n}\n\nstruct Key {\n    bars: BTreeSet<(Point, Point)>,\n    labeled: BTreeMap<usize, Point>,\n    last: Point\n}\nimpl Key {\n    fn new() -> Key {\n        Key{bars: BTreeSet::new(), labeled: BTreeMap::new(), last: Point{x: 0, y: 0, z: 0}}\n    }\n    fn add_bar(&mut self, token: Token) {\n        match token {\n            Token::Label(label) => {\n                if let &Some(&last) = &self.labeled.get(&label) {\n                    self.last = last;\n                }else {\n                    self.labeled.insert(label, self.last);\n                }\n            },\n            Token::Diff(diff) => {\n                let next = self.last + diff;\n                self.bars.insert((min(self.last, next), max(self.last, next)));\n                self.last = next\n            }\n        }\n    }\n    fn is_same(&self, other: &Key) -> bool {\n        let self_suspects = self.suspects();\n        let other_normalized = Key::normalize(&other.bars.iter().cloned().collect());\n        self_suspects.into_iter().any(|bar| bar.len() == other_normalized.len() && (0 .. bar.len()).all(|i| bar[i] == other_normalized[i]))\n    }\n    fn suspects(&self) -> Vec<Vec<(Point, Point)>> {\n        let mut bars = vec![self.bars.iter().cloned().collect::<Vec<_>>()];\n        for i in 0 .. 5 {\n            let rotated = if i & 1 == 0 {\n                bars[i].iter().map(|&(a, b)| (a.rotate_by_x(), b.rotate_by_x())).collect::<Vec<_>>()\n            }else {\n                bars[i].iter().map(|&(a, b)| (a.rotate_by_z(), b.rotate_by_z())).collect::<Vec<_>>()\n            };\n            bars.push(rotated);\n        }\n        bars.into_iter().flat_map(|bar| {\n            let mut ret = vec![Key::normalize(&bar)];\n            for i in 0 .. 3 {\n                let last = Key::normalize(&ret[i].iter().map(|&(a, b)| (a.rotate_by_y(), b.rotate_by_y())).collect());\n                ret.push(last);\n            }\n            ret\n        }).collect::<Vec<_>>()\n    }\n    fn normalize(bars: &Vec<(Point, Point)>) -> Vec<(Point, Point)> {\n        let mut bar = bars.clone();\n        let origin = bar.iter().flat_map(|&(a, b)| vec![a, b]).min().unwrap();\n        for i in 0 .. bar.len() {\n            let a = bar[i].0 - origin;\n            let b = bar[i].1 - origin;\n            bar[i] = (min(a, b), max(a, b));\n        }\n        bar.sort();\n        bar\n    }\n}\n\nfn main() {\n    loop {\n        let mut line1 = Vec::new();\n        while line1.is_empty() {\n            read!(line: [String]);\n            line1 = line;\n        }\n        let a = line1[0].parse::<usize>().ok().unwrap();\n        if a == 0 {break;}\n        let mut first = line1[1..].iter().map(|s| s.parse::<Token>().ok().unwrap()).collect::<Vec<_>>();\n        while first.len() < a {\n            read!(tokens: [Token]);\n            for t in tokens {\n                first.push(t);\n            }\n        }\n        read!(line2: [String]);\n        let b = line2[0].parse::<usize>().ok().unwrap();\n        let mut second = line2[1..].iter().map(|s| s.parse::<Token>().ok().unwrap()).collect::<Vec<_>>();\n        while second.len() < b {\n            read!(tokens: [Token]);\n            for t in tokens {\n                second.push(t);\n            }\n        }\n        let mut first_key = Key::new();\n        for token in first {\n            first_key.add_bar(token);\n        }\n        let mut second_key = Key::new();\n        for token in second {\n            second_key.add_bar(token);\n        }\n        if first_key.is_same(&second_key) {\n            println!(\"SAME\");\n        }else {\n            println!(\"DIFFERENT\");\n        }\n    }\n}\n"
  }
]