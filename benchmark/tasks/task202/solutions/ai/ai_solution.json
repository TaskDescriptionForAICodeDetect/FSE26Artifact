[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PATHS 100\n#define MAX_LENGTH 1000\n\ntypedef struct {\n    char path[MAX_LENGTH];\n    int label;\n} KeyPath;\n\ntypedef struct {\n    KeyPath paths[MAX_PATHS];\n    int count;\n} Key;\n\nvoid parseKey(const char* input, Key* key) {\n    int i = 0, j = 0, k = 0;\n    while (input[i] != '\\0') {\n        if (input[i] == ' ') {\n            i++;\n            continue;\n        }\n        key->paths[k].path[j] = '\\0';\n        key->paths[k].label = 0;\n        while (input[i] >= '0' && input[i] <= '9') {\n            key->paths[k].label = key->paths[k].label * 10 + (input[i] - '0');\n            i++;\n        }\n        j = 0;\n        while (input[i] != ' ' && input[i] != '\\0') {\n            key->paths[k].path[j++] = input[i++];\n        }\n        key->paths[k].path[j] = '\\0';\n        k++;\n        j = 0;\n    }\n    key->count = k;\n}\n\nint comparePaths(const void* a, const void* b) {\n    const KeyPath* pa = (const KeyPath*)a;\n    const KeyPath* pb = (const KeyPath*)b;\n    int cmp = strcmp(pa->path, pb->path);\n    if (cmp != 0) return cmp;\n    return pa->label - pb->label;\n}\n\nint areKeysSame(Key* key1, Key* key2) {\n    if (key1->count != key2->count) return 0;\n    qsort(key1->paths, key1->count, sizeof(KeyPath), comparePaths);\n    qsort(key2->paths, key2->count, sizeof(KeyPath), comparePaths);\n    for (int i = 0; i < key1->count; i++) {\n        if (strcmp(key1->paths[i].path, key2->paths[i].path) != 0 || \n            key1->paths[i].label != key2->paths[i].label) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char input1[MAX_LENGTH * MAX_PATHS];\n    char input2[MAX_LENGTH * MAX_PATHS];\n    while (fgets(input1, sizeof(input1), stdin) != NULL && \n           fgets(input2, sizeof(input2), stdin) != NULL) {\n        Key key1, key2;\n        parseKey(input1, &key1);\n        parseKey(input2, &key2);\n        if (areKeysSame(&key1, &key2)) {\n            printf(\"SAME\\n\");\n        } else {\n            printf(\"DIFFERENT\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KeyDescriptionComparator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCases = scanner.nextInt();\n        \n        for (int t = 0; t < testCases; t++) {\n            int numPaths1 = scanner.nextInt();\n            List<Path> key1 = readPaths(scanner, numPaths1);\n            \n            int numPaths2 = scanner.nextInt();\n            List<Path> key2 = readPaths(scanner, numPaths2);\n            \n            System.out.println(comparePaths(key1, key2) ? \"SAME\" : \"DIFFERENT\");\n        }\n        \n        scanner.close();\n    }\n    \n    static List<Path> readPaths(Scanner scanner, int numPaths) {\n        List<Path> paths = new ArrayList<>();\n        for (int i = 0; i < numPaths; i++) {\n            String direction = scanner.next();\n            int label1 = scanner.nextInt();\n            int label2 = scanner.nextInt();\n            paths.add(new Path(direction, label1, label2));\n        }\n        return paths;\n    }\n    \n    static boolean comparePaths(List<Path> key1, List<Path> key2) {\n        if (key1.size() != key2.size()) return false;\n        \n        Map<String, Set<Point>> pointMap1 = createPointMap(key1);\n        Map<String, Set<Point>> pointMap2 = createPointMap(key2);\n        \n        if (pointMap1.size() != pointMap2.size()) return false;\n        \n        for (String dir : pointMap1.keySet()) {\n            if (!pointMap2.containsKey(dir)) return false;\n            \n            Set<Point> points1 = pointMap1.get(dir);\n            Set<Point> points2 = pointMap2.get(dir);\n            \n            if (points1.size() != points2.size()) return false;\n        }\n        \n        return true;\n    }\n    \n    static Map<String, Set<Point>> createPointMap(List<Path> paths) {\n        Map<String, Set<Point>> pointMap = new HashMap<>();\n        \n        for (Path path : paths) {\n            String dir = path.direction;\n            if (!pointMap.containsKey(dir)) {\n                pointMap.put(dir, new HashSet<>());\n            }\n            \n            Point start, end;\n            if (dir.equals(\"N\") || dir.equals(\"S\")) {\n                start = new Point(path.label1, 0);\n                end = new Point(path.label2, 0);\n            } else if (dir.equals(\"E\") || dir.equals(\"W\")) {\n                start = new Point(0, path.label1);\n                end = new Point(0, path.label2);\n            } else {\n                throw new IllegalArgumentException(\"Invalid direction\");\n            }\n            \n            pointMap.get(dir).add(start);\n            pointMap.get(dir).add(end);\n        }\n        \n        return pointMap;\n    }\n    \n    static class Path {\n        String direction;\n        int label1;\n        int label2;\n        \n        Path(String direction, int label1, int label2) {\n            this.direction = direction;\n            this.label1 = label1;\n            this.label2 = label2;\n        }\n    }\n    \n    static class Point {\n        int x, y;\n        \n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Point point = (Point) o;\n            return x == point.x && y == point.y;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:04:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator<(const Point& other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nstruct Bar {\n    Point p1, p2;\n    Bar(Point p1, Point p2) : p1(p1), p2(p2) {\n        if (p2 < p1) swap(this->p1, this->p2);\n    }\n    bool operator<(const Bar& other) const {\n        if (p1 == other.p1) return p2 < other.p2;\n        return p1 < other.p1;\n    }\n};\n\nvector<Bar> parseKey(const string& s) {\n    vector<Bar> bars;\n    Point current(0, 0);\n    map<Point, int> labels;\n    for (size_t i = 0; i < s.size(); ) {\n        if (s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D') {\n            Point next = current;\n            if (s[i] == 'L') next.x -= 1;\n            else if (s[i] == 'R') next.x += 1;\n            else if (s[i] == 'U') next.y += 1;\n            else if (s[i] == 'D') next.y -= 1;\n            bars.emplace_back(current, next);\n            current = next;\n            ++i;\n        } else {\n            int num = 0;\n            while (i < s.size() && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n                ++i;\n            }\n            labels[current] = num;\n        }\n    }\n    return bars;\n}\n\nbool areSameKeys(const string& s1, const string& s2) {\n    vector<Bar> bars1 = parseKey(s1);\n    vector<Bar> bars2 = parseKey(s2);\n    if (bars1.size() != bars2.size()) return false;\n    set<Bar> set1(bars1.begin(), bars1.end());\n    set<Bar> set2(bars2.begin(), bars2.end());\n    return set1 == set2;\n}\n\nint main() {\n    string s1, s2;\n    while (cin >> s1 >> s2) {\n        if (areSameKeys(s1, s2)) {\n            cout << \"SAME\" << endl;\n        } else {\n            cout << \"DIFFERENT\" << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:04:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_PATHS 100\n#define MAX_LINE 1000\n\ntypedef struct {\n    int start;\n    int end;\n    char direction;\n} GoldBar;\n\ntypedef struct {\n    GoldBar bars[MAX_PATHS];\n    int barCount;\n} Key;\n\nint parseKey(char* input, Key* key) {\n    key->barCount = 0;\n    char* token = strtok(input, \" \");\n    \n    while (token != NULL) {\n        GoldBar bar;\n        if (sscanf(token, \"%c%d\", &bar.direction, &bar.start) != 2) {\n            return 0;\n        }\n        \n        switch (bar.direction) {\n            case 'N': bar.end = bar.start + 1; break;\n            case 'S': bar.end = bar.start - 1; break;\n            case 'E': bar.end = bar.start + 1; break;\n            case 'W': bar.end = bar.start - 1; break;\n            default: return 0;\n        }\n        \n        key->bars[key->barCount++] = bar;\n        token = strtok(NULL, \" \");\n    }\n    return 1;\n}\n\nbool isSameKey(Key* key1, Key* key2) {\n    if (key1->barCount != key2->barCount) return false;\n    \n    bool matched[MAX_PATHS] = {false};\n    \n    for (int i = 0; i < key1->barCount; i++) {\n        bool found = false;\n        for (int j = 0; j < key2->barCount; j++) {\n            if (!matched[j] && \n                key1->bars[i].direction == key2->bars[j].direction &&\n                abs(key1->bars[i].start - key2->bars[j].start) == 0 &&\n                abs(key1->bars[i].end - key2->bars[j].end) == 0) {\n                matched[j] = true;\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}\n\nint main() {\n    int testCases;\n    scanf(\"%d\", &testCases);\n    getchar(); \n\n    for (int t = 0; t < testCases; t++) {\n        char line1[MAX_LINE], line2[MAX_LINE];\n        fgets(line1, sizeof(line1), stdin);\n        fgets(line2, sizeof(line2), stdin);\n        \n        line1[strcspn(line1, \"\\n\")] = 0;\n        line2[strcspn(line2, \"\\n\")] = 0;\n\n        Key key1, key2;\n        if (!parseKey(line1, &key1) || !parseKey(line2, &key2)) {\n            printf(\"INVALID\\n\");\n            continue;\n        }\n\n        printf(\"%s\\n\", isSameKey(&key1, &key2) ? \"SAME\" : \"DIFFERENT\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Bar {\n    int start, end;\n    string direction;\n};\n\nvector<Bar> parseKey(const string& keyDesc) {\n    vector<Bar> bars;\n    istringstream iss(keyDesc);\n    string segment;\n    \n    while (iss >> segment) {\n        Bar bar;\n        size_t dirPos = segment.find_first_of(\"NSEW\");\n        \n        if (dirPos != string::npos) {\n            bar.direction = segment.substr(dirPos, 1);\n            bar.start = stoi(segment.substr(0, dirPos));\n            bar.end = stoi(segment.substr(dirPos + 1));\n            bars.push_back(bar);\n        }\n    }\n    \n    return bars;\n}\n\nbool areKeysSame(const string& key1Desc, const string& key2Desc) {\n    vector<Bar> key1 = parseKey(key1Desc);\n    vector<Bar> key2 = parseKey(key2Desc);\n    \n    if (key1.size() != key2.size()) return false;\n    \n    set<pair<int, int>> positions1, positions2;\n    int minX1 = INT_MAX, minY1 = INT_MAX;\n    int minX2 = INT_MAX, minY2 = INT_MAX;\n    \n    for (const Bar& bar : key1) {\n        if (bar.direction == \"N\" || bar.direction == \"S\") {\n            positions1.insert({bar.start, bar.end});\n            minX1 = min(minX1, bar.start);\n            minY1 = min(minY1, bar.end);\n        } else {\n            positions1.insert({bar.end, bar.start});\n            minX1 = min(minX1, bar.end);\n            minY1 = min(minY1, bar.start);\n        }\n    }\n    \n    for (const Bar& bar : key2) {\n        if (bar.direction == \"N\" || bar.direction == \"S\") {\n            positions2.insert({bar.start, bar.end});\n            minX2 = min(minX2, bar.start);\n            minY2 = min(minY2, bar.end);\n        } else {\n            positions2.insert({bar.end, bar.start});\n            minX2 = min(minX2, bar.end);\n            minY2 = min(minY2, bar.start);\n        }\n    }\n    \n    int xOffset = minX1 - minX2;\n    int yOffset = minY1 - minY2;\n    \n    set<pair<int, int>> translatedPositions2;\n    for (const auto& pos : positions2) {\n        translatedPositions2.insert({pos.first + xOffset, pos.second + yOffset});\n    }\n    \n    return positions1 == translatedPositions2;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    cin.ignore();\n    \n    while (T--) {\n        string key1Desc, key2Desc;\n        getline(cin, key1Desc);\n        getline(cin, key2Desc);\n        \n        cout << (areKeysSame(key1Desc, key2Desc) ? \"SAME\" : \"DIFFERENT\") << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:05:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KeyComparator {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Point point = (Point) o;\n            return x == point.x && y == point.y;\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n\n    static class Bar {\n        Point p1, p2;\n        Bar(Point p1, Point p2) {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Bar bar = (Bar) o;\n            return (p1.equals(bar.p1) && p2.equals(bar.p2)) || (p1.equals(bar.p2) && p2.equals(bar.p1));\n        }\n        @Override\n        public int hashCode() {\n            return p1.hashCode() + p2.hashCode();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int t = 0; t < T; t++) {\n            String[] path1 = scanner.nextLine().split(\" \");\n            String[] path2 = scanner.nextLine().split(\" \");\n\n            Set<Bar> bars1 = buildBars(path1);\n            Set<Bar> bars2 = buildBars(path2);\n\n            if (bars1.equals(bars2)) {\n                System.out.println(\"SAME\");\n            } else {\n                System.out.println(\"DIFFERENT\");\n            }\n        }\n    }\n\n    private static Set<Bar> buildBars(String[] path) {\n        Set<Bar> bars = new HashSet<>();\n        Point current = new Point(0, 0);\n        int label = 1;\n\n        for (String step : path) {\n            Point next = new Point(current.x, current.y);\n            char dir = step.charAt(0);\n            switch (dir) {\n                case 'U':\n                    next.y += 1;\n                    break;\n                case 'D':\n                    next.y -= 1;\n                    break;\n                case 'L':\n                    next.x -= 1;\n                    break;\n                case 'R':\n                    next.x += 1;\n                    break;\n            }\n            bars.add(new Bar(new Point(current.x, current.y), new Point(next.x, next.y)));\n            current = next;\n            label++;\n        }\n        return bars;\n    }\n}",
    "timestamp": "2025-08-05 19:05:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def path_signature(key_description):\n    positions = set()\n    x, y = 0, 0\n    stack = []\n\n    def move(direction):\n        nonlocal x, y\n        if direction == 'N':\n            y += 1\n        elif direction == 'S':\n            y -= 1\n        elif direction == 'E':\n            x += 1\n        elif direction == 'W':\n            x -= 1\n\n    for path in key_description:\n        x, y = 0, 0\n        labels = []\n        for element in path:\n            if isinstance(element, int):\n                labels.append(element)\n                positions.add((x, y))\n            elif element in 'NSEW':\n                move(element)\n\n        positions.update((label,) for label in labels)\n\n    return positions\n\ndef are_keys_same(key1, key2):\n    return path_signature(key1) == path_signature(key2)\n\ndef main():\n    num_pairs = int(input())\n    for _ in range(num_pairs):\n        key1 = eval(input().strip())\n        key2 = eval(input().strip())\n        if are_keys_same(key1, key2):\n            print('SAME')\n        else:\n            print('DIFFERENT')\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:16:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class KeyComparison {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        \n        for (int i = 0; i < n; i++) {\n            String key1 = scanner.nextLine().trim();\n            String key2 = scanner.nextLine().trim();\n            \n            if (areKeysSame(key1, key2)) {\n                System.out.println(\"SAME\");\n            } else {\n                System.out.println(\"DIFFERENT\");\n            }\n        }\n        \n        scanner.close();\n    }\n    \n    private static boolean areKeysSame(String key1, String key2) {\n        List<String> paths1 = parsePaths(key1);\n        List<String> paths2 = parsePaths(key2);\n        \n        Set<String> normalizedPaths1 = normalizePaths(paths1);\n        Set<String> normalizedPaths2 = normalizePaths(paths2);\n        \n        return normalizedPaths1.equals(normalizedPaths2);\n    }\n\n    private static List<String> parsePaths(String key) {\n        List<String> paths = new ArrayList<>();\n        StringBuilder currentPath = new StringBuilder();\n        for (char c : key.toCharArray()) {\n            if (Character.isDigit(c)) {\n                currentPath.append(c);\n            } else {\n                if (currentPath.length() > 0) {\n                    paths.add(currentPath.toString());\n                    currentPath.setLength(0);\n                }\n                currentPath.append(c);\n            }\n        }\n        if (currentPath.length() > 0) {\n            paths.add(currentPath.toString());\n        }\n        return paths;\n    }\n    \n    private static Set<String> normalizePaths(List<String> paths) {\n        Set<String> normalizedPaths = new HashSet<>();\n        for (String path : paths) {\n            char direction = path.charAt(0);\n            String labels = path.substring(1);\n            String normalizedPath = direction + labels;\n            normalizedPaths.add(normalizedPath);\n        }\n        return normalizedPaths;\n    }\n}",
    "timestamp": "2025-08-13 02:16:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PATH_LENGTH 1000\n#define DIRECTIONS 4\n\nenum Direction { UP, DOWN, LEFT, RIGHT };\n\n// Function to convert direction character to corresponding enum value\nint getDirection(char dir) {\n    switch (dir) {\n        case 'U': return UP;\n        case 'D': return DOWN;\n        case 'L': return LEFT;\n        case 'R': return RIGHT;\n    }\n    return -1;\n}\n\n// Function to normalize the key description\nvoid normalizeKey(char *key, int *normalized) {\n    int x = 0, y = 0;\n    char *token;\n    \n    memset(normalized, 0, sizeof(int) * MAX_PATH_LENGTH * DIRECTIONS);\n    \n    token = strtok(key, \" \");\n    while (token != NULL) {\n        int dir = getDirection(token[0]);\n        int label = atoi(&token[1]);\n        \n        switch(dir) {\n            case UP: x += 0; y += label; break;\n            case DOWN: x += 0; y -= label; break;\n            case LEFT: x -= label; y += 0; break;\n            case RIGHT: x += label; y += 0; break;\n        }\n        \n        normalized[x + MAX_PATH_LENGTH/2 + (y + MAX_PATH_LENGTH/2) * DIRECTIONS]++;\n        \n        token = strtok(NULL, \" \");\n    }\n}\n\nint areKeysSame(char *key1, char *key2) {\n    int normalized1[MAX_PATH_LENGTH * DIRECTIONS];\n    int normalized2[MAX_PATH_LENGTH * DIRECTIONS];\n    \n    normalizeKey(key1, normalized1);\n    normalizeKey(key2, normalized2);\n    \n    return memcmp(normalized1, normalized2, sizeof(normalized1)) == 0;\n}\n\nint main() {\n    int testCases, i;\n    char key1[MAX_PATH_LENGTH], key2[MAX_PATH_LENGTH];\n    \n    scanf(\"%d\", &testCases);\n    for (i = 0; i < testCases; i++) {\n        scanf(\" %s %s\", key1, key2);\n        \n        if (areKeysSame(key1, key2)) {\n            printf(\"SAME\\n\");\n        } else {\n            printf(\"DIFFERENT\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 02:16:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def normalize_key(key):\n    # Convert key to a canonical representation\n    normalized = {}\n    used_positions = set()\n    \n    for path in key:\n        current_pos = (0, 0)\n        current_path = [current_pos]\n        \n        for move in path:\n            if isinstance(move, str):\n                # Handle directional moves\n                if move == 'U':\n                    current_pos = (current_pos[0], current_pos[1] + 1)\n                elif move == 'D':\n                    current_pos = (current_pos[0], current_pos[1] - 1)\n                elif move == 'L':\n                    current_pos = (current_pos[0] - 1, current_pos[1])\n                elif move == 'R':\n                    current_pos = (current_pos[0] + 1, current_pos[1])\n                \n                # Check for position overlap\n                if current_pos in used_positions:\n                    return None\n                used_positions.add(current_pos)\n                current_path.append(current_pos)\n            else:\n                # Assuming move is a label\n                current_path.append(move)\n        \n        # Convert path to tuple for hashability\n        normalized[tuple(current_path)] = 1\n    \n    return normalized\n\ndef are_keys_same(key1, key2):\n    norm1 = normalize_key(key1)\n    norm2 = normalize_key(key2)\n    \n    return norm1 == norm2 if norm1 is not None and norm2 is not None else False\n\ndef main():\n    # Number of test cases\n    T = int(input())\n    \n    for _ in range(T):\n        # Number of paths in first key\n        N = int(input())\n        key1 = []\n        for _ in range(N):\n            path = input().split()\n            key1.append([int(x) if x.isdigit() else x for x in path])\n        \n        # Number of paths in second key\n        M = int(input())\n        key2 = []\n        for _ in range(M):\n            path = input().split()\n            key2.append([int(x) if x.isdigit() else x for x in path])\n        \n        # Check and print result\n        print('SAME' if are_keys_same(key1, key2) else 'DIFFERENT')\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:17:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_key(description):\n    key = {}\n    for path in description:\n        x, y = 0, 0\n        for i in range(0, len(path), 2):\n            direction = path[i]\n            length = int(path[i+1])\n            if direction == 'U':\n                for _ in range(length):\n                    y += 1\n                    if (x, y) in key:\n                        return None\n                    key[(x, y)] = True\n            elif direction == 'D':\n                for _ in range(length):\n                    y -= 1\n                    if (x, y) in key:\n                        return None\n                    key[(x, y)] = True\n            elif direction == 'L':\n                for _ in range(length):\n                    x -= 1\n                    if (x, y) in key:\n                        return None\n                    key[(x, y)] = True\n            elif direction == 'R':\n                for _ in range(length):\n                    x += 1\n                    if (x, y) in key:\n                        return None\n                    key[(x, y)] = True\n    return key\n\ndef solve():\n    import sys\n    input = sys.stdin.read().splitlines()\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    for _ in range(T):\n        desc1 = input[idx].strip().split()\n        idx += 1\n        desc2 = input[idx].strip().split()\n        idx += 1\n        \n        key1 = parse_key(desc1)\n        key2 = parse_key(desc2)\n        \n        if key1 is None or key2 is None:\n            print(\"DIFFERENT\")\n        elif key1 == key2:\n            print(\"SAME\")\n        else:\n            print(\"DIFFERENT\")\n\nsolve()",
    "timestamp": "2025-08-13 02:17:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to;\n    char direction;\n    Edge(int f, int t, char d): from(f), to(t), direction(d) {}\n    \n    bool operator<(const Edge& other) const {\n        if (from != other.from) return from < other.from;\n        if (to != other.to) return to < other.to;\n        return direction < other.direction;\n    }\n};\n\nclass Key {\nprivate:\n    vector<Edge> edges;\n    \npublic:\n    Key(const vector<Edge>& e): edges(e) {}\n    \n    string normalize() {\n        sort(edges.begin(), edges.end());\n        unordered_map<int, int> relabel;\n        int nextLabel = 0;\n        \n        vector<Edge> normalizedEdges;\n        for (const auto& edge : edges) {\n            int from = edge.from, to = edge.to;\n            if (relabel.count(from) == 0) {\n                relabel[from] = nextLabel++;\n            }\n            if (relabel.count(to) == 0) {\n                relabel[to] = nextLabel++;\n            }\n            normalizedEdges.emplace_back(relabel[from], relabel[to], edge.direction);\n        }\n        \n        sort(normalizedEdges.begin(), normalizedEdges.end());\n        \n        string result;\n        for (const auto& edge : normalizedEdges) {\n            result += \"{\" + to_string(edge.from) + \",\" + to_string(edge.to) + \",\" + edge.direction + \"}\";\n        }\n        \n        return result;\n    }\n};\n\nbool areKeysSame(const vector<Edge>& key1, const vector<Edge>& key2) {\n    Key k1(key1), k2(key2);\n    return k1.normalize() == k2.normalize();\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        int m1, m2;\n        cin >> m1;\n        vector<Edge> key1;\n        for (int i = 0; i < m1; ++i) {\n            int u, v;\n            char d;\n            cin >> u >> v >> d;\n            key1.emplace_back(u, v, d);\n        }\n        \n        cin >> m2;\n        vector<Edge> key2;\n        for (int i = 0; i < m2; ++i) {\n            int u, v;\n            char d;\n            cin >> u >> v >> d;\n            key2.emplace_back(u, v, d);\n        }\n        \n        if (areKeysSame(key1, key2)) {\n            cout << \"SAME\" << endl;\n        } else {\n            cout << \"DIFFERENT\" << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:05:03"
  }
]