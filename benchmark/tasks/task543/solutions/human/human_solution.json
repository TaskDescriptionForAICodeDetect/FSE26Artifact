[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  val Array(n, r) = readLine.trim.split(' ').map(_.toInt)\n  val numbers = readLine.trim.split(' ').map(_.toInt - 1)\n  val uft = new UnionFind(n + 1)\n  for (i ← numbers.indices) {\n    uft.merge(i, numbers(i))\n  }\n  var size = Nil: List[Int]\n  for (i ← numbers.indices if !uft.isSame(i, n)) {\n    size ::= uft.sizeOf(i)\n    uft.merge(i, n)\n  }\n  val values = size.groupBy(identity).mapValues(_.length).toArray.sortBy(_._1)\n  val memo = Array.fill(math.min(n - r, r) + 1){false}\n  memo(0) = true\n  for ((v, c) ← values) {\n    var i = 0\n    while ((1 << (i + 1)) <= c) {\n      val value = v << i\n      for (j ← (0 until memo.length - value).reverse if memo(j)) {\n        memo(j + value) = true\n      }\n      i += 1\n    }\n    val rest = c - (1 << i) + 1\n    val value = rest * v\n    if (rest != 0) for (j ← (0 until memo.length - value).reverse if memo(j)) {\n      memo(j + value) = true\n    }\n  }\n  println(\n    if (memo.last) \"Yes\" else \"No\"\n  )\n}\nclass UnionFind(val size: Int) {\n  private[this] val parent = Array.fill(size){-1}\n  def find(a: Int): Int = {\n    if (parent(a) < 0) a\n    else {\n      parent(a) = find(parent(a))\n      parent(a)\n    }\n  }\n  def isSame(a: Int, b: Int): Boolean = find(a) == find(b)\n  def merge(a: Int, b: Int): Unit = {\n    val ar = find(a)\n    val br = find(b)\n    if (ar != br){\n      if (parent(ar) < parent(br)) {\n        parent(ar) += parent(br)\n        parent(br) = ar\n      }else {\n        parent(br) += parent(ar)\n        parent(ar) = br\n      }\n    }\n  }\n  def sizeOf(a: Int): Int = -parent(find(a))\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, R, P[300000], t[300000], s[300000];\nmap<int, int>mp;\nvector<pair<int, int>>v;\n\nint par(int x) {\n\tif (t[x] < 0)return x;\n\treturn t[x] = par(t[x]);\n}\n\nvoid uni(int x, int y) {\n\tx = par(x);\n\ty = par(y);\n\tif (x == y)return;\n\tif (t[x] < t[y]) {\n\t\tt[x] += t[y];\n\t\tt[y] = x;\n\t}\n\telse {\n\t\tt[y] += t[x];\n\t\tt[x] = y;\n\t}\n}\n\n\nint main() {\n\tcin >> N >> R;\n\tmemset(t, -1, sizeof t);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> P[i];\n\t\t--P[i];\n\t\tuni(P[i], i);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (t[i] < 0) {\n\t\t\t++mp[-t[i]];\n\t\t}\n\t}\n\tfor (pair<int, int>p : mp) {\n\t\tv.push_back(p);\n\t}\n\tR = min(R, N - R);\n\tvector<vector<bool>>DP(v.size() + 1, vector<bool>(R + 1));\n\tDP[0][0] = true;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tvector<int>u(R + 1, -1);\n\t\tfor (int j = 0; j <= R; ++j) {\n\t\t\tif (DP[i][j]) {\n\t\t\t\tu[j] = v[i].second;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= R; ++j) {\n\t\t\tif (u[j] != -1) {\n\t\t\t\tDP[i + 1][j] = true;\n\t\t\t\tif (j + v[i].first <= R) {\n\t\t\t\t\tu[j + v[i].first] = max(u[j + v[i].first], u[j] - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (DP[v.size()][R]) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nint n, r;\nint p[300000];\nbool saw[300001];\nvector<int> v;\nbool dp[300001];\nint d_m = 0;\n\nint main() {\n    cin >> n >> r;\n    rep(i,n) cin >> p[i];\n    rep(i,n) p[i]--;\n    rep(i,n) {\n        if (saw[i]) continue;\n        saw[i] = true;\n        int cnt = 1;\n        int j = p[i];\n        while (true) {\n            if (saw[j]) break;\n            saw[j] = true;\n            j = p[j];\n            cnt++;\n        }\n        v.push_back(cnt);\n    }\n    sort(v.begin(), v.end());\n    dp[0] = true;\n    rep(i,v.size()) {\n        int con = 1;\n        while (i != v.size()-1) {\n            if (v[i] == v[i+1]) {\n                i++;\n                con++;\n            } else {\n                break;\n            }\n        }\n        for (int k = d_m; k >= 0; k--) {\n            if (!dp[k]) continue;\n            rep(_,con) {\n                dp[k+v[i]*(_+1)] = true;\n                d_m = max(d_m, k+v[i]*(_+1));\n            }\n        }\n    }\n    if (dp[r]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\n\n\nint main() {\n    int n, r;\n    cin >> n >> r;\n    r = min(r, n-r);\n    vector<int> p(n);\n    for (auto &&i : p) scanf(\"%d\", &i), i--;\n    vector<int> visited(n);\n    int k = 0;\n    vector<int> sz;\n    for (int i = 0; i < n; ++i) {\n        if(visited[i]) continue;\n        if(p[i] == i) {\n            k++;\n            continue;\n        }\n        int cnt = 0;\n        while(!visited[i]){\n            cnt++;\n            visited[i] = 1;\n            i = p[i];\n        }\n        sz.emplace_back(cnt);\n    }\n    bitset<150001> v;\n    v.set(0);\n    for (int i : sz) v |= (v << i);\n    for (int i = max(0, r-k); i <= r; ++i) {\n        if(v[i]){\n            puts(\"Yes\");\n            return 0;\n        }\n    }\n    puts(\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {\n    vector<int> par; // uf(x,y)->y\n    UnionFind() {}\n    UnionFind(int NV) { init(NV); }\n    void init(int NV) { par.clear(); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) { x = operator[](x); y = operator[](y); if (x != y) par[x] = y; }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan\n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \n \n \n \nint N, R, P[301010];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> N >> R;\n\tif (N - R < R) R = N - R;\n\trep(i, 0, N) cin >> P[i];\n\trep(i, 0, N) P[i]--;\n\n\tUnionFind uf;\n\tuf.init(N);\n\trep(i, 0, N) uf(i, P[i]);\n\tmap<int, int> cnt;\n\trep(i, 0, N) cnt[uf[i]]++;\n\tvector<int> v;\n\tfore(p, cnt) v.push_back(p.second);\n\n\tbitset<150001> dp;\n\tdp.set(0);\n\tfore(x, v) dp = dp | (dp << x);\n\n\tif (dp[R]) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE=4*1e5;\nusing Bit=bitset<SIZE>;\nint main(){\n    int n,r;\n    cin>>n>>r;\n    vector<int> p(n);\n    for(int i=0;i<n;i++) cin>>p[i],p[i]--;\n\n    map<int,int> mp;\n    vector<int> used(n);\n    for(int i=0;i<n;i++){\n        if(!used[i]){\n            used[i]=true;\n            int v=p[i];\n            int cnt=1;\n            while(v!=i){\n                used[v]=true;\n                v=p[v];\n                cnt++;\n            }\n            mp[cnt]++;\n        }\n    }\n\n    vector<pair<int,int>> item(mp.begin(),mp.end());\n    int sz=item.size();\n    vector<Bit> dp(sz+1);\n\n    dp[0][0]=1;\n    for(int i=0;i<sz;i++){\n        int x=item[i].first;\n        int cnt=item[i].second;\n        for(int j=0;j<x;j++){\n            int piyo=0;\n            for(int k=j;k<=n;k+=x){\n                if(dp[i][k]) piyo=cnt+1;\n                dp[i+1][k]=(dp[i+1][k]||(piyo>0));\n                piyo--;\n            }\n        }\n    }\n    cout<<(dp[sz][r] ? \"Yes\" : \"No\")<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>istream &operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\n//template <typename T, typename S>ostream &operator<<(ostream &os, pair<T, S> &p) {os << p.first << \" \" << p.second;return os;}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T, class U>bool chmin(T& a, U b) { if (a > b) { a = b; return true; }return false; }\ntemplate <class T, class U>bool chmax(T& a, U b) { if (a < b) { a = b; return true; }return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n\tbool is_root(int x) { return parent[x] < 0; }\n};\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, R; cin >> N >> R;\n\tvector<int>p(N); rep(i, 0, N) { cin >> p[i]; p[i]--; }\n\tvector<int>q(N);\n\trep(i, 0, N) {\n\t\tq[p[i]] = i;\n\t}\n\n\tUnionFind uf(N);\n\trep(i, 0, N) {\n\t\tuf.unite(i, q[i]);\n\t}\n\tvector<int>v;\n\trep(i, 0, N) {\n\t\tif (uf.is_root(i)) {\n\t\t\tv.eb(uf.size_of(i));\n\t\t}\n\t}\n\n\tmap<int, int>mp;\n\tfor (auto x : v) {\n\t\tmp[x]++;\n\t}\n\n\tchmin(R, N - R);\n\tvector<int>dp(R + 1);\n\tdp[0] = true;\n\tfor (auto yy : mp) {\n\t\tint i = 0;\n\t\twhile (yy.second) {\n\t\t\tint m=min(yy.second, 1ll << i);\n\t\t\ti++;\n\t\t\tyy.second -= m;\n\t\t\tint x = yy.first*m;\n\t\t\trrep(j, x, dp.size()) {\n\t\t\t\tchmax(dp[j], dp[j - x]);\n\t\t\t}\n\t\t}\n\t}\n\tYes(dp.back());\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <bitset>\n#define _repargs(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _repargs(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p = 0) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\n\n// union find\nclass union_find {\npublic:\n    int n;\n    vector<int> parent, rnk, num;\n    \n    union_find(int n) : n(n), parent(n), rnk(n, 0), num(n, 1) {rep(i, n) parent[i] = i; }\n    \n    int root(int x){ return (parent[x] == x) ? x : root(parent[x]); }\n    \n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return;\n        }\n        if (rnk[x] < rnk[y]) {\n            parent[x] = y;\n            num[y] += num[x];\n        }\n        else{\n            parent[y] = x;\n            num[x] += num[y];\n            if (rnk[x] == rnk[y]) {\n                rnk[x]++;\n            }\n        }\n        n--;\n    }\n    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    int count(int x){ return num[root(x)]; }\n};\nconst int MAX_N = 150020;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    // source code\n    \n    int N, R;\n    cin >> N >> R;\n    vector<int> A(N);\n    rep(i, N) {\n        cin >> A[i];\n        A[i]--;\n    }\n    union_find uf(N);\n    rep(i, N) uf.unite(A[i], A[A[i]]);\n    vector<int> used(N, 0);\n    vector<int> B;\n    rep(i, N) {\n        int root = uf.root(i);\n        if (used[root]) {\n            continue;\n        }\n        used[root] = true;\n        B.pb(uf.count(root));\n    }\n    bitset<MAX_N> C(1);\n    rep(i, B.size()){\n        C |= (C << B[i]);\n    }\n    \n    if(C.test(min(R, N - R)) == 1) {\n        output(\"Yes\");\n    }\n    else {\n        output(\"No\");\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/07/14.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\nclass UnionFind{\n    vi node;\npublic:\n    UnionFind(int n){\n        node=vi(n,-1);\n    }\n    int root(int x){\n        if(node[x]<0) return x;\n        return node[x]=root(node[x]);\n    }\n    bool uni(int x, int y){\n        x=root(x);\n        y=root(y);\n        if(x==y) return false;\n        if(-node[x]<-node[y]) swap(x,y);\n        node[x]+=node[y];\n        node[y]=x;\n        return true;\n    }\n};\n\nint main(){\n    int n,r;\n    cin >> n >> r;\n    vi p(n);\n    UnionFind uf(n);\n    rep(i,n){\n        cin >> p[i];\n        p[i]--;\n        uf.uni(i,p[i]);\n    }\n    vi c(n);\n    rep(i,n){\n        c[uf.root(i)]++;\n    }\n    vi v;\n    v.reserve(n);\n    rep(i,n){\n        if(c[i]>0) v.push_back(c[i]);\n    }\n    n=v.size();\n//    sort(all(v));\n    rep(i,n){\n        if(v[i]==r){\n            CYES;\n            return 0;\n        }\n    }\n    random_device seed_gen;\n    mt19937 engine(seed_gen());\n    int q=1e8/n;\n    rep(_,q){\n        shuffle(all(v), engine);\n        int k=0,idx=0;\n        while(k<r){\n            k+=v[idx];\n            idx++;\n        }\n        if(k==r){\n            CYES;\n            return 0;\n        }\n    }\n    CNO;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n// #pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = (i64)1e9 + 7;\n\nconst i64 INF = (i64)1e18 + 7;\n\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#ifdef TEST\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); cout << \"value = \" << x << endl;\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n#else\n#define vecdump(x)\n#define dump(x)\n#endif\n\n\nvoid _dump(int, string& x){\n#ifdef TEST\n    cout << x << endl;\n#endif\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n#ifdef TEST\n    cout << x << \" \";\n#endif\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n#ifdef TEST\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    cout << endl;\n#endif\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\nstruct UnionFind{\n    vector<int> par;\n    int count;\n    UnionFind(int n) : par(n, -1), count(0){}\n    int Find(int x){return par[x] < 0 ? x : Find(par[x]);}\n    int Size(int x){return par[x] < 0 ? -par[x] : Size(par[x]);}\n    bool Unite(int x, int y){\n        x = Find(x);\n        y = Find(y);\n        if(x == y)\n            return false;\n        if(par[x] > par[y])\n            swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return ++count;\n    }\n};\n\n\n\ni64 solve(i64 _count){\n\n    int n, r;\n    cin >> n >> r;\n\n    if(!static_cast<bool>(cin))\n        return MOD;\n#ifdef TEST\n    cout << \"Case: \" << _count << endl;\n#endif\n\n    if(r > n - r)\n        r = n - r;\n    vector<int> a(n);\n    for(auto& x : a){\n        cin >> x;\n        --x;\n    }\n    UnionFind u(n);\n    vector<int> par;\n    for(int i = 0; i < n; ++i)\n        u.Unite(i, a[i]);\n    for(int i = 0; i < n; ++i)\n        if(u.par[i] < 0)\n            par.emplace_back(u.Size(i));\n    bitset<300001> bs;\n    bs.set(0);\n    for(auto& x : par){\n        bs |= bs << x;\n        if(bs[r]){\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n\n    return 0;\n}\n\n\nsigned main(){\n\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int t = 0;\n    while(solve(++t) != MOD);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T> bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> v) {\n    for (int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) {\n        fill_v(e, v);\n    }\n};\nvector<int> vis, to;\nint dfs(int i, int c) {\n    vis[i] = 1;\n    if (!vis[to[i]]) {\n        return dfs(to[i], c + 1);\n    }\n    return c;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, r;\n    cin >> n >> r;\n    vis.resize(n);\n    to.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> to[i];\n        --to[i];\n    }\n    vector<int> co(n + 1);\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            int t = dfs(i, 1);\n            co[t]++;\n            // cout << t << endl;\n        }\n    }\n    vector<int> a, b;\n    for (int i = 0; i <= n; i++) {\n        if (co[i]) {\n            a.push_back(i);     // val\n            b.push_back(co[i]); // limit\n        }\n    }\n    int m = a.size();\n    //  cout << m << endl;\n    auto dp = make_v<int>(n + 1);\n    fill_v(dp, -1);\n    dp[0] = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (dp[j] != -1) {\n                dp[j] = b[i];\n            }\n            if (j >= a[i] && dp[j - a[i]] > 0) {\n                chmax(dp[j], dp[j - a[i]] - 1);\n            }\n        }\n        //  cout << dp[i + 1];\n    }\n    if (dp[r] != -1) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nstruct UnionFind {\n  vector<int> c, s;\n  UnionFind(size_t n) : c(n), s(n, 1) { iota(begin(c), end(c), 0); }\n  int root(int i) { return c[i] == i ? i : (c[i] = root(c[i])); }\n  bool same(int i, int j) { return root(i) == root(j); }\n  void unite(int i, int j) {\n    i = root(i); j = root(j);\n    if (i != j) {\n      if (s[i] > s[j]) { c[j] = i; s[i] += s[j]; }\n      else { c[i] = j; s[j] += s[i]; }\n    }\n  }\n  int size(int i) { return s[root(i)]; }\n};\nconst i64 mod = 1e9 + 7;\ni64 n, r;\nvector<vector<i64>> g;\nint main() {\n  cin >> n >> r;\n\n  UnionFind uf(n + 1);\n  for (i64 i = 1; i <= n; ++i) {\n    i64 p;\n    cin >> p;\n    uf.unite(i, p);\n  }\n\n  vector<bool> b(n + 1);\n  vector<i64> ss(n + 1);\n  for (i64 i = 1; i <= n; ++i) {\n    i64 r = uf.root(i);\n    if (!b[r]) {\n      b[r] = true;\n      ss[uf.size(r)]++;\n    }\n  }\n\n  vector<i64> dp(n + 1);\n  dp[0] = 1;\n  for (i64 i = 1; i <= n; ++i) {\n    if (ss[i] > 0) {\n      vector<i64> dp_to(n + 1);\n      for (i64 j = 0; j <= n; ++j) {\n        dp_to[j] = dp[j];\n        if (j >= i) dp_to[j] += dp_to[j - i];\n        i64 k = j - (ss[i] + 1) * i;\n        if (k >= 0) dp_to[j] -= dp[k];\n        dp_to[j] += mod;\n        dp_to[j] %= mod;\n      }\n      dp = dp_to;\n    }\n  }\n  if (dp[r] > 0) cout << \"Yes\\n\";\n  else cout << \"No\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, r;\n    cin >> n >> r;\n\n    vector<int> as(n);\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        a--;\n        as[i] = a;\n    }\n\n    vector<vector<int>> ps;\n    vector<int> sz;\n    vector<bool> visited(n);\n    for (int i = 0; i < n; i++) {\n        if (visited[i]) continue;\n        visited[i] = true;\n        int idx = i;\n        vector<int> idxs = {idx};\n        while (1) {\n            idx = as[idx];\n            if (visited[idx]) break;\n            idxs.push_back(idx);\n            visited[idx] = true;\n        }\n        ps.push_back(idxs);\n        sz.push_back(idxs.size());\n    }\n\n    sort(sz.begin(), sz.end());\n    bitset<151515> can_make;\n    can_make[0] = 1;\n    int MAKE = min(r, n - r);\n    for (int a : sz) {\n        if (a > MAKE) continue;\n        can_make |= can_make << a;\n    }\n    cout << (can_make[MAKE] ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, r; cin>>n>>r;\n    if(r>n/2) r=n-r;\n    bool used[300010]={};\n    vector<int> v;\n    int p[300010];\n    for(int i=0; i<n; i++){\n        cin>>p[i]; p[i]--;\n    }\n    for(int i=0; i<n; i++){\n        if(!used[i]){\n            int c=0;\n            int t=i;\n            while(!used[t]){\n                used[t]=1;\n                t=p[t];\n                c++;\n            }\n            v.push_back(c);\n        }\n    }\n    bitset<150001> bs;\n    bs[0]=1;\n    for(auto x:v){\n        bs=bs|(bs<<x);\n    }\n    if(bs[r]) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\n#define Mod 1000000007\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\n#define INF 1ll<<59\n\n\nstruct UnionFind {\n    int n, cnt;\n    vector<int> par, rank, sz;\n\n    UnionFind(int n) : n(n), cnt(n), par(n), rank(n), sz(n, 1) {\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return sz[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        } else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n        cnt--;\n    }\n};\n\n\nint main(){\n  ll i,j;\n  ll n,r;\n  cin>>n>>r;\n  ll p[n+1];\n\n  for(i=1;i<=n;i++) {\n    ll x;\n    cin>>x;\n    p[i]=x;\n  }\n  \n  ll used[n+1];\n  for(i=1;i<=n;i++){\n    used[i]=0;\n  }\n\n\n  UnionFind uf(n+1);\n  vector<ll> v;\n\n  for(i=1;i<=n;i++){\n    if(used[i]==0){\n      used[i]=1;\n      ll t=i;\n      ll si=1;\n      while(uf.find(t)!=uf.find(p[t])){\n        uf.unite(t,p[t]);\n        si++;\n        t=p[t];\n        used[t]=1;\n      }\n      v.pb(si);\n    } \n  }\n\n  VI cnt(n+1,0);\n  for(i=0;i<v.size();i++) cnt[v[i]]++;\n\n  vector<P> u;\n  for(i=0;i<=n;i++){\n    if(cnt[i]>0) u.pb(P(i,cnt[i]));\n  }\n  ll z=u.size();\n\n  VI dp(n+1,-1);\n  dp[0]=0;\n\n  for(i=0;i<z;i++){\n    for(j=0;j<n+1;j++){\n      if(dp[j]>=0) {\n        dp[j]=u[i].se;\n      } else if(j<u[i].fi || dp[j-u[i].fi]<=0 ){\n        dp[j]=-1;\n      } else{\n        dp[j]=dp[j-u[i].fi]-1;\n      }\n    }\n  }\n\n  if(dp[r]>=0) cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing int64 = long long;\n\nusing vint = vector<int>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr int64 INF64 = (1ll << 60) - 1;\n\n#define rep(i, N) for(int i=0;i<(int)(N);++i)\n#define fs first\n#define sc second\n#define e_b emplace_back\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\treturn os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos << \"[\";\n\tfor (auto& e : v) os << e << \", \";\n\treturn os << \"]\";\n}\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& m) {\n\tos << \"{\" << endl;\n\tfor (auto& e : m) os << \"(\" << e.first << \", \" << e.second << \")\" << endl;\n\treturn os << \"}\";\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& s) {\n\tos << \"{\" << endl;\n\tfor (auto& e : s) os << \", \" << e << endl;\n\treturn os << \"}\";\n}\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint64 gcd(int64 x, int64 y) {\n\tif (x == 0 || y == 0) return 0;\n\tint64 r;\n\twhile ((r = y % x) != 0) {\n\t\ty = x;\n\t\tx = r;\n\t}\n\treturn x;\n}\nint64 lcm(int64 x, int64 y) {\n\tif (x == 0 || y == 0) return 0;\n\treturn x / gcd(x, y) * y;\n}\n\n// int dx[] = { -1, 0, 1, 0 };\n// int dy[] = { 0, 1, 0, -1 };\n\nvoid Main();\nsigned main() {\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(30);\n\tMain();\n}\n\n\n/*----------------------------Insert from here!----------------------------*/\n\nstruct UnionFind {\n\tvector<int> data;\n\n\tUnionFind(int sz) {\n\t\tdata.assign(sz, -1);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return false;\n\t\tif (data[x] > data[y]) swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\treturn true;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint root(int x) {\n\t\tif (data[x] < 0) return x;\n\t\treturn data[x] = root(data[x]);\n\t}\n\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n/*----------------------------Insert above here----------------------------*/\n\n\nvoid Main() {\n\tint n, r; cin >> n >> r;\n\tUnionFind tree(n);\n\trep(i, n) {\n\t\tint p; cin >> p, p--;\n\t\ttree.unite(i, p);\n\t}\n\n\tmap<int, int> m;\n\trep(i, n) {\n\t\tif (tree.root(i) == i) m[tree.size(i)]++;\n\t}\n\n\tr = min(r, n - r);\n\tvint dp(r + 1, -1);\n\tdp[0] = 0;\n\tfor (auto& e : m) {\n\t\tint cnt = e.sc;\n\t\tint v = e.fs;\n\t\tfor (int j = 0; j <= r; ++j) {\n\t\t\tif (dp[j] >= 0) dp[j] = cnt;\n\t\t\telse if (j < v || dp[j - v] <= 0) dp[j] = -1;\n\t\t\telse dp[j] = dp[j - v] - 1;\n\t\t}\n\t}\n\n\tcout << (dp[r] > 0 ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\ntemplate <class T> inline T chmax(T &a, T &b) {a = max(a, b);}\ntemplate <class T> inline T chmin(T &a, T &b) {a = min(a, b);}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr ll INF = 1e18;\nconstexpr double pi = acos(-1);\nconstexpr double EPS = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, r; cin>>n>>r;\n    vector<int> id2p(n);\n    for(int i=0; i<n; i++){\n        int p; cin>>p;\n        id2p[i] = --p;\n    }\n\n    vector<bool> visited(n, false);\n    vector<int> groupNum;\n    for(int i=0; i<n; i++){\n        int cur = i;\n        int cnt = 0;\n        while(!visited[cur]){\n            visited[cur] = true;\n            cur = id2p[cur];\n            cnt++;\n        }\n\n        if(cnt) groupNum.emplace_back(cnt);\n    }\n\n    r = min(r, n - r);\n    bitset<150001> dp;\n    dp[0] = 1;\n    for(auto i : groupNum){\n        dp |= (dp << i);\n    }\n\n    cout << (dp[r] ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n,num;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),num(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  Int size(Int x){\n    return r[find(x)];\n  }\n  Int count() const{\n    return num;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,r;\n  cin>>n>>r;\n  vector<Int> ps(n);\n  for(Int i=0;i<n;i++) cin>>ps[i],ps[i]--;\n\n  UnionFind uf(n);\n  for(Int i=0;i<n;i++) uf.unite(i,ps[i]);\n\n  vector<Int> vs;\n  for(Int i=0;i<n;i++)\n    if(uf.find(i)==i) vs.emplace_back(uf.size(i));\n\n  const Int BS = 600;\n  vector<Int> cnt(BS,0);\n  for(Int v:vs)\n    if(v<BS) cnt[v]++;\n\n  vector<Int> dp(n+1,0);\n  dp[0]=1;\n  for(Int w=1;w<BS;w++){\n    vector<Int> nx(n+1,-1);\n    for(Int i=0;i<=n;i++){\n      if(dp[i]) chmax(nx[i],cnt[w]);\n      if(nx[i]>0&&i+w<=n) chmax(nx[i+w],nx[i]-1);\n    }\n    for(Int i=0;i<=n;i++) dp[i]=nx[i]>=0;\n  }\n\n  for(Int v:vs){\n    if(v<BS) continue;\n    for(Int i=n;i>=0;i--)\n      if(i+v<=n) dp[i+v]|=dp[i];\n  }\n\n  cout<<(dp[r]?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n, r;\n\nstruct U {\n  int a[333333];\n  U() {\n    memset(a, -1, sizeof(a));\n  }\n  int root(int p) {\n    return a[p] < 0 ? p : (a[p] = root(a[p]));\n  }\n  bool same(int p, int q) {\n    return root(p) == root(q);\n  }\n  bool merge(int p, int q) {\n    if (same(p, q)) return false;\n    p = root(p);\n    q = root(q);\n    a[p] += a[q];\n    a[q] = p;\n    return true;\n  }\n  int sz(int p) {\n    return -a[root(p)];\n  }\n};\n\nU uni;\nint cnt[333333];\nbool used[333333];\nint m;\nint a[333333], b[333333];\nint dp[333333];\n\nint main(void) {\n  scanf(\"%d%d\", &n, &r);\n  for (int i = 0; i < n; i++) {\n    int x; scanf(\"%d\", &x); --x;\n    uni.merge(i, x);\n  }\n\n  for (int i = 0; i < n; i++) {\n    int r = uni.root(i);\n    if (!used[r]) {\n      cnt[uni.sz(i)] += 1;\n      used[r] = true;\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (cnt[i]) {\n      a[m] = i;\n      b[m] = cnt[i];\n      // printf(\"%d: %d %d\\n\", m, i, cnt[i]);\n      ++m;\n    }\n  }\n\n  memset(dp, -1, sizeof(dp));\n  dp[0] = 0;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j <= r; j++) {\n      if (dp[j] >= 0) dp[j] = b[i];\n      else if (j < a[i] || dp[j - a[i]] <= 0) dp[j] = -1;\n      else dp[j] = dp[j - a[i]] - 1;\n    }\n  }\n\n  puts(dp[r] >= 0 ? \"Yes\" : \"No\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<(n);i++)\n#define int long long\n\nconst int SIZE=300010;\nvector<int> G[SIZE];\nint visited[SIZE];\nint cnt;\n\nvoid dfs(int v)\n{\n  visited[v]=true;\n  cnt++;\n  for(int u:G[v]){\n    if(!visited[u]){\n      dfs(u);\n    }\n  }\n}\n\nsigned main()\n{\n  int N,R; cin>>N>>R;\n  vector<int> p(N);\n  for(int i=0;i<N;i++){\n    cin>>p[i]; p[i]--;\n  }\n\n  for(int i=0;i<N;i++){\n    G[p[i]].push_back(i);\n  }\n  R=min(R,N-R);\n\n  bitset<SIZE/2> dp;\n  dp[0]=1;\n  for(int i=0;i<N;i++){\n    if(!visited[i]){\n      cnt=0;\n      dfs(i);\n      dp|=(dp<<cnt);\n    }\n  }\n  cout<<(dp[R]? \"Yes\":\"No\")<<endl;;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\nint dp[150010];\nint par[300010],sz[300010];\nint init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i; sz[i] = 1;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x); y = find(y);\n\tif(x==y) return;\n\tif(sz[x]<sz[y]) swap(x,y);\n\tsz[x] += sz[y]; par[y] = x;\n}\n\nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\nint b[300010] = {};\nvector<int> v,u;\nint main(){\n\tint i,j,k,n,r,sum = 0;\n\tcin >> n >> r;\n\tr = min(r,n - r);\n\tinit(n);\n\tfor(i=0;i<n;i++){\n\t\tint a; cin >> a; a--;\n\t\tunite(i,a);\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(par[i]==i && sz[i]!=1){\n\t\t\tb[sz[i]]++;\n\t\t\tsum += sz[i];\n\t\t}\n\t}\n\tfor(i=0;i<=150000;i++) dp[i] = -1;\n\tfor(i=0;i<=n;i++){\n\t\tif(b[i]!=0){\n\t\t\tv.push_back(b[i]);\n\t\t\tu.push_back(i);\n\t\t}\n\t}\n\tdp[0] = 0;\n\tfor(i=0;i<v.size();i++){\n\t\tfor(j=0;j<=r;j++){\n\t\t\tif(dp[j]>=0){\n\t\t\t\tdp[j] = v[i];\n\t\t\t}else if(j - u[i]>=0 && dp[j - u[i]]>=0){\n\t\t\t\tdp[j] = dp[j - u[i]] - 1;\n\t\t\t}else{\n\t\t\t\tdp[j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=r;i>=sum + r - n && i>=0;i--){\n\t\tif(dp[i]>=0 && sum - i<=n - r){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass UnionFind\n{\n    std::vector<int> data;\n\npublic:\n    UnionFind(int size) : data(size, -1) {}\n    bool unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x != y)\n        {\n            if (data[y] < data[x])\n                std::swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    int root(int x)\n    {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x)\n    {\n        return -data[root(x)];\n    }\n};\n\nconstexpr int MAX_N = 300010;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, r;\n    cin >> n >> r;\n    vector<int> p(n), used(n, 0);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> p[i];\n        p[i]--;\n        if (i == p[i])\n            used[i] = 1;\n    }\n    vector<int> sz;\n    int sum = 0;\n    UnionFind uf(n);\n    for (int i = 0; i < n; i++)\n    {\n        if (used[i])\n            continue;\n        int pos = i;\n        used[pos] = 1;\n        while (used[p[pos]] == 0)\n        {\n            uf.unite(pos, p[pos]);\n            pos = p[pos];\n            used[pos] = 1;\n        }\n        sum += uf.size(i);\n        sz.push_back(uf.size(i));\n    }\n    bitset<MAX_N> bs;\n    bs[0] = 1;\n    for (auto v : sz)\n    {\n        bs |= (bs << v);\n    }\n    for (int i = 0; i <= n; i++)\n    {\n        if (bs[i] == 0)\n            continue;\n        int j = sum - i;\n        if(i<=r && j<=n-r)\n        {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n        if(i<=n-r && j<=r)\n        {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define MAX\n\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\tint N, R;\n\tvector<int> P, used, dp;\n\tvector<pair<int,int>> num;\n\tmap<int,int> mp;\n\t\n\tcin>>N>>R;\n\t\n\tP.resize(N+1);\n\tused.resize(N+10,false);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tcin>>P[i];\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(used[i]) continue;\n\t\tint con = 0, now = P[i];\n\t\twhile(true){\n\t\t\tif(used[now])break;\n\t\t\tused[now] = true;\n\t\t\tnow = P[now];\n\t\t\tcon++;\n\t\t}\n\t\tmp[con]++;\n\t\t// num.push_back(con);\n\t}\n\t\n\tfor(pair<int,int> p : mp){\n\t\tnum.push_back(p);\n\t}\n\t\n\tdp.resize(min(R,N-R)+10,false);\n\tdp[0] = true;\n\t\n\tfor(int i = 0; i < num.size(); i++){\n\t\tfor(int j = dp.size()-1; j >= 0; j--){\n\t\t\tif(dp[j]){\n\t\t\t\tfor(int k = j + num[i].first, l = 0; l < num[i].second &&  k < dp.size(); k += num[i].first, l++){\n\t\t\t\t\tif(dp[k]) break;\n\t\t\t\t\tdp[k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<yn(dp[min(R,N-R)])<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define FOR(i, s, n) for (int i = (s); i < (n); i++)\n#define RFOR(i, s, n) for (int i = (n) - 1; i >= (s); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\nconst long long MOD = 1e9+7, INF = 1e18;\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a=b;return true;}return false;}\n\n\nstruct UnionFind{\nint uf[100010];\nint rank1[100010];\n\n//n要素で初期化\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    uf[i]=i;\n    rank1[i]=0;\n  }\n}\n\n//木の根を求める\nint find(int x){\n  if(uf[x]==x){\n    return x;\n  } else {\n    return uf[x]=find(uf[x]);\n  }\n}\n\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n\n  if(rank1[x]<rank1[y]){\n    uf[x]=y;\n  }else{\n    uf[y]=x;\n    if(rank1[x]==rank1[y])rank1[x]++;\n  }\n}\n\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\nreturn find(x)==find(y);\n}\n};\n//arc-d65 連結　latteさん\n//UF uf;\n//uf.init(n)をわすれない\nstruct UF{\n    vector<int>par,sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nsigned main(){\n\tint N,R;\n\tcin>>N>>R;\n\tvector<int>p(N);\n\tUF uf;\n\tuf.init(N);\n\tREP(i,N){\n\t\tcin>>p[i];\n\t\tp[i]--;\n\t\tif(p[i]!=i)uf.unite(i,p[i]);\n\t}\n\tvector<int>cnt(300030,0);\n\tvector<int>used(300030,0);\n\tREP(i,N){\n\t\tif(used[uf.find(i)])continue;\n\t\tcnt[uf.size(i)]++;\n\t\tused[uf.find(i)] = true;\n\t}\n\tvector<pair<int,int>>v;\n\tREP(i,300030){\n\t\tif(cnt[i])v.push_back({i,cnt[i]});\n\t}\n\tvector<int>dp(300030,-1);\n\tdp[0] = 1;\n\tREP(i,v.size()){\n\t\tREP(j,R+1){\n\t\t\tif(dp[j] >= 0){\n\t\t\t\tdp[j] = v[i].second;\n\t\t\t}else if(j < v[i].first || dp[j - v[i].first] <= 0){\n\t\t\t\tdp[j] = -1;\n\t\t\t}else {\n\t\t\t\tdp[j] = dp[j - v[i].first] - 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dp[R] >= 0)cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, R;\n    cin >> N >> R;\n    UnionFind uni(N + 1);\n    for(int i = 1; i <= N; i++) {\n        int P;\n        cin >> P;\n        uni.merge(i, P);\n    }\n    bitset<150001> dp;\n    dp[0] = 1;\n    for(int i = 1; i <= N; i++) {\n        if(uni.root(i) != i) continue;\n        dp |= dp<<uni.size(i);\n    }\n    if(dp[min(R, N - R)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int N = 3e5+10;\nvec edge[N], used(N,0);\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,r;\n  cin >> n >> r;\n\n  vector<int> a(n);\n  REP(i,n) cin >> a[i],a[i]--;\n  \n  vec tmp;map<int,int> mp;\n  REP(i,n){\n    if(used[i]) continue;\n    int id = a[i], cnt=1;\n    used[i]++;\n    while(id != i){\n      used[id]++;\n      id = a[id];\n      cnt++;\n    }\n    mp[cnt]++;\n  }\n\n  int m = mp.size(), k = min(n-r,r);\n\n  mat dp(2,vec(k+1,-1));\n\n  dp[0][0] = 0;\n\n  auto itr = mp.begin();\n  REP(i,m){\n    //cout << itr->fs SP itr->sc << endl;\n    REP(j,k+1){\n      if(dp[i&1][j] >= 0) dp[(i+1)&1][j] = itr->sc;\n      else if (j - itr->fs >= 0 && dp[(i+1)&1][j-itr->fs] > 0) dp[(i+1)&1][j] = dp[(i+1)&1][j-itr->fs] - 1;\n      else dp[(i+1)&1][j] = -1;\n    }\n    //REP(j,k+1) cout << dp[i+1][j] << \" \";\n    //cout << endl;\n    itr++;\n  }\n\n  if(dp[m&1][k] >= 0) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl; \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(i,n) for(long long i = 0;i < n;++i)\npair<int,int> union_tree[400000];\nint union_find(int a) {\n\tif (union_tree[a].first == a) return a;\n\treturn union_tree[a].first = union_find(union_tree[a].first);\n}\nint union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tif (a != b) {\n\t\tunion_tree[a].second += union_tree[b].second;\n\t\tunion_tree[b].second = 0;\n\t\tunion_tree[b].first = union_tree[a].first;\n\t}\n\treturn 0;\n}\nint main() {\n\tiostream::sync_with_stdio(false);\n\tint n, r;\n\tcin >> n >> r;\n\tREP(i, n) {\n\t\tunion_tree[i] = make_pair(i, 1);\n\t}\n\tvector<int> inputs;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tinputs.push_back(a);\n\t}\n\tfor (int i = 0; i < inputs.size(); ++i) {\n\t\tif (inputs[i] != i) {\n\t\t\tunion_merge(i, inputs[i]);\n\t\t}\n\t}\n\tvector<int> gogo;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint hoge = union_find(i);\n\t\tif (union_tree[hoge].second == 0) continue;\n\t\tgogo.push_back(union_tree[hoge].second);\n\t\tunion_tree[hoge].second = 0;\n\t}\n\tsort(gogo.begin(), gogo.end(), greater<int>());\n\tif (gogo.size() <= 100) {\n\t\tset<int> tea;\n\t\ttea.insert(0);\n\t\tfor (int i = 0; i < gogo.size(); ++i) {\n\t\t\tfor (auto q = tea.begin(); q != tea.end(); ++q) {\n\t\t\t\tint hoge = *q;\n\t\t\t\thoge *= -1;\n\t\t\t\thoge += gogo[i];\n\t\t\t\tif (hoge == r) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\ttea.insert(-hoge);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tlong long now = min(r, n - r);\n\t\tfor (int q = 0; q < gogo.size(); ++q) {\n\t\t\tif (now >= gogo[q]) {\n\t\t\t\tnow -= gogo[q];\n\t\t\t}\n\t\t}\n\t\tif (now == 0) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tREP(tea, 100) {\n\t\t\tlong long now = min(r, n - r);\n\t\t\tfor (int q = 0; q < gogo.size(); ++q) {\n\t\t\t\tif (now >= gogo[q]&&rand() % 2 == 0) {\n\t\t\t\t\tnow -= gogo[q];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (now == 0) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nstruct UnionFind {\n    V<ll> rank;\n    V<ll> parent;\n    V<ll> size;\n\n    UnionFind(ll N) : rank(N, 0), parent(N), size(N, 1) {\n        iota(parent.begin(), parent.end(), 0ll);\n    }\n\n    ll find(ll child) {\n        return (child == parent[child] ? child : parent[child] = find(parent[child]));\n    }\n\n    void unit(ll x, ll y) {\n        ll px = find(x);\n        ll py = find(y);\n        if(px == py) {\n            return;\n        }\n        if(rank[px] < rank[py]) {\n            swap(px, py);\n        }\n        parent[py] = px;\n        rank[px] += (rank[px] == rank[py]);\n        size[px] += size[py];\n    }\n\n    bool same(ll x, ll y) {\n        return (find(x) == find(y));\n    }\n};\n    \nconst size_t max_size = 3e5 + 1;\nusing BS = bitset<max_size>;\n\nint main() {\n    ll N, R;\n    cin >> N >> R;\n    V<ll> P(N);\n    for(auto &&e : P) { \n        cin >> e;\n        e--; \n    }\n    UnionFind uf(N);\n    for(ll i = 0; i < N; i++) uf.unit(P[i], i);\n    BS bs(1);\n    ll cnt_one = 0;\n    for(ll i = 0; i < N; i++) if(uf.find(i) == i) {\n        auto s = uf.size[i];\n        if(2 <= s) bs |= (bs << uf.size[i]);\n        else cnt_one++;\n    }\n\n    for(auto n : { R, N - R }) {\n        for(ll i = max<ll>(n - cnt_one, 0); i <= n; i++) if(bs.test(i)) {\n            cout << \"Yes\\n\";\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nvector<int> subset_sum(vector<int> &a, vector<int> &m, int K) {\n    vector<int> dp(K + 1, -1);\n    dp[0] = 0;\n    for (int i = 0; i < a.size(); ++i) {\n        for (int j = 0; j <= K; ++j) {\n            if (dp[j] >= 0) dp[j] = m[i];\n            else if (j < a[i] || dp[j - a[i]] <= 0) dp[j] = -1;\n            else dp[j] = dp[j - a[i]] - 1;\n        }\n    }\n    return dp;\n}\n\nvoid _main() {\n    int N, R;\n    cin >> N >> R;\n    vector<int> P(N), used(N, 0);\n    REP (i, N) {\n        cin >> P[i];\n        P[i]--;\n    }\n    map<int, int> mp;\n    REP (i, N) if (!used[i]) {\n        vector<int> v(1, P[i]);\n        while (v.back() != i) {\n            used[v.back()] = 1;\n            v.push_back(P[v.back()]);\n        }\n        if (v.size() > 1) mp[v.size()]++;\n    }\n    if (R > N - R) R = N - R;\n    if (mp.size() == 0) {\n        cout << \"Yes\" << endl;\n    } else {\n        int sum = 0;\n        vector<int> a, m;\n        for (auto p : mp) {\n            a.push_back(p.first);\n            m.push_back(p.second);\n            sum += a.back() * m.back();\n        }\n        auto dp = subset_sum(a, m, R);\n        int tmp = 0;\n        for (int i = R; i > 0; --i) if (dp[i] >= 0) {\n            tmp = i;\n            break;\n        }\n        cout << (sum - tmp <= N - R ? \"Yes\" : \"No\") << endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e18;\nconst lli mod = 1e9 +7;\ntypedef pair<lli, lli> pll;\n\nint main(){\n\tint n,r;\n\tcin >> n >> r;\n\tvector<int> p(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> p[i];\n\t\tp[i]--;\n\t}\n\tmap<int, int> numsmap;\n\tvector<bool> used(n, false);\n\tfor(int i=0; i<n; i++){\n\t\tif(used[i]) continue;\n\t\tused[i] = true;\n\t\tint curr = p[i];\n\t\tint num = 1;\n\t\twhile(curr != i){\n\t\t\tused[curr] = true;\n\t\t\tcurr = p[curr];\n\t\t\tnum++;\n\t\t}\n\t\tnumsmap[num]++;\n\t}\n\n\tvector<int> nums;\n\tfor(auto p: numsmap){\n\t\tint key = p.first;\n\t\tint value = p.second;\n\t\tint power2 = 1;\n\t\twhile(power2 <= value){\n\t\t\tnums.push_back(key*power2);\n\t\t\tvalue -= power2;\n\t\t\tpower2 *= 2;\n\t\t}\n\t\tnums.push_back(key*value);\n\t}\n\n\tvector<bool> dp(n+1, false);\n\tdp[0] = true;\n\tfor(int i: nums){\n\t\tfor(int j=n; j>=0; j--){\n\t\t\tif(dp[j]) dp[j+i] = true;\n\t\t}\n\t}\n\tif(dp[r]){\n\t\tcout << \"Yes\" << endl;\n\t}else{\n\t\tcout << \"No\" << endl; \n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>(), R = read<int>();\n    auto P = readVec<int>(N);\n    UnionFind uf(N);\n    for (int i = 0; i < N; i++) { uf.unite(P[i] - 1, i); }\n    std::vector<int> c(N, 0);\n    for (int i = 0; i < N; i++) { c[uf.find(i)]++; }\n    std::map<int, int> mp;\n    for (const int C : c) { mp[C]++; }\n    std::vector<ll> W;\n    for (const auto& p : mp) {\n        const ll v = p.first;\n        ll num = p.second;\n        for (ll n = 1; num > 0; n *= 2) {\n            const int use = std::min(n, num);\n            num -= use;\n            W.push_back(v * use);\n        }\n    }\n    std::vector<int> dp(N + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < W.size(); i++) {\n        const int w = W[i];\n        for (int j = N - w; j >= 0; j--) { dp[j + w] |= dp[j]; }\n    }\n    std::cout << (dp[R] == 1 ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Aa^~ kokoro ga pyonpyon suru n jaa^~\n// ZZZXXkXkkkZ!``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ```?Wfpppbpbbpbbpbbbkbkk\n// ppbbbpbbpVr`` `` ` ` ` ` ```` `` ` ` ``  ` ` ` ` ` ` ` ` `  dppbbkkkkkkkkkkqkqkk\n// HkqqqqqkkWr`` ` ` ``` ``` `?G, ` ` ``.JC!```` ` ` `` `` ````(Wpbkkkkkkkkqkkkkkqk\n// mmmmmqqqqpr` `` `` ```````.+zT=`` `` 7TO-.```````` `` `` ```(yppbkkkkkkkkkkkkkkk\n// ggmgmmqqqH$ ``````````....````` `  ````````.`````` `` ``````.yfpppbbbbkkkkqqqqqH\n// gmmmmmqqqkW<```` `````...`````  .,.`  ````....````` ``````` (Wbqqmgmmgmggggggggg\n// qmmmqqqqkkWk.``````````````````` ;:<`` `````.`````````````-_<-?WHHqmmmmmmgmmgggg\n// @@@@@@@gggHH6- ``````````````` `` _ `` ```````````````` ._~~_.`-?Wkqmmmmmmmggg@g\n// @@@@g@gggHY~.-<_- `````````````````````````````````` ._~~(<-``.`.(WHqqqmmggggmmm\n// @@g@gggHH=.`..._<-___..```````````````````````. .-_~~~_(!``-.``.`` OHHWUWHmqHWXW\n// gggggmqK1.``..~.. _<<+-(____..  ````````  ..__~~_((<<!.`.``` .``.`` j0C1XUHmHIdW\n// ggmmqH0!,_``.>`````` _<<;<v<<<++((((((((((<<<<<<~_. (-.``~``.>..```  jOuWHHqHIdH\n// gmmqkW!`(_ J>`    `` ` _~<`_~~~~<<<<<<<~~__````````` ?1. ._`(__```    zXWHg@HkXH\n// gHHWS{``(lJ<!``.``.```(:+>`._`````.` <..`` - ``. `   _ ?&._.I`_`````` .XyVfppppW\n// HHHSv``.(X:_..... _..(;+<!.(<..-.....-.-_..+_`..<.`.`..`_IJd}  .`..````jqg@@@@@@\n// XHWZ{..<Jk~!.`.. (<.-(+>(_.(1.(_..`.`.`.<_.+<_..<<-..._..-zy>.`_`...```.WH@HHHHH\n// bkWt~.-jCz(_..`.(+<.(;< ._-<=_(<_..-....(_.<1<..(<<.`._..-JUS-._.`...```dHmH9VUH\n// WUUO..(f.(c...__+z<-(+~` _-+<_(><..__.`.(<._.z_.(1;_..__.(C(zT-(..`...``(WHR<+Xk\n// kkkk._(_.->..._(z;:_><.._>_+_<(1>_._<...(v<<.(<.(+z<..-_(Z~_<_j+_..`...`(WHKz1ZW\n// @@gR._+_..~..-<+z<<?<>```_.<_.(+1><_;_..(1_:`.<<??1z--(+Z!..<_.j<....`..(bgHAAQX\n// @@mR.(j:..~.._<z!`.(>~``` ~(_.(+<1><><_.(((_`.<__`.<_.(X>...<_.(<.....`.JUWWWyWW\n// @gmH_(zl..(.._+>```<+_````.~>``(+.<?>>_._(<```(<<``(__<>....<.._<.......dXkkkHHH\n// mmqHl(dk_.(_.-=~`.`.1-..._~-1.``_:`(??<_~(`.--.&_.`.<(;<...._.._<..`..._Xg@@@@@@\n// qHkpk(dX<.(;..j_```.(((JJ&a&-~``````.1<_```-(((e+.-(/`(>...._..(<......(Wmggg@@g\n// HVHbWcz><__+_.(_.(dWWHHH@HHc~````````.+~`` (jHMMMHHHm&.?..._<..(<_..._.(WqqHHmHg\n// 0>vWWkzZwl~<o.__`__~X@@HM@Hb ```.`.``. ```` d@@HHH@@K?76...(<..(<_...(_(ppWWWWHq\n// X0XWHKXXw$<(z<.( `` WHHMHHHH_``````````````.WHHMNMHHH_`(...(<_.(z_..._<(fWVC174W\n// XuXWHHWWz>__+z+.!`..??CZYCOX_`````````````.`~.OvTUZUS_`~.._+?_.(_~_.._zjO=1+~+jy\n// kkkkkkkkX:._<z=1(_`` << ``->``.``.``.``.```` ?<`` (v!`._..(??_.(1._.._=dUOOzzzwX\n// @@@@@@@@H<...1O=v<_...__ -_````````````````.`` `` ~.`` :.~+=?~.(;_(...jdQQQQQkkk\n// H@@@@@@@H~...(==>.~~~~~....`.`````````.`````.`........->.(===~~<<.(...(dg@@@@@@@\n// @@@H@@HHH_.__(=l>~.~~~~~....``.``.``.```..`......~~~~~(<_+=l=~_<.->..~_dqggggg@g\n// @H@@@@MHH_._<(=l>...........```````````````.`...~~~~~~+<(=lz=~((j=z_..~jWqmmgggm\n// @@H@@HHWH_._<(lll-.......```.````.``.`..`````........_z<+llZz~(lOO=<...(VYUUUW9Y\n// @@HMMHWZf>~_=:=llw+.`````````.`.```__~~_``.`````.....(z+llOOz_zllOlz~..~<<1+dW>_\n// MMM#MHHWXl~_=>1ltwOl&.`.``.`````.``````````````.````.(llttwtz(OltwOz<..__zwOwwOz\n// HM#HMHUUI<._1z+ttOZttlt&....``.``.`.````.``...``...(zZtttOktzjttttwlz_._<(Xkkkkk\n// HHHmHSZu:(_~+OztttXtttOZZttO+-..............-(+ztOttwttttd0tOZttttwOl<~.(_dMMHHH\n// rvuuXuuI~~<~(uttttwvOwwwkQQHMMHHHHHHHHHMMMNmgey?OwwwrtttwXOtwttttttXtO-~.((wZyyy\n// HHHHHHK>(~(-(dOrtrrl(QgMHMMMHHHHHHHHHHHHHHHH##HMNkX0rrrrXXrd%`` (Ctwwtz_~.<(Wg@H\n// NNNNNHD(~(zo~zXrrrQdHHMMNMHHHHHHHHHHHHHHHHHHHHHH##HNmyrdKkwZ ` _``-zwrt1~~_<(MNM\n// MMMMM#<<_jwr:(Z4QHHMMHMHHHHHHHHHHHHHHHHHHHHHHHHHHHH###NHSXZ>` ~````.OXtt>~._<?MM\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cout << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n\n#ifdef PYONPOI\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cout<<endl; \\\n  }while(0)\n#else\n#define DEBUG\n#endif\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nusing B = bitset<150005>;\nint dp[2][300010];\n\nint main(){\n  int N, R;\n  scanf(\"%d%d\", &N, &R);\n\n  VI xs(N);\n  REP(i,N) scanf(\"%d\", &xs[i]);\n  REP(i,N) --xs[i];\n  VI cnt;\n  vector<bool> vis(N);\n  REP(i,N){\n    if(vis[i]) continue;\n    int crt = i;\n    cnt.PB(0);\n    while(!vis[crt]){\n      vis[crt] = true;\n      crt = xs[crt];\n      cnt.back()++;\n    }\n  }\n\n#if 1\n  SORT(cnt);\n  \n  fill((int*)dp, (int*)dp + 2*300010, INF);\n  int crt = 0, nxt = 1;\n  dp[crt][0] = 0;\n  for(int i=0;i<SZ(cnt);){\n    int w = cnt[i];\n    int c = 0;\n    while(i<SZ(cnt) && cnt[i]==w) ++c, ++i;\n\n    fill((int*)dp[nxt], (int*)dp[nxt] + 300010, INF);\n    for(int x=0;x<=R;++x){\n      if(dp[crt][x] < INF)\n        dp[nxt][x] = 0;\n      \n      if(x - w >= 0 && dp[nxt][x-w] + 1 <= c)\n        mini(dp[nxt][x], dp[nxt][x-w] + 1);\n    }\n    swap(crt, nxt);\n  }\n\n  printf(\"%s\\n\", (dp[crt][R] < INF ? \"Yes\" : \"No\"));\n#else\n  R = min(R, N-R);\n  B bit;\n  bit.set(0);\n  for(auto x: cnt){\n    bit |= bit << x;\n    if(bit[R]) break;\n  }\n  printf(\"%s\\n\", (bit[R]==1 ? \"Yes\" : \"No\"));\n#endif\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\n#define INF (1<<28)\n#define DEKAI 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define int long long\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n\n\n\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  int size(int x){\n    return r[find(x)];\n  }\n  int hoge(int x){\n  \treturn find(x);\n  }\n  int count() const{\n    return num;\n  }\n};\n\n\nsigned main(){\n\tint n,r;\n\tcin>>n>>r;\n\tvector<int> v;\n\tmap<int,int> m;\n\tlp(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\tv.push_back(a);\n\t\tm[a]=i;\n\t}\n\tsort(v.begin(),v.end());\n\tUnionFind UF(n);\n\tlp(i,v.size()){\n\t\tUF.unite(i,m[v[i]]);\n\t}\n\t//cout<<UF.count()<<endl;\n\tvector<int> s;\n\tset<int> h;\n\tlp(i,n){\n\t\tif(h.find(UF.hoge(i))==h.end()){\n\t\t\th.insert(UF.hoge(i));\n\t\t\ts.push_back(UF.size(i));\n\t\t}\n\t}\n\t\n    sort(s.begin(),s.end());\n\tint mm = s.size();\n\n    /*\n    for(int i = 0; i < mm; i++){\n        cerr << s[i] << \" \";\n    }\n    cerr << endl;\n    */\n    vector<int> acc(mm + 1, 0);\n    for(int i = 0; i < mm; i++){\n        acc[i + 1] = s[i];\n        acc[i + 1] += acc[i];\n    }\n\n    if(n - r < r) r = n - r;\n    map<int, int> mp;\n    for(int i = 0; i < mm; i++){\n        mp[s[i]]++;\n    }\n\n    vector<int> w;\n    vector<int> l;\n    \n    for(auto x : mp){\n        w.push_back(x.first);\n        l.push_back(x.second);\n    }\n\n    int k = w.size();\n    \n    /*\n    cerr << k << endl;\n    for(int i = 0; i < k; i++) cerr << w[i] << \" \" << l[i];\n    cerr << endl;\n    */\n\n    vector<int> mono;\n    for(int i = 0; i < k; i++){\n        int val = 1;\n        int sum = 0;\n        for(;; val *= 2){\n            sum += val;\n            if(sum >= l[i]){\n                sum -= val;\n                val = l[i] - sum;\n                mono.push_back(val * w[i]);\n                break;\n            }\n            mono.push_back(val * w[i]);\n        }\n    }\n\n    int kk = mono.size();\n    \n    /*\n    for(int i = 0; i < kk; i++) cerr << mono[i] << \" \";\n    cerr << endl;*/\n    int cur = 0;\n    int nxt = 1;\n    vector<vector<int>> dp(2, vector<int> (r + 10 * n, 0));\n    dp[0][0] = 1;\n    for(int i = 0; i < kk; i++){\n        for(int j = 0; j <= r; j++){\n            if(dp[cur][j] == 0) continue;\n            \n            // 使わない\n            dp[nxt][j] = 1;\n            dp[nxt][j + mono[i]] = 1;\n            \n        }\n        swap(cur, nxt);\n    }\n    \n    /*\n    for(int j = 0; j <= r; j++){\n        cerr << dp[cur][j] << \" \";\n    }\n    cerr << endl;\n    */\n    if(dp[cur][r] == 1 or dp[cur][n - r] == 1) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct UnionFind {\n  const int n;\n  V<> t; // root ? -sz : par\n  UnionFind(int n) : n(n), t(n, -1) {}\n  int find(int v) { return t[v] < 0 ? v : t[v] = find(t[v]); }\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (-t[u] < -t[v]) swap(u, v);\n    t[u] += t[v];\n    t[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int size(int v) { return -t[find(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, r; cin >> n >> r;\n  UnionFind uf(n);\n  for (int i = 0; i < n; ++i) {\n    int p; cin >> p, --p;\n    uf.unite(i, p);\n  }\n  set<int> se;\n  for (int i = 0; i < n; ++i) se.insert(uf.find(i));\n  V<> a;\n  for (int e : se) a.push_back(uf.size(e));\n  bitset<150001> bs;\n  bs[0] = true;\n  for (int e : a) {\n    bs |= bs << e;\n  }\n  cout << (bs[min(r, n - r)] ? \"Yes\" : \"No\") << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n,num;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),num(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  Int size(Int x){\n    return r[find(x)];\n  }\n  Int count() const{\n    return num;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,r;\n  cin>>n>>r;\n  vector<Int> ps(n);\n  for(Int i=0;i<n;i++) cin>>ps[i],ps[i]--;\n\n  UnionFind uf(n);\n  for(Int i=0;i<n;i++) uf.unite(i,ps[i]);\n\n  vector<Int> vs;\n  for(Int i=0;i<n;i++)\n    if(uf.find(i)==i) vs.emplace_back(uf.size(i));\n\n  const Int BS = 600;\n  vector<Int> cnt(BS,0);\n  for(Int v:vs)\n    if(v<BS) cnt[v]++;\n\n  vector<Int> dp(n+1,0);\n  dp[0]=1;\n  for(Int w=1;w<BS;w++){\n    vector<Int> nx(n+1,-1);\n    for(Int i=0;i<=n;i++){\n      if(dp[i]) chmax(nx[i],cnt[w]);\n      if(nx[i]>0&&i+w<=n) chmax(nx[i+w],nx[i]-1);\n    }\n    for(Int i=0;i<=n;i++) dp[i]=nx[i]>=0;\n  }\n\n  for(Int v:vs){\n    if(v<BS) continue;\n    for(Int i=n;i>=0;i--)\n      if(i+v<=n) dp[i+v]|=dp[i];\n  }\n\n  cout<<(dp[r]?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n\n    //-1で初期化。最初はすべてバラバラ\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    //Aがどのグループに属しているか(Aの根)を調べる\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    //AとBをくっつける\n    bool unite(int A, int B) {\n    //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        //既にくっついているからくっつけない\n        if(A == B) return false; \n\n        //大きいほう(A)に小さいほう(B)をくっつける\n        //大小が逆ならひっくり返す\n        if(size(A) < size(B)) swap(A,B);\n\n        //Aのサイズを更新する\n        parent[A] += parent[B];\n        //Bの親をAに変更する\n        parent[B] = A;\n\n        return true;\n    }\n\n    //AとBが同じグループならtrueを返す\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n\n    int n,r;\n    cin>>n>>r;\n    int p[n];\n    UnionFind uni(n);\n    for(int i=0;i<n;i++){\n        cin>>p[i];\n        p[i]--;\n        uni.unite(p[i],i);\n    }\n\n    map<int,int> mp;\n    for(int i=0;i<n;i++){\n        if(uni.root(i)==i) mp[uni.size(i)]++;\n    }\n    int dp[r+1];\n    memset(dp,-1,sizeof(dp));\n    dp[0]=0;\n    for(auto i:mp){\n        for(int j=0;j<=r;j++){\n            if(dp[j]>=0){\n                dp[j]=i.second;\n            }\n            else if(j<i.first || dp[j-i.first]<=0){\n                dp[j]=-1;\n            }\n            else dp[j]=dp[j-i.first]-1;\n        }\n    }\n    if(dp[r]>=0){\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n\n    \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct union_find{\n    VI par;\n\n    void init(int n){\n        par.resize(n);\n        REP(i,n) par[i] = i;\n    }\n\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void merge(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        par[x] = y;\n    }\n};\n\nint main() {\n    int n, r;\n    cin >> n >> r;\n    VI p(n);\n    REP(i,n) p[i] = in() - 1;\n    union_find uf;\n    uf.init(n);\n    REP(i,n) uf.merge(i, p[i]);\n    VI sz(n);\n    REP(i,n) sz[uf.find(i)]++;\n    VI a;\n    REP(i,n) if (sz[i]) a.push_back(sz[i]);\n    chmin(r, n - r);\n\n    bitset<150001> bs;\n    bs.set(0);\n    for (int x : a) bs |= (bs << x);\n    cout << (bs[r] ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint main(){\n    int N, R;\n    cin >> N >> R;\n    int P[300000];\n    UnionFind uf(N);\n    for(int i=0; i<N; i++){\n        cin >> P[i];\n        uf.unite(i, P[i]-1);\n    }\n\n    vector<int> cmp;\n    for(int i=0; i<N; i++) if(uf.find(i) == i) cmp.push_back(uf.size(i));\n\n    R = min(R, N-R);\n    bitset<150001> dp;\n    dp[0] = 1;\n    for(int a : cmp) dp |= (dp << a);\n    cout << (dp[R] ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//int N,M,K,L,R,H,W;\nlong long int N,M,K,L,R,H,W;\n\n//const long long int MOD=1000000007;\nconst int MOD=1000000007;\n//const long long int MOD=998244353;\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>N>>K;\n\tvector<int>p(N);\n\tfor(auto &i:p){\n\t\tcin>>i;\n\t\ti--;\n\t}\n\tUnionFind uf(N);\n\tfor(int i=0;i<N;i++){\n\t\tuf.Unite(i,p[i]);\n\t}\n\tvector<int>v(N);\n\tfor(int i=0;i<N;i++){\n\t\tv[uf.Find(i)]++;\n\t}\n\tK=min(K,N-K);\n\t//vector<int>dp(K+1);\n\t//dp[0]=1;\n\tbitset<150001>bs;\n\tbs.flip(0);\n\tfor(int i=0;i<N;i++){\n\t\tif(!v[i])continue;\n\t\tbs|=(bs<<v[i]);\n\t}\n\tif(bs.test(K))cout<<\"Yes\\n\";\n\telse cout<<\"No\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <bitset>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nbitset<300005> B;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, R;\n\tcin >> N >> R;\n\tvector<int> A(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\t//A[i] = i + 1;\n\t\tA[i]--;\n\t}\n\tvector<int> V(N, 0);\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (V[i] == 0) {\n\t\t\tint t = i;\n\t\t\tint cnt = 1;\n\t\t\tV[i] = 1;\n\t\t\twhile (true) {\n\t\t\t\tt = A[t];\n\t\t\t\tif (t == i)break;\n\t\t\t\tV[t] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//cerr << cnt << endl;\n\t\t\tmp[cnt]++;\n\t\t}\n\t}\n\tB.set(0);\n\tfor (auto m : mp) {\n\t\tint sz = m.first;\n\t\tfor (int i = 0; i <= 20; i++) {\n\t\t\tif ((1 << (i + 1)) - 1 < m.second) {\n\t\t\t\tB = (B | (B << (sz << i)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint x = m.second - ((1 << i) - 1);\n\t\t\t\t//cerr << sz << \" \" << x << endl;\n\t\t\t\tB = (B | (B << (sz * x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 0; i <= N; i++) {\n\t\tcerr << (B[i] ? 1 : 0) << endl;\n\n\n\t}*/\n\n\tif (B[R]) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tUNDEFINED,\n\tUSED,\n\tEITHER,\n};\n\n#define SIZE 300005\n\nint N,R;\nint table[SIZE],num[SIZE];\nint dp[SIZE];\nmap<int,bool> MAP;\nType type[SIZE];\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&R);\n\n\tint num_either;\n\n\tfor(int i = 1; i <= N; i++){\n\n\t\tscanf(\"%d\",&table[i]);\n\t\tif(i == table[i]){\n\n\t\t\ttype[i] = EITHER; //どちらのグループでも良い\n\t\t\tnum_either++;\n\t\t}else{\n\n\t\t\ttype[i] = UNDEFINED;\n\t\t}\n\t}\n\n\tint sum = 0;\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tnum[i] = 0;\n\t}\n\n\tvector<int> V;\n\n\t//場所 != 数字となっている数字の、本来の位置を指したループを作る(グループ1)\n\tfor(int i = 1; i <= N; i++){\n\n\t\tif(type[i] == UNDEFINED){\n\n\t\t\tint count = 0;\n\n\t\t\ttype[i] = USED;\n\t\t\tcount++;\n\n\t\t\tint loc = i;\n\n\t\t\twhile(type[table[loc]] == UNDEFINED){\n\n\t\t\t\ttype[table[loc]] = USED;\n\t\t\t\tcount++;\n\t\t\t\tloc = table[loc];\n\t\t\t}\n\n\t\t\tsum += count;\n\t\t\tnum[count] += 1;\n\n\t\t\tauto at = MAP.find(count); //初登場の数字\n\t\t\tif(at == MAP.end()){\n\n\t\t\t\tMAP[count] = true;\n\t\t\t\tV.push_back(count);\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[0] = 0;\n\tfor(int i = 1; i <= N; i++){\n\n\t\tdp[i] = -1;\n\t}\n\tfor(int i = 0; i < V.size(); i++){ //数の種類のループ\n\t\tfor(int k = 0; k <= N; k++){ //作りたい数のループ\n\n\t\t\tif(dp[k] >= 0){\n\n\t\t\t\tdp[k] = num[V[i]]; //V[i]の個数\n\n\t\t\t}else if(k < V[i] || dp[k-V[i]] <= 0){\n\n\t\t\t\tdp[k] = -1;\n\n\t\t\t}else{\n\n\t\t\t\tdp[k] = dp[k-V[i]]-1; //V[i]を1つ使用\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= max(R,N-R); i++){\n\t\tif(dp[i] < 0)continue; //数字iを作れないならSKIP\n\n\t\tif(min(i,sum-i) <= min(R,N-R) && max(i,sum-i) <= max(R,N-R)){\n\t\t\t//差分は、eitherを適当に割り振って調整\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"No\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind{\nprivate:\n    vector<int> p,s;\n\tint cnt;\npublic:\n\tUnionFind(){}\n\tUnionFind(int N){\n\t\tcnt = N;\n\t\tp = s = vector<int>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(p[x]==x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(s[x]>s[y]){\n\t\t\tp[y] = x;\n\t\t\ts[x] += s[y];\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\ts[y] += s[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tbool is_same_set(int x,int y) {return find(x)==find(y);}\n\tint size(int x) {return s[find(x)];}\n\tint compnents_number(){return cnt;}\n};\n\nint N,R,p;\nint cnt[500010] = {};\nint checked[500010] = {};\nint a[1010] = {},m[1010] = {};\nint dp[500010];\nint main(){\n    cin >> N >> R;\n    UnionFind uf(N);\n    for(int i=1;i<=N;i++){\n        cin >> p;\n        uf.unite(i,p);\n    }\n    int ma = 0;\n    for(int i=1;i<=N;i++) if(!checked[uf.find(i)]){\n        ma = max(ma,uf.size(i));\n        cnt[uf.size(i)]++;\n        checked[uf.find(i)] = 1;\n    }\n    int num = 0;\n    for(int i=1;i<=ma;i++){\n        if(cnt[i]==0) continue;\n        num++;\n        a[num] = i; m[num] = cnt[i];\n    }\n    for(int i=1;i<=R;i++) dp[i] = -1;\n    for(int i=1;i<=num;i++){\n        for(int j=0;j<=R;j++){\n            if(dp[j]>=0) dp[j] = m[i];\n            else if(j<a[i] || dp[j-a[i]]<=0) dp[j] = -1;\n            else dp[j] = dp[j-a[i]]-1;\n        }\n    }\n    cout << (dp[R]>=0? \"Yes\":\"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nstruct UnionFind {\nprivate:\n    vector<int> par,sizes;\npublic:\n    UnionFind (int n) {\n        par.resize(n);\n        sizes = vector<int>(n,1);\n        for (int i = 0;i < n;++i) par[i] = i;\n    }\n\n    int find(int x) {\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x,int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (sizes[x] < sizes[y]) swap(x,y);\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    bool same(int x,int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return sizes[find(x)];\n    }\n};\n\nint main() {\n    int n,r;\n    cin >> n >> r;\n    int s = min(r,n-r);\n    vector<int> a(n),b;\n    bitset<300010> bs;\n    bs.set(0); \n    UnionFind uf(n);\n    for (int i = 0;i < n;++i) cin >> a[i];\n    for (int i = 0;i < n;++i) uf.unite(i,a[i]-1);\n    for (int i = 0;i < n;++i) if (uf.find(i) == i) b.push_back(uf.size(i));\n    for (int& i : b) {\n        bs |= (bs<<i);\n        if (bs[s]) {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvoid solve() {\n\tint n; cin >> n;\n\tuf u(n);\n\tint r; cin >> r;\n\tvector<int> p(n);\n\trep(i, n)cin >> p[i];\n\trep(i, n) {\n\t\tu.unite(i, p[i]-1);\n\t}\n\tvector<int> c(n);\n\trep(i, n) {\n\t\tc[u.find(i)]++;\n\t}\n\tint k = sqrt(n + 0.01);\n\tvector<int> cc(k + 1);\n\tvector<int> v;\n\trep(i, n) {\n\t\tif (c[i] > 0 && c[i] <= k) {\n\t\t\tcc[c[i]]++;\n\t\t}\n\t\telse if (c[i] > k) {\n\t\t\tv.push_back(c[i]);\n\t\t}\n\t}\n\tvector<bool> dp(n + 1); dp[0] = true;\n\trep1(i, k) {\n\t\tif (cc[i] == 0)continue;\n\t\tvector<int> past(i);\n\t\trep(j, n + 1) {\n\t\t\tif (j + i > n)break;\n\t\t\tif (dp[j]) {\n\t\t\t\tif (dp[j + i]) {\n\t\t\t\t\tpast[j%i] = j + i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint t = (j - past[j%i]) / i;\n\t\t\t\t\tif (t < cc[i]) {\n\t\t\t\t\t    dp[j + i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i, v.size()) {\n\t\tper(j, n + 1) {\n\t\t\tif (j + v[i] > n)continue;\n\t\t\tif (dp[j]) {\n\t\t\t\tdp[j + v[i]] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (dp[r]) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tu = root(u), v = root(v);\n\t\tif (u == v) return;\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve(void)\n{\n\tint n, r, p;\n\tcin >> n >> r;\n\tunionfind uf(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> p;\n\t\tuf.unite(i, p-1);\n\t}\n\tvector<int> used(n), ws;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (used[uf.root(i)]) continue;\n\t\tws.push_back(uf.rank[uf.root(i)]);\n\t\tused[uf.root(i)] = 1;\n\t}\n\tbitset<150010> dp;\n\tr = min(r, n - r);\n\tdp[0] = 1;\n\tfor (int w : ws)\n\t{\n\t\tdp |= dp << w;\n\t\tif (dp[r])\n\t\t{\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\n\nint main()\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nclass UnionFind {\n  vector<ll> par, h, sz;\npublic:\n  UnionFind(ll size) : par(size, 0), h(size, 0), sz(size, 1) {\n    rep(i, size) par[i] = i;\n  }\n  void unite(ll u, ll v) {\n    u = root(u), v = root(v);\n    if (u == v) return;\n    if (h[u] < h[v]) {\n      par[u] = v;\n      sz[v] += sz[u];\n    }\n    else {\n      par[v] = u;\n      sz[u] += sz[v];\n    }\n    if (h[u] == h[v]) ++h[u];\n  }\n  ll size(ll v) {\n    return sz[root(v)];\n  }\n  bool isUnited(ll u, ll v) {\n    return root(u) == root(v);\n  }\n  ll root(ll v) {\n    if (par[v] == v) return v;\n    return par[v] = root(par[v]);\n  }\n};\n\nvoid solve() {\n  ll n, R; cin >> n >> R;\n  vector<ll> a(n); cin >> a;\n  each(x, a) --x;\n  UnionFind uf(n);\n  rep(i, n) if (a[i] != i) uf.unite(a[i], i);\n  map<ll, ll> cnt;\n  rep(i, n) cnt[uf.root(i)] = uf.size(i);\n  vector<ll> v;\n  each(p, cnt) v.pb(p.second);\n  bitset<300001> b = false;\n  b[0] = true;\n  ll one = 0;\n  each(x, v) {\n    if (x == 1) one++;\n    else {\n      b |= (b<<x);\n    }\n  }\n  bool ans = false;\n  ll i0 = max(0LL, R-one);\n  rep(i, i0, R+1) {\n    if (b[i]) ans = true;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, R, A[1 << 19]; vector<int> G;\nbool used[1 << 19];\n\nbitset<150005>E;\n\nvoid solve() {\n\tE.set(0);\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tE |= (E << G[i]);\n\t}\n\tif (E[R] == 1) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &R); R = min(R, N - R);\n\tfor (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true) continue;\n\n\t\tint cx = i, cnt = 0;\n\t\twhile (used[cx] == false) {\n\t\t\tused[cx] = true;\n\t\t\tcx = A[cx];\n\t\t\tcnt++;\n\t\t}\n\t\tG.push_back(cnt);\n\t}\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector <bool> v_bool;\ntypedef vector <ll> v_ll;\ntypedef vector <vector <ll> > vv_ll;\ntypedef vector < pair <ll,ll> > vp_ll;\ntypedef pair <ll,ll> p_ll;\n\nbool TEST=false;\nll MOD = 1000000007;\n\nvoid show(){if (TEST){cout << endl;}}\nvoid show(string x){if (TEST){cout << x;}}\nvoid show(string x,bool enter){\n  if (TEST){if (enter) cout << \"<#> \" << x << endl;else cout << x;}\n}\nvoid show(ll x){if (TEST){cout << x;}}\nvoid show(ll x,bool enter){\n  if (TEST){if (enter) cout << \"<#> \" << x << endl;else cout << x;}\n}\nvoid show(p_ll p){\n  if (TEST){cout << \"{ \";show(p.first);cout << \" \";show(p.second);cout << \" }\";}\n}\nvoid show(v_ll v){\n  if (TEST){\n    cout << \"<begin> \";\n    for (ll i=0;i<v.size();i++){show(v[i]); cout << \" \";}cout <<\"<end>\"<< endl;\n}}\nvoid show(vv_ll v){\n  if (TEST){\n    cout << \"//////////\" << endl;\n    for (ll i=0;i<v.size();i++){\n      show(v[i]); cout << endl;\n}}}\nvoid show(vp_ll v){\n  if (TEST){\n    cout << \"//////////\" << endl;\n    for (ll i=0;i<v.size();i++){\n      show(v[i]); cout << endl;\n}}}\n\nll mod(ll x){\n  ll n=MOD;\n  ll ret=x%n;\n  if (ret<0)ret+=n;\n  return ret;\n}\nvoid mod_self(ll &x){\n  x=mod(x);\n}\nll mod_inv(ll x){\n  ll n=MOD;\n  ll y = x,z = n-2, ret=1;\n  y=mod(y);\n  while (z>0){\n    if(z%2==1) ret=mod(ret*y);\n    y=mod(y*y);\n    z/=2;\n  }\n  return ret;\n}\nll mod_pow(ll x,ll a){\n  ll y = x,z = a,ret=1;\n  y=mod(y);\n  if (z<0)z=-z;\n  while (z>0){\n    if(z%2==1) ret=mod(ret*y);\n    y=mod(y*y);\n    z/=2;\n  }\n  if (a<0) ret=mod_inv(ret);\n  return ret;\n}\nv_ll mod_nck(ll n){\n  v_ll nck(n+1,0);\n  nck[0]=1;\n  for (ll i=1;i<=n;i++){\n    nck[i]=mod(nck[i-1]*(n+1-i));\n    nck[i]=mod(nck[i]*mod_inv(i));\n  }\n  return nck;\n}\nv_ll mod_factorial(ll n){\n  v_ll fct(n+1,0);\n  fct[0]=1;\n  for (ll i=1;i<=n;i++){\n    fct[i]=mod(fct[i-1]*i);\n  }\n  return fct;\n}\n\n\n\nll N,R;\nv_ll A;\nint main(){\n  cin >> N >> R;\n  A.assign(N+10,0);\n  for (ll i=1;i<=N;i++){\n    cin >> A[i];\n  }\n  v_bool added,arrived;\n  v_ll comefrom,parent;\n  added.assign(N+10,false);\n  arrived.assign(N+10,false);\n  comefrom.assign(N+10,-1);\n  parent.assign(N+10,-1);\n  queue <ll> que;\n  ll begin=1;\n  que.push(begin);\n  added[begin]=true;\n  v_ll x(N+10,0);\n  ll xi=0;\n  while(!que.empty()){\n    ll now=que.front();\n    que.pop();\n    arrived[now]=true;\n    parent[now]=begin;\n    ll next=A[now];\n    x[xi]++;\n    if (!added[next]){\n      que.push(next);\n      added[next]=true;\n      comefrom[next]=now;\n    }\n    if (que.empty()){\n      while(begin<=N){\n        if (!arrived[begin]){\n          que.push(begin);\n          added[begin]=true;\n          xi++;\n          break;\n        }\n        begin++;\n      }\n    }\n  }\n  v_ll y(N+10,0);\n  map<ll,ll> mp;\n\n  for (ll i=0;i<=N;i++){\n    mp[i]=0;\n  }\n  for (ll i=0;i<=xi;i++){\n    mp[x[i]]++;\n  }\n  for (ll i=0;i<=N;i++){\n    y[i]=mp[i];\n  }\n  v_ll z(N+10,-1);\n  z[0]=0;\n  //TEST=true;\n  //show(x);\n  //show(y);\n  for (ll i=1;i<=N;i++){\n    if (y[i]==0)continue;\n    for (ll j=0;j<=N;j++){\n      if (z[j]>=0) z[j]=0;\n    }\n    for (ll j=i;j<=N;j++){\n      if (z[j-i]>=0 && z[j]<0 && z[j-i]+1<=y[i]){\n        if (z[j]<0)z[j]=0;\n        z[j]=z[j-i]+1;\n      }\n    }\n  }\n  if (z[R]>=0){\n  cout << \"Yes\" << endl;\n  }else{\n    cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Aa^~ kokoro ga pyonpyon suru n jaa^~\n// ZZZXXkXkkkZ!``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ```?Wfpppbpbbpbbpbbbkbkk\n// ppbbbpbbpVr`` `` ` ` ` ` ```` `` ` ` ``  ` ` ` ` ` ` ` ` `  dppbbkkkkkkkkkkqkqkk\n// HkqqqqqkkWr`` ` ` ``` ``` `?G, ` ` ``.JC!```` ` ` `` `` ````(Wpbkkkkkkkkqkkkkkqk\n// mmmmmqqqqpr` `` `` ```````.+zT=`` `` 7TO-.```````` `` `` ```(yppbkkkkkkkkkkkkkkk\n// ggmgmmqqqH$ ``````````....````` `  ````````.`````` `` ``````.yfpppbbbbkkkkqqqqqH\n// gmmmmmqqqkW<```` `````...`````  .,.`  ````....````` ``````` (Wbqqmgmmgmggggggggg\n// qmmmqqqqkkWk.``````````````````` ;:<`` `````.`````````````-_<-?WHHqmmmmmmgmmgggg\n// @@@@@@@gggHH6- ``````````````` `` _ `` ```````````````` ._~~_.`-?Wkqmmmmmmmggg@g\n// @@@@g@gggHY~.-<_- `````````````````````````````````` ._~~(<-``.`.(WHqqqmmggggmmm\n// @@g@gggHH=.`..._<-___..```````````````````````. .-_~~~_(!``-.``.`` OHHWUWHmqHWXW\n// gggggmqK1.``..~.. _<<+-(____..  ````````  ..__~~_((<<!.`.``` .``.`` j0C1XUHmHIdW\n// ggmmqH0!,_``.>`````` _<<;<v<<<++((((((((((<<<<<<~_. (-.``~``.>..```  jOuWHHqHIdH\n// gmmqkW!`(_ J>`    `` ` _~<`_~~~~<<<<<<<~~__````````` ?1. ._`(__```    zXWHg@HkXH\n// gHHWS{``(lJ<!``.``.```(:+>`._`````.` <..`` - ``. `   _ ?&._.I`_`````` .XyVfppppW\n// HHHSv``.(X:_..... _..(;+<!.(<..-.....-.-_..+_`..<.`.`..`_IJd}  .`..````jqg@@@@@@\n// XHWZ{..<Jk~!.`.. (<.-(+>(_.(1.(_..`.`.`.<_.+<_..<<-..._..-zy>.`_`...```.WH@HHHHH\n// bkWt~.-jCz(_..`.(+<.(;< ._-<=_(<_..-....(_.<1<..(<<.`._..-JUS-._.`...```dHmH9VUH\n// WUUO..(f.(c...__+z<-(+~` _-+<_(><..__.`.(<._.z_.(1;_..__.(C(zT-(..`...``(WHR<+Xk\n// kkkk._(_.->..._(z;:_><.._>_+_<(1>_._<...(v<<.(<.(+z<..-_(Z~_<_j+_..`...`(WHKz1ZW\n// @@gR._+_..~..-<+z<<?<>```_.<_.(+1><_;_..(1_:`.<<??1z--(+Z!..<_.j<....`..(bgHAAQX\n// @@mR.(j:..~.._<z!`.(>~``` ~(_.(+<1><><_.(((_`.<__`.<_.(X>...<_.(<.....`.JUWWWyWW\n// @gmH_(zl..(.._+>```<+_````.~>``(+.<?>>_._(<```(<<``(__<>....<.._<.......dXkkkHHH\n// mmqHl(dk_.(_.-=~`.`.1-..._~-1.``_:`(??<_~(`.--.&_.`.<(;<...._.._<..`..._Xg@@@@@@\n// qHkpk(dX<.(;..j_```.(((JJ&a&-~``````.1<_```-(((e+.-(/`(>...._..(<......(Wmggg@@g\n// HVHbWcz><__+_.(_.(dWWHHH@HHc~````````.+~`` (jHMMMHHHm&.?..._<..(<_..._.(WqqHHmHg\n// 0>vWWkzZwl~<o.__`__~X@@HM@Hb ```.`.``. ```` d@@HHH@@K?76...(<..(<_...(_(ppWWWWHq\n// X0XWHKXXw$<(z<.( `` WHHMHHHH_``````````````.WHHMNMHHH_`(...(<_.(z_..._<(fWVC174W\n// XuXWHHWWz>__+z+.!`..??CZYCOX_`````````````.`~.OvTUZUS_`~.._+?_.(_~_.._zjO=1+~+jy\n// kkkkkkkkX:._<z=1(_`` << ``->``.``.``.``.```` ?<`` (v!`._..(??_.(1._.._=dUOOzzzwX\n// @@@@@@@@H<...1O=v<_...__ -_````````````````.`` `` ~.`` :.~+=?~.(;_(...jdQQQQQkkk\n// H@@@@@@@H~...(==>.~~~~~....`.`````````.`````.`........->.(===~~<<.(...(dg@@@@@@@\n// @@@H@@HHH_.__(=l>~.~~~~~....``.``.``.```..`......~~~~~(<_+=l=~_<.->..~_dqggggg@g\n// @H@@@@MHH_._<(=l>...........```````````````.`...~~~~~~+<(=lz=~((j=z_..~jWqmmgggm\n// @@H@@HHWH_._<(lll-.......```.````.``.`..`````........_z<+llZz~(lOO=<...(VYUUUW9Y\n// @@HMMHWZf>~_=:=llw+.`````````.`.```__~~_``.`````.....(z+llOOz_zllOlz~..~<<1+dW>_\n// MMM#MHHWXl~_=>1ltwOl&.`.``.`````.``````````````.````.(llttwtz(OltwOz<..__zwOwwOz\n// HM#HMHUUI<._1z+ttOZttlt&....``.``.`.````.``...``...(zZtttOktzjttttwlz_._<(Xkkkkk\n// HHHmHSZu:(_~+OztttXtttOZZttO+-..............-(+ztOttwttttd0tOZttttwOl<~.(_dMMHHH\n// rvuuXuuI~~<~(uttttwvOwwwkQQHMMHHHHHHHHHMMMNmgey?OwwwrtttwXOtwttttttXtO-~.((wZyyy\n// HHHHHHK>(~(-(dOrtrrl(QgMHMMMHHHHHHHHHHHHHHHH##HMNkX0rrrrXXrd%`` (Ctwwtz_~.<(Wg@H\n// NNNNNHD(~(zo~zXrrrQdHHMMNMHHHHHHHHHHHHHHHHHHHHHH##HNmyrdKkwZ ` _``-zwrt1~~_<(MNM\n// MMMMM#<<_jwr:(Z4QHHMMHMHHHHHHHHHHHHHHHHHHHHHHHHHHHH###NHSXZ>` ~````.OXtt>~._<?MM\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cout << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n\n#ifdef PYONPOI\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cout<<endl; \\\n  }while(0)\n#else\n#define DEBUG\n#endif\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nusing B = bitset<150005>;\n\nint main(){\n  int N, R;\n  scanf(\"%d%d\", &N, &R);\n\n  VI xs(N);\n  REP(i,N) scanf(\"%d\", &xs[i]);\n  REP(i,N) --xs[i];\n\n  VI cnt;\n  vector<bool> vis(N);\n  REP(i,N){\n    if(vis[i]) continue;\n    int crt = i;\n    cnt.PB(0);\n    while(!vis[crt]){\n      vis[crt] = true;\n      crt = xs[crt];\n      cnt.back()++;\n    }\n  }\n\n  R = min(R, N-R);\n  B bit;\n  bit.set(0);\n  for(auto x: cnt){\n    bit |= bit << x;\n    if(bit[R]) break;\n  }\n  printf(\"%s\\n\", (bit[R]==1 ? \"Yes\" : \"No\"));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n \nstruct UnionFind{\nprivate:\n  vector<int> data;\npublic:\n  int N;\n  UnionFind(int n) : data(n, -1), N(n){}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return false;\n    --N;\n    if(data[y] < data[x]) swap(x,y);\n    data[x] += data[y];\n    data[y] = x;\n    return x != y;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  int size(int x){ return -data[find(x)]; }\n};\n\nint main(){\n  int N, R;\n  cin >> N >> R;\n  vector<int> P(N);\n  UnionFind uf(N);\n  for(int i = 0; i < N; ++i){\n    cin >> P[i];\n    --P[i];\n    uf.unite(i,P[i]);\n  }\n  map<long long,int> T;\n  for(int i = 0; i < N; ++i){\n    if(i != uf.find(i)) continue;\n    ++T[uf.size(i)];\n  }\n\n  vector<bool> dp(R+1,false);\n  dp[0] = true;\n\n  for(auto e : T){\n    int w, m;\n    tie(w,m) = e;\n    for(int k = 0; m > 0; ++k){\n      int c = min(m, (1<<k));\n      m -= c;\n      vector<bool> dp_ = dp;\n      for(int j = 0; j <= R; ++j){\n        if(not dp[j]) continue;\n        if(j+c*w > R) break;\n        dp_[j+c*w] = true;\n      }\n      dp = dp_;\n    }\n  }\n  if(dp[R]) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nclass UnionFind {\nprivate:\n  int siz;\n  vector<int> a;\n\npublic:\n  UnionFind(int x) : a(x, -1) {}\n\n  int root(int x) {\n    return a[x] < 0 ? x : a[x] = root(a[x]);\n  }\n\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    siz--;\n    if (a[x] > a[y]) swap(x, y);\n    a[x] += a[y];\n    a[y] =x;\n    return true;\n  }\n\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  int size(int x) {\n    return -a[root(x)];\n  }\n  \n  int conneted_component() {\n  \treturn siz;\n  }\n};\nsigned main() { \n  ios::sync_with_stdio(false); cin.tie(0);\n  int n, r;\n  cin >> n >> r;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    a[i]--;\n  }\n  UnionFind uf(n);\n  for (int i = 0; i < n; i++) {\n    uf.unite(a[i], a[a[i]]);\n  }\n  vector<int> c;\n  for (int i = 0; i < n; i++) {\n    if (i == uf.root(i)) {\n      c.push_back(uf.size(i));\n    }\n  }\n  r = min(r, n - r);\n  bitset<150002> dp;\n  dp[0] = 1;\n  for (int i : c) dp |= (dp << i);\n  if (dp[r]) {\n    puts(\"Yes\");\n  } else {\n    puts(\"No\");\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300010\n\nnamespace FastFourierTransform {\n  using real=double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = {{0, 0},\n                     {1, 0}};\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\nvector<int> dp[SIZE*4];\n\nint main(){\n  int N, R, P[SIZE];\n  vector<int> vec;\n\n  scanf(\"%d%d\", &N, &R);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", P+i);\n    P[i]--;\n  }\n\n  bool used[SIZE] = {};\n  for (int i=0; i<N; i++) {\n    int counter = 0;\n    int now = i;\n\n    while(!used[now]) {\n      used[now] = true;\n      counter++;\n      now = P[now];\n    }\n\n    if (counter)\n      vec.push_back(counter);\n  }\n\n  sort(vec.begin(), vec.end());\n\n  int M = vec.size();\n\n  int n2 = 1;\n  for (;n2 < M; n2*=2);\n\n  for (int i=0; i<M; i++) {\n    dp[i+n2-1].assign(vec[i]+1, 0);\n    dp[i+n2-1][0] = 1;\n    dp[i+n2-1][vec[i]] = 1;\n  }\n\n  for (int i=n2-2; i>=0; i--) {\n    if (dp[i*2+1].empty()) {\n\n    } else if (dp[i*2+2].empty()) {\n      swap(dp[i], dp[i*2+1]);\n    } else {\n      dp[i] = FastFourierTransform::multiply(dp[i*2+1], dp[i*2+2]);\n\n      for (int j=0; j<dp[i].size(); j++)\n        dp[i][j] = !!dp[i][j];\n    }\n  }\n\n  if (dp[0][R]) {\n    puts(\"Yes\");\n  } else {\n    puts(\"No\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int s, d; Weight w; Flow c;\n    Edge() {};\n    Edge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n    g[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n    addArc(g, a, b, w);\n    addArc(g, b, a, w);\n}\n\nint solve(Graph &g, vi &used, int pos, int hop)\n{\n    if (used[pos]) return hop;\n    used[pos] = 1;\n    return solve(g, used, g[pos][0].d, hop+1);\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int2(n, r);\n    vector<int> data(n);\n    for (int i = 0; i < n; i++) {\n        cin >> data[i];\n        data[i]--;\n    }\n\n    Graph g(n);\n    rep(i, data.size()) {\n        addArc(g, i, data[i]);\n    }\n\n    vi used(n, 0);\n    map<int, int> poka;\n    rep(i, n) {\n        if (!used[i]) {\n            poka[solve(g, used, i, 0)]++;\n        }\n    }\n\n    vi dp(n+1, 0);\n    dp[0] = 1;\n    for (auto i = poka.begin(); i != poka.end(); i++) {\n        int tmp = i->sec;\n        for (int k = 1; tmp > 0; k*=2) {\n            int key = min(tmp, k);\n            tmp -= key;\n            for (int j = dp.size()-1; j >= 0; j--) {\n                if (j + key * i->fir < dp.size() && dp[j]) \n                    dp[j + key * i->fir] = 1;\n            }\n        }\n    }\n\n    if (dp[r] || dp[n-r]) {\n        std::cout << \"Yes\" << std::endl;\n    } else {\n        std::cout << \"No\" << std::endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\n#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\nint n,r;\nint a[352521];\n\nint dat[352521];\nint root(int x){\n\treturn dat[x]<0 ? x : dat[x]=root(dat[x]);\n}\nvoid unite(int a,int b){\n\ta=root(a); b=root(b);\n\tif(a==b)return;\n\tif(dat[a]>dat[b])swap(a,b);\n\tdat[a] += dat[b];\n\tdat[b] = a;\n}\n\nbool dp[352521];\n\nint main(){\n\tscanf(\"%d%d\",&n,&r);\n\tREP(i,n)scanf(\"%d\",a+i);\n\tREP(i,n)a[i]--;\n\tfill(dat,dat+n,-1);\n\tREP(i,n)unite(i,a[i]);\n\tmap<int,int> sizes;\n\tREP(i,n)if(root(i)==i)sizes[-dat[i]]++;\n\tdp[0] = true;\n\tauto f = [&](int w){\n\t\tFORR(i,0,n)if(dp[i] && i+w<=n){\n\t\t\tdp[i+w] = true;\n\t\t}\n\t};\n\tfor(pii P : sizes){\n\t\tint w = P.first;\n\t\tint c = P.second;\n\t\tint b = 1;\n\t\twhile(b<=c){\n\t\t\tc -= b;\n\t\t\tf(w*b);\n\t\t\tb *= 2;\n\t\t}\n\t\tif(c>0){\n\t\t\tf(w*c);\n\t\t}\n\t}\n\tputs(dp[r] ? \"Yes\" : \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"Yes\")\n#define p_no() p(\"No\")\n\nvoid vprint(vector<ll> A){\n    ll L = A.size();\n    FOR(i, 0, L){\n        if(i) cout << ' ';\n        cout << A[i];\n    }\n    cout << endl;\n}\n\nstruct UnionFind{\n    vector<ll> parent;\n    UnionFind(ll sz){\n        parent.resize(sz);\n        reset();\n    }\n\n    void reset(){\n        FOR(i, 0, parent.size()){\n            parent[i] = i;\n        }\n    }\n\n    void unite(ll a, ll b){\n        if(a>b){\n            swap(a, b);\n        }\n        // cout << \"unite \" << a << \" \" << b << endl;\n        ll rootA = findRoot(a);\n        ll rootB = findRoot(b);\n        if(rootA>rootB){\n            swap(rootA, rootB);\n        }\n        if(rootA==rootB){\n            return;\n        }else{\n            // 小さい方を親にする\n            parent[rootB] = rootA;\n        }\n    }\n\n    ll findRoot(ll a){\n        if(parent[a]==a){\n            return a;\n        }else{\n            return parent[a] = findRoot(parent[a]);\n        }\n    }\n\n    map<ll, vector<ll> > getGroups(){\n        map<ll, vector<ll> > G;\n        FOR(i, 0, parent.size()){\n            ll r = findRoot(i);\n            G[r].push_back(i);\n        }\n        return G;\n    }\n\n    bool is_same_group(ll a, ll b){\n        ll rootA = findRoot(a);\n        ll rootB = findRoot(b);\n        if(rootA==rootB){\n            return true;\n        }else{\n            return false;\n        }\n    }\n};\n\nconst ll MAX_V = 300010;\nbool dp[MAX_V];\n\n// ant book p64\n// a : value\n// m : count\n// K : target number\nbool can_make(vector<ll>& a, vector<ll>& m, ll K){\n    FOR(i, 0, MAX_V){\n        dp[i] = -1;\n    }    \n    ll N = a.size();\n    FOR(i, 0, N){\n        FOR(j, 0, K+1){\n            if(dp[j]>=0){\n                dp[j]=m[i];\n            }else if(j<a[i] || dp[j-a[i]]<=0){\n                dp[j] = -1;\n            }else{\n                dp[j]=dp[j-a[i]] - 1;\n            }\n        }\n    }\n    if(dp[K]>=0){ \n        return true;\n    }else{\n        return false;\n    }\n}\n\nbool can_make_naive(vector<ll>& a, vector<ll>& m, ll K){\n    vector<ll> V;\n    FOR(i, 0, a.size()){\n        FOR(j, 0, m[i]){\n            V.push_back(a[i]);\n        }\n    }\n    ll N = V.size();\n\n    // p(\"V\");\n    // vprint(V);\n\n    FOR(i, 0, 1<<N){\n        ll sum = 0;\n        FOR(j, 0, N){\n            if(i>>j&1){\n                sum += V[j];\n            }\n        }\n        if(sum==K) return true;\n    }\n    return false;\n}\n\nbool can_make_bitset_ver(vector<ll>& a, vector<ll>& m, ll K){\n    vector<ll> V;\n    FOR(i, 0, a.size()){\n        FOR(j, 0, m[i]){\n            V.push_back(a[i]);\n        }\n    }\n    ll N = V.size();\n    bitset<150001> dp;\n    dp[0] = 1;\n    for(int a : V) dp |= (dp << a);\n    if(dp[K]){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N, R;\n    cin >> N >> R;\n\n    vector<ll> A(N);\n    FOR(i, 0, N){\n        cin >> A.at(i);\n        A[i]--;\n    }\n\n    auto uf = UnionFind(N);\n\n    FOR(i, 0, N){\n        uf.unite(i, A[i]);\n    }\n\n    auto group_mp = uf.getGroups();\n    map<ll, ll> mp;\n    for(auto pa : group_mp){\n        ll sz = pa.second.size();\n        mp[sz]++;\n    }\n    \n    vector<ll> V; // value\n    vector<ll> C; // count\n    for(auto pa : mp){\n        ll v = pa.first;\n        ll c = pa.second;\n        V.push_back(v);\n        C.push_back(c);\n    }\n    // vprint(V);\n    // vprint(C);\n\n    // if(can_make_naive(V, C, R)){\n    if(can_make_bitset_ver(V, C, min(N-R, R))){\n    // if(can_make(V, C, R)){\n        p_yes();\n    }else{\n        p_no();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nusing B = std::bitset<150005>;\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, r); r = std::min(r, n - r);\n\tVEC(int, p, n);\n\tREP(i, n) --p[i];\n\n\tV<int> a;\n\tV<bool> used(n, false);\n\n\tint one = 0;\n\n\tREP(i, n) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tint now = p[i];\n\t\tint cnt = 1;\n\t\twhile (now != i) {\n\t\t\t++cnt;\n\t\t\tused[now] = true;\n\t\t\tnow = p[now];\n\t\t}\n\t\tif (cnt == 1) ++one;\n\t\telse a.emplace_back(cnt);\n\t}\n\n\tB dp = 0;\n\tdp[0] = 1;\n\tfor (const auto& x : a) {\n\t\tdp |= dp << x;\n\t}\n\tint ma = 0;\n\tREP(i, r + 1) {\n\t\tif (dp[i]) ma = i;\n\t}\n\n\tif (IN(ma, r, ma + one + 1)) {\n\t\tOUT(\"Yes\")BR;\n\t}\n\telse {\n\t\tOUT(\"No\")BR;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef struct union_find {\n  int32_t *parent;\n  int32_t size;\n} union_find;\n\nvoid init_union_find (union_find * const u) {\n  for (int32_t i = 0; i < u->size; ++i){\n    u->parent[i] = -1;\n  }\n}\n\nunion_find* new_union_find (const int32_t size) {\n  union_find * const u = (union_find *) calloc (1, sizeof (union_find));\n  u->parent = (int32_t *) calloc (size, sizeof (int32_t));\n  u->size = size;\n  init_union_find (u);\n  return u;\n}\n\nint32_t root (union_find * const u, int32_t x) {\n  if (u->parent[x] < 0) return x;\n  return u->parent[x] = root (u, u->parent[x]);\n}\n\nvoid unite (union_find * const u, int32_t x, int32_t y) {\n  x = root (u, x);\n  y = root (u, y);\n  if (x == y) return;\n  if (u->parent[x] > u->parent[y]) {\n    const int32_t swap = x;\n    x = y;\n    y = swap;\n  }\n  u->parent[x] += u->parent[y];\n  u->parent[y] = x;\n}\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n#define SORT(a,num,cmp) qsort((a),(num),sizeof(*(a)),cmp)\n\nint cmp_int (const void *a, const void *b) {\n  i32 d = *(i32 *)a - *(i32 *)b;\n  return d == 0 ? 0 : d > 0 ? -1 : 1;\n}\n\nvoid run (void) {\n  i32 n, r;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &r);\n  i32 *p = ALLOC (n + 1, i32);\n  for (i32 i = 1; i <= n; ++i) {\n    scanf (\"%\" SCNi32, p + i);\n  }\n  union_find *u = new_union_find (n + 1);\n  for (i32 i = 1; i <= n; ++i) {\n    unite (u, i, p[i]);\n  }\n  i32 *size = ALLOC (n + 1, i32);\n  for (i32 i = 1; i <= n; ++i) {\n    size[root (u, i)]++;\n  }\n  SORT (size, n + 1, cmp_int);\n  i32 len = 1;\n  while (size[len] > 0) ++len;\n  uint8_t *dp = ALLOC (r + 1, uint8_t);\n  dp[0] = 1;\n  for (i32 i = 0; i < len;) {\n    i32 s = size[i];\n    i32 c = 0;\n    for (; i < len && size[i] == s; ++i) c++;\n    i32 b = 1;\n    while (c > 0) {\n      i32 p = s * b;\n      for (i32 j = r - p; j >= 0; --j) {\n        dp[j + p] |= dp[j];\n      }\n      c -= b;\n      b = MIN (2 * b, c);\n    }\n  }\n  puts (dp[r] ? \"Yes\" : \"No\");\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define ull unsigned long long\n#define rep(i,l,r)for(int i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\n\nint a[300010];\nint num[300010];\null s[50000];\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tk=min(k,n-k);\n\trep(i,1,n+1)scanf(\"%d\",num+i);\n\t\n\trep(i,1,n+1)if(num[i]){\n\t\tint cnt=0;\n\t\tfor(int crr=i;num[crr];){\n\t\t\tint t=num[crr];\n\t\t\tnum[crr]=0;\n\t\t\tcrr=t;\n\t\t\tcnt++;\n\t\t}\n\t\ta[cnt]++;\n\t}\n\t\n\trep(i,0,n)if(a[i]>1){\n\t\ta[i]--;\n\t\tfor(int s=2;a[i]>=s;s*=2){\n\t\t\ta[i]-=s;\n\t\t\ta[i*s]++;\n\t\t}\n\t\tif(a[i]>1)a[i*a[i]]++,a[i]=0;\n\t\ta[i]++;\n\t}\n\n\tint sum=0;\n\ts[0]=1;\n\trep(i,1,n/2+1)rep(_,0,a[i]){\n\t\tfor(int j=sum/64;j>=0;j--){\n\t\t\tif(i%64)s[j+i/64+1]|=s[j]>>(64-i%64);\n\t\t\ts[j+i/64]|=s[j]<<(i%64);\n\t\t}\n\t\tsum=min(n/2,sum+i);\n\t}\n\tputs(bit(s[k/64],k%64)?\"Yes\":\"No\");\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint R = sc.nextInt();\n\t\tR = Math.min(R, N - R);\n\t\tint[] P = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tP[i] = Integer.parseInt(sc.next()) - 1;\n\t\t}\n\t\tint one = 0;\n\t\tArrayList<Integer> len = new ArrayList<>();\n\t\tboolean[] used = new boolean[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (used[i]) continue;\n\t\t\tint cur = i;\n\t\t\tint l = 1;\n\t\t\tused[cur] = true;\n\t\t\twhile (P[cur] != i) {\n\t\t\t\tcur = P[cur];\n\t\t\t\t++l;\n\t\t\t\tused[cur] = true;\n\t\t\t}\n\t\t\tif (l == 1) {\n\t\t\t\tone++;\n\t\t\t} else {\n\t\t\t\tlen.add(l);\n\t\t\t}\n\t\t}\n\t\tBits bs = new Bits(R + 1);\n\t\tbs.bits[0] = 1L;\n\t\tfor (int i = 0; i < len.size(); i++) {\n\t\t\tbs.shiftLOr(len.get(i));\n\t\t}\n\t\tboolean ans = false;\n\t\tfor (int i = 0; i <= one && i <= R; i++) {\n\t\t\tif (bs.get(R - i)) {\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\n\t}\n\n\tstatic class Bits {\n\t\tlong[] bits;\n\n\t\tBits(int size) {\n\t\t\tbits = new long[(size + 63) / 64];\n\t\t}\n\n\t\tvoid shiftLOr(int shift) {\n\t\t\tint m1 = shift >> 6;\n\t\t\tint m2 = shift & 63;\n\t\t\tif (m2 == 0) {\n\t\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\t\tbits[i + m1] |= bits[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\t\tint p1 = i + m1 + 1;\n\t\t\t\t\tint p2 = i + m1;\n\t\t\t\t\tlong v1 = bits[i] >>> (64 - m2);\n\t\t\t\t\tlong v2 = bits[i] << m2;\n\t\t\t\t\tif (p1 < bits.length) {\n\t\t\t\t\t\tbits[p1] |= v1;\n\t\t\t\t\t}\n\t\t\t\t\tbits[p2] |= v2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tboolean get(int pos) {\n\t\t\treturn ((bits[pos >> 6] >>> (pos & 63)) & 1) != 0;\n\t\t}\n\n\t\tvoid set(int pos) {\n\t\t\tbits[pos >> 6] |= (1L << (pos & 63));\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class Main implements Runnable {\n\t\n\t//static int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        PrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int r = sc.nextInt();\n        \n        int[] p = sc.nextintArray(n);\n        for(int i=0;i<n;i++){\n        \tp[i]--;\n        }\n        \n        UnionFind uft = new UnionFind(n);\n        \n        for(int i=0;i<n;i++){\n        \tuft.unite(i, p[i]);\n        }\n        \n        ArrayList<Integer> size = new ArrayList<>();\n        \n        boolean[] checked = new boolean[n];\n        int onenum = 0;\n        \n        for(int i=0;i<n;i++){\n        \tint root = uft.find(i);\n        \tif(!checked[root]){\n        \t\tchecked[root] = true;\n        \t\tint ssize = uft.setSize(root);\n        \t\tif(ssize == 1){\n        \t\t\tonenum++;\n        \t\t}\n        \t\telse{\n        \t\t\tsize.add(ssize);\n        \t\t}\n        \t}\n        }\n        \n        if(size.size() == 0){\n        \tout.println(\"Yes\");\n        \tout.flush();\n        \treturn;\n        }\n\n        BitVector dp = new BitVector(r+1);\n        dp.set(0);\n        if(size.get(0)<=r){\n            dp.set(size.get(0));\n        }\n        \n        for(int i=0;i<size.size()-1;i++){\n        \tdp.shiftLOr(size.get(i+1));\n        }\n        \n        boolean can = false;\n        \n        for(int i=0;i<=onenum && r-i>=0;i++){\n        \tif(dp.get(r-i)){\n        \t\tcan = true;\n        \t\tbreak;\n        \t}\n        }\n\n        if(can){\n        \tout.println(\"Yes\");\n        }\n        else{\n        \tout.println(\"No\");\n        }\n        \n        out.flush();\n    }\n    \n}\n\nclass BitVector {\n    public int n;\n    public int m;\n    public long[] bits;\n\n    public BitVector(int length) {\n        n = length;\n        bits = new long[(n+63)>>>6];\n        m = bits.length;\n    }\n\n    public void set(int at) {\n        bits[at>>>6] |= 1L<<(at&63);\n    }\n\n    public void set(int at, boolean s) {\n        if (s) {\n            bits[at>>>6] |= 1L<<(at&63);\n        } else {\n            bits[at>>>6] &= ~(1L<<(at&63));\n        }\n    }\n\n    public boolean get(int at) {\n        int big = at >>> 6 ;\n        if (big >= bits.length) {\n            return false;\n        }\n        return ((bits[big] >>> (at&63)) & 1) == 1;\n    }\n\n    public BitVector shiftLeft(int l) {\n        BitVector ret = new BitVector(n+l);\n        int big = l >>> 6;\n        int small = l & 63;\n        for (int i = 0; i < m ; i++) {\n            ret.bits[i+big] |= bits[i] << small;\n        }\n        if (small >= 1) {\n            for (int i = 0; i+big+1 < ret.m; i++) {\n                ret.bits[i+big+1] |= (bits[i] >>> (64-small));\n            }\n        }\n        return ret;\n    }\n    \n\tvoid shiftLOr(int shift) {\n\t\tint m1 = shift >> 6;\n\t\tint m2 = shift & 63;\n\t\tif (m2 == 0) {\n\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\tbits[i + m1] |= bits[i];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = bits.length - 1 - m1; i >= 0; i--) {\n\t\t\t\tint p1 = i + m1 + 1;\n\t\t\t\tint p2 = i + m1;\n\t\t\t\tlong v1 = bits[i] >>> (64 - m2);\n\t\t\t\tlong v2 = bits[i] << m2;\n\t\t\t\tif (p1 < bits.length) {\n\t\t\t\t\tbits[p1] |= v1;\n\t\t\t\t}\n\t\t\t\tbits[p2] |= v2;\n\t\t\t}\n\t\t}\n\t}\n\n    public BitVector or(BitVector o) {\n        BitVector ans = new BitVector(Math.max(n, o.n));\n        for (int i = 0; i < ans.m ; i++) {\n            if (i < m) {\n                ans.bits[i] = bits[i];\n            }\n            if (i < o.m) {\n                ans.bits[i] |= o.bits[i];\n            }\n        }\n        return ans;\n    }\n}\n\nclass UnionFind {\n\tint[] par;\n\tint[] rank;\n\tint[] peers; //集合の要素数用\n\t\n\tpublic UnionFind(int n){\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tpeers = new int[n];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i] = i;\n\t\t\tpeers[i] = 1;\n\t\t}\n\t}\n\t\n\t//木の根を求める\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}\n\t\telse{\n\t\t\treturn par[x] = find(par[x]);\t//経路圧縮\n\t\t}\n\t}\n\t\n\t//xとyの属する集合を併合\n\tpublic void unite(int x, int y){\n\t\tint px = find(x);\n\t\tint py = find(y);\n\t\t\n\t\tif(px == py){\n\t\t\treturn;\n\t\t}\n\t\telse if(rank[px] < rank[py]){\n\t\t\tpeers[py] += peers[px];\n\t\t\tpar[px] = py;\n\n\t\t}\n\t\telse{\n\t\t\tpeers[px] += peers[py];\n\t\t\tpar[py] = px;\n\t\t\tif(rank[px]==rank[py]){\n\t\t\t\trank[px]++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//xとyが同じ集合に属するか\n\tpublic boolean isSame(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\t//xの仲間の数を求める\n\tpublic int setSize(int x){\n\t\treturn peers[find(x)];\n\t}\n\n\t//頂点数\n\tpublic int N(){\n\t\treturn par.length;\n\t}\n\t\n\t//全体でいくつの集合に分かれているか\n\tpublic int numOfSet(){\n\t\tint ans = 0;\n\t\tboolean[] checked = new boolean[N()];\n\t\tfor(int i=0;i<N();i++){\n\t\t\tint r = find(i);\n\t\t\tif(!checked[r]){\n\t\t\t\tchecked[r] = true;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n}\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic int[][] nextintMatrix(int h, int w){\n\t\tint[][] mat = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tmat[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.HUPC_day2\n{\n    class D\n    {\n        static void Main(string[] args)\n        {\n            Method(args);\n        }\n\n        static void Method(string[] args)\n        {\n            int[] nr = ReadInts();\n            int n = nr[0];\n            int r = nr[1];\n            int[] ps = ReadInts();\n            int[] groups = new int[n];\n            for(int i = 0; i < n; i++)\n            {\n                groups[i] = -1;\n            }\n            int groupCnt = 0;\n            for(int i = 0; i < n; i++)\n            {\n                if (groups[i] >= 0) continue;\n\n                HashSet<int> posSet = new HashSet<int>();\n                int now = i;\n                while (!posSet.Contains(now))\n                {\n                    posSet.Add(now);\n                    groups[now] = groupCnt;\n                    now = ps[now] - 1;\n                }\n                groupCnt++;\n            }\n\n            int[] cnts = new int[groupCnt];\n            for(int i = 0; i < n; i++)\n            {\n                cnts[groups[i]]++;\n            }\n\n            List<int[]> cntParams = new List<int[]>();\n            for (int i = 0; i < groupCnt; i++)\n            {\n                if (cntParams.Count == 0) {\n                    cntParams.Add(new int[2] { cnts[i], 1 });\n                }\n                else\n                {\n                    if (cntParams[cntParams.Count - 1][0] == cnts[i])\n                    {\n                        cntParams[cntParams.Count - 1][1]++;\n                    }\n                    else\n                    {\n                        cntParams.Add(new int[2] { cnts[i], 1 });\n                    }\n                }\n            }\n\n            int[,] dp = new int[cntParams.Count, r + 1];\n            for(int i = 0; i < cntParams.Count; i++)\n            {\n                for(int j = 0; j < r + 1; j++)\n                {\n                    dp[i, j] = -1;\n                }\n            }\n\n            for(int i = 0; i < cntParams.Count; i++)\n            {\n                dp[i, 0] = cntParams[i][1];\n                for(int j = 0; j < r + 1; j++)\n                {\n                    if (i > 0 && dp[i - 1, j] >= 0)\n                    {\n                        dp[i, j] = cntParams[i][1];\n                    }\n                    else if (j - cntParams[i][0] >= 0 \n                        && dp[i, j - cntParams[i][0]] > 0)\n                    {\n                        dp[i, j] = dp[i, j - cntParams[i][0]] - 1;\n                    }\n                }\n            }\n\n            if (dp[cntParams.Count-1,r]>=0)\n            {\n                WriteLine(\"Yes\");\n            }\n            else\n            {\n                WriteLine(\"No\");\n            }\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nN, R = map(int, input().split())\nif 2*R > N:\n    R = N - R\nP = [0] + list(map(int, input().split()))\n\nL = []\nused = [False]*(N+1)\npre = 0\nfor i in range(1, N+1):\n    cnt = 0\n    while not used[i]:\n        used[i] = True\n        cnt += 1\n        i = P[i]\n    if cnt:\n        L.append(cnt)\ntable = [0]*(N+1)\nfor l in L:\n    table[l] += 1\nL = []\nfor i in range(N//2, 0, -1):\n    x = table[i]\n    if not x:\n        continue\n    if x == 1:\n        L.append(i)\n    else:\n        p = 1 \n        while p+p <= x:\n            L.append(p*i)\n            p = p+p\n        if x - p + 1:\n            L.append(i*(x - p + 1))\nL = [l for l in L if l <= R]\nL.sort()\nH = 1\nfor l in L:\n    H = H|(H<<l)\nif H & 1<<R:\n    print('Yes')\nelse:\n    print('No')\n"
  },
  {
    "language": "Python",
    "code": "N, R = map(int, input().split())\nif 2*R > N:\n    R = N - R\nP = [0] + list(map(int, input().split()))\n\nL = []\nLapp = L.append\nused = [False]*(N+1)\npre = 0\nfor i in range(1, N+1):\n    cnt = 0\n    while not used[i]:\n        used[i] = True\n        cnt += 1\n        i = P[i]\n    if cnt:\n        Lapp(cnt)\ntable = [0]*(N+1)\nfor l in L:\n    table[l] += 1\nL = []\nLapp = L.append\nfor i in range(1, min(R,N//2)+1):\n    x = table[i]\n    if not x:\n        continue\n    if x == 1:\n        Lapp(i)\n    else:\n        Lapp(i)\n        p = 2\n        while 2*p <= x:\n            table[p*i] += 1\n            p *= 2\n        if x == p:\n            Lapp(i)\n        table[i*(x - p + 1)] += 1\nH = 1\nfor l in L:\n    H = H|(H<<l)\nif H & 1<<R:\n    print('Yes')\nelse:\n    print('No')\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::collections::BTreeMap;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let r: usize = sc.read();\n    let p: Vec<usize> = sc.vec::<usize>(n).into_iter().map(|x| x - 1).collect();\n\n    let mut used = vec![0; n];\n    let mut cur = 1;\n    for i in 0..n {\n        if used[i] != 0 {\n            continue;\n        }\n        let mut pos = i;\n        while used[pos] == 0 {\n            used[pos] = cur;\n            pos = p[pos];\n        }\n        cur += 1;\n    }\n\n    let count = used\n        .into_iter()\n        .fold(BTreeMap::new(), |mut map, x| {\n            *map.entry(x).or_insert(0) += 1;\n            map\n        })\n        .into_iter()\n        .fold(BTreeMap::new(), |mut map, (_, count)| {\n            *map.entry(count).or_insert(0) += 1;\n            map\n        });\n\n    let r = cmp::min(r, n - r);\n    let mut dp = vec![-1; r + 1];\n    dp[0] = 0;\n    for (a, m) in count.into_iter() {\n        for j in 0..(r + 1) {\n            if dp[j] >= 0 {\n                dp[j] = m;\n            } else if j < a || dp[j - a] <= 0 {\n                dp[j] = -1;\n            } else {\n                dp[j] = dp[j - a] - 1;\n            }\n        }\n    }\n\n    if dp[r] >= 0 {\n        println!(\"Yes\");\n    } else {\n        println!(\"No\");\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/keyence2019/submissions/4071067\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![0; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] = std::cmp::max(self.rank[y], self.rank[x] + 1);\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n}\n\n// Verified by https://atcoder.jp/contests/arc084/submissions/3935443\n#[derive(Clone)]\nstruct BitSet {\n    size: usize,\n    buf: Vec<usize>,\n}\n\nimpl BitSet {\n    // size should be a multiple of bit-size of usize.\n    fn new(size: usize) -> Self {\n        let w = 8 * std::mem::size_of::<usize>();\n        assert_eq!(size & (w - 1), 0);\n        let count = size / w;\n        BitSet {\n            size: size,\n            buf: vec![0; count],\n        }\n    }\n    #[allow(unused)]\n    fn set(&mut self, idx: usize, val: bool) {\n        debug_assert!(idx < self.size);\n        let w = 8 * std::mem::size_of::<usize>();\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        if val {\n            self.buf[idx0] |= 1 << idx1;\n        } else {\n            self.buf[idx0] &= !(1 << idx1);\n        }\n    }\n    #[allow(unused)]\n    fn get(&self, idx: usize) -> bool {\n        let w = 8 * std::mem::size_of::<usize>();\n        debug_assert!(idx < self.size);\n        let idx0 = idx / w;\n        let idx1 = idx & (w - 1);\n        (self.buf[idx0] >> idx1 & 1) == 1\n    }\n    #[allow(unused)]\n    fn shl(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i];\n            }\n        } else {\n            ans.buf[sh0] = self.buf[0] << sh1;\n            for i in 1 .. count - sh0 {\n                ans.buf[i + sh0] = self.buf[i] << sh1\n                    | self.buf[i - 1] >> (w - sh1);\n            }\n        }\n        ans\n    }\n    // Not verified\n    #[allow(unused)]\n    fn shr(&self, val: usize) -> Self {\n        if val >= self.size { return Self::new(self.size); }\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        let sh0 = val / w;\n        let sh1 = val & (w - 1);\n        let mut ans = Self::new(self.size);\n        if sh1 == 0 {\n            for i in 0 .. count - sh0 {\n                ans.buf[i] = self.buf[i + sh0];\n            }\n        } else {\n            for i in 0 .. count - sh0 - 1 {\n                ans.buf[i] = self.buf[i + sh0] >> sh1\n                    | self.buf[i + sh0 + 1] << (w - sh1);\n            }\n            ans.buf[self.size - sh0 - 1] = self.buf[self.size - 1] >> sh1;\n        }\n        ans\n    }\n    #[allow(unused)]\n    fn msb(&self) -> Option<usize> {\n        let w = 8 * std::mem::size_of::<usize>();\n        let count = self.size / w;\n        for i in (0 .. count).rev() {\n            let v = self.buf[i];\n            if v != 0 {\n                return Some(w * i + w - 1 - v.leading_zeros() as usize);\n            }\n        }\n        None\n    }\n}\n\n// TODO reference is not allowed as rhs\nimpl std::ops::BitXorAssign for BitSet {\n    fn bitxor_assign(&mut self, other: BitSet) {\n        debug_assert_eq!(self.size, other.size);\n        for i in 0 .. self.buf.len() {\n            self.buf[i] ^= other.buf[i];\n        }\n    }\n}\n// TODO reference is not allowed as rhs\nimpl std::ops::BitOrAssign for BitSet {\n    fn bitor_assign(&mut self, other: BitSet) {\n        debug_assert_eq!(self.size, other.size);\n        for i in 0 .. self.buf.len() {\n            self.buf[i] |= other.buf[i];\n        }\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize, r: usize,\n        a: [usize1; n],\n    }\n    let mut uf = UnionFind::new(n);\n    for i in 0..n {\n        uf.unite(i, a[i]);\n    }\n    let mut occ = vec![0; n];\n    for i in 0..n {\n        occ[uf.root(i)] += 1;\n    }\n    const W: usize = 300_000 / 64 * 64 + 64;\n    let mut bs = BitSet::new(W);\n    bs.set(0, true);\n    let mut num = vec![];\n    let mut one = 0;\n    for i in 0..n {\n        if occ[i] == 0 { continue; }\n        if occ[i] == 1 {\n            one += 1;\n        } else {\n            num.push(occ[i]);\n        }\n    }\n    for n in num {\n        let tmp = bs.shl(n);\n        bs |= tmp;\n    }\n    let mut ok = false;\n    for i in 0..one + 1 {\n        if r >= i && bs.get(r - i) {\n            ok = true;\n        }\n    }\n    puts!(\"{}\\n\", if ok { \"Yes\" } else { \"No\" });\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use self::bitset::BitSet;\nuse std::cmp;\nuse std::collections::BTreeMap;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n = sc.read();\n    let r: usize = sc.read();\n    let x: Vec<usize> = sc.vec::<usize>(n).into_iter().map(|x| x - 1).collect();\n    let mut used = vec![0; n];\n    let mut phase = 1;\n    for i in 0..n {\n        if used[i] != 0 {\n            continue;\n        }\n        let mut cur = i;\n        while used[cur] == 0 {\n            used[cur] = phase;\n            cur = x[cur];\n        }\n        phase += 1;\n    }\n\n    let mut map = BTreeMap::new();\n    for p in used.into_iter() {\n        *map.entry(p).or_insert(0) += 1;\n    }\n\n    let mut count = vec![0; n + 1];\n    for (_, c) in map.into_iter() {\n        count[c] += 1;\n    }\n\n    let one = count[1];\n    let count = count\n        .into_iter()\n        .enumerate()\n        .filter(|&(v, c)| v > 1 && c > 0)\n        .collect::<Vec<(usize, usize)>>();\n\n    let r = cmp::min(r, n - r);\n    let mut b = BitSet::new(1);\n    b.set(0, true);\n    for (v, count) in count.into_iter() {\n        for _ in 0..count {\n            let c = b.shift_left(v);\n            b |= c;\n        }\n    }\n\n    for i in 0..(one + 1) {\n        if r >= i && b.get(r - i) {\n            println!(\"Yes\");\n            return;\n        }\n    }\n\n    println!(\"No\");\n}\n\npub mod bitset {\n    use std::ops::{BitOrAssign, Shl};\n    const ONE_VALUE_LENGTH: usize = 63;\n    const MAXIMUM: u64 = (1u64 << ONE_VALUE_LENGTH as u64) - 1;\n\n    pub fn get_bit_position(index: usize) -> (usize, usize) {\n        let data_index = index / ONE_VALUE_LENGTH;\n        let bit_index = index % ONE_VALUE_LENGTH;\n        (data_index, bit_index)\n    }\n\n    #[derive(PartialEq, Clone, Debug)]\n    pub struct BitSet {\n        data: Vec<u64>,\n    }\n\n    impl BitOrAssign for BitSet {\n        fn bitor_assign(&mut self, rhs: Self) {\n            if self.data.len() < rhs.data.len() {\n                self.data.resize(rhs.data.len(), 0);\n            }\n            let n = if self.data.len() > rhs.data.len() {\n                rhs.data.len()\n            } else {\n                self.data.len()\n            };\n            for i in 0..n {\n                assert!(self.data[i] <= MAXIMUM);\n                assert!(rhs.data[i] <= MAXIMUM);\n                self.data[i] |= rhs.data[i];\n            }\n        }\n    }\n\n    impl Shl<usize> for BitSet {\n        type Output = Self;\n        fn shl(self, rhs: usize) -> Self {\n            self.shift_left(rhs)\n        }\n    }\n\n    impl BitSet {\n        pub fn new(n: usize) -> Self {\n            let size = (n + ONE_VALUE_LENGTH - 1) / ONE_VALUE_LENGTH;\n            BitSet {\n                data: vec![0; size],\n            }\n        }\n\n        pub fn new_from(value: u64) -> Self {\n            BitSet { data: vec![value] }\n        }\n\n        pub fn set(&mut self, index: usize, value: bool) {\n            let (data_index, bit_index) = get_bit_position(index);\n            assert!(self.data.len() > data_index);\n            if value {\n                self.data[data_index] |= (1 << bit_index) as u64;\n            } else {\n                let tmp = MAXIMUM ^ (1 << bit_index) as u64;\n                self.data[data_index] &= tmp;\n            }\n        }\n\n        pub fn get(&mut self, index: usize) -> bool {\n            let (data_index, bit_index) = get_bit_position(index);\n            self.data.len() > data_index && self.data[data_index] & (1u64 << bit_index as u64) != 0\n        }\n\n        pub fn shift_left(&self, shift: usize) -> Self {\n            let mut next_data = Vec::new();\n            let prefix_empty_count = shift / ONE_VALUE_LENGTH;\n            let shift_count = (shift % ONE_VALUE_LENGTH) as u64;\n            for _ in 0..prefix_empty_count {\n                next_data.push(0);\n            }\n\n            let mut from_previous = 0;\n            let room = ONE_VALUE_LENGTH as u64 - shift_count;\n            for &data in self.data.iter() {\n                let overflow = (data >> room) << room;\n                let rest = data - overflow;\n                let value = (rest << shift_count) + from_previous;\n                assert!(value <= MAXIMUM);\n                next_data.push(value);\n                from_previous = overflow >> room;\n            }\n            if from_previous > 0 {\n                next_data.push(from_previous);\n            }\n            BitSet { data: next_data }\n        }\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]