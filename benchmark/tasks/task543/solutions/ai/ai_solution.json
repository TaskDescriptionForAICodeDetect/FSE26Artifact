[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canSort(int arr[], int n, int r) {\n    // Track the colors of elements\n    int color[n];\n    for (int i = 0; i < n; i++) {\n        color[i] = (i < r) ? 0 : 1;  // 0 for red, 1 for blue\n    }\n\n    // Check if we can sort by swapping within same color\n    for (int i = 0; i < n; i++) {\n        int correct_val = i + 1;\n        \n        // Check if current element is in incorrect position\n        if (arr[i] != correct_val) {\n            // Find replacement in same color\n            bool found = false;\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] == correct_val && color[i] == color[j]) {\n                    // Swap\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                    found = true;\n                    break;\n                }\n            }\n            \n            // If no replacement found, sorting is impossible\n            if (!found) return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int n, r;\n    scanf(\"%d %d\", &n, &r);\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    printf(\"%s\\n\", canSort(arr, n, r) ? \"YES\" : \"NO\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\nbool canSort(int N, int R, int sequence[]) {\n    for (int i = 0; i < N; i++) {\n        if (sequence[i] != i + 1) {\n            if ((sequence[i] <= R && i + 1 <= R) || (sequence[i] > R && i + 1 > R)) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, R;\n    scanf(\"%d %d\", &N, &R);\n    int sequence[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &sequence[i]);\n    }\n    if (canSort(N, R, sequence)) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canSort(int N, int R, vector<int>& sequence) {\n    vector<int> sorted_sequence = sequence;\n    sort(sorted_sequence.begin(), sorted_sequence.end());\n    \n    vector<int> red_positions;\n    for (int i = 0; i < N; ++i) {\n        if (sequence[i] <= R) {\n            red_positions.push_back(i);\n        }\n    }\n    \n    for (int i = 0; i < R; ++i) {\n        if (sorted_sequence[red_positions[i]] != i + 1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, R;\n    cin >> N >> R;\n    vector<int> sequence(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> sequence[i];\n    }\n    \n    if (canSort(N, R, sequence)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TwoColorsSort {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int R = scanner.nextInt();\n        int[] sequence = new int[N];\n        for (int i = 0; i < N; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n        \n        List<Integer> redPositions = new ArrayList<>();\n        List<Integer> redValues = new ArrayList<>();\n        List<Integer> bluePositions = new ArrayList<>();\n        List<Integer> blueValues = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            if (i < R) {\n                redPositions.add(i);\n                redValues.add(sequence[i]);\n            } else {\n                bluePositions.add(i);\n                blueValues.add(sequence[i]);\n            }\n        }\n        \n        Collections.sort(redValues);\n        Collections.sort(blueValues);\n        \n        boolean possible = true;\n        int redIndex = 0;\n        int blueIndex = 0;\n        \n        for (int i = 0; i < N; i++) {\n            int expected = i + 1;\n            if (redIndex < redValues.size() && redValues.get(redIndex) == expected) {\n                redIndex++;\n            } else if (blueIndex < blueValues.size() && blueValues.get(blueIndex) == expected) {\n                blueIndex++;\n            } else {\n                possible = false;\n                break;\n            }\n        }\n        \n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 22:05:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TwoColorSort {\n    public static void solve(int[] arr, int N, int R) {\n        // Check if sorting is possible\n        boolean possible = canSort(arr, N, R);\n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n\n    static boolean canSort(int[] arr, int N, int R) {\n        // Check if each number's color allows it to be in its correct position\n        for (int i = 0; i < N; i++) {\n            int correctPos = arr[i] - 1;\n            \n            // If number is red but can't swap with blue \n            if (i < R && correctPos >= R) {\n                return false;\n            }\n            \n            // If number is blue but can't swap with red\n            if (i >= R && correctPos < R) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int R = Integer.parseInt(st.nextToken());\n        \n        int[] arr = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            arr[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        solve(arr, N, R);\n    }\n}",
    "timestamp": "2025-08-05 22:05:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canSort(vector<int>& arr, int R) {\n    int N = arr.size();\n    vector<int> sorted = arr;\n    sort(sorted.begin(), sorted.end());\n    \n    vector<int> red, blue;\n    for (int i = 0; i < N; i++) {\n        if (i < R) red.push_back(arr[i]);\n        else blue.push_back(arr[i]);\n    }\n    \n    sort(red.begin(), red.end());\n    sort(blue.begin(), blue.end());\n    \n    int r = 0, b = 0;\n    for (int i = 0; i < N; i++) {\n        if (i < R) {\n            if (red[r] != sorted[i]) return false;\n            r++;\n        } else {\n            if (blue[b] != sorted[i]) return false;\n            b++;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, R;\n    cin >> N >> R;\n    \n    vector<int> arr(N);\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    \n    cout << (canSort(arr, R) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_sort(N, R, sequence):\n    # Count misplaced numbers\n    misplaced_red = misplaced_blue = 0\n    \n    # Lists to check availability\n    red_positions = set(range(1, R + 1))\n    blue_positions = set(range(R + 1, N + 1))\n    \n    for i in range(N):\n        correct_position = i + 1\n        number = sequence[i]\n        \n        if number != correct_position:\n            if number in red_positions and correct_position in red_positions:\n                misplaced_red += 1\n            elif number in blue_positions and correct_position in blue_positions:\n                misplaced_blue += 1\n            else:\n                return \"No\"\n    \n    return \"Yes\"\n\n# Example Usage:\nN = 5\nR = 2\nsequence = [3, 5, 1, 4, 2] # Modify this sequence as needed\nprint(can_sort(N, R, sequence))",
    "timestamp": "2025-08-13 08:54:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TwoColorsSort {\n\n    public static boolean canSortWithColors(int[] sequence, List<Integer> redIndices) {\n        int n = sequence.length;\n        boolean[] isRed = new boolean[n];\n        for (int index : redIndices) {\n            isRed[index] = true;\n        }\n        \n        for (int color = 0; color < 2; color++) {\n            List<Integer> coloredNumbers = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if ((color == 0 && isRed[i]) || (color == 1 && !isRed[i])) {\n                    coloredNumbers.add(sequence[i]);\n                }\n            }\n            \n            if (!isSorted(coloredNumbers)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private static boolean isSorted(List<Integer> list) {\n        for (int i = 1; i < list.size(); i++) {\n            if (list.get(i) < list.get(i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] sequence = {2, 1, 3, 5, 4};\n        List<Integer> redIndices = Arrays.asList(1, 3);\n        System.out.println(canSortWithColors(sequence, redIndices) ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-13 08:54:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint main() {\n    int T; // Number of test cases\n    scanf(\"%d\", &T);\n    while (T--) {\n        int N, R;\n        scanf(\"%d %d\", &N, &R);\n        \n        int red[R], blue[N-R];\n        int minRed = N+1, maxBlue = 0; // Min in red and max in blue for checking\n        \n        for (int i = 1; i <= N; ++i) {\n            int input;\n            scanf(\"%d\", &input);\n            if (i <= R) {\n                red[i-1] = input;\n                if (input < minRed) minRed = input;\n            } else {\n                blue[i-R-1] = input;\n                if (input > maxBlue) maxBlue = input;\n            }\n        }\n        \n        // Check if the sorting can be accomplished\n        if (minRed < maxBlue) {\n            printf(\"NO\\n\");\n        } else {\n            printf(\"YES\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 08:54:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_sort(N, R):\n    red_positions = []\n    blue_positions = []\n    \n    # Collect current positions of red and blue numbers\n    for i in range(1, N+1):\n        if i <= R:\n            red_positions.append(i)\n        else:\n            blue_positions.append(i)\n    \n    # Check if red and blue numbers can be sorted within their color groups\n    red_sorted = sorted(red_positions)\n    blue_sorted = sorted(blue_positions)\n    \n    return red_sorted == red_positions and blue_sorted == blue_positions\n\n# Read input\nN, R = map(int, input().split())\n\n# Output result\nprint(\"Yes\" if can_sort(N, R) else \"No\")",
    "timestamp": "2025-08-13 08:55:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    for _ in range(T):\n        N, R = map(int, data[index:index+2])\n        index += 2\n        A = list(map(int, data[index:index+N]))\n        index += N\n        \n        red_positions = []\n        blue_positions = []\n        for i in range(N):\n            if A[i] <= R:\n                red_positions.append(A[i])\n            else:\n                blue_positions.append(A[i])\n        \n        # Check if red and blue parts are already sorted within themselves\n        is_possible = True\n        \n        # Check red part\n        for i in range(len(red_positions)-1):\n            if red_positions[i] > red_positions[i+1]:\n                is_possible = False\n                break\n        \n        if is_possible:\n            # Check blue part\n            for i in range(len(blue_positions)-1):\n                if blue_positions[i] > blue_positions[i+1]:\n                    is_possible = False\n                    break\n        \n        print(\"YES\" if is_possible else \"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 08:55:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nbool canSortTwoColors(int N, int R) {\n    // If R is 0 or R is N, he can't make any swaps.\n    if (R == 0 || R == N) {\n        return false;\n    }\n    // He can shuffle numbers within both color partitions,\n    // so he can sort if both partitions exist.\n    return true;\n}\n\nint main() {\n    int N, R;\n    std::cin >> N >> R;\n    if (canSortTwoColors(N, R)) {\n        std::cout << \"Yes\" << std::endl;\n    } else {\n        std::cout << \"No\" << std::endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:20"
  }
]