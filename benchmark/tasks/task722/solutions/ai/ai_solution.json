[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n#define MAX_M 200005\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_M];\nint head[MAX_N], deg[MAX_N], tot;\nint n, m;\ndouble dp[MAX_N];\n\nvoid add_edge(int u, int v) {\n    edges[tot].to = v;\n    edges[tot].next = head[u];\n    head[u] = tot++;\n    deg[u]++;\n}\n\nvoid dfs(int u) {\n    if (u == n) {\n        dp[u] = 0;\n        return;\n    }\n\n    dp[u] = INT_MAX;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (dp[v] == -1) dfs(v);\n        dp[u] = fmin(dp[u], 1.0 / deg[u] + dp[v]);\n    }\n}\n\ndouble solve() {\n    memset(head, -1, sizeof(head));\n    memset(deg, 0, sizeof(deg));\n    memset(dp, -1, sizeof(dp));\n    tot = 0;\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    double min_expected = INT_MAX;\n    for (int del = 0; del < tot; del++) {\n        // Remove one edge\n        int orig_next = edges[del].next;\n        int orig_from = 0;\n        for (int i = 1; i <= n; i++) {\n            if (head[i] == del) {\n                head[i] = orig_next;\n                orig_from = i;\n                deg[i]--;\n                break;\n            }\n            for (int j = head[i]; j != -1; j = edges[j].next) {\n                if (edges[j].next == del) {\n                    edges[j].next = orig_next;\n                    orig_from = i;\n                    break;\n                }\n            }\n        }\n\n        // Recalculate\n        memset(dp, -1, sizeof(dp));\n        dfs(1);\n        min_expected = fmin(min_expected, dp[1]);\n\n        // Restore edge\n        edges[del].next = orig_next;\n        if (orig_from) {\n            deg[orig_from]++;\n            for (int i = 1; i <= n; i++) {\n                if (head[i] == orig_next) {\n                    head[i] = del;\n                    break;\n                }\n                for (int j = head[i]; j != -1; j = edges[j].next) {\n                    if (edges[j].next == orig_next) {\n                        edges[j].next = del;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    return min_expected;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        printf(\"%.10f\\n\", solve());\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:41:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 600\n#define MAXM MAXN * (MAXN - 1) / 2\n#define INF 1e18\n\ntypedef struct {\n    int s, t;\n} Edge;\n\nEdge edges[MAXM];\nint N, M;\nint out_degree[MAXN];\nint adj[MAXN][MAXN];\ndouble E[MAXN];\ndouble temp_E[MAXN];\n\nvoid compute_expected_value() {\n    for (int i = 1; i <= N; i++) {\n        E[i] = 0.0;\n    }\n\n    for (int i = N - 1; i >= 1; i--) {\n        if (out_degree[i] == 0) {\n            E[i] = INF;\n            continue;\n        }\n        double sum = 0.0;\n        int max_j = -1;\n        double max_val = -1.0;\n        for (int j = 0; j < out_degree[i]; j++) {\n            int t = adj[i][j];\n            sum += E[t];\n            if (E[t] > max_val) {\n                max_val = E[t];\n                max_j = j;\n            }\n        }\n        if (out_degree[i] == 1) {\n            E[i] = 1.0 + sum / out_degree[i];\n        } else {\n            E[i] = 1.0 + (sum - max_val) / (out_degree[i] - 1);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &edges[i].s, &edges[i].t);\n    }\n\n    memset(out_degree, 0, sizeof(out_degree));\n    for (int i = 0; i < M; i++) {\n        int s = edges[i].s;\n        int t = edges[i].t;\n        adj[s][out_degree[s]++] = t;\n    }\n\n    compute_expected_value();\n    double min_E = E[1];\n\n    for (int i = 0; i < M; i++) {\n        int s = edges[i].s;\n        int t = edges[i].t;\n        if (out_degree[s] <= 1) continue;\n\n        int pos = -1;\n        for (int j = 0; j < out_degree[s]; j++) {\n            if (adj[s][j] == t) {\n                pos = j;\n                break;\n            }\n        }\n        if (pos == -1) continue;\n\n        // Remove edge s->t\n        adj[s][pos] = adj[s][out_degree[s] - 1];\n        out_degree[s]--;\n\n        compute_expected_value();\n        if (E[1] < min_E) {\n            min_E = E[1];\n        }\n\n        // Restore edge s->t\n        adj[s][out_degree[s]] = t;\n        out_degree[s]++;\n    }\n\n    printf(\"%.10lf\\n\", min_E);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    vector<vector<int>> rev_adj(N + 1);\n    vector<int> out_degree(N + 1, 0);\n    for (int i = 0; i < M; ++i) {\n        int s, t;\n        cin >> s >> t;\n        adj[s].push_back(t);\n        rev_adj[t].push_back(s);\n        out_degree[s]++;\n    }\n\n    vector<double> E(N + 1, 0.0);\n    vector<double> P(N + 1, 0.0);\n    P[N] = 1.0;\n    queue<int> q;\n    q.push(N);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : rev_adj[u]) {\n            E[v] += (E[u] + 1) / out_degree[v];\n            P[v] += P[u] / out_degree[v];\n            if (--out_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    double res = E[1];\n    vector<double> dp(N + 1, 0.0);\n    for (int u = 1; u < N; ++u) {\n        if (adj[u].size() <= 1) continue;\n        double max_e = 0.0;\n        for (int v : adj[u]) {\n            max_e = max(max_e, E[v] + 1);\n        }\n        double new_e = (E[u] * out_degree[u] - max_e) / (out_degree[u] - 1);\n        dp[u] = new_e;\n    }\n\n    vector<double> new_E(N + 1, 0.0);\n    vector<double> new_P(N + 1, 0.0);\n    new_P[N] = 1.0;\n    vector<int> new_out_degree = out_degree;\n    for (int u = 1; u < N; ++u) {\n        if (adj[u].size() <= 1) continue;\n        double max_e = 0.0;\n        int max_v = -1;\n        for (int v : adj[u]) {\n            if (E[v] + 1 > max_e) {\n                max_e = E[v] + 1;\n                max_v = v;\n            }\n        }\n        new_out_degree[u]--;\n        adj[u].erase(remove(adj[u].begin(), adj[u].end(), max_v), adj[u].end());\n    }\n\n    q.push(N);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : rev_adj[u]) {\n            new_E[v] += (new_E[u] + 1) / new_out_degree[v];\n            new_P[v] += new_P[u] / new_out_degree[v];\n            if (--new_out_degree[v] == 0) {\n                q.push(v);\n            }\n        }\n    }\n\n    if (new_out_degree[1] > 0) {\n        res = min(res, new_E[1]);\n    }\n\n    cout << fixed << setprecision(10) << res << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:42:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Edge {\n        int from, to;\n        Edge(int from, int to) {\n            this.from = from;\n            this.to = to;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int s = sc.nextInt();\n            int t = sc.nextInt();\n            adj.get(s).add(new Edge(s, t));\n        }\n\n        double[] E = new double[N + 1];\n        for (int u = N - 1; u >= 1; u--) {\n            double sum = 0;\n            for (Edge e : adj.get(u)) {\n                sum += E[e.to];\n            }\n            E[u] = sum / adj.get(u).size() + 1;\n        }\n\n        double res = E[1];\n        double[] maxDiff = new double[N + 1];\n        for (int u = N - 1; u >= 1; u--) {\n            if (adj.get(u).size() <= 1) {\n                maxDiff[u] = 0;\n                continue;\n            }\n            double maxE = 0;\n            double sum = 0;\n            for (Edge e : adj.get(u)) {\n                sum += E[e.to];\n                if (E[e.to] > maxE) {\n                    maxE = E[e.to];\n                }\n            }\n            double original = (sum) / adj.get(u).size() + 1;\n            double modified = (sum - maxE) / (adj.get(u).size() - 1) + 1;\n            maxDiff[u] = original - modified;\n        }\n\n        double[] dp = new double[N + 1];\n        for (int u = 1; u <= N; u++) {\n            dp[u] = E[u];\n        }\n\n        for (int u = 1; u < N; u++) {\n            if (adj.get(u).size() <= 1) continue;\n            double maxE = 0;\n            double sum = 0;\n            for (Edge e : adj.get(u)) {\n                sum += E[e.to];\n                if (E[e.to] > maxE) {\n                    maxE = E[e.to];\n                }\n            }\n            double original = (sum) / adj.get(u).size() + 1;\n            double modified = (sum - maxE) / (adj.get(u).size() - 1) + 1;\n            double diff = original - modified;\n\n            for (Edge e : adj.get(u)) {\n                if (E[e.to] == maxE) {\n                    double[] newE = new double[N + 1];\n                    System.arraycopy(E, 0, newE, 0, N + 1);\n                    newE[u] = modified;\n                    for (int v = u - 1; v >= 1; v--) {\n                        sum = 0;\n                        for (Edge edge : adj.get(v)) {\n                            sum += newE[edge.to];\n                        }\n                        newE[v] = sum / adj.get(v).size() + 1;\n                    }\n                    if (newE[1] < res) {\n                        res = newE[1];\n                    }\n                    break;\n                }\n            }\n        }\n\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 22:44:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static final int MAX_N = 100005;\n    static List<Integer>[] graph;\n    static int[] outDegree;\n    static double[] expectedPaths;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        \n        graph = new ArrayList[N+1];\n        outDegree = new int[N+1];\n        expectedPaths = new double[N+1];\n        \n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int s = Integer.parseInt(st.nextToken());\n            int t = Integer.parseInt(st.nextToken());\n            graph[s].add(t);\n            outDegree[s]++;\n        }\n        \n        double minExpected = solve(N);\n        System.out.printf(\"%.10f\\n\", minExpected);\n    }\n    \n    static double solve(int N) {\n        Arrays.fill(expectedPaths, 0);\n        expectedPaths[N] = 0;\n        \n        for (int room = N-1; room >= 1; room--) {\n            if (graph[room].isEmpty()) continue;\n            \n            expectedPaths[room] = Double.MAX_VALUE;\n            double bestRemoval = Double.MAX_VALUE;\n            \n            for (int blockedPath = 0; blockedPath < graph[room].size(); blockedPath++) {\n                double expectedPathsWithBlock = calculateExpectedPaths(room, blockedPath);\n                bestRemoval = Math.min(bestRemoval, expectedPathsWithBlock);\n            }\n            \n            expectedPaths[room] = Math.min(expectedPaths[room], bestRemoval);\n        }\n        \n        return expectedPaths[1];\n    }\n    \n    static double calculateExpectedPaths(int room, int blockedPathIndex) {\n        double expectedTotalPaths = 0;\n        int pathCount = graph[room].size();\n        \n        for (int i = 0; i < pathCount; i++) {\n            if (i == blockedPathIndex) continue;\n            \n            int nextRoom = graph[room].get(i);\n            expectedTotalPaths += 1.0 / (pathCount - 1) * (1 + expectedPaths[nextRoom]);\n        }\n        \n        return expectedTotalPaths;\n    }\n}",
    "timestamp": "2025-08-05 22:44:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint N, M;\nvector<int> graph[MAXN];\nvector<int> rev_graph[MAXN];\ndouble dp[MAXN];\nint in_degree[MAXN];\n\nvoid solve() {\n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int s, t;\n        cin >> s >> t;\n        graph[s].push_back(t);\n        rev_graph[t].push_back(s);\n        in_degree[t]++;\n    }\n    \n    queue<int> q;\n    for (int i = 1; i < N; i++) {\n        if (in_degree[i] == 0) q.push(i);\n    }\n    \n    dp[N] = 0;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        int out_edges = graph[curr].size();\n        dp[curr] = 1.0;\n        \n        for (int next : graph[curr]) {\n            dp[curr] += dp[next] / out_edges;\n        }\n        \n        for (int prev : rev_graph[curr]) {\n            in_degree[prev]--;\n            if (in_degree[prev] == 0) q.push(prev);\n        }\n    }\n    \n    double best = dp[1];\n    \n    for (int i = 0; i < M; i++) {\n        int s = graph[1][i];\n        double curr = 1.0 + dp[s];\n        best = min(best, curr);\n    }\n    \n    printf(\"%.10f\\n\", best);\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_expected_passages(N, M, passages):\n    from collections import defaultdict\n    import heapq\n\n    # Building adjacency list from passages\n    adj_list = defaultdict(list)\n    for s, t in passages:\n        adj_list[s].append(t)\n\n    # Precalculate expectations starting from each room\n    expected_passages = [float('inf')] * (N + 1)\n    expected_passages[N] = 0\n    priority_queue = [(0, N)]\n\n    while priority_queue:\n        expect, room = heapq.heappop(priority_queue)\n        if expected_passages[room] < expect:\n            continue\n        for parent in range(room):\n            if room in adj_list[parent]:\n                new_expect = (expect + 1) / len(adj_list[parent])\n                if new_expect < expected_passages[parent]:\n                    expected_passages[parent] = new_expect\n                    heapq.heappush(priority_queue, (new_expect, parent))\n\n    # Determine the minimum expected passages by potentially blocking\n    min_expect_with_block = float('inf')\n    room_1_t = adj_list[1]\n    original_expect = sum((expected_passages[t] + 1) / len(room_1_t) for t in room_1_t)\n\n    for block in room_1_t:\n        # Simulate blocking each individual passage\n        if len(room_1_t) > 1:\n            new_expect = sum(\n                (expected_passages[t] + 1) / (len(room_1_t) - 1)\n                for t in room_1_t\n                if t != block\n            )\n            min_expect_with_block = min(min_expect_with_block, new_expect)\n\n    return min(min_expect_with_block, original_expect)\n\n\n# Example usage\nN = 4\nM = 4\npassages = [(1, 2), (1, 3), (2, 4), (3, 4)]\nprint(min_expected_passages(N, M, passages))  # Output: Expected value",
    "timestamp": "2025-08-13 12:12:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CaveEscape {\n\n    static class Passage {\n        int start, end;\n        Passage(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static double calculateExpectedPassages(int N, int M, int[][] passagesArray) {\n        List<List<Integer>> passages = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            passages.add(new ArrayList<>());\n        }\n\n        // Build the adjacency list\n        for (int i = 0; i < M; i++) {\n            int s = passagesArray[i][0];\n            int t = passagesArray[i][1];\n            passages.get(s).add(t);\n        }\n\n        // dp[i] means the expected number of steps from room i to room N\n        double[] dp = new double[N + 1];\n        Arrays.fill(dp, Double.MAX_VALUE);\n        dp[N] = 0.0;\n\n        for (int i = N - 1; i >= 1; i--) {\n            double sum = 0.0;\n            for (int nextRoom : passages.get(i)) {\n                sum += dp[nextRoom];\n            }\n            dp[i] = sum / passages.get(i).size() + 1;\n        }\n\n        double optimalE = dp[1];\n        for (int blockedIndex = 0; blockedIndex < passages.get(1).size(); blockedIndex++) {\n            double alternativeE = 0.0;\n            int count = passages.get(1).size() - 1;\n            for (int i = 0; i < passages.get(1).size(); i++) {\n                if (i != blockedIndex) {\n                    alternativeE += dp[passages.get(1).get(i)];\n                }\n            }\n            alternativeE = count == 0 ? Double.MAX_VALUE : alternativeE / count + 1;\n            optimalE = Math.min(optimalE, alternativeE);\n        }\n\n        return optimalE;\n    }\n\n    public static void main(String[] args) {\n        int N = 4;\n        int M = 4;\n        int[][] passagesArray = {{1, 2}, {1, 3}, {2, 4}, {3, 4}};\n        double result = calculateExpectedPassages(N, M, passagesArray);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 12:12:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int target;\n    double original_prob;\n    double adjusted_prob;\n} Passage;\n\ntypedef struct {\n    Passage *passages;\n    int passage_count;\n} Room;\n\nRoom rooms[MAX_N];\nint roomCount, passageCount;\nint s[MAX_M], t[MAX_M];\n\ndouble dfs(int roomIndex, double *dp, double *blocked_dp) {\n    if (roomIndex == roomCount) return dp[roomIndex];\n    if (dp[roomIndex] >= 0) return dp[roomIndex];\n    \n    double expectation = 0;\n    for (int i = 0; i < rooms[roomIndex].passage_count; i++) {\n        Passage *p = &rooms[roomIndex].passages[i];\n        expectation += 1 + p->original_prob * dfs(p->target, dp, blocked_dp);\n    }\n    \n    dp[roomIndex] = expectation;\n    \n    expectation = 0;\n    for (int i = 0; i < rooms[roomIndex].passage_count; i++) {\n        Passage *p = &rooms[roomIndex].passages[i];\n        expectation += 1 + p->adjusted_prob * dfs(p->target, blocked_dp, blocked_dp);\n    }\n    \n    blocked_dp[roomIndex] = expectation;\n    \n    return dp[roomIndex];\n}\n\nint main() {\n    scanf(\"%d %d\", &roomCount, &passageCount);\n\n    for (int i = 0; i < passageCount; i++) {\n        scanf(\"%d %d\", &s[i], &t[i]);\n        s[i]--; t[i]--;\n    }\n    \n    for (int i = 0; i < roomCount; i++) {\n        rooms[i].passage_count = 0;\n        rooms[i].passages = malloc(MAX_M * sizeof(Passage));\n    }\n    \n    for (int i = 0; i < passageCount; i++) {\n        Passage p;\n        p.target = t[i];\n        rooms[s[i]].passages[rooms[s[i]].passage_count++] = p;\n    }\n    \n    double dp[MAX_N], blocked_dp[MAX_N];\n    \n    for (int i = 0; i < roomCount; i++) {\n        dp[i] = -1;\n        blocked_dp[i] = -1;\n        \n        int pc = rooms[i].passage_count;\n        \n        for (int j = 0; j < pc; j++) {\n            rooms[i].passages[j].original_prob = 1.0 / pc;\n            rooms[i].passages[j].adjusted_prob = (pc == 1 ? 1.0 : 1.0 / (pc - 1));\n        }\n    }\n    \n    double best = INT_MAX, original = dfs(0, dp, blocked_dp);\n        \n    for (int i = 0; i < rooms[0].passage_count; i++) {\n        Passage *block_passage = &rooms[0].passages[i];\n        \n        for (int j = 0; j < rooms[0].passage_count; j++) {\n            Passage *p = &rooms[0].passages[j];\n            p->adjusted_prob = (p == block_passage ? 0 : 1.0 / (rooms[0].passage_count - 1));\n        }\n         \n        for (int k = 0; k < roomCount; k++) blocked_dp[k] = -1;\n        double blocked_expectation = dfs(0, dp, blocked_dp);\n\n        if (blocked_expectation < best) best = blocked_expectation;\n    }\n\n    printf(\"%.6f\\n\", best);\n    \n    for (int i = 0; i < roomCount; i++) {\n        free(rooms[i].passages);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:13:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimizeExpectedPassages(N, M, passages) {\n  const graph = Array.from({ length: N + 1 }, () => []);\n  const inDegree = Array(N + 1).fill(0);\n\n  passages.forEach(([s, t]) => {\n    graph[s].push(t);\n    inDegree[t]++;\n  });\n\n  const expectedPassages = Array(N + 1).fill(Infinity);\n  expectedPassages[N] = 0;\n\n  const queue = [];\n  for (let i = 1; i <= N; i++) {\n    if (inDegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    graph[current].forEach(next => {\n      expectedPassages[next] = Math.min(expectedPassages[next], 1 + expectedPassages[current]);\n      inDegree[next]--;\n      if (inDegree[next] === 0) {\n        queue.push(next);\n      }\n    });\n  }\n\n  let minExpectedPassages = Infinity;\n\n  passages.forEach(([s, t], index) => {\n    const newGraph = graph.map(edges => edges.slice());\n    newGraph[s] = newGraph[s].filter(room => room !== t);\n    \n    const newInDegree = Array(N + 1).fill(0);\n    newGraph.forEach((edges, node) => {\n      edges.forEach(edge => {\n        newInDegree[edge]++;\n      });\n    });\n\n    const newExpectedPassages = Array(N + 1).fill(Infinity);\n    newExpectedPassages[N] = 0;\n\n    const newQueue = [];\n    for (let i = 1; i <= N; i++) {\n      if (newInDegree[i] === 0) {\n        newQueue.push(i);\n      }\n    }\n\n    while (newQueue.length > 0) {\n      const current = newQueue.shift();\n      newGraph[current].forEach(next => {\n        newExpectedPassages[next] = Math.min(newExpectedPassages[next], 1 + newExpectedPassages[current]);\n        newInDegree[next]--;\n        if (newInDegree[next] === 0) {\n          newQueue.push(next);\n        }\n      });\n    }\n\n    minExpectedPassages = Math.min(minExpectedPassages, newExpectedPassages[1]);\n  });\n\n  return minExpectedPassages;\n}\n\n// Test case\n// const N = 4;\n// const M = 4;\n// const passages = [\n//   [1, 2],\n//   [1, 3],\n//   [2, 4],\n//   [3, 4]\n// ];\n// console.log(minimizeExpectedPassages(N, M, passages)); // Expected output value depending on the case specifics",
    "timestamp": "2025-08-13 12:13:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, M, passages):\n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    out_degree = [0] * (N + 1)\n    \n    for s, t in passages:\n        graph[s].append(t)\n        in_degree[t] += 1\n        out_degree[s] += 1\n    \n    # Compute expected path length without blocking\n    def compute_expected_length():\n        dist = [float('inf')] * (N + 1)\n        prob = [0] * (N + 1)\n        dist[1] = 0\n        prob[1] = 1\n        \n        q = deque([1])\n        while q:\n            curr = q.popleft()\n            if curr == N:\n                continue\n            \n            for next_room in graph[curr]:\n                if out_degree[curr] > 0:\n                    dist[next_room] = min(dist[next_room], dist[curr] + 1)\n                    prob[next_room] = max(prob[next_room], prob[curr] / out_degree[curr])\n                    q.append(next_room)\n        \n        return dist[N]\n    \n    # Try blocking each passage and find minimum expected length\n    min_expected = float('inf')\n    for block_s, block_t in [(0, 0)] + passages:\n        if block_s:\n            graph[block_s].remove(block_t)\n            out_degree[block_s] -= 1\n            in_degree[block_t] -= 1\n        \n        expected = compute_expected_length()\n        min_expected = min(min_expected, expected)\n        \n        if block_s:\n            graph[block_s].append(block_t)\n            out_degree[block_s] += 1\n            in_degree[block_t] += 1\n    \n    return min_expected\n\n# Read input\nN, M = map(int, input().split())\npassages = []\nfor _ in range(M):\n    s, t = map(int, input().split())\n    passages.append((s, t))\n\n# Output result\nprint(solve(N, M, passages))",
    "timestamp": "2025-08-13 12:13:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, passages) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    const inDegree = new Array(N + 1).fill(0);\n    const outDegree = new Array(N + 1).fill(0);\n\n    for (const [s, t] of passages) {\n        graph[s].push(t);\n        outDegree[s]++;\n        inDegree[t]++;\n    }\n\n    const dp = new Array(N + 1).fill(Infinity);\n    dp[N] = 0;\n\n    for (let i = N - 1; i >= 1; i--) {\n        if (graph[i].length === 0) continue;\n        dp[i] = graph[i].reduce((sum, next) => sum + dp[next], 0) / graph[i].length + 1;\n    }\n\n    let minExpected = Infinity;\n    for (const [s, t] of passages) {\n        const tempGraph = graph.map(arr => [...arr]);\n        const index = tempGraph[s].indexOf(t);\n        tempGraph[s].splice(index, 1);\n\n        const tempDp = new Array(N + 1).fill(Infinity);\n        tempDp[N] = 0;\n\n        for (let i = N - 1; i >= 1; i--) {\n            if (tempGraph[i].length === 0) continue;\n            tempDp[i] = tempGraph[i].reduce((sum, next) => sum + tempDp[next], 0) / tempGraph[i].length + 1;\n        }\n\n        minExpected = Math.min(minExpected, tempDp[1]);\n    }\n\n    return minExpected;\n}",
    "timestamp": "2025-08-13 12:13:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    adj = [[] for _ in range(N+1)]\n    rev_adj = [[] for _ in range(N+1)]\n    edges = []\n    for _ in range(M):\n        s, t = map(int, input[ptr:ptr+2])\n        ptr +=2\n        adj[s].append(t)\n        rev_adj[t].append(s)\n        edges.append((s, t))\n    \n    # Compute E without blocking any edge\n    E = [0.0] * (N + 1)\n    for u in range(N-1, 0, -1):\n        total = 0.0\n        cnt = 0\n        for v in adj[u]:\n            total += E[v]\n            cnt += 1\n        if cnt > 0:\n            E[u] = total / cnt + 1\n    \n    if N == 1:\n        print(0.0)\n        return\n    \n    # Compute the critical edge to block\n    max_reduction = 0.0\n    best_edge = -1\n    \n    # Precompute the probabilities P[u]: probability to pass through u\n    P = [0.0] * (N + 1)\n    P[1] = 1.0\n    for u in range(1, N):\n        cnt = len(adj[u])\n        for v in adj[u]:\n            P[v] += P[u] / cnt\n    \n    for s, t in edges:\n        if len(adj[s]) == 1:\n            continue\n        current_contribution = P[s] * (E[s] - ( (E[s] - 1) * len(adj[s]) - E[t] ) / (len(adj[s]) - 1 ) )\n        if current_contribution > max_reduction:\n            max_reduction = current_contribution\n            best_edge = (s, t)\n    \n    if best_edge == -1:\n        print(E[1])\n        return\n    \n    s_block, t_block = best_edge\n    \n    # Recompute E with the blocked edge\n    E_blocked = [0.0] * (N + 1)\n    for u in range(N-1, 0, -1):\n        total = 0.0\n        cnt = 0\n        for v in adj[u]:\n            if u == s_block and v == t_block:\n                continue\n            total += E_blocked[v]\n            cnt += 1\n        if cnt > 0:\n            E_blocked[u] = total / cnt + 1\n        else:\n            E_blocked[u] = float('inf')\n    \n    print(min(E[1], E_blocked[1]))\n\nsolve()",
    "timestamp": "2025-08-13 12:13:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n\nfunction solve() {\n    let idx = 0;\n    const [N, M] = input[idx++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    const revAdj = Array.from({ length: N + 1 }, () => []);\n    const edges = [];\n    \n    for (let i = 0; i < M; i++) {\n        const [s, t] = input[idx++].split(' ').map(Number);\n        adj[s].push(t);\n        revAdj[t].push(s);\n        edges.push({ s, t });\n    }\n\n    // Compute E without blocking any edge\n    const E = new Array(N + 1).fill(0);\n    const P = new Array(N + 1).fill(0);\n    P[N] = 1;\n    \n    for (let u = N - 1; u >= 1; u--) {\n        let sumE = 0;\n        let sumP = 0;\n        for (const v of adj[u]) {\n            sumE += E[v];\n            sumP += P[v];\n        }\n        const k = adj[u].length;\n        E[u] = 1 + sumE / k;\n        P[u] = sumP / k;\n    }\n\n    if (adj[1].length === 1) {\n        console.log(E[1].toFixed(6));\n        return;\n    }\n\n    // Find the best edge to block\n    let maxDiff = 0;\n    let criticalEdge = null;\n    \n    const dpE = new Array(N + 1).fill(0);\n    const dpP = new Array(N + 1).fill(0);\n    dpE[N] = 0;\n    dpP[N] = 1;\n    \n    for (let u = N - 1; u >= 1; u--) {\n        const k = adj[u].length;\n        let sumE = 0;\n        let sumP = 0;\n        let maxE = -Infinity;\n        let maxIdx = -1;\n        \n        for (let i = 0; i < adj[u].length; i++) {\n            const v = adj[u][i];\n            sumE += dpE[v];\n            sumP += dpP[v];\n            if (dpE[v] > maxE) {\n                maxE = dpE[v];\n                maxIdx = i;\n            }\n        }\n        \n        if (k > 1) {\n            const newSumE = sumE - maxE;\n            const newSumP = sumP - dpP[adj[u][maxIdx]];\n            const newK = k - 1;\n            const candidateDiff = (sumE / k) - (newSumE / newK);\n            if (u === 1 || (newSumP > 0 && candidateDiff > maxDiff)) {\n                maxDiff = candidateDiff;\n                criticalEdge = { s: u, t: adj[u][maxIdx] };\n            }\n        }\n        \n        dpE[u] = 1 + sumE / k;\n        dpP[u] = sumP / k;\n    }\n\n    if (criticalEdge === null) {\n        console.log(E[1].toFixed(6));\n        return;\n    }\n\n    // Recompute E with the critical edge blocked\n    const newAdj = Array.from({ length: N + 1 }, () => []);\n    for (const edge of edges) {\n        if (edge.s === criticalEdge.s && edge.t === criticalEdge.t) continue;\n        newAdj[edge.s].push(edge.t);\n    }\n\n    const newE = new Array(N + 1).fill(0);\n    newE[N] = 0;\n    \n    for (let u = N - 1; u >= 1; u--) {\n        const k = newAdj[u].length;\n        if (k === 0) {\n            newE[u] = 0;\n            continue;\n        }\n        let sum = 0;\n        for (const v of newAdj[u]) {\n            sum += newE[v];\n        }\n        newE[u] = 1 + sum / k;\n    }\n\n    console.log(Math.min(E[1], newE[1]).toFixed(6));\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:14:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\ndouble computeExpectedPassages(int N, vector<pair<int, int>>& edges, set<pair<int, int>>& blocked) {\n    vector<vector<int>> adj(N + 1);\n    map<pair<int, int>, int> counters;\n\n    for (auto &edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        adj[u].push_back(v);\n        counters[{u, v}]++;\n    }\n\n    vector<double> expected(N + 1, numeric_limits<double>::max());\n    expected[N] = 0;\n\n    for (int i = N - 1; i >= 1; --i) {\n        double sum = 0;\n        int num_edges = 0;\n        for (int j : adj[i]) {\n            if (!blocked.count({i, j})) {\n                sum += expected[j];\n                num_edges++;\n            }\n        }\n        if (num_edges > 0)\n            expected[i] = 1 + sum / num_edges;\n    }\n\n    return expected[1];\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> edges(M);\n    set<pair<int, int>> fullSet;\n    \n    for (int i = 0; i < M; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n        fullSet.insert(edges[i]);\n    }\n\n    double minExpectedPassages = computeExpectedPassages(N, edges, {});\n\n    for (auto& edge : edges) {\n        set<pair<int, int>> blocked({edge});\n        double exp = computeExpectedPassages(N, edges, blocked);\n        if (exp < minExpectedPassages) {\n            minExpectedPassages = exp;\n        }\n    }\n\n    cout << minExpectedPassages << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:33:41"
  }
]