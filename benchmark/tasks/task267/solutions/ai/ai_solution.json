[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int start;\n    int end;\n} Interval;\n\ntypedef struct {\n    char name[100];\n    Interval intervals[1000];\n    int count;\n    int total;\n} Programmer;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint overlap(Interval a, Interval b) {\n    if (a.start > b.end || b.start > a.end) {\n        return 0;\n    }\n    return min(a.end, b.end) - max(a.start, b.start);\n}\n\nint main() {\n    int g_count;\n    scanf(\"%d\", &g_count);\n    Interval goddess[1000];\n    for (int i = 0; i < g_count; i++) {\n        scanf(\"%d %d\", &goddess[i].start, &goddess[i].end);\n    }\n\n    int p_count;\n    scanf(\"%d\", &p_count);\n    Programmer programmers[1000];\n    for (int i = 0; i < p_count; i++) {\n        scanf(\"%s %d\", programmers[i].name, &programmers[i].count);\n        programmers[i].total = 0;\n        for (int j = 0; j < programmers[i].count; j++) {\n            scanf(\"%d %d\", &programmers[i].intervals[j].start, &programmers[i].intervals[j].end);\n        }\n    }\n\n    for (int i = 0; i < p_count; i++) {\n        for (int j = 0; j < programmers[i].count; j++) {\n            for (int k = 0; k < g_count; k++) {\n                programmers[i].total += overlap(programmers[i].intervals[j], goddess[k]);\n            }\n        }\n    }\n\n    int max_time = 0;\n    for (int i = 0; i < p_count; i++) {\n        if (programmers[i].total > max_time) {\n            max_time = programmers[i].total;\n        }\n    }\n\n    printf(\"%d\\n\", max_time);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Event {\n    int time;\n    bool is_start;\n    bool is_goddess;\n    int id;\n};\n\nbool compareEvents(const Event &a, const Event &b) {\n    if (a.time != b.time) {\n        return a.time < b.time;\n    }\n    return a.is_start > b.is_start;\n}\n\nint main() {\n    int G, P;\n    cin >> G >> P;\n\n    vector<Event> events;\n    for (int i = 0; i < G; ++i) {\n        int start, end;\n        cin >> start >> end;\n        events.push_back({start, true, true, -1});\n        events.push_back({end, false, true, -1});\n    }\n\n    for (int i = 0; i < P; ++i) {\n        int start, end;\n        cin >> start >> end;\n        events.push_back({start, true, false, i});\n        events.push_back({end, false, false, i});\n    }\n\n    sort(events.begin(), events.end(), compareEvents);\n\n    map<int, int> programmer_time;\n    bool goddess_present = false;\n    int current_start = 0;\n    vector<int> active_programmers;\n\n    for (const auto &event : events) {\n        if (event.is_goddess) {\n            if (event.is_start) {\n                goddess_present = true;\n                current_start = event.time;\n                for (int id : active_programmers) {\n                    programmer_time[id] += event.time - current_start;\n                }\n            } else {\n                if (goddess_present) {\n                    for (int id : active_programmers) {\n                        programmer_time[id] += event.time - current_start;\n                    }\n                }\n                goddess_present = false;\n            }\n        } else {\n            if (event.is_start) {\n                if (goddess_present) {\n                    programmer_time[event.id] += event.time - current_start;\n                }\n                active_programmers.push_back(event.id);\n            } else {\n                auto it = find(active_programmers.begin(), active_programmers.end(), event.id);\n                if (it != active_programmers.end()) {\n                    if (goddess_present) {\n                        programmer_time[event.id] += event.time - current_start;\n                    }\n                    active_programmers.erase(it);\n                }\n            }\n        }\n        if (goddess_present && !event.is_start) {\n            current_start = event.time;\n        }\n    }\n\n    int max_time = 0;\n    for (const auto &entry : programmer_time) {\n        if (entry.second > max_time) {\n            max_time = entry.second;\n        }\n    }\n\n    cout << max_time << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Event implements Comparable<Event> {\n    int time;\n    boolean isStart;\n    boolean isGoddess;\n\n    Event(int time, boolean isStart, boolean isGoddess) {\n        this.time = time;\n        this.isStart = isStart;\n        this.isGoddess = isGoddess;\n    }\n\n    @Override\n    public int compareTo(Event other) {\n        if (this.time != other.time) {\n            return this.time - other.time;\n        }\n        if (this.isStart != other.isStart) {\n            return this.isStart ? -1 : 1;\n        }\n        return 0;\n    }\n}\n\npublic class BlessedTime {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Event> events = new ArrayList<>();\n        Map<String, List<int[]>> programmers = new HashMap<>();\n\n        int N = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int i = 0; i < N; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            String name = parts[0];\n            int start = Integer.parseInt(parts[1]);\n            int end = Integer.parseInt(parts[2]);\n            if (!programmers.containsKey(name)) {\n                programmers.put(name, new ArrayList<>());\n            }\n            programmers.get(name).add(new int[]{start, end});\n        }\n\n        int M = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int i = 0; i < M; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            int start = Integer.parseInt(parts[0]);\n            int end = Integer.parseInt(parts[1]);\n            events.add(new Event(start, true, true));\n            events.add(new Event(end, false, true));\n        }\n\n        Collections.sort(events);\n\n        int activeGoddess = 0;\n        int currentStart = -1;\n        List<int[]> goddessIntervals = new ArrayList<>();\n\n        for (Event event : events) {\n            if (event.isGoddess) {\n                if (event.isStart) {\n                    if (activeGoddess == 0) {\n                        currentStart = event.time;\n                    }\n                    activeGoddess++;\n                } else {\n                    activeGoddess--;\n                    if (activeGoddess == 0) {\n                        goddessIntervals.add(new int[]{currentStart, event.time});\n                    }\n                }\n            }\n        }\n\n        Map<String, Integer> blessedTime = new HashMap<>();\n\n        for (Map.Entry<String, List<int[]>> entry : programmers.entrySet()) {\n            String name = entry.getKey();\n            List<int[]> intervals = entry.getValue();\n            int total = 0;\n\n            for (int[] interval : intervals) {\n                int start = interval[0];\n                int end = interval[1];\n\n                for (int[] goddessInterval : goddessIntervals) {\n                    int goddessStart = goddessInterval[0];\n                    int goddessEnd = goddessInterval[1];\n\n                    int overlapStart = Math.max(start, goddessStart);\n                    int overlapEnd = Math.min(end, goddessEnd);\n\n                    if (overlapStart < overlapEnd) {\n                        total += overlapEnd - overlapStart;\n                    }\n                }\n            }\n            blessedTime.put(name, total);\n        }\n\n        int maxTime = 0;\n        for (int time : blessedTime.values()) {\n            if (time > maxTime) {\n                maxTime = time;\n            }\n        }\n\n        System.out.println(maxTime);\n    }\n}",
    "timestamp": "2025-08-05 20:51:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GoddessBlessedTime {\n    public static int maxBlessedTime(List<int[]> entries) {\n        TreeMap<Integer, Integer> timeline = new TreeMap<>();\n        \n        for (int[] entry : entries) {\n            timeline.put(entry[0], timeline.getOrDefault(entry[0], 0) + 1);\n            timeline.put(entry[1], timeline.getOrDefault(entry[1], 0) - 1);\n        }\n        \n        int currentPresent = 0;\n        int lastTime = 0;\n        int maxBlessed = 0;\n        \n        for (Map.Entry<Integer, Integer> event : timeline.entrySet()) {\n            if (currentPresent > 0) {\n                maxBlessed += event.getKey() - lastTime;\n            }\n            \n            currentPresent += event.getValue();\n            lastTime = event.getKey();\n        }\n        \n        return maxBlessed;\n    }\n    \n    public static void main(String[] args) {\n        List<int[]> entries = new ArrayList<>();\n        entries.add(new int[]{1, 5});\n        entries.add(new int[]{2, 7});\n        entries.add(new int[]{3, 6});\n        \n        System.out.println(maxBlessedTime(entries));\n    }\n}",
    "timestamp": "2025-08-05 20:51:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ENTRIES 1000\n#define MAX_NAME_LENGTH 50\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int arrival_time;\n    int departure_time;\n} LogEntry;\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int total_blessed_time;\n} ProgrammerTime;\n\nint main() {\n    int goddess_arrival, goddess_departure;\n    scanf(\"%d %d\", &goddess_arrival, &goddess_departure);\n\n    int n;\n    scanf(\"%d\", &n);\n\n    LogEntry entries[MAX_ENTRIES];\n    ProgrammerTime times[MAX_ENTRIES] = {0};\n    int unique_programmers = 0;\n\n    for (int i = 0; i < n; i++) {\n        char name[MAX_NAME_LENGTH];\n        int arrival, departure;\n        scanf(\"%s %d %d\", name, &arrival, &departure);\n\n        int blessed_start = (arrival > goddess_arrival) ? arrival : goddess_arrival;\n        int blessed_end = (departure < goddess_departure) ? departure : goddess_departure;\n\n        if (blessed_end > blessed_start) {\n            int blessed_time = blessed_end - blessed_start;\n\n            int found = 0;\n            for (int j = 0; j < unique_programmers; j++) {\n                if (strcmp(times[j].name, name) == 0) {\n                    times[j].total_blessed_time += blessed_time;\n                    found = 1;\n                    break;\n                }\n            }\n\n            if (!found) {\n                strcpy(times[unique_programmers].name, name);\n                times[unique_programmers].total_blessed_time = blessed_time;\n                unique_programmers++;\n            }\n        }\n    }\n\n    int max_blessed_time = 0;\n    for (int i = 0; i < unique_programmers; i++) {\n        if (times[i].total_blessed_time > max_blessed_time) {\n            max_blessed_time = times[i].total_blessed_time;\n        }\n    }\n\n    printf(\"%d\\n\", max_blessed_time);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nint calculateMaxBlessedTime(vector<vector<int>>& godessTimes, vector<vector<int>>& programmerTimes) {\n    int maxTime = 0;\n    unordered_map<int, int> blessedTimes;\n\n    // Sort goddess arrival and departure times\n    sort(godessTimes.begin(), godessTimes.end());\n\n    for (auto& programmerEntry : programmerTimes) {\n        int programmerId = programmerEntry[0];\n        int arrival = programmerEntry[1];\n        int departure = programmerEntry[2];\n\n        for (auto& goddessTime : godessTimes) {\n            int goddessArrival = goddessTime[0];\n            int goddessDeparture = goddessTime[1];\n\n            // Calculate overlap time\n            int overlapStart = max(arrival, goddessArrival);\n            int overlapEnd = min(departure, goddessDeparture);\n\n            if (overlapStart < overlapEnd) {\n                blessedTimes[programmerId] += overlapEnd - overlapStart;\n                maxTime = max(maxTime, blessedTimes[programmerId]);\n            }\n        }\n    }\n\n    return maxTime;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> godessTimes(N, vector<int>(2));\n    for (int i = 0; i < N; ++i) {\n        cin >> godessTimes[i][0] >> godessTimes[i][1];\n    }\n\n    vector<vector<int>> programmerTimes(M, vector<int>(3));\n    for (int i = 0; i < M; ++i) {\n        cin >> programmerTimes[i][0] >> programmerTimes[i][1] >> programmerTimes[i][2];\n    }\n\n    int result = calculateMaxBlessedTime(godessTimes, programmerTimes);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nfrom datetime import datetime\n\ndef parse_log_entry(entry):\n    parts = entry.split()\n    event = parts[0]\n    timestamp = \" \".join(parts[1:])\n    return event, datetime.strptime(timestamp, '%Y-%m-%d %H:%M')\n\ndef calculate_blessed_times(logbook):\n    goddess_times = []\n    programmer_times = defaultdict(list)\n    \n    for entry in logbook:\n        event, timestamp = parse_log_entry(entry)\n        \n        if event == \"GoddessArrival\":\n            goddess_times.append((timestamp, None))\n        elif event == \"GoddessDeparture\":\n            if goddess_times and goddess_times[-1][1] is None:\n                goddess_times[-1] = (goddess_times[-1][0], timestamp)\n        elif event.startswith(\"Programmer\"):\n            name, event_type = event.split(':')[1], event.split(':')[0]\n            if event_type == \"ProgrammerArrival\":\n                programmer_times[name].append((timestamp, None))\n            elif event_type == \"ProgrammerDeparture\" and name in programmer_times:\n                if programmer_times[name] and programmer_times[name][-1][1] is None:\n                    programmer_times[name][-1] = (programmer_times[name][-1][0], timestamp)\n    \n    blessed_times = defaultdict(int)\n    \n    for name, times in programmer_times.items():\n        for programmer_start, programmer_end in times:\n            if programmer_end:\n                for goddess_start, goddess_end in goddess_times:\n                    if goddess_start and goddess_end:\n                        overlap_start = max(programmer_start, goddess_start)\n                        overlap_end = min(programmer_end, goddess_end)\n                        if overlap_start < overlap_end:\n                            blessed_times[name] += int((overlap_end - overlap_start).total_seconds() / 60)\n    \n    max_blessed_time_programmer = max(blessed_times, key=blessed_times.get, default=None)\n    return blessed_times[max_blessed_time_programmer] if max_blessed_time_programmer else 0\n\n# Example of usage:\nlogbook_entries = [\n    \"GoddessArrival 2023-10-01 09:00\",\n    \"Programmer:Alice Arrival 2023-10-01 09:10\",\n    \"Programmer:Bob Arrival 2023-10-01 09:15\",\n    \"GoddessDeparture 2023-10-01 09:30\",\n    \"Programmer:Alice Departure 2023-10-01 09:20\",\n    \"Programmer:Bob Departure 2023-10-01 09:35\"\n]\n\nresult = calculate_blessed_times(logbook_entries)\nprint(result)",
    "timestamp": "2025-08-13 03:44:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\n\nclass LogEntry {\n    LocalDateTime time;\n    boolean isArrival;\n    boolean isGoddess;\n    String name;\n\n    LogEntry(LocalDateTime time, boolean isArrival, boolean isGoddess, String name) {\n        this.time = time;\n        this.isArrival = isArrival;\n        this.isGoddess = isGoddess;\n        this.name = name;\n    }\n}\n\npublic class GoddessAltar {\n\n    public static void main(String[] args) {\n        // Sample log entries for testing:\n        List<String> logs = Arrays.asList(\n            \"2023-10-08T09:00:Goddess:Arrives\",\n            \"2023-10-08T09:10:John:Arrives\",\n            \"2023-10-08T09:15:Amy:Arrives\",\n            \"2023-10-08T09:30:Goddess:Departs\",\n            \"2023-10-08T09:45:John:Departs\",\n            \"2023-10-08T10:00:Amy:Departs\"\n        );\n\n        System.out.println(calculateBlessedTime(logs));\n    }\n\n    public static int calculateBlessedTime(List<String> logs) {\n        List<LogEntry> logEntries = parseLogs(logs);\n        Collections.sort(logEntries, Comparator.comparing(entry -> entry.time));\n\n        Map<String, Integer> blessedTime = new HashMap<>();\n        Set<String> programmersOnSite = new HashSet<>();\n        boolean goddessPresent = false;\n        LocalDateTime previousTime = null;\n\n        for (LogEntry entry : logEntries) {\n            if (previousTime != null && goddessPresent) {\n                int minutes = (int) (entry.time.until(previousTime, java.time.temporal.ChronoUnit.MINUTES));\n                for (String programmer : programmersOnSite) {\n                    blessedTime.put(programmer, blessedTime.getOrDefault(programmer, 0) + minutes);\n                }\n            }\n\n            if (entry.isGoddess) {\n                goddessPresent = entry.isArrival;\n            } else if (entry.isArrival) {\n                programmersOnSite.add(entry.name);\n            } else {\n                programmersOnSite.remove(entry.name);\n            }\n\n            previousTime = entry.time;\n        }\n\n        return blessedTime.values().stream().max(Integer::compareTo).orElse(0);\n    }\n\n    private static List<LogEntry> parseLogs(List<String> logs) {\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\");\n        List<LogEntry> logEntries = new ArrayList<>();\n\n        for (String log : logs) {\n            String[] parts = log.split(\":\");\n            LocalDateTime timestamp = LocalDateTime.parse(parts[0] + ':' + parts[1], formatter);\n            String name = parts[2];\n            boolean isArrival = parts[3].equals(\"Arrives\");\n            boolean isGoddess = name.equals(\"Goddess\");\n\n            logEntries.add(new LogEntry(timestamp, isArrival, isGoddess, name));\n        }\n        \n        return logEntries;\n    }\n}",
    "timestamp": "2025-08-13 03:44:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_ENTRIES 1000\n#define MINUTES_PER_DAY 1440\n\ntypedef struct {\n    int time;\n    char type; // 'G' for goddess, 'A' for arrival of a programmer, 'D' for departure of a programmer\n    int programmerId;\n} LogEntry;\n\nint compareLogEntries(const void *a, const void *b) {\n    return ((LogEntry *)a)->time - ((LogEntry *)b)->time;\n}\n\nint main() {\n    int n, i, goddessStartTime = -1, currentGoddessTime = 0, maxBlessedTime = 0, currentProgrammer = -1;\n    int currentProgrammers[MAX_ENTRIES] = {0};\n    int programmerBlessedTime[MAX_ENTRIES] = {0};\n    LogEntry log[MAX_ENTRIES];\n\n    // Read number of log entries\n    scanf(\"%d\", &n);\n\n    // Read log entries\n    for (i = 0; i < n; i++) {\n        char eventType;\n        int hour, minute, programmerId = -1;\n        scanf(\" %c %d:%d\", &eventType, &hour, &minute);\n        if (eventType == 'A' || eventType == 'D') {\n            scanf(\"%d\", &programmerId);\n        }\n        log[i].time = hour * 60 + minute;\n        log[i].type = eventType;\n        log[i].programmerId = programmerId;\n    }\n\n    // Sort log entries by time\n    qsort(log, n, sizeof(LogEntry), compareLogEntries);\n\n    // Process log entries\n    for (i = 0; i < n; i++) {\n        if (log[i].type == 'G') {\n            if (goddessStartTime == -1) {\n                goddessStartTime = log[i].time;\n            } else {\n                currentGoddessTime += log[i].time - goddessStartTime;\n                goddessStartTime = -1;\n            }\n        } else {\n            if (goddessStartTime != -1) {\n                // Calculate blessed time for current programmers\n                for (int j = 0; j < n; j++) {\n                    if (currentProgrammers[j] > 0) {\n                        programmerBlessedTime[j] += log[i].time - goddessStartTime;\n                    }\n                }\n            }\n\n            if (log[i].type == 'A') {\n                currentProgrammers[log[i].programmerId]++;\n            } else if (log[i].type == 'D') {\n                currentProgrammers[log[i].programmerId]--;\n            }\n\n            if (goddessStartTime != -1) {\n                goddessStartTime = log[i].time;\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (programmerBlessedTime[j] > maxBlessedTime) {\n                maxBlessedTime = programmerBlessedTime[j];\n                currentProgrammer = j;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", maxBlessedTime);\n    return 0;\n}",
    "timestamp": "2025-08-13 03:44:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_blessed_time(logbook):\n    goddess_presence = []\n    programmer_times = {}\n\n    for entry in logbook:\n        name, timestamp, action = entry.split()\n        time = int(timestamp)\n        \n        if name == 'Goddess':\n            if action == 'Arrives':\n                goddess_presence.append(time)\n            else:\n                goddess_presence.pop(0)\n        else:\n            if action == 'Arrives':\n                if name not in programmer_times:\n                    programmer_times[name] = 0\n                programmer_times[name] -= time\n            else:\n                if goddess_presence:\n                    programmer_times[name] += time\n\n    return max(programmer_times.values()) if programmer_times else 0",
    "timestamp": "2025-08-13 03:44:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_time(time_str):\n    hh, mm = map(int, time_str.split(':'))\n    return hh * 60 + mm\n\ndef solve():\n    import sys\n    input = sys.stdin.read().splitlines()\n    \n    goddess_times = []\n    programmers = {}\n    \n    i = 0\n    while i < len(input):\n        line = input[i].strip()\n        if not line:\n            i += 1\n            continue\n        if line == 'G':\n            i += 1\n            arrive = parse_time(input[i].strip())\n            i += 1\n            depart = parse_time(input[i].strip())\n            goddess_times.append((arrive, depart))\n            i += 1\n        else:\n            name = line\n            i += 1\n            arrive = parse_time(input[i].strip())\n            i += 1\n            depart = parse_time(input[i].strip())\n            if name not in programmers:\n                programmers[name] = []\n            programmers[name].append((arrive, depart))\n            i += 1\n    \n    max_blessed = 0\n    for name in programmers:\n        total = 0\n        for prog_arrive, prog_depart in programmers[name]:\n            for god_arrive, god_depart in goddess_times:\n                start = max(prog_arrive, god_arrive)\n                end = min(prog_depart, god_depart)\n                if start < end:\n                    total += end - start\n        if total > max_blessed:\n            max_blessed = total\n    \n    print(max_blessed)\n\nsolve()",
    "timestamp": "2025-08-13 03:44:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Timestamp {\n    int hours;\n    int minutes;\n    bool isArrival; // true for arrival, false for departure\n    bool isGoddess; // true for goddess, false for programmer\n    \n    Timestamp(int h, int m, bool a, bool g) : hours(h), minutes(m), isArrival(a), isGoddess(g) {}\n    \n    // Comparison function for sorting timestamps\n    bool operator<(const Timestamp &other) const {\n        if (hours != other.hours)\n            return hours < other.hours;\n        if (minutes != other.minutes)\n            return minutes < other.minutes;\n        if (isGoddess != other.isGoddess)\n            return isGoddess; // goddess timestamps prioritize over programmers\n        return isArrival < other.isArrival;\n    }\n};\n\n// Function to convert string time \"HH:MM\" to minutes since start of day\nint timeToMinutes(const string &time) {\n    int h = (time[0] - '0') * 10 + (time[1] - '0');\n    int m = (time[3] - '0') * 10 + (time[4] - '0');\n    return h * 60 + m;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Timestamp> events;\n    \n    // Input parsing\n    for (int i = 0; i < n; ++i) {\n        string time;\n        string type;\n        cin >> time >> type;\n        bool isArrival = type == \"arrives\";\n        int hours = (time[0] - '0') * 10 + (time[1] - '0');\n        int minutes = (time[3] - '0') * 10 + (time[4] - '0');\n        \n        if (type == \"Goddess_arrives\" || type == \"Goddess_departs\") {\n            events.emplace_back(hours, minutes, isArrival, true);\n        } else {\n            events.emplace_back(hours, minutes, isArrival, false);\n        }\n    }\n    \n    // Sort all events\n    sort(events.begin(), events.end());\n    \n    map<string, int> programmersTime;\n    int blessedStart = -1;\n    int currentGoddessCount = 0;\n    map<string, int> currentProgrammers;\n\n    // Processing events\n    for (const auto &event : events) {\n        if (event.isGoddess) {\n            // Goddess event\n            if (event.isArrival) {\n                if (currentGoddessCount == 0) {\n                    blessedStart = event.hours * 60 + event.minutes;\n                }\n                currentGoddessCount++;\n            } else {\n                currentGoddessCount--;\n                if (currentGoddessCount == 0 && blessedStart != -1) {\n                    int blessedEnd = event.hours * 60 + event.minutes;\n                    int blessedDuration = blessedEnd - blessedStart;\n                    for (auto &prog : currentProgrammers) {\n                        programmersTime[prog.first] += blessedDuration;\n                    }\n                }\n            }\n        } else {\n            // Programmer event\n            string programmer = \"Programmer\" + to_string(event.hours) + \":\" + to_string(event.minutes);\n            if (event.isArrival) {\n                currentProgrammers[programmer] = timeToMinutes(to_string(event.hours) + \":\" + to_string(event.minutes));\n            } else {\n                currentProgrammers.erase(programmer);\n            }\n        }\n    }\n    \n    // Find the programmer with the longest blessed time\n    string blessedProgrammer;\n    int maxBlessedTime = 0;\n    for (const auto &prog : programmersTime) {\n        if (prog.second > maxBlessedTime) {\n            maxBlessedTime = prog.second;\n            blessedProgrammer = prog.first;\n        }\n    }\n    \n    cout << maxBlessedTime << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:47"
  }
]