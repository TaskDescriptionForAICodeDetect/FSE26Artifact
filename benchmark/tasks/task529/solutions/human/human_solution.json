[
  {
    "language": "Scala",
    "code": "import Main.AhoCorasick.Automaton\n\nimport scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn\n\nobject Main extends App {\n  import scala.io.StdIn._\n\n  val file = StdIn\n\n  val n = file.readLine.toInt\n  val patterns = Array.tabulate(n){_ ⇒ file.readLine.trim}\n  val target = file.readLine.trim\n  println(solve(target, patterns))\n  def solve(target: String, patterns: Array[String]): Long = {\n    val mod = 1000000007L\n    val aho = AhoCorasick(patterns)\n    val memo = Array.tabulate(target.length + 1){_ ⇒ 0L}.also(_(0) = 1L)\n    val automaton = aho.makeAutomaton\n    for (i ← target.indices){\n      automaton.move(target(i))\n      for (length ← automaton.matchLength){\n        memo(i + 1) += memo(i - length + 1)\n      }\n      memo(i + 1) %= mod\n    }\n    memo.last\n  }\n\n  object AhoCorasick {\n    private object Trie{\n      def apply(patterns: Iterable[String]): Trie = {\n        val res = new Trie\n        for (pattern ← patterns) {\n          var length = 0\n          var current = res\n          while (length != pattern.length) {\n            current.child.find(_._1 == pattern(length)) match {\n              case Some((_, trie)) ⇒\n                current = trie\n                length += 1\n              case None ⇒\n                val next = new Trie\n                current.child ::= (pattern(length), next)\n                current = next\n                length += 1\n            }\n          }\n          current.word = pattern\n        }\n        res\n      }\n    }\n\n    private class Trie {\n      private var word: String = \"\"\n      private[AhoCorasick] def pattern: String = word\n      private var child: List[(Char, Trie)] = Nil\n      private[AhoCorasick] def children: List[(Char, Trie)] = child\n    }\n    def apply(patterns: Iterable[String]): AhoCorasick = {\n      val trie = Trie(patterns)\n      val root = new AhoCorasick().also{aho ⇒\n        aho.pattern = trie.pattern\n      }\n      val queue: mutable.Queue[(AhoCorasick, Trie)] = mutable.Queue((root, trie))\n      while (queue.nonEmpty){\n        val (aho, trie) = queue.dequeue()\n        for ((c, t) ← trie.children){\n          val next = new AhoCorasick().also{it ⇒\n            it.pattern = t.pattern\n            val (f, m) = findNext(aho, c)\n            it.failure = f\n            it.matchLength = if (it.hasPattern) t.pattern.length::m else m\n          }\n          aho.child ::= (c, next)\n          queue.enqueue((next, t))\n        }\n      }\n      root\n    }\n    @tailrec\n    private[this] def addToResult(current: AhoCorasick, length: Int, result: List[(Int, Int)]): List[(Int, Int)] = {\n      if (current.isRoot) result\n      else if (current.hasPattern) addToResult(current.failure, length, (length - current.patternLength, length - 1)::result)\n      else addToResult(current.failure, length, result)\n    }\n    @tailrec\n    private[this] def findNext(current: AhoCorasick, next: Char): (AhoCorasick, List[Int]) = {\n      current.child.find(_._1 == next) match {\n        case Some((_, t)) ⇒ (t, t.matchLength)\n        case None if current.isRoot ⇒ (current, Nil)\n        case _ ⇒ findNext(current.failure, next)\n      }\n    }\n    @tailrec\n    private[this] def findNext(current: AhoCorasick, target: String, length: Int): AhoCorasick = {\n      current.child.find(_._1 == target(length)) match {\n        case Some((_, r)) ⇒ r\n        case None if current.isRoot ⇒ current\n        case _ ⇒ findNext(current.failure, target, length)\n      }\n    }\n    @tailrec\n    private def findAll(current: AhoCorasick, target: String, length: Int, result: List[(Int, Int)]): List[(Int, Int)] = {\n      if (target.length == length) addToResult(current, length, result)\n      else findAll(findNext(current, target, length), target, length + 1, addToResult(current, length, result))\n    }\n    class Automaton private[AhoCorasick] (private var aho: AhoCorasick){\n      def move(char: Char): Unit = {\n        var isEnd = true\n        while(isEnd) {\n          aho.child.find(_._1 == char) match {\n            case Some((_, next)) ⇒\n              aho = next\n              isEnd = false\n            case None if aho.isRoot ⇒\n              isEnd = false\n            case None ⇒ aho = aho.failure\n          }\n        }\n      }\n      def matchLength: List[Int] = aho.matchLength\n    }\n  }\n  class AhoCorasick {\n    private var failure = this\n    private var pattern = \"\"\n    private var matchLength: List[Int] = Nil\n    private var child = Nil: List[(Char, AhoCorasick)]\n    private def isRoot: Boolean = failure == this\n    private def hasPattern: Boolean = pattern != \"\"\n    private def patternLength: Int = pattern.length\n    def findAllMatch(target: String): List[(Int, Int)] = {\n      AhoCorasick.findAll(this, target, 0, Nil)\n    }\n    def makeAutomaton: Automaton = new Automaton(this)\n  }\n\n  implicit class Scope[T](val value: T) extends AnyVal{\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    @inline\n    def let[A](func: T ⇒ A): A = func(value)\n\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int P0 = 23;\nconst int P1 = 67;\nconst int MOD0 = 998244353;\nconst int MOD1 = 1000000007;\n\ntypedef pair<int , int> P;\n\n#define mkp(a , b) make_pair(a , b)\n#define ft first\n#define sd second\n\ninline P operator + (P p , P q){return mkp((p.ft + q.ft) % MOD0 , (p.sd + q.sd) % MOD1);}\ninline P operator - (P p , P q){return mkp((p.ft - q.ft + MOD0) % MOD0 , (p.sd - q.sd + MOD1) % MOD1);}\ninline P operator * (P p , P q){return mkp(1ll * p.ft * q.ft % MOD0 ,  1ll * p.sd * q.sd % MOD1);}\n\ninline P &operator +=(P &p , P q){return p = p + q;}\ninline P &operator -=(P &p , P q){return p = p - q;}\ninline P &operator *=(P &p , P q){return p = p * q;}\n\nconst int N = 100005;\nconst int L = 100005;\n\nunordered_set<LL> exist;\n\nP hash_value[L] , inv[L] , invp;\nchar s[L] , t[L];\nint len[N];\nint f[L];\nint n , l;\n\ninline int quick_power(int x , int y , int mod)\n{\n\tint ret = 1;\n\tfor (;y;y >>= 1 , x = 1ll * x * x % mod) if (y & 1) ret = 1ll * ret * x % mod;\n\treturn ret;\n}\n\ninline void add(int &x , int y){x = x + y >= MOD1 ? x + y - MOD1 : x + y;}\n\nint main()\n{\n\t//freopen(\"b.in\" , \"r\" , stdin) , freopen(\"b.out\" , \"w\" , stdout);\n\tscanf(\"%d\" , &n);\n\tfor (int i = 1 , l_;i <= n;++ i)\n\t{\n\t\tscanf(\"%s\" , s + 1) , l_ = strlen(s + 1) , len[i] = l_;\n\t\tP base = mkp(1 , 1) , cur = mkp(0 , 0);\n\t\tfor (int j = 1;j <= l_;++ j)\n\t\t{\n\t\t\tcur += base * mkp(s[j] - 'a' + 1 , s[j] - 'a' + 1);\n\t\t\tbase *= mkp(P0 , P1);\n\t\t}\n\t\texist.insert(cur.ft * 1000000000ll + cur.sd);\n\t}\n\tsort(len + 1 , len + 1 + n) , n = unique(len + 1 , len + 1 + n) - (len + 1);\n\tscanf(\"%s\" , t + 1) , l = strlen(t + 1);\n\tinv[0] = mkp(1 , 1) , invp = mkp(quick_power(P0 , MOD0 - 2 , MOD0) , quick_power(P1 , MOD1 - 2 , MOD1));\n\tP base = mkp(1 , 1);\n\tf[0] = 1;\n\tfor (int i = 1;i <= l;++ i)\n\t{\n\t\tinv[i] = inv[i - 1] * invp;\n\t\thash_value[i] = hash_value[i - 1] + base * mkp(t[i] - 'a' + 1 , t[i] - 'a' + 1);\n\t\tfor (int j = 1;j <= n && len[j] <= i;++ j)\n\t\t{\n\t\t\tP range_hash = (hash_value[i] - hash_value[i - len[j]]) * inv[i - len[j]];\n\t\t\tif (exist.count(range_hash.ft * 1000000000ll + range_hash.sd)) add(f[i] , f[i - len[j]]);\n\t\t}\n\t\tbase *= mkp(P0 , P1);\n\t}\n\tprintf(\"%d\\n\" , f[l]);\n\t//fclose(stdin) , fclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll in()\n{\n    ll re=0,f=1;char x=getchar();\n    while(x<'0'||x>'9'){if(x=='-')f=-1;x=getchar();}\n    while(x>='0'&&x<='9')re=re*10+x-48,x=getchar();\n    return re*f;\n}\nvoid out(ll x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(!x){putchar('0');return;}\n    char z[21],ct=0;\n    while(x){z[++ct]=x%10+48,x/=10;}\n    while(ct){putchar(z[ct]);--ct;}\n}\nint n;\nchar ss[500000];\nint s[100010],pt;\nint len[100010],tlen;\nchar t[100010];\nint ptr=1;\nconst ll mod=1e9+7;\nstruct node{\n    int ch[26],fa;\n    char v;\n    vector<int>cnt;\n}nd[200010];\nvoid ins(int l,int len)\n{\n    int cur=1;\n    for(int i=l;i<l+len;++i)\n    {\n        char c=ss[i];\n        if(!nd[cur].ch[c-'a'])\n        {\n            nd[cur].ch[c-'a']=++ptr;\n            nd[ptr].fa=cur;\n            nd[ptr].v=c;\n        }\n        cur=nd[cur].ch[c-'a'];\n    }\n    nd[cur].cnt.push_back(len);\n}\nint fail[200010];\nvoid bfs()\n{\n    queue<int>q;\n    fail[1]=1;\n    for(int i=0;i<26;++i)\n    if(nd[1].ch[i])\n    {\n        fail[nd[1].ch[i]]=1;\n        q.push(nd[1].ch[i]);\n    }\n    else nd[1].ch[i]=1;\n    while(!q.empty())\n    {\n        int h=q.front();q.pop();\n        for(int i=0;i<26;++i)\n        if(nd[h].ch[i])\n        {\n            fail[nd[h].ch[i]]=nd[fail[h]].ch[i];\n            q.push(nd[h].ch[i]);\n        }\n        else nd[h].ch[i]=nd[fail[h]].ch[i];\n    }\n}\nll dp[200010];\nint main()\n{\n    scanf(\"%d\\n\",&n);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%s\",ss+pt);\n        s[i]=pt;\n        len[i]=strlen(ss+pt);\n        pt=pt+len[i]+1;\n    }\n    for(int i=1;i<=n;++i)\n        ins(s[i],len[i]);\n    bfs();\n    scanf(\"%s\",t+1);\n    tlen=strlen(t+1);\n    dp[0]=1;\n    int cur=1;\n    for(int i=1;i<=tlen;++i)\n    {\n        cur=nd[cur].ch[t[i]-'a'];\n        int now=cur;\n        while(now>1)\n        {\n            vector<int>&v=nd[now].cnt;\n            for(int j=0;j<v.size();++j)\n                dp[i]=(dp[i]+dp[i-v[j]])%mod;\n            now=fail[now];\n        }\n    }\n    cout<<dp[tlen]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL=long long;\n#define rep(i,n) for(int i=0; i<n; i++)\n#define rep1(i,n) for(int i=1; i<n; i++)\n#define all(a) (a).begin(),(a).end();\n\nusing uLL=unsigned long long;\nmap<int,int>M;\nset<uLL>S[700];\nint n;\nstring s[1<<17];\nLL dp[1<<17],mod=1e9+7;\nuLL gethash(string a)\n{\n  uLL B=mod;\n  uLL now=0;\n  for(int i=0;i<a.size();i++)now=now*B+a[i];\n  return now;\n}\nvector<uLL>h(1);\nvector<uLL>make(1);\nvector<int>le(1);\n\nint main(){\n  cin>>n;\n  int sz=0;\n  for(int i=0;i<n;i++)\n  {\n    cin>>s[i];\n    int l=s[i].length();\n    int id;\n    if(M[l]==0)\n    {\n      id=M[l]=++sz;\n      uLL now=1;\n      uLL B=mod;\n      for(int j=0;j<l;j++)now=now*B;\n      make.push_back(now);\n      h.push_back(0);\n      le.push_back(l);\n    }\n    else id=M[l];\n    S[id].insert(gethash(s[i]));\n  }\n  string t;cin>>t;\n  dp[0]=1;\n  for(int i=0;i<t.size();i++)\n  {\n    for(int j=1;j<=sz;j++)\n    {\n      h[j]=h[j]*(uLL)mod+t[i];\n      if(i>=le[j])h[j]=h[j]-make[j]*t[i-le[j]];\n      if(i>=le[j]-1&&S[j].find(h[j])!=S[j].end())\n      {\n        dp[i+1]=(dp[i+1]+dp[i+1-le[j]])%mod;\n      }\n    }\n  }\n  cout<<dp[t.size()]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <cstring>\n#include <queue>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007;\nconst int SIZE = 26;\n\nstruct PMA {\n  PMA* node[SIZE + 1];\n  vector<int> matched;\n  PMA() { memset(node, 0, sizeof(node)); }\n\n  vector<int> unite(const vector<int> &a, const vector<int> &b) {\n    vector<int> ret;\n    set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(ret));\n    return ret;\n  }\n\n  void build(vector<string> pattern) {\n    PMA* root = this;\n    root -> node[SIZE] = root;\n    for(size_t i=0; i<pattern.size(); i++) {\n      PMA* now = root;\n      for(size_t j=0; j<pattern[i].size(); j++) {\n        int c = pattern[i][j] - 'a';\n        if(!now -> node[c]) {\n          now -> node[c] = new PMA;\n        }\n        now = now -> node[c];\n      }\n      now -> matched.push_back(i);\n    }\n\n    queue<PMA*> que;\n    for(int i=0; i<SIZE; i++) {\n      if(!root -> node[i]) root -> node[i] = root;\n      else {\n        root -> node[i] -> node[SIZE] = root;\n        que.push(root -> node[i]);\n      }\n    }\n\n    while(que.size()) {\n      PMA* now = que.front(); que.pop();\n      for(int i=0; i<SIZE; i++) {\n        if(now -> node[i]) {\n          PMA* nxt = now -> node[SIZE];\n          while(!nxt -> node[i]) nxt = nxt -> node[SIZE];\n\n          now->node[i]->node[SIZE] = nxt->node[i];\n          now->node[i]->matched=unite(now->node[i]->matched, nxt->node[i]->matched);\n          que.push(now->node[i]);\n        }\n      }\n    }\n  }\n\n  ll solve(const string s, vector<string> pattern) {\n    PMA* pma = this;\n\n    int N = s.length();\n    vector<ll> dp(N+1);\n    dp[0] = 1;\n    for(size_t i=0; i<s.length(); i++) {\n      int c = s[i] - 'a';\n      while(!pma -> node[c]) pma = pma -> node[SIZE];\n\n      pma = pma -> node[c];\n      for(size_t j=0; j<pma->matched.size(); j++) {\n        int r = i+1, l=r-pattern[ pma->matched[j] ].length();\n        (dp[r] += dp[l]) %= MOD;\n      }\n    }\n\n    return dp[N];\n  }\n};\n\nint main() {\n  int N; cin >> N;\n  vector<string> pats(N);\n  for(int i=0; i<N; i++) {\n    cin >> pats[i];\n  }\n\n  string text; cin >> text;\n  PMA pma;\n  pma.build(pats);\n\n  cout << pma.solve(text, pats) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n\n// int main(){\n// \n// \n//   return 0;\n// }\n\n/* Rolling Hash */\n// n = 9973, 10007\n\nstruct RollingHash{\n  int N, base;\n  ll hash[SIZE], pow[SIZE];\n\n  template <typename Type>\n  RollingHash(int base, int n, Type *arr):\n    N(n), base(base)\n  {\n    hash[0] = 0;\n    pow[0] = 1;\n    for(int i=0; i<N; i++){\n      hash[i+1] = (hash[i] + arr[i]) * base % mod;\n      pow[i+1] = pow[i] * base % mod;\n    }\n  }\n\n  // get [l,r)\n  ll getHash(int l, int r) {\n    return (mod + hash[r] - hash[l] * pow[r-l] % mod) % mod;\n  }\n};\n\nconst int base1 = 9973;\nconst int base2 = 10007;\n\nset<pair<ll,ll>> ss[700];\nmap<int,int> dict;\nint dicti = 0;\nvector<int> vec;\n\nll getHash(int base, int n, char *arr){\n  RollingHash rh(base, n, arr);\n  return rh.getHash(0, n);\n}\n\nchar s[SIZE], t[SIZE];\nll dp[SIZE] = {};\n\nint main(){\n  int n;\n\n  scanf(\"%d\", &n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%s\", s);\n    int m = strlen(s);\n    ll h1 = getHash(base1, m, s);\n    ll h2 = getHash(base2, m, s);\n    vec.push_back(m);\n    if(dict.find(m) == dict.end()) dict[m] = dicti++;\n    ss[dict[m]].insert({h1, h2});\n  }\n\n  scanf(\"%s\", t);\n\n  int m = strlen(t);\n  RollingHash rh1(base1, m, t), rh2(base2, m, t);\n\n  dp[0] = 1;\n\n  for(int i=0;i<m;i++){\n    for(auto it : dict){\n      int p = it.first;\n      if(i+p > m) break;\n      ll h1 = rh1.getHash(i, i+p);\n      ll h2 = rh2.getHash(i, i+p);\n      if(ss[it.second].find({h1, h2}) != ss[it.second].end())\n        dp[i+p] = (dp[i+p] + dp[i]) % mod;\n    }\n  }\n\n  printf(\"%lld\\n\", dp[m]);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define Real double\n#define int long long\n\nconst int MAXN=100020;\nint dp[100020]={0};\nnamespace SA{\n\tint rank[MAXN],tmp[MAXN];\n\tint n,k;\n\tbool compare_sa(int i,int j){\n\t\tif(rank[i]!=rank[j]) return rank[i] <rank[j];\n\t\tint ri=(i+k<=n) ?rank[i+k]:-1;\n\t\tint rj=(j+k<=n) ?rank[j+k]:-1;\n\t\treturn ri<rj;\n\t}\n\n\tvoid createSA(const string &s,int *sa){\n\t\tn=s.size();\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tsa[i]=i;\n\t\t\trank[i]=i<n?s[i]:-1;\n\t\t}\n\t\tfor(k=1;k<=n;k*=2){\n\t\t\tsort(sa,sa+n+1,compare_sa);\n\t\t\ttmp[sa[0]]=0;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ttmp[sa[i]]=tmp[sa[i-1]]+(compare_sa(sa[i-1],sa[i])?1:0);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++) rank[i]=tmp[i];\n\t\t}\n\t}\n}\nint N;\nvector<int> G[100020];\nstring e[200020];\n\nint me[100020];\nint saiki(int u){\n//\tcout<<u<<endl;\n\tif(u==N) return 1;\n\tif(me[u]>=0)return me[u];\nint r=0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tr+=saiki(G[u][i]);\n\t\tr %= 1000000007;\n\t} \n\t\tme[u]=r;\n\treturn r;\n\n}\nvector<int> ve;\nint sa[MAXN];\nsigned main() {\n\tint t;\n\tcin>>t;\n\nfor(int i=0;i<t;i++){\n\tcin>>e[i];\n}\n\nstring s;\ncin>>s;\nN=s.size();\nSA::createSA(s,sa);\nfor(int i=0;i<100020;i++) me[i]=-1;\n//for(int i=0;i<=N;i++) cout<<sa[i]<<\" \";\n//\tcout<<endl;\n\n//cout<<\"s\"<<esss\n\tint ch[30]={0};\n\tfor(int i=0;i<N;i++) ch[s[i]-'a']++;\nbool w=false;\nint mo;\n\t\tfor(int i=0;i<26;i++) if(ch[i]==100000){\n\t\t\tw=true;\n\t\t\tmo=i;\n}\n\nif(w){\n\nfor(int i=0;i<t;i++){\n\tfor(int j=0;j<30;j++) ch[j]=0;\n\t\tfor(int j=0;j<e[i].size();j++) ch[e[i][j]-'a']++;\n\t\t\tif(ch[mo]==e[i].size()) ve.push_back(e[i].size());\n}\n\ndp[0]=1;\nfor(int i=1;i<=100000;i++){\n\tfor(int j=0;j<ve.size();j++){\n\t\tif(i<ve[j]) continue;\n\t\tdp[i] += dp[i-ve[j]];\n\t\tdp[i] %= 1000000007;\n\t}\n}\ncout<<dp[100000]<<endl;\nreturn 0;\n\n}\n\nfor(int i=0;i<t;i++){\n\nint l=e[i].length();\n\tint ue=N+1;\n\tint si=0;\n\tint me;\n\twhile(ue-si>1){\n\t\tme=(ue+si)/2;\n\t\tif(s.substr(sa[me])<e[i]) si=me;\n\t\telse ue=me;\n\t}\n\tint hanisi=ue;\n\n\tue=N+1,si=0;\nstring ee=e[i];\nee[e[i].length()-1]++;\n\twhile(ue-si>1){\n\t\tme=(ue+si)/2;\n\t\tif(s.substr(sa[me])>=ee) ue=me;\n\t\telse si=me;\n\t}\n\tint haniue=si;\n//cout<<e[i]<<endl;\n//cout<<\"   \"<<hanisi<<\" \"<<haniue<<endl;1\n\tfor(int j=hanisi;j<=haniue;j++){\n\t\tG[sa[j]].push_back(sa[j]+l);\n\t//\tcout<<sa[j]<<\" \"<<sa[j]+l<<endl;\n\t}\n\n}\n\n//cout<<\"e\"<<endl;\n\n\ncout<<saiki(0)<<endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <vector>\n#define llint long long\n#define ulint unsigned long long\n#define mod 1000000007\n\nusing namespace std;\n\nstruct node{\n  int num;\n  int next[26];\n  node(){\n    num = 0;\n    for(int i = 0; i < 26; i++) next[i] = -1;\n  }\n};\n\nint n;\nstring s, t;\nint R = 430;\nvector<string> vec;\nvector<node> trie;\nulint beki[200005];\nulint shash[200005], thash[200005];\nllint dp[100005];\n\nulint getHash(string &s)\n{\n  ulint ret = 0;\n  for(int i = 0; i < s.size(); i++) ret = ret * mod + s[i];\n  return ret;\n}\n\nint main(void)\n{\n  cin >> n;\n\n  beki[0] = 1;\n  for(int i = 1; i < 200005; i++) beki[i] = beki[i-1] * mod;\n\n  trie.push_back(node());\n  for(int i = 1; i <= n; i++){\n    cin >> s;\n    if(s.size() >= R){\n      vec.push_back(s);\n      shash[vec.size()-1] = getHash(s);\n    }\n    else{\n      int p = 0;\n      for(int j = 0; j < s.size(); j++){\n        if(trie[p].next[s[j]-'a'] == -1){\n          trie.push_back(node());\n          trie[p].next[s[j]-'a'] = trie.size()-1;\n        }\n        p = trie[p].next[s[j]-'a'];\n      }\n      trie[p].num++;\n    }\n  }\n\n  cin >> t;\n  int m = t.size();\n  t = \"#\" + t;\n  thash[0] = t[0];\n  for(int i = 1; i <= m; i++){\n    thash[i] = thash[i-1] * mod + t[i];\n  }\n\n  dp[0] = 1;\n  for(int i = 0; i < m; i++){\n    int p = 0;\n    for(int j = 1; j < R; j++){\n      if(i+j > m) break;\n      p = trie[p].next[t[i+j]-'a'];\n      if(p == -1) break;\n      if(trie[p].num) dp[i+j] += dp[i], dp[i+j] %= mod;\n    }\n    for(int j = 0; j < vec.size(); j++){\n      int len = vec[j].size(), l = i+1, r = i+len;\n      if(r > m) continue;\n      if(thash[r] - thash[l-1] * beki[r-l+1] == shash[j]) dp[r] += dp[i], dp[r] %= mod;\n    }\n  }\n  cout << dp[m] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nstruct RollingHash {\n    using uint = uint64_t;\n    vector<uint> hash, pow;\n    static const uint MASK30 = (1LL<<30)-1,\n                 MASK31 = (1LL<<31)-1,\n                 MASK61 = (1LL<<61)-1;\n\n    template<typename S>\n        RollingHash(const S& s, uint base) {\n            int n = s.size();\n            hash.assign(n+1, 0);\n            pow.assign(n+1, 1);\n            for (int i = 0; i < n; ++i) {\n                hash[i+1] = _mod(_mul(hash[i], base) + s[i]);\n                pow[i+1] = _mul(pow[i], base);\n            }\n        }\n\n    uint get(int l, int r) const {\n        return _mod(hash[r] + MASK61 - _mul(hash[l], pow[r - l]));\n    }\n\n    static uint _mul(uint a, uint b) {\n        uint au = a >> 31, ad = a & MASK31,\n             bu = b >> 31, bd = b & MASK31;\n        uint m = au * bd + ad * bu;\n        uint mu = m >> 30, md = m & MASK30;\n\n        return _mod(au*bu*2 + mu + (md<<31) + ad*bd);\n    }\n    static uint _mod(uint x) {\n        uint xu = x >> 61, xd = x & MASK61;\n        uint ret = xu + xd;\n        if (ret >= MASK61) ret -= MASK61;\n        return ret;\n    }\n    static uint gen_base() {\n        mt19937 random{random_device{}()};\n        uniform_int_distribution<uint> dist(2, MASK61-2);\n        return dist(random);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    using uint = uint64_t;\n    using Int = modint<MOD>;\n\n    int n; cin >> n;\n    uint BASE = RollingHash::gen_base();\n    map<int,map<uint,bool>> hash;\n    for (int i = 0; i < n; ++i) {\n        string s; cin >> s;\n        hash[s.size()][RollingHash(s, BASE).get(0, s.size())] = true;\n    }\n\n    string t; cin >> t;\n    RollingHash hashT(t, BASE);\n\n    vector<Int> dp(t.size()+1);\n    dp[0] = 1;\n    for (int i = 0; i < t.size(); ++i) {\n        for (const auto& tp : hash) {\n            int sz = tp.first;\n            const map<uint,bool>& mp = tp.second;\n            if (i + sz > t.size()) continue;\n            if (mp.count(hashT.get(i, i+sz))) {\n                dp[i + sz] += dp[i];\n            }\n        }\n    }\n\n    cout << dp[t.size()] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\nint n;\nstring s[1<<17];\nset<unsigned long>S[700];\nmap<int,int>M;\nvector<unsigned long>h,make;\nvector<int>le;\nstring t;\nlong dp[1<<17],mod=1e9+7;\nmain()\n{\n\tcin>>n;\n\tint sz=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i];\n\t\tint l=s[i].size();\n\t\tif(M.find(l)==M.end())\n\t\t{\n\t\t\tM[l]=sz++;\n\t\t\tle.push_back(l);\n\t\t\th.push_back(0);\n\t\t\tunsigned long now=1;\n\t\t\tfor(int j=0;j<l;j++)\n\t\t\t{\n\t\t\t\tnow=now*mod;\n\t\t\t}\n\t\t\tmake.push_back(now);\n\t\t}\n\t\tunsigned long tmp=0;\n\t\tfor(int j=0;j<l;j++)tmp=tmp*mod+s[i][j];\n\t\tS[M[l]].insert(tmp);\n\t}\n\tcin>>t;\n\tdp[0]=1;\n\tfor(int i=0;i<t.size();i++)\n\t{\n\t\tfor(int j=0;j<sz;j++)\n\t\t{\n\t\t\th[j]=h[j]*mod+t[i];\n\t\t\tif(i>=le[j])h[j]-=t[i-le[j]]*make[j];\n\t\t\tif(i>=le[j]-1&&S[j].find(h[j])!=S[j].end())dp[i+1]=(dp[i+1]+dp[i+1-le[j]])%mod;\n\t\t}\n\t}\n\tcout<<dp[t.size()]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <math.h>\n#include <deque>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\nconst int N=100001;\nconstexpr ll mod=1e9+7;\n\nint dp[N];\null m;\nvector<ull> g[N];\null po[N],hs[N];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint q; cin >> q;\n\tstring s; \n\twhile(q--){\n\t\tcin >> s;\n\t\tm=0;\n\t\tfor(char c:s){\n\t\t\tm=m*911+c;\n\t\t}\n\t\tg[s.size()].push_back(m);\n\t}\n\tcin >> s;po[0]=1;\n\tfor(int i=0;i<s.size();i++){\n\t\tpo[i+1]=911*po[i];\n\t\ths[i+1]=911*hs[i]+s[i];\n\t}\n\tvector<int> v;\n\tfor(int i=1;i<=s.size();i++){\n\t\tif(g[i].size()){\n\t\t\tv.push_back(i);\n\t\t\tsort(g[i].begin(), g[i].end());\n\t\t}\n\t}\n\tdp[0]=1;\n\tfor(int i=1;i<=s.size();i++){\n\t\tfor(int j:v){\n\t\t\tif(j>i)continue;\n\t\t\tint l=0,r=g[j].size();\n\t\t\tull f=hs[i]-hs[i-j]*po[j];\n\t\t\twhile(r-l>1){\n\t\t\t\tint mi=(l+r)/2;\n\t\t\t\tif(g[j][mi]<=f)l=mi;\n\t\t\t\telse r=mi;\n\t\t\t}\n\t\t\tif(g[j][l]==f){\n\t\t\t\tdp[i]+=dp[i-j];\n\t\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[s.size()]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n\nstruct RollingHash{\n  typedef unsigned long long ull;\n  string S;\n  ull B;\n  Int len;\n  vector<ull> hash,p;\n  RollingHash(){}\n  RollingHash(string S_,ull B_ = 1e9+7):\n    S(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n    hash[0] = 0; p[0] = 1;\n    for(Int i=0;i<len;i++){\n      hash[i+1] = hash[i] * B + S[i];\n      p[i+1] = p[i] * B;\n    }\n  }\n\n  ull find(Int l,Int r){\n    return hash[r] - hash[l] * p[r-l];\n  }\n};\n\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  vector<string> s(n);\n  for(Int i=0;i<n;i++) cin>>s[i];\n  \n  string t;\n  cin>>t;\n  \n  vector<RollingHash> rhs;\n  for(Int i=0;i<n;i++) rhs.push_back(RollingHash(s[i]));\n  using ull=RollingHash::ull;\n  vector< vector<Int> > l(26);\n  vector< vector<ull> > v(26);\n  for(Int i=0;i<n;i++){\n    l[s[i][0]-'a'].push_back(s[i].size());\n    v[s[i][0]-'a'].push_back(rhs[i].find(0,s[i].size()));\n  }\n  \n  RollingHash rht(t);\n  vector<Int> dp(t.size()+1,0);\n  dp[0]=1;\n  const Int MOD=1e9+7;\n  for(Int i=0;i<(Int)t.size();i++){\n    if(!dp[i]) continue;\n    for(Int j=0;j<(Int)l[t[i]-'a'].size();j++){\n      if(i+l[t[i]-'a'][j]>(Int)t.size()) continue;\n      if(rht.find(i,i+l[t[i]-'a'][j])==v[t[i]-'a'][j]){\n\tdp[i+l[t[i]-'a'][j]]+=dp[i];\n\tdp[i+l[t[i]-'a'][j]]%=MOD;\n      }\n    }\n  }\n  cout<<dp.back()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9+7;\n\nstruct AhoCorasick{\n    static const int charsiz = 128;\n    struct Node{\n        vector<int> matched;\n        int next[charsiz];\n        Node() {\n            memset(next, 0, sizeof(next));\n        }\n    };\n    \n    vector<Node> automaton;\n    vector<string> patterns;\n    \n    AhoCorasick(){}\n    AhoCorasick(vector<string> &s){\n        patterns = s;\n        build();\n    }\n    \n    void build(){\n        make_trie();\n        make_failure_path();\n    }\n    void make_trie(){\n        automaton.emplace_back();\n        for(int i=0; i<(int)patterns.size(); i++){\n            int curr = 0;\n            for(int c: patterns[i]){ \n                if(automaton[curr].next[c] == 0){\n                    automaton[curr].next[c] = automaton.size();\n                    automaton.emplace_back();\n                }\n                curr = automaton[curr].next[c];\n            }\n            automaton[curr].matched.push_back(i);\n        }\n    }\n    void make_failure_path(){\n        queue<int> wait;\n        wait.push(0);\n        while(!wait.empty()){\n            int curr = wait.front();\n            wait.pop();\n            for(int i=1; i<charsiz; i++){\n                int next_i = automaton[curr].next[i];\n                if(next_i != 0){\n                    int fail = automaton[curr].next[0];\n                    while(fail!=0 and automaton[fail].next[i]==0){\n                        fail = automaton[fail].next[0];\n                    }\n                    if(fail == curr){\n                        automaton[next_i].next[0] = 0;\n                    }else{\n                        automaton[next_i].next[0] = automaton[fail].next[i];\n                    }\n                    wait.push(next_i);\n                }\n            }\n            insertvec(automaton[curr].matched,\n                      automaton[automaton[curr].next[0]].matched);\n        }\n    }\n    vector<vector<int>> match(string &t){\n        vector<vector<int>> res(patterns.size());\n        int curr = 0;\n        for(int i=0; i<(int)t.length(); i++){\n            while(curr!=0 and automaton[curr].next[(int)t[i]]==0){\n                curr = automaton[curr].next[0];\n            }\n            curr = automaton[curr].next[(int)t[i]];\n            \n            for(int j: automaton[curr].matched){\n                int len = patterns[j].length();\n                res[j].push_back(i-len+1);\n            }\n        }\n        return res;\n    }\n    vector<int> match_seq(string &t){\n        vector<int> res(t.length());\n        int curr = 0;\n        for(int i=0; i<(int)t.length(); i++){\n            while(curr!=0 and automaton[curr].next[(int)t[i]]==0){\n                curr = automaton[curr].next[0];\n            }\n            curr = automaton[curr].next[(int)t[i]];\n            res[i] = curr;;\n        }\n        return res;\n    }\n    \n    template<class T>\n    void insertvec(vector<T> &a, const vector<T> &b){\n        a.insert(a.end(), b.begin(), b.end());\n    }\n};\n\nint main(){\n    int n;\n    cin >> n;\n    \n    vector<string> s(n);\n    for(int i=0; i<n; i++){\n        cin >> s[i];\n    }\n    string t;\n    cin >> t;\n    AhoCorasick ac(s);\n    auto ret = ac.match_seq(t);\n    \n    vector<vector<int>> matchlen(t.length());\n    for(int i=0; i<(int)t.length(); i++){\n        for(int strid: ac.automaton[ret[i]].matched){\n            int len = s[strid].length();\n            matchlen[i-len+1].push_back(len);\n        }\n    }\n    vector<lli> dp(t.length()+1, 0);\n    dp[0] = 1;\n    for(int i=0; i<(int)t.length(); i++){\n        for(int j: matchlen[i]){\n            dp[i+j] = (dp[i+j] + dp[i]) %mod;\n        }\n    }\n    cout << dp.back() << endl;\n    return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 200005;\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nset<pll> st[MAX_N];\nll dp[MAX_N/2];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<int> l;\n    rep(i,n){\n        string s;\n        cin >> s;\n        RollingHash rh;\n        st[len(s)].insert(rh.hash(s));\n        l.pb(len(s));\n    }\n    zip(l);\n    string t;\n    cin >> t;\n    int m = len(t);\n    RollingHash rh;\n    rh.init(t);\n    dp[0] = 1;\n    rep(i,m){\n        if(dp[i]){\n            each(j,l){\n                if(i+j > m) break;\n                if(st[j].find(rh.hash(i,i+j-1)) != st[j].end()){\n                    dp[i+j] = (dp[i+j]+dp[i]) % MOD;\n                }\n            }\n        }\n    }\n    cout << dp[m] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Node{\n\tint table[26];\n\tbool finish_FLG;\n};\n\nNode nodes[200001];\n\nint node_index = 1,N,length;\nll dp[100001];\nchar buf[100001];\n\nll recursive(int start_pos){\n\n\tif(dp[start_pos] != -1)return dp[start_pos];\n\n\tstack<int> S;\n\n\tint tmp_ch,tmp_node_index = 0,ch_loc = start_pos,depth = 0;\n\n\twhile(true){\n\t\ttmp_ch = buf[ch_loc]-'0';\n\n\t\tif(nodes[tmp_node_index].table[tmp_ch] == -1)break;\n\n\t\ttmp_node_index = nodes[tmp_node_index].table[tmp_ch];\n\t\tdepth++;\n\n\t\tif(nodes[tmp_node_index].finish_FLG){\n\t\t\tS.push(start_pos+depth);\n\t\t}\n\n\t\tch_loc++;\n\n\t\tif(buf[ch_loc] == '\\0')break;\n\t}\n\n\tdp[start_pos] = 0;\n\n\twhile(!S.empty()){\n\t\tdp[start_pos] += recursive(S.top());\n\t\tdp[start_pos] %= MOD;\n\t\tS.pop();\n\t}\n\n\tdp[start_pos] %= MOD;\n\n\treturn dp[start_pos];\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 200000; i++){\n\t\tfor(int k = 0; k < 26; k++)nodes[i].table[k] = -1;\n\t\tnodes[i].finish_FLG = false;\n\t}\n\n\tscanf(\"%d\",&N);\n\n\tint tmp_ch,tmp_node_index,ch_loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s\",buf);\n\n\t\ttmp_node_index = 0;\n\t\tch_loc = 0;\n\n\t\twhile(true){\n\t\t\ttmp_ch = buf[ch_loc]-'0';\n\n\t\t\tif(nodes[tmp_node_index].table[tmp_ch] == -1){\n\t\t\t\tnodes[tmp_node_index].table[tmp_ch] = node_index;\n\t\t\t\ttmp_node_index = node_index;\n\t\t\t\tnode_index++;\n\t\t\t}else{\n\t\t\t\ttmp_node_index = nodes[tmp_node_index].table[tmp_ch];\n\t\t\t}\n\t\t\tch_loc++;\n\t\t\tif(buf[ch_loc] == '\\0'){\n\t\t\t\tnodes[tmp_node_index].finish_FLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\tfor(int i = 0; i < length; i++)dp[i] = -1;\n\tdp[length] = 1;\n\n\tprintf(\"%lld\\n\",recursive(0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int mod = 1e9 + 7;\n \nstruct TrieNode\n{\n  int nxt[27];\n \n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  vector< int > accept; // ???????????????id\n \n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n \nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n \n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n \n  virtual void direct_action(int node, int id) {}\n \n  virtual void child_action(int node, int child, int id) {}\n \n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n \n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n \n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n \n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n \n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n \n  int size()\n  {\n    return (nodes[0].exist);\n  }\n \n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n \nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n \n  Aho_Corasick() : Trie() {}\n \n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n \n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n \n        auto &u = nodes[now.nxt[i]].accept;\n        auto &v = nodes[nodes[fail].nxt[i]].accept;\n        vector< int > accept;\n        set_union(begin(u), end(u), begin(v), end(v), back_inserter(accept));\n        u = accept;\n        que.emplace(now.nxt[i]);\n      }\n \n    }\n  }\n \n  vector< int > match(char c, int &now)\n  {\n    while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n    now = nodes[now].nxt[c - 'a'];\n    // count += correct[now];\n    return (nodes[now].accept);\n  }\n};\n \nint main()\n{\n  int N;\n  string S[100000], T;\n \n  cin >> N;\n  Aho_Corasick aho;\n \n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n    aho.add(S[i]);\n  }\n  aho.build();\n \n  cin >> T;\n  vector< int > dp(T.size() + 1, 0);\n  dp[0] = 1;\n  int curr = 0;\n  for(int i = 0; i < T.size(); i++) {\n    for(auto &p : aho.match(T[i], curr)) {\n      (dp[i + 1] += dp[i + 1 - S[p].size()]) %= mod;\n    }\n  }\n \n  cout << dp.back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nconst ll mod = 1000000007;\nll N;\nll dp[100100];\nstruct SuffixArray {\n  vector< int > SA;\n  const string s;\n\n  SuffixArray(const string &str) : s(str) {\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](int a, int b) {\n      return s[a] == s[b] ? a > b : s[a] < s[b];\n    });\n    vector< int > classes(s.size()), c(s.begin(), s.end()), cnt(s.size());\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const {\n    return SA[k];\n  }\n\n  size_t size() const {\n    return s.size();\n  }\n\n  bool lt_substr(const string &t, int si = 0, int ti = 0) {\n    int sn = (int) s.size(), tn = (int) t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return true;\n      if(s[si] > t[ti]) return false;\n      ++si, ++ti;\n    }\n    return si >= sn && ti < tn;\n  }\n\n  int lower_bound(const string &t) {\n    int low = -1, high = (int) SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return high;\n  }\n\n  pair< int, int > lower_upper_bound(string &t) {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = (int) SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return {idx, high};\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nstruct LongestCommonPrefixArray {\n  const SuffixArray &SA;\n  vector< int > LCP, rank;\n\n  LongestCommonPrefixArray(const SuffixArray &SA) : SA(SA), LCP(SA.size()) {\n    rank.resize(SA.size());\n    for(int i = 0; i < SA.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    for(int i = 0, h = 0; i < SA.size(); i++) {\n      if(rank[i] + 1 < SA.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < SA.size() && SA.s[i + h] == SA.s[j + h]; ++h);\n        LCP[rank[i] + 1] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const {\n    return LCP[k];\n  }\n\n  size_t size() const {\n    return LCP.size();\n  }\n\n  void output() {\n    for(int i = 0; i < size(); i++) {\n      cout << i << \": \" << LCP[i] << \" \" << SA.s.substr(SA[i]) << endl;\n    }\n  }\n};\n\nvector<int> A[100010];\n\n\nint main() {\n    cin >> N;\n    vector<string> S(N);\n    for(int i = 0; i < N; i++) cin >> S[i];\n    sort(S.begin(), S.end());\n    S.erase(unique(S.begin(), S.end()), S.end());\n    N = S.size();\n    string T;\n    cin >> T;\n    SuffixArray SA(T);\n    //SA.output();\n    for(int i = 0; i < S.size(); i++) {\n        auto tmp = SA.lower_upper_bound(S[i]);\n        //cerr << S[i] << \" \" << tmp.first << \" \" << tmp.second << endl;\n        for(int j = tmp.first; j < tmp.second; j++) {\n            A[SA[j]].push_back(S[i].size());\n        }\n    }\n    dp[0] = 1;\n    for(int i = 0; i <= T.size(); i++) {\n        dp[i] %= mod;\n        for(auto delta : A[i]) {\n            dp[i+delta] += dp[i];\n        }\n    }\n    cout << dp[T.size()] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntemplate<int char_size>\nstruct TrieNode {\n  std::vector<int> nxt;\n\n  int exist;\n  std::vector<int> accept;\n\n  TrieNode():nxt(char_size+1, -1), exist(0) {}\n};\n\ntemplate<int char_size, int margin>\nstruct Trie {\n  using Node = TrieNode<char_size>;\n\n  std::vector<Node> nodes;\n  int root;\n\n  Trie():root(0) { nodes.push_back(Node()); }\n\n  virtual void direct_action(int node, int id) {node++;id++;}\n  virtual void child_action(int node, int child, int id) {node++;child++;id++;}\n\n  void update_direct(int node, int id) {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n  void update_child(int node, int child, int id) {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n  void add(const std::string& str, int str_idx, int node_idx, int id) {\n    if(str_idx == static_cast<int>(str.size())) {\n      update_direct(node_idx, id);\n    } else {\n      const int c = str[str_idx]-margin;\n      if(nodes[node_idx].nxt[c] == -1) {\n\tnodes[node_idx].nxt[c] = nodes.size();\n\tnodes.push_back(Node());\n      }\n      add(str, str_idx+1, nodes[node_idx].nxt[c], id);\n      update_child(node_idx, nodes[node_idx].nxt[c], id);\n    }\n  }\n  void add(const std::string& str, int id) {\n    add(str, 0, 0, id);\n  }\n  void add(const std::string& str) {\n    add(str, nodes[0].exist);\n  }\n  void query(const std::string& str, const std::function<void(int)>& f, int str_idx, int node_idx) {\n    for(auto& idx : nodes[node_idx].accept) f(idx);\n    if(str_idx == static_cast<int>(str.size())) {\n      return;\n    } else {\n      const int c = str[str_idx]-margin;\n      if(nodes[node_idx].nxt[c] == -1) return;\n      query(str, f, str_idx+1, nodes[node_idx].nxt[c]);\n    }\n  }\n  void query(const std::string& str, const std::function<void(int)>& f) {\n    query(str, f, 0, 0);\n  }\n  int size() const {\n    return nodes[0].exist;\n  }\n  int node_size() const {\n    return nodes.size();\n  }\n  const Node& operator [](int k) const {\n    return nodes[k];\n  }\n};\n\ntemplate<int char_size, int margin>\nstruct Aho_Corasick : Trie<char_size, margin> {\n  using TRIE = Trie<char_size, margin>;\n  static const int FAIL = char_size;\n  std::vector<int> correct;\n\n  Aho_Corasick() : TRIE(){}\n\n  void build(bool heavy = true) {\n    correct.resize(TRIE::nodes.size());\n    for(int i = 0; i < TRIE::nodes.size(); ++i) {\n      correct[i] = TRIE::nodes[i].accept.size();\n    }\n\n    std::queue<int> que;\n    for(int i = 0; i <= char_size; ++i) {\n      if(~TRIE::nodes[0].nxt[i]) {\n\tTRIE::nodes[TRIE::nodes[0].nxt[i]].nxt[FAIL] = 0;\n\tque.emplace(TRIE::nodes[0].nxt[i]);\n      } else {\n\tTRIE::nodes[0].nxt[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      TrieNode<char_size>& now = TRIE::nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < char_size; ++i) {\n\tif(now.nxt[i] == -1) continue;\n\tint fail = now.nxt[FAIL];\n\twhile(TRIE::nodes[fail].nxt[i] == -1) fail = TRIE::nodes[fail].nxt[FAIL];\n\tTRIE::nodes[now.nxt[i]].nxt[FAIL] = TRIE::nodes[fail].nxt[i];\n\tif(heavy) {\n\t  auto& u = TRIE::nodes[now.nxt[i]].accept;\n\t  auto& v = TRIE::nodes[TRIE::nodes[fail].nxt[i]].accept;\n\t  std::vector<int> accept;\n\t  set_union(begin(u), end(u), begin(v), end(v), back_inserter(accept));\n\t  u = accept;\n\t}\n\tque.emplace(now.nxt[i]);\n      }\n    }\n  }\n  int match(const std::string& str, std::vector<int>& result, int now = 0) {\n    result.assign(TRIE::size(), 0);\n    int cnt = 0;\n    for(auto& c : str) {\n      while(TRIE::nodes[now].nxt[c-margin] == -1) now = TRIE::nodes[now].nxt[FAIL];\n      now = TRIE::nodes[now].nxt[c-margin];\n      cnt += correct[now];\n      for(auto& v : TRIE::nodes[now].accept) ++result[v];\n    }\n    return cnt;\n  }\n  int move(const char& c, int& now) {\n    int cnt = 0;\n      while(TRIE::nodes[now].nxt[c-margin] == -1) now = TRIE::nodes[now].nxt[FAIL];\n      now = TRIE::nodes[now].nxt[c-margin];\n      cnt += correct[now];\n      return cnt;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  Aho_Corasick<26, 'a'> aho;\n  vector<string> s(N);\n  rep(i, N) {\n    cin >> s[i];\n    aho.add(s[i]);\n  }\n  aho.build();\n  string t;\n  cin >> t;\n  int L = t.size();\n  vint dp(L+1);\n  dp[0] = 1;\n  int now = aho.root;\n  rep(i, L) {\n    aho.move(t[i], now);\n    //cout<<now<<endl;\n    //cout << \"T[0:\"<<i<<\"] \"<<t.substr(0, i+1) << endl;\n    for(int j : aho[now].accept) {\n      //cout << j << \" \" << s[j] << endl;\n      dp[i+1] += dp[i-s[j].size()+1];\n      dp[i+1] %= mod;\n    }\n  }\n  cout << dp[L] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct trie{\n\tint to[26];\n\tint val;\n\ttrie(){\n\t\tval=0;\n\t}\n};\n\nint size=1;\ntrie t[1<<19];\n\nvector<int> make(const string& str){\n\tint n=str.size();\n\tvector<int> ret(n+1);\n\tret[0]=-1;\n\tint j=-1;\n\tfor(int i=0;i<n;i++){\n\t\twhile(j>=0 && str[i]!=str[j]){\n\t\t\tj=ret[j];\n\t\t}\n\t\tret[i+1]=++j;\n\t}\n\treturn ret;\n}\n\nint now=0;\nvector<int> ret[201];\nint moveto[201];\nint koko[201];\n\nvoid kmp(const string& str,const string& word){\n\tvector<int> table=make(word);\n\tint m=0,i=0,n=str.size();\n\twhile(m+i<n){\n\t\tif(word[i]==str[m+i]){\n\t\t\tif(++i==(int)(word.size())){\n\t\t\t\tret[now].push_back(m);\n\t\t\t\tm=m+i-table[i];\n\t\t\t\ti=table[i];\n\t\t\t}\n\t\t}else{\n\t\t\tm=m+i-table[i];\n\t\t\tif(i>0)i=table[i];\n\t\t}\n\t}\n}\n\nvoid pushTrie(string str){\n\tint node=0;\n\tfor(int i=0;i<(int)str.size();i++){\n\t\tint b=(str[i]-'a');\n\t\tif(t[node].to[b]==0){\n\t\t\tt[node].to[b]=size++;\n\t\t}\n\t\tnode=t[node].to[b];\n\t}\n\tt[node].val++;\n}\n\nstring str;\nint n;\nll dp[100001];\n\nvoid sendValue(int f,ll val){\n\tint node=0;\n\tfor(int i=0;i<=1000;i++){\n\t\tif(i+f>=n)return;\n\t\tint b=(str[i+f]-'a');\n\t\tif(t[node].to[b]==0)return;\n\t\tnode=t[node].to[b];\n\t\tif(t[node].val>0){\n\t\t\tdp[i+f+1]+=val;\n\t\t\tif(dp[i+f+1]>=MOD)dp[i+f+1]%=MOD;\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nstring s[100001];\nint als=0;\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> s[i];\n\t}\n\tcin >> str;\n\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i].size()<=1000){\n\t\t\tpushTrie(s[i]);\n\t\t}else{\n\t\t\tkmp(str,s[i]);\n\t\t\tmoveto[now]=s[i].size();\n\t\t\tnow++;\n\t\t}\n\t}\n\tn=str.size();\n\tdp[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tsendValue(i,dp[i]);\n\t\tfor(int j=0;j<now;j++){\n\t\t\tint k=koko[j];\n\t\t\tif(k<ret[j].size() && ret[j][k]==i){\n\t\t\t\tdp[i+moveto[j]]+=dp[i];\n\t\t\t\tif(dp[i+moveto[j]]>=MOD){\n\t\t\t\t\tdp[i+moveto[j]]%=MOD;\n\t\t\t\t}\n\t\t\t\tkoko[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\n/* Aho Corasick */\n   \n\ntemplate <int X /*文字の種類*/ >\nclass AhoCorasick{\npublic:\n  struct Node{\n    char c;          //頂点の文字\n    int pre;         //親の頂点番号\n    int val;         //重み\n    int exist;       //単語が存在するか\n    int dep;         //ノードの深さ\n    int failEdge;    //パターンマッチに失敗した時に戻るノード\n    vector<int> bto; //to[i] != -1?  (to[i]):(posからtoへのパターンマッチに失敗した時に戻るノード)\n    vector<int> to;  //次の頂点番号\n    Node(){};\n    Node(char c,int pre,int val = 0,int exist = 0):\n      c(c),pre(pre),val(val),exist(exist), to(X,-1){};\n  };\n  \n  vector<Node> v;          //ノード\n  function<int(char)> toI; //文字から数字に変換する関数\n  int ok;\n  \n  AhoCorasick(function<int(char)> toI=[](char ch){return ch-'A';} ,char c = '$'/*根に用いる文字*/)\n    :toI(toI),ok(false){v.push_back(Node(c, -1, 0/*!!!!!*/));}\n\n  int size(){return v.size();}\n  Node operator [](int i)const {return v[i];}\n  \n  inline void check(int pos){assert(0 <= pos && pos<size());}\n  inline int go(int pos,char c, int flag = 0){check(pos);return flag == 0? v[pos].to[toI(c)]:v[pos].bto[toI(c)];}\n  inline int go(const string &s,int pos = 0){\n    for(char c:s){\n      pos = go(pos,c);\n      if(pos == -1) return -1;\n    }\n    return pos;\n  }\n  \n  inline int back(int pos){check(pos);return v[pos].pre;}\n  inline int getVal(int pos){check(pos);return v[pos].val;}\n  inline int exist(int pos){check(pos);return v[pos].exist;}\n  inline int failEdge(int pos){check(pos);assert(ok);return v[pos].failEdge;}\n  inline int failEdge(int pos,char to){check(pos);assert(ok);return v[pos].bto[toI(to)];}\n  inline int depth(int pos){check(pos);assert(ok);return v[pos].dep;}\n  \n  inline void addWord(const string &s,int val = 1){\n    ok = false;\n    int pos = 0, dep = 0;\n    for(char c:s){\n      v[pos].dep = dep++;\n      if(go(pos,c) != -1){pos = go(pos,c);continue;}\n      v.push_back(Node(c,pos));\n      pos = v[pos].to[toI(c)] = v.size()-1;\n    }\n    v[pos].dep = dep;\n    v[pos].exist = 1;\n    v[pos].val = max(v[pos].val, val);  //min,max,+ 臨機応変に変えて\n  }\n\n  void build(){\n    ok = 1;\n    buildBackEdge();\n    nextMatch.resize(size());\n    for(int i=1;i<size();i++) nextMatch[i] = failEdge(i);\n    nextMatch[0] = -1;\n  }\n  \n  vector<int> nextMatch; //to[i] := ノードiを含めないノードiからみて最も単語長が長くなるノード\n  //posから見て単語長が最も長くなるようなノードを返す。(pos自体が単語の場合はposを返す)\n  int suffixMatch(int pos){\n    if(pos == -1) return -1;\n    if(exist(pos)) return pos;\n    return nextMatch[pos] = suffixMatch(nextMatch[pos]);\n  }\n    \n  //res[i]にはs[i]からmatchする単語の長さが入っている。\n  vector<vector<int> > matchedIdx(const string &s){\n    assert(exist(0) == 0); //空文字列が単語として存在する場合、たぶん壊れるので直す必要がある。\n    assert(ok);\n    int n = s.size();\n    vector<vector<int> > res(n);\n    \n    for(int i=0, pos=0;i<n;i++){\n      char ch = s[i];\n      pos = go(pos, ch, true);\n      int p = suffixMatch(pos);\n      while(p != -1 && exist(p)){\n\tres[ i - depth(p) + 1].push_back(depth(p));\n\tp = suffixMatch(nextMatch[p]);\n      }\n    }\n    return res;\n  }\n  \nprivate:\n  void buildBackEdge(){\n    const int root = 0;\n    queue<int> Q;\n    Q.push(root);\n    v[root].failEdge = root;\n    for(int i=0;i<size();i++) v[i].bto = v[i].to;\n    for(int i=0;i<X;i++) if(v[root].bto[i] == -1) v[root].bto[i] = root;\n    \n    while(!Q.empty()){\n      int pos = Q.front(); Q.pop();\n      \n      for(int i=0;i<X;i++){\n\tint to = v[pos].to[i];\n\tif(to == -1) continue;\n\tQ.push(to);\n\tv[to].failEdge = (pos == root)? root:v[ v[pos].failEdge ].bto[i];\n\tfor(int i=0;i<X;i++) if(v[to].bto[i] == -1) v[to].bto[i] = v[ v[to].failEdge ].bto[i];\n      }\n    }\n  }\n};\n\n\nvoid check(){\n  AhoCorasick <26> aho([](char ch){return ch - 'a';});\n  aho.addWord(\"abcde\");\n  aho.addWord(\"bc\");\n  aho.addWord(\"bab\");\n  aho.addWord(\"d\");\n  aho.addWord(\"ab\");\n  aho.build();\n  pr(aho.ok);\n  for(int i=0;i<aho.size();i++){\n    pr(i, aho[i].c, aho[i].failEdge);\n  }\n\n  string s = \"abcdefgabab\";\n  auto Idx = aho.matchedIdx(s);\n  for(int i=0;i<(int)s.size();i++) pr(i, s[i], Idx[i]);\n  \n}\n\nvoid AOJ_2863(){\n  int n;\n  cin>>n;\n  AhoCorasick <26> aho([](char ch){return ch - 'a';});\n  for(int i=0;i<n;i++){\n    string s;\n    cin>>s;\n    aho.addWord(s);\n  }\n  aho.build();\n  string t;\n  cin>>t;  \n  auto Idx = aho.matchedIdx(t);\n  int len = t.size();\n  vector<int> dp(len+1, 0);\n  dp[0] = 1;\n  const int mod = 1e9 + 7;\n  for(int i=0;i<len;i++){\n    for(int l:Idx[i]){\n      dp[i+l] = (dp[i+l] + dp[i])%mod;\n    }\n  }\n  int ans = dp[len];\n  cout<<ans<<endl;\n}\n\n\nvoid AOJ_2212(){\n while(1){\n    int h,w;\n    cin>>h>>w;\n    if(h == 0 && w == 0) return;\n    vector<string> mp(h);\n    for(int i=0;i<h;i++) cin>>mp[i];\n\n    auto func = [](char ch){\n      if(ch == 'U') return 0;\n      if(ch == 'R') return 1;\n      if(ch == 'D') return 2;\n      if(ch == 'L') return 3;\n      return -1;\n    };\n  \n    AhoCorasick <4> aho(func);\n  \n    int m;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      string s;\n      cin>>s;\n      aho.addWord(s);\n    }\n    aho.build();\n    int sy, sx;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) if(mp[i][j] == 'S') sy = i, sx = j;\n\n    auto bfs = [&]()->int{\n      typedef tuple<int,int,int,string> T;\n      queue<T> Q;\n      Q.push(T(sy, sx, 0, \"\"));\n      vector<vector<vector<int> > > D(h, vector<vector<int> > (w, vector<int>(aho.size(),-1)));\n      D[sy][sx][0] = 0;\n    \n      string str = \"URDL\";\n      int dy[] = {-1, 0, 1, 0};\n      int dx[] = {0, 1, 0, -1};\n      while(!Q.empty()){\n\tint y, x, pos;\n\tstring his;\n\ttie(y, x, pos, his) = Q.front(); Q.pop();\n\tint cost = D[y][x][pos];\n\tif(aho.suffixMatch(pos) != -1) continue;\n\tif(mp[y][x] == 'G') return cost;\n\n\n\tfor(int i=0;i<4;i++){\n\t  int ny = y + dy[i];\n\t  int nx = x + dx[i];\n\t  char dir = str[i];\n\t  if(ny < 0 || nx < 0 || ny >= h || nx >= w || mp[ny][nx] == '#') continue;\n\t  int to = aho.go(pos, dir);\n\t  if(to == -1) to = aho.failEdge(pos, dir);\n\t  if(D[ny][nx][to] != -1) continue;\n\t  D[ny][nx][to] = cost+1;\n\t  Q.push(T(ny, nx, to, his + dir));\n\t}\n      }\n      return -1;\n    };\n\n    int ans = bfs();\n    cout<<ans<<endl;\n  }\n}\n\n\nsigned main(){\n  //check();\n  //AOJ_2212();\n  AOJ_2863();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M & mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\nstruct Aho{\n    struct node{\n        ll idx;\n        char c;\n        map<char,node*> next;\n        node* parent;\n        node* back;\n        bool exist;\n        vector<ll> dp;\n        \n        //bool used;\n        \n        node():next(),dp(){\n            idx=-1;\n            c=-1;\n            parent=NULL;\n            back=NULL;\n            exist=false;\n        }\n    };\n    \n    node root;\n    ll size;\n    \n    ll add(const string &s){\n        node* where=&root;\n        bool New=false;\n        for(int i=0;i<s.size();i++){\n            if(where->next.find(s[i])==where->next.end()){\n                New=true;\n                node* P=(node*)calloc(1,sizeof(node));\n                *P=node();\n                where->next[s[i]]=P;\n                P->parent=where;\n                where=P;\n                //where->idx=size++;\n                where->c=s[i];\n            }\n            else{\n                where=where->next[s[i]];\n                New=false;\n            }\n        }\n        where->idx=size++;\n        where->dp.push_back(where->idx);\n        where->exist=true;\n        return where->idx;\n    }\n    \n    void build(){\n        queue<node*> Q;\n        for(auto i=root.next.begin();i!=root.next.end();++i){\n            Q.push(i->second);\n        }\n        while(!Q.empty()){\n            node* where=Q.front();\n            Q.pop();\n            if(where->parent==&root){\n                where->back=&root;\n            }\n            else{\n                node* P=where->parent->back;\n                while(1){\n                    if(P==&root && P->next.find(where->c)==P->next.end()){where->back=&root; break;}\n                    if(P->next.find(where->c)!=P->next.end()){\n                        P=P->next.find(where->c)->second;\n                        where->back=P;\n                        for(auto &i:P->dp){where->dp.push_back(i);}\n                        break;\n                    }\n                    P=P->back;\n                }\n            }\n            for(auto i=where->next.begin();i!=where->next.end();++i){\n                Q.push(i->second);\n            }\n        }\n    }\n    \n    /*\n    vector<ll> search(const string &s){\n        vector<ll> used;\n        vector<node*> B;\n        node* where=&root;\n        for(int i=0;i<s.size();i++){\n            while(where!=&root && where->next.find(s[i])==where->next.end()){\n                where=where->back;\n            }\n            if(where->next.find(s[i])==where->next.end()){continue;}\n            where=where->next.find(s[i])->second;\n            if(!where->used){\n                queue<node*> q;\n                q.push(where);\n                while(!q.empty()){\n                    node* W=q.front();\n                    q.pop();\n                    W->used=true;\n                    used.push_back(W->idx);\n                    B.push_back(W);\n                    if(!W->parent->used){\n                        q.push(W->parent);\n                    }\n                    if(!W->back->used){\n                        q.push(W->back);\n                    }\n                }\n            }\n        }\n        sort(used.begin(),used.end());\n        for(auto &i:B){i->used=false;}\n        return used;\n    }\n     */\n    \n    node* move(node* where,const char &c){\n        while(where!=&root && where->next.find(c)==where->next.end()){\n            where=where->back;\n        }\n        if(where->next.find(c)!=where->next.end()){where=where->next.find(c)->second;}\n        return where;\n    }\n    \n    Aho():root(),size(0){root.back=&root; /*root.used=true;*/}\n    \n    node* Root(){return &root;}\n};\n\n\ntypedef Mod_Int<1000000007> Int;\n\n\nint main(){\n    ll n;\n    cin>>n;\n    Aho A;\n    vector<ll> str(n);\n    for(int i=0;i<n;i++){\n        string s;\n        cin>>s;\n        ll a=A.add(s);\n        str[i]=s.size();\n    }\n    string s;\n    cin>>s;\n    vector<Int> dp(s.size()+1,0);\n    dp[0]=1;\n    A.build();\n    auto I=A.Root();\n    for(int i=0;i<s.size();i++){\n        I=A.move(I,s[i]);\n        for(ll &t:I->dp){\n            dp[i+1]+=dp[i+1-str[t]];\n        }\n    }\n    cout<<dp[s.size()].a<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <cstring>\n#include <queue>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007;\nconst int SIZE = 26;\n\nstruct PMA {\n  PMA* node[SIZE + 1];\n  vector<int> matched;\n  PMA() { memset(node, 0, sizeof(node)); }\n\n  vector<int> unite(const vector<int> &a, const vector<int> &b) {\n    vector<int> ret;\n    set_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(ret));\n    return ret;\n  }\n\n  void build(vector<string> pattern) {\n    PMA* root = this;\n    root -> node[SIZE] = root;\n    for(size_t i=0; i<pattern.size(); i++) {\n      PMA* now = root;\n      for(size_t j=0; j<pattern[i].size(); j++) {\n        int c = pattern[i][j] - 'a';\n        if(!now -> node[c]) {\n          now -> node[c] = new PMA;\n        }\n        now = now -> node[c];\n      }\n      now -> matched.push_back(i);\n    }\n\n    queue<PMA*> que;\n    for(int i=0; i<SIZE; i++) {\n      if(!root -> node[i]) root -> node[i] = root;\n      else {\n        root -> node[i] -> node[SIZE] = root;\n        que.push(root -> node[i]);\n      }\n    }\n\n    while(que.size()) {\n      PMA* now = que.front(); que.pop();\n      for(int i=0; i<SIZE; i++) {\n        if(now -> node[i]) {\n          PMA* nxt = now -> node[SIZE];\n          while(!nxt -> node[i]) nxt = nxt -> node[SIZE];\n\n          now->node[i]->node[SIZE] = nxt->node[i];\n          now->node[i]->matched=unite(now->node[i]->matched, nxt->node[i]->matched);\n          que.push(now->node[i]);\n        }\n      }\n    }\n  }\n\n  ll solve(const string s, vector<string> pattern) {\n    PMA* pma = this;\n\n    int N = s.length();\n    vector<ll> dp(N+1);\n    dp[0] = 1;\n    for(size_t i=0; i<s.length(); i++) {\n      int c = s[i] - 'a';\n      while(!pma -> node[c]) pma = pma -> node[SIZE];\n\n      pma = pma -> node[c];\n      for(size_t j=0; j<pma->matched.size(); j++) {\n        int r = i+1, l=r-pattern[ pma->matched[j] ].length();\n        (dp[r] += dp[l]) %= MOD;\n      }\n    }\n\n    return dp[N];\n  }\n};\n\nint main() {\n  int N; cin >> N;\n  vector<string> pats(N);\n  for(int i=0; i<N; i++) {\n    cin >> pats[i];\n  }\n\n  string text; cin >> text;\n  PMA pma;\n  pma.build(pats);\n\n  cout << pma.solve(text, pats) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Node{\n\tint table[26];\n\tbool finish_FLG;\n};\n\nNode nodes[200001];\n\nint node_index = 1,N,length;\nll dp[100001];\nchar buf[100001];\n\nll recursive(int start_pos){\n\n\tif(dp[start_pos] != -1)return dp[start_pos];\n\n\tstack<int> S;\n\n\tint tmp_ch,tmp_node_index = 0,ch_loc = start_pos,depth = 0;\n\n\twhile(true){\n\t\ttmp_ch = buf[ch_loc]-'a';\n\n\t\tif(nodes[tmp_node_index].table[tmp_ch] == -1)break;\n\n\t\ttmp_node_index = nodes[tmp_node_index].table[tmp_ch];\n\t\tdepth++;\n\n\t\tif(nodes[tmp_node_index].finish_FLG){\n\t\t\tS.push(start_pos+depth);\n\t\t}\n\n\t\tch_loc++;\n\n\t\tif(buf[ch_loc] == '\\0')break;\n\t}\n\n\tdp[start_pos] = 0;\n\n\twhile(!S.empty()){\n\t\tdp[start_pos] += recursive(S.top());\n\t\tdp[start_pos] %= MOD;\n\t\tS.pop();\n\t}\n\n\tdp[start_pos] %= MOD;\n\n\treturn dp[start_pos];\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 200000; i++){\n\t\tfor(int k = 0; k < 26; k++)nodes[i].table[k] = -1;\n\t\tnodes[i].finish_FLG = false;\n\t}\n\n\tscanf(\"%d\",&N);\n\n\tint tmp_ch,tmp_node_index,ch_loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s\",buf);\n\n\t\ttmp_node_index = 0;\n\t\tch_loc = 0;\n\n\t\twhile(true){\n\t\t\ttmp_ch = buf[ch_loc]-'a';\n\n\t\t\tif(nodes[tmp_node_index].table[tmp_ch] == -1){\n\t\t\t\tnodes[tmp_node_index].table[tmp_ch] = node_index;\n\t\t\t\ttmp_node_index = node_index;\n\t\t\t\tnode_index++;\n\t\t\t}else{\n\t\t\t\ttmp_node_index = nodes[tmp_node_index].table[tmp_ch];\n\t\t\t}\n\t\t\tch_loc++;\n\t\t\tif(buf[ch_loc] == '\\0'){\n\t\t\t\tnodes[tmp_node_index].finish_FLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\tfor(int i = 0; i < length; i++)dp[i] = -1;\n\tdp[length] = 1;\n\n\tprintf(\"%lld\\n\",recursive(0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//ll inv(ll a, ll p) {\n//\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n//}\n//modint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvoid Z_algorithm(const string &s, vector<int> &a) {\n\tint sz = s.size();\n\ta.resize(sz);\n\ta[0] = sz;\n\tint i = 1, j = 0;\n\twhile (i < sz) {\n\t\twhile (i + j < sz&&s[j] == s[i + j])++j;\n\t\ta[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < sz&&k + a[k] < j)a[i + k] = a[k], ++k;\n\t\ti += k; j -= k;\n\t}\n}\n\nstruct Node {\n\tNode *ch[26];\n\tint las;\n\tNode() {\n\t\trep(i, 26)ch[i] = NULL; las = 0;\n\t}\n};\n\nvoid add(Node *nd, string &s) {\n\trep(i, s.size()) {\n\t\tint t = s[i] - 'a';\n\t\tif (nd->ch[t] == NULL)nd->ch[t] = new Node();\n\t\tnd = nd -> ch[t];\n\t}\n\tnd->las = 1;\n}\n\nconst int b = 500;\nmodint dp[1 << 17];\nvector<int> r[1 << 17];\nvoid solve() {\n\tint n; cin >> n;\n\tvector<string> v(n);\n\tNode* root = new Node();\n\tvector<string> ad;\n\trep(i, n) {\n\t\tcin >> v[i];\n\t\tif (v[i].size() <= b) {\n\t\t\tadd(root, v[i]);\n\t\t}\n\t\telse {\n\t\t\tad.push_back(v[i]);\n\t\t}\n\t}\n\tstring s; cin >> s;\n\tn = s.size();\n\trep(i, ad.size()) {\n\t\tstring t = ad[i] + s;\n\t\tvector<int> ra;\n\t\tZ_algorithm(t, ra);\n\t\trep(j, n) {\n\t\t\tif (ra[j + ad[i].size()] >= ad[i].size()) {\n\t\t\t\tr[j].push_back(ad[i].size());\n\t\t\t}\n\t\t}\n\t}\n\tdp[0] = 1;\n\trep(i, n) {\n\t\tfor (int len : r[i]) {\n\t\t\tdp[i + len] += dp[i];\n\t\t}\n\t\tNode *cur = root;\n\t\trep(j, b) {\n\t\t\tif (i + j >= n)break;\n\t\t\tint nex = s[i + j] - 'a';\n\t\t\tif (cur->ch[nex] == NULL)break;\n\t\t\tcur = cur->ch[nex];\n\t\t\tif (cur->las)dp[i + j + 1] += dp[i];\n\t\t}\n\t}\n\tcout << dp[n] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,unsigned long long>P;\n\nint trie[200009][27],n,c,dp[100009];\nstring s;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  typedef unsigned long long ull;\n  string S;\n  ull B;\n  int len;\n  vector<ull> hash,p;\n  RollingHash(){}\n  RollingHash(string S_,ull B_=1000000007LL):\n    S(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\nsigned main(){\n  vector<P>v;\n  r(i,200009)r(j,27)trie[i][j]=-1;\n  cin>>n;\n  string t[n];\n  r(i,n){\n    cin>>s;\n    if(s.size()<=500){\n        int idx=0;\n        r(j,s.size()){\n            int p=s[j]-'a';\n            if(trie[idx][p]==-1) trie[idx][p]=++c;\n            idx=trie[idx][p];\n        }\n        trie[idx][26]=1;\n    }\n    else{\n        RollingHash R(s);\n        v.push_back(P(s.size(),R.find(0,s.size())));\n    }\n  }\n  cin>>s;\n  RollingHash R(s);\n  dp[0]=1;\n  r(i,s.size()){\n    int idx=0,sum=0,j=i;\n    while(trie[idx][s[j]-'a']!=-1 && j!=s.size()){\n      idx=trie[idx][s[j]-'a'];\n      if(trie[idx][26]==1)dp[j+1]+=dp[i];\n      j++;\n      dp[j]%=1000000007;\n    }\n    r(j,v.size()){\n        int len=v[j].first;\n        if(len+i>s.size())continue;\n        if(R.find(i,i+len)==v[j].second){\n            dp[i+len]+=dp[i];\n            dp[i+len]%=1000000007;\n        }\n    }\n  }\n  cout<<dp[s.size()]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N = 2e5 + 5, M = 26;\nconst int Mod = 1e9 + 7;\nint Trie[N][M], d[N], val[N], dp[N], f[N], q[N];\nint n, len, root, tot;\nchar s[N];\nstruct E{int next, to;} edge[N << 1];\nint head[N], nedge;\ninline int addline(int x, int y){\n\tedge[++ nedge].next = head[x];\n\tedge[nedge].to = y;\n\thead[x] = nedge;\n\n}\nint Dfs(int u, int Last){\n\tf[u] = Last;\n\tint tmp = Last;\n\tif (val[u]) tmp = u;\n\tfor (int i = head[u]; i; i = edge[i].next)\n\t\tDfs(edge[i].to, tmp);\n}\nint Insert(int &u, int dep){\n\tif (!u) u = ++ tot;\n\t//printf(\"%d %d\\n\",dep,u);\n\td[u] = dep;\n\t//if (dep > 10) return 0;\n\tif (dep - 1 == len){\n\t\tval[u] ++;\n\t\treturn 0;\n\t}\n\tInsert(Trie[u][s[dep] - 97], dep + 1);\n}\nint Getans(int u, int l){\n\tif (u == root) return 0;\n\t//printf(\"%d %d %d %d\\n\",u, d[u] - 1, val[u], l);\n\tdp[l] = (dp[l] + 1ll * val[u] * dp[l - d[u] + 1] % Mod) % Mod;\n//\tprintf(\"Res:%d %d %d %d\\n\",dp[1], dp[2], dp[3], dp[4]);\n\tGetans(f[u], l);\n}\nint Query(int u, int l){\n\t//printf(\"Query:%d %d\\n\",u,l);\n\tGetans(u, l);\n\tif (l == len) return 0;\n\tQuery(Trie[u][s[l + 1] - 97], l + 1);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%s\", s + 1);\n\t\tlen = strlen(s + 1);\n\t\tInsert(root, 1);\n\t}\n\tint l = 1, r = 0;\n\tfor (int i = 0; i < M; i++)\n\t\tif (Trie[root][i]){\n\t\t\tf[Trie[root][i]] = root;\n\t\t\tq[++r] = Trie[root][i];\n\t\t}\n\t\telse\n\t\t\tTrie[root][i] = root;\n\twhile (l <= r){\n\t\tint u = q[l];\n\t\tl ++;\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tif (Trie[u][i]){\n\t\t\t\tf[Trie[u][i]] = Trie[f[u]][i];\n\t\t\t\tq[++ r] = Trie[u][i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tTrie[u][i] = Trie[f[u]][i];\n\t}\n\t//for (int i = 1; i <= tot; i++)\n\t//\tprintf(\"%d \",f[i]);\n\t//printf(\"\\n\");\n\t//return 0;\n\t//Dfs(root, root);\n\tfor (int i = 2; i <= tot; i++)\n\t\taddline(f[i], i);\n\tDfs(1, 1);\n\tscanf(\"%s\", s + 1);\n\tlen = strlen(s + 1);\n\tdp[0] = 1;\n\tQuery(root, 0);\n\tprintf(\"%d\\n\", dp[len]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass RollingHash{\npublic:\n  typedef long long ll;\n  ll B, mod;  //B: ハッシュ基数\n  int n;\n  string s;\n  vector<ll> hash;\n  vector<ll> k;\n\n  RollingHash():n(-1){};\n  RollingHash(string s,ll B = 1777771,ll mod = 1e9 + 7):\n    B(B),mod(mod),n(s.size()),s(s),hash(n+1),k(n+1)\n  {\n    for(int i=0;i<n;i++) hash[i+1] = (hash[i] * B % mod + s[i]) % mod;\n    k[0] = 1;\n    for(int i=1;i<=n;i++) k[i] = (k[i-1] * B) % mod;\n  }\n\n  ll get(int l,int r){ //[l, r)\n    assert(0<=l && r<=n && l<=r);\n    return (mod + hash[r] - hash[l] * k[r-l] % mod) % mod;\n  }\n  \n  //hash[a]とB.hash[b]からみて何文字一致してるか。\n  int count(int a, RollingHash &B, int b){\n    int L = 0, R = min( n - a, B.n - b ) + 1;\n    while( L + 1 < R ){\n      int M = ( L + R ) / 2;\n      get( a, a + M ) != B.get( b, b + M ) ? R = M : L = M;\n    }\n    return L;\n  }\n};\n\nsigned main(){\n  int n,mod=1e9+7;\n  string s,t;\n  cin>>n;\n  map<int,vector<int> > mp;\n  vector<int> v[1000],o;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    RollingHash tp=RollingHash(s);\n    mp[s.size()].push_back(tp.get(0,0+s.size()));    \n  }\n  \n  int m=0;\n  for(auto p : mp){\n    o.push_back(p.first);\n    for(auto pp : p.second)v[m].push_back(pp);\n    sort(v[m].begin(),v[m].end());\n    m++;\n  }\n  cin>>t;\n  RollingHash rh=RollingHash(t);\n  int dp[100001]={};\n  dp[0]=1;\n  \n  for(int i=0;i<t.size();i++){\n    for(int j=0;j<m;j++){\n      if(i+o[j]>t.size())break;\n      int hs=rh.get(i,i+o[j]);\n      auto I=lower_bound(v[j].begin(),v[j].end(),hs);\n      if(I==v[j].end()||*I!=hs)continue;\n      (dp[i+o[j]]+=dp[i])%=mod;\n    }\n  }\n  cout<<dp[t.size()]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long;\n\ntemplate <typename T> T inf;\ntemplate <> constexpr int inf<int> = 1e9;\ntemplate <> constexpr ll inf<ll> = 1e18;\n\nconstexpr int M = 1e9 + 7;\n\n\nclass aho_corasick {\n    struct PMA {\n        std::weak_ptr<PMA> fail;\n        std::vector<std::shared_ptr<PMA>> next;\n        std::vector<int> accept;\n\n        PMA()\n            : fail(), next(alphabets)\n        {}\n    };\n\npublic:\n    aho_corasick(std::vector<std::string> const& ts)\n        : K(ts.size()), root(std::make_shared<PMA>())\n    {\n        root->fail = root;\n        for(int i = 0; i < K; ++i) {\n            PMA* t = root.get();\n            for(auto cc : ts[i]) {\n                int c = cc - alphabet_base;\n                if(!t->next[c]) {\n                    t->next[c] = std::make_shared<PMA>();\n                }\n                t = t->next[c].get();\n            }\n            t->accept.push_back(i);\n        }\n\n        std::queue<std::shared_ptr<PMA>> que;\n        for(int c = 0; c < alphabets; ++c) {\n            if(root->next[c]) {\n                root->next[c]->fail = root;\n                que.push(root->next[c]);\n            }\n        }\n        while(!que.empty()) {\n            auto t = que.front();\n            que.pop();\n            for(int c = 0; c < alphabets; ++c) {\n                if(t->next[c]) {\n                    que.push(t->next[c]);\n                    // assert(!t->fail.expired());\n                    auto r = t->fail.lock();\n                    while(!r->next[c] && r != root) {\n                        r = r->fail.lock();\n                    }\n                    auto& nxt = r->next[c];\n                    if(!nxt) { // root\n                        nxt = root;\n                    }\n                    t->next[c]->fail = nxt;\n                    for(auto ac : nxt->accept) {\n                        t->next[c]->accept.push_back(ac);\n                    }\n                }\n            }\n        }\n    }\n\n    std::vector<std::vector<int>> match(std::string const& s, std::vector<std::string> const& ts, ll& cnt) {\n        std::vector<std::vector<int>> res(K);\n        std::vector<ll> dp(s.size() + 1);\n        dp[0] = 1;\n        PMA* now = root.get();\n        for(int i = 0; i < (int)s.size(); ++i) {\n            int c = s[i] - alphabet_base;\n            while(!now->next[c] && now != root.get()) {\n                now = now->fail.lock().get();\n            }\n            now = now->next[c].get();\n            if(now == nullptr) {\n                now = root.get();\n            }\n            for(auto k : now->accept) {\n                //res[k].push_back(i);\n                (dp[i + 1] += dp[i - ts[k].size() + 1]) %= M;\n            }\n        }\n        cnt = dp[s.size()];\n        return res;\n    }\n\nprivate:\n    static int const alphabets = 26;      // a-z\n    static int const alphabet_base = 'a'; // a\n    int const K;\n    std::shared_ptr<PMA> root;\n};\n\n\nusing namespace std;\nint main() {\n    int N;\n    cin >> N;\n    string t;\n    vector<string> s(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> s[i];\n    }\n    cin >> t;\n\n    aho_corasick aho(s);\n    ll res = 0;\n    auto match_pos = aho.match(t, s, res);\n    cout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n\ntemplate <class Container>\nstd::vector<int> zalgo(const Container& dat) {\n    int n = dat.size();\n\n    std::vector<int> ret(n);\n    ret[0] = n;\n\n    int i = 1, len = 0;\n    while (i < n) {\n        while (i + len < n && dat[len] == dat[i + len]) {\n            ++len;\n        }\n        ret[i] = len;\n\n        if (len == 0) {\n            ++i;\n            continue;\n        }\n\n        int nlen = 1;\n        while (i + nlen < n && nlen + ret[nlen] < len) {\n            ret[i + nlen] = ret[nlen];\n            ++nlen;\n        }\n\n        i += nlen;\n        len -= nlen;\n    }\n\n    return ret;\n}\n\nconstexpr int MOD = 1000000007;\nconstexpr int S = 100;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<std::set<std::string>> ses(S);\n    std::vector<std::string> ss;\n\n    while (n--) {\n        std::string s;\n        std::cin >> s;\n\n        if ((int)s.length() < S) {\n            ses[s.length()].insert(s);\n        } else {\n            ss.push_back(s);\n        }\n    }\n\n    std::string t;\n    std::cin >> t;\n    int m = t.length();\n\n    std::vector<std::vector<int>> to(m);\n    for (int i = 0; i < m; ++i) {\n        for (int k = 0; k < S; ++k) {\n            if (ses[k].count(t.substr(i, k))) {\n                to[i].push_back(i + k);\n            }\n        }\n    }\n\n    for (auto s : ss) {\n        int l = s.length();\n        s += t;\n        auto vs = zalgo(s);\n        for (int i = 0; i < m; ++i) {\n            if (vs[i + l] >= l) to[i].push_back(i + l);\n        }\n    }\n\n    std::vector<int> dp(m + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < m; ++i) {\n        for (auto j : to[i]) {\n            (dp[j] += dp[i]) %= MOD;\n        }\n    }\n    std::cout << dp.back() << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    mod = 10**9 + 9\n    base = 37\n    ca = ord('a')\n\n    N = int(readline())\n    SS = [readline().strip() for i in range(N)]\n    SS.sort(key = len)\n\n    T = readline().strip()\n    L = len(T)\n\n    L0 = max(max(map(len, SS)), L)\n\n    r = 1\n    pw = [1]*(L0+1)\n    for i in range(L0):\n        pw[i+1] = r = r * base % mod\n\n    SM = defaultdict(dict)\n    E = [None]*N\n    for i in range(N):\n        s = SS[i][::-1]\n        h = 0\n        p = -1\n        for j, c in enumerate(s):\n            h = (h + pw[j] * (ord(c) - ca)) % mod\n            if j+1 in SM and h in SM[j+1]:\n                p = SM[j+1][h]\n        l = len(s)\n        E[i] = (E[p] + [l]) if p != -1 else [l]\n        SM[l][h] = i\n\n    *SI, = SM.items()\n    SI.sort()\n    H = [0]*(L+1)\n    r = 0\n    for i, c in enumerate(T):\n        H[i+1] = r = (base * r + (ord(c) - ca)) % mod\n\n    MOD = 10**9 + 7\n    dp = [0]*(L+1)\n    dp[0] = 1\n    SI.append((L+10, set()))\n    it = iter(SI).__next__\n    ln, sn = it()\n    SL = []\n    for i in range(1, L+1):\n        if i == ln:\n            SL.append((ln, sn, pw[ln]))\n            ln, sn = it()\n        hi = H[i]\n        for l, hs, w in reversed(SL):\n            v = (hi - H[i-l]*w) % mod\n            if v in hs:\n                dp[i] = sum(dp[i-e] for e in E[hs[v]]) % MOD\n                break\n    write(\"%d\\n\" % dp[L])\nsolve()\n"
  }
]