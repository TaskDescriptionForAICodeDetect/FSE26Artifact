[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvector<vi> a(n, vi(n));\n\trep(i, n) rep(j, n) if(i != j) cin >> a[i][j];\n\t\n\tvector<vector<ll>> dp(n, vector<ll>(n, 1e18));\n\tvector<vector<ll>> ls(n, vector<ll>(n + 1));\n\tvector<vector<ll>> rs(n, vector<ll>(n + 1));\n\t\n\trep(i, n) rep(j, n) rs[i][j + 1] = rs[i][j] + a[i][j];\n\trep(i, n) rep(j, n) ls[i][j + 1] = ls[i][j] + a[j][i];\n\t\n\tll ans = 1e18;\n\tdp[0][0] = 0;\n\trep(j, n) rep(i, j + 1){\n\t\tvector<ll> sum(n + 1);\n\t\tfor(int k = n - 1; k > j; k--) sum[k] = sum[k + 1] + rs[k][j] - rs[k][i];\n\t\tll tmp = 0;\n\t\tfor(int k = j + 1; k < n; k++){\n\t\t\tdp[j][k] = min(dp[j][k], dp[i][j] + tmp + sum[k]);\n\t\t\ttmp += ls[k][k] - ls[k][j];\n\t\t}\t\t\n\t\tans = min(ans, dp[i][j] + tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntemplate <class T>\ninline T Min(const T &a, const T &b) {return a < b ? a : b;}\n\ntypedef long long ll;\n\nconst int N = 505;\nconst ll INF = 1e18;\n\nint n, a[N][N];\nll ans = INF, s1[N][N], s2[N][N], f[N][N];\n\nint main()\n{\n\tread(n);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++)\n\t\tif (i != j) read(a[i][j]);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j < i; j++)\n\t\ts1[i][j] = s1[i][j - 1] + a[j][i], s2[i][j] = s2[i][j - 1] + a[i][j];\n\tfor (int i = 0; i < N; i++) for (int j = 0; j < N; j++)\n\t\tf[i][j] = INF; f[1][1] = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++)\n\t{\n\t\tll cost = 0;\n\t\tfor (int k = i + 1; k <= n; k++)\n\t\t\tf[k][i] = Min(f[k][i], f[i][j] + cost + s2[k][i - 1]),\n\t\t\t\tcost += s2[k][j - 1] + s1[k][k - 1] - s1[k][i - 1];\n\t\tans = Min(ans, f[i][j] + cost);\n\t}\n\treturn std::cout << ans << std::endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\nusing namespace std;\n#define MAXN 500\n#define LL long long\n#define INF 1000000000000000000\nint n;\nLL sum[2][MAXN+5][MAXN+5],dp[MAXN+5][MAXN+5];\nLL read(){\n   \tLL x=0,F=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n   \twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x*F;\n}\nLL get_sum(int x1,int x2,int y1,int y2,int id){\n\treturn sum[id][x2][y2]-sum[id][x1-1][y2]-sum[id][x2][y1-1]+sum[id][x1-1][y1-1];\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\tif(i!=j)sum[(i>j)][i][j]=read();\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)dp[i][j]=INF;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tsum[0][i][j]+=sum[0][i-1][j]+sum[0][i][j-1]-sum[0][i-1][j-1];\n\t\t\tsum[1][i][j]+=sum[1][i-1][j]+sum[1][i][j-1]-sum[1][i-1][j-1];\n\t\t}\n\tdp[0][0]=0; \n\tfor(int i=0;i<=n;i++)\n\t\tfor(int pre=0;pre<max(1,i);pre++)\n\t\t\tfor(int nxt=i+1;nxt<=n;nxt++)\n\t\t\tdp[nxt][i]=min(dp[nxt][i],dp[i][pre]+get_sum(nxt+1,n,pre+1,i,1)+get_sum(i+1,nxt,i+1,nxt,0));\n\tLL ans=dp[n][1];\n\tfor(int i=1;i<=n;i++)ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fi first\n#define se second\n#define MK make_pair\n#define PB push_back\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int ,int> PII;\nconst int N=510;\nconst LL oo = 1ll<<60;\nLL pre[N][N],pre2[N][N], a[N][N], f[N][N];\ntemplate<class T>\nvoid upmin(T&a, T b){if ( b<a) a=b;}\n\nint n, m;\nLL Inner(int i, int j){return pre2[j][j]-pre2[i-1][j]-pre2[j][i-1]+pre2[i-1][i-1];}\nLL Outer(int i,int j, int k){return pre[k][i-1]-pre[j][i-1];}\nint main(){\n\t#ifdef che\n\tfreopen(\"input.txt\",\"rt\",stdin);\n\tfreopen(\"output.txt\",\"wt\",stdout);\n\t#endif\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; ++j) if ( i!=j){\n\t\t\tscanf(\"%lld\", a[i]+j);\n\t\t\tpre[i][j]= a[i][j];\n\t\t\tif ( i<j) pre2[i][j] = a[i][j];\n\t\t}\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; ++j) pre[i][j] += pre[i-1][j], pre2[i][j]+=pre2[i-1][j];\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=1; j<=n; ++j) pre[i][j] += pre[i][j-1], pre2[i][j]+=pre2[i][j-1];\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=i; j<=n; ++j) f[i][j] = oo;\n\t\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=i; j<=n; ++j){\n\t\t\tif ( i==1) f[i][j] = Inner(i,j);\n\t\t\tfor (int k=j+1; k<=n; ++k) upmin(f[j+1][k], f[i][j] + Inner(j+1,k)+Outer(i,j,k));\n\t\t\t#ifdef che\n\t\t\tdebug(\"f[%d][%d] = %lld\\n\", i,j,f[i][j]);\n\t\t\t#endif\n\t\t}\n\tLL ans=oo;\n\tfor (int i=1; i<=n; ++i) upmin(ans, f[i][n]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n;\nll a[505][505],sum[505][505],f[505][505],s[505][505];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(i!=j)scanf(\"%lld\",&a[i][j]);\n\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];\n\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]*(i<j);\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\tfor(int j=i;j<=n;j++)\n\t{\n\t\tif(f[i][j]>1e17)continue;\n\t\tfor(int k=j+1;k<=n;k++)\n\t\t  f[j][k]=min(f[j][k],f[i][j]+s[k][k]-s[j][k]-s[k][j]+s[j][j]+sum[n][j]-sum[n][i]-sum[k][j]+sum[k][i]);\n\t}\n\tll ans=1e18;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][n]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst int N = 505;\n\nint a[N][N];\nll fromL[N][N];\nll fromR[N][N];\nll f[N][N];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) if (i != j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) if (i != j) {\n\t\t\tif (i < j) {\n\t\t\t\tfromL[i + 1][j + 1] = a[i][j];\n\t\t\t} else {\n\t\t\t\tfromR[i + 1][j + 1] = a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tfromL[i + 1][j + 1] += fromL[i + 1][j] + fromL[i][j + 1] - fromL[i][j];\n\t\t\tfromR[i + 1][j + 1] += fromR[i + 1][j] + fromR[i][j + 1] - fromR[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tf[0][i] = fromR[i][i];\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tll cost = f[k][i];\n\t\t\t\tcost += fromR[j][j] - fromR[i][j] - fromR[j][k] + fromR[i][k];\n\t\t\t\tcost += fromL[i][j] - fromL[i][i];\n\t\t\t\tf[i][j] = max(f[i][j], cost); \n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans = min(ans, -f[i][n]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n  int a;\n  cin>>a;\n  int b;\n  cin>>b;\n  int c;\n  cin>>c;\n  int d;\n  cin>>d;\n  int e;\n  cin>>e;\n  int a+b+c+d=f;\n  int f/e=g;\n  cout<<g/2;\n1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n  0\n  q\n  w\n  e\n  r\n  t\n  y\n  u\n  i\n  o\n  p\n  a\n  s\n  d\n  f\n  g\n  h\n  j\n  k\n  l\n  z\n  x\n  c\n  v\n  b\n  n\n  m\n  `\n  -\n  =\n  [\n  ]\n  \\\n  ;\n  '\n    ,\n  .\n    /\n    7\n    8\n    9\n    6\n    5\n    4\n    1\n    2\n    3\n    0\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// D - Negative Cycle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tINF\t1e16\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<vector<long long> > a(n, vector<long long>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (i != j) cin >> a[i][j];\n\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, INF));\n\tdp[0][0] = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long> x(i), y(i);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = i + 1; k <= n; k++) x[j] += a[k - 1][j - 1];\n\t\t\tif (j > 0) x[j] += x[j - 1];\n\t\t}\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tfor (int k = j + 1; k <= i; k++) y[j] += a[j][k - 1];\n\t\t\tif (j + 1 < i - 1) y[j] += y[j + 1];\n\t\t}\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tfor (int k = 0; k <= j; k++)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + x[j] - x[k] + y[j]);\n\t}\n\n\tcout << *min_element(dp[n].begin(),dp[n].end()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define gmi(a,b) a=(a)<(b)?(a):(b)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FOF(i,a,b) for(int i=a;i< b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=550;\nconst ll INF=1e18;\nint n,x;\nll ans,a[N][N],b[N][N],f[N][N];\nll SB(int x,int y){return b[x][x]-b[x][y]-b[y][x]+b[y][y];}\nint main(){\n\tfreopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOF(i,0,n)FOF(j,0,n)if(i!=j){\n\t\tscanf(\"%d\",&x);\n\t\tj<i?a[j+1][i]=x:b[i+1][j]=x;\n\t}\n\tFOR(i,1,n)FOR(j,1,n){\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t}\n\tFOR(i,1,n)FOR(j,0,i) f[i][j]=INF;\n\tFOR(i,1,n)FOR(j,0,i)FOR(k,0,j)\n\t\tgmi(f[i][j],f[j][k]+a[k][i-1]-a[k][j-1]+SB(i-1,j));\n\t//FOR(i,1,n)FOR(j,0,i-1) cout<<f[i][j]<<\" \\n\"[j==i-1];\n\tans=INF;\n\tFOF(j,0,n) ans=min(ans,f[n][j]);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \n#define nn 508\n#define mod 998244353\nll n;ll cost[nn][nn];\nll dp[nn][nn];\nvoid upd(ll&x,ll y){\n\tx=min(x,y);\n}\nll pre[nn][nn],pres[nn][nn];ll prec[nn][nn],precs[nn][nn];\n\nll cut(ll l,ll r,ll x,ll y){\n\treturn pres[r][y]-pres[l-1][y]-pres[r][x-1]+pres[l-1][x-1];\n}\n\nll ccut(ll l,ll r,ll x,ll y){\n\treturn precs[r][y]-precs[l-1][y]-precs[r][x-1]+precs[l-1][x-1];\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) if(i!=j) scanf(\"%lld\",&cost[i][j]); \n\t\tfor(int j=1;j<=n;j++) pre[i][j]+=pre[i][j-1]+cost[i][j];\n\t}\t\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) pres[i][j]+=pres[i-1][j]+pre[i][j];\n\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=n;j++) cost[i][j]*=(i<j);\n\t\tfor(int j=1;j<=n;j++) prec[i][j]+=prec[i][j-1]+cost[i][j];\n\t}\t\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) precs[i][j]+=precs[i-1][j]+prec[i][j];\n\t\n\tll ans=1e18;\n\tmemset(dp,0x3f,sizeof dp);dp[0][0]=0;\n\tfor(int x=0;x<=n;x++)\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tupd(dp[x][i],dp[i][j]+cut(x+1,n,j+1,i)+ccut(i+1,x,i+1,x));\n\t\t\t}\n\t\t\t//dp[x][i]<<\":\"<<ans<<\"\\n\";\n\t\t\tupd(ans,dp[x][i]+ccut(x+1,n,x+1,n));\n\t\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=505;const ll inf=0x3f3f3f3f3f3f3f3f;\nll sa[N][N],sb[N][N],f[N][N];int n,a[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)fp(j,1,n)if(i!=j)scanf(\"%d\",&a[i][j]);\n\tfp(i,1,n)fp(j,i+1,n+1){\n\t\tsa[i][j]=sa[i][j-1];\n\t\tfp(k,i,j-1)sa[i][j]+=a[k][j];\n\t}\n\tfp(i,1,n)fd(j,n,i+1){\n\t\tsb[i][j]=sb[i][j+1];\n\t\tfp(k,1,i)sb[i][j]+=a[j][k];\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfp(i,0,n)fp(j,i,n)if(f[i][j]<inf)\n\t\tfp(k,j+1,n+1)cmin(f[j][k],f[i][j]+sa[j+1][k]+sb[j][k+1]-sb[i][k+1]);\n\tR ll res=inf;\n\tfp(i,0,n)cmin(res,f[i][n+1]);\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define gmi(a,b) a=(a)<(b)?(a):(b)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FOF(i,a,b) for(int i=a;i< b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=550;\nconst ll INF=1e18;\nint n,x;\nll ans,a[N][N],b[N][N],f[N][N];\nll SB(int x,int y){return b[x][x]-b[x][y]-b[y][x]+b[y][y];}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOF(i,0,n)FOF(j,0,n)if(i!=j){\n\t\tscanf(\"%d\",&x);\n\t\tj<i?a[j+1][i]=x:b[i+1][j]=x;\n\t}\n\tFOR(i,1,n)FOR(j,1,n){\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t}\n\tFOR(i,1,n)FOR(j,0,i) f[i][j]=INF;\n\tFOR(i,1,n)FOR(j,0,i)FOR(k,0,j)\n\t\tgmi(f[i][j],f[j][k]+a[k][i-1]-a[k][j-1]+SB(i-1,j));\n\t//FOR(i,1,n)FOR(j,0,i-1) cout<<f[i][j]<<\" \\n\"[j==i-1];\n\tans=INF;\n\tFOF(j,0,n) ans=min(ans,f[n][j]);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 505;\nconst ll INF = 1000000000000000;\nint n, x;\nll w[MAXN][MAXN], s[MAXN][MAXN], t[MAXN][MAXN], dp[MAXN][MAXN];\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) if(i!=j) scanf(\"%d\", w[i]+j);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+w[i][j];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tt[i][j]=t[i-1][j]+t[i][j-1]-t[i-1][j-1]+(i<j?w[i][j]:0);\n\t\tfor(int i=1; i<=n; i++){\n\t\tdp[i][1]=t[i][i]-t[0][i]-t[i][0]+t[0][0];\n\t\tfor(int j=2; j<=i; j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tfor(int k=1; k<j; k++)\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[j-1][k]+t[i][i]-t[i][j-1]-t[j-1][i]+t[j-1][j-1]+s[i][k-1]-s[j-1][k-1]);\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=1; i<=n; i++) ans=min(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n#define int         int64_t\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 5e2 + 5;\nconst int inf = (ll)1e18;\n\nint f[N][N], n, c[N][N], cost[N][N];\n\nint get(int x, int y, int u, int v) {\n    if(x > u || y > v) return 0;\n    return c[u][v] + c[x - 1][y - 1] - c[u][y - 1] - c[x - 1][v];\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n;\n    for(int i = 1; i <= n + 1; ++i) {\n        for(int j = 1; j <= n + 1; ++j) {\n            if(i != j && i <= n && j <= n) cin >> c[i][j];\n            c[i][j] += c[i - 1][j] + c[i][j - 1] - c[i - 1][j - 1];\n        }\n    }\n    /// cost(i, j) = sum c[a][b] | i < a < b <= j\n    for(int i = 0; i <= n + 1; ++i) {\n        for(int j = i + 1; j <= n + 1; ++j)\n            cost[i][j] = cost[i][j - 1] + get(i + 1, j, j - 1, j);\n    }\n    fill_n(&f[0][0], N * N, inf);\n    for(int i = 1; i <= n + 1; ++i) f[0][i] = cost[0][i];\n    auto minimize = [&](int& x, int y) {if(x > y) x = y;};\n    for(int i = 0; i <= n; ++i) {\n        for(int j = i + 1; j <= n + 1; ++j) {\n            if(f[i][j] == inf) continue;\n            for(int k = j + 1; k <= n + 1; ++k) {\n                minimize(f[j][k], f[i][j] + cost[j][k] + get(k + 1, i + 1, n + 1, j));\n            }\n        }\n    }\n    int res = inf;\n    for(int i = 0; i <= n; ++i) res = min(res, f[i][n + 1]);\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 577;\nconst ll INF = LLONG_MAX / 2;\n\nint N;\nll A[MAX_N][MAX_N], cost1[MAX_N][MAX_N], cost2[MAX_N][MAX_N];\nll dp[MAX_N][MAX_N];\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i == j) continue;\n            scanf(\"%lld\", &A[i][j]);\n            if (i < j) cost1[i][j] = A[i][j];\n            else cost2[j][i] = A[i][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i][j - 1];\n        }\n    }\n    for (int i = N; i; i--) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i + 1][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = N; j; j--) {\n            cost2[i][j] += cost2[i][j + 1];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost2[i][j] += cost2[i - 1][j];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        dp[0][i] = cost1[1][i];\n        for (int j = 1; j < i; j++) {\n            dp[j][i] = INF;\n            for (int k = 0; k < j; k++) {\n                dp[j][i] = min(dp[j][i], dp[k][j] + cost1[j + 1][i] + cost2[j][i + 1] - cost2[k][i + 1]);\n            }\n        }\n    }\n    ll ans = INF;\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < i; j++) {\n            ans = min(ans, dp[j][i] + cost1[i + 1][N]);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nconstexpr long long INF = 1'000'000'000'000'000'000;\nint n;\nstd::vector<std::vector<int>> a;\nstd::vector<std::vector<long long>> dp, sum, rsum;\nlong long query(std::vector<std::vector<long long>> &v, int l, int r, int d, int u) {\n    return v[r][u] - v[r][d] - v[l][u] + v[l][d];\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n;\n    a.assign(n, std::vector<int>(n));\n    dp.assign(n, std::vector<long long>(n, INF));\n    sum.assign(n + 1, std::vector<long long>(n + 1));\n    rsum.assign(n + 1, std::vector<long long>(n + 1));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                std::cin >> a[i][j];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            rsum[i + 1][j + 1] = rsum[i + 1][j] + rsum[i][j + 1] - rsum[i][j] + (i < j ? a[i][j] : 0);\n    long long ans = INF;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            ans = std::min(ans, dp[i][j] + query(rsum, j, n, j, n));\n            for (int k = j + 1; k < n; ++k)\n                dp[j][k] = std::min(dp[j][k], dp[i][j] + query(rsum, j, k, j, k) + query(sum, k, n, i, j));\n        }\n    }\n    std::cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nlong long n;\nlong long w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nlong long ans=(1<<30);\n\ninline int getsum(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  cin>>w[i][j];\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=(1<<30);\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tcout<<ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=510;\nint n,a[maxn][maxn];\nlong long suma[maxn][maxn],sumb[maxn][maxn],f[maxn][maxn],ans=1e18;\ninline long long getsum(int a,int b,int c){return sumb[b+1][c]+suma[n][b]-suma[n][a]+suma[c][a]-suma[c][b];}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(i^j) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) suma[i][j]=suma[i-1][j]+suma[i][j-1]-suma[i-1][j-1]+a[i][j];\n\tfor(int j=1;j<=n;j++) for(int i=j;i>=1;i--) sumb[i][j]=sumb[i+1][j]+sumb[i][j-1]-sumb[i+1][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=1e18;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tf[i][0]=getsum(0,0,i);\n\t\tans=min(ans,f[i][0]+getsum(0,i,n));\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<j;k++) f[i][j]=min(f[i][j],f[j][k]+getsum(k,j,i));\n\t\t\tans=min(ans,f[i][j]+getsum(j,i,n));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int N=505;\nLL n,a[N][N],b[N][N],dp[N][N];\ninline LL geta(int s1,int s2,int t1,int t2) {\n    if(s1>s2 || t1>t2) return 0;\n    return a[s2][t2]-(s1?a[s1-1][t2]:0)-(t1?a[s2][t1-1]:0)+((s1&&t1)?a[s1-1][t1-1]:0);\n}\ninline LL getb(int s1,int s2,int t1,int t2) {\n    if(s1>s2 || t1>t2) return 0;\n    return b[s2][t2]-(s1?b[s1-1][t2]:0)-(t1?b[s2][t1-1]:0)+((s1&&t1)?b[s1-1][t1-1]:0);\n}\ninline LL trans(int x,int y,int z) {\n    LL sum=getb(1,x,y+2,z+1);\n    sum+=getb(x+1,y,z+1,z+1);\n    sum+=geta(y+1,z,y+2,z);\n    return sum;\n}\n\nint main() {\n    cin>>n;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<i;j++) cin>>b[j][i];\n        for(int j=i+1;j<=n;j++) cin>>a[i][j];\n    }\n    for(int i=1;i<=n+1;i++)\n        for(int j=1;j<=n+1;j++)\n            a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+a[i][j], b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+b[i][j];\n    \n    memset(dp,0x3f,sizeof(dp));\n    for(int i=1;i<n;i++) {\n        dp[i][0]=trans(0,0,i);\n        for(int p=0;p<i;p++)\n            for(int j=i+1;j<n;j++)\n                dp[j][i]=min(dp[j][i],trans(p,i,j)+dp[i][p]);\n    }\n    \n    LL ans=trans(0,0,n);\n    for(int i=1;i<n;i++)\n        for(int p=0;p<i;p++)\n            ans=min(ans,dp[i][p]+trans(p,i,n));\n    cout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst ll inf = 1e18 + 7;\nconst int N = 505;\nconst double eps = 1e-9;\nll a[N][N], dp[N][N], mx[N][N];\nll pos[N][N], neg[N][N];\n\ninline ll sum(int i1, int j1, int i2, int j2) {\n  return a[i2][j2] - a[i1-1][j2] - a[i2][j1-1] + a[i1-1][j1-1];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n; cin >> n;\n  if (n <= 2) {\n    cout << \"0\\n\";\n    return 0;\n  }\n  ll tot = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) {\n      if (j != i)\n        cin >> a[i][j];\n      tot += a[i][j];\n      a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + a[i][j];\n      dp[i][j] = mx[i][j] = -inf;\n    }\n  for (int i = 1; i <= n; i++) {\n    for (int j = i+1; j <= n; j++) {\n      pos[i][j] = pos[i][j-1] + sum(j, i, j, j);\n      neg[i][j] = neg[i][j-1] + sum(i, j, j, j);\n    }\n  }\n  ll ans = inf;\n  for (int r = 2; r <= n; r++) {\n    dp[2][r] = pos[1][r] + neg[1][n] - neg[1][r] - neg[r+1][n];\n    ans = min(ans, tot - pos[1][n] - neg[1][n] + neg[1][r] + neg[r+1][n]);\n  }\n  for (int r = 2; r <= n; r++) {\n    for (int i = r+1; i <= n; i++) {\n      ll& val = dp[r+1][i];\n      for (int l = r; l > 2; l--) {\n        mx[r][i] = max(mx[r][i], pos[l][i] - pos[l][r]);\n        val = max(val, dp[l][r] + neg[r+1][n] - neg[r+1][i] - neg[i+1][n] + mx[r][i]);\n      }\n      ll tmp = dp[2][r] + neg[r+1][n] - neg[r+1][i] - neg[i+1][n] + neg[1][r];\n      for (int j = 2; j <= r; j++)\n        val = max(val, tmp + pos[j][i] - pos[j][r] - neg[1][j-1] - neg[j][r]);\n    }\n    ans = min(ans, tot - dp[r+1][n]);\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 505\n#define ll long long \nusing namespace std;\n\t\nint n,i,j,k,s[maxn][maxn];\nll a[maxn][maxn],b[maxn][maxn],f[maxn][maxn];\n\nll Suma(int x,int xx,int y,int yy){\n\tif (x>xx||y>yy) return 0;\n\treturn a[xx][yy]-a[x-1][yy]-a[xx][y-1]+a[x-1][y-1];\n}\n\nll Sumb(int l,int r){\n\treturn b[r][r]-b[r][l-1]-b[l-1][r]+b[l-1][l-1];\n}\n\t\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++) scanf(\"%d\",&a[i][j]);\n\t\tfor(j=i+1;j<=n;j++) scanf(\"%d\",&a[i][j]);\n\t\tfor(j=1;j<=n;j++) s[i][j]=a[i][j];\n\t}\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) \n\t\tb[i][j]=a[i][j]*(i<j)+b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++)\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\tmemset(f,127,sizeof(f)),f[0][0]=0;\n\tfor(i=0;i<n;i++) for(j=0;j<=i;j++) if (f[i][j]<1e18){\n\t\tfor(k=i+1;k<=n;k++)\n\t\t\tf[k][i]=min(f[k][i],f[i][j]+Sumb(i+1,k)+Suma(i+1,k,1,j));\n\t}\n\tll ans=1e18;\n\tfor(i=0;i<=n;i++) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n;\nint a[505][505];\nlong long dp[505][505],sum[505][505],sum2[505][505];\nlong long ask(int k,int j,int i)\n{\n\treturn sum[j+1][i]+sum2[n][j]-sum2[n][k]-sum2[i][j]+sum2[i][k];\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++) if(i!=j) a[i][j]=read();\n\tfor(int j=1;j<=n;j++)\n\tfor(int i=j;i>=1;i--) sum[i][j]=sum[i+1][j]+sum[i][j-1]-sum[i+1][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++) sum2[i][j]=sum2[i-1][j]+sum2[i][j-1]-sum2[i-1][j-1]+a[i][j];\n\tmemset(dp,0x3f,sizeof(dp));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tdp[i][0]=ask(0,0,i);\n\t\tfor(int j=1;j<i;j++)\n\t\tfor(int k=0;k<j;k++) dp[i][j]=min(dp[i][j],dp[j][k]+ask(k,j,i));\n\t}\n\tlong long ans=1e18;\n\tfor(int i=1;i<n;i++)\n\tfor(int j=0;j<i;j++) ans=min(ans,dp[i][j]+ask(j,i,n));\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 510\n#define ll long long\nint n;\nint a[N][N];\nll p[N][N],q[N][N];\nll f[N][N][N];\nvoid upd(ll &a,ll b){a=max(a,b);}\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<i;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),sum+=a[i][j];\n\t\tfor (int j=i+1;j<=n;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),sum+=a[i][j];\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=i-1;j>=1;--j)\n\t\t\tp[i][j]=p[i][j+1]+a[i][j];\n\t\tfor (int j=1;j<i;++j)\n\t\t\tq[i][j]=q[i][j-1]+a[j][i];\n\t}\n\tmemset(f,128,sizeof f);\n\tf[1][1][0]=0;\n\tfor (int i=1;i<n;++i)\n\t\tfor (int j=1;j<=i;++j)\n\t\t\tfor (int k=j-1;k<i;++k)\n\t\t\t\tif (f[i][j][k]>=0){\n\t\t\t\t\tupd(f[i+1][j][k],f[i][j][k]+p[i+1][j]+q[i+1][k]);\n\t\t\t\t\tupd(f[i+1][k+1][i],f[i][j][k]+p[i+1][k+1]+q[i+1][i]);\n\t\t\t\t}\n\tll ans=0;\n\tfor (int j=1;j<=n;++j)\n\t\tfor (int k=j-1;k<n;++k)\n\t\t\tupd(ans,f[n][j][k]);\n\tprintf(\"%lld\\n\",sum-ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    auto N    = in<int>();\n    auto fass = make_v({N, N}, 0LL);\n    auto bass = make_v({N, N}, 0LL);\n    ll btotal = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) { fsss[i][j] += fsss[i][j - 1], bsss[i][j] += bsss[i][j - 1]; }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) { fsss[i][j] += fsss[i - 1][j], bsss[i][j] += bsss[i - 1][j]; }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto used = make_v({N + 1, N + 1}, false);\n    auto memo = make_v({N + 1, N + 1}, 0LL);\n    auto dp   = mfp([&](auto&& self, const int pp, const int p) -> ll {\n        if (p == N) { return 0; }\n        if (used[pp][p]) { return memo[pp][p]; }\n        ll ans = inf_v<ll>;\n        for (int np = p + 1; np <= N; np++) {\n            const ll fore = fsum(pp, p, np);\n            const ll back = bsum(pp, p, np);\n            chmin(ans, fore + back + self(self, p, np));\n        }\n        return used[pp][p] = true, memo[pp][p] = ans;\n    });\n    outln(dp(0, 0) + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N;\n\tcin >> N;\n\tVV<ll> A(N,V<ll>(N));\n\t\n\trep(i,N) rep(j,N) if(i!=j){\n\t\tcin >> A[i][j];\n\t}\n\t\n\n\tconst ll inf = 1e18;\n\tVV<ll> dp(N,V<ll>(N,inf)),ndp(N,V<ll>(N,inf));\n\tdp[0][0] = 0;\n\trep1(i,N-1){\n\t\tV<ll> Rs(N+1),Ls(N+1);\n\t\trep1(x,N) Rs[x] = Rs[x-1] + A[x-1][i];\n\t\trep1(x,N) Ls[x] = Ls[x-1] + A[i][x-1];\n\t\tauto R = [&](int l,int r,int i){\t//[l,r) -> i\n\t\t\treturn Rs[r] - Rs[l];\n\t\t};\n\t\tauto L = [&](int l,int r,int i){\t//[l,r) <- i\n\t\t\treturn Ls[r] - Ls[l];\n\t\t};\n\t\trep(j,N) rep(k,N) ndp[j][k] = inf;\n\t\trep(j,i) rep(k,max(j,1)){\n\t\t\tchmin(ndp[j][k],dp[j][k] + R(j,i,i) + L(0,k,i));\n\t\t\tchmin(ndp[i][j],dp[j][k] + L(0,j,i));\n\t\t}\n\t\tswap(dp,ndp);\n\t}\n\tll ans = inf;\n\trep(j,N) rep(k,N) chmin(ans,dp[j][k]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n\nint A[500][500];\nLLI pre[501][501];\nLLI dp[500][500];\nint main() {\n    int i,j;\n    int N;\n    LLI sum = 0;\n    scanf(\"%d\",&N);\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (i != j) {\n                scanf(\"%d\",&A[i][j]);\n                if (j < i) sum += A[i][j];\n                else A[i][j] = -A[i][j];\n            }\n            pre[i+1][j+1] = pre[i+1][j]+pre[i][j+1]-pre[i][j]+A[i][j];\n        }\n    }\n\n    int k;\n    LLI ans = -1e18;\n    for (i = 0; i < N; i++) {\n        for (j = 0; j <= i; j++) {\n            if (j == 0) dp[i][j] = pre[i+1][i+1];\n            else {\n                dp[i][j] = -1e18;\n                for (k = 0; k < j; k++) {\n                    dp[i][j] = max(dp[i][j],dp[j-1][k]+pre[i+1][i+1]-pre[i+1][j]-pre[j][i+1]+pre[j][j] \\\n                         + pre[i+1][j]-pre[i+1][k]-pre[j][j]+pre[j][k]);\n                }\n            }\n            if (i == N-1) ans = max(ans,dp[i][j]);\n        }\n    }\n    printf(\"%lld\\n\",sum-ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 510;\n\nint n;\nll a[N][N], dp[N][N]; \n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n#endif\n\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j)\n      if (i != j)\n        scanf(\"%lld\", &a[i][j]);\n  for (int i = 1; i <= n; ++i)\n    for (int j = i + 1; j <= n; ++j)\n      a[i][j] += a[i][j - 1];\n  for (int j = 1; j <= n; ++j)\n    for (int i = j + 1; i <= n; ++i)\n      a[i][j] += a[i - 1][j];\n  for (int i = 1; i <= n; ++i) {\n    ll as = 0;\n    for (int j = i; j; --j) {\n      dp[i][j] = 1LL << 60;\n      as += a[j][i];\n      ll bs = 0;\n      for (int k = j != 1; k < j; ++k) {\n        dp[i][j] = min(dp[i][j], dp[j - 1][k] + bs);\n        bs += a[i][k] - a[j - 1][k];\n      }\n      dp[i][j] += as;\n    }\n  }\n  ll ans = *min_element(dp[n] + 1, dp[n] + n + 1);\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=510;\nconst int p=998244353;\ntypedef long long ll;\nint i,j,k,n,m,x,y,t,a[N][N];\nll w[N][N],r[N][N],f[N][N];\nll val(int a,int b,int c){ return w[b][c]-w[a-1][c]; }\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)for (j=1;j<=n;j++)if (i!=j)scanf(\"%d\",&a[i][j]);\n\tfor (i=1;i<=n;i++)for (j=n;j>=i+1;j--){w[i][j]=w[i][j+1];for (k=1;k<=i;k++)w[i][j]+=a[j][k];}\n\tfor (i=1;i<=n;i++)for (j=i+1;j<=n+1;j++){ r[i][j]=r[i][j-1]; for (k=i;k<=j-1;k++)r[i][j]+=a[k][j]; }\n    memset(f,0x3f,sizeof f);\n\tf[0][0]=0;for (i=0;i<=n;i++)for (j=i;j<=n;j++)if (f[i][j]<1e18){for (k=j+1;k<=n+1;k++)f[j][k]=min(f[j][k],f[i][j]+r[j+1][k]+val(i+1,j,k+1));}\n    ll ans=1e18;\n    for (i=0;i<=n;i++)ans=min(ans,f[i][n+1]);\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll sum[501][501];\nll dp[502][502];\nll cop[502][502];\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<ll>> a(n);\n\trep(i, n) {\n\t\ta[i].resize(n);\n\t\trep(j, n) {\n\t\t\tif (i == j)a[i][j] = 0;\n\t\t\telse cin >> a[i][j];\n\t\t}\n\t}\n\n\t//calc sum\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ts += a[k][j];\n\t\t\t}\n\t\t\tsum[i][j] = s;\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\t{\n\t\tll s = 0;\n\t\tfor (int j = n-1; j>0; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j][k] = s + sum[0][k] + sum[k + 1][j];\n\t\t\t}\n\n\t\t\ts += a[j][0];\n\t\t}\n\t\t/*cout << \"0 is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tfor (int i = 1; i < n-1; i++) {\n\t\trep(j, n + 1)rep(k, n + 1)cop[j][k] = INF;\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tif (dp[j][k] == 0)continue;\n\t\t\t\tll s = 0;\n\t\t\t\tif (k >= i) {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tcop[l][k] = min(cop[l][k], s+dp[j][k] + sum[k + 1][l] - sum[k + 1][j]);\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tfor (int m = j; m <= l; m++) {\n\t\t\t\t\t\t\tcop[l][m] = min(cop[l][m], s + dp[j][k] + sum[i][m] - sum[i][j] + sum[m+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, n + 1)rep(k, n + 1)dp[j][k]=cop[j][k];\n\n\t\t/*cout << i << \" is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tll ans = INF;\n\t/*rep(i, n)rep(j, n) {\n\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}*/\n\trep(i, n+1)rep(j, n+1)ans = min(ans, dp[i][j]);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//from https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\n//from https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\nclass edge {\npublic:\n    int to;\n    llint cap;\n    llint cost;\n    llint rev;\n    bool isrev;\n};\nedge make_edge(int a,int b,int c,int d,bool e){\n\tedge x;\n\tx.to=a;\n\tx.cap=b;\n\tx.cost=c;\n\tx.rev=d;\n\tx.isrev=e;\n\treturn x;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n \n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back(make_edge(to, cap, cost, (int) graph[to].size(), false));\n    graph[to].emplace_back(make_edge(from, 0, -cost, (int) graph[from].size() - 1, true));\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cerr << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nint main(void){\n\tint n,i,j;cin>>n;\n\tPrimalDual<llint,llint>gra(n+2);\n\tllint ans=0;\n\tfor(i=0;i<n-1;i++){gra.add_edge(i,i+1,big,0);}\n\tvector<llint>ovcap(n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i;j++){\n\t\t\tllint A;cin>>A;gra.add_edge(i,j,A,1);\n\t\t}\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tllint A;cin>>A;\n\t\t\tovcap[i]-=A;\n\t\t\tovcap[j]+=A;\n\t\t\tans+=A;\n\t\t\tgra.add_edge(j,i,A,1);\n\t\t\t\n\t\t}\n\t}\n\tllint allover=0;\n\tfor(i=0;i<n;i++){\n\t\tif(ovcap[i]>0){allover+=ovcap[i];gra.add_edge(n,i,ovcap[i],0);}\n\t\telse{gra.add_edge(i,n+1,-ovcap[i],0);}\n\t}\n\tcerr<<\"allover=\"<<allover<<endl;\n\tllint flow=gra.min_cost_flow(n,n+1,allover);\n\tcerr<<\"flow=\"<<flow<<endl;\n\tcout<<ans-flow<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// D - Negative Cycle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tINF\t1e16\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<vector<long long> > a(n, vector<long long>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (i != j) cin >> a[i][j];\n\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, INF));\n\tdp[0][0] = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long> c(i), d(i);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = i; k < n; k++) c[j] += a[k][j - 1];\n\t\t\tc[j] += c[j - 1];\n\t\t}\n\t\tfor (int j = i - 2; j >= 0; j--) {\n\t\t\tfor (int k = j + 1; k < i; k++) d[j] += a[j][k];\n\t\t\td[j] += d[j + 1];\n\t\t}\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tfor (int k = 0; k <= j; k++)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + c[j] - c[k] + d[j]);\n\t}\n\n\tcout << *min_element(dp[n].begin(),dp[n].end()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP1(u) for(int i=hd[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)\n#define REP2(u) for(int&i=cr[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)\nusing namespace std;\nconst int N=200200,INF=1000010000;\nint n,x,y,ans,S,T,fl=1;\nint a[N],b[N],ca[N],cb[N],hd[N],cr[N],dep[N];\nqueue<int>q;\nstruct edge{int n,v,c;}e[N];\nvoid add_(int u,int v,int c){e[++fl]=(edge){hd[u],v,c};hd[u]=fl;}\nvoid adde(int u,int v,int c){add_(u,v,c);add_(v,u,0);}\nbool bfs(){\n\tFOR(i,S,T) dep[i]=-1,cr[i]=hd[i];\n\tq.push(S);dep[S]=0;\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tREP1(u)if(c && dep[v]<0)\n\t\t\tdep[v]=dep[u]+1,q.push(v);\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int E){\n\tif(u==T) return E;\n\tint F=0;\n\tREP2(u)if(c && dep[v]==dep[u]+1){\n\t\tint t=dfs(v,min(c,E));\n\t\tF+=t;e[i^1].c+=t;\n\t\tE-=t;e[i^0].c-=t;\n\t\tif(!E) break;\n\t}\n\treturn F;\n}\nint main(){\n\t//freopen(\"perm.in\",\"r\",stdin);\n\t//freopen(\"perm.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);S=T=1;\n\tFOR(i,1,n) scanf(\"%d\",&a[i]);\n\tFOR(i,1,n) scanf(\"%d\",&b[i]);\n\tFOR(i,1,n)if(!ca[i])for(x=a[i],++T;ca[x]=T,x!=i;x=a[x]);\n\tFOR(i,1,n)if(!cb[i])for(x=b[i],++T;cb[x]=T,x!=i;x=b[x]);\n\t++T;\n\tFOR(i,1,n){\n\t\tx=ca[i];y=cb[i];\n\t\tif(a[i]==b[i]){\n\t\t\tif(i==a[i]) ans++;\n\t\t\telse adde(x,y,1),e[fl].c=1;\n\t\t}\n\t\telse{\n\t\t\tif(i!=a[i] && i!=b[i]) adde(y,x,1);\n\t\t\tif(i==a[i]) adde(y,T,1);\n\t\t\tif(i==b[i]) adde(S,x,1);\n\t\t}\n\t}\n\t//FOR(u,1,T){cout<<u<<':';REP(u) cout<<v<<'-'<<c<<' ';cout<<'\\n';}\n\twhile(bfs()) ans+=dfs(S,INF);\n\tcout<<n-ans<<'\\n';\n\tFOR(i,1,n) cout<<(~dep[ca[i]]?a[i]:i)<<' ';cout<<'\\n';\n\tFOR(i,1,n) cout<<(~dep[cb[i]]?i:b[i])<<' ';cout<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 505\nusing namespace std;\ntypedef long long ll;\n\nll n, mn=4e18, a[N][N], s[N][N], x[N][N], d[N][N];\nint main() {\n\tll i, j, k, tx;\n\tcin >> n;\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) if(i!=j) scanf(\"%lld\", &a[i][j]);\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) x[i][j] = x[i-1][j] + x[i][j-1] - x[i-1][j-1] + (i<j ? a[i][j] : 0);\n\tfor(i=1; i<=n; i++) {\n\t\td[i][1] = x[i][i];\n\t\tfor(j=2; j<=i; j++) {\n\t\t\td[i][j] = 4e18;\n\t\t\ttx = x[i][i] - x[i][j-1] - x[j-1][i] + x[j-1][j-1];\n\t\t\tfor(k=1; k<j; k++) {\n\t\t\t\td[i][j] = min(d[i][j], d[j-1][k] + tx + s[i][k-1] - s[j-1][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1; i<=n; i++) mn = min(mn, d[n][i]);\n\tcout << mn;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, a[505][505];\nLL cp[505][505], cq[505][505];\nLL dp[2][505][505];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) rep(j, n)\n\tif(i != j) scanf(\"%d\", &a[i][j]);\n\t\n\trep(i, n) rep(j, n)\n\tif(i < j) cp[i][j] = cp[i][j - 1] + a[i][j];\n\t\n\trep(i, n) for(int j = n - 1; j >= 0; j --)\n\tif(j > i) cq[i][j - 1] = cq[i][j] + a[j][i];\n\t\n\trep(i, n) rep(j, n) dp[(n - 1) & 1][i][j] = INF;;\n\tdp[(n - 1) & 1][n - 1][n - 1] = cp[n - 1][n - 1] + cq[n - 1][n - 1];\n\t\n\tfor(int i = n - 2; i >= 0; i --) {\n\t\tint ori = !(i & 1), nw = i & 1;\n\t\trpe(j, n) rep(k, n) dp[nw][j][k] = INF;\n\t\tfor(int j = i; j < n; j ++) for(int k = j; k < n; k ++)\n\t\tdp[nw][j][k] = min(dp[nw][j][k], dp[ori][j][k] + cp[i][j] + cq[i][k]);\n\t\tLL cans = INF;\n\t\tfor(int j = n - 1; j >= i; j --) {\n\t\t\tfor(int k = j; k < n; k ++) cans = min(cans, dp[ori][j][k]);\n\t\t\tfor(int k = j; k >= i; k --) dp[nw][k][j] = min(dp[nw][k][j], cans + cp[i][k] + cq[i][j]);\n\t\t}\n\t}\n\t\n\tLL ans = INF;\n\trep(i, n) for(int j = i; j < n; j ++)\n\tans = min(ans, dp[0][i][j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 510;\nll dp[N][N], n;\nll mat[N][N], sum[2][N][N];\nll calc(int tp,int l1,int r1,int l2,int r2) {\n  return sum[tp][r1][r2] - sum[tp][l1-1][r2] - sum[tp][r1][l2-1] + sum[tp][l1-1][l2-1];\n}\nint main() {\n  read(n);\n  rep (i, 1, n) {\n    rep (j, 1, n) if (i != j) {\n      read(mat[i][j]);\n    }\n  }\n  rep (i, 1, n) rep (j, 1, n)\n    sum[i < j][i][j] = mat[i][j];\n  rep (k, 0, 1) {\n    rep (i, 1, n) rep (j, 1, n)\n      sum[k][i][j] += sum[k][i][j-1];\n    rep (i, 1, n) rep (j, 1, n)\n      sum[k][i][j] += sum[k][i-1][j];\n  }\n  memset(dp, 0, sizeof dp);\n  rep (i, 1, n) rep (j, 1, n) dp[0][0] += mat[i][j];\n  rep (i, 1, n) {\n    rep (a, 0, i-1) rep (b, 0, max(0, a-1)) {\n      ckmx(dp[i][a], dp[a][b] - calc(1, a+1, i, a+1, i) - calc(0, i+1, n, 1, a));\n    }\n  }\n  ll ans = 0;\n  rep (a, 0, n) rep (b, 0, max(0, a-1))\n    ckmx(ans, dp[a][b] - calc(1, a+1, n, a+1, n));\n  ans = dp[0][0] - ans;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e18;\nconst int MAXN = 505;\n\nint n;\nll w[MAXN][MAXN],f[MAXN][MAXN],sum1[MAXN][MAXN],sum2[MAXN][MAXN];\n\nll getVal1(int a,int b,int c,int d){\n\treturn sum1[b][d] - (c == 0 ? 0 : sum1[b][c - 1]) - (a == 0 ? 0 : sum1[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum1[a - 1][c - 1]);\n}\n\nll getVal2(int a,int b,int c,int d){\n\treturn sum2[b][d] - (c == 0 ? 0 : sum2[b][c - 1]) - (a == 0 ? 0 : sum2[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum2[a - 1][c - 1]);\n}\n\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif(i != j)\n\t\t\t    scanf(\"%d\",&w[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum1[i][j] = sum1[i - 1][j] + sum1[i][j - 1] - sum1[i - 1][j - 1] + w[i][j];\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum2[i][j] = sum2[i - 1][j] + sum2[i][j - 1] - sum2[i - 1][j - 1] + (i < j ? w[i][j] : 0);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tf[i][1] = getVal2(0,i,0,i);\n\t\tfor(int j = 2;j <= i;j++){\n\t\t\tf[i][j] = INF;\n\t\t\tfor(int k = 1;k < j;k++)\n\t\t\t\tf[i][j] = min(f[i][j],f[j - 1][k] + getVal2(j,i,j,i) + getVal1(j,i,0,k - 1));\n\t\t}\n\t}\n\tll ans = INF;\n\tfor(int i = 1;i <= n;i++)\n\t    ans = min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e18;\nconst int MAXN = 505;\n\nint n;\nll w[MAXN][MAXN],f[MAXN][MAXN],sum1[MAXN][MAXN],sum2[MAXN][MAXN];\n\nll getVal1(int a,int b,int c,int d){\n\treturn sum1[b][d] - (c == 0 ? 0 : sum1[b][c - 1]) - (a == 0 ? 0 : sum1[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum1[a - 1][c - 1]);\n}\n\nll getVal2(int a,int b,int c,int d){\n\treturn sum2[b][d] - (c == 0 ? 0 : sum2[b][c - 1]) - (a == 0 ? 0 : sum2[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum2[a - 1][c - 1]);\n}\n\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif(i != j)\n\t\t\t    scanf(\"%d\",&w[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum1[i][j] = sum1[i - 1][j] + sum1[i][j - 1] - sum1[i - 1][j - 1] + w[i][j];\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum2[i][j] = sum2[i - 1][j] + sum2[i][j - 1] - sum2[i - 1][j - 1] + (i < j ? w[i][j] : 0);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tf[i][1] = getVal2(0,i,0,i);\n\t\tfor(int j = 2;j <= i;j++){\n\t\t\tf[i][j] = INF;\n\t\t\tfor(int k = 1;k < j;k++)\n\t\t\t\tf[i][j] = min(f[i][j],f[j - 1][k] + getVal2(j,i,j,i) + getVal1(j,i,0,k - 1));\n\t\t}\n\t}\n\tll ans = INF;\n\tfor(int i = 1;i <= n;i++)\n\t    ans = min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nvoid Umn(auto &x,auto y){\n    x=min(x,y);\n}\n\nll n, a[555][555], s1[555][555], s2[555][555], f[555][555], g[555][555], inf=1e15;\n\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j){\n            if (i!=j) cin>>a[i][j];\n            s1[i][j]=s1[i][j-1]+a[i][j];\n            s2[i][j]=s2[i-1][j]+a[i][j];\n        }\n    memset(f,33,sizeof f);\n    f[0][0]=0;\n    for (int w=1;w<=n;++w){\n        memset(g,33,sizeof g);\n        for (int i=0;i<=n;++i)\n            for (int j=0;j<=n;++j)\n                if (f[i][j]<inf){\n                    Umn(g[i][j],f[i][j]+s2[w-1][w]-s2[i][w]+s1[w][j]);\n                    Umn(g[w-1][i],f[i][j]+s1[w][i]);\n                }\n        memcpy(f,g,sizeof f);\n    }\n    ll ans=inf;\n    for (int i=0;i<=n;++i)\n        for (int j=0;j<=n;++j)\n            Umn(ans,f[i][j]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define __AVX__ 1\n#define __AVX2__ 1\n#define __SSE__ 1\n#define __SSE2__ 1\n#define __SSE2_MATH__ 1\n#define __SSE3__ 1\n#define __SSE4_1__ 1\n#define __SSE4_2__ 1\n#define __SSE_MATH__ 1\n#define __SSSE3__ 1\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")\n#define cmax(a,b) ((a)>(b))\n#include <immintrin.h>\n#include<bits/stdc++.h>\n__m256i a[1033333/8+1],a2[2033333/8+1];\nunsigned int b[1033333],a1[1033333];\n#define re register\nint main()\n{\n\tsrand(time(0));rand();rand();\n\tre double xl1=0,xl2=0;\n\tre unsigned int x=rand(),y=rand(),*aa=(unsigned int *)&a,*aa2=(unsigned int *)&a2;\n\tfor(re int i=0;i<1033333;i++)\n\t{\n\t\taa2[i]=a1[i]=x,x^=x<<13,x^=x>>17,x^=x<<5;\n\t\taa[i]=b[i]=y,y^=y<<13,y^=y>>17,y^=y<<5;\n\t}\n\tfor(re int ii=1;ii<=500;ii++){\n\tre double xl=clock();\n\tfor(re int i=0;i<1033333/8+1;i++)a[i]=_mm256_xor_si256(a[i],a2[i]),_mm256_add_epi32(a[i],a2[i]),_mm256_and_si256(a[i],a2[i]),_mm256_max_epi32(a[i],a2[i]);\n\txl1+=clock()-xl;xl=clock();\n\t//for(re int i=0;i<1033333;i++)b[i]^=a1[i],b[i]+=a1[i],b[i]&=a1[i],b[i]=cmax(b[i],a1[i]);\n\t//xl2+=clock()-xl;\n\t}\n\tprintf(\"%.10lf %.10lf\\n\",xl1,xl2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505;\nint n,a[N][N],dp[N][N],b[N][N],c[N][N];\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<i;j++)scanf(\"%lld\",&a[i][j]);\n\t\tfor (int j=i+1;j<=n;j++)scanf(\"%lld\",&a[i][j]);\n\t\tfor (int j=1;j<=n;j++)b[i][j]=a[i][j];\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)b[i][j]+=b[i-1][j];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)b[i][j]+=b[i][j-1];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tc[i][j]=c[i][j-1];\n\t\t\tfor (int k=i;k<=j;k++)c[i][j]+=a[k][j];\n\t\t}\n\tmemset(dp,0x3f3f3f3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t\tfor (int x=j+1;x<=n;x++)\n\t\t\t\tdp[j][x]=min(dp[j][x],dp[i][j]+b[x][i]-b[j][i]+c[j+1][x]);\n\tint ans=1e18;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t\tans=min(ans,dp[i][j]+b[n][i]-b[j][i]+c[j+1][n]);\n\tprintf(\"%lld\\n\",ans);\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 505;\nconst ll INF = 1000000000000000;\nint n, x;\nll w[MAXN][MAXN], s[MAXN][MAXN], t[MAXN][MAXN], dp[MAXN][MAXN];\nint main(){\n\tfreopen(\"park.in\", \"r\", stdin);\n\tfreopen(\"park.out\",\"w\",stdout);\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) if(i!=j) scanf(\"%d\", w[i]+j);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+w[i][j];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tt[i][j]=t[i-1][j]+t[i][j-1]-t[i-1][j-1]+(i<j?w[i][j]:0);\n\t\tfor(int i=1; i<=n; i++){\n\t\tdp[i][1]=t[i][i]-t[0][i]-t[i][0]+t[0][0];\n\t\tfor(int j=2; j<=i; j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tfor(int k=1; k<j; k++)\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[j-1][k]+t[i][i]-t[i][j-1]-t[j-1][i]+t[j-1][j-1]+s[i][k-1]-s[j-1][k-1]);\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=1; i<=n; i++) ans=min(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=505;\nconst long long INF=4557430888798830399;\nint n;\nlong long a[N][N];\nlong long s1[N][N],s2[N][N];\nlong long f[N][N];\nlong long calc1(int l1,int r1,int l2,int r2)\n{\n\tswap(l1,l2);\n\tswap(r1,r2);\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n//\tcerr<<\"Calc1\"<<l1<<\" \"<<r1<<\" \"<<l2<<\" \"<<r2<<\" res:\"<<s1[r1][r2]<<\"\\n\";\n\treturn s1[r1][r2]-s1[l1-1][r2]-s1[r1][l2-1]+s1[l1-1][l2-1];\n}\nlong long calc2(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n//\tcerr<<\"Calc-1\"<<l1<<\" \"<<r1<<\" \"<<l2<<\" \"<<r2<<\" res:\"<<s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1]<<\"\\n\";\n\treturn s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) scanf(\"%lld\",&a[i][j]);\n//\tfor(int i=1;i<=n;i++)\n//\t{\n//\t\tfor(int j=1;j<=n;j++)\n//\t\t\tprintf(\"%lld \",a[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n//\tfor(int i=1;i<=n+1;i++)\n//\t{\n//\t\tfor(int j=1;j<=n+1;j++)\n//\t\t\tprintf(\"%lld \",s1[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<INF)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\n\t\t\t\t\t{\n\t\t\t\t\t\tint t=calc1(i+1,j,k+1,n+1)+calc2(j+1,k,j+1,k);\n\t\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+t);\n//\t\t\t\t\t\tcerr<<\"f\"<<i<<\" \"<<j<<\" \"<<f[i][j]<<\" ccc\"<<\" \"<<t<<\" \"<<\"to \"<<j<<\" \"<<k<<\" \"<<f[j][k]<<\"\\n\";\n\t\t\t\t\t}\n\tlong long res=INF;\n\tfor(int i=0;i<=n;i++)\n\t\tres=min(res,f[i][n+1]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=505;\nconst long long INF=4557430888798830399;\nint n;\nint a[N][N];\nlong long s1[N][N],s2[N][N];\nlong long f[N][N];\nlong long calc1(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s1[r1][r2]-s1[l1-1][r2]-s1[r1][l2-1]+s1[l1-1][l2-1];\n}\nlong long calc2(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<INF)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+calc1(k+1,n+1,i+1,j)+calc2(j+1,k,j+1,k));\n\tlong long res=INF;\n\tfor(int i=0;i<=n;i++)\n\t\tres=min(res,f[i][n+1]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <iomanip>\n#include <iostream> \n#define ll long long\n#define N 550\n#define inf 1000000000000000\nusing namespace std;\n\nll n,dp[N][N],w[N][N],p[N][N],tot[N][N];\n\ninline ll getans(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nvoid fl()\n{\n\tfreopen(\"park.in\",\"r\",stdin);\n\tfreopen(\"park.out\",\"w\",stdout);\n}\n\nint main()\n{\n\t//fl();\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++) \n\t\t\tif (i!=j) cin>>w[i][j];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i-1][j]+p[i][j-1]-p[i-1][j-1]+w[i][j];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i-1][j]+tot[i][j-1]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tdp[i][1]=tot[i][i]-tot[0][i]-tot[i][0]+tot[0][0];\n\t\tfor (int j=2;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=inf;\n\t\t\tfor (int k=1;k<j;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getans(j,i,0,k-1));\n\t\t}\n\t}\n\tll ans=inf;\n\tfor (int i=1;i<=n;i++) ans=min(ans,dp[n][i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\ntypedef unsigned long long lu;\ntypedef long long li;\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (int)((lu)x * y % mod); }\ninline int Mul(int x, int y, int z) { return (int)((lu)x * y % mod * z % mod); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\n\n// ----------------------------------------\n\nconst int maxn = 500;\nconst li infl = ~0LLU >> 2;\n\nint n, a[maxn][maxn];\nli dp[maxn][maxn], basic, total;\nli sl[maxn + 1][maxn + 1], sr[maxn + 1][maxn + 1];\n\nvoid Init(void) {\n  for (int i = 0; i <= n; ++i) {\n    sl[i][i] = sr[i][i] = 0;\n  }\n  for (int l = n; l >= 0; --l) {\n    for (int r = l + 1; r <= n; ++r) {\n      sl[l][r] = sl[l][r - 1];\n      for (int k = l; k < r - 1; ++k) {\n        sl[l][r] += a[r - 1][k];\n      }\n      sr[l][r] = sr[l + 1][r];\n      for (int k = l + 1; k < r; ++k) {\n        sr[l][r] += a[l][k];\n      }\n    }\n  }\n}\n\nli CalcL(int l, int r) {\n  return sl[l][r];\n}\n\nli CalcR(int l, int r) {\n  return sr[l][r];\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i != j) {\n        scanf(\"%d\", a[i] + j);\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      basic += a[i][j];\n      total += a[i][j] + a[j][i];\n    }\n  }\n\n  Init();\n\n  li global = -infl;\n  for (int i = 1; i < n; ++i) {\n    for (int j = i + 1; j < n; ++j) {\n      // calc (i, j)\n      li &ans = dp[i][j];\n      ans = CalcL(0, j) - CalcR(0, i) - CalcR(i, j);\n      for (int k = 1; k < i; ++k) {\n        // try (k, i, j)\n        li now = dp[k][i];\n        now += CalcL(k, j) - CalcL(k, i) - CalcR(i, j);\n        Max(ans, now);\n      }\n      li now = ans;\n      now += CalcL(i, n) - CalcL(i, j) - CalcR(j, n);\n      Max(global, now);\n    }\n  }\n\n  Max(global, CalcL(0, n) - CalcR(0, n));\n  for (int i = 1; i < n; ++i) {\n    Max(global, CalcL(0, n) - CalcR(0, i) - CalcR(i, n));\n  }\n\n  global += basic;\n  global = total - global;\n  printf(\"%lld\\n\", global);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nstruct P {\n    ll x, y;\n    char ty;\n};\nostream& operator<<(ostream& os, const P& p) {\n    return os << p.ty << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\nconst int MN = 510;\nint n;\nll cost[MN][MN];\nll rcost[MN][MN];\nll cost_sm[MN][MN];\nll rcost_sm[MN][MN];\n\nll memo[MN][MN][MN];\nbool vis[MN][MN][MN];\nll calc(int a, int b, int c) {\n    /*\n    [0, a) : 2\n    [a, b) : 1\n    [b, c) : 0\n     */\n    if (c == n) return 0;\n    if (vis[a][b][c]) return memo[a][b][c];\n    vis[a][b][c] = true;    \n    ll ans = TEN(18);\n    /*\n      c = 0\n      prohibit\n      2 <- 0\n      0 -> 0\n     */\n    ans = min(ans, cost_sm[c][a] + (rcost_sm[c][c] - rcost_sm[c][b]) + calc(a, b, c + 1));\n    /*\n      c = -1\n      prohibit\n      1 <- -1      \n     */\n    ans = min(ans, (cost_sm[c][b]) + calc(b, c, c + 1));\n\n    return memo[a][b][c] = ans;\n}\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            cin >> cost[i][j];\n            rcost[j][i] = cost[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cost_sm[i][j + 1] = cost_sm[i][j] + cost[i][j];\n            rcost_sm[i][j + 1] = rcost_sm[i][j] + rcost[i][j];\n        }\n    }\n\n\n    cout << calc(0, 0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<long long>> foo(n + 1, vector<long long>(n + 1));\n  vector<vector<long long>> bar(n + 1, vector<long long>(n + 1));\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j < i; ++j) {\n      cin >> foo[j][i];\n    }\n    for (int j = i + 1; j <= n; ++j) {\n      cin >> bar[i][j];\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      foo[i][j] += foo[i - 1][j] + foo[i][j - 1] - foo[i - 1][j - 1];\n      bar[i][j] += bar[i - 1][j] + bar[i][j - 1] - bar[i - 1][j - 1];\n    }\n  }\n  vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 1ll << 60));\n  dp[0][0] = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < max(i, 1); ++j) {\n      for (int k = i + 1; k <= n; ++k) {\n        long long sum_foo = foo[i][n] + foo[j][k] - foo[i][k] - foo[j][n];\n        long long sum_bar = bar[k][k] + bar[i][i] - bar[i][k] - bar[k][i];\n        dp[k][i] = min(dp[k][i], dp[i][j] + sum_foo + sum_bar);\n      }\n    }\n  }\n  cout << *min_element(dp[n].begin(), dp[n].end()) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=500;\n\nint n;\nint Icst[N+3][N+3];\nll Esum1[N+3][N+3],Esum2[N+3][N+3],Ef[N+3][N+3];\n\nll Calc1(int La,int Ra,int Lb,int Rb){\n\tif(La>Ra || Lb>Rb) return 0;\n\treturn Esum1[Ra][Rb]-Esum1[Ra][Lb-1]-Esum1[La-1][Rb]+Esum1[La-1][Lb-1];\n}\nll Calc2(int La,int Ra,int Lb,int Rb){\n\tif(La>Ra || Lb>Rb) return 0;\n\treturn Esum2[Ra][Rb]-Esum2[Ra][Lb-1]-Esum2[La-1][Rb]+Esum2[La-1][Lb-1];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tscanf(\"%d\",&Icst[i][j]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tEsum1[i][j]=Esum1[i-1][j]+Esum1[i][j-1]-Esum1[i-1][j-1]+(i>j? Icst[i][j]:0);\n\t\t\tEsum2[i][j]=Esum2[i-1][j]+Esum2[i][j-1]-Esum2[i-1][j-1]+(i<j? Icst[i][j]:0);\n\t\t}\n\tn++;\n\tmemset(Ef,0x3f,sizeof Ef);\n\tconst ll INF=Ef[0][0];\n\tll Vans=INF;\n\tEf[0][0]=0;\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=0;j<i;j++){\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t\tEf[i][j]=min(Ef[i][j],Ef[j][k]+Calc1(i+1,n-1,k+1,j)+Calc2(j+1,i,j+1,i));\n\t\t\tif(i==n-1)\n\t\t\t\tVans=min(Vans,Ef[i][j]);\n\t\t}\n\tprintf(\"%lld\\n\",Vans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 505;\nconst long long INF = 0x3f3f3f3f3f3f3f3fll;\n\nint n;\nint a[N][N];\nlong long s1[N][N], s2[N][N], f[N][N];\n\nlong long getsum(long long s[N][N], int sx, int sy, int tx, int ty) {\n\treturn s[tx][ty] - s[sx][ty] - s[tx][sy] + s[sx][sy];\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tread(a[i][j]);\n\t\t\t}\n\t\t\ts1[i][j] = s1[i - 1][j] + s1[i][j - 1] - s1[i - 1][j - 1] + (i < j ? a[i][j] : 0);\n\t\t\ts2[i][j] = s2[i - 1][j] + s2[i][j - 1] - s2[i - 1][j - 1] + (i > j ? a[i][j] : 0);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tf[i][j] = INF;\n\t\t}\n\t}\n\tf[0][0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = i + 1; k <= n; ++k) {\n\t\t\t\tf[k][i] = std::min(f[k][i], f[i][j] + getsum(s1, i, i, k, k) + getsum(s2, i, 0, k, j));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = INF;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans = std::min(ans, f[n][i]);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nll a[502][502],b[502][502],f[501][501],ans,sum;\nint n,i,j,k,l;\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"agc036d.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)\n\t{\n\t\tfo(j,1,n)\n\t\tif (i!=j)\n\t\tscanf(\"%lld\",&a[i][j]),b[i][j]=a[i][j]*(i>j),a[i][j]*=(i<j);\n\t}\n\tfo(i,1,n) fo(j,1,n) a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1],b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t\n\tmemset(f,128,sizeof(f));\n\tfo(i,1,n)\n\t{\n\t\tf[i][0]=b[i][i];\n\t\tfo(j,0,i-1)\n\t\t{\n\t\t\tfo(k,i+1,n)\n\t\t\tf[k][i]=max(f[k][i],f[i][j]+(a[i][k]-a[i][i])+((b[k][k]-b[i][k])-(b[k][j]-b[i][j])));\n\t\t}\n\t}\n\t\n\tans=0;\n\tfo(i,0,n-1) ans=max(ans,f[n][i]);\n\tans=a[n][n]+b[n][n]-ans;\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500;\n\nint n, a[maxn][maxn];\nlong long from[maxn][maxn], to[maxn][maxn], dp[maxn][maxn][maxn], ans;\n\nvoid cmin(long long &x, long long y) { x = min(x, y); }\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) if (j != i) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tfrom[i][j] = (j?from[i][j-1]:0) + a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tto[i][j] = (j?to[i][j-1]:0) + a[j][i];\n\t\t}\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tans = dp[0][0][0];\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = 0; k <= j; ++k) {\n\t\t\t\tcmin(dp[i+1][j][k], dp[i][j][k]+(to[i+1][i]-(j?to[i+1][j-1]:0))+(k?from[i+1][k-1]:0));\n\t\t\t\tcmin(dp[i+1][i+1][j], dp[i][j][k]+(j?from[i+1][j-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t\tfor (int k = 0; k <= j; ++k)\n\t\t\tcmin(ans, dp[n-1][j][k]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=505;\nint a[MAXN][MAXN],n;\nLL f[MAXN][MAXN][MAXN],g[MAXN],s1[MAXN][MAXN],s2[MAXN][MAXN];\nint main()\n{\n\tn=read();\n\tLL sum=0;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)a[i][j]=read(),sum+=a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)s1[i][j]=s1[i][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)s2[j][i]=s2[j][i-1]+a[i][j];\n\tmemset(f,-63,sizeof(f));f[1][0][0]=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i-1;j++)\n\t\t{\n\t\t\tg[j]=-(1LL<<63-1);\n\t\t\tfor(int k=0;k<=j;k++)g[j]=max(g[j],f[i-1][j][k]+s2[i][j]+s1[i][i]-s1[i][j]);\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tf[i][j][k]=f[i-1][j][k]+s1[i][i]-s1[i][k]+s2[i][j];\n\t\t\t\tf[i][j][k]=max(f[i][j][k],g[k]+s2[i][j]-s2[i][k]);\n\t\t\t}\n\t}\n\tLL ans=(1LL<<63-1);\n\tfor(int i=0;i<n;i++)for(int j=0;j<=i;j++)ans=min(ans,sum-f[n][i][j]);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x3f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 0x3f3f3f3f)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 0x3f3f3f3f;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 500;\nint n;\nll f[maxn + 1][maxn + 1][maxn + 1], ans = 1e18;\nll s[maxn + 10][maxn + 10], t[maxn + 10][maxn + 10], a[maxn + 10][maxn + 10];\n\nvoid upd(ll &x, ll y) {\n\tx = min(x, y);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (i != j) scanf(\"%lld\", &a[i][j]);\n\t\t\ts[i][j] = s[i][j - 1] + a[i][j];\n\t\t\tt[i][j] = t[i - 1][j] + a[i][j];\n\t\t}\n\tmemset(f, 0x3f, sizeof f);\n\tf[1][1][1] = 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tfor (int k = 1; k <= j; ++k) {\n\t\t\t\tupd(f[i + 1][j][k], f[i][j][k] + t[i][i + 1] - t[j - 1][i + 1] + s[i + 1][k - 1]);\n\t\t\t\tupd(f[i + 1][i + 1][j], f[i][j][k] + s[i + 1][j - 1]);\n\t\t\t\tupd(f[i + 1][i + 1][i + 1], f[i][j][k] + s[i + 1][i]);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tans = min(ans, f[n][i][j]);\n\tprintf(\"%lld\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-03-25 15:20:24\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=510;\nconst i64 inf=1ll<<50;\ni64 n,a[N][N],f[N][N],ans,s[N][N],S[N][N];\nint main()\n{\n\tn=read(); ans=inf;\n\tfr(i,1,n) fr(j,1,n) if(i!=j) a[i][j]=read();\n\tfr(i,1,n) fr(j,1,n)\n\t{\n\t\ts[i][j]=s[i-1][j]+s[i][j-1]+a[i][j]-s[i-1][j-1];\n\t\tS[i][j]=S[i-1][j]+S[i][j-1]+(i>=j?0:a[i][j])-S[i-1][j-1];\n\t}\n\tfr(i,0,n+1) fr(j,0,n+1) f[i][j]=inf;\n\tf[0][0]=0;\n\tfr(j,0,n) fr(i,0,j) if(f[i][j]!=inf)\n\t\tfr(k,j+1,n+1)\n\t\t{\n\t\t\ti64 F=f[i][j];\n\t\t\tF+=S[k?k-1:0][k?k-1:0]-S[k?k-1:0][j?j-1:0]-S[j?j-1:0][k?k-1:0]+S[j?j-1:0][j?j-1:0];\n\t\t\t//fr(I,1,n) if(I>=j&&I<k) fr(J,1,n) if(J>=j&&J<k&&I<J) F+=a[I][J];\n\t\t\tF+=s[n][j?j-1:0]-s[n][i?i-1:0]-s[k?k-1:0][j?j-1:0]+s[k?k-1:0][i?i-1:0];\n\t\t\t//fr(I,1,n) if(I>=i&&I<j) fr(J,1,n) if(J>=k) F+=a[J][I];\n\t\t\tf[j][k]=std::min(f[j][k],F);\n\t\t}\n\t\t/*\n\t\t(-)\t000001111222223333\n\t\t         i   j    k\n\t\t*/\n\tfr(i,0,n) ans=std::min(ans,f[i][n+1]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//from https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\n//from https://ei1333.github.io/luzhiled/snippets/graph/primal-dual.html\nclass edge {\npublic:\n    int to;\n    llint cap;\n    llint cost;\n    llint rev;\n    bool isrev;\n};\nedge make_edge(int a,llint b,llint c,llint d,bool e){\n\tedge x;\n\tx.to=a;\n\tx.cap=b;\n\tx.cost=c;\n\tx.rev=d;\n\tx.isrev=e;\n\treturn x;\n}\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n \n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back(make_edge(to, cap, cost, (int) graph[to].size(), false));\n    graph[to].emplace_back(make_edge(from, 0, -cost, (int) graph[from].size() - 1, true));\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cerr << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nint main(void){\n\tint n,i,j;cin>>n;\n\tPrimalDual<llint,llint>gra(n+2);\n\tllint ans=0;\n\tfor(i=0;i<n-1;i++){gra.add_edge(i,i+1,big,0);}\n\tvector<llint>ovcap(n);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<i;j++){\n\t\t\tllint A;cin>>A;gra.add_edge(i,j,A,1);\n\t\t}\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tllint A;cin>>A;\n\t\t\tovcap[i]-=A;\n\t\t\tovcap[j]+=A;\n\t\t\tans+=A;\n\t\t\tgra.add_edge(j,i,A,1);\n\t\t\t\n\t\t}\n\t}\n\tllint allover=0;\n\tfor(i=0;i<n;i++){\n\t\tif(ovcap[i]>0){allover+=ovcap[i];gra.add_edge(n,i,ovcap[i],0);}\n\t\telse{gra.add_edge(i,n+1,-ovcap[i],0);}\n\t}\n\t//cerr<<\"allover=\"<<allover<<endl;\n\tllint flow=gra.min_cost_flow(n,n+1,allover);\n\t//cerr<<\"flow=\"<<flow<<endl;\n\tcout<<ans-flow<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vvi a(N, vi(N));\n    F0R (i, N) F0R (j, N) if (i != j) re(a[i][j]);\n\n    vvll pref(N, vll(N + 1));\n    F0R (i, N) F0R (j, N) pref[i][j+1] = pref[i][j] + a[i][j];\n\n    vvll ferp(N+1, vll(N));\n    F0R (i, N) F0R (j, N) ferp[i+1][j] = ferp[i][j] + a[i][j];\n\n    vvll dp(N + 1, vll(N + 1, LLONG_MAX)); dp[0][1] = 0;\n    vvll DP = dp;\n\n    FOR (i, 1, N) {\n        trav (r, DP) fill(all(r), LLONG_MAX);\n\n        F0R (pc, N + 1) F0R (cc, N + 1) {\n            ll cost = dp[pc][cc]; if (cost == LLONG_MAX) continue;\n            {\n                ll stay = cost;\n                // FOR (v, i - cc, i) stay += a[v][i];\n                stay += ferp[i][i] - ferp[i-cc][i];\n                // F0R (v, i - cc - pc) stay += a[i][v];\n                stay += pref[i][i - cc - pc];\n\n                ckmin(DP[pc][cc+1], stay);\n            }\n            {\n                ll go = cost + pref[i][i - cc];\n                //F0R (v, i - cc) go += a[i][v];\n\n                ckmin(DP[cc][1], go);\n            }\n        }\n\n        swap(dp, DP);\n    }\n\n    ll ans = LLONG_MAX;\n    trav (r, dp) ckmin(ans, *min_element(all(r)));\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 505\n\nint n, a[N][N];\ntypedef long long ll;\nll pos[N][N], neg[N][N];\n\nconst ll inf = 1ll<<62;\n\nll dp[N][N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (j == i) continue;\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tpos[i][i] = 0;\n\t\tfor (int j = i - 1; j >= 1; j --) pos[i][j] = pos[i][j+1] + a[j][i];\n\t\tneg[i][i] = 0;\n\t\tfor (int j = i - 1; j >= 1; j --) neg[i][j] = neg[i][j+1] + a[i][j];\n\t}\n\tfor (int i = 0; i <= n; i ++) for (int j = 0; j <= i; j ++) dp[i][j] = inf;\n\tdp[0][0] = 0;\n\tfor (int j = 0; j <= n; j ++) {\n\t\tfor (int k = 0; k <= j; k ++) {\n\t\t\tll cur = 0;\n\t\t\tfor (int i = j + 1; i <= n; i ++) {\n\t\t\t\tcur += pos[i][j+1] - neg[i][k+1];\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + cur);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = inf;\n\tfor (int i = 0; i < n; i ++) ans = min(ans, dp[n][i]);\n\tfor (int i = 1; i <= n; i ++) for (int j = i - 1; j >= 1; j --) ans += a[i][j];\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=505;\nconst LL inf=(LL)1e17;\n\nint n;\nLL s1[N][N],s2[N][N],a[N][N],f[N][N];\n\nvoid pre()\n{\n\tfor (int l=1;l<n;l++)\n\t\tfor (int i=1;i+l<=n;i++)\n\t\t{\n\t\t\tint j=i+l;\n\t\t\ts1[i][j]=s1[i][j-1]+s1[i+1][j]-s1[i+1][j-1]+a[i][j];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=n;j>i;j--)\n\t\t\ts2[i][j]=s2[i][j+1]+a[j][i];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t\ts2[i][j]+=s2[i-1][j];\n}\n\nLL dp()\n{\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=n;j++)\n\t\t\tf[i][j]=inf;\n\tLL ans=s1[1][n];\n\tfor (int i=1;i<=n;i++) ans=std::min(ans,s1[1][i]+s1[i+1][n]);\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=s1[1][i]+s1[i+1][j]+s2[i][j+1];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t{\n\t\t\tans=std::min(ans,f[i][j]+s1[j+1][n]);\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tf[j][k]=std::min(f[j][k],f[i][j]+s1[j+1][k]+s2[j][k+1]-s2[i][k+1]);\n\t\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i!=j) scanf(\"%lld\",&a[i][j]);\n\tpre();\n\tprintf(\"%lld\\n\",dp());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<set>\n#include<cmath>\n#include<map>\n#include<bitset>\n#include<fstream>\n#include<tr1/unordered_map>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define x first\n#define y second\n\nvoid proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\nint read()\n{\n\tint x = 0, f = 1; int c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 510;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\nLL dp[2][maxn][maxn], A[maxn][maxn], B[maxn][maxn];\n\ninline void ckmin(LL &x, LL y) { x >= y ? x = y : 0; }\n\nint main()\n{\n\n\tint n = read();\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfor(int j = 1; j <= n; ++j) if(i != j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tif(i < j) A[j][i] = x;\n\t\t\telse B[i][j] = x;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= i; ++j)\n\t\t\tA[i][j] += A[i][j - 1], B[i][j] += B[i][j - 1];\n\n\tint p = 0, q = 1;\n\tmemset(dp, 0x3f, sizeof(dp));\n\tdp[p][0][0] = 0;\n\tfor(int i = 2; i <= n; ++i)\n\t{\n\t\tswap(p, q);\n\t\tfor(int j = 0; j <= i; ++j) for(int k = 0; k <= i; ++k) dp[p][j][k] = INF;\n\n\t\tfor(int j = 0; j < i; ++j)\n\t\t\tfor(int k = j; k < i; ++k) if(dp[q][j][k] != INF)\n\t\t\t{\n\t\t\t\tLL tmp = dp[q][j][k];\n\t\t\t\t//if(tmp == 1) cout << '!' << endl;\n\n\t\t\t\tif(j == 0 && k == 0)\n\t\t\t\t{\n\t\t\t\t\tckmin(dp[p][0][0], tmp + A[i][i]);\n\t\t\t\t\tckmin(dp[p][0][i], tmp);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(j == 0)\n\t\t\t\t{\n\t\t\t\t\tckmin(dp[p][0][k], tmp + A[i][i] - A[i][k - 1]);\n\t\t\t\t\tckmin(dp[p][k][i], tmp + B[i][k - 1]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tckmin(dp[p][j][k], tmp + A[i][i] - A[i][k - 1] + B[i][j - 1]);\n\t\t\t\tckmin(dp[p][k][i], tmp + B[i][k - 1]);\n\t\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i <= n; ++i)\n\t\t\tfor(int j = 0; j <= n; ++j) \n\t\t\t{\n\t\t\t\tcout << i << ' ' << j << ' ' << dp[p][i][j] << endl;\n\t\t\t}*/\n\t}\n\n\tLL ans = INF;\n\tfor(int i = 0; i <= n; ++i)\n\t\tfor(int j = 0; j <= n; ++j) \n\t\t{\n\t\t\t//cout << i << ' ' << j << ' ' << dp[p][i][j] << endl;\n\t\t\tckmin(ans, dp[p][i][j]);\n\t\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=500;\n\nint n;\nint Icst[N+3][N+3];\nll Ef[N+3][N+3],Ecac[N+3],Ecuc[N+3];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tscanf(\"%d\",&Icst[i][j]);\n\tn++;\n\tmemset(Ef,0x3f,sizeof Ef);\n\tconst ll INF=Ef[0][0];\n\tll Vans=INF;\n\tEf[0][0]=0;\n\tfor(int i=1;i<=n-1;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tEcac[j]=0;\n\t\t\tfor(int k=i+1;k<n;k++) Ecac[j]+=Icst[k][j];\n\t\t\tif(j) Ecac[j]+=Ecac[j-1];\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tEcuc[j]=0;\n\t\t\tfor(int k=j+1;k<=i;k++) Ecuc[j]+=Icst[j+1][k];\n\t\t\tif(j+1<i-1) Ecuc[j]+=Ecuc[j+1];\n\t\t}\n\t\tfor(int j=0;j<i;j++){\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t\tEf[i][j]=min(Ef[i][j],Ef[j][k]+Ecac[j]-Ecac[k]+Ecuc[j]);\n\t\t\tif(i==n-1) Vans=min(Vans,Ef[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",Vans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nchar aa[N],a[N],mp[9]=\"ABC\";\nint be[N],en[N],tp[N];\nint nn,i,j,k,n,ct[3],ctt[3],id[N],xb1,xb2,he,ta,p[N];\nbool bb[N];\ninline void swapp(int x,int y){\n\tswap(ct[x],ct[y]);swap(mp[x],mp[y]);\n\tfor(int i=1;i<=n;++i)\n\t\tif(a[i]-'A'==x)a[i]='A'+y;\n\t\t\telse if(a[i]-'A'==y)a[i]='A'+x;\n}\ninline void ins(int l,int r){\n\tbe[++xb2]=l;en[xb2]=r;\n\t++ct[tp[xb2]=l<r?0:a[l]-'A'];\n}\ninline void build(){\n\tmemset(ct,0,12);xb1=xb2=0;\n\tfor(i=1;i<=n;++i)if(a[i]=='A')id[++xb1]=i;\n\tif(id[1]>1)ins(1,id[1]-1);\n\tfor(i=1;i<xb1;++i)ins(id[i]+1,id[i+1]-1);\n\tif(id[xb1]<n)ins(id[xb1]+1,n);\n}\nint main(){\n\tscanf(\"%s\",aa+1);nn=strlen(aa+1);\n\tfor(i=1;i<=nn;++i)if(!n || aa[i]!=a[n])a[++n]=aa[i];\n\tfor(i=1;i<=n;++i)++ct[a[i]-'A'];\n\tif(ct[1]<ct[0] && ct[1]<=ct[2])swapp(0,1);\n\t\telse if(ct[2]<=ct[1] && ct[2]<ct[0])swapp(0,2);\n\tbuild();\n\tif(!ct[0]){\n\t\tputs(\"\");\n\t\treturn 0;\n\t}\n\tif(ct[0]+ct[2]<ct[1])swapp(1,2),build();\n\the=1;ta=n;memcpy(aa+1,a+1,n);\n\tif(ct[0]+ct[1]<ct[2] && aa[ta]=='C')--xb2,--ct[2],--ta;\n\tif(ct[0]+ct[1]<ct[2] && aa[he]=='C')--xb2,--ct[2],++he;\n\tn=0;\n\tfor(i=he;i<=ta;++i){\n\t\ta[++n]=aa[i];\n\t\tif(n>2 && a[n-2]=='A' && a[n-1]=='C' && a[n]=='A' && \n\t\t\tct[0]+ct[1]<ct[2])--ct[2],n-=2;\n\t}\n\tbuild();\n\tfor(i=1;i<=xb2;++i){\n\t\tp[i]=be[i];\n\t\tif(tp[i])++p[i];else if(ct[1]<ct[2]){\n\t\t\tif(a[be[i]]=='B')++p[i];\n\t\t\t\telse p[i]+=2,bb[i]=1;\n\t\t\t++ct[1];--ct[0];\n\t\t}\n\t}\n\tfor(i=1;i<=xb2;++i)for(;p[i]+1<=en[i] && ct[1]<xb1;++ct[1])p[i]+=2;\n\tvector<int>v[2];\n\tfor(i=1;i<=xb2;++i){\n\t\tif(bb[i])v[a[be[i]]-'B'].push_back(i);\n\t\tif(p[i]<=en[i])v[a[en[i]-'C']].push_back(i);\n\t}\n\tfor(;ct[1]<xb1;v[0].pop_back(),v[1].pop_back()){\n\t\tint x=v[0].back(),y=v[1].back();\n\t\tif(bb[x] && a[be[x]]=='B')bb[x]=0;else ++p[x];\n\t\tif(bb[y] && a[be[y]]=='B')bb[y]=0;else if(p[y]<=en[y])++p[y];\n\t}\n\tfor(i=j=1;i<=xb2;++i)if(p[i]>be[i]){\n\t\tfor(;j<=xb1 && id[j]<be[i];++j)putchar(mp[0]);\n\t\tfor(k=bb[i]?be[i]+1:be[i];k<p[i];++k)putchar(mp[a[k]-'A']);\n\t}\n\tfor(;j<=xb1;++j)putchar(mp[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll INF = 1e18;\nconst int MAXN = 505;\n\nint n;\nll w[MAXN][MAXN],f[MAXN][MAXN],sum1[MAXN][MAXN],sum2[MAXN][MAXN];\n\nll getVal1(int a,int b,int c,int d){\n\treturn sum1[b][d] - (c == 0 ? 0 : sum1[b][c - 1]) - (a == 0 ? 0 : sum1[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum1[a - 1][c - 1]);\n}\n\nll getVal2(int a,int b,int c,int d){\n\treturn sum2[b][d] - (c == 0 ? 0 : sum2[b][c - 1]) - (a == 0 ? 0 : sum2[a - 1][d]) + (a == 0 || c == 0 ? 0 : sum2[a - 1][c - 1]);\n}\n\nint main(){\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++){\n\t\t\tif(i != j)\n\t\t\t    scanf(\"%d\",&w[i][j]);\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum1[i][j] = sum1[i - 1][j] + sum1[i][j - 1] - sum1[i - 1][j - 1] + w[i][j];\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 1;j <= n;j++)\n\t\t    sum2[i][j] = sum2[i - 1][j] + sum2[i][j - 1] - sum2[i - 1][j - 1] + (i < j ? w[i][j] : 0);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tf[i][1] = getVal2(0,i,0,i);\n\t\tfor(int j = 2;j <= i;j++){\n\t\t\tf[i][j] = INF;\n\t\t\tfor(int k = 1;k < j;k++)\n\t\t\t\tf[i][j] = min(f[i][j],f[j - 1][k] + getVal2(j,i,j,i) + getVal1(j,i,0,k - 1));\n\t\t}\n\t}\n\tll ans = INF;\n\tfor(int i = 1;i <= n;i++)\n\t    ans = min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, a[505][505];\nLL cp[505][505], cq[505][505];\nLL dp[2][505][505];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) rep(j, n)\n\tif(i != j) scanf(\"%d\", &a[i][j]);\n\t\n\trep(i, n) rep(j, n)\n\tif(i < j) cp[i][j] = cp[i][j - 1] + a[i][j];\n\t\n\trep(i, n) for(int j = n - 1; j >= 0; j --)\n\tif(j > i) cq[i][j - 1] = cq[i][j] + a[j][i];\n\t\n\trep(i, n) rep(j, n) dp[(n - 1) & 1][i][j] = INF;;\n\tdp[(n - 1) & 1][n - 1][n - 1] = cp[n - 1][n - 1] + cq[n - 1][n - 1];\n\t\n\tfor(int i = n - 2; i >= 0; i --) {\n\t\tint ori = !(i & 1), nw = i & 1;\n\t\trep(j, n) rep(k, n) dp[nw][j][k] = INF;\n\t\tfor(int j = i; j < n; j ++) for(int k = j; k < n; k ++)\n\t\tdp[nw][j][k] = min(dp[nw][j][k], dp[ori][j][k] + cp[i][j] + cq[i][k]);\n\t\tLL cans = INF;\n\t\tfor(int j = n - 1; j >= i; j --) {\n\t\t\tfor(int k = j; k < n; k ++) cans = min(cans, dp[ori][j][k]);\n\t\t\tfor(int k = j; k >= i; k --) dp[nw][k][j] = min(dp[nw][k][j], cans + cp[i][k] + cq[i][j]);\n\t\t}\n\t}\n\t\n\tLL ans = INF;\n\trep(i, n) for(int j = i; j < n; j ++)\n\tans = min(ans, dp[0][i][j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 505;\nconst long long INF = 1e18;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, a[MAXN][MAXN];\nll s[MAXN][MAXN], cost[MAXN][MAXN], dp[MAXN][MAXN];\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tread(a[i][j]);\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tread(a[i][j]);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 1; j <= n; j++)\n\t\ts[i][j] = s[i][j - 1] + a[i][j];\n\tfor (int i = 0; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\t\tdp[i][j] = INF;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i; j <= n; j++) {\n\t\tll res = 0;\n\t\tfor (int k = i; k <= j; k++)\n\t\t\tres += s[k][j] - s[k][k];\n\t\tcost[i][j] = res;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[0][i] = cost[1][i];\n\tfor (int i = 0; i <= n - 1; i++)\n\tfor (int j = i + 1; j <= n; j++) {\n\t\tll tmp = dp[i][j];\n\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\ttmp += s[k][i];\n\t\t\tchkmin(dp[j][k], tmp + cost[j + 1][k]);\n\t\t}\n\t}\n\tll ans = INF;\n\tfor (int i = 0; i <= n - 1; i++)\n\t\tchkmin(ans, dp[i][n]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=505;\nconst long long INF=4557430888798830399;\nint n;\nlong long a[N][N];\nlong long s1[N][N],s2[N][N];\nlong long f[N][N];\nlong long calc1(int l1,int r1,int l2,int r2)\n{\n\tswap(l1,l2);\n\tswap(r1,r2);\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s1[r1][r2]-s1[l1-1][r2]-s1[r1][l2-1]+s1[l1-1][l2-1];\n}\nlong long calc2(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) scanf(\"%lld\",&a[i][j]);\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<INF)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+calc1(i+1,j,k+1,n+1)+calc2(j+1,k,j+1,k));\n\tlong long res=INF;\n\tfor(int i=0;i<=n;i++)\n\t\tres=min(res,f[i][n+1]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// D.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 550;\nconst ll INF = 1e18;\n\nint n, ai[MAX_N][MAX_N];\nll pre[MAX_N][MAX_N], dp[MAX_N][MAX_N], cost[MAX_N][MAX_N];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (i != j)\n\t\t\t\tscanf(\"%d\", &ai[i][j]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tpre[i][j] = ai[i][j] + pre[i][j - 1];\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tdp[i][j] = INF;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i; j <= n; j++)\n\t\t\tfor (int k = i; k <= j; k++)\n\t\t\t\tcost[i][j] += pre[k][j] - pre[k][k];\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[0][i] = cost[1][i];\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t{\n\t\t\tll acc = dp[i][j];\n\t\t\tfor (int k = j + 1; k <= n; k++)\n\t\t\t\tacc += pre[k][i], dp[j][k] = min(dp[j][k], acc + cost[j + 1][k]);\n\t\t}\n\tll ans = INF;\n\tfor (int i = 0; i <= n - 1; i++)\n\t\tans = min(ans, dp[i][n]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll INF=1LL<<50;\nint n;\nll ans,a[510][510],dp[510][510],s[2][510][510];\nvoid update(ll &x,ll y) {\n\tif (x>y) x=y;\n}\nll S(int k,int x1,int x2,int y1,int y2) {\n\treturn s[k][x2][y2]-s[k][x1-1][y2]-s[k][x2][y1-1]+s[k][x1-1][y1-1];\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif (i!=j) read(a[i][j]);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++) {\n\t\tfor (int k=0;k<2;k++) {\n\t\t\ts[k][i][j]=s[k][i-1][j]+s[k][i][j-1]-s[k][i-1][j-1];\n\t\t}\n\t\ts[i>j][i][j]+=a[i][j];\n\t}\n\tfor (int i=0;i<=n;i++)\n\tfor (int j=0;j<=n;j++) dp[i][j]=INF;\n\tdp[0][0]=0;\n\tfor (int i=0;i<n;i++)\n\tfor (int j=0;j<=i;j++) {\n\t\tif (dp[i][j]==INF) continue;\n\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\tfor (int x=i+1;x<=n;x++)\n\t\t\tupdate(dp[x][i],dp[i][j]+S(0,i+1,x,i+1,x)+S(1,x+1,n,j+1,i));\n\t}\n\tans=INF;\n\tfor (int i=1;i<=n;i++) update(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=505;\nint n;\nint w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nint ans=2147483647;\n\ninline int getsum(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  scanf(\"%lld\",&w[i][j]);\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=0x3f3f3f3f;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=505;\nint n;\nint w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nint ans=2147483647<<10;\n\ninline int getsum(int u,int v,int x,int y){\n\treturn p[v][y]-(x==0?0:p[v][x-1])-(u==0?0:p[u-1][y])+(u==0 || v==0?0:p[u-1][x-1]);\n}\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  scanf(\"%lld\",&w[i][j]);\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=0x3f3f3f3f;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=500+5;\nlong long n,a[N][N],g[2][N][N],f[N][N],cnt,sum=0x3f3f3f3f3f3f3f3f;\nvoid init(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=0;++i<=n;) for(int j=0;++j<=n;i==j?:scanf(\"%lld\",&a[i][j]));\n}\nlong long gg(int k,int lx,int ly,int rx,int ry){\n\treturn g[k][rx][ry]-g[k][lx-1][ry]-g[k][rx][ly-1]+g[k][lx-1][ly-1];\n}\nvoid work(){\n\tfor(int i=0;++i<=n;){\n\t\tfor(int j=0;++j<=n;i>=j?:g[0][i][j]=a[i][j],g[0][i][j]+=g[0][i][j-1]);\n\t\tfor(int j=0;++j<=n;g[0][i][j]+=g[0][i-1][j]);\n\t}\n\tfor(int i=0;++i<=n;){\n\t\tfor(int j=0;++j<=n;i<=j?:g[1][i][j]=a[i][j],g[1][i][j]+=g[1][i][j-1]);\n\t\tfor(int j=0;++j<=n;g[1][i][j]+=g[1][i-1][j]);\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=-1;++i<=n;) for(int j=-1;++j<max(i,1);) for(int h=i;++h<=n;\n\t\tcnt=f[i][j]+gg(1,h+1,j+1,n,i)+gg(0,i+1,i+1,h,h),f[h][i]=min(f[h][i],cnt));\n\tfor(int i=0;++i<=n;sum=min(sum,f[n][i]));\n}\nvoid prin(){\n\tprintf(\"%lld\",sum);\n}\nint main(){\n\tinit();\n\twork();\n\tprin();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nint main() {\n  int n;\n  cin >> n;\n  vii a(n, vi(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) continue;\n      cin >> a[i][j];\n    }\n  }\n\n  vll rem_cost1(n, vl(n));\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      rem_cost1[i][j] = rem_cost1[i][j - 1];\n      for (int k = i; k < j; k++) {\n        rem_cost1[i][j] += a[k][j];\n      }\n    }\n  }\n\n  vll rem_cost2(n, vl(n));\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      rem_cost2[i][j] = rem_cost2[i][j - 1];\n      for (int k = i; k >= 0; k--) {\n        rem_cost2[i][j] += a[j][k];\n      }\n    }\n  }\n\n  vll dp(n, vl(n, INF));\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      dp[i][j] = rem_cost1[0][j] + rem_cost1[j + 1][i];\n    }\n  }\n\n  rep (i, n) {\n    rep (j, n) {\n      if (dp[i][j] >= INF / 2) continue;\n      for (int k = i + 1; k < n; k++) {\n        ll add = 0;\n        add += rem_cost1[i + 1][k];\n        add += (rem_cost2[j][k] - rem_cost2[j][i]);\n        dp[k][i] = min(dp[k][i], dp[i][j] + add);\n      }\n    }\n  }\n\n  /*\n  DEBUG_MAT(a);\n  DEBUG_MAT(rem_cost1);\n  DEBUG_MAT(rem_cost2);\n  DEBUG_MAT(dp);\n  //*/\n\n  ll ans = INF;\n  rep (j, n) {\n    ans = min(ans, dp[n - 1][j]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nconst int N = 512; \nint a[N][N];\nll pos[N][N], neg[N][N];\nll dp[N][N];\n\nvoid solve() {\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i!=j) cin >> a[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j >= 0; j--) {\n            pos[i][j] += pos[i][j+1] + a[i][j];\n            neg[i][j] += neg[i][j+1] + a[j][i];\n        }\n    }\n    memset(dp, 0x3f, sizeof dp);\n    dp[0][0] = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            ll sum = 0;\n            for (int x = i+1; x <= n; x++) {\n                //sum += pos[x][j] - pos[x][i];\n                sum += -pos[x-1][j];\n                sum += neg[x-1][i];\n                dp[x][i] = min(dp[x][i], dp[i][j] + sum);\n            }\n        }\n    }\n    ll res = 1ll<<60;\n    for (int j = 0; j <= n; j++) {\n        res = min(res, dp[n][j]);\n    }\n    for (int i = 0; i < n; i++) {\n        res += pos[i][0];\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\ntypedef long long LL;\nconst int N = 505;\n\nint n,x,a[N][N];\nLL s1[N][N], s2[N][N], dp[N][N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)rep(j,1,n-1){\n\t\tscanf(\"%d\",&x);\n\t\ta[i][j+(j>=i)]=x;\n\t}\n\t\n\trep(i,1,n){\n\t\tLL sum1 = 0, sum2 = 0;\n\t\trep(j,i,n){\n\t\t\tsum1 += a[i][j], sum2 += a[j][i];\n\t\t\ts1[i][j] = s1[i-1][j] + sum1;\n\t\t\ts2[i][j] = s2[i-1][j] + sum2;\n\t\t} \n\t}\n\t\n\trep(i,0,n+1)rep(j,0,n+1)dp[i][j]=1e18;\n\tdp[1][0]=0;\n\trep(i,1,n)rep(j,0,i-1)rep(x,i+1,n+1){\n\t\tLL sum1 = s1[x-1][x-1] - s1[i-1][x-1];\n\t\tLL sum2 = s2[i-1][n] - (j?s2[j-1][n]:0) - s2[i-1][x-1] + (j?s2[j-1][x-1]:0);\n\t\tdp[x][i] = min(dp[x][i], dp[i][j] + sum1 + sum2);\n\t}\n\tLL ans = 1e18;\n\trep(i,1,n) ans = min(ans, dp[n+1][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nlong long w[510][510], D[510][510], w2[510][510];\nlong long S[510][510], S2[510][510];\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (i == j)continue;\n\t\t\tscanf(\"%lld\", &w[i][j]);\n\t\t\tif (i < j)w2[i][j] = w[i][j];\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tS[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + w[i][j];\n\t\t\tS2[i][j] = S2[i - 1][j] + S2[i][j - 1] - S2[i - 1][j - 1] + w2[i][j];\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tD[i][0] = S2[i][i];\n\t\tfor (j = 1; j < i; j++) {\n\t\t\tD[i][j] = 1e18;\n\t\t\tlong long u = S2[i][i] - S2[j][i] - S2[i][j] + S2[j][j];\n\t\t\tfor (k = 0; k < j; k++) {\n\t\t\t\tD[i][j] = min(D[i][j], D[j][k] + u + S[i][k] - S[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long res = 1e18;\n\tfor (i = 0; i < n; i++)res = min(res, D[n][i]);\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define ll long long\nusing namespace std;\nconst int N=505;\nint a[N][N],n;\nll S[N][N];\nll SSS[N][N],f[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) For(j,1,n) if (i!=j) scanf(\"%d\",&a[i][j]);\n\tFor(i,1,n) For(j,1,n) S[i][j]=S[i][j-1]+a[i][j];\n\tFor(i,1,n) For(j,1,n) SSS[i][j]=SSS[i-1][j]+a[i][j];\n\tFor(i,1,n) f[0][i]=f[0][i-1]+S[i][i];\n\tFor(i,0,n) For(j,i+1,n){\n\t\tll SSSS=0;\n\t\tFor(k,j+1,n){\n\t\t\tSSSS+=S[k][k]-S[k][i]+SSS[j][k];\n\t\t\tf[j][k]=max(f[j][k],f[i][j]+SSSS);\n\t\t}\n\t}\n\tll ans=0;\n\tFor(i,0,n-1) ans=max(ans,f[i][n]);\n\tFor(i,1,n) For(j,1,n) ans-=a[i][j];\n\tprintf(\"%lld\\n\",-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(505);\ntypedef long long int LL;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N;\nLL A[Max_N][Max_N], Sum1[Max_N][Max_N], Sum2[Max_N][Max_N], F[Max_N][Max_N], Ans;\n\ninline LL query1(int l1, int r1, int l2, int r2)\n{\n\treturn Sum1[r1][r2] - Sum1[l1 - 1][r2] - Sum1[r1][l2 - 1] + Sum1[l1 - 1][l2 - 1];\n}\n\ninline LL query2(int l1, int r1, int l2, int r2)\n{\n\treturn Sum2[r1][r2] - Sum2[l1 - 1][r2] - Sum2[r1][l2 - 1] + Sum2[l1 - 1][l2 - 1];\n}\n\ninline void upd(LL &a, LL b)\n{\n\ta = min(a, b);\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t\tgi(A[i][j]);\n\t\t\tSum1[i][j] = Sum1[i - 1][j] + Sum1[i][j - 1] - Sum1[i - 1][j - 1] + A[i][j] * (i < j);\n\t\t\tSum2[i][j] = Sum2[i - 1][j] + Sum2[i][j - 1] - Sum2[i - 1][j - 1] + A[i][j] * (i > j);\n\t\t}\n\tAns = Sum1[N][N];\n\tfor (int x = 1;x <= N - 1;++x)\n\t\tAns = min(Ans, query1(1, x, 1, x) + query2(x + 1, N, x + 1, N));\n\tmemset(F, 0X3F, sizeof(F));\n\tfor (int a = 1;a <= N - 1;++a)\n\t\tfor (int b = a + 1;b <= N - 1;++b)\n\t\t{\n\t\t\tupd(F[a][b], query1(1, a, 1, a) + query1(a + 1, b, a + 1, b) + query2(b + 1, N, 1, a));\n\t\t\tfor (int c = b + 1;c <= N - 1;++c)\n\t\t\t\tupd(F[b][c], F[a][b] + query1(b + 1, c, b + 1, c) + query2(c + 1, N, a + 1, b));\n\t\t\tupd(Ans, F[a][b] + query1(b + 1, N, b + 1, N));\n\t\t}\n\tprint(Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint a[505][505];\nlong long b[505][505],c[505][505],f[505][505];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)if(j!=i)scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++)b[i][j]=b[i][j-1]+a[i][j];\n\t\tfor(int j=n;j>=i;j--)c[i][j]=c[i][j+1]+a[j][i];\n\t}\n\tfor(int j=1;j<=n;j++){\n\t\tfor(int i=1;i<=j;i++)c[i][j]+=c[i-1][j];\n\t\tfor(int i=j;i>=1;i--)b[i][j]+=b[i+1][j];\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tfor(int x=1;x<=n;x++)\n\t\t\t\tfor(int y=1;y<=n;y++)\n\t\t\t\t\tif(x<y){\n\t\t\t\t\t\tif(x>=i&&y<=j)b[i][j]+=a[x][y];\n\t\t\t\t\t}else if(x>y){\n\t\t\t\t\t\tif(x>=j&&y<=i)c[i][j]+=a[x][y];\n\t\t\t\t\t}\n\t\t}\n\t*/\n\t/*\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++)printf(\"%lld \",b[i][j]);\n\t\tputs(\"\");\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++)printf(\"%lld \",c[i][j]);\n\t\tputs(\"\");\n\t}\n\t*/\n\tmemset(f,63,sizeof(f));\n\tfor(int i=2;i<=n;i++)f[i][1]=b[1][i-1]+c[0][i];\n\tfor(int i=3;i<=n+1;i++)\n\t\tfor(int j=2;j<i;j++)\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tf[i][j]=min(f[i][j],f[j][k]+c[j-1][i]-c[k-1][i]+b[j][i-1]);\n\tlong long ans=1e18;\n\tfor(int i=1;i<=n;i++)ans=min(ans,f[n+1][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    auto N    = in<int>();\n    auto fass = make_v({N, N}, 0LL);\n    auto bass = make_v({N, N}, 0LL);\n    ll btotal = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) { fsss[i][j] += fsss[i][j - 1], bsss[i][j] += bsss[i][j - 1]; }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) { fsss[i][j] += fsss[i - 1][j], bsss[i][j] += bsss[i - 1][j]; }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto dp   = make_v({N + 1, N + 1}, inf_v<ll>);\n    dp[0][0]  = 0;\n    for (int np = 0; np <= N; np++) {\n        for (int p = 0; p < np; p++) {\n            for (int pp = 0; pp <= p; pp++) {\n                const ll fore = fsum(pp, p, np);\n                const ll back = bsum(pp, p, np);\n                chmin(dp[p][np], fore + back + dp[pp][p]);\n            }\n        }\n    }\n    ll ans = inf_v<ll>;\n    for (int p = 0; p <= N; p++) { chmin(ans, dp[p][N]); }\n    outln(ans + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=5e2+10;\nnamespace MAIN{\n    int n;\n    int A[N][N];\n    LL dp[N][N],pre[N][N],suf[N][N];\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)\n            for(res j=1;j<=n;j++)\n                if(i!=j)A[i][j]=read();\n        for(res i=1;i<=n;i++){\n            for(res j=i+1;j<=n+1;j++){\n                pre[i][j]=pre[i][j-1];\n                for(res k=i;k<j;k++)pre[i][j]+=A[k][j];\n            }\n            for(res j=n;j>=i+1;j--){\n                suf[i][j]=suf[i][j+1];\n                for(res k=1;k<=i;k++)suf[i][j]+=A[j][k];\n            }\n        }\n        for(res i=0;i<=n+1;i++)\n            for(res j=0;j<=n+1;j++)\n                dp[i][j]=INF;\n        dp[0][0]=0;\n        for(res i=0;i<=n;i++)\n            for(res j=i;j<=n;j++)\n                if(dp[i][j]!=INF)\n                    for(res k=j+1;k<=n+1;k++)\n                        dp[j][k]=min(dp[j][k],dp[i][j]+pre[j+1][k]+suf[j][k+1]-suf[i][k+1]);\n        RG LL ans=INF;\n        for(res i=0;i<=n;i++)ans=min(ans,dp[i][n+1]);\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 505\nusing namespace std;\ntypedef long long ll;\n\nll n, ans=4e18, a[N][N], pl[N][N], mn[N][N], d[N][N];\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tll i, j, k, t;\n\tcin >> n;\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) if(i!=j) scanf(\"%lld\", &a[i][j]);\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) pl[i][j] = pl[i-1][j] + pl[i][j-1] - pl[i-1][j-1] + (i>j ? a[i][j] : 0);\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) mn[i][j] = mn[i-1][j] + mn[i][j-1] - mn[i-1][j-1] + (i<j ? a[i][j] : 0);\n\tfor(i=1; i<=n; i++) {\n\t\td[i][1] = mn[i][i];\n\t\tfor(j=2; j<=i; j++) {\n\t\t\td[i][j] = 4e18;\n\t\t\tt = mn[i][i] - mn[i][j-1] - mn[j-1][i] + mn[j-1][j-1];\n\t\t\tfor(k=1; k<j; k++) {\n\t\t\t\td[i][j] = min(d[i][j], d[j-1][k] + t + pl[i][k-1] - pl[j-1][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1; i<=n; i++) ans = min(ans, d[n][i]);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=505;\nconst long long INF=4557430888798830399;\nint n;\nint a[N][N];\nlong long s1[N][N],s2[N][N];\nlong long f[N][N];\nlong long calc1(int l1,int r1,int l2,int r2)\n{\n\tswap(l1,l2);\n\tswap(r1,r2);\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s1[r1][r2]-s1[l1-1][r2]-s1[r1][l2-1]+s1[l1-1][l2-1];\n}\nlong long calc2(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n\treturn s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<INF)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+calc1(i+1,j,k+1,n+1)+calc2(j+1,k,j+1,k));\n\tlong long res=INF;\n\tfor(int i=0;i<=n;i++)\n\t\tres=min(res,f[i][n+1]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 577;\nconst ll INF = LLONG_MAX / 2;\n\nint N;\nll A[MAX_N][MAX_N], cost1[MAX_N][MAX_N], cost2[MAX_N][MAX_N];\nll dp[MAX_N][MAX_N];\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i == j) continue;\n            scanf(\"%lld\", &A[i][j]);\n            if (i < j) cost1[i][j] = A[i][j];\n            else cost2[j][i] = A[i][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i][j - 1];\n        }\n    }\n    for (int i = N; i; i--) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i + 1][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = N; j; j--) {\n            cost2[i][j] += cost2[i][j + 1];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost2[i][j] += cost2[i - 1][j];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        dp[0][i] = cost1[1][i];\n        for (int j = 1; j < i; j++) {\n            dp[j][i] = INF;\n            for (int k = 0; k < j; k++) {\n                dp[j][i] = min(dp[j][i], dp[k][j] + cost1[j + 1][i] + cost2[j][i + 1] - cost2[k][i + 1]);\n            }\n        }\n    }\n    ll ans = INF;\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < i; j++) {\n            ans = min(ans, dp[j][i] + cost1[i + 1][N]);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt a[540][540];\nInt n;\nInt dp[540][540];\nInt minuss[540][540];\nInt pluss[540][540];\nInt calc(Int i, Int j, Int k){\n    Int res = minuss[j][k] + pluss[0][k] + pluss[i][j] - pluss[0][j] - pluss[i][k];\n//    cout << i << \" \" << j << \" \" << k << \":\" << res << endl;\n    return res;\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < n;j++){\n            if(i == j)continue;\n            cin >> a[i][j];\n        }\n    }\n    for(Int k = 2;k <= n;k++){\n        for(Int i = 0;i + k <= n;i++){\n            Int j = i + k;\n            minuss[i][j] = minuss[i][j-1] + minuss[i+1][j] - minuss[i+1][j-1] + a[i][j-1];\n            pluss[i][j] = pluss[i][j-1] + pluss[i+1][j] - pluss[i+1][j-1] + a[j-1][i];\n//            cout << i << \" \" << j << \" \" << minuss[i][j] << \" \" << pluss[i][j] << endl;\n        }\n    }\n    for(Int i = 1;i <= n;i++){\n        dp[0][i] = minuss[0][i];\n        \n        //      cout << \"dp[\"<< 0 <<\"][\" << i <<\"]: \" << dp[0][i] << endl;\n    }\n\n    for(Int i = 1;i < n;i++){\n        for(Int j = i+1;j <= n;j++){\n            dp[i][j] = LINF;\n            for(Int k = 0;k < i;k++){\n                dp[i][j] = min(dp[i][j], dp[k][i] + calc(k, i, j));\n            }\n//            cout << \"dp[\"<< i <<\"][\" << j <<\"]: \" << dp[i][j] << endl;\n        }\n    }\n    Int res = LINF;\n    for(Int i = 0;i < n;i++){\n        res = min(res, dp[i][n]);\n    }\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=508,p=998244353,inf=0x3f3f3f3f;\nint read(){\n    int f=1,g=0;char ch=getchar();\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n    for (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n    return f*g;\n}\nint n,m;\nll a[N][N],b[N][N],f[N][N];\nll getsum(ll a[][N],int lx,int ly,int rx,int ry)\n{return a[rx][ry]-a[rx][ly-1]-a[lx-1][ry]+a[lx-1][ly-1];}\nvoid chkmin(ll &x,ll y){if (x>y) x=y;}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<i;j++) b[i][j]=read();\n\t\tfor (int j=i+1;j<=n;j++) a[i][j]=read();\n\t\tfor (int j=1;j<=n;j++)\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1],\n\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfor (int i=0;i<n;i++)\n\tfor (int j=0;j<=max(i-1,0);j++)\n\tfor (int k=i+1;k<=n;k++)\n\tchkmin(f[k][i],f[i][j]+getsum(a,i+1,i+1,k,k)+getsum(b,k+1,j+1,n,i));\n\tll ans=f[n][0];\n\tfor (int i=1;i<n;i++) chkmin(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    const auto N = in<int>();\n    auto fass    = make_v({N, N}, 0LL);\n    auto bass    = make_v({N, N}, 0LL);\n    ll btotal    = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            fsss[i][j] += fsss[i][j - 1];\n            bsss[i][j] += bsss[i][j - 1];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            fsss[i][j] += fsss[i - 1][j];\n            bsss[i][j] += bsss[i - 1][j];\n        }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto memo = make_v({N + 1, N + 1}, -1LL);\n    auto dp   = mfp([&](auto&& self, const int pp, const int p) -> ll {\n        if (p == N) { return 0; }\n        if (memo[pp][p] != -1LL) { return memo[pp][p]; }\n        ll ans = inf_v<ll>;\n        for (int np = p + 1; np <= N; np++) {\n            const ll fore = fsum(pp, p, np);\n            const ll back = bsum(pp, p, np);\n            SHOW(pp, p, np, fore);\n            SHOW(pp, p, np, back);\n            chmin(ans, fore + back + self(self, p, np));\n        }\n        SHOW(pp, p, ans);\n        return memo[pp][p] = ans;\n    });\n    SHOW(btotal);\n    outln(dp(0, 0) + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 505;\n\nint n;\nlint sum[MAXN][MAXN], dp[MAXN][MAXN];\n\nlint gs12117(int sx, int ex, int sy, int ey){\n\treturn sum[ex][ey] - sum[sx-1][ey] - sum[ex][sy-1] + sum[sx-1][sy-1];\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tlint dn = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tint x = 0;\n\t\t\tif(i != j) scanf(\"%d\",&x);\n\t\t\tif(i < j) dn += x;\n\t\t\tsum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + x;\n\t\t}\n\t}\n\tmemset(dp, 0x3f, sizeof(dp)); \n\tfor(int i=1; i<n; i++) dp[1][i] = 0;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=1; j<=i; j++){\n\t\t\tfor(int k=i+1; k<=n; k++){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k], \n\t\t\t\tdp[j][i] - gs12117(j, i, i + 1, n) + gs12117(k + 1, n, j, i));\n\t\t\t}\n\t\t}\n\t}\n\tlint dap = 1e18;\n\tfor(int j=2; j<=n; j++){\n\t\tdap = min(dap,dn + dp[j][n]);\n\t}\n\tcout << dap << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    auto N    = in<int>();\n    auto fass = make_v({N, N}, 0LL);\n    auto bass = make_v({N, N}, 0LL);\n    ll btotal = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            fsss[i][j] += fsss[i][j - 1];\n            bsss[i][j] += bsss[i][j - 1];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            fsss[i][j] += fsss[i - 1][j];\n            bsss[i][j] += bsss[i - 1][j];\n        }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto memo = make_v({N + 1, N + 1}, -inf_v<ll>);\n    auto dp   = mfp([&](auto&& self, const int pp, const int p) -> ll {\n        if (p == N) { return 0; }\n        if (memo[pp][p] != -inf_v<ll>) { return memo[pp][p]; }\n        ll ans = inf_v<ll>;\n        for (int np = p + 1; np <= N; np++) {\n            const ll fore = fsum(pp, p, np);\n            const ll back = bsum(pp, p, np);\n            chmin(ans, fore + back + self(self, p, np));\n        }\n        return memo[pp][p] = ans;\n    });\n    outln(dp(0, 0) + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nint a[510][510]={};\nint b[510][510]={};\n\nint dp[2][510][510];\n\nsigned main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\t\n\tint n;\n\tcin>>n;\n\tint zen=0;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j){\n\t\tif(i<j){\n\t\t\tcin>>a[j][i];\n\t\t\tzen+=a[j][i];\n\t\t}\n\t\telse{\n\t\t\tcin>>b[i][j];\n\t\t\tzen+=b[i][j];\n\n\t\t}\n\t}\n\tfor(int j=1;j<=n;j++){\n\t\tfor(int i=1;i<=n;i++)a[j][i]+=a[j][i-1],b[j][i]+=b[j][i-1];\n\t}\n\t\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[1][i][j]=-1;\n\tdp[1][0][1]=0;\n\tfor(int t=1;t<n;t++){\n\t\tint f=t%2;\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)dp[1-t%2][i][j]=-1;\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)if(dp[f][i][j]>=0){\n\t\t\t{\n\t\t\t\tint g=a[t+1][t]+b[t+1][t+1]-b[t+1][t-j];\n\t\t\t\tdp[1-f][j][1]=max(dp[1-f][j][1],dp[f][i][j]+g);\n\t\t\t}\n\t\t\t{\n\t\t\t\tint g=a[t+1][t-j]+b[t+1][t+1]-b[t+1][t-i-j];\n\t\t\t\tdp[1-f][i][j+1]=max(dp[1-f][i][j+1],dp[f][i][j]+g);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tint ans=-1;\n\t\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)ans=max(dp[n%2][i][j],ans);\n//\tcout<<ans<<endl;\n\tcout<<zen-ans<<endl;\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#define __AVX__ 1\n#define __AVX2__ 1\n#define __SSE__ 1\n#define __SSE2__ 1\n#define __SSE2_MATH__ 1\n#define __SSE3__ 1\n#define __SSE4_1__ 1\n#define __SSE4_2__ 1\n#define __SSE_MATH__ 1\n#define __SSSE3__ 1\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")\n#define cmax(a,b) ((a)>(b))\n#include <immintrin.h>\n#include<bits/stdc++.h>\n__m128i a[1033333/4+1],a2[2033333/4+1];\nunsigned int b[1033333],a1[1033333];\n#define re register\nint main()\n{\n\tsrand(time(0));rand();rand();\n\tre double xl1=0,xl2=0;\n\tre unsigned int x=rand(),y=rand(),*aa=(unsigned int *)&a,*aa2=(unsigned int *)&a2;\n\tfor(re int i=0;i<1033333;i++)\n\t{\n\t\taa2[i]=a1[i]=x,x^=x<<13,x^=x>>17,x^=x<<5;\n\t\taa[i]=b[i]=y,y^=y<<13,y^=y>>17,y^=y<<5;\n\t}\n\tfor(re int ii=1;ii<=500;ii++){\n\tre double xl=clock();\n\tfor(re int i=0;i<1033333/4+1;i++)a[i]=_mm_xor_si128(a[i],a2[i]),_mm_add_epi32(a[i],a2[i]),_mm_and_si128(a[i],a2[i]),_mm_max_epi32(a[i],a2[i]);\n\txl1+=clock()-xl;xl=clock();\n\tfor(re int i=0;i<1033333;i++)b[i]^=a1[i],b[i]+=a1[i],b[i]&=a1[i],b[i]=cmax(b[i],a1[i]);\n\txl2+=clock()-xl;\n\t}\n\tprintf(\"%.10lf %.10lf\\n\",xl1,xl2);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 511;\nint n;\nint t[MAX][MAX];\nint sum_z[MAX][MAX];\nint sum_do[MAX][MAX];\nint dp[MAX][MAX];\nconst int inf = 1e15;\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  int all = 0;\n  R(i,n)R(j,n){\n    if(i != j){\n      cin >> t[i][j];\n      all += t[i][j];\n    }\n  }\n  R(i,n)for(int j = i; j>=0;j--){\n    sum_z[i][j] = sum_z[i][j + 1] + t[i][j];\n  }\n  R(i,n)R(j,n){\n    sum_do[i][j+1] = sum_do[i][j] + t[j][i];\n  }\n  R(i,n){\n    R(ko,i+1)R(po,ko+1){\n      dp[ko][po] += sum_z[i][po] + sum_do[i][ko];\n      maxi(dp[i+1][ko], dp[ko][po]);\n    }\n    \n  }\n  int res = 0;\n  R(i,n){\n    maxi(res, dp[n][i]);\n  }\n  cout << all - res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint a[510][510];\nlong long f[510][510],sum[510][510],cnt[510][510];\ninline long long mymin(long long a,long long b)\n{\n\tif(a>b)swap(a,b);\n\tif(a==0)return b;\n\telse return a;\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read();\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)if(i!=j)a[i][j]=read();\n    }\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)sum[i][j]=sum[i][j-1]+a[i][j];\n    }\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)cnt[i][j]=cnt[i][j-1]+sum[j][i]-sum[j][j-1];\n    }\n    for(int i=n-1;i>=1;i--)\n    {\n    \tfor(int j=i+1;j<=n;j++)\n    \t{\n    \t\tf[i][j]=cnt[j-1][j-1]-cnt[j-1][i-1];\n    \t\tlong long tot=0,mn=0,uf=0;\n    \t\tfor(int k=n;k>=j;k--)\n    \t\t{\n    \t\t\ttot+=sum[k][j-1]-sum[k][i-1];\n    \t\t\tuf+=sum[k][n]-sum[k][k-1];\n    \t\t\tif(k==j)mn=mymin(mn,uf);\n    \t\t\telse mn=mymin(mn,f[j][k]+tot);\n    \t\t}f[i][j]+=mn;\n    \t}\n    }long long ans=f[1][2];\n    for(int i=3;i<=n;i++)ans=min(ans,f[1][i]);\n    printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nll w[505][505];\nll dp[505][505];\nll sum[505][505];\nll tot[505][505];\ninline ll calc(int a,int b,int c,int d){\n\treturn sum[b][d]-(a==0?0:sum[a-1][d])-(c==0?0:sum[b][c-1])-(a==0||b==0?0:sum[a-1][c-1]);\n}\nint main(){\n\tfreopen(\"park.in\",\"r\",stdin);\n\tfreopen(\"park.out\",\"w\",stdout); \n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tscanf(\"%d\",&w[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i-1][j]+tot[i][j-1]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=1e18;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1]+calc(j,i,0,k-1));\n\t\t} \n\t}\t\t\n\tll ans=1e18;\n\tfor(int i=1;i<=n;i++) ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=510;\nconst int p=998244353;\n#define ll long long\nll i,j,k,n,m,x,y,t,a[N][N];\nll w[N][N],r[N][N],f[N][N];\nll val(ll a,ll b,ll c){return w[b][c]-w[a-1][c];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)for(j=1;j<=n;j++)if(i!=j)scanf(\"%d\",&a[i][j]);\n\tfor (i=1;i<=n;i++)for(j=n;j>=i+1;j--){w[i][j]=w[i][j+1];for (k=1;k<=i;k++)w[i][j]+=a[j][k];}\n\tfor (i=1;i<=n;i++)for(j=i+1;j<=n+1;j++){r[i][j]=r[i][j-1];for (k=i;k<=j-1;k++)r[i][j]+=a[k][j];}\n    memset(f,0x3f,sizeof(f));\n\tf[0][0]=0;for(i=0;i<=n;i++)for(j=i;j<=n;j++)if(f[i][j]<1e18){for(k=j+1;k<=n+1;k++)f[j][k]=min(f[j][k],f[i][j]+r[j+1][k]+val(i+1,j,k+1));}\n    ll ans=1e18;for(i=0;i<=n;i++)ans=min(ans,f[i][n+1]);\n\treturn printf(\"%lld\\n\",ans),0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\n#define int long long\nnamespace run{\n\tconst int N=509;\n\tint n,A[N][N],f[N][N],sum[N][N],g[N][N];\n\tint main(){\n\t\tn=read<int>();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++) if(i^j)\n\t\t\t\tA[i][j]=read<int>();\n\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++) sum[i][j]=A[i][j]+sum[i][j-1],g[i][j]=(i>=j?A[i][j]:0)+g[i][j-1];\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int i=1;i<=n;i++) sum[i][j]+=sum[i-1][j],g[i][j]+=g[i-1][j];\n\t\n\t\tfor(int i=1;i<=n;i++) f[0][i]=g[i][i];\n\t\tint ans=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tfor(int j=0;j<i;j++)\n\t\t\t\tfor(int k=j+1;k<i;k++){\n\t\t\t\t\tf[k][i]=max(f[k][i],f[j][k]+sum[k][i]-sum[k][k]+sum[i][k]-sum[i][j]-sum[k][k]+sum[k][j]+g[i][i]+g[k][k]-g[i][k]-g[k][i]);\n\t\t\t\t\tif(i==n) ans=max(ans,f[k][i]);\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum[n][n]-ans);\n\t\treturn 0;\n\t}\n}\n#undef int\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[1010][1010];\nint B[1010][1010];\nll SA[1010][1010];\nll SB[1010][1010];\nll dp[1010][1010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(x,N) FOR(y,N) {\n\t\tif(x<y) cin>>A[x][y];\n\t\tif(x>y) cin>>B[x][y];\n\t\tSA[x+1][y+1]=SA[x][y+1]+SA[x+1][y]-SA[x][y]+A[x][y];\n\t\tSB[x+1][y+1]=SB[x][y+1]+SB[x+1][y]-SB[x][y]+B[x][y];\n\t}\n\t\n\t\n\tFOR(y,N+1) FOR(x,N+1) dp[y][x]=1LL<<60;\n\tfor(i=1;i<=N;i++) {\n\t\tdp[0][i]=SA[i][i];\n\t}\n\tll ret=dp[0][N];\n\tfor(int l=0;l<N;l++) {\n\t\tfor(int r=l+1;r<N;r++) {\n\t\t\tfor(int x=r+1;x<=N;x++) {\n\t\t\t\t\n\t\t\t\tdp[r][x]=min(dp[r][x],dp[l][r]+SA[x][x]-SA[r][x]-SA[x][r]+SA[r][r]+SB[x][l]-SB[r][l]);\n\t\t\t\tif(x==N) ret=min(ret,dp[r][x]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 501;\n\nll M[MAXN][MAXN] = {0};\nll A[MAXN][MAXN] = {0};\nll B[MAXN][MAXN] = {0};\n\n\nint DP1[MAXN][MAXN][2] = {0};\nbool DP1C[MAXN][MAXN][2] = {0};\n\nint dp1(int i, int j, int kind){\n    if(i > j)return 0;\n    if(kind == -1)return j-i+1;\n    if(DP1C[i][j][kind])return DP1[i][j][kind];\n    int ans = dp1(i,j-1,kind) + dp1(j,n-1,kind-1);\n    DP1[i][j][kind] = ans;\n    DP1C[i][j][kind] = 1;\n    return ans;\n}\n\nint enumerate(int a, int b, int c){\n    return dp1(0, a-1, 1) + dp1(a, b-1, 0) + dp1(b, c-1, -1);\n}\n\nll DP[20958500] = {0};\nbool DPC[20958500] = {0};\n\nll dp(int a, int b, int c){\n    if(a < 0)return 0;\n    int h = enumerate(a,b,c);\n    if(DPC[h])return DP[h];\n    ll ans1 = A[a][b] + B[a][c] + dp(a-1,b,c);\n    ll ans2 = big*big;\n    if(b > a+1)ans2 = A[a][a+1] + B[a][b-1] + dp(a-1,a+1,b-1);\n    ll ans3 = B[a][a] + dp(a-1, a, a);\n\n    ll ans = ans1;\n    ll pek = 0;\n    if(ans2 < ans){\n        ans = ans2;\n        pek = 1;\n    }\n    if(ans3 < ans){\n        ans = ans3;\n        pek = 2;\n    }\n\n    DPC[h] = 1;\n    DP[h] = ans;\n    //cerr << a << \" \" << b << \" \" << c << \"   pek: \" << pek << \"  ans: \" << ans << \"\\n\";\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n    cin >> n;\n\n    rep(c1,0,n){\n        rep(c2,0,n-1){\n            cin >> a;\n            int c3 = c2;\n            if(c2 >= c1)c3++;\n            M[c1][c3] = a;\n        }\n    }\n\n    rep(c1,0,n){\n        a = 0;\n        rep(c2,c1+1,n+1){\n            A[c1][c2] = a;\n            a += M[c1][c2];\n        }\n        a = 0;\n        for(int c2 = n-1; c2 >= c1; c2--){\n            B[c1][c2] = a;\n            a += M[c2][c1];\n        }\n    }\n    ll temp = big*big;\n    ll extra = 0;\n    for(int c1 = n-1; c1 > 0; c1--){\n        extra += A[c1][n];\n        temp = min(temp, dp(c1,c1+1,n-1) + extra);\n    }\n\n    cout << temp << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define N 505\nusing namespace std;\ntypedef long long ll;\n\nll n, ans=4e18, a[N][N], pl[N][N], mn[N][N], d[N][N];\nint main() {\n\tll i, j, k, t;\n\tcin >> n;\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) if(i!=j) scanf(\"%lld\", &a[i][j]);\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) pl[i][j] = pl[i-1][j] + pl[i][j-1] - pl[i-1][j-1] + (i>j ? a[i][j] : 0);\n\tfor(i=1; i<=n; i++) for(j=1; j<=n; j++) mn[i][j] = mn[i-1][j] + mn[i][j-1] - mn[i-1][j-1] + (i<j ? a[i][j] : 0);\n\tfor(i=1; i<=n; i++) {\n\t\td[i][1] = mn[i][i];\n\t\tfor(j=2; j<=i; j++) {\n\t\t\td[i][j] = 4e18;\n\t\t\tt = mn[i][i] - mn[i][j-1] - mn[j-1][i] + mn[j-1][j-1];\n\t\t\tfor(k=1; k<j; k++) {\n\t\t\t\td[i][j] = min(d[i][j], d[j-1][k] + t + pl[i][k-1] - pl[j-1][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1; i<=n; i++) ans = min(ans, d[n][i]);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=510;\nll a[N][N],b[N][N],f[N][N],g[N][N],dp[N][N],ans=LLONG_MAX;\nint n;\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<i;++j)cin>>b[j][i-1];\n\t\tfor(int j=i+1;j<=n;++j)cin>>a[i][j-1];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j){\n\t\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\t\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i;j<=n;++j){\n\t\t\tf[i][j]=a[j][j]+a[i-1][i-1]-a[i-1][j]-a[j][i-1];\n\t\t\tg[i][j]=b[i][n]-b[i][j-1];\n\t\t}\n\tmemset(dp,0x3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=0;j<i;++j)\n\t\t\tfor(int k=j;k<i;++k)dp[k][i]=min(dp[k][i],dp[j][k]+f[k+1][i-1]+g[k][i]-g[j][i]);\n\tfor(int i=0;i<=n;++i)ans=min(ans,dp[i][n]);\n\tcout<<ans<<'\\n';\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\n#define rll register ll\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=5e2+5;\nconst ll inf=1e18;\nll dp[N][N],a[2][N][N];\ninline ll query(ri d,ri x1,ri x2,ri y1,ri y2){\n\treturn x1>x2||y1>y2?0:a[d][x2][y2]-a[d][x1-1][y2]-a[d][x2][y1-1]+a[d][x1-1][y1-1];\n}\nint main(){\n\tri n,i,j,k;\n\tgi(n);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=1;j<=n;++j)\n\t\t\tif(i!=j){\n\t\t\t\tgi(k);\n\t\t\t\tif(i<j)\n\t\t\t\t\ta[0][i][j]=k;\n\t\t\t\telse\n\t\t\t\t\ta[1][i][j]=k;\n\t\t\t}\n\tfor(k=0;k<=1;++k)\n\t\tfor(i=1;i<=n;++i)\n\t\t\tfor(j=1;j<=n;++j)\n\t\t\t\ta[k][i][j]+=a[k][i-1][j]+a[k][i][j-1]-a[k][i-1][j-1];\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=0;j<=n;++j)\n\t\t\tdp[i][j]=1e18;\n\tdp[0][0]=0;\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=i;j<=n;++j)\n\t\t\tif(dp[i][j]!=inf)\n\t\t\t\tfor(k=j+1;k<=n;++k)\n\t\t\t\t\tdp[j][k]=min(dp[j][k],dp[i][j]+query(0,i+1,j,i+1,j)+query(1,k+1,n,i+1,j));\n\trll ans=inf;\n\tfor(i=0;i<=n;++i)\n\t\tfor(j=i;j<=n;++j)\n\t\t\tif(dp[i][j]!=inf)\n\t\t\t\tans=min(ans,dp[i][j]+query(0,i+1,j,i+1,j)+query(0,j+1,n,j+1,n));\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 505;\nconst ll INF = (ll)1e18;\nll a[N][N];\nll b[N][N];\nll dp[N][N];\nint n;\n\nll getSum(int l, int r, int x, int y) {\n\treturn a[l][x] + a[r][y] - a[l][y] - a[r][x];\n}\nll getCost(int i, int j, int k) {\n\treturn getSum(k, n, i, j) + b[j][k];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i != j)\n\t\t\t\tscanf(\"%lld\", &a[i + 1][j + 1]);\n\t\t\ta[i + 1][j + 1] += a[i + 1][j] + a[i][j + 1] - a[i][j];\n\t\t}\n\tfor (int len = 1; len <= n; len++) {\n\t\tfor (int l = 0; l + len <= n; l++) {\n\t\t\tint r = l + len;\n\t\t\tb[l][r] = b[l + 1][r] + getSum(l, l + 1, l, r);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i; j <= n; j++)\n\t\t\tdp[i][j] = INF;\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[0][i] = b[0][i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\tdp[j][k] = min(dp[j][k], dp[i][j] + getCost(i, j, k));\n\t\t\t}\n\tll ans = INF;\n\tfor (int i = 0; i < n; i++)\n\t\tans = min(ans, dp[i][n]);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nint main() {\n  int n;\n  cin >> n;\n  vll a(n, vl(n));\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) {\n        a[i][j] = INF;\n      }\n      else {\n        cin >> a[i][j];\n      }\n    }\n  }\n\n  vll max_cost(n, vl(n));\n  vll sum_cost(n, vl(n));\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      sum_cost[i][j] = sum_cost[i][j - 1];\n      for (int k = i; k < j; k++) {\n        sum_cost[i][j] += a[k][j];\n      }\n    }\n  }\n\n\n  vector<vll> rem_cost(n, vll(n, vl(2, INF)));\n  rep (i, n) {\n    for (int j = i + 1; j< n; j++) {\n      rem_cost[i][j][0] = sum_cost[i][j];\n    }\n  }\n\n\n  for (int len = 1; len <= n; len++) {\n    rep (i, n) {\n      int j = i + len;\n      if (j >= n) break;\n      if (i + 1 == j) {\n        rem_cost[i][j][1] = 0;\n        continue;\n      }\n      for (int d = j - 1; d >= i; d--) {\n        chmin(rem_cost[i][j][1], rem_cost[i][d][1] + rem_cost[d][j][0]);\n        chmin(rem_cost[i][j][1], rem_cost[i][d][0] + rem_cost[d][j][1]);\n      }\n      chmin(rem_cost[i][j][1], sum_cost[i][j] - a[i][j]);\n    }\n  }\n  \n  vll prot_cost(n, vl(n));\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      prot_cost[i][j] = prot_cost[i][j - 1];\n      for (int k = i; k < j; k++) {\n        prot_cost[i][j] += a[j][k];\n      }\n    }\n  }\n\n  /*\n  DEBUG_MAT(prot_cost);\n  cout << \"rem_cost\" << endl;\n  rep (i, n) {\n    rep (j, n) {\n      cout << rem_cost[i][j][1] << \" \";\n    }\n    cout << endl;\n  }\n  //*/\n\n  vl dp(n, INF);\n  dp[0] = prot_cost[0][n - 1];\n  rep (i, n) {\n    for (int j = i + 1; j < n; j++) {\n      dp[j] = min(dp[j], dp[i] + rem_cost[i][j][1] - prot_cost[i][j]);\n    }\n  }\n  \n  //DEBUG_VEC(dp);\n  cout << dp[n - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll a[555][555];\nll pr[555][555];\nll pl[555][555];\n\nll suml(int r, int al, int ar)\n{\n\tal=max(al,0);\n\tif(al==0) return pl[r][ar];\n\treturn pl[r][ar]-pl[r][al-1];\n}\n\nll sumr(int r, int al, int ar)\n{\n\tal=max(al,0);\n\tif(al==0) return pr[r][ar];\n\treturn pr[r][ar]-pr[r][al-1];\n}\n\nll dp[511][511][511];\n\nvoid amin(ll &x, ll y)\n{\n\tif(y<x) x=y;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tpl[i][j]=a[j][i];\n\t\t\tif(j>0) pl[i][j]+=pl[i][j-1];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tpr[i][j]=a[i][j];\n\t\t\tif(j>0) pr[i][j]+=pr[i][j-1];\n\t\t}\n\t}\n\tconst ll INF = ll(1e18);\n\tfor(int k=0;k<=n;k++)\n\t{\n\t\tfor(int i=0;i<=k;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t{\n\t\t\t\tdp[k][i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdp[1][0][0]=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tll ans = dp[i][j][k];\n\t\t\t\tif(ans>=INF) continue;\n\t\t\t\t//cerr<<\"DP \"<<i<<' '<<j<<' '<<k<<'\\n';\n\t\t\t\t//cerr<<i+1<<' '<<j<<' '<<k<<' '<<ans+suml(i,j,i-1)+sumr(i,0,k-1)<<'\\n';\n\t\t\t\t//cerr<<i+1<<' '<<i<<' '<<j<<' '<<ans+sumr(i,0,j-1)<<'\\n';\n\t\t\t\tamin(dp[i+1][j][k],ans+suml(i,j,i-1)+sumr(i,0,k-1)); //extend\n\t\t\t\tamin(dp[i+1][i][j],ans+sumr(i,0,j-1));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tamin(ans,dp[n][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 505;\n\nll d[MX][MX];\nll e[MX][MX];\nll dp[MX][MX];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vvi a(n,vi(n));\n  rep(i,n)rep(j,n) {\n    if (i == j) continue;\n    scanf(\"%d\",&a[i][j]);\n  }\n  rep(l,n) {\n    ll x = 0;\n    srep(r,l,n) {\n      srep(i,l,r) x += a[i][r];\n      e[l][r+1] = x;\n    }\n  }\n  rep(l,n) {\n    ll x = 0;\n    srep(r,l,n) {\n      srep(i,l,r) x += a[r][i];\n      d[l][r+1] = x;\n    }\n  }\n  rep(i,n+1)rep(j,n+1) dp[i][j] = LINF;\n  dp[0][0] = d[0][n];\n  rep(i,n)srep(j,i,n) {\n    srep(k,j+1,n+1) {\n      ll now = dp[i][j];\n      now += e[j][k];\n      now -= d[i][k] - d[i][j];\n      mins(dp[j][k], now);\n    }\n  }\n  ll ans = LINF;\n  rep(i,n) mins(ans, dp[i][n]);\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define re(a,n) reverse(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=500+100;\nconst int inf=0x3f3f3f3f;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n;\nll a[twx][twx];\nll s[2][twx][twx];\nll asd[twx][twx];\nvoid update(ll &x,ll y)\n{\n    x=x<y?x:y;\n}\nll sum(int t,int lx,int rx,int ly,int ry)\n{\n    return s[t][rx][ry]-s[t][lx-1][ry]-s[t][rx][ly-1]+s[t][lx-1][ly-1];\n}\nvoid init()\n{\n\tn=read();\n    f1(1,n,i)\n    {\n        f1(1,n,j)\n        {\n            if(j==i)\n            {\n                continue ;\n            }\n            a[i][j]=read();\n        }\n    }\n    f1(1,n,i)\n    {\n        f1(1,n,j)\n        {\n            if(i<j) \n            {\n                s[0][i][j]=a[i][j];\n            }\n            s[0][i][j]+=s[0][i][j-1];\n        }\n        f1(1,n,j)\n        {\n            s[0][i][j]+=s[0][i-1][j];\n        }\n    }\n    f1(1,n,i)\n    {\n        f1(1,n,j)\n        {\n            if(i>j)\n            {\n                s[1][i][j]=a[i][j];\n            }\n            s[1][i][j]+=s[1][i][j-1];\n        }\n        f1(1,n,j)\n        {\n            s[1][i][j]+=s[1][i-1][j];\n        }\n    }\n    memset(asd,42,sizeof(asd));\n    asd[0][0]=0ll;\n    f1(0,n,i)\n    {\n        f1(0,(int)(max(i,1)-1),j)\n        {\n            f1(i+1,n,k)\n            {\n                ll tmp=asd[i][j]+sum(1,k+1,n,j+1,i)+sum(0,i+1,k,i+1,k);\n                update(asd[k][i],tmp);\n            }\n        }\n    }\n    ll ans=asd[n][1];\n    f1(1,n,i)\n    {\n        update(ans,asd[n][i]);//哪一位q[i]是1都可以，取最小。\n    }\n    printf(\"%lld\\n\",ans);\n}\nvoid work()\n{\n\t\n}\nvoid print()\n{\n\t\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n    init();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\n#define ll long long\n\nconst ll llf = (signed ll) (~0ull >> 2);\n\nconst int N = 505;\n\nint n;\nint A[N][N];\nll s[N][N];\nll dp[N][N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (i == j) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscanf(\"%d\", A[i] + j);\n\t\t\ts[i][j] = A[i][j] + s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tdp[i][j] = llf;\n\tdp[1][1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[1][i] = dp[1][i - 1];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tdp[1][i] += A[j][i];\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tll cost = 0;\n\t\tfor (int b = i - 1; b; b--) {\n\t\t\tfor (int j = b + 2; j <= i; j++)\n\t\t\t\tcost += A[b + 1][j];\n\t\t\tfor (int a = b; a; a--) {\n\t\t\t\tdp[b + 1][i] = min(dp[b + 1][i], dp[a][b] + cost + s[i][a - 1] - s[b][a - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = llf;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = min(ans, dp[i][n]);\n\tprintf(\"%lld\\n\", ans);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 505;\n\nint n;\nll sumA[Maxn][Maxn];\nll all;\nll A[Maxn][Maxn], B[Maxn][Maxn], C[Maxn][Maxn];\nll rem;\n\nll Get(int row, int c1, int c2)\n{\n    return c1 > c2? 0: sumA[row][c2] - sumA[row][c1 - 1];\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            int a;\n            if (i == j) a = 0;\n            else scanf(\"%d\", &a);\n            sumA[i][j] = a + sumA[i][j - 1];\n            all += a;\n        }\n    for (int i = 1; i <= n; i++)\n        rem += Get(i, 1, i - 1);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 1; k <= i; k++)\n                A[i][j] += Get(k, j, n);\n            for (int k = i + 1; k < j; k++)\n                A[i][j] += Get(k, j + 1, n);\n        }\n    for (int i = 1; i <= n; i++)\n        for (int j = i; j <= n; j++) {\n            for (int k = i; k < j; k++)\n                B[i][j] += Get(k, j, n);\n        }\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) {\n            for (int k = 1; k < j; k++)\n                C[i][j] += Get(k, 1, k - 1);\n            for (int k = j; k <= n; k++)\n                C[i][j] += Get(k, i + 1, k - 1);\n        }\n    ll mx = 0;\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) {\n            mx = max(mx, A[i][j] + rem);\n            for (int k = j + 1; k <= n; k++)\n                mx = max(mx, A[i][j] + B[j][k] + C[i][k]);\n        }\n    cout << all - mx << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define MN 501\n\ntypedef long long ll;\n\nint n;\nll f[MN][MN][MN], a[MN][MN];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j < i; j++) scanf(\"%lld\", &a[i][j]), a[i][j] += a[i][j - 1];\n\t\tfor(int j = i + 1; j <= n; j++) scanf(\"%lld\", &a[i][j]), a[i][j] += a[i - 1][j]; \n\t}\n\tmemset(f, 0x3f, sizeof(f)); f[0][0][0] = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tfor(int k = 0; k <= j; k++)\n\t\t\t{\n\t\t\t\tf[i + 1][i][j] = std::min(f[i + 1][i][j], f[i][j][k] + a[i + 1][j]);\n\t\t\t\tf[i + 1][j][k] = std::min(f[i + 1][j][k], f[i][j][k] + a[i][i + 1] - a[j][i + 1] + a[i + 1][k]); \n\t\t\t}\n\tll ans = 1e18;\n\tfor(int j = 0; j <= n; j++)\n\t\tfor(int k = 0; k <= j; k++) ans = std::min(ans, f[n][j][k]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< vector<cat> > A_sum_pos(N, vector<cat>(N+1, 0));\n\tvector< vector<cat> > A_sum_neg(N, vector<cat>(N+1, 0));\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < i; j++) cin >> A_sum_pos[i][j];\n\t\tfor(int j = i+1; j < N; j++) cin >> A_sum_neg[j][i];\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) A_sum_neg[i][j+1] += A_sum_neg[i][j];\n\t\tfor(int j = i-1; j >= 0; j--) A_sum_pos[i][j] += A_sum_pos[i][j+1];\n\t}\n\tvector< vector<cat> > sum(N, vector<cat>(N, 0));\n\tfor(int i = 1; i < N; i++) sum[i][0] = sum[i-1][0] + A_sum_pos[i][0];\n\tfor(int i = 0; i < N; i++) for(int j = 0; j <= i; j++) {\n\t\tcat sp = 0, sn = 0;\n\t\tfor(int k = i+1; k < N; k++) {\n\t\t\tsp += A_sum_pos[k][j];\n\t\t\tsn += A_sum_neg[k][i];\n\t\t\tsum[k][i+1] = max(sum[k][i+1], sum[i][j] + sp + sn);\n\t\t}\n\t}\n\tcat max_sum = 0;\n\tfor(int i = 0; i < N; i++) max_sum = max(max_sum, sum[N-1][i]);\n\tcat ans = -max_sum;\n\tfor(int i = 0; i < N; i++) ans += A_sum_pos[i][0] + A_sum_neg[i][N];\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nint A[511][511];\n\nLL M[511][511];\nLL P[511][511];\n\nLL MINUS(int l, int r) {\n    LL tmp = M[r][r] - M[r][l] - M[l][r] + M[l][l];\n    LL ret = 0;\n    for (int i=l; i<r; i++) for (int j=i+1; j<r; j++) {\n        ret += A[i][j];\n    }\n    assert(tmp == ret);\n    return tmp;\n}\nLL PLUS(int k, int l, int r) {\n    LL tmp = P[r][k] - P[l][k];\n    LL ret = 0;\n    for (int i=l; i<r; i++) for (int j=0; j<k; j++) {\n\tret += A[i][j];\n    }\n    assert(tmp == ret);\n    return tmp;\n}\n\nLL dp[511][511];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) REP (j, N) {\n\tif (i == j) continue;\n\tscanf(\"%d\", &A[i][j]);\n    }\n\n    //N = 500;\n    //REP (i, N) REP (j, N) A[i][j] = rand() % 1000000000;\n\n    REP (i, N+1) REP (j, N+1) {\n\tP[i+1][j+1] = P[i][j+1] + P[i+1][j] - P[i][j];\n\tM[i+1][j+1] = M[i][j+1] + M[i+1][j] - M[i][j];\n\tif (i < j) M[i+1][j+1] += A[i][j];\n\tif (i > j) P[i+1][j+1] += A[i][j];\n    }\n\n    memset(dp, 0x3f, sizeof dp);\n    const LL INF = dp[0][0];\n    dp[0][0] = 0;\n    for (int i=0; i<N; i++) for (int j=(i? i+1: 0); j<N; j++) if (dp[i][j] < INF) {\n\tfor (int k=j+1; k<=N; k++) {\n\t    amin(dp[j][k], dp[i][j] + MINUS(j, k) + PLUS(i, j, k));\n\t}\n    }\n\n    LL ans = INF;\n    REP (i, N) {\n\t//if (dp[i][N] == 0) eprintf(\"%d\\n\", i);\n\tamin(ans, dp[i][N]);\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\nlong long sum[2][510][510];\nlong long g[510][510];\nlong long rect(int t,int r1,int c1,int r2,int c2){\n\tif(r1>r2||c1>c2)return 0;\n\treturn sum[t][r2+1][c2+1]-sum[t][r1][c2+1]-sum[t][r2+1][c1]+sum[t][r1][c1];\n}\nlong long dp[510][510];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tscanf(\"%lld\",&g[i][j]);\n\t\t\tif(i<j){\n\t\t\t\tsum[0][i+1][j+1]+=g[i][j];\n\t\t\t}else{\n\t\t\t\tsum[1][j+1][i+1]+=g[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=a;j++){\n\t\t\tfor(int k=0;k<=a;k++){\n\t\t\t\tsum[i][j][k+1]+=sum[i][j][k];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=a;j++){\n\t\t\tfor(int k=0;k<=a;k++){\n\t\t\t\tsum[i][j+1][k]+=sum[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<510;i++)for(int j=0;j<510;j++)\n\t\tdp[i][j]=inf;\n\tfor(int i=0;i<a;i++){\n\t\tdp[i][a]=rect(0,0,0,i,i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tfor(int k=i+1;k<a;k++){\n\t\t\t\tlong long tmp=dp[i][j];\n\t\t\t\ttmp+=rect(0,i+1,i+1,k,k);\n\t\t\t\ttmp+=rect(1,0,i+1,j,k);\n\t\t\t\tdp[k][i]=min(dp[k][i],tmp);\n\t\t\t}\n\t\t}\n\t\t// i, a\n\t\tfor(int k=i+1;k<a;k++){\n\t\t\tlong long tmp=dp[i][a];\n\t\t\ttmp+=rect(0,i+1,i+1,k,k);\n\t\t\tdp[k][i]=min(dp[k][i],tmp);\n\t\t}\n\t}\n\tlong long ret=inf;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<i;j++){\n\t\t\tlong long tmp=dp[i][j];\n\t\t\ttmp+=rect(0,i+1,i+1,a-1,a-1);\n\t\t\ttmp+=rect(1,0,i+1,j,a-1);\n\t\t\tret=min(ret,tmp);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tlong long tmp=dp[i][a];\n\t\ttmp+=rect(0,i+1,i+1,a-1,a-1);\n\t\tret=min(ret,tmp);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "// D - Negative Cycle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tINF\t1e16\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<vector<long long> > a(n, vector<long long>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (i != j) cin >> a[i][j];\n\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, INF));\n\tdp[0][0] = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long> x(i), y(i);\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = i + 1; k <= n; k++) x[j] += a[k - 1][j - 1];\n\t\t\tx[j] += x[j - 1];\n\t\t}\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tfor (int k = j + 1; k < i + 1; k++) y[j] += a[j][k - 1];\n\t\t\tif (j + 1 < i - 1) y[j] += y[j + 1];\n\t\t}\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tfor (int k = 0; k < j + 1; k++)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + x[j] - x[k] + y[j]);\n\t}\n\n\tcout << *min_element(dp[n].begin(),dp[n].end()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n \nusing namespace std;\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n \ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n \ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n \ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n \ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n \nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n \nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n \nconst ll inf = 1LL << 50;\nll dp[510][510][510];\nll A[510][510];\n \nll pls[510][510];\nll mns[510][510];\n \nint main(void){\n\tint n;\n\tcin >> n;\n \n\trep(i, n)rep(j, n){\n\t\tif(i == j) continue;\n\t\tcin >> A[i][j];\n\t}\n \n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) pls[i][j] += pls[i][j - 1];\n\t\t\tpls[i][j] += A[i][j];\n\t\t}\n\t}\n \n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) mns[i][j] += mns[i][j - 1];\n\t\t\tmns[i][j] += A[j][i];\n\t\t}\n\t}\n \n \n\tconst int unused = n;\n \n\trep(i, n + 1) rep(j, n + 1) rep(k, n + 1) dp[i][j][k] = inf; \n\tdp[0][0][unused] = 0;\n \n\trep(i, n - 1) rep(j, n + 1) rep(k, n + 1){\n\t\tif (dp[i][j][k] == inf) continue;\n\t\t\n\t\tconst int vj = j;\n\t\tconst int vk = (k != unused) ? k : -1;\n \n\t\t// potential increase\n\t\t{\n\t\t\tll add = 0LL;\n\t\t\tif(vj - 1 >= 0) add += pls[i + 1][vj - 1];\n\t\t\tchmin(dp[i + 1][i + 1][j], dp[i][j][k] + add);\n\t\t}\n \n\t\t// do nothing \n\t\t{\n\t\t\tll add = 0LL;\n\t\t\tadd += mns[i + 1][i];\n\t\t\tif(vj - 1 >= 0) add -= mns[i + 1][vj - 1];\n\t\t\tif(vk - 1 >= 0) add += pls[i + 1][vk - 1];\n\t\t\tchmin(dp[i + 1][j][k], dp[i][j][k] + add);\n\t\t}\n\t}\n \n\tll ans = inf;\n\trep(j, n + 1) rep(k, n + 1) chmin(ans, dp[n - 1][j][k]);\n\tcout << ans << endl;\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int N = 505;\nint n;\nint a[N][N];\nll w[N][N], v[N][N], f[N][N];\n\ninline int read() {\n\tint s = 0, f = 1;\n\tchar ch;\n\tfor(; ch < '0' || ch > '9'; ch = getchar())\tif(ch == '-')\tf = -1;\n\tfor(; ch >= '0' && ch <= '9'; ch = getchar())\ts = (s << 1) + (s << 3) + ch - '0';\n\treturn s * f;\n}\n\ninline ll calc(int a, int b, int c) { return w[b][c] - w[a - 1][c]; }\n\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tif(i ^ j)\ta[i][j] = read();\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = n; j >= i + 1; --j) {\n\t\t\tw[i][j] = w[i][j + 1];\n\t\t\tfor(int k = 1; k <= i; ++k)\tw[i][j] += a[j][k];\n\t\t}\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n + 1; ++j) {\n\t\t\tv[i][j] = v[i][j - 1];\n\t\t\tfor(int k = i; k <= j - 1; ++k)\tv[i][j] += a[k][j];\n\t\t}\n\tmemset(f, 0x3f, sizeof(f));\n\tf[0][0] = 0;\n\tfor(int i = 0; i <= n; ++i)\n\t\tfor(int j = i; j <= n; ++j)\n\t\t\tif(f[i][j] < 1e18)\n\t\t\t\tfor(int k = j + 1; k <= n + 1; ++k)\n\t\t\t\t\tf[j][k] = min(f[j][k], f[i][j] + v[j + 1][k] + calc(i + 1, j, k + 1));\n\tll ans = 1e18;\n\tfor(int i = 0; i <= n; ++i)\tans = min(ans, f[i][n + 1]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 510\n#define INF 1000000000000000000ll\nusing namespace std;\nll ans=INF,dp[N][N],a[N][N],n,g[N][N],f[N][N];\nll co1(int l,int r,int x){return f[x][r]-f[x][l-1];}\nll co2(int x,int l,int r){return g[x][r]-g[x][l-1];}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)if (i!=j)cin>>a[i][j];\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n+1;j++)dp[i][j]=INF;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tg[i][j]=g[i][j-1]+a[i][j],f[i][j]=f[i][j-1]+a[j][i];\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<i;j++)dp[0][0]+=a[i][j];\n\tfor (int i=0;i<n;i++){\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tll su=0;\n\t\t\tfor (int k=j+1;k<=n+1;k++){\n\t\t\t\tsu=su+co1(j,k-2,k-1)-co2(k-1,i,k-2);\n\t\t\t\tdp[j][k]=min(dp[j][k],dp[i][j]+su);\n\t\t\t\tif (k==n+1)ans=min(ans,dp[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <ll, pair <ll, ll>>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n \ntypedef long long ll;\n \ntypedef long double ld;\n \nusing namespace std;\n \nconst ll maxn = 5e2 + 100;\nconst ll inf = 1e15;\n\nll n, m, k, t;\n\nll dp[maxn][maxn][2];\n\nll A[maxn][maxn];\n\nll getdp(ll l, ll r, ll i) {\n    if (dp[l][r][i] != -1) {\n        return dp[l][r][i];\n    }\n    if (i == 0) {\n        ll dd = 0;\n        ll q;\n        for (q = l; q <= r; q++) {\n            dd += A[q][r];\n        }\n        dp[l][r][i] = dp[l][r - 1][i] + dd;\n    }\n    else {\n        ll q;\n        ll dd = 0;\n        for (q = r + 1; q < n; q++) {\n            dd += A[q][l - 1];\n        }\n        dp[l][r][i] = dp[l - 1][r][i] + dd;\n    }\n    return dp[l][r][i];\n}\n\nll D[maxn][maxn];\n\nll get_in(ll l, ll r) {\n    while (r >= n) {\n        r--;\n    }\n    while (l >= n) {\n        l--;\n    }\n    if (l > r) {\n        return 0;\n    }\n    ll ans = getdp(l, r, 0); \n    // cout << \"IN \" << l << \" \" << r  << \" \" << ans << endl;\n    return ans;\n}\n\nll get_out(ll l, ll r) {\n    while (r >= n) {\n        r--;\n    }\n    while (l >= n) {\n        l--;\n    }\n    while (l > r) {\n        r++;\n    }\n    ll ans = getdp(l, r, 1);\n    // cout << \"OUT \" << l << \" \" << r  << \" \" << ans << endl;\n    return ans;\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b;\n    cin >> n;\n    for (q = 0; q < n; q++) {\n        for (w = 0; w < n; w++) {\n            if (w == q) {\n                continue;\n            }\n            cin >> A[q][w];\n        }\n    }\n    for (q = 0; q < maxn; q++) {\n        for (w = 0; w < maxn; w++) {\n            for (e = 0; e < 2; e++) {\n                dp[q][w][e] = -1;\n            }\n        }\n    }\n    for (q = 0; q < maxn; q++) {\n        dp[q][q][0] = 0;\n    }\n\n    for (q = 0; q < maxn; q++) {\n        dp[0][q][1] = 0;\n    }\n    for (q = 0; q < maxn; q++) {\n        dp[q][n - 1][1] = 0;\n    }\n\n    // ll ans = 0;\n    for (q = 0; q < maxn; q++) {\n        for (w = 0; w < maxn; w++) {\n            D[q][w] = inf;\n        }\n    }\n    D[0][0] = 0;\n    for (q = 1; q <= n + 1; q++) {\n        for (w = 0; w < q; w++) {\n            D[q][w] = inf;\n            for (e = 0; e <= w; e++) {\n                ll dans = D[w][e];\n                ll d = get_in(w, q - 1);\n                ll d1 = get_out(w, q - 1) - get_out(e, q - 1);\n                dans += d + d1;\n                D[q][w] = min(D[q][w], dans);\n            }\n            // cout << q << \" \" << w << \" \" << \"D \" << D[q][w] << endl << endl;\n        }\n    }\n    ll ans = inf;\n    for (q = 0; q <= n; q++) {\n        ans = min(ans, D[n + 1][q]);\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 505;\nconst ll inf = 1e18;\nint n;\nll a[N][N], b[N][N], f[N][N], ans = inf;\n\ninline ll calc(int k, int j, int i) {\n\treturn b[j+1][i] + a[n][j] - a[n][k] - a[i][j] + a[i][k];\n}\n\nint main() {\n\trd(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (i != j) rd(a[i][j]);\n\tfor (int j = 1; j <= n; j++)\n\t\tfor (int i = j; i; i--)\n\t\t\tb[i][j] = b[i+1][j] + b[i][j-1] - b[i+1][j-1] + a[i][j];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\ta[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1];\n\tfor (int i = 1; i < n; i++) {\n\t\tf[i][0] = calc(0, 0, i);\n\t\tans = min(ans, f[i][0] + calc(0, i, n));\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tf[i][j] = inf;\n\t\t\tfor (int k = 0; k < j; k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[j][k] + calc(k, j, i));\n\t\t\tans = min(ans, f[i][j] + calc(j, i, n));\n\t\t}\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.7.22 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define eps 1e-10\n#define RG register\n#define db double\n#define lb long db\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define gc getchar\n#define Pi 2.0*acos(-1.0)\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG __int128 x){\n//    if(x>10)write(x/10);\n//    putchar(x%10+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=5e2+10;\nnamespace MAIN{\n    int n;\n    int A[N][N];\n    LL dp[N][N],pre[N][N],suf[N][N];\n    inline void MAIN(){\n        n=read();\n        for(res i=1;i<=n;i++)\n            for(res j=1;j<=n;j++)\n                if(i!=j)A[i][j]=read();\n        for(res i=1;i<=n;i++){\n            for(res j=i+1;j<=n+1;j++){\n                pre[i][j]=pre[i][j-1];\n                for(res k=i;k<j;k++)pre[i][j]+=A[k][j];\n            }\n            for(res j=n;j>=i+1;j--){\n                suf[i][j]=suf[i][j+1];\n                for(res k=1;k<=i;k++)suf[i][j]+=A[j][k];\n            }\n        }\n        for(res i=0;i<=n+1;i++)\n            for(res j=0;j<=n+1;j++)\n                dp[i][j]=INF;\n        dp[0][0]=0;\n        for(res i=0;i<=n;i++)\n            for(res j=i;j<=n;j++)\n                if(dp[i][j]!=INF)\n                    for(res k=j+1;k<=n+1;k++)\n                        dp[j][k]=min(dp[j][k],dp[i][j]+pre[j+1][k]+suf[j][k+1]-suf[i][k+1]);\n        RG LL ans=INF;\n        for(res i=0;i<=n;i++)ans=min(ans,dp[i][n+1]);\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Winding\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\nnamespace fastIO\n{\n\tconst UI BUFFER_SIZE = (UI) 1 << 15;\n\tchar buffer[BUFFER_SIZE], *cur, *ed;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\n\n// END tpl.\n\nconst int MAXN = 500;\n\nint n;\n\nint A[MAXN + 5][MAXN + 5], B[MAXN + 5][MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tif(i < j) A[i][j] = read<int>();\n\t\t\tif(i > j) B[j][i] = read<int>();\n\t\t}\n}\n\ninline void solve()\n{\n\tstatic LL S0[MAXN + 5][MAXN + 5], pre[MAXN + 5][MAXN + 5], S[MAXN + 5][MAXN + 5][MAXN + 5];\n\n\tfor(int len = 1; len <= n; ++len)\n\t\tfor(int i = 1; i + len <= n; ++i)\n\t\t{\n\t\t\tint j = i + len;\n\t\t\tS0[i][j] = S0[i + 1][j] + S0[i][j - 1] - S0[i + 1][j - 1] + B[i][j];\n\t\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tpre[i][0] = 0;\n\t\tfor(int j = 1; j <= n; ++j) pre[i][j] = pre[i][j - 1] + B[i][j];\n\t}\n\n\tfor(int j = 1; j <= n; ++j) for(int k = j + 1; k <= n; ++k)\n\t\tfor(int i = j; i >= 0; --i) S[i][j][k] = S[i + 1][j][k] + pre[i][k] - pre[i][j];\n\n\tstatic LL suf[MAXN + 5][MAXN + 5], S1[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tsuf[0][i] = 0;\n\t\tfor(int j = 1; j <= i; ++j) suf[j][i] = suf[j - 1][i] + A[j][i];\n\t}\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tS1[i][j] = S1[i][j - 1] + suf[i][j];\n\n\tstatic LL f[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i) f[0][i] = S0[1][i];\n\tfor(int k = 1; k <= n; ++k) for(int j = 1; j < k; ++j)\n\t{\n\t\tLL res = S0[j + 1][k] + S1[j][k];\n\t\tfor(int i = 0; i < j; ++i)\n\t\t\tchkmax(f[j][k], res + f[i][j] + S[i + 1][j][k]);\n\t}\n\n\tLL sum = 0;\n\tfor(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j)\n\t\tsum += A[i][j] + B[i][j];\n\n\tLL ans = 0;\n\tfor(int i = 0; i < n; ++i) chkmax(ans, f[i][n]);\n\tprintf(\"%lld\\n\", sum - ans);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\n\ntemplate< typename T >\nstruct Dinic\n{\n    struct edge\n    {\n        int to;\n        T cap;\n        int rev;\n    };\n    \n    const T INF;\n    vector< vector< edge > > graph;\n    vector< T > min_cost;\n    vector< int > iter;\n    \n    Dinic(int n) : INF(numeric_limits< T >::max())\n    {\n        graph.resize(n);\n    }\n    \n    void add_edge(int from, int to, T cap)\n    {\n        graph[from].push_back((edge) {to, cap, (int) graph[to].size()});\n        graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n    }\n    \n    bool bfs(int s, int t)\n    {\n        min_cost.assign(graph.size(), -1);\n        queue< int > que;\n        min_cost[s] = 0;\n        que.push(s);\n        while(!que.empty()) {\n            int p = que.front();\n            que.pop();\n            for(auto &e : graph[p]) {\n                if(e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return (min_cost[t] != -1);\n    }\n    \n    T dfs(int idx, const int t, T flow)\n    {\n        if(idx == t) return (flow);\n        for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return (d);\n                }\n            }\n        }\n        return (0);\n    }\n    \n    T max_flow(int s, int t)\n    {\n        T flow = 0;\n        while(bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            T f = 0;\n            while((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n        return (flow);\n    }\n};\n\nint N, M;\n\nint index(int i, int j){\n    return i * N + j;\n}\n\nint main(){\n    cin >> N;\n    M = 2 * N - 1;\n    Dinic<lint> graph(N * M + 1);\n    for(int i = 0; i < N - 1; i++){\n        for(int j = 0; j < M; j++){\n            graph.add_edge(index(j, i), index(j, i + 1), 1e18);\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(i == j){\n                continue;\n            }\n            lint A;\n            cin >> A;\n            if(i < j){\n                for(int k = 0; k < M - 1; k++){\n                    graph.add_edge(index(k, i), index(k + 1, j), A);\n                }\n            }else{\n                for(int k = 0; k < M - 1; k++){\n                    graph.add_edge(index(k + 1, i), index(k, j), A);\n                }\n            }\n        }\n    }\n    for(int i = N; i < M; i++){\n        graph.add_edge(index(i, 0), N * M, 1e18);\n    }\n    cout << graph.max_flow(index(N - 1, 0), N * M) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nint n;\n#define Maxn 505\nll val1[Maxn][Maxn];//below\nll val2[Maxn][Maxn];//up\nll f[Maxn][Maxn];\nll sum[Maxn];\ninline int calc(int x){return x*(x+1)/2;}\ninline void rd(int &x){\n\tx=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=x*10+ch-'0';\n\t\tch=getchar();\n\t}\n}\nint main(){\n\tll All=0;\n\trd(n);\n\tint x;\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=1;j<=n;++j)\n\t       if(j!=i){\n\t       \t    rd(x);\n\t       \t    All+=x;\n\t       \t    if(j<i)val1[j][i-1]=x;\n\t       \t    else val2[i][j-1]=x;\n\t\t   }\n\tn--;\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=2;j<=i;++j){\n\t    \tval1[j][i]+=val1[j-1][i];\n\t    \tval2[j][i]+=val2[j-1][i];\n\t\t}\n\tll Ans=0;\n\tll Ha=0;\n\tfor(register int i=1;i<=n;++i){\n\t\tHa+=val1[i][i];\n\t    f[i][0]=Ha+val2[i][i];\n\t\tfor(register int j=0;j<i;++j){\n\t\t\tll tmp=0;\n\t\t    for(register int k=i+1;k<=n;++k){\n\t\t    \tf[k][i]=max(f[k][i],f[i][j]+tmp+val1[k][k]-val1[i][k]+val2[k][k]);\n                tmp+=val1[k][k]-val1[j][k]+val2[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tfor(register int i=1;i<=n;++i)sum[i]=val1[i][i]+sum[i-1];\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=i+1;j<=n;++j){\n\t    \tval1[i][j]+=val1[i][j-1];\n\t    \tval2[i][j]+=val2[i][j-1];\n\t\t}\n\tfor(register int i=1;i<=n;++i)\n\t    for(register int j=0;j<i;++j)\n\t    \tAns=max(Ans,f[i][j]-val1[j][n]+val1[j][i]+val2[i][n]-val2[i][i]+sum[n]-sum[i]);\n    printf(\"%lld\\n\",All-Ans);\n\treturn 0;\t    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\n\ntemplate< typename T >\nstruct Dinic\n{\n    struct edge\n    {\n        int to;\n        T cap;\n        int rev;\n    };\n    \n    const T INF;\n    vector< vector< edge > > graph;\n    vector< T > min_cost;\n    vector< int > iter;\n    \n    Dinic(int n) : INF(numeric_limits< T >::max())\n    {\n        graph.resize(n);\n    }\n    \n    void add_edge(int from, int to, T cap)\n    {\n        graph[from].push_back((edge) {to, cap, (int) graph[to].size()});\n        graph[to].push_back((edge) {from, 0, (int) graph[from].size() - 1});\n    }\n    \n    bool bfs(int s, int t)\n    {\n        min_cost.assign(graph.size(), -1);\n        queue< int > que;\n        min_cost[s] = 0;\n        que.push(s);\n        while(!que.empty()) {\n            int p = que.front();\n            que.pop();\n            for(auto &e : graph[p]) {\n                if(e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return (min_cost[t] != -1);\n    }\n    \n    T dfs(int idx, const int t, T flow)\n    {\n        if(idx == t) return (flow);\n        for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return (d);\n                }\n            }\n        }\n        return (0);\n    }\n    \n    T max_flow(int s, int t)\n    {\n        T flow = 0;\n        while(bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            T f = 0;\n            while((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n        return (flow);\n    }\n};\n\nint N, M;\n\nint index(int i, int j){\n    return i * N + j;\n}\n\nint main(){\n    cin >> N;\n    M = 2 * N - 1;\n    Dinic<lint> graph(N * M + 1);\n    for(int i = 0; i < N - 1; i++){\n        for(int j = 0; j < M; j++){\n            graph.add_edge(index(j, i), index(j, i + 1), 1e16);\n        }\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < N; j++){\n            if(i == j){\n                continue;\n            }\n            lint A;\n            cin >> A;\n            if(i < j){\n                for(int k = 0; k < M - 1; k++){\n                    graph.add_edge(index(k, i), index(k + 1, j), A);\n                }\n            }else{\n                for(int k = 0; k < M - 1; k++){\n                    graph.add_edge(index(k + 1, i), index(k, j), A);\n                }\n            }\n        }\n    }\n    for(int i = N; i < M; i++){\n        graph.add_edge(index(i, 0), N * M, 1e16);\n    }\n    cout << graph.max_flow(index(N - 1, 0), N * M) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nll A[510][510];\nll U[510][510];\nll D[510][510];\n\nll dp[510][510][510];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif(i == j) continue;\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, i) {\n\t\t\tU[i][j + 1] = U[i][j] + A[j][i];\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, i) {\n\t\t\tD[i][j + 1] = D[i][j] + A[i][j];\n\t\t}\n\t}\n\trep(i, 0, N + 1) {\n\t\trep(j, 0, N + 1) {\n\t\t\trep(k, 0, N + 1) {\n\t\t\t\tdp[i][j][k] = linf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[1][0][0] = 0;\n\trep(i, 1, N) {\n\t\trer(j, N, 0) {\n\t\t\trer(k, N, 0) {\n\t\t\t\tif(dp[i][j][k] == linf) continue;\n\t\t\t\tMIN(dp[i][k][i], dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\trep(k, 0, N) {\n\t\t\t\t// debug(i, j, k, dp[i][j][k], U[i][i] - U[i][k], D[i][j]);\n\t\t\t\tMIN(dp[i + 1][j][k], dp[i][j][k] + (U[i][i] - U[i][k]) + D[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tll res = linf;\n\trep(j, 0, N) {\n\t\trep(k, 0, N) {\n\t\t\t// debug(N, j, k, dp[N][j][k]);\n\t\t\tMIN(res, dp[N][j][k]);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[505][505];\nlong long s1[505][505],s2[505][505];\nlong long dp[505][505];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i][j-1]+a[i][j];\n\t\t}\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t{\n\t\t\ts2[i][j]=s2[i][j+1]+a[j][i];\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tdp[i][j]=1000000000000000000LL;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]<dp[i-1][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i-1][j]=dp[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tdp[j][k]+=s1[i][k]+s2[i][j+1];\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=1000000000000000000LL;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(dp[i][j]<ans)\n\t\t\t{\n\t\t\t\tans=dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL MOD = 998244353;\nconst int N = 505;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n,x,a[N][N];\nLL s1[N][N], s2[N][N], dp[N][N];\n\nint main(){\n\tfreopen(\"test.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\trep(i,1,n)rep(j,1,n-1){\n\t\tscanf(\"%d\",&x);\n\t\ta[i][j+(j>=i)]=x;\n\t}\n\t\n\trep(i,1,n){\n\t\tLL sum1 = 0, sum2 = 0;\n\t\trep(j,i,n){\n\t\t\tsum1 += a[i][j], sum2 += a[j][i];\n\t\t\ts1[i][j] = s1[i-1][j] + sum1;\n\t\t\ts2[i][j] = s2[i-1][j] + sum2;\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<s1[i][j]<<\" \"<<s2[i][j]<<endl;\n\t\t} \n\t}\n\t\n\trep(i,0,n+1)rep(j,0,n+1)dp[i][j]=1e18;\n\trep(i,2,n)dp[i][1] = s1[i-1][i-1];\n\trep(i,2,n)rep(j,1,i-1)rep(x,i+1,n){\n\t\tLL sum1 = s1[x-1][x-1] - s1[i-1][x-1];\n\t\tLL sum2 = s2[i-1][n] - s2[j-1][n] - s2[i-1][x-1] + s2[j-1][x-1];\n\t\tdp[x][i] = min(dp[x][i], dp[i][j] + sum1 + sum2);\n\t\t//cout<<x<<\" \"<<i<<\" \"<<j<<\" \"<<dp[x][i]<<endl;//<<sum1<<\" \"<<sum2<<endl;\n\t}\n\tLL ans = s1[n][n];\n\trep(i,2,n)rep(j,1,i-1) ans = min(ans, dp[i][j]+s1[n][n]-s1[i-1][n]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vvi a(N, vi(N));\n    F0R (i, N) F0R (j, N) if (i != j) re(a[i][j]);\n\n    vvll pref(N, vll(N + 1));\n    F0R (i, N) F0R (j, N) pref[i][j+1] = pref[i][j] + a[i][j];\n\n    vvll ferp(N+1, vll(N));\n    F0R (i, N) F0R (j, N) ferp[i+1][j] = ferp[i][j] + a[i][j];\n\n    map<pii, ll> dp; dp[{ 0, 1 }] = 0;\n\n    FOR (i, 1, N) {\n        decltype(dp) DP;\n        trav (p, dp) {\n            int pc, cc; tie(pc, cc) = p.f; ll cost = p.s;\n            {\n                ll stay = cost;\n                // FOR (v, i - cc, i) stay += a[v][i];\n                stay += ferp[i][i] - ferp[i-cc][i];\n                // F0R (v, i - cc - pc) stay += a[i][v];\n                stay += pref[i][i - cc - pc];\n\n                pii key = mp(pc, cc+1);\n                ll put = min(stay, DP.count(key) ? DP[key] : LLONG_MAX);\n                DP[key] = put;\n            }\n            {\n                ll go = cost + pref[i][i - cc];\n                //F0R (v, i - cc) go += a[i][v];\n                pii key = mp(cc, 1);\n                ll put = min(go, DP.count(key) ? DP[key] : LLONG_MAX);\n                DP[key] = put;\n            }\n        }\n\n        dp = move(DP);\n    }\n\n    ll ans = LLONG_MAX;\n    trav (p, dp) ckmin(ans, p.s);\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 505;const ll inf=1e16;\nint n,a[N][N];\nll f[2][N][N],qz1[N][N],qz2[N][N];\nint main() {\n\tread(n);rep(i,1,n)rep(j,1,n)if(i!=j)read(a[i][j]);\n\trep(i,1,n)rep(j,1,n)qz1[i][j]=a[i][j]+qz1[i][j-1];//hang\n\trep(i,1,n)rep(j,1,n)qz2[i][j]=a[i][j]+qz2[i-1][j];//lie\n\trep(i,0,1)rep(j,0,n)rep(k,0,n)f[i][j][k]=inf;\n\tf[0][0][0]=0;\n\trep(t,0,n-1){\n\t\tint p=t&1,q=p^1;//p-->q\n\t\trep(i,0,t+1)rep(j,0,i)f[q][i][j]=inf;\n\t\trep(x,0,t)rep(y,0,x)if(f[p][x][y]<inf){\n\t\t\tll tmp=f[p][x][y]+qz1[t+1][y]+qz2[t][t+1]-qz2[x][t+1];\n\t\t\tumin(f[q][x][y],tmp);umin(f[q][t+1][x],tmp);\n\t\t}\n\t}\n\tll res=inf;rep(i,0,n)rep(j,0,i)umin(res,f[n&1][i][j]);\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll a[200105],sum=0;\nint d[200105][35],n;\ninline ll read()\n{\n\tchar c=getchar();int a=1;ll ans=0;\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')a=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())ans=ans*10+int(c)-48;\n\treturn a*ans;\n}\nint aaaa(int s,int v)\n{\n\tint k=(int)(log((v-s+1)*1.0)/log(2.0));\n\tif(a[d[s][k]]<a[d[v-(1<<k)+1][k]])\n\t{\n\t\treturn d[s][k];\n\t}\n\telse \n\t{\n\t\treturn d[v-(1<<k)+1][k];\n\t}\n}\nvoid awsl(int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tsum+=a[l];\n\t\treturn;\n\t}\n\tint minn=aaaa(l,r);\n\tsum=sum+(ll)(minn-l+1)*(r-minn+1)*a[minn];\n\tif(l<=minn-1)\n\t{\n\t\tawsl(l,minn-1);\n\t}\n\tif(r>=minn+1)\n\t{\n\t\tawsl(minn+1,r);\n\t}\n}\nint main()\n{\n\tn=read(); \n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta[i]=read();\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\td[i][0]=i;\n\t}\n\tfor(int j=1;(1<<j)<=n;j++)\n\t{\n\t\tfor(int i=0;i+(1<<j)-1<n;i++)\n\t\t{\n\t\t\tif(a[d[i][j-1]]<a[d[i+(i<<(j-1))][j-1]])\n\t\t\t{\n\t\t\t\td[i][j]=d[i][j-1];\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\td[i][j]=d[i+(1<<(j-1))][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tawsl(0,n-1);\n\tcout<<sum;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nlint d[501][501][501];\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  // auto d = make_higher_vector<3, lint>(n, n + 1, n + 1);\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      // at(d, j, k, 0) = 0;\n      d[j][k][0] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf) continue;\n        dp[j][k] = std::min(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=505;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint a[MAXN][MAXN],n;ll Sum[2][MAXN][MAXN],F[MAXN][MAXN];\ninline ll Get(int opt,int lx,int rx,int ly,int ry){return Sum[opt][rx][ry]-Sum[opt][lx-1][ry]-Sum[opt][rx][ly-1]+Sum[opt][lx-1][ly-1];}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();\n\tRep(i,1,n)Rep(j,1,n)if(j!=i)a[i][j]=read();\n\tRep(i,1,n)Rep(j,1,n){\n\t\tif(i<j)Sum[0][i][j]=a[i][j];if(i>j)Sum[1][i][j]=a[i][j];\n\t\tSum[0][i][j]+=Sum[0][i-1][j]+Sum[0][i][j-1]-Sum[0][i-1][j-1];\n\t\tSum[1][i][j]+=Sum[1][i-1][j]+Sum[1][i][j-1]-Sum[1][i-1][j-1];\n\t}memset(F,0x3f,sizeof(F)),F[0][0]=0;\n\tRep(i,0,n)Rep(j,0,max(i-1,0))Rep(k,i+1,n)F[k][i]=min(F[k][i],F[i][j]+Get(1,k+1,n,j+1,i)+Get(0,i+1,k,i+1,k));\n\tll ans=1e18;Rep(j,0,n)ans=min(ans,F[n][j]);cout<<ans<<\"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n#pragma GCC optimize(\"unroll-loops\")    \n#include <bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define len(a) int(a.size())\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n        \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n        \ntypedef long long base; \ntypedef pair<int, int> point;      \ntypedef complex<double> comp;\n\nconst int N = 505;\n\nint n;\nint w[N][N];\nlong long sum[2][N][N];\nlong long dp[N][N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    srand(time(0));\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n    \tfor (int j = 1; j <= n; ++j) {\n    \t\tif (i == j) continue;\n    \t\tcin >> w[i][j];\n    \t\tsum[i > j][min(i, j)][max(i, j) - 1] += w[i][j];\n    \t}\n    }\n    for (int i = n + 1; i--;) {\n    \tfor (int j = i + 1; j <= n + 1; ++j) {\n    \t\tsum[0][i][j] += sum[0][i + 1][j] + sum[0][i][j - 1] - sum[0][i + 1][j - 1];\n    \t\tsum[1][i][j] += sum[1][i + 1][j] + sum[1][i][j - 1] - sum[1][i + 1][j - 1];\n    \t}\n    }\n    for (int i = 0; i <= n + 1; ++i) {\n    \tfor (int j = 0; j <= n + 1; ++j) {\n    \t\tdp[i][j] = 1e18;\n    \t}\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i <= n; ++i) {\n    \tfor (int j = i; j <= n; ++j) {\n    \t\tif (dp[i][j] == 1e18) continue;\n    \t\tfor (int R = j + 1; R <= n + 1; ++R) {\n    \t\t\tlong long d = sum[1][i + 1][n + 1] \n    \t\t\t\t\t\t- sum[1][i + 1][R - 1] \n    \t\t\t\t\t\t- sum[1][j + 1][n + 1] \n    \t\t\t\t\t\t+ sum[1][j + 1][R - 1];\n    \t\t\t// cout << \"? \" << d << ' ' << i << ' ' << j << ' ' << R << endl;\n    \t\t\td += sum[0][j + 1][R - 1];\n    \t\t\t// cout << \"  \" << d << ' ' << dp[i][j] + d << endl;\n    \t\t\tchkmin(dp[j][R], dp[i][j] + d);\n    \t\t}\n       \t}\n    }\n    long long ans = 1e18;\n    for (int i = 0; i <= n; ++i) {\n    \tchkmin(ans, dp[i][n + 1]);\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nlong long n;\nlong long w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nlong long ans=(1<<30);\n\ninline long long getsum(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  cin>>w[i][j];\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=(1<<30);\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tcout<<ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 505;\n\ntypedef pair<int,int>   ii;\n\nll  f[N][N];\nll  s_r[N][N];\nll  s_c[N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 0 ; i < n ; ++i)\n    for(int j = 0 ; j < n ; ++j)    {\n        int x = 0;\n        if (i ^ j)\n            cin >> x;\n\n        s_r[i][j] = x + (j ? s_r[i][j - 1] : 0);\n        s_c[i][j] = x + (i ? s_c[i - 1][j] : 0);\n    }\n\n    --n;\n\n    ll  ans = 0;\n\n    for(int i = 0 ; i <= n ; ++i)\n        ans += s_c[i][i];\n\n    for(int i = 0 ; i < n ; ++i)    {\n        ll  val = 0;\n\n        for(int j = 1 ; j <= i ; ++j)   val += s_c[j][j];\n        for(int j = i ; j <= n ; ++j)   val += s_c[j][j] - s_c[i][j];\n\n        if (ans > val)\n            ans = val;\n    }\n\n    for(int i = 0 ; i < n ; ++i)\n    for(int j = 0 ; j < i ; ++j)    {\n        ll  offset = s_r[i + 1][j];\n\n        for(int k = i ; k > j ; --k)\n            offset += s_c[k][k] - s_c[j][k];\n\n        f[i][j] = offset;\n\n        for(int k = 1 ; k <= j ; ++k)   f[i][j] += s_c[k][k];\n        for(int k = i ; k >  j ; --k)   offset  += s_r[k][j];\n\n        for(int k = j ; k > 0 ; --k)    {\n            offset -= s_c[i][k];\n            offset += s_c[j][k];\n\n            if (f[i][j] > f[i][k - 1] + offset)\n                f[i][j] = f[i][k - 1] + offset;\n        }\n        ll  curval = f[i][j] - s_r[i + 1][j];\n\n        for(int k = n ; k > i ; --k)    {\n            curval += s_c[k][k] - s_c[i][k];\n            curval += s_r[k][j];\n        }\n\n        if (ans > curval)\n            ans = curval;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nint forw[505][505];\nint back[505][505];\nint n;\nint dp[505][505];\n\nint getf(int x, int xx, int y, int yy)\n{\n\tif(x>xx||y>yy) return 0;\n\treturn forw[xx][yy]-forw[x-1][yy]-forw[xx][y-1]+forw[x-1][y-1];\n}\n\nint getb(int x, int xx, int y, int yy)\n{\n\tif(x>xx||y>yy) return 0;\n\treturn back[xx][yy]-back[x-1][yy]-back[xx][y-1]+back[x-1][y-1];\n}\n\nsigned main()\n{\n\tcin>>n;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<i; j++)\n\t\t{\n\t\t\tcin>>back[i][j];\n\t\t}\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tcin>>forw[i][j];\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tforw[i][j]=forw[i][j]+forw[i-1][j]+forw[i][j-1]-forw[i-1][j-1];\n\t\t\tback[i][j]=back[i][j]+back[i-1][j]+back[i][j-1]-back[i-1][j-1];\n//\t\t\tcout<<forw[i][j]<<endl;\n//\t\t\tcout<<back[i][j]<<endl;\n\t\t}\n\t}\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tdp[i][j]=1000000000000000;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tint ans=1000000000000000;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<i; j++)\n\t\t{\n\t\t\tfor(int k=0; k<=j; k++)\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[j][k]+getf(j+1,i,j+1,i)+getb(i+1, n, k+1, j));\n\t\t\t}\n\t\t\tif(i==n)\n\t\t\t{\n//\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t\t\tans=min(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nll a[500][500];\nll rsum[500][500];\nll dp[500][500];\nll range[500][500];\nll rev[501][500];\nll revs[501][500];\n\nvoid init() {\n    rep(i,n) {\n        for (int j = i+1; j < n; j++) {\n            rsum[i][j] = rsum[i][j-1] + a[i][j];\n        }\n    }\n    for (int i = n-1; i >= 0; i--) {\n        for (int j = 0; j < i; j++) {\n            rev[i][j] = rev[i+1][j] + a[i][j];\n        }\n    }\n    rep(i,n) {\n        rep(j,n) {\n            if (j == 0) revs[i][j] = rev[i][j];\n            else revs[i][j] = rev[i][j] + revs[i][j-1];\n        }\n    }\n    rep(i,n) {\n        for (int j = i+1; j < n; j++) {\n            for (int k = i; k < j; k++) {\n                range[i][j] += rsum[k][j-1];\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    rep(i,n) rep(j,n) {\n        if (i == j) continue;\n        cin >> a[i][j];\n    }\n    init();\n    rep(i,n) rep(j,n) dp[i][j] = linf;\n    dp[0][0] = 0;\n    rep(i,n) {\n        for (int j = i; j < n; j++) {\n            for (int k = j+1; k < n; k++) {\n                /*\n                ll cnt = 0;\n                for (int u = j; u < k; u++) {\n                    cnt += rsum[u][k-1];\n                    for (int v = u+1; v < k; v++) {\n                        cnt += a[u][v];\n                    }\n                }\n                */\n                ll cnt = range[j][k];\n                /*\n                for (int u = k; u < n; u++) {\n                    for (int v = i; v < j; v++) {\n                        cnt += a[u][v];\n                    }\n                }\n                */\n                /*\n                for (int v = i; v < j; v++) {\n                    cnt += rev[k][v];\n                }\n                */\n                if (j > 0) cnt += revs[k][j-1]-(i==0?0:revs[k][i-1]);\n                dp[k][j] = min(dp[k][j], dp[j][i] + cnt);\n            }\n        }\n    }\n    ll ans = linf;\n    rep(i,n) {\n        for (int j = i+1; j < n; j++) {\n            ll cnt = 0;\n            for (int k = j; k < n; k++) {\n                cnt += rsum[k][n-1];\n                /*\n                for (int l = k+1; l < n; l++) {\n                    cnt += a[k][l];\n                }\n                */\n            }\n            ans = min(ans, dp[j][i]+cnt);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=505;\nll a[N][N],b[N][N];\nll f[N][N],n;\nll sumA(int u,int v,int c,int d){\n\tu--,c--;\n\treturn a[v][d]-a[u][d]-a[v][c]+a[u][c];\n}\nll sumB(int u,int v,int c,int d){\n\tu--,c--;\n\treturn b[v][d]-b[u][d]-b[v][c]+b[u][c];\n}\nll move(ll &a,ll b){a=a>b?a:b;}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (i>j)scanf(\"%lld\",&b[i][j]);// 1\n\t\t\tif (i<j)scanf(\"%lld\",&a[i][j]);// -1\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1],\n\t\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\tfor (int i=1;i<n;i++){\n\t\tf[i][0]=sumB(1,i,1,i);\n\t\tfor (int j=0;j<i;j++)\n\t\t\tfor (int k=i+1;k<=n;k++)\n\t\t\t\tmove(f[k][i],f[i][j]+sumA(1,i,i+1,k)+sumB(i+1,k,j+1,k));\n\t}\n\tll ans=0;\n\tfor (int i=0;i<n;i++)move(ans,f[n][i]);\n\tcout<<a[n][n]+b[n][n]-ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\n#define FF first\n#define SS second\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\nusing namespace std;\nconst int maxn = 511;\nll inf;\nint n;\nint a[maxn][maxn];\nll dp[maxn][maxn], ca[maxn][maxn], cb[maxn][maxn];\nll suma[maxn][maxn], sumb[maxn][maxn];\nvoid upd(ll &x, ll v) {x=min(x, v);}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tif (i!=j) scanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll sum = 0;\n\t\tfor (int j=i; j>=0; j--)\n\t\t{\n\t\t\tca[i][j] = sum;\n\t\t\tsum += a[j][i];\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll sum = 0;\n\t\tfor (int j=1; j<=i; j++)\n\t\t{\n\t\t\tcb[i][j] = sum;\n\t\t\tsum += a[i][j];\n\t\t}\n\t}\n\tfor (int i=0; i<=n; i++)\n\t{\n\t\tfor (int j=0; j<=n; j++)\n\t\t{\n\t\t\tsuma[i][j] = ca[i][j];\n\t\t\tsumb[i][j] = cb[i][j];\n\t\t}\n\t}\n\tfor (int i=1; i<=n+1; i++) for (int j=0; j<=n+1; j++)\n\t{\n\t\tsuma[i][j] += suma[i-1][j];\n\t\tsumb[i][j] += sumb[i-1][j];\n\t}\n\tmemset(dp, 20, sizeof(dp));\n\tinf = dp[0][0];\n\tdp[n+1][n+1] = 0;\n\tfor (int i=n+1; i>=1; i--)\n\t{\n\t\tfor (int j=i; j<=n+1; j++)\n\t\t{\n\t\t\tll &cur = dp[i][j];\n\t\t\tif (cur>=inf) continue;\n\t\t\tfor (int k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tll c = 0;\n\t\t\t\tc += suma[j][i-1]-suma[i-1][i-1];\n\t\t\t\tc += sumb[j][k]-sumb[i-1][k];\n\t\t\t\tupd(dp[k][i-1], dp[i][j]+c);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=505;\nconst LL INF=1e18;\nint n;\nint a[N][N];\nLL f[N][N],g[N][N];\nLL dp[N][N];\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\tFor(j,1,n)\n\t\t\tif (i!=j)\n\t\t\t\ta[i][j]=read();\n\tFor(i,1,n){\n\t\tFor(j,i+1,n){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tg[i][j]=g[i][j-1];\n\t\t\tFor(k,i,j){\n\t\t\t\tf[i][j]-=a[k][j];\n\t\t\t\tg[i][j]+=a[j][k];\n\t\t\t}\n\t\t}\n\t}\n//\touttag(a);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%d \",a[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(f);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",f[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(g);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",g[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n\tFor(i,0,N-1)\n\t\tFor(j,0,N-1)\n\t\t\tdp[i][j]=-INF;\n\tdp[1][1]=-f[1][n];\n\tLL ans=-INF;\n\tFor(i,1,n)\n\t\tFor(j,1,n){\n//\t\t\tprintf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n\t\t\tif (i<=j){\n\t\t\t\tans=max(ans,dp[i][j]+f[i][n]+g[j][n]);\n\t\t\t\tif (i<j)\n\t\t\t\t\tdp[j+1][j]=max(dp[j+1][j],dp[i][j]+f[i][j-1]-a[j-1][j]-a[j][j+1]);\n\t\t\t\tFor(k,j+1,n){\n//\t\t\t\t\tdp[k][j]=max(dp[k][j],dp[i][j]+f[i][k-1]);\n\t\t\t\t\tdp[k][i]=max(dp[k][i],dp[i][j]+f[i][k-1]-g[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFor(k,i,n)\n\t\t\t\t\tdp[i][k]=max(dp[i][k],dp[i][j]+g[j][k]);\n\t\t\t}\n\t\t}\n\tcout<<g[1][n]-f[1][n]-ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nll a[500][500];\nll rsum[500][500];\nll dp[500][500];\n\nint main() {\n    cin >> n;\n    rep(i,n) rep(j,n) {\n        if (i == j) continue;\n        cin >> a[i][j];\n    }\n    rep(i,n) {\n        for (int j = i+1; j < n; j++) {\n            rsum[i][j] = rsum[i][j-1] + a[i][j];\n        }\n    }\n    rep(i,n) rep(j,n) dp[i][j] = linf;\n    dp[0][0] = 0;\n    rep(i,n) {\n        for (int j = i; j < n; j++) {\n            for (int k = j+1; k < n; k++) {\n                ll cnt = 0;\n                for (int u = j; u < k; u++) {\n                    cnt += rsum[u][k-1];\n                    /*\n                    for (int v = u+1; v < k; v++) {\n                        cnt += a[u][v];\n                    }\n                    */\n                }\n                for (int u = k; u < n; u++) {\n                    for (int v = i; v < j; v++) {\n                        cnt += a[u][v];\n                    }\n                }\n                dp[k][j] = min(dp[k][j], dp[j][i] + cnt);\n            }\n        }\n    }\n    ll ans = linf;\n    rep(i,n) {\n        for (int j = i+1; j < n; j++) {\n            ll cnt = 0;\n            for (int k = j; k < n; k++) {\n                cnt += rsum[k][n-1];\n                /*\n                for (int l = k+1; l < n; l++) {\n                    cnt += a[k][l];\n                }\n                */\n            }\n            ans = min(ans, dp[j][i]+cnt);\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 505;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nint val[MX][MX];\nll neg[MX][MX], pos[MX][MX], f[MX][MX];\n\nvoid input()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<i; j++)\n\t\t{\n\t\t\tread(val[i][j]);\n\t\t\tpos[i][j] += val[i][j];\n\t\t}\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tread(val[i][j]);\n\t\t\tneg[i][j] += val[i][j];\n\t\t}\n\t}\n\tfor(int i=0; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tpos[i][j] += pos[i][j-1];\n\t\t\tneg[i][j] += neg[i][j-1];\n\t\t}\n\tfor(int j=0; j<=n; j++)\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tpos[i][j] += pos[i-1][j];\n\t\t\tneg[i][j] += neg[i-1][j];\n\t\t}\n}\n\nvoid work()\n{\n\tmemset(f, 0x3f, sizeof(f));\n\tfor(int i=0; i<=n; i++) f[0][i] = neg[i][i];\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t{\n\t\t\tfor(int k=j+1; k<=n; k++)\n\t\t\t{\n\t\t\t\tll new_pos = pos[k][i] - pos[j][i];\n\t\t\t\tll new_neg = neg[k][k] - neg[j][k] - neg[k][j] + neg[j][j];\n\t\t\t\tcmin(f[j][k], f[i][j] + new_pos + new_neg);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int i=0; i<=n; i++) cmin(ans, f[i][n]);\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <list>\n \n// hloya template v25\n  \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n  \n#include <bits/stdc++.h>\n#include <valarray>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \nvoid bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid upmax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid upmin(T& x, T y) {\n    x = min(x, y);\n}\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-6;\nconst int maxn = (int)3e5 + 12;//, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst double PI = acos(-1.0);\n \nconst int mod = 1e9 + 7;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % mod;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % mod;\n    }\n}\n\nll dp[505][505];\nll a[505][505];\nll p[505][505], p2[505][505];\n\nll sum(int x1, int x2, int y1, int y2) {\n    assert(x1 <= x2 && y1 <= y2);\n    return p[x2][y2] - (x1 ? p[x1 - 1][y2] : 0) - (y1 ? p[x2][y1 - 1] : 0) +\n        ((x1&&y1) ? p[x1 - 1][y1 - 1] : 0);\n}\n\nll sum2(int x1, int x2, int y1, int y2) {\n    assert(x1 <= x2 && y1 <= y2);\n    return p2[x2][y2] - (x1 ? p2[x1 - 1][y2] : 0) - (y1 ? p2[x2][y1 - 1] : 0) +\n        ((x1&&y1) ? p2[x1 - 1][y1 - 1] : 0);\n}\n\nint main() {\n    // files1;\n    fast_io;\n\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            cin >> a[i][j];\n        }\n    memset(dp, -1, sizeof(dp));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            p[i][j] = (i < j ? a[i][j] : 0);\n            if (i)\n                p[i][j] += p[i - 1][j];\n            if (j)\n                p[i][j] += p[i][j - 1];\n            if (i && j)\n                p[i][j] -= p[i - 1][j - 1];\n\n            p2[i][j] = (i > j ? a[i][j] : 0);\n            if (i)\n                p2[i][j] += p2[i - 1][j];\n            if (j)\n                p2[i][j] += p2[i][j - 1];\n            if (i && j)\n                p2[i][j] -= p2[i - 1][j - 1];\n        }\n\n    ll ans = 0;\n\n    for (int i = 0; i + 1 < n; i++) {\n        ans = max(ans, sum(0, i, i + 1, n - 1) + sum2(0, n - 1, 0, n - 1));\n    }\n\n    for (int i = 0; i + 1 < n; i++)\n        for (int j = i + 1; j + 1 < n; j++) {\n            dp[i][j] = max(dp[i][j], sum(0, i, i + 1, n - 1) + sum(i + 1, j, j + 1, n - 1) + \n                        sum2(0, j, 0, j));\n\n            ans = max(ans, dp[i][j] + sum2(i + 1, n - 1, i + 1, n - 1) -\n                sum2(i + 1, j, i + 1, j));\n\n            for (int k = j + 1; k + 1 < n; k++) {\n                dp[j][k] = max(dp[j][k],\n                    dp[i][j] + sum(j + 1, k, k + 1, n - 1) + \n                    sum2(i + 1, k, i + 1, k) - sum2(i + 1, j, i + 1, j));\n            }\n        }\n    ll sum = p[n-1][n-1] + p2[n-1][n-1];\n    cout << sum - ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=505;\nll f[N][N],g[N][N],dp[N][N];\nll gf(int a,int b,int c,int d){//<=1,i>j\n\treturn f[b][d]+f[a][c]-f[a][d]-f[b][c];\n}\nll gg(int a,int b,int c,int d){//>=1,i<j\n\treturn g[b][d]+g[a][c]-g[a][d]-g[b][c];\n}\nint main(){\n\tint n=read();\n\tFor(i,1,n){\n\t\tFor(j,1,n){\n\t\t\tint x=0;\n\t\t\tif(i!=j)x=read();\n\t\t\tf[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1];\n\t\t\tg[i][j]=g[i-1][j]+g[i][j-1]-g[i-1][j-1];\n\t\t\tif(i>j)f[i][j]+=x; else g[i][j]+=x;\n\t\t}\n\t}\n\tll ans=gg(0,n,0,n);\n\tFor(i,1,n-1)ans=min(ans,gg(0,i,0,i)+gg(i,n,i,n));\n\tans-=gf(0,n,0,n);\n\tFor(i,1,n-1){\n\t\tFor(j,i+1,n-1){\n\t\t\tdp[i][j]=-gf(0,j,0,j)+gg(0,i,0,i)+gg(i,j,i,j);\n\t\t\tll zs=-gf(i,j,i,j)+gg(i,j,i,j); dp[i][j]-=zs;\n\t\t\tFor(k,1,i-1)dp[i][j]=min(dp[i][j],dp[k][i]-gf(i,j,k,i)); \n\t\t\tdp[i][j]+=zs;\n\t\t\tans=min(ans,dp[i][j]-gf(j,n,i,n)+gg(j,n,j,n));\n\t\t}\n\t}\n\tcout<<ans+gf(0,n,0,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[510][510];\nlong long f[510][510];\nlong long g[510][510];\nlong long dp[510][510];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t//f\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=n-1;j>=i;j--)\n\t\t\tf[i][j]=f[i][j+1]+a[j+1][i];\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=1;j<n;j++)\n\t\t\tf[i][j]+=f[i-1][j];\n\t//g\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i;j<n;j++)\n\t\t\tg[i][j]=g[i][j-1]+a[i][j+1];\n\tfor(int i=n-1;i>=1;i--)\n\t\tfor(int j=2;j<n;j++)\n\t\t\tg[i][j]+=g[i+1][j];\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tdp[i][j]=1e18;\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tif(k&&k==j)continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+g[j+1][i-1]+f[j][i]-f[k][i]);\n\t\t\t}\n\t\t}\n\tlong long ans=1e18;\n\tfor(int i=0;i<n;i++)\n\t\tans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 505;\nconst ll INF = 1e18;\n\nint N;\nll a[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 1; j <= N; j++)\n\t\t\tif (j != i)\n\t\t\t\tscanf(\"%lld\", a[i] + j);\n}\n\nll rectangle(int x1, int x2, int y1, int y2) {\n\treturn a[x2][y2] + a[x1 - 1][y1 - 1] - a[x1 - 1][y2] - a[x2][y1 - 1];\n}\n\nll rec(int l, int r) {\n\tll &ref = dp[l][r];\n\tif (ref != INF)\n\t\treturn ref;\n\tif (l == 1)\n\t\treturn ref = rectangle(l, r, l, r);\n\tfor (int i = 1; i < l; i++)\n\t\tref = min(ref, rec(i, l - 1) + rectangle(l, r, i, r));\n\treturn ref;\n}\n\nll solve() {\n\tfor (int i = 0; i <= N; i++)\n\t\tfor (int j = 0; j <= N; j++)\n\t\t\tdp[i][j] = INF;\n\t\t\t\n\tll sum = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tsum += a[i][j];\n\t\t\ta[i][j] = -a[i][j];\n\t\t}\n\t\t\n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = 1; j <= N; j++)\n\t\t\ta[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1];\n\t\n\tll best = INF;\n\tfor (int i = 1; i <= N; i++)\n\t\tbest = min(best, rec(i, N));\n\t\n\treturn sum + best;\n}\n\nint main() {\n\tload();\n\tprintf(\"%lld\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 510;\ntypedef long long LL;\nint n;\nLL A[MAXN][MAXN], B[MAXN][MAXN], dp[MAXN][MAXN];\nvoid getmin(LL & x, LL y) { x > y ? x = y : 0; }\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j < i; ++j) std::cin >> B[j][i];\n\t\tfor (int j = i + 1; j <= n; ++j) std::cin >> A[i][j];\n\t}\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tA[i][j] += A[i][j - 1];\n\tfor (int i = n; i; --i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tA[i][j] += A[i + 1][j];\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i; j <= n; ++j)\n\t\t\tB[i][j] += B[i - 1][j];\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = i; j <= n; ++j) {\n\t\t\tLL tot = 0;\n\t\t\tfor (int k = j + 1; k <= n; ++k) {\n\t\t\t\ttot += B[i][k];\n\t\t\t\tgetmin(dp[j][k], dp[i][j] + A[j + 1][k] + tot);\n\t\t\t}\n\t\t}\n\tLL ans = 0x3f3f3f3f3f3f3f3fLL;\n\tfor (int i = 1; i <= n; ++i) getmin(ans, dp[i][n]);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 507\n\nint N;\nll f[MAX_N][MAX_N], s1[MAX_N][MAX_N], s2[MAX_N][MAX_N];\n\ninline ll calc(int k, int j, int i) {\n    return s2[j + 1][i] + s1[N][j] - s1[N][k] - s1[i][j] + s1[i][k];\n}\n\nint main() {\n    read(N);\n    Rep(i, N) Rep(j, N) if (i != j) read(s1[i][j]);\n    Rep(j, N) IRep(i, j) s2[i][j] =\n        s2[i + 1][j] + s2[i][j - 1] - s2[i + 1][j - 1] + s1[i][j];\n    Rep(i, N) Rep(j, N) s1[i][j] +=\n        s1[i - 1][j] + s1[i][j - 1] - s1[i - 1][j - 1];\n    ll ans = 1e17;\n    Lep(i, N) {\n        f[i][0] = calc(0, 0, i);\n        chmin(ans, f[i][0] + calc(0, i, N));\n        Lep(j, i) {\n            f[i][j] = 1e17;\n            lep(k, 0, j) { chmin(f[i][j], f[j][k] + calc(k, j, i)); }\n            chmin(ans, f[i][j] + calc(j, i, N));\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 500;\nconst ll INF = ll(1E18);\nint A[MAXN + 5][MAXN + 5], B[MAXN + 5][MAXN + 5], n;\nll SA[MAXN + 5][MAXN + 5], SB[MAXN + 5][MAXN + 5];\nll dp[2][MAXN + 5][MAXN + 5], f[2][MAXN + 5], g[2];\nint main() {\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<=i-1;j++) scanf(\"%d\", &B[j][i-1]); // i -> j (i > j)\n        for(int j=i+1;j<=n;j++) scanf(\"%d\", &A[i][j-1]);\n    }\n    for(int j=1;j<=n;j++)\n        for(int i=1;i<=n;i++)\n            SA[i][j] = A[i][j] + SA[i-1][j], SB[i][j] = B[i][j] + SB[i-1][j];\n    n--;\n    for(int j=1;j<=n;j++) {\n        for(int k=j+1;k<=n;k++)\n            dp[0][j][k] = INF;\n        f[0][j] = INF;\n    }\n    g[0] = 0;\n    for(int i=1;i<=n;i++) {\n        for(int j=1;j<i;j++) {\n            for(int k=j+1;k<i;k++)\n                dp[1][j][k] = dp[0][j][k], dp[0][j][k] = INF;\n            f[1][j] = f[0][j], f[0][j] = INF;\n        }\n        g[1] = g[0], g[0] = INF;\n        for(int j=1;j<i;j++) {\n            for(int k=j+1;k<i;k++) {\n                dp[0][j][k] = min(dp[0][j][k], dp[1][j][k] + SA[i][i] - SA[k][i] + SB[j][i]);\n                dp[0][k][i] = min(dp[0][k][i], dp[1][j][k] + SB[k][i]);\n            }\n            f[0][j] = min(f[0][j], f[1][j] + SA[i][i] - SA[j][i]);\n            dp[0][j][i] = min(dp[0][j][i], f[1][j] + SB[j][i]);\n        }\n        g[0] = min(g[0], g[1] + SA[i][i]);\n        f[0][i] = min(f[0][i], g[1]);\n    }\n    ll mn = INF;\n    for(int j=1;j<=n;j++) {\n        for(int k=j+1;k<=n;k++)\n            mn = min(mn, dp[0][j][k]);\n        mn = min(mn, f[0][j]);\n    }\n    mn = min(mn, g[0]);\n    printf(\"%lld\\n\", mn);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=505;\nconst LL inf=(LL)1e17;\n\nint n;\nLL s1[N][N],s2[N][N],a[N][N],f[N][N];\n\nvoid pre()\n{\n\tfor (int l=1;l<n;l++)\n\t\tfor (int i=1;i+l<=n;i++)\n\t\t{\n\t\t\tint j=i+l;\n\t\t\ts1[i][j]=s1[i][j-1]+s1[i+1][j]-s1[i+1][j-1]+a[i][j];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=n;j>i;j--)\n\t\t\ts2[i][j]=s2[i][j+1]+a[j][i];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t\ts2[i][j]+=s2[i-1][j];\n}\n\nLL dp()\n{\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=n;j++)\n\t\t\tf[i][j]=inf;\n\tLL ans=s1[1][n];\n\tfor (int i=1;i<=n;i++) ans=std::min(ans,s1[1][i]+s1[i+1][n]);\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=s1[1][i]+s1[i+1][j]+s2[i][j+1];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t{\n\t\t\tans=std::min(ans,f[i][j]+s1[j+1][n]);\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tf[j][k]=std::min(f[j][k],f[i][j]+s1[j+1][k]+s2[j][k+1]-s2[i][k+1]);\n\t\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i!=j) scanf(\"%lld\",&a[i][j]);\n\tpre();\n\tprintf(\"%lld\\n\",dp());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 510 \nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nll f[N][N],pre[2][N][N],a[N][N]; int n;\nll calc(int ty,int xl,int xr,int yl,int yr){return pre[ty][xr][yr]-pre[ty][xl-1][yr]-pre[ty][xr][yl-1]+pre[ty][xl-1][yl-1];}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)\tfor(int j=1;j<=n;j++)\n\t{\n\t\tfor(int t=0;t<2;t++)\tpre[t][i][j]=pre[t][i-1][j]+pre[t][i][j-1]-pre[t][i-1][j-1];\n\t\tpre[i>j][i][j]+=a[i][j];\n\t}\n}\nvoid upd(ll &x,ll y){x=x<y?x:y;}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++)\ta[i][j]=read();\n\t\tfor(int j=i+1;j<=n;j++)\ta[i][j]=read();\n\t}\n\tinit(); memset(f,48,sizeof(f)); f[0][0]=0;\n\tfor(int i=0;i<=n;i++)\tfor(int j=0;j<max(1,i);j++)\n\t\tfor(int k=i+1;k<=n;k++) if(f[i][j]!=f[0][1])\n\t\t\tupd(f[k][i],f[i][j]+calc(0,i+1,k,i+1,k)+calc(1,k+1,n,j+1,i));\n\tll ans=f[0][1];\n\tfor(int i=1;i<=n;i++)\tupd(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nconst Int MAX = 505;\nconst Int INF = 1e18;\nInt dp[MAX][MAX][MAX];\n\nInt A[MAX][MAX];\n\n// S[j][i] = sum_{k=i}^{j-1} A[j][i]\n// T[i][k] = sum_{k=1}^{j}   A[i][k]\n\nInt S[MAX][MAX];\nInt T[MAX][MAX];\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n;\n  cin>>n;\n  for(Int i=1;i<=n;i++)\n    for(Int j=1;j<=n;j++)\n      if(i!=j) cin>>A[i][j];\n\n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      for(Int k=0;k<MAX;k++)\n        dp[i][j][k]=INF;\n\n  dp[1][0][0]=0;\n\n  for(Int i=1;i<=n;i++){\n    for(Int j=0;j<=n;j++)\n      for(Int p=i-1;p>j;p--)\n        S[j][i]+=A[p][i];\n\n    for(Int k=0;k<=n;k++)\n      for(Int q=k;q>0;q--)\n        T[i][k]+=A[i][q];\n  }\n\n  // k <= j <= i\n  for(Int i=1;i<n;i++){\n    for(Int j=0;j<i;j++){\n      for(Int k=0;k<=j;k++){\n        if(dp[i][j][k]>=INF) continue;\n\n        {\n          Int ni=i+1;\n          Int nj=j;\n          Int nk=k;\n          Int nc=S[nj][ni]+T[ni][nk];\n          chmin(dp[ni][nj][nk],dp[i][j][k]+nc);\n        }\n\n        for(Int x=i;x>j;x--){\n          Int ni=i+1;\n          Int nj=x;\n          Int nk=j;\n          Int nc=S[nj][ni]+T[ni][nk];\n          chmin(dp[ni][nj][nk],dp[i][j][k]+nc);\n        }\n      }\n    }\n  }\n\n  Int ans=INF;\n  for(Int j=0;j<n;j++)\n    for(Int k=0;k<=j;k++)\n      chmin(ans,dp[n][j][k]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nint n;\nint w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nint ans=2147483647;\n\ninline int getsum(int u,int v,int x,int y){\n\treturn p[v][y]-(x==0?0:p[v][x-1])-(u==0?0:p[u-1][y])+(u==0 || v==0?0:p[u-1][x-1]);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  scanf(\"%d\",&w[i][j]);\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=0x3f3f3f3f;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\ntemplate<typename T>\ninline int chkmin(T &x, T y) {\n  return x > y ? x = y, 1 : 0;\n}\n\nconst int MAXN = 500;\n\nint n;\nint A[MAXN + 9][MAXN + 9];\n\nlong long sum[2][MAXN + 9][MAXN + 9];\n\nvoid Calc_Sum() {\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      sum[0][i][j] += sum[0][i][j - 1];\n      sum[1][i][j] += sum[1][i][j - 1];\n    }\n    for (int j = 1; j <= n; ++j) {\n      sum[0][i][j] += sum[0][i - 1][j];\n      sum[1][i][j] += sum[1][i - 1][j];\n    }\n  }\n}\n\nlong long dp[MAXN + 9][MAXN + 9];\n\ninline long long cost(int opt, int lx, int rx, int ly, int ry) {\n  return sum[opt][rx][ry] - sum[opt][lx - 1][ry] - sum[opt][rx][ly - 1] + sum[opt][lx - 1][ly - 1];\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) \n    for (int j = 1; j <= n; ++j)\n      if (i != j) {\n        scanf(\"%d\", &A[i][j]);\n        i < j ? sum[0][i][j] = A[i][j] : sum[1][i][j] = A[i][j]; \n      }\n\n  Calc_Sum();\n\n  memset(dp, 0x3f, sizeof dp);\n  dp[0][0] = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < (!i ? 1 : i); ++j)\n      for (int k = i + 1; k <= n; ++k)\n        chkmin(dp[k][i], dp[i][j] + cost(1, k + 1, n, j + 1, i) + cost(0, i + 1, k, i + 1, k));\n\n  long long ans = 0x3f3f3f3f3f3f3f3fLL;\n  for (int i = 0; i <= n; ++i) chkmin(ans, dp[n][i]);\n\n  printf(\"%lld\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    auto N    = in<int>();\n    auto fass = make_v({N, N}, 0LL);\n    auto bass = make_v({N, N}, 0LL);\n    ll btotal = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            fsss[i][j] += fsss[i][j - 1];\n            bsss[i][j] += bsss[i][j - 1];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            fsss[i][j] += fsss[i - 1][j];\n            bsss[i][j] += bsss[i - 1][j];\n        }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto memo = make_v({N + 1, N + 1}, -1LL);\n    auto dp   = mfp([&](auto&& self, const int pp, const int p) -> ll {\n        if (p == N) { return 0; }\n        if (memo[pp][p] != -1LL) { return memo[pp][p]; }\n        ll ans = inf_v<ll>;\n        for (int np = p + 1; np <= N; np++) {\n            const ll fore = fsum(pp, p, np);\n            const ll back = bsum(pp, p, np);\n            SHOW(pp, p, np, fore);\n            SHOW(pp, p, np, back);\n            chmin(ans, fore + back + self(self, p, np));\n        }\n        SHOW(pp, p, ans);\n        return memo[pp][p] = ans;\n    });\n    SHOW(btotal);\n    outln(dp(0, 0) + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 510;\n\nint n, a[maxn][maxn];\nlong long from[maxn][maxn], to[maxn][maxn], dp[maxn][maxn][maxn], ans;\n\nvoid cmin(long long &x, long long y) { x = min(x, y); }\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) if (j != i) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tfrom[i][j] = (j?from[i][j-1]:0) + a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tto[i][j] = (j?to[i][j-1]:0) + a[j][i];\n\t\t}\n\t}\n\tmemset(dp, 0x3f, sizeof(dp));\n\tans = dp[0][0][0];\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = 0; k <= j; ++k) {\n\t\t\t\tcmin(dp[i+1][j][k], dp[i][j][k]+(to[i+1][i]-(j?to[i+1][j-1]:0))+(k?from[i+1][k-1]:0));\n\t\t\t\tcmin(dp[i+1][i+1][j], dp[i][j][k]+(j?from[i+1][j-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t\tfor (int k = 0; k <= j; ++k)\n\t\t\tcmin(ans, dp[n-1][j][k]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N = 505;\n\nint n;\nlong long a[N][N], pos[N][N], neg[N][N]; \nlong long ans, sum, f[N][N];\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tscanf(\"%d\", &n); \n\trep(i, 1, n) rep(j, 1, n) if (j != i) {\n\t\tscanf(\"%lld\", &a[i][j]); \n\t\tsum += a[i][j]; \n\t}\n\trep(i, 1, n) rep(j, i + 1, n) {\n\t\tpos[i][j] = a[j][i];\n\t\tneg[i][j] = a[i][j];\n\t}\n\trep(i, 1, n) dec(j, i - 1, 1) {\n\t\tpos[j][i] += pos[j + 1][i];\n\t\tneg[j][i] += neg[j + 1][i];\n\t}\n\trep(i, 1, n) rep(j, 1, (i > 1 ? i - 1 : 1)) {\n\t\tlong long w = 0;\n\t\t//Pr(\"f[%d][%d] = %lld\\n\", i, j, f[i][j]); \n\t\trep(k, i + 1, n + 1) {\n\t\t\tf[k][i] = max(f[k][i], f[i][j] + w + neg[1][k] + pos[i][k]);\n\t\t\t//assert(f[k][i] <= sum);\n\t\t\tw += pos[j][k] + neg[1][k] - neg[i][k];\n\t\t}\n\t}\n\trep(i, 1, n) ans = max(ans, f[n + 1][i]);\n\tprintf(\"%lld\\n\", sum - ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define int long long\n#define MAXN 506\nint n;\nint dp[MAXN][MAXN] , Sa[MAXN][MAXN] , Si[MAXN][MAXN];\nint A[MAXN][MAXN] , B[MAXN][MAXN];\nsigned main() {\n\tcin >> n;\n\tfor( int i = 1 ; i <= n ; ++ i ) {\n\t\tfor( int j = 1 ; j < i ; ++ j ) \n\t\t\tscanf(\"%lld\",&A[j][i]);\n\t\tfor( int j = i + 1 ; j <= n ; ++ j )\n\t\t\tscanf(\"%lld\",&B[i][j]);\n\t}\n\tfor( int i = 1 ; i <= n ; ++ i ) \n\t\tfor( int j = n ; j >= i + 1 ; -- j ) {\n\t\t\tSa[i][j] = Sa[i][j + 1];\n\t\t\tfor( int k = 1 ; k <= i ; ++ k ) Sa[i][j] += A[k][j];\n\t\t}\n\tfor( int i = 1 ; i <= n ; ++ i ) \n\t\tfor( int j = i + 1 ; j <= n + 1 ; ++ j ) {\n\t\t\tSi[i][j] = Si[i][j - 1];\n\t\t\tfor( int k = i ; k <= j - 1 ; ++ k ) Si[i][j] += B[k][j];\n\t\t}\n\tmemset( dp , 0x3f3f , sizeof dp );\n\tdp[0][0] = 0;\n\tfor( int i = 0 ; i <= n ; ++ i ) \n\t\tfor( int j = i ; j <= n ; ++ j )\n\t\t\tif( dp[i][j] < 0x3f3f3f3f3f3f3f3f ) {\n\t\t\t\tfor( int k = j + 1 ; k <= n + 1 ; ++ k ) \n\t\t\t\t\tdp[j][k] = min( dp[j][k] , dp[i][j] + Si[j + 1][k] + Sa[j][k + 1] - Sa[i][k + 1] );\n\t\t\t}\n\tint ans = 0x3f3f3f3f3f3f3f3f;\n\tfor( int i = 0 ; i <= n ; ++ i ) \n\t\tans = min( ans , dp[i][n + 1] );\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, A[510][510];\nll S1[510][510], S2[510][510];\nll dp[510][510];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<=N;j++) if(i != j) scanf(\"%d\", A[i] + j);\n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tS1[i][i] = 0;\n\t\tfor(int j=i+1;j<=N;j++) {\n\t\t\tS1[i][j] = S1[i][j-1];\n\t\t\tfor(int k=i;k<j;k++) {\n\t\t\t\tS1[i][j] += A[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tS2[i][j] = S2[i][j-1] + A[i][j];\n\t\t}\n\t}\n\trep(i, 510) rep(j, 510) dp[i][j] = 1e18;\n\tfor(int i=1;i<=N;i++) {\n\t\tdp[1][i] = S1[1][i];\n\t\tfor(int k=1;k<i;k++) {\n\t\t\tll sum = 0;\n\t\t\tfor(int j=i;j>k;j--) {\n\t\t\t\tsum += S2[j][k-1];\n\t\t\t\tdp[j][i] = min(dp[j][i], dp[k][j-1] + S1[j][i] + sum);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int i=1;i<=N;i++) ans = min(ans, dp[i][N]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nll F[505][505], A[505][505], B[505][505];\n\nvoid upd(ll &x, ll y) {\n\tif (x > y) x = y;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (j != i) {\n\t\t\t\tif (i < j) scanf(\"%lld\", A[i] + j);\n\t\t\t\telse scanf(\"%lld\", B[j] + i);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tA[i][j] += A[i - 1][j];\n\t\t\tB[i][j] += B[i - 1][j];\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tA[i][j] += A[i][j - 1];\n\t\t\tB[i][j] += B[i][j - 1];\n\t\t}\n\tmemset(F, 0x3f, sizeof F);\n\tF[0][0] = 0;\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = i; j <= n; ++j) {\n\t\t\tfor (int k = j + 1; k <= n; ++k)\n\t\t\t\tupd(F[j][k], F[i][j] + A[n][k] - A[j][k] + B[j][n] - B[j][k] - B[i][n] + B[i][k]);\n\t\t\tF[n + 1][0] = min(F[n + 1][0], F[i][j] + A[n][n] - A[j][n]);\n\t\t}\n\tprintf(\"%lld\\n\", F[n + 1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll sum[501][501];\nll dp[502][502];\nll cop[502][502];\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<ll>> a(n);\n\trep(i, n) {\n\t\ta[i].resize(n);\n\t\trep(j, n) {\n\t\t\tif (i == j)a[i][j] = 0;\n\t\t\telse cin >> a[i][j];\n\t\t}\n\t}\n\n\t//calc sum\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ts += a[k][j];\n\t\t\t}\n\t\t\tsum[i][j] = s;\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\t{\n\t\tll s = 0;\n\t\tfor (int j = n-1; j>0; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j][k] = s + sum[0][k] + sum[k + 1][j];\n\t\t\t}\n\n\t\t\ts += a[j][0];\n\t\t}\n\t\t/*cout << \"0 is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tfor (int i = 1; i < n-1; i++) {\n\t\trep(j, n + 1)rep(k, n + 1)cop[j][k] = INF;\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tfor (int k = i-1; k <= j; k++) {\n\t\t\t\tif (dp[j][k] == 0)continue;\n\t\t\t\tll s = 0;\n\t\t\t\tif (k >= i) {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tcop[l][k] = min(cop[l][k], s+dp[j][k] + sum[k + 1][l] - sum[k + 1][j]);\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tfor (int m = j; m <= l; m++) {\n\t\t\t\t\t\t\tcop[l][m] = min(cop[l][m], s + dp[j][k] + sum[i][m] - sum[i][j] + sum[m+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, n + 1)rep(k, n + 1)dp[j][k]=cop[j][k];\n\n\t\t/*cout << i << \" is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tll ans = INF;\n\t/*rep(i, n)rep(j, n) {\n\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}*/\n\trep(i, n+1)rep(j, n+1)ans = min(ans, dp[i][j]);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 505;\nconst ll INF = 1000000000000000;\nint n, x;\nll w[MAXN][MAXN], s[MAXN][MAXN], t[MAXN][MAXN], dp[MAXN][MAXN];\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++) if(i!=j) scanf(\"%d\", w[i]+j);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+w[i][j];\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)\n\t\t\tt[i][j]=t[i-1][j]+t[i][j-1]-t[i-1][j-1]+(i<j?w[i][j]:0);\n\t\tfor(int i=1; i<=n; i++){\n\t\tdp[i][1]=t[i][i]-t[0][i]-t[i][0]+t[0][0];\n\t\tfor(int j=2; j<=i; j++){\n\t\t\tdp[i][j]=INF;\n\t\t\tfor(int k=1; k<j; k++)\n\t\t\t\tdp[i][j]=min(dp[i][j], dp[j-1][k]+t[i][i]-t[i][j-1]-t[j-1][i]+t[j-1][j-1]+s[i][k-1]-s[j-1][k-1]);\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(int i=1; i<=n; i++) ans=min(ans, dp[n][i]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=520;\nconst ll inf=0x3f3f3f3f3f3f3f3f;\n\nint n;\nll A[maxn][maxn];\nll B[maxn][maxn];\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)REP(j,1,n)\n\t\tif(i<j)A[i][j]=read();\n\t\telse if(i>j)B[j][i]=read();\n\tREP(i,1,n)REP(j,1,n)A[i][j]+=A[i-1][j];\n\tREP(i,1,n)REP(j,1,n)A[i][j]+=A[i][j-1];\n\tREP(i,1,n)REP(j,1,n)B[i][j]+=B[i-1][j];\n\tREP(i,1,n)REP(j,1,n)B[i][j]+=B[i][j-1];\n\t\n}\n\nll f[maxn][maxn];\n\ninline ll matrixA(int x1,int x2,int y1,int y2)\n{\n\tif(x1>x2 || y1>y2)return 0;\n\treturn A[x2][y2]-A[x1-1][y2]-A[x2][y1-1]+A[x1-1][y1-1];\n}\n\ninline ll matrixB(int x1,int x2,int y1,int y2)\n{\n\tif(x1>x2 || y1>y2)return 0;\n\treturn B[x2][y2]-B[x1-1][y2]-B[x2][y1-1]+B[x1-1][y1-1];\n}\n\ninline void doing()\n{\n\tmemset(f,inf,sizeof(f));\n\tf[0][0]=0;\n\tREP(i,0,n-1)REP(j,0,i)if(f[i][j]!=inf)\n\t{\n\t\tREP(k,i+1,n-1)\n\t\t{\n\t\t\tchkmin(f[k][i],f[i][j]+matrixA(i+1,k-1,i+1,k)+matrixB(1,j,i+1,k));\n\t\t}\n\t}\n\tll ans=inf;\n\tREP(i,0,n-1)REP(j,0,i)if(f[i][j]!=inf)\n\t{\n\t\tchkmin(ans,f[i][j]+matrixA(i+1,n,i+1,n)+matrixB(1,j,i+1,n));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define gmi(a,b) a=(a)<(b)?(a):(b)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define FOF(i,a,b) for(int i=a;i< b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=550,INF=1000010000;\nint n,x;\nll ans,a[N][N],b[N][N],f[N][N];\nll SB(int x,int y){return b[x][x]-b[x][y]-b[y][x]+b[y][y];}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOF(i,0,n)FOF(j,0,n)if(i!=j){\n\t\tscanf(\"%d\",&x);\n\t\tj<i?a[j+1][i]=x:b[i+1][j]=x;\n\t}\n\tFOR(i,1,n)FOR(j,1,n){\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\t\tb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n\t}\n\tFOR(i,1,n)FOR(j,0,i) f[i][j]=INF;\n\tFOR(i,1,n)FOR(j,0,i)FOR(k,0,j)\n\t\tgmi(f[i][j],f[j][k]+a[k][i-1]-a[k][j-1]+SB(i-1,j));\n\t//FOR(i,1,n)FOR(j,0,i-1) cout<<f[i][j]<<\" \\n\"[j==i-1];\n\tans=INF;\n\tFOF(j,0,n) ans=min(ans,f[n][j]);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n    const int64_t INF = 1e18;\n\nstruct Dinic{\n    struct edge {\n        int64_t to, cap, rev;\n        edge(int64_t to, int64_t cap, int64_t rev):to(to), cap(cap), rev(rev){}\n    };\n\n    int N, S, T;\n    int64_t flow = 0;\n\n    vector<int> level, iter;\n    vector<vector<edge>> G;\n\n    Dinic(int N, int S, int T):N(N), S(S), T(T){\n        flow = 0;\n        level.resize(N);\n        iter.resize(N);\n        G.resize(N);\n    }\n\n    void add_edge(int from, int to, int64_t cap){\n        G[from].emplace_back(to, cap, G[to].size());\n        G[to].emplace_back(from, 0, G[from].size()-1);\n    }\n\n    void bfs(int s){\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(que.size()){\n            int v = que.front(); que.pop();\n            for(auto& e : G[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int64_t dfs(int v, int t, int64_t f){\n        if(v == t) return f;\n        for(int& i=iter[v]; i<G[v].size(); i++){\n            auto& e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int64_t d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int64_t max_flow(){\n        while(true){\n            bfs(S);\n            if(level[T] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            while(true){\n                int64_t f = dfs(S, T, INF);\n                if(f == 0) break;\n                flow += f;\n            }\n        }\n    }\n};\n\nint code(int x, int y){\n    return x*1001 + (y+500);\n}\n\nint main(){\n    int N, A[500][500];\n    cin >> N;\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++) if(i!=j) cin >> A[i][j];\n\n    int S = 500*1001;\n    int T = S+1;\n    Dinic solver(T+1, S, T);\n\n    for(int i=0; i<N-1; i++) for(int d=-N; d<=N; d++) solver.add_edge(code(i, d), code(i+1, d), INF);\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++) if(i != j) for(int d=-N; d<=N; d++){\n        if(i < j && d-1 >= -N) solver.add_edge(code(i, d), code(j, d-1), A[i][j]);\n        if(i > j && d+1 <=  N) solver.add_edge(code(i, d), code(j, d+1), A[i][j]);\n    }\n\n    solver.add_edge(S, code(N-1, 0), INF);\n    for(int d=-N; d<0; d++) solver.add_edge(code(N-1, d), T, INF);\n    cout << solver.max_flow() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long hxtype;\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst int N=505;\nll a[N][N],s1[N][N],s2[N][N],dp[N][N];\ninline ll get(int a,int b,int c){return s2[c][a]-s2[b-1][a]-s1[b][c];}\nint main(){\n\tint n,i,j,k;ll sum=0ll,w;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tfor(j=  1;j!=i;++j){scanf(\"%lld\",&a[i][j]);sum+=a[i][j];}\n\t\tfor(j=i+1;j<=n;++j){scanf(\"%lld\",&a[i][j]);sum+=a[i][j];}\n\t}\n\tfor(i=n;i   ;--i)for(j=i;j<=n;++j)s1[i][j]=s1[i+1][j]+s1[i][j-1]-s1[i+1][j-1]+a[i][j];\n\tfor(i=1;i<=n;++i)for(j=n;j   ;--j)s2[i][j]=s2[i-1][j]+s2[i][j+1]-s2[i-1][j+1]+a[i][j];\n\tfor(i=1;i<=n;++i)dp[1][i]=get(1,1,i);\n\tfor(i=2;i<=n;++i)for(j=i;j<=n;++j){\n\t\tw=0ll;\n//\t\tfor(k=1;k!=i;++k)printf(\"dp[%d][%d] %lld+%lld => dp[%d][%d]\\n\",k,i-1,dp[k][i-1],get(k,i,j),i,j);\n\t\tfor(k=1;k!=i;++k)cmax(w,dp[k][i-1]+get(k,i,j));\n\t\tdp[i][j]=w;\n\t}\n//\tprintf(\"S1\\n\");\n//\tfor(i=1;i<=n;++i){for(j=1;j<=n;++j)printf(\"%lld \",s1[i][j]);printf(\"\\n\");}\n//\tprintf(\"S2\\n\");\n//\tfor(i=1;i<=n;++i){for(j=1;j<=n;++j)printf(\"%lld \",s2[i][j]);printf(\"\\n\");}\n//\tprintf(\"DP\\n\");\n//\tfor(i=1;i<=n;++i){for(j=1;j<=n;++j)printf(\"%lld \",dp[i][j]);printf(\"\\n\");}\n\tw=0ll;\n\tfor(i=1;i<=n;++i)cmax(w,dp[i][n]);\n\tprintf(\"%lld\",sum-w);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/30.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\nint main(){\n    int n;\n    cin >> n;\n    mtl a(n, vl(n, 0));\n    ll total = 0;\n    rep(i, n){\n        rep(j, i) cin >> a[i][j], total += a[i][j];\n        repl(j, i + 1, n) cin >> a[i][j], total += a[i][j];\n        reverse(all(a[i]));\n    }\n    reverse(all(a));\n    mtl x(n + 1, vl(n + 1, 0)), y(n + 1, vl(n + 1, 0));\n    repl(i, 1, n+1){\n        repl(j, 1, i){\n            x[i][j] = x[i][j - 1] + a[i - 1][j - 1];\n        }\n        per(j, i - 1){\n            y[i][j] = y[i][j + 1] + a[j][i - 1];\n        }\n    }\n    mtl dp(n + 1, vl(n + 1, 0));\n    repl(i, 1, n + 1){\n        dp[0][i] = dp[0][i - 1] + y[i][0];\n    }\n    rep(i, n+1){\n        repl(j, i + 1, n+1){\n            ll d = 0;\n            repl(k, j + 1, n + 1){\n                d += x[k][j] + y[k][i];\n                dp[j][k] = max(dp[j][k], dp[i][j] + d);\n            }\n        }\n    }\n    ll ans = 0;\n    rep(i, n) ans = max(ans, dp[i][n]);\n    cout << total - ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 505\ntypedef long long ll;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\ninline ll read(){\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint a[N][N],n;\nll dp[N][N],s[2][N][N],ans;\ninline ll calc(int i,int X1,int Y1,int X2,int Y2){\n\treturn s[i][X2][Y2]-s[i][X1-1][Y2]-s[i][X2][Y1-1]+s[i][X1-1][Y1-1];\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i==j)continue;\n\t\t\ta[i][j]=read();\n\t\t}\n\t}\n\tans=inf;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\ts[0][i][j]=s[0][i-1][j]+s[0][i][j-1]-s[0][i-1][j-1]+(i<j?a[i][j]:0);\n\t\t\ts[1][i][j]=s[1][i-1][j]+s[1][i][j-1]-s[1][i-1][j-1]+(j<i?a[i][j]:0);\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int k=i+1;k<=n;++k){\n\t\t\t\tdp[k][i]=min(dp[k][i],dp[i][j]+calc(0,i+1,i+1,k,k)+calc(1,i+1,1,k,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tans=min(ans,dp[n][i]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nconstexpr long long INF = 1'000'000'000'000'000'000;\nint n;\nstd::vector<std::vector<int>> a;\nstd::vector<std::vector<long long>> dp, sum, rsum;\nlong long query(std::vector<std::vector<long long>> &v, int l, int r, int d, int u) {\n    return v[r][u] - v[r][d] - v[l][u] + v[l][d];\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cin >> n;\n    a.assign(n, std::vector<int>(n));\n    dp.assign(n, std::vector<long long>(n, INF));\n    sum.assign(n + 1, std::vector<long long>(n + 1));\n    rsum.assign(n + 1, std::vector<long long>(n + 1));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                std::cin >> a[i][j];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + a[i][j];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            rsum[i + 1][j + 1] = rsum[i + 1][j] + rsum[i][j + 1] - rsum[i][j] + (i < j ? a[i][j] : 0);\n    long long ans = INF;\n    dp[0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            ans = std::min(ans, dp[i][j] + query(rsum, j, n, j, n));\n            for (int k = j + 1; k < n; ++k)\n                dp[j][k] = std::min(dp[j][k], dp[i][j] + query(rsum, j, k, j, k) + query(sum, k, n, i, j));\n        }\n    }\n    std::cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 505;\nconst LL inf = 0x3f3f3f3f3f3f3f3f;\n\nLL dp[2][N][N], sum1[N][N], sum2[N][N], ans = inf;\nint n;\n\nvoid down(LL &x, LL y) { x = std::min(x, y); }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tstd::cin >> sum1[i][j];\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tstd::cin >> sum2[j][i];\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tsum1[i][j] += sum1[i][j - 1], sum2[i][j] += sum2[i][j - 1];\n\tdp[1][1][0] = 0;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint now = i & 1, lst = now ^ 1;\n\t\tstd::memset(dp[now], 0x3f, sizeof dp[0]);\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tfor (int k = 0; k < j; ++k) if (dp[lst][j][k] < inf) {\n\t\t\t\tdown(dp[now][j][k], dp[lst][j][k] + sum1[i][k - 1] + sum2[i][i - 1] - sum2[i][j - 1]);\n\t\t\t\tdown(dp[now][i][j], dp[lst][j][k] + sum1[i][j - 1]);\n\t\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tdown(ans, dp[n & 1][i][j]);\n\tstd::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2019年07月22日 星期一 11时13分09秒\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 555;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nint n, a[maxn][maxn];\nll dp[maxn][maxn], pre1[maxn][maxn], pre2[maxn][maxn];\nvoid upd(ll &x, ll y) { if(x > y) x = y; }\n\nint main() {\n    scanf(\"%d\", &n);\n    rep(i, n) rep(j, n) if(i != j) scanf(\"%d\", &a[i][j]);\n    rep(i, n) rep(j, n) {\n        pre1[i][j] = pre1[i - 1][j] + pre1[i][j - 1] - pre1[i - 1][j - 1] + a[i][j];\n        pre2[i][j] = pre2[i - 1][j] + pre2[i][j - 1] - pre2[i - 1][j - 1] + (i<j ? a[i][j] : 0);\n    }\n\n    memset(dp, 0x3f, sizeof dp);\n\n    dp[0][0] = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int last = 0; last <= i; ++last) {\n            for(int j = i + 1; j <= n; ++j) {\n                upd(dp[j][i], dp[i][last] + pre1[j][last] - pre1[i][last] + pre2[j][j] - pre2[i][j] - pre2[j][i] + pre2[i][i]); \n            }\n        }\n    }\n    ll ans = INF;\n    for(int last = 0; last < n; ++last)\n        upd(ans, dp[n][last]);\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  auto d = make_higher_vector<3, lint>(n, n + 1, n + 1);\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      at(d, j, k, 0) = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf) continue;\n        dp[j][k] = std::min(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n// #define inf    0x7f7f7f7f\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x3f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 1e18)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 1e18;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n;\nint a[505][505];\nll s1[505][505], s2[505][505];\nll dp[2][505][505];\nint main()\n{\n    cin>>n;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(i==j) continue;\n            cin>>a[i][j];\n        }\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++) s1[i][j+1]=s1[i][j]+a[i][j];\n        for(int j=0; j<n; j++) s2[i][j+1]=s2[i][j]+a[j][i];\n    }\n    const ll INF=1e18;\n    dp[0][0][1]=0;\n    for(int i=1; i<n; i++){\n        for(int j=0; j<=i+1; j++) for(int k=1; j+k<=i+1; k++) dp[i&1][j][k]=INF;\n        for(int j=0; j<=i; j++){\n            for(int k=1; j+k<=i; k++){\n                if(dp[(i&1)^1][j][k]==INF) continue;\n                dp[i&1][j][k+1]=min(dp[i&1][j][k+1], dp[(i&1)^1][j][k]+s2[i][i]-s2[i][i-k]+s1[i][i-j-k]);\n                dp[i&1][k][1]=min(dp[i&1][k][1], dp[(i&1)^1][j][k]+s1[i][i-k]);\n                dp[i&1][0][1]=min(dp[i&1][0][1], dp[(i&1)^1][j][k]+s1[i][i]);\n            }\n        }\n    }\n    ll ans=INF;\n    for(int i=0; i<=n; i++){\n        for(int j=1; i+j<=n; j++) ans=min(ans, dp[(n-1)&1][i][j]);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_N(505);\ntypedef long long int LL;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N;\nLL A[Max_N][Max_N], Sum1[Max_N][Max_N], Sum2[Max_N][Max_N], F[Max_N][Max_N], Ans;\n\ninline LL query1(int l1, int r1, int l2, int r2)\n{\n\treturn Sum1[r1][r2] - Sum1[l1 - 1][r2] - Sum1[r1][l2 - 1] + Sum1[l1 - 1][l2 - 1];\n}\n\ninline LL query2(int l1, int r1, int l2, int r2)\n{\n\treturn Sum2[r1][r2] - Sum2[l1 - 1][r2] - Sum2[r1][l2 - 1] + Sum2[l1 - 1][l2 - 1];\n}\n\ninline void upd(LL &a, LL b)\n{\n\ta = min(a, b);\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tfor (int j = 1;j <= N;++j)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t\tgi(A[i][j]);\n\t\t\tSum1[i][j] = Sum1[i - 1][j] + Sum1[i][j - 1] - Sum1[i - 1][j - 1] + A[i][j] * (i < j);\n\t\t\tSum2[i][j] = Sum2[i - 1][j] + Sum2[i][j - 1] - Sum2[i - 1][j - 1] + A[i][j] * (i > j);\n\t\t}\n\tAns = Sum1[N][N];\n\tfor (int x = 1;x <= N - 1;++x)\n\t\tAns = min(Ans, query1(1, x, 1, x) + query1(x + 1, N, x + 1, N));\n\tmemset(F, 0X3F, sizeof(F));\n\tfor (int a = 1;a <= N - 1;++a)\n\t\tfor (int b = a + 1;b <= N - 1;++b)\n\t\t{\n\t\t\tupd(F[a][b], query1(1, a, 1, a) + query1(a + 1, b, a + 1, b) + query2(b + 1, N, 1, a));\n\t\t\tfor (int c = b + 1;c <= N - 1;++c)\n\t\t\t\tupd(F[b][c], F[a][b] + query1(b + 1, c, b + 1, c) + query2(c + 1, N, a + 1, b));\n\t\t\tupd(Ans, F[a][b] + query1(b + 1, N, b + 1, N));\n\t\t}\n\tprint(Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing i64 = long long;\n\nconst int N = 500 + 7;\n\nint n;\ni64 a[N][N], f[N][N], g[N][N], h[N][N], ans;\n\ni64 s(i64 f[N][N], int i1, int i2, int j1, int j2) {\n\treturn f[i2][j2] + f[i1][j1] - f[i2][j1] - f[i1][j2];\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (i != j) scanf(\"%lld\", a[i] + j);\n\t\t\t(i < j ? f[i][j] : g[j][i]) = a[i][j];\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tf[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1],\n\t\t\tg[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1];\n\tans = s(g, 0, n, 0, n);\n\tfor (int i = 1; i < n; ++i) {\n\t\th[i][0] = s(f, 0, i, i, i + 1) + s(g, 0, i, 0, i + 1);\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tfor (int k = 0; k < j; ++k)\n\t\t\t\th[i][j] = std::max(h[i][j], h[j][k] + s(f, 0, i, i, i + 1) + s(f, 0, j, j + 1, i) + s(g, j, i, i, i + 1) + s(g, k, i, j + 1, i) );\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = 0; j < i; ++j)\n\t\t\tans = std::max(ans, h[i][j] + s(f, 0, i, i + 1, n) + s(g, j, n, i + 1, n));\n\tprintf(\"%lld\\n\", s(f, 0, n, 0, n) + s(g, 0, n, 0, n) - ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid chmin(int64_t& a, int64_t b){\n    a = min(a, b);\n}\n\nint main(){\n    int N;\n    int64_t A[500][500] = {0}, Spos[501][501] = {0}, Sneg[501][501] = {0};\n    cin >> N;\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++) if(i!=j){\n        cin >> A[i][j];\n        (i < j ? Sneg[i+1][j+1] : Spos[i+1][j+1]) = A[i][j];\n    }\n\n    for(int i=0; i<N; i++) for(int j=0; j<N; j++){\n        Spos[i+1][j+1] += Spos[i+1][j] + Spos[i][j+1] - Spos[i][j];\n        Sneg[i+1][j+1] += Sneg[i+1][j] + Sneg[i][j+1] - Sneg[i][j];\n    }\n\n    const int64_t INF = 1e18;\n    int64_t dp[501][501];\n    for(int i=0; i<=N; i++) for(int j=0; j<=N; j++) dp[i][j] = INF;\n    dp[N][N] = 0;\n    for(int i=N; i>=0; i--) for(int j=N; j>=i; j--) for(int k=i-1; k>=0; k--){\n        int64_t res = dp[i][j];\n        res += Sneg[i][i] - Sneg[i][k] - Sneg[k][i] + Sneg[k][k];\n        res += Spos[N][i] - Spos[N][k] - Spos[j][i] + Spos[j][k];\n        chmin(dp[k][i], res);\n    }\n\n    int64_t ans = INF;\n    for(int j=0; j<=N; j++) chmin(ans, dp[0][j]);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\ntypedef vector<LL> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> PI; \ntypedef pair<LL,LL> PLL;\ntypedef unsigned long long ULL;\ntypedef pair<double,double> PD;\n\n#define FOR(x, b, e) for(int x = b; x<= (e); x++)\n#define FORD(x, b, e) for(int x = b; x>= (e); x--)\n#define REP(x, n) for(int x = 0; x<(n); ++x)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(x) ((int)(x).size())\n\n#define PB push_back\n#define IN insert\n#define ST first\n#define ND second\n#define INF 2000000011\n#define MOD 1000000007\n\n#define MAXS 510\n\nint n;\n\nint main(){\n\t\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\t\n\tVVL dp(n,VL(n,LONG_LONG_MAX));\n\tVVL pref(n,VL(n));\n\tVVI tab(n,VI(n));\n\t\n\tFOR(i,0,n-1){\n\t\tFOR(j,0,n-1){\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\tcin>>tab[i][j];\n\t\t}\n\t}\n\t\n\tFOR(dl,1,n){\n\t\tREP(i,n){\n\t\t\tint j=dl+i;\n\t\t\tif(j>=n)\n\t\t\t\tbreak;\n\t\t\tif(dl==1){\n\t\t\t\tpref[i][j]=tab[i][j];\n\t\t\t\tpref[j][i]=tab[j][i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpref[i][j]=pref[i][j-1]+pref[i+1][j]-pref[i+1][j-1]+tab[i][j];\n\t\t\t\tpref[j][i]=pref[j-1][i]+pref[j][i+1]-pref[j-1][i+1]+tab[j][i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(i==0){\n\t\t\tFOR(j,0,n-1)\n\t\t\t\tdp[0][j]=min(dp[0][j],pref[0][j]);\n\t\t}\n\t\telse{\n\t\t\tFOR(j,i,n-1)\n\t\t\t\tREP(k,i)\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[k][i-1]+pref[i][j]+pref[j][0]-pref[j][k]-pref[i-1][0]+pref[i-1][k]);\n\t\t}\n\t}\n\t\n\tLL wyn=LONG_LONG_MAX;\n\tREP(i,n)\n\t\twyn=min(wyn,dp[i][n-1]);\n\tcout<<wyn;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=505;\nint a[MAXN][MAXN],n;\nLL f[MAXN][MAXN],g[MAXN],s1[MAXN][MAXN],s2[MAXN][MAXN];\nint s[MAXN];\nint main()\n{\n//\tfreopen(\"d.in\",\"r\",stdin);\n//\tfreopen(\"d.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)a[i][j]=read();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)s1[i][j]=s1[i][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)s2[j][i]=s2[j][i-1]+a[i][j];\n\tmemset(f,63,sizeof(f));LL INF=f[0][0];\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tf[i][0]=0;\n\t\tfor(int j=1;j<=i;j++)f[i][0]+=s1[j][i]-s1[j][j];\n\t}\n\tfor(int i=1;i<n;i++)for(int j=0;j<i;j++)if(f[i][j]!=INF)\n\t{\n\t\tLL sum=0;\n\t\tfor(int k=i+1;k<=n;k++)\n\t\t{\n\t\t\tsum+=s2[k][k]-s2[k][i]+s1[k][j];\n\t\t\tf[k][i]=min(f[k][i],f[i][j]+sum);\n\t\t}\n\t}\n\tLL ans=(1LL<<63-1);\n\tfor(int i=0;i<n;i++)ans=min(ans,f[n][i]);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=500 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL v[2][NN][NN]={};\nLL dp[2][NN][NN]={};\nvoid upd(LL &x,LL y){\n\tx=max(x,y);\n}\nLL vof(int kd,int l,int r,int x){\n\treturn v[kd][r][x]-v[kd][l-1][x];\n}\nint main(){\n\t//open();\n\tn=read();\n\tmemset(dp,-60,sizeof dp);\n\tLL sum=0;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i==j)continue;\n\t\t\tLL x=read();\n\t\t\tsum+=x;\n\t\t\tif(i<j){\n\t\t\t\tv[1][i][j]=x;\n\t\t\t}\n\t\t\telse v[0][j][i]=x;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tv[1][i][j]+=v[1][i-1][j];\n\t\t\tv[0][i][j]+=v[0][i-1][j];\n\t\t}\n\t}\n\tdp[0][0][0]=0;\n\tint now=0;\n\tfor(int i=1;i<=n;++i){\n\t\tnow^=1;\n\t\tfor(int j=0;j<=i;++j){\n\t\t\tfor(int l=0;l<=i;++l){\n\t\t\t\tdp[now][j][l]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<i;++j){\n\t\t\tfor(int l=j;l<i;++l){\n\t\t\t\tupd(dp[now][j][l],dp[now^1][j][l]);\n\t\t\t\tupd(dp[now][l][i],dp[now^1][j][l]);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<i;++j){\n\t\t\tfor(int l=j;l<=i;++l){\n\t\t\t\tdp[now][j][l]+=vof(0,j+1,i,i+1)+vof(1,1,l,i+1);\n\t\t\t}\n\t\t}\n\t}\n\tLL ans=0;\n\tfor(int j=0;j<n;++j){\n\t\tfor(int l=j;l<=n;++l){\n\t\t\tupd(ans,dp[now][j][l]);\n\t\t}\n\t}\n\tans=sum-ans;\n\tprintf(\"%lld\\n\",ans);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 503;\nconst lint linf = 0x3f3f3f3f3f3f3f3f;\n\nint n;\nlint val[_][_]={0},spv[_][_]={0},snv[_][_]={0};\nlint f[_][_];\n\nint main()\n{\n\tn=ty();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)val[i][j]=ty();\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j>=i+1;j--)\n\t\t{\n\t\t\tspv[i][j]=spv[i][j+1];\n\t\t\tfor(int k=1;k<=i;k++)spv[i][j]+=val[j][k];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n+1;j++)\n\t\t{\n\t\t\tsnv[i][j]=snv[i][j-1];\n\t\t\tfor(int k=i;k<j;k++)snv[i][j]=snv[i][j]+val[k][j];\n\t\t}\n\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<linf)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+(spv[j][k+1]-spv[i][k+1])+snv[j+1][k]);\n\tlint ans=linf;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][n+1]);\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n;\nll w[505][505];\nll dp[505][505];\nll sum[505][505];\nll tot[505][505];\ninline ll calc(int a,int b,int c,int d){\n\treturn sum[b][d]-(a==0?0:sum[a-1][d])-(c==0?0:sum[b][c-1])-(a==0||b==0?0:sum[a-1][c-1]);\n}\nint main(){\n//\tfreopen(\"park.in\",\"r\",stdin);\n//\tfreopen(\"park.out\",\"w\",stdout); \n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tscanf(\"%d\",&w[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i-1][j]+tot[i][j-1]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=1e18;\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1]+calc(j,i,0,k-1));\n\t\t} \n\t}\t\t\n\tll ans=1e18;\n\tfor(int i=1;i<=n;i++) ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505;\nint f[505][505],sum[2][505][505];\nint calc(int type,int x1,int y1,int x2,int y2){\n\treturn sum[type][x2][y2]-sum[type][x1-1][y2]-sum[type][x2][y1-1]+sum[type][x1-1][y1-1];\n}\nint a[505][505];\nvoid add(int &x,int y){\n\tx=min(x,y);\n}\nsigned main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tif(i==j) continue;\n\t\t\tcin>>a[i][j];\n\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j){\n\t\t\tsum[0][i][j]=sum[0][i-1][j]+sum[0][i][j-1]-sum[0][i-1][j-1]+(i<j?a[i][j]:0);\n\t\t\tsum[1][i][j]=sum[1][i-1][j]+sum[1][i][j-1]-sum[1][i-1][j-1]+(i>j?a[i][j]:0);\n\t\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=i;++j)\n\t\t\tfor(int k=i+1;k<=n;++k)\n\t\t\t\tadd(f[k][i],f[i][j]+calc(0,i+1,i+1,k,k)+calc(1,i+1,1,k,j));\n\tint ans=1e18;\n\tfor(int i=0;i<n;++i)\n\t\tadd(ans,f[n][i]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 505\n#define INF 1000000000000000000LL\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nint a[MAXN][MAXN];\nll sum[2][MAXN][MAXN];\nll dp[MAXN][MAXN];\nll getcost(int id,int fromx,int fromy,int tox,int toy)\n{\n    if(fromx>fromy||tox>toy) return 0;\n    return sum[id][fromy][toy]-sum[id][fromx-1][toy]-sum[id][fromy][tox-1]+sum[id][fromx-1][tox-1];\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            if(i==j) continue;\n            scanf(\"%d\",&a[i][j]);\n        }\n    for(int k=0;k<2;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n            {\n                int add=(i<j?1:0)^(k==0?1:0);\n                sum[k][i][j]=sum[k][i][j-1]+a[i][j]*(1-add);\n            }\n    for(int k=0;k<2;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                sum[k][i][j]=sum[k][i][j]+sum[k][i-1][j];\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            dp[i][j]=INF;\n    //\n    dp[0][0]=0;\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=0;j<=n;j++)\n        {\n            if(dp[i][j]==INF) continue;\n            for(int k=i+1;k<=n;k++)\n                dp[k][i]=min(dp[k][i],dp[i][j]+getcost(1,k+1,n,j+1,i)+getcost(0,i+1,k,i+1,k));\n        }\n    }\n    ll ans=INF;\n    for(int i=0;i<=n;i++) ans=min(ans,dp[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<vector<ll>> A(n,vector<ll>(n,0));\n    ll all=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i==j){continue;}\n            cin>>A[i][j];\n            all+=A[i][j];\n        }\n    }\n    vector<vector<ll>> upper(n,vector<ll>(n,0));\n    vector<vector<ll>> lower(n,vector<ll>(n,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i<j){upper[i][j]=A[i][j];}\n            else{lower[i][j]=A[i][j];}\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j<n;j++){\n            upper[i][j]+=upper[i-1][j];\n            lower[i][j]+=lower[i-1][j];\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=1;j<n;j++){\n            upper[i][j]+=upper[i][j-1];\n            lower[i][j]+=lower[i][j-1];\n        }\n    }\n    \n    auto sum2=[](const vector<vector<ll>> &Ab,ll x,ll y)->ll{return (x<0 || y<0)?0LL:Ab[x][y];};\n    \n    auto sum=[&](const vector<vector<ll>> &Ab,ll xs,ll xl,ll ys,ll yl)->ll{\n        if(xs>xl || ys>yl){return 0LL;}\n        return sum2(Ab,xl,yl)-sum2(Ab,xl,ys-1)-sum2(Ab,xs-1,yl)+sum2(Ab,xs-1,ys-1);\n    };\n    \n    vector<vector<ll>> dp(n,vector<ll>(n,0));\n    for(ll i=0;i<n;i++){\n        for(ll j=i;j<n;j++){\n            for(ll m=i;m<=j;m++){\n                dp[i][j]=max(dp[i][j],sum(upper,i,m-1,m,n-1));\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n            //dp[i][j]+=sum(upper,i,j,j+1,n-1);\n            dp[i][j]+=sum(lower,i,j,i,j);\n            dp[i][j]=max(dp[i][j],sum(upper,i,j,i,n-1));\n            //cout<<dp[i][j]<<endl;\n        }\n    }\n    for(ll w=0;w<n;w++){\n        for(ll lf=0;lf+w<n;lf++){\n            ll i=lf,j=lf+w;\n            if(i+1<n){dp[i][j]=max(dp[i][j],dp[i+1][j]+sum(upper,i,i,0,n-1));}\n            if(j-1>=i){dp[i][j]=max(dp[i][j],dp[i][j-1]+sum(upper,j,j,0,n-1));}\n            for(ll m=i+1;m<=j;m++){\n                dp[i][j]=max(dp[i][j],dp[i][m-1]+dp[m][j]);\n            }\n        }\n    }\n    ll mx=0;\n    for(auto &I:dp){for(auto &J:I){mx=max(mx,J);}}\n    cout<<all-mx<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=505;\nconst int p=998244353;\nint n;\nint a[N][N];\nLL w[N][N],vv[N][N];\nLL f[N][N];\n\nvoid read(int &x){ scanf(\"%d\",&x); }\nvoid read(LL &x){ scanf(\"%lld\",&x); }\n\nLL vwv(int a,int b,int c){\n\treturn w[b][c]-w[a-1][c];\n}\n\nvoid chkmin(LL &x,LL y){\n\tif (y<x) x=y;\n}\n\nint main(){\n\tread(n);\n\tfr(i,1,n)\n\t fr(j,1,n)\n\t  if (i!=j) read(a[i][j]);\n\tfr(i,1,n)\n\t rf(j,n,i+1){\n\t \tw[i][j]=w[i][j+1];\n\t \tfr(k,1,i) w[i][j]+=a[j][k];\n\t }\n\tfr(i,1,n)\n\t fr(j,i+1,n+1){\n\t \tvv[i][j]=vv[i][j-1];\n\t \tfr(k,i,j-1) vv[i][j]+=a[k][j];\n\t }\n\tmemset(f,0x3f,sizeof f);\n\tf[0][0]=0;\n\tfr(i,0,n)\n\t fr(j,i,n)\n\t  if (f[i][j]<1e18){\n\t  \tfr(k,j+1,n+1)\n\t  \t chkmin(f[j][k],f[i][j]+vv[j+1][k]+vwv(i+1,j,k+1));\n\t  }\n\tLL ans=1e18;\n\tfr(i,0,n) chkmin(ans,f[i][n+1]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 500\n#define LL long long\n#define INF 1e18\n#define Gmin(x,y) (x>(y)&&(x=(y)))\nusing namespace std;\nint n,a[N+5][N+5];LL f[N+5][N+5],s1[N+5][N+5],s2[N+5][N+5],t1[N+5][N+5],t2[N+5][N+5];\nint main()\n{\n\tRI i,j,k;LL ans=INF;for(scanf(\"%d\",&n),i=1;i<=n;++i) for(j=1;j<=n;++j) i^j&&scanf(\"%d\",&a[i][j]);\n\tfor(i=1;i<=n+1;++i) for(j=1;j<=n+1;++j) s1[i][j]=s1[i][j-1]+a[i][j],s2[i][j]=s2[i-1][j]+a[i][j];\n\tfor(i=1;i<=n;++i) for(j=n+1;j>=i+1;--j) t1[i][j]=t1[i][j+1]+s1[j][i];\n\tfor(i=1;i<=n;++i) for(j=i+1;j<=n+1;++j) t2[i][j]=t2[i][j-1]+s2[j-1][j]-s2[i-1][j];\n\tfor(i=0;i<=n+1;++i) for(j=0;j<=n+1;++j) f[i][j]=INF;f[0][0]=0;\n\tfor(i=0;i<=n;++i) for(j=i;j<=n;++j) if(f[i][j]!=INF)\n\t\tfor(k=j+1;k<=n+1;++k) Gmin(f[j][k],f[i][j]+t1[j][k+1]-t1[i][k+1]+t2[j+1][k]);\n\tfor(i=0;i<=n;++i) Gmin(ans,f[i][n+1]);return printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nllint n;\nllint a[505][505];\nllint sum[505][505];\nllint dp[505][505][505];\n\nllint get(llint sx, llint sy, llint tx, llint ty)\n{\n\tif(sx > tx || sy > ty) return 0;\n\treturn sum[tx][ty] - sum[sx-1][ty] - sum[tx][sy-1] + sum[sx-1][sy-1];\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tsum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1] + a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tdp[i][j][k] = inf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[1][0][0] = 0;\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= n; k++){\n\t\t\t\tdp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k] + get(j+1, i+1, i, i+1) + get(i+1, 1, i+1, k) );\n\t\t\t\tdp[i+1][i][j] = min(dp[i+1][i][j], dp[i][j][k] + get(i+1, 1, i+1, j) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ans = inf;\n\tfor(int j = 0; j <= n; j++){\n\t\tfor(int k = 0; k <= n; k++){\n\t\t\tans = min(ans, dp[n][j][k]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nlong long n,m,i,j,k,dp[505][505],w1[505][505],w2[505][505],a[505][505],ans;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n){\n\t\tfz1(j,n)if(i!=j){\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tfz1(i,n){\n\t\tfd(j,n,i+1){\n\t\t\tw1[i][j]=w1[i][j+1];\n\t\t\tfz1(k,i){\n\t\t\t\tw1[i][j]+=a[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfz1(i,n){\n\t\tfz(j,i,n+1){\n\t\t\tw2[i][j]=w2[i][j-1];\n\t\t\tfz(k,i,j-1){\n\t\t\t\tw2[i][j]+=a[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfz0g(i,n){\n\t\tfz(j,i,n)if(dp[i][j]<0x3f3f3f3f3f3f3f3fll){\n\t\t\tfz(k,j+1,n+1){\n\t\t\t\tlong long f=dp[i][j];\n\t\t\t\tf+=w2[j+1][k];\n\t\t\t\tf+=w1[j][k+1]-w1[i][k+1];\n\t\t\t\tdp[j][k]=min(dp[j][k],f);\n\t\t\t}\n\t\t}\n\t}\n\tans=0x3f3f3f3f3f3f3f3fll;\n\tfz0g(i,n){\n\t\tans=min(ans,dp[i][n+1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod=998244353;\nint t=0,Link[100010],lin[100010],f[100010],f1[100010],n,m,tt=0;\nbool vis[100010];\nlong long dis[100010],dis1[100010];\nstruct edge {int nex,v,w;}e[200010],E[200010];\nstruct dsa{int x,y,z;}a[100010];\nvoid Insert(int xx,int yy,int zz) {e[++t].nex=Link[xx];e[t].v=yy;e[t].w=zz;Link[xx]=t;}\nvoid Insert_(int xx,int yy,int zz) {E[++tt].nex=lin[xx];E[tt].v=yy;E[tt].w=zz;lin[xx]=tt;} \nvoid Dijkstra()\n{\n\tpriority_queue < pair <long long,int> > q;\n\tmemset(dis,10,sizeof(dis));\n\tq.push(make_pair(0,1));\n\tdis[1]=0;f[1]=1;\n\twhile (q.size()) {\n\t\tint x=q.top().second;\n\t\tq.pop();\n\t\tif (vis[x]) continue;\n\t\tvis[x]=true;\n\t\tfor (int i=Link[x];i;i=e[i].nex) \n\t\t  if (dis[x]+e[i].w<dis[e[i].v]) {\n\t\t  \t  dis[e[i].v]=dis[x]+e[i].w;\n\t\t  \t  f[e[i].v]=f[x];\n\t\t      q.push(make_pair(-dis[e[i].v],e[i].v));\n\t\t  }\n\t\t  else if (dis[x]+e[i].w==dis[e[i].v]) \n\t\t  \t  f[e[i].v]+=f[x],f[e[i].v]%=Mod;\n\t}\n}\nvoid Dijkstra_()\n{\n\tpriority_queue <pair <long long,int> > q;\n\tmemset(dis1,10,sizeof(dis1));\n\tmemset(vis,0,sizeof(vis));\n\tq.push(make_pair(0,2));\n\tdis1[2]=0;f1[2]=1;\n\twhile (q.size()) {\n\t\tint x=q.top().second;\n\t\tq.pop();\n\t\tif (vis[x]) continue;\n\t\tvis[x]=true;\n\t\tfor (int i=lin[x];i;i=E[i].nex) \n\t\t  if (dis1[x]+E[i].w<dis1[E[i].v]) {\n\t\t  \t  dis1[E[i].v]=dis1[x]+E[i].w;\n\t\t  \t  f1[E[i].v]=f1[x];\n\t\t      q.push(make_pair(-dis1[E[i].v],E[i].v));\n\t\t  }\n\t\t  else if (dis1[x]+E[i].w==dis1[E[i].v])\n\t\t    f1[E[i].v]+=f1[x],f1[E[i].v]%=Mod;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=m;i++) {\n\t\tscanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].z);\n\t\tInsert(a[i].x,a[i].y,a[i].z);\n\t\tInsert_(a[i].y,a[i].x,a[i].z);\n\t}\n\tDijkstra();\n\tDijkstra_();\n\tlong long len=dis[2];\n\t\n\tfor (int i=1;i<=m;i++) \n\t\tif (dis[a[i].x]+dis1[a[i].y]+a[i].z==len&&1LL*f[a[i].x]*f1[a[i].y]%Mod==f[2]) {\n\t\t\tif (dis[a[i].y]+dis1[a[i].x]+a[i].z>len) puts(\"SAD\");\n\t\t\t  else if (dis[a[i].y]+dis1[a[i].x]+a[i].z==len) puts(\"SOSO\");\n\t\t\t    else puts(\"HAPPY\");\n\t\t\t    \n\t\t}\n\t\telse {\n\t\t\tif (dis[a[i].y]+dis1[a[i].x]+a[i].z<len) puts(\"HAPPY\");\n\t\t\telse puts(\"SOSO\");\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 501;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint N, A[MX][MX];\narray<array<ll,501>,501> dp;\nll cum[2][MX];\n\nint main() {\n    setIO(); re(N);\n    ll sum = 0;\n    FOR(i,1,N+1) FOR(j,1,N+1) if (i != j) {\n    \tre(A[i][j]);\n    \tsum += A[i][j];\n    }\n    FOR(i,1,N) {\n    \tF0R(j,i) F0R(k,j+1) ckmax(dp[i][j],dp[j][k]);\n    \tFOR(j,1,i+1) {\n    \t\tcum[0][j] = cum[0][j-1]+A[j][i+1];\n    \t\tcum[1][j] = cum[1][j-1]+A[i+1][j];\n    \t}\n    \t// ps(\"HA\",cum[0][i],cum[1][i]);\n    \tF0R(j,i+1) F0R(k,j+1) dp[j][k] += cum[0][j]+cum[1][i]-cum[1][k];\n    \t\t// A[1..j][i+1]+A[i+1][k+1..i]\n    }\n    ll ret = 0; F0R(j,N) F0R(k,j+1) ckmax(ret,dp[j][k]);\n    ps(sum-ret);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=510;\ntypedef long long ll;\nconst ll inf=1e18;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,a[N][N];\nll f[N][N],s1[N][N],s2[N][N];\n\nll getsum(ll s[N][N],int x1,int x2,int y1,int y2) {\n\treturn s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];\n}\n\nint main() {\n\tcin>>n;n+=4;\n\tfor(int i=3;i<=n-2;i++)\n\t\tfor(int j=3;j<=n-2;j++)\n\t\t\tif(i!=j) a[i][j]=gi();\n\tmemset(f,0x3f,sizeof(f)),f[1][2]=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) {\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++) {\n\t\t\tif(f[i][j]>=inf) continue;\n\t\t\tfor(int k=j+1;k<=n;k++) {\n\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+getsum(s1,k+1,n,i+1,j)+getsum(s2,j+1,k,j+1,k));\n\t\t\t}\n\t\t}\n\tcout<<f[n-1][n];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __AVX__ 1\n#define __AVX2__ 1\n#define __SSE__ 1\n#define __SSE2__ 1\n#define __SSE2_MATH__ 1\n#define __SSE3__ 1\n#define __SSE4_1__ 1\n#define __SSE4_2__ 1\n#define __SSE_MATH__ 1\n#define __SSSE3__ 1\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\")\n#define cmax(a,b) ((a)>(b))\n#include <immintrin.h>\n#include<bits/stdc++.h>\n__m256i a[1033333/8+1],a2[2033333/8+1];\nunsigned int b[1033333],a1[1033333];\n#define re register\nint main()\n{\n\tsrand(time(0));rand();rand();\n\tre double xl1=0,xl2=0;\n\tre unsigned int x=rand(),y=rand(),*aa=(unsigned int *)&a,*aa2=(unsigned int *)&a2;\n\tfor(re int i=0;i<1033333;i++)\n\t{\n\t\taa2[i]=a1[i]=x,x^=x<<13,x^=x>>17,x^=x<<5;\n\t\taa[i]=b[i]=y,y^=y<<13,y^=y>>17,y^=y<<5;\n\t}\n\tfor(re int ii=1;ii<=500;ii++){\n\tre double xl=clock();\n\t//for(re int i=0;i<1033333/8+1;i++)a[i]=_mm256_xor_si256(a[i],a2[i]),_mm256_add_epi32(a[i],a2[i]),_mm256_and_si256(a[i],a2[i]),_mm256_max_epi32(a[i],a2[i]);\n\t//xl1+=clock()-xl;xl=clock();\n\tfor(re int i=0;i<1033333;i++)b[i]^=a1[i],b[i]+=a1[i],b[i]&=a1[i],b[i]=cmax(b[i],a1[i]);\n\txl2+=clock()-xl;\n\t}\n\tprintf(\"%.10lf %.10lf\\n\",xl1,xl2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nvoid pre(){\n\n\n}\n\nvoid solve(){\n\n\n}\nint a[509][509];\nll s1[509][509],s2[509][509];\nll tot1[509][509],tot2[509][509];\nll b[509][509];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint n;cin>>n;\n\trep(i,n){\n\t\trep(j,i) cin>>a[i][j],s2[i][j]=a[i][j];\n\t\trepA(j,i+1,n-1) cin>>a[i][j],s1[j][i]=a[i][j];\n\t}\n\trep(i,n) repD(j,i-1,0) s1[i][j]+=s1[i][j+1],s2[i][j]+=s2[i][j+1];\n\trep(i,n) repD(j,i-1,0){\n\t\ttot1[i][j]=s1[i][j]+tot1[i-1][j];\n\t\ttot2[i][j]=s2[i][j];\n\t}\n\trepD(i,n-2,0) repD(j,i-1,0) tot2[i][j]+=tot2[i+1][j];\n\tll ans = 1e18;\n\trep(i,n-1){\n\t\tans=min(ans,tot1[i][0]+tot1[n-1][i+1]);\n\t\tb[0][i+1]=tot1[i][0];\n\t}\n\ttrace(ans);\n\trepA(i,1,n-2){\n\t\trepA(j,0,i-1){\n\t\t\tb[j+1][i+1]=1e18;\n\t\t\trepA(k,-1,j-1){\n\t\t\t\tll cur=b[k+1][j+1]+tot1[i][j+1];\n\t\t\t\tcur+=tot2[i+1][k+1]-tot2[i+1][j+1];\n\t\t\t\tb[j+1][i+1]=min(b[j+1][i+1],cur);\n\t\t\t\tans=min(ans,cur+tot1[n-1][i+1]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nconst long long inf=1000000000000000;\nlong long n;\nlong long w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nlong long ans=inf;\n\nlong long getsum(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  cin>>w[i][j];\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[0][i]-tot[i][0]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=inf;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tcout<<ans;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint v[510][510],n;\nlong long f[510][510],sp[510][510],ss[510][510],ans=1e18;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=n;++j)if(i^j)scanf(\"%d\",v[i]+j);\n\tfor(int i=1;i<=n;++i)for(int j=n;j>i;--j)\n\t\tss[i][j]=ss[i-1][j]+ss[i][j+1]-ss[i-1][j+1]+v[j][i];\n\tfor(int i=n;i;--i)for(int j=i+1;j<=n;++j)\n\t\tsp[i][j]=sp[i+1][j]+sp[i][j-1]-sp[i+1][j-1]+v[i][j];\n\tfor(int i=0;i<=n;++i)for(int j=0;j<=n;++j)f[i][j]=1e18;\n\tfor(int i=1;i<=n;++i)f[i][0]=sp[1][i];\n\tfor(int i=1;i<n;++i)for(int j=0;j<i;++j)for(int k=i+1;k<=n;++k)\n\t\tf[k][i]=min(f[k][i],f[i][j]+ss[i][k+1]-ss[j][k+1]+sp[i+1][k]);\n\tfor(int i=0;i<n;++i)ans=min(ans,f[n][i]);\n\tprintf(\"%lld\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=505;\nconst LL INF=1e18;\nint n;\nint a[N][N];\nLL f[N][N],g[N][N];\nLL dp[N][N];\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\tFor(j,1,n)\n\t\t\tif (i!=j)\n\t\t\t\ta[i][j]=read();\n\tFor(i,1,n){\n\t\tFor(j,i+1,n){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tg[i][j]=g[i][j-1];\n\t\t\tFor(k,i,j){\n\t\t\t\tf[i][j]-=a[k][j];\n\t\t\t\tg[i][j]+=a[j][k];\n\t\t\t}\n\t\t}\n\t}\n//\touttag(a);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%d \",a[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(f);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",f[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(g);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",g[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n\tFor(i,0,N-1)\n\t\tFor(j,0,N-1)\n\t\t\tdp[i][j]=-INF;\n\tdp[1][1]=-f[1][n];\n\tLL ans=-INF;\n\tFor(i,1,n)\n\t\tFor(j,1,n){\n//\t\t\tprintf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n\t\t\tif (i<=j){\n\t\t\t\tans=max(ans,dp[i][j]+f[i][n]+g[j][n]);\n//\t\t\t\tif (i<j)\n//\t\t\t\t\tdp[j+1][j]=max(dp[j+1][j],dp[i][j]+f[i][j-1]-a[j-1][j]-a[j][j+1]);\n\t\t\t\tFor(k,j+1,n){\n\t\t\t\t\tdp[k][i]=max(dp[k][i],dp[i][j]+f[i][k-1]-g[i][j]);\n//\t\t\t\t\tFor(t,j,n)\n//\t\t\t\t\t\tdp[k][t]=max(dp[k][t],dp[i][j]+f[i][k-1]-g[i][j]+g[i][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFor(k,i,n)\n\t\t\t\t\tdp[i][k]=max(dp[i][k],dp[i][j]+g[j][k]);\n\t\t\t}\n\t\t}\n\tcout<<g[1][n]-f[1][n]-ans<<endl;\n\treturn 0;\n}\n/*\n5\n14 16 3 3\n15 5 7 19\n14 9 0 11\n14 5 8 2\n9 0 4 18\n*/"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\ntemplate <typename T>\nvoid chkmin(T &dp, const T &val) {\n    if (val < dp) dp = val;\n}\n\nconst size_t N = 500 + 5;\n\nLL a[N][N], dp[N][N];\n\nint main() {\n    int n = read();\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (i != j) {\n                a[i][j] = read();\n            }\n        }\n    }\n\n    memset(dp, 0x3f, sizeof dp);\n    dp[0][0] = 0;\n    for (int i = 1; i < n; ++i) {\n        static LL fr_i[N], to_i[N];\n        for (int j = 1; j <= i; ++j) {\n            fr_i[j] = fr_i[j - 1] + a[i + 1][j];\n            to_i[j] = to_i[j - 1] + a[j][i + 1];\n        }\n        for (int a = 0; a < i; ++a) {\n            for (int b = (a ? a + 1 : 0); b < i; ++b) {\n                chkmin(dp[b][i], dp[a][b]);\n            }\n        }\n        for (int a = 0; a < i; ++a) {\n            for (int b = (a ? a + 1 : 0); b <= i; ++b) {\n                dp[a][b] += fr_i[a] + to_i[i] - to_i[b];\n            }\n        }\n    }\n\n    LL ans = 1e18;\n    for (int a = 0; a < n; ++a) {\n        for (int b = 0; b < n; ++b) {\n            ans = min(ans, dp[a][b]);\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nint n;\nint w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nint ans=2147483647;\n\ninline int getsum(int a,int b,int c,int d){\n\treturn p[b][d]-(c==0?0:p[b][c-1])-(a==0?0:p[a-1][d])+(a==0||c==0?0:p[a-1][c-1]);\n}\n\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  scanf(\"%d\",&w[i][j]);\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=0x3f3f3f3f;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tprintf(\"%d\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=510;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n; LL a[N][N],b[N][N];\nLL get (int k,int j,int i) { return b[j+1][i]+a[n][j]-a[n][k]-a[i][j]+a[i][k]; }\nLL f[N][N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif (i!=j) sc(a[i][j]);\n\tfor (int j=1; j<=n; j++)\n\t\tfor (int i=j; i>=1; i--)\n\t\t\tb[i][j]=a[i][j]+b[i+1][j]+b[i][j-1]-b[i+1][j-1];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\ta[i][j]+=a[i][j-1]+a[i-1][j]-a[i-1][j-1];\n\tLL ans=1e18;\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tf[i][0]=get (0,0,i);\n\t\tchkmin (ans,f[i][0]+get (0,i,n));\n\t\tfor (int j=1; j< i; j++)\n\t\t{\n\t\t\tf[i][j]=1e18;\n\t\t\tfor (int k=0; k< j; k++)\n\t\t\t\tchkmin (f[i][j],f[j][k]+get (k,j,i));\n\t\t\tchkmin (ans,f[i][j]+get (j,i,n));\n\t\t}\n\t}\n\tpr(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x3f3f3f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 0x3f3f3f3f)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 0x3f3f3f3f3f3f3f3f;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 505;\nint n;\nll inf, v1[N][N], v2[N][N], f[N][N];\nll get(ll v[N][N], int x1, int x2, int y1, int y2) {\n  return v[x2][y2] - v[x1][y2] - v[x2][y1] + v[x1][y1];\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      scanf(\"%lld\", &v1[j][i]);\n    }\n    for (int j = i + 1; j <= n; j++) {\n      scanf(\"%lld\", &v2[i][j]);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      v1[i][j] = v1[i][j] + v1[i - 1][j] + v1[i][j - 1] - v1[i - 1][j - 1];\n      v2[i][j] = v2[i][j] + v2[i - 1][j] + v2[i][j - 1] - v2[i - 1][j - 1];\n    }\n  }\n  memset(f, 0x3f, sizeof f);\n  inf = f[0][0];\n  f[0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i + !i; j++) if (f[i][j] != inf) {\n      for (int k = i + 1; k <= n; k++) {\n        f[k][i] = min(f[k][i], f[i][j] + get(v1, j, i, k, n) + get(v2, i, k, i, k));\n      }\n    }\n  }\n  ll ans = inf;\n  for (int j = 0; j < n; j++) {\n    ans = min(ans, f[n][j]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  auto d = make_higher_vector<3, lint>(n, n + 1, n + 1, -1);\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      at(d, j, k, 0) = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf) continue;\n        cmn(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n;\nll a[305][305],sum[305][305],f[305][305],s[305][305];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(i!=j)scanf(\"%lld\",&a[i][j]);\n\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];\n\t\ts[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]*(i<j);\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\tfor(int j=i;j<=n;j++)\n\t{\n\t\tif(f[i][j]>1e17)continue;\n\t\tfor(int k=j+1;k<=n;k++)\n\t\t  f[j][k]=min(f[j][k],f[i][j]+s[k][k]-s[j][k]-s[k][j]+s[j][j]+sum[n][j]-sum[n][i]-sum[k][j]+sum[k][i]);\n\t}\n\tll ans=1e18;\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][n]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N;\nll A[510][510];\nll lpsum[510][510];\nll psum[510][510],nsum[510][510];\nll dp[510][510];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  ll tot=0;\n  rep(i,N){\n    rep(j,N){\n      if(i==j)continue;\n      cin>>A[i][j];\n      tot+=A[i][j];\n    }\n  }\n\n  rep(i,N){\n    repl(j,i+1,N){\n      lpsum[i][j]=lpsum[i][j-1]+A[j][i];\n    }\n    for(ll j=i-1;j>=0;j--){\n      psum[j][i]=psum[j+1][i]+A[i][j];\n    }\n    for(ll j=i-1;j>=0;j--){\n      nsum[j][i]=nsum[j+1][i]+A[j][i];\n    }\n  }\n\n  ll res=0;\n  rep(i,N)rep(j,N)dp[i][j]=-INF;\n  repl(i,1,N){\n    dp[i][0]=psum[0][i]+nsum[0][i];\n    for(ll j=i-1;j>=0;j--){\n      dp[i][0]+=psum[0][j];\n    }\n\n    ll crt=dp[i][0];\n    repl(k,i+1,N){\n      crt+=nsum[0][k]-nsum[i][k];\n      crt+=psum[0][k];\n    }\n    maxch(res,crt);\n  }\n\n  repl(i,1,N)repl(j,1,i){\n    ll vp=psum[j][i]+lpsum[j][i-1];\n    ll vn=nsum[0][i];\n    for(ll k=i-1;k>j;k--){\n      vn+=nsum[0][k]-nsum[j][k];\n    }\n    for(ll k=j-1;k>=0;k--){\n      vp+=lpsum[k][i-1]-lpsum[k][j];\n      maxch(dp[i][j],dp[j][k]+vp+vn);\n    }\n\n    ll crt=dp[i][j];\n    repl(k,i+1,N){\n      crt+=nsum[0][k]-nsum[i][k];\n      crt+=psum[j][k];\n    }\n    maxch(res,crt);\n  }\n\n  cout<<tot-res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  // auto d = make_higher_vector<3, lint>(n, n + 1, n + 1);\n  lint d[501][501][501];\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      // at(d, j, k, 0) = 0;\n      d[j][k][0] = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf) continue;\n        dp[j][k] = std::min(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll infll = (ll)1e18;\nconst int N = (int)505;\nint n;\nll p_sum_pos[N][N], p_sum_neg[N][N], f[N][N], ans = infll;\n\nll get_p_sum_pos (int x_1, int x_2, int y_1, int y_2) { return p_sum_pos[x_2][y_2] + p_sum_pos[x_1 - 1][y_1 - 1]\n                                                               - p_sum_pos[x_2][y_1 - 1] - p_sum_pos[x_1 - 1][y_2]; }\n\nll get_p_sum_neg (int x_1, int x_2, int y_1, int y_2) { return p_sum_neg[x_2][y_2] + p_sum_neg[x_1 - 1][y_1 - 1]\n                                                               - p_sum_neg[x_2][y_1 - 1] - p_sum_neg[x_1 - 1][y_2]; }\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n//    freopen(\"test.INP\", \"r\", stdin);\n\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j < i; ++j) cin >> p_sum_pos[i][j];\n        for (int j = i + 1; j <= n; ++j) cin >> p_sum_neg[i][j];\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            p_sum_neg[i][j] += p_sum_neg[i - 1][j] + p_sum_neg[i][j - 1] - p_sum_neg[i - 1][j - 1];\n            p_sum_pos[i][j] += p_sum_pos[i - 1][j] + p_sum_pos[i][j - 1] - p_sum_pos[i - 1][j - 1];\n        }\n    }\n\n    for (int i = 1; i < n; ++i) ans = min(ans, get_p_sum_neg(1, i, 1, i) + get_p_sum_neg(i + 1, n, i + 1, n) );\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            f[i][j] = get_p_sum_pos(j + 1, n, 1, i) + get_p_sum_neg(i + 1, j, i + 1, j) + get_p_sum_neg(1, i, 1, i);\n        }\n    }\n\n    for (int k = 1; k < n; ++k) {\n        for (int i = k + 1; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                f[i][j] = min(f[i][j], f[k][i] + get_p_sum_pos(j + 1, n, k + 1, i) + get_p_sum_neg(i + 1, j, i + 1, j) );\n            }\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            ans = min(ans, f[i][j] + get_p_sum_neg(j + 1, n, j + 1, n) );\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nconst Int MAX = 505;\nconst Int INF = 1e18;\nInt dp[MAX][MAX][MAX];\n\nInt A[MAX][MAX];\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n;\n  cin>>n;\n  for(Int i=1;i<=n;i++)\n    for(Int j=1;j<=n;j++)\n      if(i!=j) cin>>A[i][j];\n\n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      for(Int k=0;k<MAX;k++)\n        dp[i][j][k]=INF;\n\n  dp[1][0][0]=0;\n\n  // k <= j <= i\n  for(Int i=1;i<n;i++){\n    for(Int j=0;j<i;j++){\n      for(Int k=0;k<=j;k++){\n        if(dp[i][j][k]>=INF) continue;\n\n        {\n          Int ni=i+1;\n          Int nj=j;\n          Int nk=k;\n          Int nc=0;\n          for(Int p=i;p>nj;p--) nc+=A[p][ni];\n          for(Int q=nk;q>0;q--) nc+=A[ni][q];\n          chmin(dp[ni][nj][nk],dp[i][j][k]+nc);\n        }\n\n        for(Int x=i;x>j;x--){\n          Int ni=i+1;\n          Int nj=x;\n          Int nk=j;\n          Int nc=0;\n          for(Int p=i;p>nj;p--) nc+=A[p][ni];\n          for(Int q=nk;q>0;q--) nc+=A[ni][q];\n          chmin(dp[ni][nj][nk],dp[i][j][k]+nc);\n        }\n      }\n    }\n  }\n\n  Int ans=INF;\n  for(Int j=0;j<n;j++)\n    for(Int k=0;k<=j;k++)\n      chmin(ans,dp[n][j][k]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 500 + 10;\n\nll a[N][N], f[N][N], b[N][N];\nll dp[N][N];\n\nint main() {\n\t// cout << sizeof(dp) / 1e6 << endl;\n\tfast_cin();\n\tint n; cin >> n;\n\tll sum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (i != j) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tsum += a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tf[i][j] = f[i][j - 1] + a[j][i];\n\t\t}\n\t\tfor (int j = i - 1; j >= 1; --j) {\n\t\t\tb[i][j] = b[i][j + 1] + a[i][j];\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = i; j >= 0; --j) {\n\t\t\tfor (int k = j; k >= 0; --k) {\n\t\t\t\tll cost = dp[j][k] + f[i + 1][j] + b[i + 1][k + 1];\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], cost);\n\t\t\t\tdp[j][k] = cost;\n\t\t\t\tans = max(ans, cost);\n\t\t\t}\n\t\t}\n\t}\n\tcout << sum - ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 510;\nint n,a[N][N];\nll b[N][N],c[N][N],dp[N][N];\n\ninline ll calc1(int l,int r){\n\tif (l>r) return 0;\n\tassert(b[r][r]-b[l-1][r]-b[r][l-1]+b[l-1][l-1]>=0);\n\treturn b[r][r]-b[l-1][r]-b[r][l-1]+b[l-1][l-1];\n}\ninline ll calc2(int x,int y,int z){\n\treturn c[y][n]-c[x][n]-c[y][z-1]+c[x][z-1];\n}\n\nint main(){\n\tn=read();\n\tFor(i,0,n+1) For(j,0,n+1) dp[i][j]=1e15;\n\tFor(i,1,n) For(j,1,n) if (i!=j) a[i][j]=read();\n\tFor(i,1,n) For(j,1,n){\n\t\tint x=(i<j)?a[i][j]:0;\n\t\tb[i][j]=b[i][j-1]+b[i-1][j]-b[i-1][j-1]+x;\n\t}\n\tFor(j,1,n) For(i,1,n){\n\t\tint x=(i>j)?a[i][j]:0;\n\t\tc[j][i]=c[j][i-1]+c[j-1][i]-c[j-1][i-1]+x;\n\t}\n\tdp[0][0]=0;\n\tFor(i,1,n) dp[0][i]=calc1(1,i);\n\tFor(i,0,n) For(j,i+1,n) For(k,j+1,n){\n\t\tdp[j][k]=min(dp[j][k],dp[i][j]+calc1(j+1,k)+calc2(i,j,k+1));\n\t}\n\tll ans=1e15;\n\tFor(i,0,n-1) ans=min(ans,dp[i][n]);\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define read() Read<int>()\nnamespace pb_ds{   \n    namespace io{\n        const int MaxBuff=1<<15;\n        const int Output=1<<23;\n        char B[MaxBuff],*S=B,*T=B;\n\t\t#define getc() ((S==T)&&(T=(S=B)+fread(B,1,MaxBuff,stdin),S==T)?0:*S++)\n        char Out[Output],*iter=Out;\n        inline void flush(){\n            fwrite(Out,1,iter-Out,stdout);\n            iter=Out;\n        }\n    }\n    template<class Type> inline Type Read(){\n        using namespace io;\n        register char ch;\n        register Type ans=0; \n        register bool neg=0;\n        while(ch=getc(),(ch<'0' || ch>'9') && ch!='-');\n        ch=='-'?neg=1:ans=ch-'0';\n        while(ch=getc(),'0'<= ch && ch<='9') ans=ans*10+ch-'0';\n        return neg?-ans:ans;\n    }\n    template<class Type> inline void Print(register Type x,register char ch='\\n'){\n        using namespace io;\n        if(!x) *iter++='0';\n        else{\n            if(x<0) *iter++='-',x=-x;\n            static int s[100]; \n            register int t=0;\n            while(x) s[++t]=x%10,x/=10;\n            while(t) *iter++='0'+s[t--];\n        }\n        *iter++=ch;\n    }\n}\nusing namespace pb_ds;\nusing namespace std;\ntypedef long long ll;\nconst int N=505;\nconst ll inf=(ll)1e18;\nint n;\nint a[N][N],b[N][N];\nll ans=inf;\nll c[N][N],d[N][N],dp[N][N];\nint main(){\n\t//freopen(\"negative.in\",\"r\",stdin);\n\t//freopen(\"negative.out\",\"w\",stdout);\n\tn=read();\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<i;++j) a[j][i]=read();\n\t\tfor (int j=i+1;j<=n;++j) b[i][j]=read();\n\t}\n\tfor (int i=1;i<=n+1;++i){\n\t\tfor (int j=i;j<=n+1;++j){\n\t\t\tc[i][j]=c[i-1][j];\n\t\t\tfor (int k=j;k<=n;++k) c[i][j]+=a[i][k];\n\t\t}\n\t}\n\tfor (int i=n+1;i;--i){\n\t\tfor (int j=i;j<=n+1;++j){\n\t\t\td[i][j]=d[i+1][j];\n\t\t\tfor (int k=i;k<=j;++k) d[i][j]+=b[i][k];\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor (int i=1;i<=n+1;++i)\n\t\tfor (int j=0;j<i;++j)\n\t\t\tfor (int k=0;k<=j;++k)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+c[j][i+1]-c[k][i+1]+d[j+1][i]);\n\tfor (int i=0;i<=n;++i)\n\t\tans=min(ans,dp[n+1][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=505;\nconst LL INF=1e18;\nint n;\nint a[N][N];\nLL f[N][N],g[N][N];\nLL dp[N][N];\nint main(){\n\tn=read();\n\tFor(i,1,n)\n\t\tFor(j,1,n)\n\t\t\tif (i!=j)\n\t\t\t\ta[i][j]=read();\n\tFor(i,1,n){\n\t\tFor(j,i+1,n){\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tg[i][j]=g[i][j-1];\n\t\t\tFor(k,i,j){\n\t\t\t\tf[i][j]-=a[k][j];\n\t\t\t\tg[i][j]+=a[j][k];\n\t\t\t}\n\t\t}\n\t}\n//\touttag(a);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%d \",a[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(f);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",f[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n//\touttag(g);\n//\tFor(i,1,n){\n//\t\tFor(j,1,n){\n//\t\t\tprintf(\"%lld \",g[i][j]);\n//\t\t}\n//\t\tputs(\"\");\n//\t}\n\tFor(i,0,N-1)\n\t\tFor(j,0,N-1)\n\t\t\tdp[i][j]=-INF;\n\tdp[1][1]=-f[1][n];\n\tLL ans=-INF;\n\tFor(i,1,n)\n\t\tFor(j,1,n){\n//\t\t\tprintf(\"dp[%d][%d] = %lld\\n\",i,j,dp[i][j]);\n\t\t\tif (i<=j){\n\t\t\t\tans=max(ans,dp[i][j]+f[i][n]+g[j][n]);\n\t\t\t\tif (i<j)\n\t\t\t\t\tdp[j+1][j]=max(dp[j+1][j],dp[i][j]+f[i][j-1]-a[j-1][j]-a[j][j+1]);\n\t\t\t\tFor(k,j+1,n){\n//\t\t\t\t\tdp[k][j]=max(dp[k][j],dp[i][j]+f[i][k-1]);\n\t\t\t\t\tFor(t,j,n)\n\t\t\t\t\t\tdp[k][t]=max(dp[k][t],dp[i][j]+f[i][k-1]-g[i][j]+g[i][t]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\telse {\n//\t\t\t\tFor(k,i,n)\n//\t\t\t\t\tdp[i][k]=max(dp[i][k],dp[i][j]+g[j][k]);\n//\t\t\t}\n\t\t}\n\tcout<<g[1][n]-f[1][n]-ans<<endl;\n\treturn 0;\n}\n/*\n5\n14 16 3 3\n15 5 7 19\n14 9 0 11\n14 5 8 2\n9 0 4 18\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=505;\nconst long long INF=1e18;\nint n,a[N][N]; long long s1[N][N],s2[N][N],f[N][N],ans=INF;\nint main()\n{\n\tRI i,j,k; for (scanf(\"%d\",&n),i=1;i<=n;++i)\n\tfor (j=1;j<=n;++j) if (i!=j) scanf(\"%d\",&a[i][j]);\n\tfor (i=1;i<=n;++i) for (j=i+1;j<=n+1;++j)\n\tfor (s1[i][j]=s1[i][j-1],k=i;k<j;++k) s1[i][j]+=a[k][j];\n\tfor (i=1;i<=n;++i) for (j=n;j>i;--j)\n\tfor (s2[i][j]=s2[i][j+1],k=1;k<=i;++k) s2[i][j]+=a[j][k];\n\tfor (i=0;i<=n+1;++i) for (j=i;j<=n+1;++j) f[i][j]=INF;\n\tfor (f[0][0]=i=0;i<=n;++i) for (j=i;j<=n;++j) if (f[i][j]!=INF)\n\tfor (k=j+1;k<=n+1;++k) f[j][k]=min(f[j][k],f[i][j]+s1[j+1][k]+s2[j][k+1]-s2[i][k+1]);\n\tfor (i=0;i<=n;++i) ans=min(ans,f[i][n+1]); return printf(\"%lld\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 500;\nconst ll INF = ll(1E18);\nint A[MAXN + 5][MAXN + 5], B[MAXN + 5][MAXN + 5], n;\n// A[i][j] -> (p[i] + p[i+1] + ... p[j] >= 1) (i <= j)\n// B[i][j] -> (p[i] + p[i+1] + ... p[j] <= 1) (i <= j)\nll SA[MAXN + 5][MAXN + 5], SB[MAXN + 5][MAXN + 5];\n// SA[i][j] -> A[1][j] + A[2][j] + ... + A[i][j]\n// SB[i][j] -> B[1][j] + B[2][j] + ... + B[i][j]\nll dp[2][MAXN + 5][MAXN + 5], f[2][MAXN + 5], g[2];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<=i-1;j++) scanf(\"%d\", &B[j][i-1]);\n\t\tfor(int j=i+1;j<=n;j++) scanf(\"%d\", &A[i][j-1]);\n\t}\n\tfor(int j=1;j<=n;j++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tSA[i][j] = A[i][j] + SA[i-1][j], SB[i][j] = B[i][j] + SB[i-1][j];\n\tn--;\n\tfor(int j=1;j<=n;j++) {\n\t\tfor(int k=j+1;k<=n;k++)\n\t\t\tdp[0][j][k] = INF;\n\t\tf[0][j] = INF;\n\t}\n\tg[0] = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tfor(int k=j+1;k<i;k++)\n\t\t\t\tdp[1][j][k] = dp[0][j][k], dp[0][j][k] = INF;\n\t\t\tf[1][j] = f[0][j], f[0][j] = INF;\n\t\t}\n\t\tg[1] = g[0], g[0] = INF;\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tfor(int k=j+1;k<i;k++) {\n\t\t\t\tdp[0][j][k] = min(dp[0][j][k], dp[1][j][k] + SA[i][i] - SA[k][i] + SB[j][i]);\n\t\t\t\tdp[0][k][i] = min(dp[0][k][i], dp[1][j][k] + SB[k][i]);\n\t\t\t}\n\t\t\tf[0][j] = min(f[0][j], f[1][j] + SA[i][i] - SA[j][i]);\n\t\t\tdp[0][j][i] = min(dp[0][j][i], f[1][j] + SB[j][i]);\n\t\t}\n\t\tg[0] = min(g[0], g[1] + SA[i][i]);\n\t\tf[0][i] = min(f[0][i], g[1]);\n\t}\n\tll mn = INF;\n\tfor(int j=1;j<=n;j++) {\n\t\tfor(int k=j+1;k<=n;k++)\n\t\t\tmn = min(mn, dp[0][j][k]);\n\t\tmn = min(mn, f[0][j]);\n\t}\n\tmn = min(mn, g[0]);\n\tprintf(\"%lld\\n\", mn);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int N=505;\nint sum[2][N][N],f[N][N],n,ans=1e15;\n\nint calc(int o,int l1,int r1,int l2,int r2){\n\treturn sum[o][r1][r2]-sum[o][l1][r2]-sum[o][r1][l2]+sum[o][l1][l2];\n}\n\nsigned main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++){\n\t\tint x=0;\n\t\tif(i^j) read(x);\n\t\tfor(int o:{0,1}) sum[o][i][j]=sum[o][i-1][j]+sum[o][i][j-1]-sum[o][i-1][j-1]+((i<j)^o)*x;\n\t}\n\tfor(int i=0;i<=n;i++) for(int j=0;j<=i;j++) f[i][j]=1e15;\n\tf[0][0]=0;\n\tfor(int i=0;i<n;i++) for(int j=0;j<=i;j++) for(int k=i+1;k<=n;k++)\n\t\tf[k][i]=min(f[k][i],f[i][j]+calc(0,i,k,i,k)+calc(1,i,k,0,j));\n\tfor(int i=0;i<n;i++) ans=min(ans,f[n][i]);\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 505\nlong long f[N][N],su1[N][N],su2[N][N],dp[N][N],n,su;\nlong long Max(long long a,long long b){return a>b?a:b;}\nint main()\n{\n\tscanf(\"%lld\",&n);for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)scanf(\"%lld\",&f[i][j]),su+=f[i][j];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)su1[i][j]=f[i][j]*(i<j)+su1[i][j-1]+su1[i-1][j]-su1[i-1][j-1],su2[i][j]=f[i][j]*(i>j)+su2[i][j-1]+su2[i-1][j]-su2[i-1][j-1];\n\tfor(int i=1;i<=n;i++)dp[1][i]=su2[i][i];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=j+1;k<=n;k++)dp[j+1][k]=Max(dp[j+1][k],dp[i][j]+su1[j][k]-su1[j][j]+su2[k][k]-su2[k][i-1]-su2[j][k]+su2[j][i-1]);\n\tlong long as=0;for(int i=1;i<=n;i++)as=Max(as,dp[i][n]);printf(\"%lld\\n\",su-as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nll A[505][505], pref[505], suf[505], ndp[505][505], dp[505][505];\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tscanf(\"%lld\", &A[i][j]);\n\t\t}\n\tconst ll INF = 1LL << 60;\n\tfor (int a = 0; a <= n; ++a)\n\t\tfor (int b = 0; b <= n; ++b)\n\t\t\tdp[a][b] = INF;\n\tdp[0][0] = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tsuf[i] = 0;\n\t\tfor (int j = i - 1; j >= 0; --j) {\n\t\t\tsuf[j] = suf[j + 1] + A[j][i];\n\t\t}\n\t\tpref[0] = A[i][0];\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tpref[j] = pref[j - 1] + A[i][j];\n\t\t}\n\t\tfor (int a = 0; a <= n; ++a)\n\t\t\tfor (int b = 0; b <= n; ++b)\n\t\t\t\tndp[a][b] = INF;\n\t\tfor (int a = 0; a < i; ++a)\n\t\t\tfor (int b = 0; b <= a; ++b) {\n\t\t\t\tndp[a][b] = min(ndp[a][b], dp[a][b] + (b == 0 ? 0 : pref[b - 1]) + suf[a]);\n\t\t\t\tndp[i][a] = min(ndp[i][a], dp[a][b] + (a == 0 ? 0 : pref[a - 1]));\n\t\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tll ans = INF;\n\tfor (int a = 0; a < n; ++a)\n\t\tfor (int b = 0; b <= a; ++b)\n\t\t\tans = min(ans, dp[a][b]);\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: D.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint a[505][505];\nint w[505][505];\nint f[505][505];\nint sum(int xl,int xr,int yl,int yr){\n\treturn  w[xr][yr]-w[xr][yl-1]-w[xl-1][yr]+w[xl-1][yl-1];\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint n,x,s=0;\n\tread(n);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<i;++j){\n\t\t\tread(x);\n\t\t\ts+=x;\n\t\t\ta[i][j]=-x;\n\t\t}\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tread(a[i][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=n;++j)w[i][j]=a[i][j]+w[i-1][j]+w[i][j-1]-w[i-1][j-1];\n\t}\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=1;i<=n;++i)f[1][i]=sum(1,i,1,i);\n\tint ans=inf;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i;j<n;++j){\n\t\t\tfor(int k=j+1;k<=n;++k)\n\t\t\t\tchkmin(f[j+1][k],f[i][j]+sum(j+1,k,i,k));\n\t\t}\n\t\tchkmin(ans,s+f[i][n]);\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "解説読んだ\nポテンシャルなるほど"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll sum[500][500];\nll dp[501][501];\nll cop[501][501];\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<ll>> a(n);\n\trep(i, n) {\n\t\ta[i].resize(n);\n\t\trep(j, n) {\n\t\t\tif (i == j)a[i][j] = 0;\n\t\t\telse cin >> a[i][j];\n\t\t}\n\t}\n\n\t//calc sum\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ts += a[k][j];\n\t\t\t}\n\t\t\tsum[i][j] = s;\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\t{\n\t\tll s = 0;\n\t\tfor (int j = n-1; j>0; j--) {\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tdp[j][k] = s + sum[0][k] + sum[k + 1][j];\n\t\t\t}\n\n\t\t\ts += a[j][0];\n\t\t}\n\t\t/*cout << \"0 is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tfor (int i = 1; i < n-1; i++) {\n\t\trep(j, n + 1)rep(k, n + 1)cop[j][k] = INF;\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tif (dp[j][k] == 0)continue;\n\t\t\t\tll s = 0;\n\t\t\t\tif (k >= i) {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tcop[l][k] = min(cop[l][k], s+dp[j][k] + sum[k + 1][l] - sum[k + 1][j]);\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tfor (int m = j; m <= l; m++) {\n\t\t\t\t\t\t\tcop[l][m] = min(cop[l][m], s + dp[j][k] + sum[i][m] - sum[i][j] + sum[m+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, n + 1)rep(k, n + 1)dp[j][k]=cop[j][k];\n\n\t\t/*cout << i << \" is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tll ans = INF;\n\t/*rep(i, n)rep(j, n) {\n\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}*/\n\trep(i, n+1)rep(j, n+1)ans = min(ans, dp[i][j]);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int, int> pi;\n\n#define fi first\n#define se second\n\nint read() {\n  int res = 0, w = 1;\n  char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') c = getchar(), w = -1;\n  while (isdigit(c)) res = (res << 1) + (res << 3) + c - '0', c = getchar();\n  return res * w;\n}\n\nconst int N = 510;\nll a[N][N];\nll s[2][N][N];\nll dp[N][N];\nint n;\n\nvoid ck(ll &x, ll y) { x = x < y ? x : y; }\n\nll getsum(int typ, int lx, int rx, int ly, int ry) {\n  return s[typ][rx][ry] - s[typ][lx - 1][ry] - s[typ][rx][ly - 1] + s[typ][lx - 1][ly - 1];\n}\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) if (i != j) a[i][j] = read();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (i < j) s[0][i][j] = a[i][j];\n      s[0][i][j] += s[0][i][j - 1];\n    }\n    for (int j = 1; j <= n; j++) s[0][i][j] += s[0][i - 1][j];\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      if (i > j) s[1][i][j] = a[i][j];\n      s[1][i][j] += s[1][i][j - 1];\n    }\n    for (int j = 1; j <= n; j++) s[1][i][j] += s[1][i - 1][j];\n  }\n  memset(dp, 0x3f, sizeof(dp));\n  dp[0][0] = 0ll;\n  for (int i = 0; i <= n; i++) {\n    for (int j = 0; j < max(i, 1); j++) {\n      for (int k = i + 1; k <= n; k++) {\n        ll tmp = dp[i][j] + getsum(1, k + 1, n, j + 1, i) + getsum(0, i + 1, k, i + 1, k);\n        ck(dp[k][i], tmp);\n      }\n    }\n  }\n  ll ans = dp[n][1];\n  for (int i = 1; i <= n; i++) ck(ans, dp[n][i]);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=505;\nint n;\nint w[maxn][maxn]={0},p[maxn][maxn]={0},tot[maxn][maxn]={0},dp[maxn][maxn]={0};\nint ans=2147483647;\n\ninline int getsum(int u,int v,int x,int y){\n\treturn p[v][y]-(x==0?0:p[v][x-1])-(u==0?0:p[u-1][y])+(u==0 || x==0?0:p[u-1][x-1]);\n}\n\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)  scanf(\"%lld\",&w[i][j]);\n\t\t\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tp[i][j]=p[i][j-1]+p[i-1][j]-p[i-1][j-1]+w[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ttot[i][j]=tot[i][j-1]+tot[i-1][j]-tot[i-1][j-1]+(i<j?w[i][j]:0);\n\t\t\t\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i][1]=tot[i][i]-tot[i][0]-tot[0][i]+tot[0][0];\n\t\tfor(int j=2;j<=i;j++){\n\t\t\tdp[i][j]=2147483647<<10;\n\t\t\tfor(int k=1;k<=j-1;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j-1][k]+(tot[i][i]-tot[i][j-1]-tot[j-1][i]+tot[j-1][j-1])+getsum(j,i,0,k-1));\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)  ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst ll inf = 1LL << 50;\nll dp[510][510][510];\nll A[510][510];\n\nll pls[510][510];\nll mns[510][510];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n)rep(j, n){\n\t\tif(i == j) continue;\n\t\tcin >> A[i][j];\n\t}\n\n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) pls[i][j] += pls[i][j - 1];\n\t\t\tpls[i][j] += A[i][j];\n\t\t}\n\t}\n\n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) mns[i][j] += mns[i][j - 1];\n\t\t\tmns[i][j] += A[j][i];\n\t\t}\n\t}\n\n\n\tconst int unused = n;\n\n\trep(i, n + 1) rep(j, n + 1) rep(k, n + 1) dp[i][j][k] = inf; \n\tdp[0][0][unused] = 0;\n\n\trep(i, n - 1) rep(j, n + 1) rep(k, n + 1){\n\t\tif (dp[i][j][k] == inf) continue;\n\t\t\n\t\tconst int vj = j;\n\t\tconst int vk = (k != unused) ? k : -1;\n\n\t\t// potential increase\n\t\t{\n\t\t\tll add = 0LL;\n\t\t\tif(vj - 1 >= 0) add += pls[i + 1][vj - 1];\n\t\t\tchmin(dp[i + 1][i + 1][j], dp[i][j][k] + add);\n\t\t}\n\n\t\t// do nothing \n\t\t{\n\t\t\tll add = 0LL;\n\t\t\tadd += mns[i + 1][i];\n\t\t\tif(vj - 1 >= 0) add -= mns[i + 1][vj - 1];\n\t\t\tif(vk - 1 >= 0) add += pls[i + 1][vk - 1];\n\t\t\tchmin(dp[i + 1][j][k], dp[i][j][k] + add);\n\t\t}\n\t}\n\n\tll ans = inf;\n\trep(j, n + 1) rep(k, n + 1) chmin(ans, dp[n - 1][j][k]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 505\n\nint n, a[N][N];\nint pos[N][N], neg[N][N];\ntypedef long long ll;\nconst ll inf = 1ll<<62;\n\nll dp[N][N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (j == i) continue;\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i ++) {\n\t\tpos[i][i] = 0;\n\t\tfor (int j = i - 1; j >= 1; j --) pos[i][j] = pos[i][j+1] + a[j][i];\n\t\tneg[i][i] = 0;\n\t\tfor (int j = i - 1; j >= 1; j --) neg[i][j] = neg[i][j+1] + a[i][j];\n\t}\n\tfor (int i = 0; i <= n; i ++) for (int j = 0; j <= i; j ++) dp[i][j] = inf;\n\tdp[0][0] = 0;\n\tfor (int j = 0; j <= n; j ++) {\n\t\tfor (int k = 0; k <= j; k ++) {\n\t\t\tll cur = 0;\n\t\t\tfor (int i = j + 1; i <= n; i ++) {\n\t\t\t\tcur += pos[i][j+1] - neg[i][k+1];\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + cur);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = inf;\n\tfor (int i = 0; i < n; i ++) ans = min(ans, dp[n][i]);\n\tfor (int i = 1; i <= n; i ++) for (int j = i - 1; j >= 1; j --) ans += a[i][j];\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ninline void chmin(ll &x, ll y) { if (x > y) x = y; }\n\nconst int maxn = 512;\nconst ll INF = TEN(18);\n\nll A[maxn][maxn];\nll dp[maxn][maxn];\nll s[2][maxn][maxn];\n\nll get(int tp, int a, int b, int c, int d) { //sum a <= x <= c, b <= y <= d\n\treturn s[tp][c+1][d+1] - s[tp][c+1][b] - s[tp][a][d+1] + s[tp][a][b];\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N) {\n\t\trep(j, N) {\n\t\t\tif (i != j) cin >> A[i][j];\n\t\t\tint tp = (i > j);\n\t\t\trep(t, 2) {\n\t\t\t\ts[t][i+1][j+1] = s[t][i+1][j] + s[t][i][j+1] - s[t][i][j];\n\t\t\t\tif (t == tp) {\n\t\t\t\t\ts[t][i+1][j+1] += A[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, maxn) rep(j, maxn) dp[i][j] = INF;\n\t\n\tfor (int i = 1; i < N; ++i) {\n\t\tdp[i][0] = get(0, 0, 0, i-1, i-1);\n\t}\n\n\tfor (int i = 1; i < N; ++i) {\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\trep(k, j) {\n\t\t\t\tchmin(dp[i][j], dp[j][k] + get(0, j, j, i-1, i-1) + get(1, i, k, N-1, j-1));\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = s[0][N][N];\n\n\tfor (int i = 1; i < N; ++i) {\n\t\trep(j, i) {\n\t\t\tchmin(ans, dp[i][j] + get(0, i, i, N-1, N-1));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#include <bits/stdc++.h>\n#define LL long long\n#define P pair<int, int>\nconst LL N = 6e4 + 10;\nconst LL inf = 0x3f3f3f3f;\nconst LL mod = 998244353;\nusing namespace std;\ntemplate <typename tp>\ninline void read(tp &x)\n{\n    x = 0; char c = getchar(); bool f = 0;\n    for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar()) ;\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar()) ;\n    if (f) x = -x;\n}\nLL n,cost[510][510];\nLL along[510][510],sum_along[510][510];\nLL inverse[510][510],sum_inverse[510][510];\nLL dp[510][510];\nsigned main()\n{\n    read(n);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            if(i==j) continue;\n            read(cost[i][j]);\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            sum_along[j][i]=sum_along[j-1][i]+cost[j][i];\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n+1;j++)\n            along[i][j]=along[i][j-1]+sum_along[j-1][j]-sum_along[i-1][j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            sum_inverse[j][i]=sum_inverse[j-1][i]+cost[i][j];\n    for(int i=1;i<=n+1;i++)\n        for(int j=n+1;j>i;j--)\n            inverse[i][j]=inverse[i][j+1]+sum_inverse[i][j];\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0]=0;\n    for(int i=0;i<=n;i++)\n        for(int j=i;j<=n;j++)\n            if(dp[i][j]<1e18)\n                for(int k=j+1;k<=n+1;k++)\n                    dp[j][k]=min(dp[j][k],dp[i][j]+along[j+1][k]+inverse[j][k+1]-inverse[i][k+1]);\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)\n        ans=min(ans,dp[i][n+1]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 21.07.2019 15:23:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> a(n, vector<int>(n));\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i != j) {\n        cin >> a[i][j];\n        total += a[i][j];\n      }\n    }\n  }\n  vector<vector<long long>> sumI(n + 1, vector<long long>(n + 1));\n  for (int j = 0; j < n; j++) {\n    sumI[0][j] = 0;\n    for (int i = 0; i < n; i++) {\n      sumI[i + 1][j] = sumI[i][j] + a[i][j];\n    }\n  }\n  vector<vector<long long>> sumJ(n + 1, vector<long long>(n + 1));\n  for (int i = 0; i < n; i++) {\n    sumJ[i][0] = 0;\n    for (int j = 0; j < n; j++) {\n      sumJ[i][j + 1] = sumJ[i][j] + a[i][j];\n    }\n  }\n  vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, -1));\n  dp[0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i; j <= n; j++) {\n      if (dp[i][j] == -1) {\n        continue;\n      }\n      long long ft = dp[i][j];\n      for (int k = j; k < n; k++) {\n        ft += sumI[j][k];\n        ft += sumJ[k][k] - sumJ[k][i];\n        dp[j][k + 1] = max(dp[j][k + 1], ft);\n      }\n    }\n  }\n  long long ans = -1;\n  for (int i = 0; i < n; i++) {\n    ans = max(ans, dp[i][n]);\n  }\n  cout << total - ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=505;\nconst LL inf=(LL)1e17;\n\nint n;\nLL s1[N][N],s2[N][N],a[N][N],f[N][N];\n\nvoid pre()\n{\n\tfor (int l=1;l<n;l++)\n\t\tfor (int i=1;i+l<=n;i++)\n\t\t{\n\t\t\tint j=i+l;\n\t\t\ts1[i][j]=s1[i][j-1]+s1[i+1][j]-s1[i+1][j-1]+a[i][j];\n\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=n;j>i;j--)\n\t\t\ts2[i][j]=s2[i][j+1]+a[j][i];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t\ts2[i][j]+=s2[i-1][j];\n}\n\nLL dp()\n{\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=0;j<=n;j++)\n\t\t\tf[i][j]=inf;\n\tLL ans=s1[1][n];\n\tfor (int i=1;i<=n;i++) ans=std::min(ans,s1[1][i]+s1[i+1][n]);\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tf[i][j]=s1[1][i]+s1[i+1][j]+s1[j+1][n]+s2[i][j+1];\n\tfor (int j=1;j<=n;j++)\n\t\tfor (int i=1;i<j;i++)\n\t\t{\n\t\t\tans=std::min(ans,f[i][j]);\n\t\t\tfor (int k=j+1;k<=n;k++)\n\t\t\t\tf[j][k]=std::min(f[j][k],f[i][j]+s1[j+1][k]+s2[j][k+1]-s2[i][k+1]);\n\t\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i!=j) scanf(\"%lld\",&a[i][j]);\n\tpre();\n\tprintf(\"%lld\\n\",dp());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 505;\nll n, dp[maxn][maxn], a[maxn][maxn], b[maxn][maxn];\nll get(ll i, ll l, ll r) {\n\treturn r >= l ? a[i][r] - a[i][l - 1] : 0;\n}\nll rget(ll i, ll l, ll r) {\n\treturn r >= l ? b[i][r] - b[i][l - 1] : 0;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif(i != j) cin >> a[i][j];\n\t\t\tb[j][i] = a[i][j];\n\t\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\ta[i][j] += a[i][j-1];\n\t\t\tb[i][j] += b[i][j-1];\n\t\t}\n\t\t\n\tmemset(dp, 0x3f, sizeof dp);\n\tdp[0][0] = 0;\n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = i; j <= n; j++)\n\t\t\tif(dp[i][j] < 1ll<<60) {\n\t\t\t\tll cur = 0;\n\t\t\t\tfor(int k = j+1; k <= n; k++) {\n\t\t\t\t\tcur += get(k, 1, i-1);\n\t\t\t\t\tcur += rget(k, j+1, k);\n\t\t\t\t\tdp[j+1][k] = min(dp[j+1][k], dp[i][j] + cur);\n\t\t\t\t}\n\t\t\t}\n\tll ans = 1ll<<60;\n\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[i][n]);\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 505;\n\n\n// class complex {\n//     long double image, real;\n// public:\n//     long double getImage() {\n//         return image;\n//     }\n//     long double getReal() {\n//         return real;\n//     }\n\n// };\n\n\nint n;\nint a[MAXN][MAXN];\nlong long s1[MAXN][MAXN], s2[MAXN][MAXN], dp[MAXN][MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n   // read(FILENAME);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n - 1; j++) {\n            cin >> a[i][j + (i <= j)];\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        long long sum1 = 0, sum2 = 0;\n        for (int j = i; j <= n; j++) {\n            sum1 += a[i][j];\n            sum2 += a[j][i];\n            s1[i][j] = s1[i - 1][j] + sum1;\n            s2[i][j] = s2[i - 1][j] + sum2;\n        } \n    }\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n + 1; j++) {\n            dp[i][j] = 1e18;\n        }\n    }\n    for (int i = 2; i <= n; i++) {\n        dp[i][1] = s1[i - 1][i - 1];\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            for (int x = i + 1; x <= n; x++) {\n                long long sum1 = s1[x - 1][x - 1] - s1[i - 1][x - 1];\n                long long sum2 = s2[i - 1][n] - s2[j - 1][n] - s2[i - 1][x - 1] + s2[j - 1][x - 1];\n                chkmin(dp[x][i], dp[i][j] + sum1 + sum2);\n            }\n        }\n    }\n    long long ans = s1[n][n];\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            chkmin(ans, dp[i][j] + s1[n][n] - s1[i - 1][n]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 505;\n\n\n// class complex {\n//     long double image, real;\n// public:\n//     long double getImage() {\n//         return image;\n//     }\n//     long double getReal() {\n//         return real;\n//     }\n\n// };\n\n\nint n;\nint a[MAXN][MAXN];\nlong long s1[MAXN][MAXN], s2[MAXN][MAXN], dp[MAXN][MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n   // read(FILENAME);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n - 1; j++) {\n            cin >> a[i][j + (i <= j)];\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        long long sum1 = 0, sum2 = 0;\n        for (int j = i; j <= n; j++) {\n            sum1 += a[i][j];\n            sum2 += a[j][i];\n            s1[i][j] = s1[i - 1][j] + sum1;\n            s2[i][j] = s2[i - 1][j] + sum2;\n        } \n    }\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n + 1; j++) {\n            dp[i][j] = 1e18;\n        }\n    }\n    for (int i = 2; i <= n; i++) {\n        dp[i][1] = s1[i - 1][i - 1];\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            for (int x = i + 1; x <= n; x++) {\n                long long sum1 = s1[x - 1][x - 1] - s1[i - 1][x - 1];\n                long long sum2 = s2[i - 1][n] - s2[j - 1][n] - s2[i - 1][x - 1] + s2[j - 1][x - 1];\n                chkmin(dp[x][i], dp[i][j] + sum1 + sum2);\n            }\n        }\n    }\n    long long ans = s1[n][n];\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            chkmin(ans, dp[i][j] + s1[n][n] - s1[i - 1][n]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, a[505][505];\nLL cp[505][505], cq[505][505];\nLL dp[2][505][505];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) rep(j, n)\n\tif(i != j) scanf(\"%d\", &a[i][j]);\n\t\n\trep(i, n) rep(j, n)\n\tif(i < j) cp[i][j] = cp[i][j - 1] + a[i][j];\n\t\n\trep(i, n) for(int j = n - 1; j >= 0; j --)\n\tif(j > i) cq[i][j - 1] = cq[i][j] + a[j][i];\n\t\n\tmemset(dp[(n - 1) & 1], INF, sizeof(dp[(n - 1) & 1]));\n\tdp[(n - 1) & 1][n - 1][n - 1] = cp[n - 1][n - 1] + cq[n - 1][n - 1];\n\t\n\tfor(int i = n - 2; i >= 0; i --) {\n\t\tint ori = !(i & 1), nw = i & 1;\n\t\tmemset(dp[nw], INF, sizeof(dp[nw]));\n\t\tfor(int j = i; j < n; j ++) for(int k = j; k < n; k ++)\n\t\tdp[nw][j][k] = min(dp[nw][j][k], dp[ori][j][k] + cp[i][j] + cq[i][k]);\n\t\tLL cans = INF;\n\t\tfor(int j = n - 1; j >= i; j --) {\n\t\t\tfor(int k = j; k < n; k ++) cans = min(cans, dp[ori][j][k]);\n\t\t\tfor(int k = j; k >= i; k --) dp[nw][k][j] = min(dp[nw][k][j], cans + cp[i][k] + cq[i][j]);\n\t\t}\n\t}\n\t\n\tLL ans = INF;\n\trep(i, n) for(int j = i; j < n; j ++)\n\tans = min(ans, dp[0][i][j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#define INF 1000000000\n#define LLINF 2000000000000000\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define LOOP(i,N) for(int i=0;i<N;i++)\n#define LOOP1(i,N) for(int i=1;i<=N;i++)\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n// #define int long long\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\tint a[n+1];\n\tLOOP(i,n){\n\t\tcin >> a[i+1];\n\t}\n\tint res[n+1];\n\tint resc = 0;\n\tfor(int i=n; i>=1; i--){\n\t\tint cnt = 0;\n\t\tint j = i*2;\n\t\twhile(j<=n){\n\t\t\tif(a[j])cnt++;\n\t\t\tj+=i;\n\t\t}\n\t\tif(cnt%2==a[i]){\n\t\t\tres[i]=0;\n\t\t}else{\n\t\t\tres[i]=1;\n\t\t\tresc++;\n\t\t}\n\t}\n\tcout << resc << endl;\n\tLOOP(i,n){\n\t\tif(res[i+1]==1)cout << i+1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\ninline int read(){\n    int x=0; bool f=1; char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n    for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n    if(f) return x;\n    return -x;\n}\nconst int N = 500;\nLL a[N+3][N+3],s[2][N+3][N+3],f[N+3][N+3];\nint n;\nvoid update(LL &x,LL y) {x = x<y?x:y;}\nLL sum(int t,int lx,int rx,int ly,int ry){\n    return s[t][rx][ry]-s[t][lx-1][ry]-s[t][rx][ly-1]+s[t][lx-1][ly-1];\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        for(int j=1; j<=n; j++){\n            if(j==i) continue;\n            scanf(\"%lld\",&a[i][j]);\n        }\n    }\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=n; j++){\n            if(i<j) s[0][i][j]=a[i][j];\n            s[0][i][j]+=s[0][i][j-1];\n        }\n        for(int j=1;j<=n;j++)s[0][i][j]+=s[0][i-1][j];\n    }\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=n; j++){\n            if(i>j)s[1][i][j]=a[i][j];\n            s[1][i][j]+=s[1][i][j-1];\n        }\n        for(int j=1;j<=n;j++)s[1][i][j]+=s[1][i-1][j];\n    }\n    memset(f,42,sizeof(f)); \n    f[0][0]=0ll;\n    for(int i=0;i<=n; i++)\n        for(int j=0;j<max(i,1);j++)\n            for(int k=i+1;k<=n;k++){\n                LL tmp=f[i][j]+sum(1,k+1,n,j+1,i)+sum(0,i+1,k,i+1,k);\n                update(f[k][i],tmp);\n            }\n    LL ans=f[n][1];\n    for(int i=1;i<=n;i++)update(ans,f[n][i]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define Inf ll(1e18)\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=505;\nint n;\nll a[maxn][maxn],sum[2][maxn][maxn],dp[maxn][maxn],ans;\nvoid ckmax(ll &a,ll b){\n\tif(b>a)a=b;\n}\nll getval(int tp,int x1,int x2,int y1,int y2){\n\tif(x1>x2||y1>y2)return 0;\n\treturn sum[tp][x2][y2]+sum[tp][x1-1][y1-1]-sum[tp][x2][y1-1]-sum[tp][x1-1][y2];\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n)REP(j,n){\n\t\tif(i==j)a[i][j]=0;\n\t\telse{\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t\tif(i>j)sum[0][i][j]=a[i][j];\n\t\t\telse sum[1][j][i]=a[i][j];\n\t\t}\n\t}\n\tREP(i,n)REP(j,n)sum[0][i][j]+=sum[0][i][j-1],sum[1][i][j]+=sum[1][i][j-1];\n\tREP(i,n)REP(j,n)sum[0][i][j]+=sum[0][i-1][j],sum[1][i][j]+=sum[1][i-1][j];\n\tREP(i,n)REP(j,n)dp[i][j]=-Inf;\n\tdp[1][1]=0;\n\tREP(i,n)REP(j,n)if(dp[i][j]!=-Inf){\n\t\tckmax(ans,dp[i][j]+getval(0,j+1,n,i,n)+getval(1,j+1,n,1,j-1));\n\t\tfor(int k=j+1;k<=n;k++){\n\t\t\tif(k==1)continue;\n\t\t\tll cur1=getval(0,k,k,j,k-1)+getval(0,j+1,k-1,i,k-1);\n\t\t\tll cur2=getval(1,k,k,1,k-1)+getval(1,j+1,k-1,1,j-1);\n\t\t\tckmax(dp[j][k],dp[i][j]+cur1+cur2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[0][n][n]+sum[1][n][n]-ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 5e2 + 5;\nint dp[2][N][N];\nint cost[N][N];\nint col[N][N];\nint row[N][N];\nconst int kInf = 1e18;\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    RE (j, n) {\n      if (i == j) { continue; }\n      cin>>cost[i][j];\n    }\n  }\n  RE (i, n) {\n    RE (j, n) {\n      col[i][j] = col[i][j - 1] + cost[i][j];\n      row[i][j] = row[i - 1][j] + cost[i][j];\n    }\n  }\n  \n  int t = 0;\n  REP (i, N) {\n    REP (j, N) {\n      dp[0][i][j] = dp[1][i][j] = kInf;\n    }\n  }\n  dp[0][0][0] = 0;\n  FOR (i, 2, n) {\n    t ^= 1;\n    REP (i, N) {\n      REP (j, N) {\n        dp[t][i][j] = kInf;\n      }\n    }\n    REP (prv_1, i) {\n      REP (prv_2, prv_1 + 1) {\n        //[0, prv_2], [prv_2 + 1, prv_1], [prv_1 + 1, i - 1]\n        //nowy przedzial\n        mini(dp[t][i - 1][prv_1], dp[t ^ 1][prv_1][prv_2] + col[i][prv_1]);\n        // kontynuujemy stary\n        int cand = dp[t ^ 1][prv_1][prv_2] + col[i][prv_2] + row[i][i] - row[prv_1][i];\n//         if (prv_1) {\n//           cand -= row[prv_1 - 1][i];\n//         }\n        mini(dp[t][prv_1][prv_2], cand);\n      }\n    }\n    REP (j, N) {\n      REP (k, N) {\n        if (dp[t][j][k] != kInf) {\n          debug(i, j, k, dp[t][j][k]);\n        }\n      }\n    }\n  }\n  int res = kInf;\n  REP (i, N) {\n    REP (j, N) {\n      mini(res, dp[t][i][j]);\n    }\n  }\n  cout<<res<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nll dp[501][501][501];\nll cost[501][501];\nint main(){\n    ll n;\n    cin >> n;\n    rep(i,n){\n        for(int j=0;j<n;j++){\n            if(j==i)continue;\n            cin >> cost[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            rep(k,n){\n                dp[i][j][k] = (1LL<<60);\n            }\n        }\n    }\n    dp[0][0][0] = 0;\n    for(int k=0;k<n-1;k++){\n        vector<ll>g(n+1);\n        vector<ll>f(n+1);\n        for(int i=1;i<n;i++){\n            g[i] = cost[k+1][i-1] + g[i-1];\n        }\n        for(int i=k;i>=0;i--){\n            f[i] = cost[i][k+1] + f[i+1];\n        }\n        for(int s=0;s<=k;s++){\n            for(int t=s;t<=k;t++){\n                // ll tmp = 0;\n                // for(int i=t+1;i<=k;i++){\n                //     tmp += cost[i][k+1];\n                // }\n                // for(int i=0;i<s;i++){\n                //     tmp += cost[k+1][i];\n                // }\n                chmin(dp[k+1][s][t],dp[k][s][t] + g[s]+f[t+1]);\n                // chmin(dp[k+1][s][t],dp[k][s][t] + tmp);\n                // tmp = 0;\n                // for(int i=0;i<=t;i++){\n                //     tmp += cost[k+1][i];\n                // }\n                // chmin(dp[k+1][t+1][k],dp[k][s][t] + tmp);\n                chmin(dp[k+1][t+1][k],dp[k][s][t] + g[t+1]);\n                if(t==k){\n                    chmin(dp[k+1][s][k+1],dp[k][s][k] + f[s]);    \n                }\n            }\n        }\n    }\n    ll res = (1LL<<60);\n    rep(i,n){\n        rep(j,n){\n            chmin(res,dp[n-1][i][j]);\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#ifdef _debug\n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nusing ul = unsigned;\nusing db = double;\nint n;\nconst int maxn = 600;\nll dp[maxn][maxn];\nll w[maxn][maxn];\nll p[maxn][maxn];\nll to[maxn][maxn];\nconst ll inf = 1ll << 59;\ninline ll get(int a, int b, int c, int d){\n\treturn p[b][d] - (c == 0 ? 0 : p[b][c-1]) - (a == 0 ? 0 : p[a-1][d]) + (a == 0 || c == 0 ? 0 : p[a-1][c-1]);\n}\ninline ll get_to(int l, int r){\n\treturn to[r][r] - to[l-1][r] - to[r][l-1] + to[l-1][l-1];\n} \nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)if(i != j)cin >> w[i][j];\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + w[i][j];\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)to[i][j] = to[i-1][j] + to[i][j-1] - to[i-1][j-1] + (i < j ? w[i][j] : 0);\n\tfor(int i = 1;i <= n;++i){\n\t\tdp[i][1] = get_to(1, i);\n\t\tfor(int j = 2;j <= i;++j){\n\t\t\tdp[i][j] = inf;\n\t\t\tfor(int k = 1;k < j;++k){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j-1][k] + get_to(j, i) + get(j, i, 0, k-1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << *min_element(dp[n]+1, dp[n]+n+1) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int N = 505;\nint n; ll a[N][N], b[N][N], dp[N][N];\nvoid chkmn(ll &a, ll b){ if(a > b) a = b; }\nll coef(int k, int j, int i){\n\treturn b[j+1][i] + a[n][j] - a[n][k] - a[i][j] + a[i][k];\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++)\n\tif(j!=i) scanf(\"%lld\",&a[i][j]);\n\tfor(int i=n; i>=1; i--)\n\tfor(int j=i; j<=n; j++)\n\tb[i][j]=a[i][j]+b[i+1][j]+b[i][j-1]-b[i+1][j-1];\n\tfor(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++)\n\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\tmemset(dp,0x3f,sizeof(dp));\n\tll ans = 1e18;\n\tfor(int i=1; i<n; i++){\n\t\tdp[i][0] = coef(0,0,i);\n\t\tchkmn(ans, dp[i][0] + coef(0,i,n));\n\t\tfor(int j=1; j<i; j++)\n\t\tfor(int k=0; k<j; k++)\n\t\tchkmn(dp[i][j], dp[j][k] + coef(k,j,i));\n\t\tfor(int j=1; j<i; j++)\n\t\tchkmn(ans, dp[i][j] + coef(j,i,n));\n\t} cout << ans; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint a[510][510];\nlong long b[510][510], g[510][510];\nlong long dp[510][510];\ninline void upd(long long &v, long long x) {\n\tif (v > x) v = x;\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tg[i][j] = g[i][j-1];\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\tg[i][j] += a[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tb[i+1][j+1] = b[i+1][j] + b[i][j+1] + a[i][j] - b[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i - 1; j > 0; j--) {\n\t\t\tdp[i][j] = 1ll << 60;\n\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\tupd(dp[i][j], dp[j][k] + g[j][i-1] + b[i][k] - b[j][k]);\n\t\t\t}\n\t\t}\n\t\tdp[i][0] = g[0][i-1];\n\t}\n\tlong long ans = 1ll << 60;\n\tfor (int i = 0; i < n; i++) {\n\t\tupd(ans, dp[n][i]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\nlong long f[510][510],a[510][510],b[510][510];\ninline long long mymin(long long x,long long y){return x<y?x:y;}\ninline long long CVN(int ll,int lr,int rl,int rr){return a[lr][rr]-a[ll-1][rr]-a[lr][rl-1]+a[ll-1][rl-1];}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tint c;scanf(\"%d\",&c);\n\t\t\ta[i][j]=a[i-1][j]+a[i][j-1]+c-a[i-1][j-1];\n\t\t}\n\t}\n\tfor(int j=2;j<=n;j++)\n\t{\n\t\tfor(int i=1;i<j;i++)b[i][j]=b[i][j-1]+CVN(i,j-1,j,j);\n\t}\n\tmemset(f,63,sizeof(f));f[0][1]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=j+1;k<=n+1;k++)\n\t\t\t{\n\t\t\t\tf[j][k]=mymin(f[j][k],f[i][j]+b[j][k-1]+CVN(k,n,i,j-1));\n\t\t\t}\n\t\t}\n\t}\n\tlong long ss=0x3f3f3f3f3f3f3f3fll;\n\tfor(int i=1;i<=n;i++)if(f[i][n+1]<ss)ss=f[i][n+1];\n\tprintf(\"%lld\\n\",ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// D - Negative Cycle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tINF\t1e16\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<vector<long long> > a(n, vector<long long>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (i != j) cin >> a[i][j];\n\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, INF));\n\tdp[0][0] = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long> x(i), y(i);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = i + 1; k <= n; k++) x[j] += a[k - 1][j - 1];\n\t\t\tif (j > 0) x[j] += x[j - 1];\n\t\t}\n\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\tfor (int k = j + 1; k < i + 1; k++) y[j] += a[j][k - 1];\n\t\t\tif (j + 1 < i - 1) y[j] += y[j + 1];\n\t\t}\n\t\tfor (int j = 0; j < i; j++)\n\t\t\tfor (int k = 0; k < j + 1; k++)\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][k] + x[j] - x[k] + y[j]);\n\t}\n\n\tcout << *min_element(dp[n].begin(),dp[n].end()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nLL _min(LL x, LL y) {return x < y ? x : y;}\nconst int N = 502;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(LL x) {\n\tif(x < 0) x = -x, putchar('-');\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nLL f[N][N], s[N][N], ss[N][N];\nint n, v[N][N];\n\nLL S(int x1, int x2, int y1, int y2) {\n\tif(x1 > x2 || y1 > y2) return 0;\n\treturn ss[x2][y2] - ss[x2][y1 - 1] - ss[x1 - 1][y2] + ss[x1 - 1][y1 - 1];\n}\n\nint main() {\n\tn = read();\n\tfor(int i = 1; i <= n + 1; i++) {\n\t\tfor(int j = 1; j <= n + 1; j++) {\n\t\t\tif(i != j && j <= n && i <= n) v[i][j] = read();\n\t\t\tss[i][j] = v[i][j] + ss[i - 1][j] + ss[i][j - 1] - ss[i - 1][j - 1];\n\t\t\tif(j >= i) s[i][j] = s[i][j - 1] + v[i][j];\n\t\t} for(int j = i; j <= n + 1; j++) s[i][j] += s[i - 1][j];\n\t} memset(f, -1, sizeof(f)); f[0][0] = 0;\n\tfor(int i = 0; i <= n; i++) for(int j = i; j <= n; j++) if(f[i][j] != -1){\n\t\tfor(int k = j + 1; k <= n + 1; k++) {\n\t\t\tif(f[j][k] == -1) f[j][k] = f[i][j] + S(k + 1, n, i + 1, j) + s[k][k] - s[j][k];\n\t\t\telse f[j][k] = _min(f[j][k], f[i][j] + S(k + 1, n, i + 1, j) + s[k][k] - s[j][k]);\n\t\t}\n\t} LL ans = f[0][n + 1];\n\tfor(int i = 1; i <= n; i++) ans = _min(ans, f[i][n + 1]);\n\tput(ans), puts(\"\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nll A[510][510];\nll U[510][510];\nll D[510][510];\n\nll dp[2][510][510];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif(i == j) continue;\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, i) {\n\t\t\tU[i][j + 1] = U[i][j] + A[j][i];\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\trep(j, 0, i) {\n\t\t\tD[i][j + 1] = D[i][j] + A[i][j];\n\t\t}\n\t}\n\trep(i, 0, 2) {\n\t\trep(j, 0, N + 1) {\n\t\t\trep(k, 0, N + 1) {\n\t\t\t\tdp[i][j][k] = linf;\n\t\t\t}\n\t\t}\n\t}\n\tdp[1][0][0] = 0;\n\tint now = 1, nex = 0;\n\trep(i, 1, N) {\n\t\trep(j, 0, N) {\n\t\t\trep(k, 0, N) {\n\t\t\t\tdp[nex][j][k] = linf;\n\t\t\t}\n\t\t}\n\t\trer(j, N, 0) {\n\t\t\trer(k, N, 0) {\n\t\t\t\tif(dp[now][j][k] == linf) continue;\n\t\t\t\tMIN(dp[now][k][i], dp[now][j][k]);\n\t\t\t}\n\t\t}\n\t\trep(j, 0, N) {\n\t\t\trep(k, 0, N) {\n\t\t\t\t// debug(i, j, k, dp[i][j][k], U[i][i] - U[i][k], D[i][j]);\n\t\t\t\tMIN(dp[nex][j][k], dp[now][j][k] + (U[i][i] - U[i][k]) + D[i][j]);\n\t\t\t}\n\t\t}\n\t\tswap(now, nex);\n\t}\n\tll res = linf;\n\trep(j, 0, N) {\n\t\trep(k, 0, N) {\n\t\t\t// debug(N, j, k, dp[N][j][k]);\n\t\t\tMIN(res, dp[now][j][k]);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint main(){\n\tint n;\n\tread(n);\n\tint a[n+1][n+1]={},b[n+1][n+1]={};\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++) read(a[i][j]);\n\t\tfor(int j=i+1;j<=n;j++) read(b[i][j]);\n\t}\n\tll s[2][510][510]={};\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ts[0][i][j]=s[0][i-1][j]+s[0][i][j-1]-s[0][i-1][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ts[1][i][j]=s[1][i-1][j]+s[1][i][j-1]-s[1][i-1][j-1]+b[i][j];\n\tll f[n+1][n+1];memset(f,63,sizeof(f));\n\tauto calc=[&](int k,int a,int b,int c,int d){\n\t\tif(a>b||c>d) return 0ll;\n\t\treturn s[k][b][d]-s[k][a-1][d]-s[k][b][c-1]+s[k][a-1][c-1];\n\t};\n\tauto chmin=[](ll &a,ll b){if(b<a) a=b;};\n\tfor(int i=1;i<=n;i++)\n\t\tf[1][i]=calc(1,1,i,2,i);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t\tchmin(f[i+1][k],f[j][i]+calc(1,i+1,k,i+2,k)+calc(0,i+1,k,1,j-1));\n\t\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;i++) chmin(ans,f[i][n]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n)                                                                \\\n  for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for (int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string { return '\"' + s + '\"'; }\nauto to_string(char c) -> std::string { return \"'\" + std::string{c} + \"'\"; }\nauto to_string(const char *s) -> std::string {\n  return to_string((std::string)s);\n}\nauto to_string(bool b) -> std::string { return (b ? \"true\" : \"false\"); }\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N> auto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T> auto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const &x : v) {\n    if (flg)\n      res += \", \";\n    else\n      flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...)                                                             \\\n  std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T> auto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U,\n          std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T,\n          std::enable_if_t<N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args,\n          std::enable_if_t<N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t> auto &at(T &t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto &at(T &t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate <typename T, typename U> inline auto cmn(T &a, U b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T, typename U> inline auto cmx(T &a, U b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nint main() {\n  freopen(\"park.in\", \"r\", stdin);\n  freopen(\"park.out\", \"w\", stdout);\n  std::cin.tie(0);\n  std::cin.sync_with_stdio(false);\n  int n;\n  std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j)\n        continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  auto d = make_higher_vector<3, lint>(n, n + 1, n + 1);\n  for (int j = 0; j < n; j++) {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++) {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++) {\n    for (int k = j + 1; k < n; k++) {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++) {\n    for (int k = j; k <= n; k++) {\n      at(d, j, k, 0) = 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int k = j; k <= n; k++) {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++) {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      for (int k = j + 1; k <= n; k++) {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf)\n          continue;\n        dp[j][k] = std::min(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n    auto ret = inf;\n    for (int i = 0; i < n; i++) {\n      cmn(ret, at(dp, i, n));\n    }\n    std::cout << ret << std::endl;\n    return 0;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll sum[501][501];\nll dp[502][502];\nll cop[502][502];\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<ll>> a(n);\n\trep(i, n) {\n\t\ta[i].resize(n);\n\t\trep(j, n) {\n\t\t\tif (i == j)a[i][j] = 0;\n\t\t\telse cin >> a[i][j];\n\t\t}\n\t}\n\n\t//calc sum\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ts += a[k][j];\n\t\t\t}\n\t\t\tsum[i][j] = s;\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\t{\n\t\tll s = 0;\n\t\tfor (int j = n-1; j>0; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j][k] = s + sum[0][k] + sum[k + 1][j];\n\t\t\t}\n\n\t\t\ts += a[j][0];\n\t\t}\n\t\t/*cout << \"0 is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tfor (int i = 1; i < n-1; i++) {\n\t\trep(j, n + 1)rep(k, n + 1)cop[j][k] = INF;\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tfor (int k = i-1; k <= j; k++) {\n\t\t\t\tif (dp[j][k] == INF)continue;\n\t\t\t\tll s = 0;\n\t\t\t\tif (k >= i) {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tcop[l][k] = min(cop[l][k], s+dp[j][k] + sum[k + 1][l] - sum[k + 1][j]);\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int l = n - 1; l >= j; l--) {\n\t\t\t\t\t\tfor (int m = j; m <= l; m++) {\n\t\t\t\t\t\t\tcop[l][m] = min(cop[l][m], s + dp[j][k] + sum[i][m] - sum[i][j] + sum[m+1][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ts += a[l][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j, n + 1)rep(k, n + 1)dp[j][k]=cop[j][k];\n\n\t\t/*cout << i << \" is result \" << endl;\n\t\trep(j, n)rep(k, n) {\n\t\t\tcout << j << \" \" << k << \" \" << dp[j][k] << endl;\n\t\t}*/\n\t}\n\tll ans = INF;\n\t/*rep(i, n)rep(j, n) {\n\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t}*/\n\trep(i, n+1)rep(j, n+1)ans = min(ans, dp[i][j]);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long inf=1000000000000000000ll;\nint n,a[510][510],x,y;\nlong long f[2][510][510],ans,sum[510][510],Sum[510][510];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) if (j!=i) scanf(\"%d\",&a[i][j]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tsum[i][0]=Sum[i][0]=0;\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tsum[i][j]=sum[i][j-1]+a[i][j],Sum[i][j]=Sum[i][j-1]+a[j][i];\n\t}\n\tfor (int i=0; i<=n; i++)\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tf[0][i][j]=f[1][i][j]=inf;\n\tx=1,y=0,f[0][1][1]=0;\n\tfor (int i=2; i<=n; i++) \n\t{\n\t\tx^=1,y^=1;\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tfor (int k=1; k<=n; k++) f[y][j][k]=inf;\n\t\tfor (int j=1; j<i; j++)\n\t\t\tfor (int k=j; k<i; k++)\n\t\t\t\tf[y][j][k]=min(f[y][j][k],f[x][j][k]+sum[i][j-1]+Sum[i][i]-Sum[i][k-1]),\n\t\t\t\tf[y][k][i]=min(f[y][k][i],f[x][j][k]+sum[i][k-1]);\n\t}\n\tans=inf;\n\tfor (int i=1; i<=n; i++) \n\t\tfor (int j=1; j<=n; j++) ans=min(ans,f[y][i][j]);\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 510\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nint a[maxn][maxn];\nll sum1[maxn][maxn],sum2[maxn][maxn],f[maxn][maxn];\nint n;\nll query1(int l1,int r1,int l2,int r2){return sum1[r1][r2]-sum1[r1][l2-1]-sum1[l1-1][r2]+sum1[l1-1][l2-1];}\nll query2(int l1,int r1,int l2,int r2){return sum2[r1][r2]-sum2[r1][l2-1]-sum2[l1-1][r2]+sum2[l1-1][l2-1];}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)a[i][j]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tsum1[i][j]=sum1[i][j-1]+sum1[i-1][j]-sum1[i-1][j-1];\n\t\t\tsum2[i][j]=sum2[i][j-1]+sum2[i-1][j]-sum2[i-1][j-1];\n\t\t\tif(i<j)sum1[i][j]+=a[i][j];\n\t\t\telse sum2[i][j]+=a[i][j];\n\t\t}\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=1;i<=n;i++)\n\t\tf[i][1]=query1(1,i,1,i);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tfor(int k=1;k<j;k++)\n\t\t\t\tf[i][j]=std::min(f[i][j],f[j-1][k]+query1(j,i,j,i)+query2(i+1,n,k,j-1));\n\tll ans=(1ll<<60);\n\tfor(int i=1;i<=n;i++)\n\t\tans=std::min(ans,f[n][i]);\n\twriteln(ans);\n\t// for(int i=1;i<=n;i++){\n\t// \tfor(int j=1;j<=n;j++)\n\t// \t\twritesp(f[i][j]);\n\t// \tputchar('\\n');\n\t// }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (510)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,a[N][N]; LL f[N][N],suf[N][N],sum[N][N],ans;\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<n;j++)read(a[i][j+(j>=i)]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=n;j>i;j--){\n\t\tsuf[i][j]=suf[i][j+1];\n\t\tfor(int k=1;k<=i;k++)suf[i][j]+=a[j][k];\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n+1;j++){\n\t\tsum[i][j]=sum[i][j-1];\n\t\tfor(int k=i;k<j;k++)sum[i][j]+=a[k][j];\n\t}\n\tmemset(f,inf,sizeof(f)),ans=inf,f[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\tfor(int j=i;j<=n;j++)\n\tfor(int k=j+1;k<=n+1;k++)\n\tf[j][k]=min(f[j][k],f[i][j]+sum[j+1][k]+suf[j][k+1]-suf[i][k+1]);\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][n+1]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvector<vi> a(n, vi(n));\n\trep(i, n) rep(j, n) if(i != j) cin >> a[i][j];\n\t\n\tvector<vector<ll>> dp(n, vector<ll>(n, 1e18));\n\tvector<vector<ll>> ls(n + 1, vector<ll>(n));\n\tvector<vector<ll>> rs(n + 1, vector<ll>(n));\n\t\n\trep(i, n) rep(j, n) rs[j + 1][i] = rs[j][i] + a[i][j];\n\trep(i, n) rep(j, n) ls[j + 1][i] = ls[j][i] + a[j][i];\n\t\n\tll ans = 1e18;\n\tdp[0][0] = 0;\n\trep(j, n) rep(i, j + 1){\n\t\tvector<ll> sum(n + 1);\n\t\tfor(int k = n - 1; k > j; k--) sum[k] = sum[k + 1] + rs[j][k] - rs[i][k];\n\t\tll tmp = 0;\n\t\tfor(int k = j + 1; k < n; k++){\n\t\t\tdp[j][k] = min(dp[j][k], dp[i][j] + tmp + sum[k]);\n\t\t\ttmp += ls[k][k] - ls[j][k];\n\t\t}\t\t\n\t\tans = min(ans, dp[i][j] + tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3fLL;\n\nint n, a[505][505];\nLL cp[505][505], cq[505][505];\nLL dp[2][505][505];\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) rep(j, n)\n\tif(i != j) scanf(\"%d\", &a[i][j]);\n\t\n\trep(i, n) rep(j, n)\n\tif(i < j) cp[i][j] = cp[i][j - 1] + a[i][j];\n\t\n\trep(i, n) for(int j = n - 1; j >= 0; j --)\n\tif(j > i) cq[i][j - 1] = cq[i][j] + a[j][i];\n\t\n\t//左开右闭\n\tmemset(dp[(n - 1) & 1], INF, sizeof(dp[(n - 1) & 1]));\n\tdp[(n - 1) & 1][n - 1][n - 1] = cp[n - 1][n - 1] + cq[n - 1][n - 1];\n\t\n\tfor(int i = n - 2; i >= 0; i --) {\n\t\tint ori = !(i & 1), nw = i & 1;\n\t\tmemset(dp[nw], INF, sizeof(dp[nw]));\n\t\tfor(int j = i; j < n; j ++) for(int k = j; k < n; k ++)\n\t\tdp[nw][j][k] = min(dp[nw][j][k], dp[ori][j][k] + cp[i][j] + cq[i][k]);\n\t\tfor(int j = i; j < n; j ++) {\n\t\t\tLL cans = INF;\n\t\t\tfor(int k = j; k < n; k ++) cans = min(cans, dp[ori][j][k]);\n\t\t\tfor(int k = j; k >= i; k --) dp[nw][k][j] = min(dp[nw][k][j], cans + cp[i][k] + cq[i][j]);\n\t\t}\n\t}\n\t\n\tLL ans = INF;\n\trep(i, n) for(int j = i; j < n; j ++)\n\tans = min(ans, dp[0][i][j]);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N, A[510][150];\nll S1[510][510], S2[510][510];\nll dp[510][510];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<=N;j++) if(i != j) scanf(\"%d\", A[i] + j);\n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tS1[i][i] = 0;\n\t\tfor(int j=i+1;j<=N;j++) {\n\t\t\tS1[i][j] = S1[i][j-1];\n\t\t\tfor(int k=i;k<j;k++) {\n\t\t\t\tS1[i][j] += A[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) {\n\t\tfor(int j=1;j<i;j++) {\n\t\t\tS2[i][j] = S2[i][j-1] + A[i][j];\n\t\t}\n\t}\n\trep(i, 510) rep(j, 510) dp[i][j] = 1e18;\n\tfor(int i=1;i<=N;i++) {\n\t\tdp[1][i] = S1[1][i];\n\t\tfor(int k=1;k<i;k++) {\n\t\t\tll sum = 0;\n\t\t\tfor(int j=i;j>k;j--) {\n\t\t\t\tsum += S2[j][k-1];\n\t\t\t\tdp[j][i] = min(dp[j][i], dp[k][j-1] + S1[j][i] + sum);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 1e18;\n\tfor(int i=1;i<=N;i++) ans = min(ans, dp[i][N]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\nvoid read(pp& x){ scanf(\"%d%d\",&x.first, &x.second); }\nvoid read(pll& x){ scanf(\"%lld%lld\",&x.first, &x.second); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\nvoid cppio(){ ios_base::sync_with_stdio(0); cin.tie(0); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define sz(x) (int)(x).size()\n\nconst int maxn = 510;\nint n;\nint cost[maxn][maxn];\n\nll dp[maxn][maxn];\n\nll cp[maxn][maxn];\nll gp[maxn][maxn];\n\nint main()\n{\n\tcppio();\n\tcin >> n;\n\trrep(i, n) rrep(j, n) if(i != j) cin >> cost[i][j];\n\n\trrep(i, n) rrep(j, n)\n\t\tcp[i][j] = cp[i-1][j] + cp[i][j-1] - cp[i-1][j-1] + cost[i][j];\n\n\trrep(i, n) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tgp[i][j] = gp[i][j-1];\n\t\t\tfor(int k=i; k<j; ++k) {\n\t\t\t\tgp[i][j] += cost[k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(dp, 0x7f, sizeof(dp));\n\n\tfor(int i=2; i<=n; ++i)\n\t\tdp[1][i] = gp[1][i];\n\n\tfor(int i=2; i<=n; ++i)\n\t\tdp[1][i] = gp[1][i];\n\n\tauto rect = [&](int l, int r, int d, int u) -> ll {\n\t\tif(l>r || d>u) return 0;\n\t\treturn cp[r][u] - cp[l-1][u] - cp[r][d-1] + cp[l-1][d-1];\n\t};\n\n\trrep(l, n) {\n\t\tfor(int r=l; r<=n; ++r) {\n\t\t\tfor(int R=r+1; R<=n; ++R) {\n\t\t\t\tdp[r+1][R] = min(dp[r+1][R],\n\t\t\t\t\tdp[l][r] + gp[r+1][R] +\n\t\t\t\t\t\trect(r+1, R, 1, l-1));\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 1ll << 60;\n\trrep(i, n) ans = min(ans, dp[i][n]);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  auto d = make_higher_vector<3, lint>(n, n + 1, n + 1, -1);\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      at(d, j, k, 0) = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        auto crr = at(d, j, k, i);\n        at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        auto crr = at(dp, i, j);\n        if (crr == inf) continue;\n        auto val_1 = at(c, j, k);\n        auto val_2 = at(d, j, k, i);\n        assert(val_1 != -1);\n        assert(val_2 != -1);\n        cmn(at(dp, j, k), crr + val_1 + val_2);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nclass stopwatch\n{\npublic:\n    stopwatch() : start{std::chrono::system_clock::now()}, rap_point{start} {}\n    template<typename Duration = std::chrono::milliseconds>\n    int64_t rap()\n    {\n        const auto now   = std::chrono::system_clock::now();\n        const auto cnt   = std::chrono::duration_cast<Duration>(now - rap_point).count();\n        return rap_point = now, cnt;\n    }\n    template<typename Duration = std::chrono::milliseconds>\n    int64_t total()\n    {\n        const auto now = std::chrono::system_clock::now();\n        const auto cnt = std::chrono::duration_cast<Duration>(now - start).count();\n        return cnt;\n    }\n\nprivate:\n    std::chrono::system_clock::time_point start;\n    std::chrono::system_clock::time_point rap_point;\n};\nconstexpr int NMAX = 500;\nll fass[NMAX][NMAX];\nll bass[NMAX][NMAX];\nll fsss[NMAX][NMAX];\nll bsss[NMAX][NMAX];\nll dp[NMAX + 1][NMAX + 1];\nint main()\n{\n    stopwatch sw;\n    auto N    = in<int>();\n    ll btotal = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) { fsss[i][j] = fass[i][j], bsss[i][j] = bass[i][j]; }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) { fsss[i][j] += fsss[i][j - 1], bsss[i][j] += bsss[i][j - 1]; }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) { fsss[i][j] += fsss[i - 1][j], bsss[i][j] += bsss[i - 1][j]; }\n    }\n    auto sum  = [&](const auto sss, const int il, const int iu, const int jl, const int ju) { return sss[iu - 1][ju - 1] - (il == 0 ? 0LL : sss[il - 1][ju - 1]) - (jl == 0 ? 0LL : sss[iu - 1][jl - 1]) + (il == 0 or jl == 0 ? 0LL : sss[il - 1][jl - 1]); };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    for (int np = 0; np <= N; np++) {\n        for (int p = 0; p < np; p++) {\n            ll min = inf_v<ll>;\n            for (int pp = 0; pp <= p; pp++) {\n                const ll fore = fsum(pp, p, np);\n                const ll back = bsum(pp, p, np);\n                chmin(min, fore + back + dp[pp][p]);\n            }\n            dp[p][np] = min;\n        }\n    }\n    ll ans = inf_v<ll>;\n    for (int p = 0; p <= N; p++) { chmin(ans, dp[p][N]); }\n    outln(ans + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nconst Int MAX = 505;\nconst Int INF = 1e18;\nInt dp[MAX][MAX][MAX];\n\nInt A[MAX][MAX];\n\n// S[j][i] = sum_{k=i}^{j-1} A[j][i]\n// T[i][k] = sum_{k=1}^{j}   A[i][k]\n\nInt S[MAX][MAX];\nInt T[MAX][MAX];\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n;\n  cin>>n;\n  for(Int i=1;i<=n;i++)\n    for(Int j=1;j<=n;j++)\n      if(i!=j) cin>>A[i][j];\n\n  for(Int i=1;i<=n;i++){\n    for(Int j=0;j<=n;j++)\n      for(Int p=i-1;p>j;p--)\n        S[j][i]+=A[p][i];\n\n    for(Int k=0;k<=n;k++)\n      for(Int q=k;q>0;q--)\n        T[i][k]+=A[i][q];\n  }\n\n  dp[1][0][0]=0;\n  // k <= j <= i\n  for(Int ni=2;ni<=n;ni++){\n    for(Int nj=0;nj==0 or nj<ni;nj++){\n      for(Int nk=0;nk==0 or nk<nj;nk++){\n        dp[ni][nj][nk]=INF;\n\n        Int pi=ni-1;\n        for(Int pj=nk;pj==0 or pj<=min(nj,pi-1);pj++)\n          for(Int pk=0;pk==0 or pk<=min(nk,pj-1);pk++)\n            if(pj<nj and nk!=pj) continue;\n            else chmin(dp[ni][nj][nk],dp[pi][pj][pk]+S[nj][ni]+T[ni][nk]);\n\n        // cout<<ni<<\" \"<<nj<<\" \"<<nk<<\":\"<<dp[ni][nj][nk]<<endl;\n      }\n    }\n  }\n\n  Int ans=INF;\n  for(Int j=0;j<n;j++)\n    for(Int k=0;k<j;k++)\n      chmin(ans,dp[n][j][k]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=505;\nconst ll inf=1e15;\n\nint n,a[N][N];\nll f[N][N];\n\nstruct Sum{\n\tll a[N][N];\n\tvoid build() {fo(i,1,n) fo(j,1,n) a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];}\n\tll query(int lx,int rx,int ly,int ry) {return a[rx][ry]-a[lx-1][ry]-a[rx][ly-1]+a[lx-1][ly-1];}\n}s0,s1;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) fo(j,1,n) if (i!=j) scanf(\"%d\",&a[i][j]);\n\tfo(i,1,n) fo(j,i+1,n) s0.a[i][j]=a[i][j];\n\tfo(i,1,n) fo(j,1,i-1) s1.a[i][j]=a[i][j];\n\ts0.build();s1.build();\n\tfo(i,0,n) fo(j,0,i) f[i][j]=inf;\n\tf[0][0]=0;\n\tfo(i,0,n) fo(j,0,i) fo(k,i+1,n) f[k][i]=min(f[k][i],f[i][j]+s0.query(i+1,k,i+1,k)+s1.query(k+1,n,j+1,i));\n\tll ans=inf;\n\tfo(i,0,n) ans=min(ans,f[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll inf = (1LL << 60);\n\nint n;\nll a[600][600], sp[600][600], sn[600][600], dp[600][600];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++) {\n      if (j == i)\n        continue;\n      cin >> a[i][j];\n    }\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < i; j++)\n      sp[i][j + 1] = sp[i][j] + a[n - j - 1][n - i - 1];\n  for (int i = 0; i < n; i++)\n    for (int j = i; j > 0; j--)\n      sn[i][j - 1] = sn[i][j] + a[n - i - 1][n - j - 1];\n  dp[0][0] = 0;\n  for (int i = 1; i < n; i++) {\n    for (int j = 0; j <= i; j++) {\n      dp[i][j] = inf;\n      for (int k = 0; k <= j; k++)\n        dp[i][j] = min(dp[i][j], dp[i - 1][k] + sp[i][j] + sn[i][j]);\n      // cerr << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n    }\n  }\n  ll res = inf;\n  for (int i = 0; i < n; i++)\n    res = min(res, dp[n - 1][i]);\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL MOD = 998244353;\nconst int N = 505;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n,x,a[N][N];\nLL s1[N][N], s2[N][N], dp[N][N];\n\nint main(){\n\t//freopen(\"test.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\trep(i,1,n)rep(j,1,n-1){\n\t\tscanf(\"%d\",&x);\n\t\ta[i][j+(j>=i)]=x;\n\t}\n\t\n\trep(i,1,n){\n\t\tLL sum1 = 0, sum2 = 0;\n\t\trep(j,i,n){\n\t\t\tsum1 += a[i][j], sum2 += a[j][i];\n\t\t\ts1[i][j] = s1[i-1][j] + sum1;\n\t\t\ts2[i][j] = s2[i-1][j] + sum2;\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<s1[i][j]<<\" \"<<s2[i][j]<<endl;\n\t\t} \n\t}\n\t\n\trep(i,0,n+1)rep(j,0,n+1)dp[i][j]=1e18;\n\trep(i,2,n)dp[i][1] = s1[i-1][i-1];\n\trep(i,2,n)rep(j,1,i-1)rep(x,i+1,n){\n\t\tLL sum1 = s1[x-1][x-1] - s1[i-1][x-1];\n\t\tLL sum2 = s2[i-1][n] - s2[j-1][n] - s2[i-1][x-1] + s2[j-1][x-1];\n\t\tdp[x][i] = min(dp[x][i], dp[i][j] + sum1 + sum2);\n\t\t//cout<<x<<\" \"<<i<<\" \"<<j<<\" \"<<dp[x][i]<<endl;//<<sum1<<\" \"<<sum2<<endl;\n\t}\n\tLL ans = s1[n][n];\n\trep(i,2,n)rep(j,1,i-1) ans = min(ans, dp[i][j]+s1[n][n]-s1[i-1][n]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nconst int maxN = 505;\n\nint n;\nLL f[maxN + 1][maxN + 1], A[maxN + 1][maxN + 1], s1[maxN + 1][maxN + 1], s2[maxN + 1][maxN + 1];\n\ninline LL read()\n{\n\tLL num = 0, f = 1;\n\tchar ch = getchar();\n\twhile( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }\n\twhile( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();\n\treturn num * f;\n}\n\ninline LL query(int xu, int yu, int xd, int yd, LL sum[maxN + 1][maxN + 1])\n{\n\treturn sum[xd][yd] - sum[xu - 1][yd] - sum[xd][yu - 1] + sum[xu - 1][yu - 1];\n}\n\nint main()\n{\n\n\tn = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t{\n\t\t\tif(i != j) A[i][j] = read();\n\t\t\ts1[i][j] = s1[i - 1][j] + s1[i][j - 1] - s1[i - 1][j - 1];\n\t\t\ts2[i][j] = s2[i - 1][j] + s2[i][j - 1] - s2[i - 1][j - 1];\n\t\t\tif(i < j) s1[i][j] += A[i][j];\n\t\t\tif(i > j) s2[i][j] += A[i][j];\n\t\t}\n\t\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tf[i][0] = query(1, 1, i + 1, i, s2);\n\t\tfor(int j = 0; j < i; j++)\n\t\t{\n\t\t\tf[i][i] = max(f[i][i], f[i - 1][j] + query(i + 1, j + 1, i + 1, i, s2) + query(1, i + 1, i, i + 1, s1));\n\t\t\tfor(int k = 0; k < j; k++)\n\t\t\t\tf[i][j] = max(f[i][j], f[j - 1][k] + query(j + 1, k + 1, i + 1, i, s2) + query(1, j + 1, j, i + 1, s1));\n\t\t}\n\t}\n\n\tLL ans = 0;\n\tfor(int i = 0; i <= n - 1; i++) ans = max(ans, f[n - 1][i]);\n\tprintf(\"%lld\", s1[n][n] + s2[n][n] - ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nconst Int MAX = 505;\nconst Int INF = 1e18;\nInt A[MAX][MAX];\nInt dp[MAX][MAX];\n\nInt X[MAX][MAX];\nInt Y[MAX][MAX];\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n;\n  cin>>n;\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      if(i!=j) cin>>A[i][j];\n\n  memset(X,0,sizeof(X));\n  for(Int k=1;k<n;k++){\n    for(Int i=0;i<k;i++){\n      if(i) X[k][i]=X[k][i-1];\n      Int a=i;\n      for(Int b=k+1;b<n;b++)\n        X[k][i]+=A[b][a];\n    }\n  }\n\n  memset(Y,0,sizeof(Y));\n  for(Int k=1;k<n;k++){\n    for(Int i=k-1;i>=0;i--){\n      Y[k][i]=Y[k][i+1];\n      Int a=i;\n      for(Int b=a+1;b<=k;b++)\n        Y[k][i]+=A[a][b];\n    }\n  }\n\n  for(Int i=0;i<MAX;i++)\n    for(Int j=0;j<MAX;j++)\n      dp[i][j]=INF;\n\n  for(Int k=1;k<n;k++)\n    for(Int i=0;i<k;i++)\n      dp[k][i]=X[k][i]+Y[k][i+1]+Y[i][0];\n\n  for(Int i=0;i+1<n;i++)\n    for(Int j=0;j<i;j++)\n      for(Int k=i+1;k+1<n;k++)\n        chmin(dp[k][i],dp[i][j]+(X[k][i]-X[k][j])+Y[k][i+1]);\n\n  Int ans=INF;\n  for(Int k=0;k+1<n;k++){\n    Int tmp=0;\n    for(Int a=0;a<n;a++)\n      for(Int b=a+1;b<n;b++)\n        if(a<=k and k<b) continue;\n        else tmp+=A[a][b];\n    chmin(ans,tmp);\n  }\n\n  for(Int i=0;i+1<n;i++)\n    for(Int j=0;j<i;j++)\n      chmin(ans,dp[i][j]+Y[n-1][i+1]);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=500;\nconst LL INF=(1LL<<50)-1;\n\nint n,a[N+9][N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tfor (int j=1;j<=n;++j)\n\t  if (i^j) scanf(\"%d\",&a[i][j]);\n}\n\nLL sum[N+9][N+9][2];\n\nvoid Get_sum(){\n  for (int i=1;i<=n;++i){\n\tfor (int j=1;j<=n;++j){\n\t  if (i^j) i<j?sum[i][j][0]=a[i][j]:sum[i][j][1]=a[i][j];\n\t  for (int k=0;k<2;++k) sum[i][j][k]+=sum[i][j-1][k];\n\t}\n    for (int j=1;j<=n;++j)\n\t  for (int k=0;k<2;++k) sum[i][j][k]+=sum[i-1][j][k];\n  }\n}\n\nLL Get_sum(int id,int x0,int y0,int x1,int y1){return sum[x1][y1][id]-sum[x1][y0-1][id]-sum[x0-1][y1][id]+sum[x0-1][y0-1][id];}\n\nLL dp[N+9][N+9],ans;\n\nvoid Get_dp(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=n;++j) dp[i][j]=INF;\n  dp[0][0]=0;\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<max(i,1);++j)\n\t  for (int k=i+1;k<=n;++k){\n\t\tLL t=dp[i][j]+Get_sum(1,k+1,j+1,n,i)+Get_sum(0,i+1,i+1,k,k);\n\t\tdp[k][i]=min(dp[k][i],t);\n\t  }\n  ans=INF;\n  for (int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n}\n\nvoid work(){\n  Get_sum();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 8/11/2019, 8:49:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\nconstexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nint N;\nll A[510][510];\nll dp[510][510];\nll sum0[510][510];\nll sum1[510][510];\n\nint main()\n{\n  cin >> N;\n  for (auto i = 1; i <= N; i++)\n  {\n    for (auto j = 1; j <= N; j++)\n    {\n      if (i == j)\n      {\n        continue;\n      }\n      cin >> A[i][j];\n    }\n  }\n  for (auto j = 0; j <= N; j++)\n  {\n    for (auto x = 0; x <= N; x++)\n    {\n      for (auto y = j + 1; y <= x - 1; y++)\n      {\n        sum0[j][x] += A[y][x];\n      }\n#if DEBUG == 1\n      cerr << \"sum0[\" << j << \"][\" << x << \"] = \" << sum0[j][x] << endl;\n#endif\n    }\n  }\n  for (auto x = 0; x <= N; x++)\n  {\n    for (auto i = 0; i < x; i++)\n    {\n      for (auto y = 1; y <= i; y++)\n      {\n        sum1[i][x] += A[x][y];\n      }\n#if DEBUG == 1\n      cerr << \"sum1[\" << i << \"][\" << x << \"] = \" << sum1[i][x] << endl;\n#endif\n    }\n  }\n  fill(&dp[0][0], &dp[0][0] + 510 * 510, infty);\n  dp[0][0] = 0;\n  for (auto j = 0; j < N; j++)\n  {\n    for (auto i = 0; i <= j; i++)\n    {\n      if (dp[i][j] == infty)\n      {\n        continue;\n      }\n      ll tmp0 = 0;\n      ll tmp1 = 0;\n      for (auto k = j + 1; k <= N; k++)\n      {\n        tmp0 += sum0[j][k];\n        tmp1 += sum1[i][k];\n        ll t = dp[i][j] + tmp0 + tmp1;\n#if DEBUG == 1\n        cerr << \"dp[\" << i << \"][\" << j << \"] = \" << dp[i][j] << \" -> dp[\" << j << \"][\" << k << \"] = \" << t << endl;\n#endif\n        mins(dp[j][k], t);\n      }\n    }\n  }\n  ll ans = infty;\n  for (auto i = 0; i < N; i++)\n  {\n    mins(ans, dp[i][N]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 505\ninline long long _c(long long x,long long y){return x<y?x:y;}\nint i,j,k,n;long long a[N][N],b[N][N],f[N][N],x;\ninline long long _a(int o,int p,int u,int v){return a[p][v]-a[p][u]-a[o][v]+a[o][u];}\ninline long long _b(int o,int p,int u,int v){return b[p][v]-b[p][u]-b[o][v]+b[o][u];}\nint main()\n{\n    scanf(\"%d\",&n),x=0x3f3f3f3f3f3f3f3fll;\n    for(i=1;i<=n;i++)for(j=1;j<=n;a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1],b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1],f[i][j++]=x)i!=j?i<j?scanf(\"%lld\",a[i]+j):scanf(\"%lld\",b[i]+j):0;\n    for(i=1;i<=n;i++)f[0][i]=_a(0,i,0,i);\n    for(i=1;i<n;i++)for(j=i+1;j<=n;j++)for(k=0;k<i;k++)f[i][j]=_c(f[i][j],f[k][i]+_a(i,j,i,j)+_b(i,j,0,k));\n    for(i=0;i<n;i++)x=_c(x,f[i][n]);\n    return 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 500\n#define ll long long\n#define INF 1000000000000000000LL\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n;\nll a[MN+5][MN+5],f[MN+5][MN+5],g[MN+5][MN+5],tot,b[MN+5][MN+5],c[MN+5][MN+5],ans=-INF;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)\n    {\n        if(i!=j) a[i][j]=read();\n        if(i>j) tot+=a[i][j];\n        f[i][j]=g[i][j]=-INF;\n    }\n    for(int i=n;i;--i) for(int j=i;j<=n;++j) \n        b[i][j]=b[i][j-1]+b[i+1][j]-b[i+1][j-1]+a[i][j],\n        c[i][j]=c[i][j-1]+c[i+1][j]-c[i+1][j-1]+a[j][i];\n    for(int i=1;i<=n;++i) for(int j=i;j<=n;++j)\n    {\n        if(i==1) f[1][j]=max(f[1][j],c[1][j]-b[1][j]);\n        for(int k=j+1;k<=n;++k)\n            f[j+1][k]=max(f[j+1][k],f[i][j]-b[j+1][k]+c[i][k]-c[i][j]);\n    }\n    for(int i=1;i<=n;++i) ans=max(ans,f[i][n]);\n    cout<<tot-ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef long double ld;\n\nconst int inf = 1e9;\nconst ll inf64 = 1e18;\n\ninline void upd(ll &x, ll y) {\n    if (x > y) {\n        x = y;\n    }\n}\n\nconst int N = 505;\n\ninline ll get_sum(int li, int lj, int ri, int rj, ll arr[N][N]) {\n    if (li > ri || lj > rj) return 0;\n    ll res = 0;\n    res += arr[ri][rj];\n    if (li > 0) res -= arr[li - 1][rj];\n    if (lj > 0) res -= arr[ri][lj - 1];\n    if (li > 0 && lj > 0) res += arr[li - 1][lj - 1];\n    return res;\n}\n\nint n;\nint a[N][N];\nll col[N][N];\nll str[N][N];\nll dp[2][N][N];\nll R[N][N];\nll L[N][N];\n\nll slow() {\n    int tot = 1 << (n - 1);\n    ll result = inf64;\n    for (int mask = 0; mask < tot; mask++) {\n        vector<ll> pref(n);\n        for (int i = 0; i + 1 < n; i++) {\n            pref[i + 1] = pref[i];\n            if ((1 << i) & mask) {\n                pref[i + 1]++;\n            }\n        }\n        ll tmp = 0;\n        for (int fr = 0; fr < n; fr++) {\n            for (int to = 0; to < n; to++) {\n                if (fr == to) {\n                    continue;\n                }\n                if (fr < to && pref[to] - pref[fr] < 1) {\n                    tmp += a[fr][to];\n                }\n                if (fr > to && pref[fr] - pref[to] > 1) {\n                    tmp += a[fr][to];\n                }\n            }\n        }\n        for (int i = 0; i + 1 < n; i++) {\n            cout << ((mask >> i) & 1);\n        }\n        cout << \" : \" << tmp << \"\\n\";\n        upd(result, tmp);\n    }\n    return result;\n}\n\nll fast() {\n    ll result = inf64;\n\n    {\n        ll tmp = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                tmp += a[i][j];\n            }\n        }\n        upd(result, tmp);\n    }\n\n    {\n        for (int i = 0; i + 1 < n; i++) {\n            ll tmp = 0;\n            for (int j = 0; j <= i; j++) {\n                for (int k = j + 1; k <= i; k++) {\n                    tmp += a[j][k];\n                }\n            }\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    tmp += a[j][k];\n                }\n            }\n            upd(result, tmp);\n        }\n    }\n\n    fill((ll*) dp, (ll*) dp + 2 * N * N, inf64);\n\n    dp[1][0][1] = a[2][0];\n\n    for (int i = 2; i + 1 < n; i++) {\n        fill((ll*) dp[i & 1], (ll*) dp[i & 1] + N * N, inf64);\n        for (int j = i - 1; j >= 0; j--) {\n            for (int k = j - 1; k >= 0; k--) {\n                upd(\n                        dp[i & 1][j][i],\n                        dp[(i - 1) & 1][k][j] + str[i + 1][j]\n                );\n                upd(\n                        dp[i & 1][k][j],\n                        dp[(i - 1) & 1][k][j]\n                        + (col[i][i + 1] - col[j][i + 1])\n                        + str[i + 1][k]\n                );\n            }\n        }\n        for (int j = i; j >= 0; j--) {\n            for (int k = j - 1; k >= 0; k--) {\n//                ll tmp = 0;\n//                for (int fr = 0; fr <= k; fr++) {\n//                    for (int to = fr; to <= k; to++) {\n//                        tmp += a[fr][to];\n//                    }\n//                }\n//                for (int fr = k + 1; fr <= j; fr++) {\n//                    for (int to = fr; to <= j; to++) {\n//                        tmp += a[fr][to];\n//                    }\n//                }\n//                for (int fr = j + 1; fr <= i + 1; fr++) {\n//                    for (int to = fr; to <= i + 1; to++) {\n//                        tmp += a[fr][to];\n//                    }\n//                }\n//                for (int fr = j + 1; fr <= i + 1; fr++) {\n//                    for (int to = k; to >= 0; to--) {\n//                        tmp += a[fr][to];\n//                    }\n//                }\n//                upd(dp[i][j][k], tmp);\n                upd(\n                    dp[i & 1][k][j],\n                    get_sum(0, 0, k, k, R)\n                    + get_sum(k + 1, k + 1, j, j, R)\n                    + get_sum(j + 1, j + 1, i + 1, i + 1, R)\n                    + get_sum(j + 1, 0, i + 1, k, L)\n                );\n            }\n        }\n    }\n\n    for (int k = 0; k + 1 < n; k++) {\n        for (int j = k + 1; j + 1 < n; j++) {\n            upd(result, dp[(n - 2) & 1][k][j]);\n        }\n    }\n\n    return result;\n}\n\nvoid test() {\n    ll fs = fast();\n    ll sl = slow();\n    if (fs != sl) {\n        cout << \"WA!\\n\";\n        cout << n << \"\\n\";\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                cout << a[i][j] << \" \";\n            }\n            cout << \"\\n\";\n        }\n        cout << \"expected: \" << sl << \"\\n\";\n        cout << \"found: \" << fs << \"\\n\";\n    } else {\n        cout << \"OK (\" << fs << \" == \" << sl << \")\\n\";\n    }\n}\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    mt19937_64 rnd(time(NULL));\n\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                continue;\n            }\n            cin >> a[i][j];\n            if (i < j) {\n                R[i][j] = a[i][j];\n            } else {\n                L[i][j] = a[i][j];\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j > 0) {\n                str[i][j] = str[i][j - 1];\n            }\n            str[i][j] += a[i][j];\n\n            if (i > 0) {\n                col[i][j] = col[i - 1][j];\n            }\n            col[i][j] += a[i][j];\n\n            if (i > 0) {\n                L[i][j] += L[i - 1][j];\n                R[i][j] += R[i - 1][j];\n            }\n            if (j > 0) {\n                L[i][j] += L[i][j - 1];\n                R[i][j] += R[i][j - 1];\n            }\n            if (i > 0 && j > 0) {\n                L[i][j] -= L[i - 1][j - 1];\n                R[i][j] -= R[i - 1][j - 1];\n            }\n        }\n    }\n\n//    test();\n//    slow();\n    cout << fast() << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500;\n\nint n, a[maxn][maxn];\nlong long from[maxn][maxn], to[maxn][maxn], dp[2][maxn][maxn], ans;\n\nvoid cmin(long long &x, long long y) { x = min(x, y); }\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) if (j != i) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tfrom[i][j] = (j?from[i][j-1]:0) + a[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tto[i][j] = (j?to[i][j-1]:0) + a[j][i];\n\t\t}\n\t}\n\tmemset(dp[0], 0x3f, sizeof(dp[0]));\n\tans = dp[0][0][0];\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tmemset(dp[i&1^1], 0x3f, sizeof(dp[0]));\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = 0; k <= j; ++k) {\n\t\t\t\tcmin(dp[i&1^1][j][k], dp[i&1][j][k]+(to[i+1][i]-(j?to[i+1][j-1]:0))+(k?from[i+1][k-1]:0));\n\t\t\t\tcmin(dp[i&1^1][i+1][j], dp[i&1][j][k]+(j?from[i+1][j-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < n; ++j)\n\t\tfor (int k = 0; k <= j; ++k)\n\t\t\tcmin(ans, dp[n&1^1][j][k]);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nll a[555][555];\nll pr[555][555];\nll pl[555][555];\n\nll suml(int r, int al, int ar)\n{\n\tal=max(al,0);\n\tif(al==0) return pl[r][ar];\n\treturn pl[r][ar]-pl[r][al-1];\n}\n\nll sumr(int r, int al, int ar)\n{\n\tal=max(al,0);\n\tif(al==0) return pr[r][ar];\n\treturn pr[r][ar]-pr[r][al-1];\n}\n\nll dp[2][511][511];\n\nvoid amin(ll &x, ll y)\n{\n\tif(y<x) x=y;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tpl[i][j]=a[j][i];\n\t\t\tif(j>0) pl[i][j]+=pl[i][j-1];\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tpr[i][j]=a[i][j];\n\t\t\tif(j>0) pr[i][j]+=pr[i][j-1];\n\t\t}\n\t}\n\tconst ll INF = ll(1e18);\n\tdp[1][0][0]=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint cur=(i+1)&1; int pre=(cur^1);\n\t\tfor(int i=0;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tdp[cur][i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<=i-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\t{\n\t\t\t\tll ans = dp[pre][j][k];\n\t\t\t\tif(ans>=INF) continue;\n\t\t\t\t//cerr<<\"DP \"<<i<<' '<<j<<' '<<k<<'\\n';\n\t\t\t\t//cerr<<i+1<<' '<<j<<' '<<k<<' '<<ans+suml(i,j,i-1)+sumr(i,0,k-1)<<'\\n';\n\t\t\t\t//cerr<<i+1<<' '<<i<<' '<<j<<' '<<ans+sumr(i,0,j-1)<<'\\n';\n\t\t\t\tamin(dp[cur][j][k],ans+suml(i,j,i-1)+sumr(i,0,k-1)); //extend\n\t\t\t\tamin(dp[cur][i][j],ans+sumr(i,0,j-1));\n\t\t\t}\n\t\t}\n\t}\n\tll ans = INF;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tamin(ans,dp[n&1][i][j]);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\n\tconst int N = 505;\n\tconst ll INF = 0x3f3f3f3f3f3f3f3fLL;\n\n\tll A[N][N], S1[N][N], S2[N][N], F[N][N];\n\n\tinline int read()\n\t{\n\t\tint x = 0, f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tinline ll Q(const int x1, const int x2, const int y1, const int y2)\n\t{\n\t\tif (x1 > x2 || y1 > y2)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn S2[x2][y2] - S2[x1 - 1][y2] - S2[x2][y1 - 1] + S2[x1 - 1][y1 - 1];\n\t}\n\n\tvoid work()\n\t{\n\t\tint n = read();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfor (int j = 1, v; j <= n; j++)\n\t\t\t{\n\t\t\t\tv = i == j ? 0 : read();\n\t\t\t\tA[i][j] = A[i][j - 1] + v;\n\t\t\t\tS2[i][j] = S2[i - 1][j] + S2[i][j - 1] + v - S2[i - 1][j - 1];\n\t\t\t}\n\t\tfor (int a = 1; a <= n; a++)\n\t\t\tfor (int b = a; b <= n; b++)\n\t\t\t\tfor (int i = a; i <= b; i++)\n\t\t\t\t\tS1[a][b] += A[i][b] - A[i][i];\n\t\tmemset(F, 0x3f, sizeof(F));\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tF[i][0] = S1[1][i];\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tfor (int j = 0; j < i; j++)\n\t\t\t\tif (F[i][j] != INF)\n\t\t\t\t\tfor (int k = i + 1; k <= n; k++)\n\t\t\t\t\t\tF[k][i] = min(F[k][i], F[i][j] + S1[i + 1][k] + Q(k + 1, n, j + 1, i));\n\t\tll ans = INF;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tans = min(ans, F[n][i]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// the distance functions are in blocks\n// forward edges only to future blocks\n// backwards edges only to self & immediate predecessor\n\nusing ll = long long;\n\nconst int MAXN = 600;\nint N;\nll A[MAXN][MAXN];\n\nll backPref[MAXN][MAXN];\nll forwPref[MAXN][MAXN];\n\nll dp[MAXN][MAXN]; // max value we can save\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (j == i) A[i][j] = 0;\n\t\t\telse cin >> A[i][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tif (i < j) {\n\t\t\t\tforwPref[i+1][j+1] = A[i][j];\n\t\t\t} else {\n\t\t\t\tbackPref[i+1][j+1] = A[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tforwPref[i+1][j+1] += forwPref[i][j+1] + forwPref[i+1][j] - forwPref[i][j];\n\t\t\tbackPref[i+1][j+1] += backPref[i][j+1] + backPref[i+1][j] - backPref[i][j];\n\t\t}\n\t}\n\n\tfor (int j = 1; j < N; j++) {\n\t\t// back [0,j) by [0,j)\n\t\t// no forwards\n\t\tdp[0][j] = backPref[j][j];\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = i+1; j <= N; j++) {\n\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\t// back [i,j) by [k,j)\n\t\t\t\t// forwards [0,i) by [i,j)\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[k][i]\n\t\t\t\t\t\t+ (backPref[j][j] - backPref[i][j] - backPref[j][k] + backPref[i][k])\n\t\t\t\t\t\t+ (forwPref[i][j] - forwPref[0][j] - forwPref[i][i] + forwPref[0][i])\n\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tans = max(ans, dp[i][N]);\n\t}\n\n\tans = -ans;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j) continue;\n\t\t\tans += A[i][j];\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 505\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nint a[maxn][maxn];\nll f[maxn][maxn],g[maxn][maxn];\nll dp[maxn][maxn];\nll calc(int i,int j,int k)\n{\n    return f[k][j]-f[k][i-1];\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n        if(i!=j)  a[i][j]=read();\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            f[i][j]=f[i][j-1];\n            for(int k=i;k<=n;k++)  f[i][j]+=a[k][j];\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i;j<=n+1;j++)\n        {\n            g[i][j]=g[i][j-1];\n            for(int k=i;k<=j;k++)  g[i][j]+=a[k][j];\n        }\n    }\n    memset(dp,0x3f,sizeof(f));\n    dp[0][0]=0;\n    for(int i=0;i<=n;i++)\n    {\n        for(int j=i;j<=n;j++)\n        {\n            if(dp[i][j]<1e18)\n            {\n                for(int k=j+1;k<=n+1;k++)\n                {\n                    dp[j][k]=min(dp[j][k],dp[i][j]+g[j+1][k]+calc(i+1,j,k+1));\n                }\n            }\n        }\n    }\n    ll ans=1e18;\n    for(int i=0;i<=n;i++)  ans=min(ans,dp[i][n+1]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (510)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,a[N][N]; LL f[N][N],suf[N][N],sum[N][N],ans;\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<n;j++)read(a[i][j+(j>=i)]);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=n;j>i;j--){\n\t\tsuf[i][j]=suf[i][j+1];\n\t\tfor(int k=1;k<=i;k++)suf[i][j]+=a[j][k];\n\t}\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=i+1;j<=n+1;j++){\n\t\tsum[i][j]=sum[i][j-1];\n\t\tfor(int k=i;k<j;k++)sum[i][j]+=a[k][j];\n\t}\n\tmemset(f,inf,sizeof(f)),ans=1e18,f[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\tfor(int j=i;j<=n;j++)\n\tfor(int k=j+1;k<=n+1;k++)\n\tf[j][k]=min(f[j][k],f[i][j]+sum[j+1][k]+suf[j][k+1]-suf[i][k+1]);\n\tfor(int i=0;i<=n;i++)ans=min(ans,f[i][n+1]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 502;\ntypedef long long ll;\nconst ll inf = 1e18;\n\nll n , A[N][N] , B[N][N] , dp[N][N] , ans = inf;\nll S(ll x[][N] , int l , int r , int lim) { return x[r][lim] - x[l - 1][lim]; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0) , cout.tie(0);\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = 1 ; j <= n ; ++j)\n            if(i < j) cin >> A[i][j];\n            else if(i > j) cin >> B[i][j];\n\n    for(int i = 1 ; i <= n ; ++i)\n        for(int j = 1 ; j <= n ; ++j) {\n            A[i][j] += A[i - 1][j] + A[i][j - 1] - A[i - 1][j - 1];\n            B[i][j] += B[i - 1][j] + B[i][j - 1] - B[i - 1][j - 1];\n        }\n    \n    for(int i = 1 ; i < n ; ++i) {\n        dp[i][0] = A[i][i];\n        for(int j = 1 ; j < i ; ++j) {\n            dp[i][j] = inf;\n            for(int k = 0 ; k < j ; ++k)\n                dp[i][j] = min(dp[i][j] , dp[j][k] + S(A , j + 1 , i , i) + S(B , j + 1 , i , k));\n        }\n        for(int j = 0 ; j < i ; ++j)\n            ans = min(ans , dp[i][j] + S(A , i + 1 , n , n) + S(B , i + 1 , n , j));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nll sum[501][501];\nll dp[502][502];\nll cop[502][502];\n\nll sum2[501][501];\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<ll>> a(n);\n\trep(i, n) {\n\t\ta[i].resize(n);\n\t\trep(j, n) {\n\t\t\tif (i == j)a[i][j] = 0;\n\t\t\telse cin >> a[i][j];\n\t\t}\n\t}\n\n\t//calc sum\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ts += a[k][j];\n\t\t\t}\n\t\t\tsum[i][j] = s;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tll s = 0;\n\t\tfor (int j = n - 1; j >= i; j--) {\n\t\t\tsum2[i][j] = s;\n\t\t\ts += a[j][i];\n\t\t}\n\t}\n\n\trep(i, n + 1)rep(j, n + 1)dp[i][j] = INF;\n\tdp[0][0] = 0;\n\t{\n\t\tll s = 0;\n\t\tfor (int j = n-1; j>0; j--) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tdp[j][k] = s + sum[0][k] + sum[k + 1][j];\n\t\t\t}\n\n\t\t\ts += a[j][0];\n\t\t}\n\t}\n\tfor (int i = 1; i < n-1; i++) {\n\t\trep(j, n + 1)rep(k, n + 1)cop[j][k] = INF;\n\n\t\tfor (int k = i; k < n; k++) {\n\t\t\tll mi = INF;\n\t\t\tfor (int l = k; l <n; l++) {\n\t\t\t\tmi = min(mi, dp[l][k] - sum[k + 1][l]);\n\t\t\t\tcop[l][k] = sum2[i][l] + sum[k + 1][l] + mi;\n\t\t\t}\n\t\t}\n\t\tll mi = INF;\n\t\tfor (int m = i; m < n; m++) {\n\t\t\tmi = min(mi, dp[m][i - 1] - sum[i][m]);\n\t\t\tfor (int l = m; l < n; l++) {\n\t\t\t\tcop[l][m] = min(cop[l][m], sum2[i][l] + sum[i][m] + sum[m + 1][l] + mi);\n\t\t\t}\n\t\t}\n\t\trep(j, n + 1)rep(k, n + 1)dp[j][k]=cop[j][k];\n\n\t}\n\tll ans = INF;\n\trep(i, n+1)rep(j, n+1)ans = min(ans, dp[i][j]);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\n\nint n;\nlong long f[1003][1003], s[2][1003][1003];\nlong long qry0(int i, int j) { return s[0][n][i] - s[0][j][i]; }\nlong long qry1(int i, int j, int k) {\n    return s[1][n][j] - s[1][n][k] - s[1][i][j] + s[1][i][k];\n}\nint main() {\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i < j)\n                s[0][i][j] = read();\n            else if (i > j)\n                s[1][i][j] = read();\n\n    n += 2;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) {\n            s[0][i][j] += s[0][i][j - 1] + s[0][i - 1][j] - s[0][i - 1][j - 1];\n            s[1][i][j] += s[1][i][j - 1] + s[1][i - 1][j] - s[1][i - 1][j - 1];\n        }\n\n    for (int i = 0; i <= n; ++i) f[i][0] = qry0(i, 0);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) {\n            f[i][j] = 10000000000000000ll;\n            for (int k = 0; k < j; ++k)\n                f[i][j] = min(f[i][j], f[j][k] + qry1(i, j, k));\n            f[i][j] += qry0(i, j);\n        }\n\n    printf(\"%lld\\n\", f[n][n - 1]);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reg register\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 505;\n\ninline ll read() {\n    reg ll s = 0, t = 0; reg char ch = getchar();\n    while (!isdigit(ch)) t |= ch == '-', ch = getchar();\n    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\n\nint n;\nll a[maxn][maxn];\nbool used[maxn][maxn];\n\nint main() {\n    n = read();\n    for (reg int i = 1; i <= n; i++) {\n        for (reg int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            a[i][j] = read();\n        }\n    }\n    memset(used, false, sizeof(used));\n    reg ll Ans = 0;\n    for (reg int tmp = 3; tmp <= n; tmp++) {\n        for (reg int i = 1; i <= n; i++) {\n            if (tmp + i - 1 > n) break;\n            reg int j = tmp + i - 1;\n            if (used[j][i]) continue;\n            reg ll sum = 0;\n            reg bool check = false;\n            for (reg int k = i + 1; k < j; k++) {\n                if (used[i][k] || used[k][j]) { check = true; break; }\n                sum += min(a[i][k], a[k][j]);\n            }\n            if (check) continue;\n            if (sum <= a[j][i]) {\n                for (reg int k = i + 1; k < j; k++) {\n                    if (a[i][k] <= a[k][j]) used[i][k] = true;\n                    else used[k][j] = true;\n                }\n            }\n            else used[j][i] = true;\n            Ans += min(sum, a[j][i]);\n        }\n    }\n    cout << Ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 505;\n\nint n;\nint a[MAXN][MAXN];\n\nll ans;\nll in[MAXN][MAXN];\nll out[MAXN][MAXN];\nll f[2][MAXN][MAXN];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 1;j <= n;j++)\n\t\t\tif (i != j)\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\tfor (int i = 1;i <= n;i++)\n\t\tfor (int j = 1;j < i;j++)\n\t\t{\n\t\t\tin[i][j] = in[i][j - 1] + a[j][i];\n\t\t\tout[i][j] = out[i][j - 1] + a[i][j];\n\t\t}\n\tfor (int i = 0;i < 2;i++)\n\t\tfor (int j = 0;j <= i;j++)\n\t\t\tfor (int k = 0;k <= j;k++)\n\t\t\t\tf[i][j][k] = 1e18;\n\tf[0][0][0] = 0;\n\tfor (int i = 0;i < n - 1;i++)\n\t{\n\t\tfor (int j = 0;j <= i + 1;j++)\n\t\t\tfor (int k = 0;k <= j;k++)\n\t\t\t\tf[~i & 1][j][k] = 1e18;\n\t\tfor (int j = 0;j <= i;j++)\n\t\t\tfor (int k = 0;k <= j;k++)\n\t\t\t\tif (f[i & 1][j][k] != 1e18)\n\t\t\t\t{\n\t\t\t\t\tf[~i & 1][j][k] = min(f[~i & 1][j][k],f[i & 1][j][k] + in[i + 2][i + 1] - in[i + 2][j] + out[i + 2][k]);\n\t\t\t\t\tf[~i & 1][i + 1][j] = min(f[~i & 1][i + 1][j],f[i & 1][j][k] + out[i + 2][j]);\n\t\t\t\t}\n\t}\n\tans = 1e18;\n\tfor (int i = 0;i <= n - 1;i++)\n\t\tfor (int j = 0;j <= i;j++)\n\t\t\tans = min(ans,f[~n & 1][i][j]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=500;\n\nint n;\nint cost[MAXN][MAXN];\n\nll dp[MAXN][MAXN]; // dp[i][j]=minimum cost when last group is [i..j]\n\nll sumforwardcost[MAXN][MAXN];\nll sumbackwardcost[MAXN][MAXN];\n\nll solve() {\n\tREP(i,n) FOR(j,i,n) { sumforwardcost[i][j]=0; FOR(k,i,j) sumforwardcost[i][j]+=cost[k][j]; if(i<j) sumforwardcost[i][j]+=sumforwardcost[i][j-1]; }\n\tREP(i,n) FOR(j,i,n) { sumbackwardcost[i][j]=0; FOR(k,i,j) sumbackwardcost[i][j]+=cost[j][k]; if(i<j) sumbackwardcost[i][j]+=sumbackwardcost[i][j-1]; }\n\n\tREP(i,n) REP(j,n) dp[i][j]=LLONG_MAX;\n\tREP(j,n) dp[0][j]=sumforwardcost[0][j];\n\tREP(i,n) FOR(j,i,n) if(dp[i][j]!=LLONG_MAX) {\n\t\tFOR(k,j+1,n) dp[j+1][k]=min(dp[j+1][k],dp[i][j]+sumforwardcost[j+1][k]+sumbackwardcost[i][n-1]-sumbackwardcost[i][k]-sumbackwardcost[j+1][n-1]+sumbackwardcost[j+1][k]);\n\t}\n\tll ret=LLONG_MAX; REP(i,n) ret=min(ret,dp[i][n-1]); return ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) REP(j,n) if(i==j) cost[i][j]=0; else scanf(\"%d\",&cost[i][j]);\n\tprintf(\"%lld\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 505\n#define ll long long\nint n;\nll ans;\nint a[M][M];\nll f[M][M],g[M][M],s[M][M],h[M][M];\nll get_s(int a,int b,int c,int d) {\n    return s[c][d]-s[c][b-1]-s[a-1][d]+s[a-1][b-1];\n}\nvoid work() {\n    for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++) s[i][j]=s[i-1][j]+a[i][j];\n    for(int j=1;j<=n;j++)\n\tfor(int i=1;i<=n;i++) s[i][j]+=s[i][j-1];\n    for(int i=1;i<n;i++)\n\tfor(int j=1;j+i<=n;j++) h[j][j+i]=h[j][j+i-1]+h[j+1][j+i]-h[j+1][j+i-1]+a[j][j+i];\n    for(int i=0;i<=n;i++)\n\tfor(int j=0;j<=n;j++) f[i][j]=1e18;\n    for(int i=1;i<n;i++)\n\t{\n\t    for(int j=0;j<=i;j++) g[j][i]=1e18;\n\t    for(int j=0;j<i;j++)\n\t\tfor(int k=j+1;k<i;k++) g[k][i]=min(g[k][i],f[j][k]+get_s(i+1,j+1,n,k)+h[k+1][i]);\n\t    for(int j=0;j<i;j++) f[j][i]=g[j][i];\n\t    f[0][i]=h[1][i];\n\t}\n    ans=1e18;\n    for(int i=0;i<n;i++)\n\tfor(int j=i+1;j<n;j++)\n\t    ans=min(ans,f[i][j]+h[j+1][n]);\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++) if(i!=j) cin>>a[i][j];\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 5e2 + 5;\nconst int mod = 1e9 + 7;\nint n , a[maxn][maxn];\nll dp[maxn][maxn];\nll sum[maxn][maxn];\nll sum1[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 1 ; j <= n ; ++j){\n            if(i != j)cin >> a[i][j];\n            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];\n            sum1[i][j] = sum1[i - 1][j] + sum1[i][j - 1] - sum1[i - 1][j - 1] + (i < j ? a[i][j] : 0);\n        }\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        dp[i][1] = sum1[i][i];\n        for(int j = 2 ; j <= i ; ++j){\n            dp[i][j] = 1e18;\n            for(int k = 1 ; k < j ; ++k){\n                dp[i][j] = min(dp[i][j] , dp[j - 1][k]\n                               + sum1[i][i] - sum1[i][j-1] - sum1[j - 1][i] + sum1[j-1][j-1]\n                               + sum[i][k - 1] - sum[j-1][k - 1]);\n//                cout << sum1[i][i] - sum1[i - 1][j] - sum1[i][j-1] + sum1[j-1][j-1] << endl;\n            }\n        }\n    }\n    cout << *min_element(dp[n]+1,dp[n]+n+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 500;\nllong a[N+3][N+3];\nllong s[2][N+3][N+3];\nllong dp[N+3][N+3];\nint n;\n\nvoid update(llong &x,llong y) {x = x<y?x:y;}\n\nllong getsum(int typ,int lx,int rx,int ly,int ry)\n{\n\treturn s[typ][rx][ry]-s[typ][lx-1][ry]-s[typ][rx][ly-1]+s[typ][lx-1][ly-1];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(j==i) continue;\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(i<j) {s[0][i][j] = a[i][j];}\n\t\t\ts[0][i][j] += s[0][i][j-1];\n\t\t}\n\t\tfor(int j=1; j<=n; j++) s[0][i][j] += s[0][i-1][j];\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=1; j<=n; j++)\n\t\t{\n\t\t\tif(i>j) {s[1][i][j] = a[i][j];}\n\t\t\ts[1][i][j] += s[1][i][j-1];\n\t\t}\n\t\tfor(int j=1; j<=n; j++) s[1][i][j] += s[1][i-1][j];\n\t}\n\tmemset(dp,42,sizeof(dp)); \n\tdp[0][0] = 0ll;\n\tfor(int i=0; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<max(i,1); j++)\n\t\t{\n//\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\tfor(int k=i+1; k<=n; k++)\n\t\t\t{\n\t\t\t\tllong tmp = dp[i][j]+getsum(1,k+1,n,j+1,i)+getsum(0,i+1,k,i+1,k);\n\t\t\t\tupdate(dp[k][i],tmp);\n//\t\t\t\tprintf(\"update dp[%d][%d]=%lld\\n\",k,i,tmp);\n\t\t\t}\n\t\t}\n\t}\n\tllong ans = dp[n][1];\n\tfor(int i=1; i<=n; i++) update(ans,dp[n][i]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\n\nint n;\nlong long f[1003][1003], s[2][1003][1003];\nlong long qry0(int i, int j) { return s[0][n][i] - s[0][j][i]; }\nlong long qry1(int i, int j, int k) {\n    return s[1][n][j] - s[1][n][k] - s[1][i][j] + s[1][i][k];\n}\nint main() {\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i < j)\n                s[0][i][j] = read();\n            else if (i > j)\n                s[1][i][j] = read();\n\n    n += 2;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) {\n            s[0][i][j] += s[0][i][j - 1] + s[0][i - 1][j] - s[0][i - 1][j - 1];\n            s[1][i][j] += s[1][i][j - 1] + s[1][i - 1][j] - s[1][i - 1][j - 1];\n        }\n\n    for (int i = 0; i <= n; ++i) f[i][0] = qry0(i, 0);\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) {\n            f[i][j] = 10000000000000000ll;\n            for (int k = 0; k < j; ++k)\n                f[i][j] = min(f[i][j], f[j][k] + qry1(i, j, k));\n            f[i][j] += qry0(i, j);\n        }\n\n    printf(\"%lld\\n\", f[n][n - 1]);\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long Sum1[5005],Sum2[5005],dp[5005][5005];\nint N,a[5005][5005];\nint main(){\n\tscanf(\"%d\",&N);\n\tfor (int i=1;i<=N;i++)\n\t\tfor (int j=1;j<N;j++)\n\t\t\tscanf(\"%d\",&a[i][j+(j>=i)]);\n\tmemset(dp,127,sizeof(dp));\n\tdp[0][0]=0;\n\tfor (int i=1;i<=N;i++){\n\t\tmemset(Sum1,0,sizeof(Sum1));\n\t\tmemset(Sum2,0,sizeof(Sum2));\n\t\tfor (int j=1;j<=i;j++){\n\t\t\tint qwq=0;\n\t\t\tfor (int k=i+1;k<=N;k++)\t\t\t\t\n\t\t\t\tSum1[j]+=a[k][j];\n\t\t\tif (j) Sum1[j]+=Sum1[j-1];\n\t\t}\n\t\tfor (int j=i-1;j>=0;j--){\n\t\t\tint qwq=0;\n\t\t\tfor (int k=j+1;k<=i;k++)\n\t\t\t\tSum2[j]+=a[j+1][k];\n\t\t\tif (j+1<i-1) \n\t\t\t\tSum2[j]+=Sum2[j+1];\n\t\t}\n\t\tfor (int j=0;j<i;j++)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+Sum1[j]-Sum1[k]+Sum2[j]);\n\t}\n\tlong long ans=LLONG_MAX;\n\tfor (int i=0;i<=N;i++)\n\t\tans=min(ans,dp[N][i]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 540;\nconst ll INF = 0x3f3f3f3f3f3f3f3fll;\n\nint n;\nll L[N][N], R[N][N], f[N][N];\n\ninline void down(ll &x, const ll y) {x > y ? x = y : 0;}\n\ninline void sum2D(ll (*a)[N]) {\n\tint i, j;\n\tfor (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) a[i][j] += a[i][j - 1];\n\tfor (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) a[i][j] += a[i - 1][j];\n}\n\ninline ll sum(ll (*a)[N], int r1, int r2, int c1, int c2) {return a[r2][c2] - a[r2][c1] - a[r1][c2] + a[r1][c1];} // (r1, r2] X (c1, c2]\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; ++i) {\n\t\tfor (j = 1; j < i; ++j) scanf(\"%lld\", L[i] + j);\n\t\tfor (; ++j <= n; ) scanf(\"%lld\", R[i] + j);\n\t}\n\tsum2D(L), sum2D(R), memset(f, 63, sizeof f);\n\tfor (i = 1; i < n; ++i) f[i][0] = R[i][i];\n\tfor (i = 1; i < n; ++i)\n\t\tfor (j = 0; j < i; ++j) if (f[i][j] < INF)\n\t\t\tfor (k = i + 1; k <= n; ++k)\n\t\t\t\tdown(f[k][i], f[i][j] + sum(R, i, k, i, k) + sum(L, k, n, j, i));\n\tprintf(\"%lld\\n\", *std::min_element(f[n], f[n] + n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N;\nll A[510][510];\nll lpsum[510][510];\nll psum[510][510],nsum[510][510];\nll dp[510][510];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  ll tot=0;\n  rep(i,N){\n    rep(j,N){\n      if(i==j)continue;\n      cin>>A[i][j];\n      tot+=A[i][j];\n    }\n  }\n\n  rep(i,N){\n    repl(j,i+1,N){\n      lpsum[i][j]=lpsum[i][j-1]+A[j][i];\n    }\n    for(ll j=i-1;j>=0;j--){\n      psum[j][i]=psum[j+1][i]+A[i][j];\n    }\n    for(ll j=i-1;j>=0;j--){\n      nsum[j][i]=nsum[j+1][i]+A[j][i];\n    }\n  }\n\n  ll res=0;\n  rep(i,N)rep(j,N)dp[i][j]=-INF;\n  repl(i,1,N){\n    dp[i][0]=psum[0][i]+nsum[0][i];\n    for(ll j=i-1;j>=0;j--){\n      dp[i][0]+=psum[0][j];\n    }\n\n    ll crt=dp[i][0];\n    repl(k,i+1,N){\n      crt+=nsum[0][k]-nsum[i][k];\n      crt+=psum[0][k];\n    }\n    maxch(res,crt);\n  }\n\n  repl(i,1,N)repl(j,1,i){\n    ll vp=psum[j][i];\n    for(ll k=i-1;k>=j;k--){\n      vp+=lpsum[k][i-1];\n    }\n    ll vn=nsum[0][i];\n    for(ll k=i-1;k>j;k--){\n      vn+=nsum[0][k]-nsum[j][k];\n    }\n    for(ll k=j-1;k>=0;k--){\n      vp+=lpsum[k][i-1]-lpsum[k][j];\n      maxch(dp[i][j],dp[j][k]+vp+vn);\n    }\n\n    ll crt=dp[i][j];\n    repl(k,i+1,N){\n      crt+=nsum[0][k]-nsum[i][k];\n      crt+=psum[j][k];\n    }\n    maxch(res,crt);\n  }\n\n  cout<<tot-res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 505;\n\ntypedef pair<int,int>   ii;\n\nll  f[N][N];\nll  s_r[N][N];\nll  s_c[N][N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n    for(int j = 1 ; j <= n ; ++j)   {\n        int x = 0;\n        int y = 0;\n\n        if (i < j)  cin >> x;\n        if (i > j)  cin >> y;\n\n        s_r[i][j] = x + s_r[i][j - 1] + s_r[i - 1][j] - s_r[i - 1][j - 1];\n        s_c[i][j] = y + s_c[i][j - 1] + s_c[i - 1][j] - s_c[i - 1][j - 1];\n    }\n    for(int i = 0 ; i <= n ; ++i)\n    for(int j = 0 ; j <= n ; ++j)\n        f[i][j] = 1e18;\n\n    f[0][0] = 0;\n\n    for(int i = 0 ; i <  n ; ++i)\n    for(int j = 0 ; j <= i ; ++j)   if (f[i][j] < 1e18)\n        for(int k = i + 1 ; k <= n ; ++k)   {\n            ll  nxt = f[i][j];\n\n            nxt += s_r[k][k] + s_r[i][i] - s_r[k][i] - s_r[i][k];\n            nxt += s_c[n][i] + s_c[k][j] - s_c[k][i] - s_c[n][j];\n\n            if (f[k][i] > nxt)\n                f[k][i] = nxt;\n        }\n\n    cout << *min_element(f[n],f[n] + 1 + n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint Sum1[5005],Sum2[5005];\nint N,a[5005][5005],dp[5005][5005];\nint main(){\n\tscanf(\"%d\",&N);\n\tfor (int i=1;i<=N;i++)\n\t\tfor (int j=1;j<N;j++)\n\t\t\tscanf(\"%d\",&a[i][j+(j>=i)]);\n\tmemset(dp,63,sizeof(dp));\n\tdp[0][0]=0;\n\tfor (int i=1;i<=N;i++){\n\t\tmemset(Sum1,0,sizeof(Sum1));\n\t\tmemset(Sum2,0,sizeof(Sum2));\n\t\tfor (int j=1;j<=i;j++){\n\t\t\tint qwq=0;\n\t\t\tfor (int k=i+1;k<=N;k++)\t\t\t\t\n\t\t\t\tSum1[j]+=a[k][j];\n\t\t\tif (j) Sum1[j]+=Sum1[j-1];\n\t\t}\n\t\tfor (int j=i-1;j>=0;j--){\n\t\t\tint qwq=0;\n\t\t\tfor (int k=j+1;k<=i;k++)\n\t\t\t\tSum2[j]+=a[j+1][k];\n\t\t\tif (j+1<i-1) \n\t\t\t\tSum2[j]+=Sum2[j+1];\n\t\t}\n\t\tfor (int j=0;j<i;j++)\n\t\t\tfor (int k=0;k<=j;k++)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+Sum1[j]-Sum1[k]+Sum2[j]);\n\t}\n\tint ans=1e9+7;\n\tfor (int i=0;i<=N;i++)\n\t\tans=min(ans,dp[N][i]);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long oo = 1LL << 60;\n\nint n;\nlong long a[555][555], sum[555][555];\n\nlong long sumRect(int x, int y, int xx, int yy)\n{\n  return a[xx][yy] + a[x][y] - a[x][yy] - a[xx][y];\n}\n\nint main()\n{\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++)\n    {\n      int x = 0;\n      if (i != j)\n        cin >> x;\n      a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + x;\n    }\n\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j <= n; j++)\n      sum[i][j] = sum[i][j - 1] + sumRect(i, j - 1, j - 1, j);\n\n  long long ans = 0;\n  for (int i = 1; i <= n; i++)\n    ans += sumRect(i - 1, i, i, n);\n\n  long long f[555][555];\n  for (int i = 0; i < n; i++)\n    for (int j = i; j < n; j++)\n      f[i][j] = oo;\n\n  for (int i = 1; i < n; i++)\n    f[0][i] = sum[0][i];\n\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++)\n    {\n      ans = min(ans, f[i][j] + sum[j][n]);\n      for (int k = j + 1; k < n; k++)\n        f[j][k] = min(f[j][k], f[i][j] + sum[j][k] + sumRect(k, i, n, j));\n    }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n \n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n \ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n \ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n \nstruct P {\n    ll x, y;\n    char ty;\n};\nostream& operator<<(ostream& os, const P& p) {\n    return os << p.ty << \"(\" << p.x << \", \" << p.y << \")\";\n}\n \nconst int MN = 510;\nint n;\nll cost[MN][MN];\nll rcost[MN][MN];\nll cost_sm[MN][MN];\nll rcost_sm[MN][MN];\n \nll memo[MN][MN][MN];\nbool vis[MN][MN][MN];\nll calc(int a, int b, int c) {\n    /*\n    [0, a) : 2\n    [a, b) : 1\n    [b, c) : 0\n     */\n    if (c == n) return 0;\n    if (vis[a][b][c]) return memo[a][b][c];\n    vis[a][b][c] = true;    \n    ll ans = TEN(18);\n    /*\n      c = 0\n      prohibit\n      2 <- 0\n      0 -> 0\n     */\n    ans = min(ans, cost_sm[c][a] + (rcost_sm[c][c] - rcost_sm[c][b]) + calc(a, b, c + 1));\n    /*\n      c = -1\n      prohibit\n      1 <- -1      \n     */\n    ans = min(ans, (cost_sm[c][b]) + calc(b, c, c + 1));\n \n    return memo[a][b][c] = ans;\n}\n \n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            cin >> cost[i][j];\n            rcost[j][i] = cost[i][j];\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cost_sm[i][j + 1] = cost_sm[i][j] + cost[i][j];\n            rcost_sm[i][j + 1] = rcost_sm[i][j] + rcost[i][j];\n        }\n    }\n \n \n    cout << calc(0, 0, 0) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 505;\nconst long long inf = 1000000000000000ll;\n\nint n;\nlong long a[N][N], pre1[N][N], pre2[N][N], f[N][N], ans = 0ll, mx = -inf;\n\nlong long query1 (int l1, int r1, int l2, int r2) {\n\treturn pre1[r1][r2] - pre1[l1 - 1][r2] - pre1[r1][l2 - 1] + pre1[l1 - 1][l2 - 1];\n}\n\nlong long query2 (int l1, int r1, int l2, int r2) {\n\treturn pre2[r1][r2] - pre2[l1 - 1][r2] - pre2[r1][l2 - 1] + pre2[l1 - 1][l2 - 1];\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i][i] = 0ll;\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tint u = i, v = j;\n\t\t\tif (v >= i) v++;\n\t\t\tscanf(\"%lld\", &a[u][v]), ans += a[u][v];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= n; j++) pre1[i][j] = pre2[i][j] = 0ll;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tlong long val1 = i > j ? max(a[i][j], 0ll) : 0ll;\n\t\t\tlong long val2 = i < j ? max(a[i][j], 0ll) : 0ll;\n\t\t\tpre1[i][j] = pre1[i - 1][j] + pre1[i][j - 1] - pre1[i - 1][j - 1] + val1;\n\t\t\tpre2[i][j] = pre2[i - 1][j] + pre2[i][j - 1] - pre2[i - 1][j - 1] + val2;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = -inf;\n\t\t\tif (j <= 1) f[i][j] = max(f[i][j], query1(1, i, 1, i));\n\t\t\telse {\n\t\t\t\tfor (int k = 1; k < j; k++) f[i][j] = max(f[i][j], f[j - 1][k] + query1(j, i, k, i) + query2(1, j - 1, j, i));\n\t\t\t}\n\t\t\tif (i == n) mx = max(mx, f[n][j]);\n\t\t}\n\t}\n\n\tans -= mx;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\ntemplate <class T> inline void cmin(T &x,T y) { x=min(x,y); }\nconst int N=510;\nll a[N][N],b[N][N];\nll f[N][N];\nint n;\nvoid getsum(ll a[][N]) {\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n}\nll query(ll a[][N],int x1,int x2,int y1,int y2) {\n\tif(x2<x1||y2<y1) return 0;\n\tx1--,y1--;\n\treturn a[x2][y2]-a[x1][y2]-a[x2][y1]+a[x1][y1];\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j) {\n\t\t\tif(i==j) continue;\n\t\t\tint x; rd(x);\n\t\t\tif(i<j) a[i][j]=x;\n\t\t\tif(i>j) b[i][j]=x;\n\t\t}\n\tgetsum(a),getsum(b);\n\tmemset(f,0x3f,sizeof(f));\n\tfor(int i=1;i<=n;++i)\n\t\tf[0][i]=query(a,1,i-1,2,i);\n\tfor(int i=0;i<=n-1;++i)\n\t\tfor(int j=i+1;j<=n-1;++j)\n\t\t\tfor(int k=j+1;k<=n-1;++k)\n\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+query(a,j+1,k-1,j+2,k)+query(b,j+1,k,1,i));\n\tll ans=query(a,1,n-1,2,n);\n\tfor(int i=0;i<=n-1;++i)\n\t\tfor(int j=i+1;j<=n-1;++j) \n\t\t\tans=min(ans,f[i][j]+query(a,j+1,n-1,j+2,n)+query(b,j+1,n,1,i));\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vvi a(N, vi(N));\n    F0R (i, N) F0R (j, N) if (i != j) re(a[i][j]);\n\n    map<pii, ll> dp; dp[{ 0, 1 }] = 0;\n\n    FOR (i, 1, N) {\n        decltype(dp) DP;\n        trav (p, dp) {\n            int pc, cc; tie(pc, cc) = p.f; ll cost = p.s;\n            {\n                ll stay = cost;\n                FOR (v, i - cc, i) stay += a[v][i];\n                F0R (v, i - cc - pc) stay += a[i][v];\n                pii key = mp(pc, cc+1);\n                DP[key] = min(stay, DP.count(key) ? DP[key] : LLONG_MAX);\n            }\n            {\n                ll go = cost;\n                F0R (v, i - cc) go += a[i][v];\n                pii key = mp(cc, 1);\n                DP[key] = min(go, DP.count(key) ? DP[key] : LLONG_MAX);\n            }\n        }\n\n        dp = move(DP);\n    }\n\n    ll ans = LLONG_MAX;\n    trav (p, dp) ckmin(ans, p.s);\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n    return getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f;\n}\ntypedef long long ll;\nconst int maxn = 500 + 5;\nll f[maxn][maxn];\nll sum[2][maxn][maxn];\nint n;\nint a[maxn][maxn];\nll cal0(int a, int b)\n{\n    return sum[0][b][b] - sum[0][a][b] - sum[0][b][a] + sum[0][a][a];\n}\nll cal1(int a, int b, int c)\n{\n    return sum[1][n][b] - sum[1][n][a] - sum[1][c][b] + sum[1][c][a];\n}\nvoid init()\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            sum[i > j][i][j] = a[i][j];\n        }\n    }\n    for(int k = 0; k < 2; ++k)\n    {\n        for(int i = 1; i <= n; ++i)\n        {\n            for(int j = 1; j <= n; ++j)\n            {\n                sum[k][i][j] += sum[k][i - 1][j] + sum[k][i][j - 1] - sum[k][i - 1][j - 1];\n            }\n        }\n    }\n}\nll solve()\n{\n    init();\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = i + 1; j <= n; ++j)\n        {\n            f[j][i] = cal0(0, i) + cal0(i, j) + cal1(0, i, j);\n        }\n    }\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j < i; ++j)\n        {\n            for(int x = i + 1; x <= n; ++x)\n            {\n                f[x][i] = min(f[x][i], f[i][j] + cal0(i, x) + cal1(j, i, x));\n            }\n        }\n    }\n    ll an = cal0(0, n);\n    for(int i = 1; i <= n; ++i)\n    {\n        ll r = cal0(i, n);\n        an = min(an, cal0(0, i) + r);\n        for(int j = 1; j < i; ++j)\n        {\n            an = min(an, f[i][j] + r);\n        }\n    }\n    return an;\n}\nint main()\n{\n    read(n);\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j) if(i != j)\n        {\n            read(a[i][j]);\n        }\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint main(){\n\tint n;\n\tread(n);\n\tint a[n+1][n+1]={},b[n+1][n+1]={};\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++) read(a[i][j]);\n\t\tfor(int j=i+1;j<=n;j++) read(b[i][j]);\n\t}\n\tll s[2][510][510]={};\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ts[0][i][j]=s[0][i-1][j]+s[0][i][j-1]-s[0][i-1][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\ts[1][i][j]=s[1][i-1][j]+s[1][i][j-1]-s[1][i-1][j-1]+b[i][j];\n\tll f[n+1][n+1];memset(f,63,sizeof(f));\n\tauto calc=[&](int k,int a,int b,int c,int d){\n\t\tif(a>b||c>d) return 0ll;\n\t\treturn s[k][b][d]-s[k][a-1][d]-s[k][b][c-1]+s[k][a-1][c-1];\n\t};\n\tauto chmin=[](ll &a,ll b){if(b<a) a=b;};\n\tfor(int i=1;i<=n;i++)\n\t\tf[1][i]=calc(1,1,i,2,i);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<i;j++){\n\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t\tchmin(f[i+1][k],f[j][i]+calc(1,i+1,k,i+2,k)+calc(0,i+1,k,1,j-1));\n\t\t}\n\tll ans=1e18;\n\tfor(int i=1;i<=n;i++) chmin(ans,f[i][n]);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\nvoid read(pp& x){ scanf(\"%d%d\",&x.first, &x.second); }\nvoid read(pll& x){ scanf(\"%lld%lld\",&x.first, &x.second); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\nvoid cppio(){ ios_base::sync_with_stdio(0); cin.tie(0); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define sz(x) (int)(x).size()\n\nconst int maxn = 510;\nint n;\nint cost[maxn][maxn];\n\nll dp[maxn][maxn];\n\nll cp[maxn][maxn];\nll gp[maxn][maxn];\n\nint main()\n{\n\tcppio();\n\tcin >> n;\n\trrep(i, n) rrep(j, n) if(i != j) cin >> cost[i][j];\n\n\trrep(i, n) rrep(j, n)\n\t\tcp[i][j] = cp[i-1][j] + cp[i][j-1] - cp[i-1][j-1] + cost[i][j];\n\n\trrep(i, n) {\n\t\tfor(int j=i+1; j<=n; ++j) {\n\t\t\tgp[i][j] = gp[i][j-1];\n\t\t\tfor(int k=i; k<j; ++k) {\n\t\t\t\tgp[i][j] += cost[k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(dp, 0x7f, sizeof(dp));\n\n\tdp[1][1] = 0;\n\tfor(int i=2; i<=n; ++i)\n\t\tdp[1][i] = gp[1][i];\n\n\tauto rect = [&](int l, int r, int d, int u) -> ll {\n\t\tif(l>r || d>u) return 0;\n\t\treturn cp[r][u] - cp[l-1][u] - cp[r][d-1] + cp[l-1][d-1];\n\t};\n\n\trrep(l, n) {\n\t\tfor(int r=l; r<=n; ++r) {\n\t\t\tfor(int R=r+1; R<=n; ++R) {\n\t\t\t\tdp[r+1][R] = min(dp[r+1][R],\n\t\t\t\t\tdp[l][r] + gp[r+1][R] +\n\t\t\t\t\t\trect(r+1, R, 1, l-1));\n\t\t\t}\n\t\t}\n\t}\n\n/*\n\trrep(i, n) {\n\t\tfor(int j=i; j<=n; ++j) printf(\"dp[%d][%d] = %lld\\n\", i, j, dp[i][j]);\n\t}\n*/\n\n\tll ans = 1ll << 60;\n\trrep(i, n) ans = min(ans, dp[i][n]);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 510;\nll dp[N][N], n;\nll mat[N][N], sum[2][N][N];\nll calc(int tp,int l1,int r1,int l2,int r2) {\n  return sum[tp][r1][r2] - sum[tp][l1-1][r2] - sum[tp][r1][l2-1] + sum[tp][l1-1][l2-1];\n}\nint main() {\n  read(n);\n  rep (i, 1, n) {\n    rep (j, 1, n) if (i != j) {\n      read(mat[i][j]);\n    }\n  }\n  rep (i, 1, n) rep (j, 1, n)\n    sum[i < j][i][j] = mat[i][j];\n  rep (k, 0, 1) {\n    rep (i, 1, n) rep (j, 1, n)\n      sum[k][i][j] += sum[k][i][j-1];\n    rep (i, 1, n) rep (j, 1, n)\n      sum[k][i][j] += sum[k][i-1][j];\n  }\n  memset(dp, 0, sizeof dp);\n  rep (i, 1, n) rep (j, 1, n) dp[0][0] += mat[i][j];\n  // 1 >= qj + .. + q_{i-1} (i > j)\n  rep (i, 1, n) {\n    rep (a, 0, i-1) rep (b, 0, max(0, a-1)) {\n      ckmx(dp[i][a], dp[a][b] - calc(1, a+1, i, a+1, i) - calc(0, i+1, n, b+1, a));\n    }\n  }\n  ll ans = 0;\n  rep (a, 0, n) rep (b, 0, max(0, a-1))\n    ckmx(ans, dp[a][b] - calc(1, a+1, n, a+1, n));\n  ans = dp[0][0] - ans;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n// #define inf    0x7f7f7f7f\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x3f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 1e18)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 1e18;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=505;\nint n,a[N][N];\nll S1[N][N],S2[N][N];\nll f[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) For(j,1,n) if (i!=j) scanf(\"%d\",&a[i][j]);\n\tFor(i,1,n) For(j,1,n) S1[i][j]=(i>j?a[i][j]:0); \n\tFor(i,1,n) Rep(j,n,1) S1[i][j]+=S1[i][j+1];\n\tFor(i,1,n) For(j,1,n) S2[i][j]=(i<j?a[i][j]:0); \n\tFor(i,1,n) For(j,1,n) S2[i][j]+=S2[i-1][j];\n\tmemset(f,233,sizeof(f));\n\tf[0][0]=0;\n\tFor(i,1,n) f[0][i]=f[0][i-1]+S1[i][1];\n\tFor(i,0,n) For(j,i+1,n){\n\t\tll vtr=f[i][j];\n\t\tFor(k,j+1,n){\n\t\t\tvtr+=S1[k][i+1]+S2[j][k];\n\t\t\tf[j][k]=max(f[j][k],vtr);\n\t\t}\n\t}\n\tll ans=0;\n\tFor(i,0,n) ans=max(ans,f[i][n]);\n\tans=-ans;\n\tFor(i,1,n) For(j,1,n)\n\t\tans+=a[i][j];\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst ll inf = 1LL << 50;\nll dp[2][510][510];\nll A[510][510];\n\nll pls[510][510];\nll mns[510][510];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n)rep(j, n){\n\t\tif(i == j) continue;\n\t\tcin >> A[i][j];\n\t}\n\n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) pls[i][j] += pls[i][j - 1];\n\t\t\tpls[i][j] += A[i][j];\n\t\t}\n\t}\n\n\trep(i, n){\n\t\trep(j, i){\n\t\t\tif(j - 1 >= 0) mns[i][j] += mns[i][j - 1];\n\t\t\tmns[i][j] += A[j][i];\n\t\t}\n\t}\n\n\n\tconst int unused = n;\n\n\trep(i, 2) rep(j, n + 1) rep(k, n + 1) dp[i][j][k] = inf; \n\tdp[0][0][unused] = 0;\n\tint cur = 0, nxt = 1;\n\n\trep(i, n - 1){\n\t\trep(j, n + 1) rep(k, n + 1) dp[nxt][j][k] = inf;\n\n\t\trep(j, n + 1) rep(k, n + 1){\n\t\t\tif (dp[cur][j][k] == inf) continue;\n\t\t\n\t\t\tconst int vj = j;\n\t\t\tconst int vk = (k != unused) ? k : -1;\n\n\t\t\t// potential increase\n\t\t\t{\n\t\t\t\tll add = 0LL;\n\t\t\t\tif(vj - 1 >= 0) add += pls[i + 1][vj - 1];\n\t\t\t\tchmin(dp[nxt][i + 1][j], dp[cur][j][k] + add);\n\t\t\t}\n\n\t\t\t// do nothing \n\t\t\t{\n\t\t\t\tll add = 0LL;\n\t\t\t\tadd += mns[i + 1][i];\n\t\t\t\tif(vj - 1 >= 0) add -= mns[i + 1][vj - 1];\n\t\t\t\tif(vk - 1 >= 0) add += pls[i + 1][vk - 1];\n\t\t\t\tchmin(dp[nxt][j][k], dp[cur][j][k] + add);\n\t\t\t}\n\t\t}\n\n\t\tswap(cur, nxt);\n\t}\n\n\tll ans = inf;\n\trep(j, n + 1) rep(k, n + 1) chmin(ans, dp[cur][j][k]);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define ll long long\n#define N 510\nusing namespace std;\nll l[N][N],r[N][N],f[N][N],g[N][N],dp[N][N];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++) scanf(\"%lld\",&l[j][i]);\n\t\tfor(int j=i+1;j<=n;j++) scanf(\"%lld\",&r[i][j]);\n\t}\n\tfor(int i=0;i<=n+1;i++)\n\t\tfor(int j=i;j<=n+1;j++)\n\t\t{\n\t\t\tf[i][j]=i?f[i-1][j]:0;\n\t\t\tfor(int k=j;k<=n+1;k++) f[i][j]+=l[i][k];\n\t\t}\n\tfor(int i=n+1;i>=0;i--)\n\t\tfor(int j=i;j<=n+1;j++)\n\t\t{\n\t\t\tg[i][j]=g[i+1][j];\n\t\t\tfor(int k=i;k<=j;k++) g[i][j]+=r[i][k];\n\t\t}\n\tmemset(dp,60,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=0;k<=j;k++)\n\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+f[j][i+1]-f[k][i+1]+g[j+1][i]);\n\tll ans=1e16;\n\tfor(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n+1][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nconst int N=505;\nll a[N][N],b[N][N],c[N][N],f[N][N],bas,mx=-1e18,sum;\nint n;\n\nvoid cmax(ll &x,ll y){\n\tif(y>x)x=y;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)rep(j,1,n)\t\n\t\tif(i!=j){\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t\tif(i<j)b[i][j]=a[i][j],bas+=a[i][j];\n\t\t\telse c[j][i]=a[i][j];\n\t\t\tsum+=a[i][j];\n\t\t}\n\tper(i,n,1)rep(j,i+2,n){\n\t\tb[i][j]+=b[i][j-1]+b[i+1][j]-b[i+1][j-1];\n\t\tc[i][j]+=c[i][j-1]+c[i+1][j]-c[i+1][j-1];\n\t}\n\tmemset(f,0xc0,sizeof f);\n\trep(i,1,n)f[1][i]=c[1][i]-b[1][i];\n\trep(i,1,n)rep(j,i,n)rep(k,j+1,n)\n\t\tcmax(f[j+1][k],f[i][j]+c[i][k]-c[i][j]-b[j+1][k]);\n\trep(i,1,n)cmax(mx,f[i][n]);\n\tcout<<sum-(mx+bas)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=510; \nint n,a;\nll S1[N][N],S2[N][N],f[N][N],ans;\nvoid Mn(ll&x,ll y) {if(x>y)x=y;}\nint main()\n{\n\tcin>>n;\n\tfo(i,1,n) fo(j,1,n) if(i^j)\n\t{\n\t\tcin>>a;\n\t\ti<j?S1[i][j]=a:S2[j][i]=a;\n\t}\n\tfo(i,1,n)\n\t{\n\t\tfd(j,i-1,1) S1[j][i]+=S1[j+1][i];\n\t\tfo(j,1,i-1) S2[j][i]+=S2[j-1][i];\n\t}\n\tfo(i,1,n) fo(j,i+1,n) S1[i][j]+=S1[i][j-1], S2[i][j]+=S2[i][j-1];\n\tmemset(f,127,sizeof f);\n\tfo(i,1,n) f[1][i]=S1[1][i];\n\tfo(i,1,n-1) fo(j,i,n-1) if(f[i][j]<f[0][0])\n\t\tfo(k,j+1,n) Mn(f[j+1][k],f[i][j]+S1[j+1][k]+S2[i-1][k]-S2[i-1][j]);\n\tans=f[0][0];\n\tfo(i,1,n) Mn(ans,f[i][n]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 505\nlong long f[N][N],su1[N][N],su2[N][N],dp[N][N],n,su;\nlong long Max(long long a,long long b){return a>b?a:b;}\nint main()\n{\n\tscanf(\"%lld\",&n);for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)scanf(\"%lld\",&f[i][j]),su+=f[i][j];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)su1[i][j]=f[i][j]*(i<j)+su1[i][j-1]+su1[i-1][j]-su1[i-1][j-1],su2[i][j]=f[i][j]*(i>j)+su2[i][j-1]+su2[i-1][j]-su2[i-1][j-1];\n\tfor(int i=1;i<=n;i++)dp[1][i]=su2[i][i];\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)for(int k=j+1;k<=n;k++)dp[j+1][k]=Max(dp[j+1][k],dp[i][j]+su1[j][k]-su1[j][j]+su2[k][k]-su2[k][i-1]-su2[j][k]+su2[j][i-1]);\n\tlong long as=0;for(int i=1;i<=n;i++)as=Max(as,dp[i][n]);printf(\"%lld\\n\",su-as);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long dp[2][503][503] , A[503][503] , N;\nvoid chkmin(long long &p , long long q){p = p < q ? p : q;}\n\nint main(){\n\tcin >> N;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j <= N ; ++j) if(i != j) cin >> A[i][j];\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = 1 ; j < i ; ++j) A[i][j] += A[i][j - 1];\n\tfor(int j = 1 ; j <= N ; ++j) for(int i = 1 ; i < j ; ++i) A[i][j] += A[i - 1][j];\n\tmemset(dp , 0x3f , sizeof(dp)); dp[0][1][1] = 0; int pos = 0;\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tmemset(dp[pos ^ 1] , 0x3f , sizeof(dp[pos]));\n\t\tfor(int j = 1 ; j < i ; ++j)\n\t\t\tfor(int k = j ; k < i ; ++k)\n\t\t\t\tif(dp[pos][j][k] < 1e18){\n\t\t\t\t\tchkmin(dp[pos ^ 1][j][k] , dp[pos][j][k] + A[i - 1][i] - A[k - 1][i] + A[i][j - 1]);\n\t\t\t\t\tchkmin(dp[pos ^ 1][k][i] , dp[pos][j][k] + A[i][k - 1]);\n\t\t\t\t}\n\t\tpos ^= 1;\n\t}\n\tlong long mn = 1e18;\n\tfor(int i = 1 ; i <= N ; ++i) for(int j = i ; j <= N ; ++j) mn = min(mn , dp[pos][i][j]);\n\tcout << mn; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=505;\nint n,a[N][N],dp[N][N],b[N][N],c[N][N];\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<i;j++)scanf(\"%lld\",&a[i][j]);\n\t\tfor (int j=i+1;j<=n;j++)scanf(\"%lld\",&a[i][j]);\n\t\tfor (int j=1;j<=n;j++)b[i][j]=a[i][j];\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)b[i][j]+=b[i-1][j];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)b[i][j]+=b[i][j-1];\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++){\n\t\t\tc[i][j]=c[i][j-1];\n\t\t\tfor (int k=i;k<=j;k++)c[i][j]+=a[k][j];\n\t\t}\n\tmemset(dp,0x3f3f3f3f,sizeof dp);\n\tdp[0][0]=0;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t\tfor (int x=j+1;x<=n;x++)\n\t\t\t\tdp[j][x]=min(dp[j][x],dp[i][j]+b[x][i]-b[j][i]+c[j+1][x]);\n\tint ans=1e18;\n\tfor (int i=0;i<=n;i++)\n\t\tfor (int j=i;j<=n;j++)\n\t\t\tans=min(ans,dp[i][j]+b[n][i]-b[j][i]+c[j+1][n]);\n\tprintf(\"%lld\\n\",ans);\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define ll long long\nusing namespace std;\nconst int N=505;\nint a[N][N],n;\nll S[N][N],SS[N][N];\nll SSS[N][N],f[N][N];\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) For(j,1,n) if (i!=j) scanf(\"%d\",&a[i][j]);\n\tFor(i,1,n) For(j,1,n) S[i][j]=S[i][j-1]+a[i][j];\n\tFor(i,1,n) For(j,i,n) SS[i][j]=SS[i][j-1]+S[j][j-1]-S[j][i-1];\n\tFor(i,1,n) For(j,1,n) SSS[i][j]=SSS[i-1][j]+a[i][j];\n\tFor(i,1,n) f[0][i]=f[0][i-1]+S[i][i];\n\tFor(i,0,n) For(j,i+1,n){\n\t\tll SSSS=0;\n\t\tFor(k,j+1,n){\n\t\t\tSSSS+=S[k][k]-S[k][i]+SSS[j][k];\n\t\t\tf[j][k]=max(f[j][k],f[i][j]+SSSS);\n\t\t}\n\t}\n\tll ans=0;\n\tFor(i,0,n-1) ans=max(ans,f[i][n]);\n\tFor(i,1,n) For(j,1,n) ans-=a[i][j];\n\tprintf(\"%lld\\n\",-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst LL Infll = 0x3f3f3f3f3f3f3f3f;\nconst int MN = 505;\n\nint N;\nLL A[MN][MN], B[MN][MN], f[MN][MN], Ans;\n\ninline LL val(int k, int j, int i) {\n\treturn B[j + 1][i] + A[N][j] - A[N][k] - A[i][j] + A[i][k];\n}\n\nint main() {\n\tscanf(\"%d\", &N), Ans = Infll;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tif (j != i) scanf(\"%lld\", &A[i][j]);\n\tfor (int j = 1; j <= N; ++j)\n\t\tfor (int i = j; i >= 1; --i)\n\t\t\tB[i][j] = B[i + 1][j] + B[i][j - 1] - B[i + 1][j - 1] + A[i][j];\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (int j = 1; j <= N; ++j)\n\t\t\tA[i][j] += A[i - 1][j] + A[i][j - 1] - A[i - 1][j - 1];\n\tfor (int i = 1; i <= N - 1; ++i) {\n\t\tf[i][0] = val(0, 0, i);\n\t\tAns = std::min(Ans, f[i][0] + val(0, i, N));\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tf[i][j] = Infll;\n\t\t\tfor (int k = 0; k < j; ++k)\n\t\t\t\tf[i][j] = std::min(f[i][j], f[j][k] + val(k, j, i));\n\t\t\tAns = std::min(Ans, f[i][j] + val(j, i, N));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvvc<int> a(n+2,vi(n+2));\n\trep(i,n)rep(j,n-1)\n\t\tcin>>a[i+1][j+(j>=i)+1];\n\t\n\tn++;\n\tconst int inf=LLONG_MAX/3;\n\tvvc<int> dp(n,vi(n,inf));\n\tdp[0][0]=0;\n\t\n\trng(i,1,n){\n\t\tvi x(i),y(i);\n\t\trep(j,i){\n\t\t\trng(k,i+1,n+1)\n\t\t\t\tx[j]+=a[k][j];\n\t\t\tif(j)x[j]+=x[j-1];\n\t\t}\n\t\tper(j,i){\n\t\t\trng(k,j+1,i+1)\n\t\t\t\ty[j]+=a[j+1][k];\n\t\t\tif(j+1<i-1)\n\t\t\t\ty[j]+=y[j+1];\n\t\t}\n\t\trep(j,i)\n\t\t\trep(k,j+1)\n\t\t\t\tchmin(dp[i][j],dp[j][k]+x[j]-x[k]+y[j]);\n\t}\n\t\n\tcout<<*min_element(all(dp[n-1]))<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nauto rd=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\n\nconst int N=501;\nint n, a[N][N];\ns64 s[N][N], ds[N][N], f[N][N];\nint main() {\n\tn=rd();\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=1; j<=n; ++j) if(i!=j) a[i][j]=rd();\n\t\tfor(int j=1; j<=n; ++j) s[i][j]=s[i][j-1]+a[i][j];\n\t\tfor(int j=1; j<=n; ++j) s[i][j]+=s[i-1][j];\n\t\tfor(int j=i; j<=n; ++j) ds[i][j]=ds[i][j-1]+a[i][j];\n\t\tfor(int j=1; j<=n; ++j) ds[i][j]+=ds[i-1][j];\n\t}\n\tfor(int i=0; i<=n; ++i) memset(f[i], 63, (n+1)*sizeof(s64));\n\tf[0][0]=0;\n\tfor(int i=0; i<=n; ++i)\n\t\tfor(int j=i; j<=n; ++j)\n\t\t\tif(f[i][j]<1e18)\n\t\t\t\tfor(int k=j+1; k<=n; ++k)\n\t\t\t\t\tcmin(f[j][k], f[i][j]+ds[k][k]-ds[j][k]-ds[k][j]+ds[j][j]+s[k][i]-s[j][i]);\n\ts64 ans=1e18;\n\tfor(int i=1; i<n; ++i) cmin(ans, f[i][n]);\n\tprintf(\"%llu\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=510;\nint n,a[maxn][maxn];\nlong long suma[maxn][maxn],sumb[maxn][maxn],f[maxn][maxn],ans=1e18;\ninline int getsum(int a,int b,int c){return sumb[b+1][c]+suma[n][b]-suma[n][a]+suma[c][a]-suma[c][b];}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(i^j) scanf(\"%d\",&a[i][j]);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) suma[i][j]=suma[i-1][j]+suma[i][j-1]-suma[i-1][j-1]+a[i][j];\n\tfor(int j=1;j<=n;j++) for(int i=j;i>=1;i--) sumb[i][j]=sumb[i+1][j]+sumb[i][j-1]-sumb[i+1][j-1]+a[i][j];\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) f[i][j]=1e18;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tf[i][0]=getsum(0,0,i);\n\t\tans=min(ans,f[i][0]+getsum(0,i,n));\n\t\tfor(int j=1;j<i;j++)\n\t\t{\n\t\t\tfor(int k=0;k<j;k++) f[i][j]=min(f[i][j],f[j][k]+getsum(k,j,i));\n\t\t\tans=min(ans,f[i][j]+getsum(j,i,n));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tn += 1;\n\tvector<vector<ll> > a(n, vector<ll>(n, 0));\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 1; j < n; j++){\n\t\t\tif(i == j) continue;\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tvector<vector<ll> > rsum(n, vector<ll>(n, 0));\n\tvector<vector<ll> > lsum(n, vector<ll>(n, 0));\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i+1; j < n; j++){\n\t\t\trsum[i][j] = rsum[i][j-1];\n\t\t\tlsum[i][j] = lsum[i][j-1];\n\t\t\tfor(int k = i; k < j; k++){\n\t\t\t\trsum[i][j] += a[k][j];\n\t\t\t\tlsum[i][j] += a[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<ll> > dp(n, vector<ll> (n, 2e18));\n\tdp[0][0] = 0;\n\tfor(int j = 0; j < n; j++){\n\t\tfor(int i = 0; i <= j; i++){\n\t\t\tfor(int k = j+1; k < n; k++){\n\t\t\t\tll newdp = dp[i][j];\n\t\t\t\tnewdp += rsum[j+1][k];\n\t\t\t\tnewdp += lsum[0][k] - lsum[0][j] - lsum[i][k] + lsum[i][j];\n\t\t\t\tdp[j+1][k] = min(dp[j+1][k], newdp);\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 2e18;\n\tfor(int i = 0; i < n; i++){\n\t\tans = min(ans, dp[i][n-1]);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 510\n#define ll long long\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define mset(x,y) memset(x,y,sizeof(x))\nusing namespace std;\nll dp[N][N],A[N][N],B[N][N],a[N][N],b[N][N];\nll getB(int rx,int ry,int lx,int ly){\n\tif(lx>rx||ly>ry) return 0;\n\treturn B[rx][ry]-B[lx-1][ry]-B[rx][ly-1]+B[lx-1][ly-1];\n}\nll getA(int rx,int ry,int lx,int ly){\n\tif(lx>rx||ly>ry) return 0;\n\treturn A[rx][ry]-A[lx-1][ry]-A[rx][ly-1]+A[lx-1][ly-1];\n}\nvoid chkmin(ll &x,ll y){ if(y<x) x=y; }\nint main(){\n\tint n;ll ans=0;\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tFor(j,1,i-1) scanf(\"%lld\",&b[i][j]);\n\t\tFor(j,i+1,n) scanf(\"%lld\",&a[i][j]);\n\t\tFor(j,1,n){\n\t\t\tA[i][j]=A[i-1][j]+A[i][j-1]+a[i][j]-A[i-1][j-1];\n\t\t\tB[i][j]=B[i-1][j]+B[i][j-1]+b[i][j]-B[i-1][j-1];\n\t\t}\n\t}\n\tmset(dp,0x3f);ans=dp[0][0];\n\tdp[0][0]=0;\n\tFor(i,0,n) For(j,0,max(i-1,0)) For(k,i+1,n)\n\t\tchkmin(dp[k][i],dp[i][j]+getB(n,i,k+1,j+1)+getA(k,k,i+1,i+1));\n\tFor(j,1,n) chkmin(ans,dp[n][j]);\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void update(ll &x,ll y) {\n  x=max(x,y);\n}\n\nint num[505][505];\n\nll sum1[505][505],sum2[505][505];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++)\n    for(int j=i+1;j<=n;j++) sum1[i][j]=sum1[i][j-1]+num[i][j];\n  for(int i=n;i>=0;i--)\n    for(int j=i+1;j<=n;j++) sum1[i][j]=sum1[i+1][j]+sum1[i][j];\n  for(int i=0;i<=n;i++)\n    for(int j=i+1;j<=n;j++) sum2[i][j]=sum2[i][j-1]+num[j][i];\n  for(int i=n;i>=0;i--)\n    for(int j=i+1;j<=n;j++) sum2[i][j]=sum2[i+1][j]+sum2[i][j];\n}\n\nll f[505][505];\n\nvoid dp(int n) {\n  for(int i=0;i<n;i++)\n    for(int j=0;j<=i;j++)\n      for(int k=i+1;k<=n;k++) \n        update(f[k][i],f[i][j]+sum1[0][k]-sum1[0][i]-sum1[i+1][k]+sum2[j+1][k]-sum2[j+1][i]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  ll s=0;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      if (i!=j) {\n\t    scanf(\"%d\",&num[i][j]);\n\t    s+=num[i][j];\n\t  }\n  pre(n);\n  dp(n);\n  ll ans=0;\n  for(int i=0;i<=n;i++) update(ans,f[n][i]);\n  printf(\"%lld\\n\",s-ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 510;\nint n;\nll a[2][N][N], f[N][N];\nll sum[2][N][N];\n\nll getsum(int sig, int a,int b, int x, int y) {\n\t//(a,x) (b,y)\n\tswap(x, b);\n\tif (a <= x && b <= y)\n\t\treturn sum[sig][x][y] - sum[sig][a - 1][y] - sum[sig][x][b - 1] + sum[sig][a - 1][b - 1];\n\telse return 0;\n}\n\nll ss;\nint main() {\n\tcin>>n;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (i != j) {\n\t\t\t\tscanf(\"%lld\\n\", &a[i<j][i][j]), ss += a[i<j][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int o=0;o<2;o++) {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tsum[o][i][j] = sum[o][i][j - 1] + a[o][i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tsum[o][i][j] += sum[o][i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(f,128,sizeof f);\n\tll ans = f[0][0];\n\tf[0][0] = 0;\n\tfor(int l = 0; l <= n; l++) {\n\t\tfor(int r = l; r <= n; r++) {\n\t\t\tfor(int nx = r + 1; nx <= n; nx++) {\n\t\t\t\tif (r == 0 && nx == 2) {\n\t\t\t\t\tint kk = r;\n\t\t\t\t}\n\t\t\t\tf[r][nx] = max(f[r][nx], f[l][r] + getsum(1, 1, r, r + 1, nx) + getsum(0, r + 1, nx, l + 1, nx));\n\n\t\t\t}\n\t\t}\n\t}\n\tfor(int l = 1; l <= n; l++) ans = max(ans, f[l][n]);\n\tcout<<ss - ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nlong long n,m,i,j,k,dp[505][505],w1[505][505],w2[505][505],a[505][505],ans;\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfz1(i,n){\n\t\tfz1(j,n)if(i!=j){\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t}\n\t}\n\tfz1(i,n){\n\t\tfd(j,n,i+1){\n\t\t\tw1[i][j]=w1[i+1][j];\n\t\t\tfz1(k,i){\n\t\t\t\tw1[i][j]+=a[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tfz1(i,n){\n\t\tfz(j,i,n+1){\n\t\t\tw2[i][j]=w2[i][j-1];\n\t\t\tfz(k,i,j-1){\n\t\t\t\tw2[i][j]+=a[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfz0g(i,n){\n\t\tfz(j,i,n)if(dp[i][j]<0x3f3f3f3f3f3f3f3fll){\n\t\t\tfz(k,j+1,n+1){\n\t\t\t\tlong long f=dp[i][j];\n\t\t\t\tf+=w2[j+1][k];\n\t\t\t\tf+=w1[j][k+1]-w1[i][k+1];\n\t\t\t\tdp[j][k]=min(dp[j][k],f);\n\t\t\t}\n\t\t}\n\t}\n\tans=0x3f3f3f3f3f3f3f3fll;\n\tfz0g(i,n){\n\t\tans=min(ans,dp[i][n+1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 520;\nll a[N][N], s1[N][N], s2[N][N];\nint n;\ninline void Pref(ll x[N][N]){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\t// cout << x[i][j] << \" \";\n\t\t\tx[i][j]+=x[i-1][j]+x[i][j-1]-x[i-1][j-1];\n\t\t}\n\t\t// puts(\"\");\n\t}\n}\ninline ll Sum(ll x[N][N], int x1,int x2,int y1,int y2){\n\treturn x[x2][y2]+x[x1-1][y1-1]-x[x1-1][y2]-x[x2][y1-1];\n}\n\nll f[N][N];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++)if(j!=i){\n\t\t\tscanf(\"%lld\",&a[i][j]);\n\t\t\tif(i<j)s1[i][j]=a[i][j];\n\t\t\telse s2[i][j]=a[i][j];\n\t\t}\n\t}\n\tPref(s1),Pref(s2);\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=0;j<=n+1;j++)\n\t\t\tf[i][j]=1e18;\n\t}\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<max(i,1);j++){\n\t\t\tfor(int k=i+1;k<=n;k++){\n\t\t\t\tll tmp = f[i][j]+Sum(s2,k+1,n,j+1,i)+Sum(s1,i+1,k,i+1,k);\n\t\t\t\t// cout << i << j << \" \"<< f[i][j] << \" \" << k << \" \" << tmp << endl;\n\t\t\t\tf[k][i]=min(f[k][i],tmp);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=f[n][0];\n\tfor(int i=1;i<=n;i++)ans=min(ans,f[n][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 505;\n\n\n// class complex {\n//     long double image, real;\n// public:\n//     long double getImage() {\n//         return image;\n//     }\n//     long double getReal() {\n//         return real;\n//     }\n\n// };\n\n\nint n;\nint a[MAXN][MAXN];\nlong long s1[MAXN][MAXN], s2[MAXN][MAXN], dp[MAXN][MAXN];\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n   // read(FILENAME);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n - 1; j++) {\n            cin >> a[i][j + (i <= j)];\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        long long sum1 = 0, sum2 = 0;\n        for (int j = i; j <= n; j++) {\n            sum1 += a[i][j];\n            sum2 += a[j][i];\n            s1[i][j] = s1[i - 1][j] + sum1;\n            s2[i][j] = s2[i - 1][j] + sum2;\n        } \n    }\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n + 1; j++) {\n            dp[i][j] = 1e18;\n        }\n    }\n    for (int i = 2; i <= n; i++) {\n        dp[i][1] = s1[i - 1][i - 1];\n    }\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            for (int x = i + 1; x <= n; x++) {\n                long long sum1 = s1[x - 1][x - 1] - s1[i - 1][x - 1];\n                long long sum2 = s2[i - 1][n] - s2[j - 1][n] - s2[i - 1][x - 1] + s2[j - 1][x - 1];\n                chkmin(dp[x][i], dp[i][j] + sum1 + sum2);\n            }\n        }\n    }\n    long long ans = s1[n][n];\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i - 1; j++) {\n            chkmin(ans, dp[i][j] + s1[n][n] - s1[i - 1][n]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (int)(n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\n#define int long long\nconst int N = 666;\nconst int inf = 1e18;\nint n, a[N][N], sum[N][N];\n\ninline void U(int &x, int y) { x = min(x, y); }\n\ninline int calc(int u, int d, int l, int r) {\n\treturn sum[d][r] - sum[u - 1][r] - sum[d][l - 1] + sum[u - 1][l - 1];\n}\n\nsigned main(void) {\n\tread(n);\n\trep (i, n) rep (j, n) if (i != j) read(a[i][j]);\n\trep (i, n) rep (j, n) sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];\n\tvector <vector <int> > dp(n + 1, vector <int> (n + 1, inf));\n\tdp[0][0] = 0;\n\trep (i, n) {\n\t\tvector <vector <int> > new_dp(n + 1, vector <int> (n + 1, inf));\n\t\tre0 (p1, i) re0 (p2, i) if (dp[p1][p2] < inf) {\n\t\t\tint cost = calc(i, i, 1, p2) + calc(p1 + 1, i - 1, i, i);\n\t\t\tU(new_dp[p1][p2], dp[p1][p2] + cost);\n\t\t\tU(new_dp[i][p1], dp[p1][p2] + cost);\n\t\t}\n\t\tswap(dp, new_dp);\n\t}\n\tint ans = inf;\n\tre0 (p1, n + 1) re0 (p2, n + 1) U(ans, dp[p1][p2]);\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf (0x7f7f7f7f)\n#define Max(a, b) ((a) > (b) ? (a) : (b))\n#define Min(a, b) ((a) < (b) ? (a) : (b))\ntypedef long long ll;\nusing namespace std;\ntemplate <class T>\ninline void read(T &x){\n    int ch = 0, f = 0; x = 0;\n    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = 1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    if(f) x = -x;\n}\nconst int N = 505;\n#define int ll\nint A[N][N], B[N][N], C[N][N], D[N][N], dp[N][N], n;\nsigned main(){\n    read(n);\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j < i; j++) read(A[j][i]);\n        for(int j = i + 1; j <= n; j++) read(B[i][j]);\n    }\n    for(int i = 0; i <= n + 1; i++)\n        for(int j = i; j <= n + 1; j++){\n            if(i) C[i][j] += C[i-1][j];\n            for(int k = j; k <= n + 1; k++) C[i][j] += A[i][k];\n        }\n    for(int i = n + 1; i >= 0; i--)\n        for(int j = i; j <= n + 1; j++){\n            D[i][j] += D[i+1][j];\n            for(int k = i; k <= j; k++) D[i][j] += B[i][k];\n        }\n    memset(dp, 0x3f, sizeof(dp));\n    dp[0][0] = 0;\n    for(int i = 1; i <= n + 1; i++)\n        for(int j = 0; j < i; j++){\n            for(int k = 0; k <= j; k++) \n                dp[i][j] = min(dp[i][j], dp[j][k] + C[j][i+1] - C[k][i+1] + D[j+1][i]);\n        }\n    int ans = inf;\n    for(int i = 0; i <= n; i++)\n        ans = min(ans, dp[n+1][i]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 510\n#define ll long long\nint n;\nint a[N][N];\nll p[N][N],q[N][N];\nll f[2][N][N];\nvoid upd(ll &a,ll b){a=max(a,b);}\nint main(){\n\tscanf(\"%d\",&n);\n\tll sum=0;\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=1;j<i;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),sum+=a[i][j];\n\t\tfor (int j=i+1;j<=n;++j)\n\t\t\tscanf(\"%d\",&a[i][j]),sum+=a[i][j];\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=i-1;j>=1;--j)\n\t\t\tp[i][j]=p[i][j+1]+a[i][j];\n\t\tfor (int j=1;j<i;++j)\n\t\t\tq[i][j]=q[i][j-1]+a[j][i];\n\t}\n\tint now=1,las=0;\n\tmemset(f[now],128,sizeof f[now]);\n\tf[now][1][0]=0;\n\tfor (int i=1;i<n;++i){\n\t\tswap(now,las);\n\t\tmemset(f[now],128,sizeof f[now]);\n\t\tfor (int j=1;j<=i;++j)\n\t\t\tfor (int k=j-1;k<i;++k)\n\t\t\t\tif (f[las][j][k]>=0){\n\t\t\t\t\tupd(f[now][j][k],f[las][j][k]+p[i+1][j]+q[i+1][k]);\n\t\t\t\t\tupd(f[now][k+1][i],f[las][j][k]+p[i+1][k+1]+q[i+1][i]);\n\t\t\t\t}\n\t}\n\tll ans=0;\n\tfor (int j=1;j<=n;++j)\n\t\tfor (int k=j-1;k<n;++k)\n\t\t\tupd(ans,f[now][j][k]);\n\tprintf(\"%lld\\n\",sum-ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#ifdef _debug\n#define dout(i) cout << #i << ' ' << i << ' '\n#else \n#define dout(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nusing ul = unsigned;\nusing db = double;\nint n;\nconst int maxn = 600;\nll dp[maxn][maxn];\nll w[maxn][maxn];\nll p[maxn][maxn];\nll to[maxn][maxn];\nconst ll inf = 1ll << 59;\nll get(int a, int b, int c, int d){\n\tif(a > b || c > d)return 0;\n\treturn p[b][d] - (c == 0 ? 0 : p[b][c-1]) - (a == 0 ? 0 : p[a-1][d]) + (a == 0 || c == 0 ? 0 : p[a-1][c-1]);\n}\nll get_to(int l, int r){\n\treturn to[r][r] - to[l-1][r] - to[r][l-1] + to[l-1][l-1];\n} \nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)if(i != j)cin >> w[i][j];\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)p[i][j] = p[i-1][j] + p[i][j-1] - p[i-1][j-1] + w[i][j];\n\tfor(int i = 1;i <= n;++i)for(int j = 1;j <= n;++j)to[i][j] = to[i-1][j] + to[i][j-1] - to[i-1][j-1] + (i < j ? w[i][j] : 0);\n\tfor(int i = 1;i <= n;++i)fill(dp[i], dp[i] + maxn, inf);\n\tfor(int i = 1;i <= n;++i){\n\t\tdp[i][1] = get_to(1, i);\n\t\tfor(int j = 2;j <= i;++j){\n\t\t\tfor(int k = 1;k < j;++k){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j-1][k] + get_to(j, i) + get(j, i, 0, k-1));\n\t\t\t}\n\t\t\t// cout << i << ' ' << j << ' ';dout(dp[i][j])<<'\\n';\n\t\t}\n\t}\n\tll res = inf;\n\tfor(int i = 1;i <= n;++i)res = min(res, dp[n][i]);\n\tcout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vvi a(N, vi(N));\n    F0R (i, N) F0R (j, N) if (i != j) re(a[i][j]);\n\n    vvi pref(N, vi(N + 1));\n    F0R (i, N) F0R (j, N) pref[i][j+1] = pref[i][j] + a[i][j];\n\n    vvi ferp(N+1, vi(N));\n    F0R (i, N) F0R (j, N) ferp[i+1][j] = ferp[i][j] + a[i][j];\n\n    map<pii, ll> dp; dp[{ 0, 1 }] = 0;\n\n    FOR (i, 1, N) {\n        decltype(dp) DP;\n        trav (p, dp) {\n            int pc, cc; tie(pc, cc) = p.f; ll cost = p.s;\n            {\n                ll stay = cost;\n                // FOR (v, i - cc, i) stay += a[v][i];\n                stay += ferp[i][i] - ferp[i-cc][i];\n                // F0R (v, i - cc - pc) stay += a[i][v];\n                stay += pref[i][i - cc - pc];\n\n                pii key = mp(pc, cc+1);\n                ll put = min(stay, DP.count(key) ? DP[key] : LLONG_MAX);\n                DP[key] = put;\n            }\n            {\n                ll go = cost + pref[i][i - cc];\n                //F0R (v, i - cc) go += a[i][v];\n                pii key = mp(cc, 1);\n                ll put = min(go, DP.count(key) ? DP[key] : LLONG_MAX);\n                DP[key] = put;\n            }\n        }\n\n        dp = move(DP);\n    }\n\n    ll ans = LLONG_MAX;\n    trav (p, dp) ckmin(ans, p.s);\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst LL Linf=0x3f3f3f3f3f3f3f3fll;\n\nint n,a[511][511];\nLL dp[511][511],ndp[511][511],prex[511][511],prey[511][511];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j)scanf(\"%d\",a[i]+j);\n\t\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t{\n\t\tprex[i][j]=prex[i][j-1]+a[i][j];\n\t\tprey[i][j]=prey[i-1][j]+a[i][j];\n\t}\n\t\n\tmemset(dp,0x3f,sizeof(dp));dp[0][0]=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tmemset(ndp,0x3f,sizeof(ndp));\n\t\tfor(int j=0;j<i;j++)for(int k=0;k<i;k++)if(dp[j][k]!=Linf)\n\t\t{\n\t\t\tif(i==n+1)continue;\n\t\t\tndp[i-1][j]=min(ndp[i-1][j],dp[j][k]+prex[i][j]);\n\t\t\tndp[j][k]=min(ndp[j][k],dp[j][k]+prex[i][k]+prey[i][i]-prey[j][i]);\n\t\t}\n\t\tmemcpy(dp,ndp,sizeof(dp));\n\t}\n\tLL ans=Linf;\n\tfor(int i=0;i<=n;i++)for(int j=0;j<=n;j++)ans=min(ans,dp[i][j]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = b - 1; i >= a; i--)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 501;\n\nll M[MAXN][MAXN] = {0};\nll A[MAXN][MAXN] = {0};\nll B[MAXN][MAXN] = {0};\n\n\nint DP1[MAXN][MAXN][2] = {0};\nbool DP1C[MAXN][MAXN][2] = {0};\n\nint dp1(int i, int j, int kind){\n    if(i > j)return 0;\n    if(kind == -1)return j-i+1;\n    if(DP1C[i][j][kind])return DP1[i][j][kind];\n    int ans = dp1(i,j-1,kind) + dp1(j,n-1,kind-1);\n    DP1[i][j][kind] = ans;\n    DP1C[i][j][kind] = 1;\n    return ans;\n}\n\nint enumerate(int a, int b, int c){\n    if(b == n){\n        return 20958500 + a;\n    }\n    return dp1(0, a-1, 1) + dp1(a, b-1, 0) + dp1(b, c-1, -1);\n}\n\nll DP[20959000] = {0};\nbool DPC[20959000] = {0};\n\nll dp(int a, int b, int c){\n    if(a < 0)return 0;\n    int h = enumerate(a,b,c);\n    if(DPC[h])return DP[h];\n    ll ans1 = A[a][b] + B[a][c] + dp(a-1,b,c);\n    ll ans2 = big*big;\n    if(b > a+1)ans2 = A[a][a+1] + B[a][b-1] + dp(a-1,a+1,b-1);\n    ll ans3 = B[a][a] + dp(a-1, a, a);\n\n    ll ans = ans1;\n    ll pek = 0;\n    if(ans2 < ans){\n        ans = ans2;\n        pek = 1;\n    }\n    if(ans3 < ans){\n        ans = ans3;\n        pek = 2;\n    }\n\n    DPC[h] = 1;\n    DP[h] = ans;\n    //cerr << a << \" \" << b << \" \" << c << \"   pek: \" << pek << \"  ans: \" << ans << \"\\n\";\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n    cin >> n;\n\n    rep(c1,0,n){\n        rep(c2,0,n-1){\n            cin >> a;\n            int c3 = c2;\n            if(c2 >= c1)c3++;\n            M[c1][c3] = a;\n        }\n    }\n\n    rep(c1,0,n){\n        a = 0;\n        rep(c2,c1+1,n+1){\n            A[c1][c2] = a;\n            a += M[c1][c2];\n        }\n        a = 0;\n        per(c2,c1,n){\n            B[c1][c2] = a;\n            a += M[c2][c1];\n        }\n    }\n\n\n    rep(c1,0,n){\n        rep(c2,c1,n){\n            rep(c3,c2,n){\n                dp(c1,c2,c3);\n            }\n        }\n    }\n\n    ll temp = big*big;\n    ll extra = 0;\n    per(c1,0,n){\n        extra += A[c1][n];\n        //cerr << dp(c1,c1+1,n-1) << \" \" << extra << \"\\n\";\n        temp = min(temp, dp(c1,c1+1,n-1) + extra);\n    }\n\n    cout << temp << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvector<vi> a(n, vi(n));\n\trep(i, n) rep(j, n) if(i != j) cin >> a[i][j];\n\t\n\tvector<vector<ll>> dp(n, vector<ll>(n, 1e18));\n\tvector<vector<ll>> ls(n + 1, vector<ll>(n));\n\tvector<vector<ll>> rs(n + 1, vector<ll>(n));\n\t\n\trep(i, n) rep(j, n) rs[j + 1][i] = rs[j][i] + a[i][j];\n\trep(i, n) rep(j, n) ls[j + 1][i] = ls[j][i] + a[j][i];\n\t\n\tvector<ll> sum(n + 1), lsd(n);\n\trep(i, n) lsd[i] = ls[i][i];\n\t\n\tll ans = 1e18;\n\tdp[0][0] = 0;\n\trep(j, n) rep(i, j + 1){\n\t\tfor(int k = n - 1; k > j; k--) sum[k] = sum[k + 1] + rs[j][k] - rs[i][k];\n\t\tll tmp = 0;\n\t\tfor(int k = j + 1; k < n; k++){\n\t\t\tdp[j][k] = min(dp[j][k], dp[i][j] + tmp + sum[k]);\n\t\t\ttmp += lsd[k] - ls[j][k];\n\t\t}\t\t\n\t\tans = min(ans, dp[i][j] + tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define pii pair<int,int>\nusing namespace std;\n\nbool sosu[500001];\nvector<int> vec, ans;\nvector<pii> edg;\nbool dfs(int cur, int cnt) {\n\tif (cnt*vec.back() < cur || cnt * vec[0] > cur) return false;\n\tif (cnt == 0) return true;\n\tfor (int v : vec) {\n\t\tif (dfs(cur - v, cnt - 1)) {\n\t\t\tans.push_back(v);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint n, cnt = 0;\n\tscanf(\"%d\", &n);\n\tint lm = n * (n - 1) / 2;\n\tfor (int i = 2; i <= lm; i++) {\n\t\tif (sosu[i]) continue;\n\t\tif (i < n)\n\t\t\tvec.push_back(i);\n\t\tfor (int j = 2; j*i <= lm; j++) {\n\t\t\tsosu[i*j] = true;\n\t\t}\n\t}\n\tfor (int i = 2; i <= lm; i++) {\n\t\tif (!sosu[i]) {\n\t\t\tif (dfs(i * 2, n)) break;\n\t\t}\n\t}\n\tif (ans.size() == 0) return !printf(\"-1\");\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!ans[i]) continue;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (!ans[i]) break;\n\t\t\tif (!ans[j]) continue;\n\t\t\tedg.push_back({ i + 1,j + 1 });\n\t\t\tans[i]--, ans[j]--;\n\t\t}\n\t}\n\tif (ans[n - 2]) {\n\t\tedg.push_back({ edg[0].first,n });\n\t\tedg.push_back({ edg[0].second, n - 1 });\n\t\tprintf(\"%d\\n\", edg.size() - 1);\n\t\tfor (int i = 1; i < edg.size(); i++)\n\t\t\tprintf(\"%d %d\\n\", edg[i].first, edg[i].second);\n\t}\n\telse if (ans[n - 1]) {\n\t\tedg.push_back({ edg[0].first,n });\n\t\tedg.push_back({ edg[0].second, n });\n\t\tprintf(\"%d\\n\", edg.size() - 1);\n\t\tfor (int i = 1; i < edg.size(); i++)\n\t\t\tprintf(\"%d %d\\n\", edg[i].first, edg[i].second);\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", edg.size());\n\t\tfor (pii v : edg) printf(\"%d %d\\n\", v.first, v.second);\n\t}\n\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <list>\n \n// hloya template v25\n  \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n  \n#include <bits/stdc++.h>\n#include <valarray>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \nvoid bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid upmax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid upmin(T& x, T y) {\n    x = min(x, y);\n}\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-6;\nconst int maxn = (int)3e5 + 12;//, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst double PI = acos(-1.0);\n \nconst int mod = 1e9 + 7;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % mod;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % mod;\n    }\n}\n\nll dp[505][505];\nll a[505][505];\nll p[505][505], p2[505][505];\n\nll sum(int x1, int x2, int y1, int y2) {\n    assert(x1 <= x2 && y1 <= y2);\n    return p[x2][y2] - (x1 ? p[x1 - 1][y2] : 0) - (y1 ? p[x2][y1 - 1] : 0) +\n        ((x1&&y1) ? p[x1 - 1][y1 - 1] : 0);\n}\n\nll sum2(int x1, int x2, int y1, int y2) {\n    assert(x1 <= x2 && y1 <= y2);\n    return p2[x2][y2] - (x1 ? p2[x1 - 1][y2] : 0) - (y1 ? p2[x2][y1 - 1] : 0) +\n        ((x1&&y1) ? p2[x1 - 1][y1 - 1] : 0);\n}\n\nint main() {\n    // files1;\n    fast_io;\n\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            cin >> a[i][j];\n        }\n    memset(dp, -1, sizeof(dp));\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            p[i][j] = (i < j ? a[i][j] : 0);\n            if (i)\n                p[i][j] += p[i - 1][j];\n            if (j)\n                p[i][j] += p[i][j - 1];\n            if (i && j)\n                p[i][j] -= p[i - 1][j - 1];\n\n            p2[i][j] = (i > j ? a[i][j] : 0);\n            if (i)\n                p2[i][j] += p2[i - 1][j];\n            if (j)\n                p2[i][j] += p2[i][j - 1];\n            if (i && j)\n                p2[i][j] -= p2[i - 1][j - 1];\n        }\n\n    ll ans = 0;\n\n    for (int i = 0; i + 1 < n; i++) {\n        ans = max(ans, sum(0, i, i + 1, n - 1) + sum2(0, n - 1, 0, n - 1));\n    }\n\n    // cout << ans << endl;\n    // return 0;\n\n    for (int i = 0; i + 1 < n; i++)\n        for (int j = i + 1; j + 1 < n; j++) {\n            dp[i][j] = sum(0, i, i + 1, n - 1) + sum(i + 1, j, j + 1, n - 1) + \n                        sum2(0, j, 0, j);\n\n            ans = max(ans, dp[i][j] + sum2(i + 1, n - 1, i + 1, n - 1) -\n                sum2(i + 1, j, i + 1, j));\n\n            for (int k = j + 1; k + 1 < n; k++) {\n                dp[j][k] = max(dp[j][k],\n                    dp[i][j] + sum(j + 1, k, k + 1, n - 1) + \n                    sum2(i + 1, k, i + 1, k) - sum2(i + 1, j, i + 1, j));\n            }\n        }\n    ll sum = p[n-1][n-1] + p2[n-1][n-1];\n    cout << sum - ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define ll long long\n#define N 510\nusing namespace std;\nll l[N][N],r[N][N],f[N][N],g[N][N],dp[N][N];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++) scanf(\"%lld\",&l[j][i]);\n\t\tfor(int j=i+1;j<=n;j++) scanf(\"%lld\",&r[i][j]);\n\t}\n\tfor(int i=0;i<=n+1;i++)\n        for(int j=i;j<=n+1;j++)\n\t\t{\n            f[i][j]=i?f[i-1][j]:0;\n            for(int k=j;k<=n+1;k++) f[i][j]+=l[i][k];\n        }\n    for(int i=n+1;i>=0;i--)\n        for(int j=i;j<=n+1;j++)\n\t\t{\n            g[i][j]=g[i+1][j];\n            for(int k=i;k<=j;k++) g[i][j]+=r[i][k];\n        }\n    memset(dp,60,sizeof(dp));\n    dp[0][0]=0;\n    for(int i=1;i<=n+1;i++)\n    \tfor(int j=0;j<n;j++)\n    \t\tfor(int k=0;k<=j;k++)\n    \t\tdp[i][j]=min(dp[i][j],dp[j][k]+f[j][i+1]-f[k][i+1]+g[j+1][i]);\n    ll ans=1e16;\n    for(int i=0;i<=n;i++)\n\t\tans=min(ans,dp[n+1][i]);\n    printf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 510;\n\nint N;\nll A[MAXN][MAXN];\nll ps[MAXN][MAXN];\nll vs[MAXN][MAXN];\nll dp[MAXN][MAXN]; // size of cur comp, prev comp\nll ndp[MAXN][MAXN];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            if (j == i) A[i][j] = 0;\n            else cin >> A[i][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        ps[i][0] = 0;\n        for (int j = 0; j < N; j++)\n            ps[i][j+1] = ps[i][j] + A[i][j];\n        vs[i][0] = 0;\n        for (int j = 0; j < N; j++)\n            vs[i][j+1] = vs[i][j] + A[j][i];\n    }\n\n    for (int i = 0; i < MAXN; i++)\n        for (int j = 0; j < MAXN; j++)\n            dp[i][j] = 1e17;\n    dp[0][0] = 0;\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j <= N; j++)\n            for (int k = 0; k <= N; k++)\n                ndp[j][k] = 1e17;\n\n        for (int j = 0; j <= i; j++)\n        {\n            for (int k = 0; k <= i - j; k++)\n            {\n                if (dp[j][k] > 9e16) continue;\n\n                int ostart = i - j;\n                int mstart = i - j - k;\n\n                // route 1, join comp\n                ll rtot = 0;\n                rtot += vs[i][i] - vs[i][ostart];\n                rtot += ps[i][mstart];\n                ndp[j+1][k] = min (ndp[j+1][k], dp[j][k] + rtot);\n\n                // route 2, start new\n                rtot = 0;\n                rtot += ps[i][ostart];\n                ndp[1][j] = min (ndp[1][j], dp[j][k] + rtot);\n            }\n        }\n\n        for (int j = 0; j <= N; j++)\n            for (int k = 0; k <= N; k++)\n                dp[j][k] = ndp[j][k];\n    }\n\n    ll ans = 1e18;\n    for (int i = 0; i <= N; i++)\n        for (int j = 0; j <= N; j++)\n            ans = min (ans, dp[i][j]);\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DNegativeCycle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector2<int> A(N, N, 0);\n        vector2<ll> B(N, N+1, 0);\n        vector2<ll> C(N+1, N, 0);\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (i != j) cin >> A[i][j];\n                B[i][j+1] = B[i][j] + A[i][j];\n                C[i+1][j] = C[i][j] + A[i][j];\n            }\n        }\n\n        constexpr ll MX = 1e18;\n        vector2<ll> D(N, N+1, MX);\n        D[0][0] = 0;\n        for (int i = 0; i < N; ++i) {\n            for (int j = i; j < N; ++j) {\n                if (D[i][j] != MX) {\n                    ll val = D[i][j];\n                    for (int k = j+1; k < N; ++k) val += B[k][j] - B[k][i];\n                    for (int k = j+1; k <= N; ++k) {\n                        D[j][k] = min(D[j][k], val);\n                        if (k != N) val += C[k][k] - C[j][k] - B[k][j] + B[k][i];\n                    }\n                }\n            }\n        }\n\n\n        ll ans = MX;\n        for (int i = 0; i < N; ++i) ans = min(ans, D[i][N]);\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDNegativeCycle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    vector<vector<int64_t>> row(n, vector<int64_t>(n));\n    vector<vector<int64_t>> col(n, vector<int64_t>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i != j) cin >> a[i][j];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = n - 1; j >= 0; --j) {\n            row[i][j] = a[i][j];\n            if (j + 1 < n) row[i][j] += row[i][j + 1];\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = n - 1; j >= 0; --j) {\n            col[i][j] = a[j][i];\n            if (j + 1 < n) col[i][j] += col[i][j + 1];\n        }\n    }\n    constexpr int64_t kInf = 1'000'000'000'000'000'000;\n    vector<vector<int64_t>> dp(n, vector<int64_t>(n, kInf));\n    dp[n - 1][n - 1] = 0;\n    for (int i = n - 2; i >= 0; --i) {\n        vector<vector<int64_t>> nxt(n, vector<int64_t>(n, kInf));\n        for (int j = 0; j < n; ++j) {\n            for (int k = j; k < n; ++k) {\n                if (dp[j][k] == kInf) continue;\n                int64_t cost = (row[i][i + 1] - (j + 1 < n ? row[i][j + 1] : 0)) + (k + 1 < n ? col[i][k + 1] : 0);\n                nxt[j][k] = min(nxt[j][k], dp[j][k] + cost);\n                cost = (j + 1 < n ? col[i][j + 1] : 0);\n                nxt[i][j] = min(nxt[i][j], dp[j][k] + cost);\n            }\n        }\n        dp = nxt;\n    }\n    int64_t ans = kInf;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) ans = min(ans, dp[i][j]);\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ninline char nc()\n{\n    return getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f;\n}\ntypedef long long ll;\nconst int maxn = 500 + 5;\nll f[maxn][maxn];\nll sum[2][maxn][maxn];\nint n;\nint a[maxn][maxn];\nll cal0(int a, int b)\n{\n    return sum[0][b][b] - sum[0][a][b] - sum[0][b][a] + sum[0][a][a];\n}\nll cal1(int a, int b, int c)\n{\n    return sum[1][n][b] - sum[1][n][a] - sum[1][c][b] + sum[1][c][a];\n}\nvoid init()\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j)\n        {\n            sum[i > j][i][j] = a[i][j];\n        }\n    }\n    for(int k = 0; k < 2; ++k)\n    {\n        for(int i = 1; i <= n; ++i)\n        {\n            for(int j = 1; j <= n; ++j)\n            {\n                sum[k][i][j] += sum[k][i - 1][j] + sum[k][i][j - 1] - sum[k][i - 1][j - 1];\n            }\n        }\n    }\n}\nll solve()\n{\n    init();\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = i + 1; j <= n; ++j)\n        {\n            f[j][i] = cal0(0, i) + cal0(i, j) + cal1(0, i, j);\n        }\n    }\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j < i; ++j)\n        {\n            for(int x = i + 1; x <= n; ++x)\n            {\n                f[x][i] = min(f[x][i], f[i][j] + cal0(i, x) + cal1(j, i, x));\n            }\n        }\n    }\n    ll an = cal0(0, n);\n    for(int i = 1; i <= n; ++i)\n    {\n        ll r = cal0(i, n);\n        an = min(an, cal0(0, i) + r);\n        for(int j = 1; j < i; ++j)\n        {\n            an = min(an, f[i][j] + r);\n        }\n    }\n    return an;\n}\nint main()\n{\n    read(n);\n    for(int i = 1; i <= n; ++i)\n    {\n        for(int j = 1; j <= n; ++j) if(i != j)\n        {\n            read(a[i][j]);\n        }\n    }\n    printf(\"%lld\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, a, b) for(int i = b - 1; i >= a; i--)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 501;\n\nll M[MAXN][MAXN] = {0};\nll A[MAXN][MAXN] = {0};\nll B[MAXN][MAXN] = {0};\n\n\nint DP1[MAXN][MAXN][2] = {0};\nbool DP1C[MAXN][MAXN][2] = {0};\n\nint dp1(int i, int j, int kind){\n    if(i > j)return 0;\n    if(kind == -1)return j-i+1;\n    if(DP1C[i][j][kind])return DP1[i][j][kind];\n    int ans = dp1(i,j-1,kind) + dp1(j,n-1,kind-1);\n    DP1[i][j][kind] = ans;\n    DP1C[i][j][kind] = 1;\n    return ans;\n}\n\nint enumerate(int a, int b, int c){\n    return dp1(0, a-1, 1) + dp1(a, b-1, 0) + dp1(b, c-1, -1);\n}\n\nll DP[20958500] = {0};\nbool DPC[20958500] = {0};\n\nll dp(int a, int b, int c){\n    if(a < 0)return 0;\n    int h = enumerate(a,b,c);\n    if(DPC[h])return DP[h];\n    ll ans1 = A[a][b] + B[a][c] + dp(a-1,b,c);\n    ll ans2 = big*big;\n    if(b > a+1)ans2 = A[a][a+1] + B[a][b-1] + dp(a-1,a+1,b-1);\n    ll ans3 = B[a][a] + dp(a-1, a, a);\n\n    ll ans = ans1;\n    ll pek = 0;\n    if(ans2 < ans){\n        ans = ans2;\n        pek = 1;\n    }\n    if(ans3 < ans){\n        ans = ans3;\n        pek = 2;\n    }\n\n    DPC[h] = 1;\n    DP[h] = ans;\n    //cerr << a << \" \" << b << \" \" << c << \"   pek: \" << pek << \"  ans: \" << ans << \"\\n\";\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n    cin >> n;\n\n    rep(c1,0,n){\n        rep(c2,0,n-1){\n            cin >> a;\n            int c3 = c2;\n            if(c2 >= c1)c3++;\n            M[c1][c3] = a;\n        }\n    }\n\n    rep(c1,0,n){\n        a = 0;\n        rep(c2,c1+1,n+1){\n            A[c1][c2] = a;\n            a += M[c1][c2];\n        }\n        a = 0;\n        per(c2,c1,n){\n            B[c1][c2] = a;\n            a += M[c2][c1];\n        }\n    }\n/*\n    rep(c1,0,n){\n        rep(c2,c1,n){\n            rep(c3,c2,n){\n                dp(c1,c2,c3);\n            }\n        }\n    }\n*/\n    ll temp = big*big;\n    ll extra = 0;\n    per(c1,0,n){\n        extra += A[c1][n];\n        temp = min(temp, dp(c1,c1+1,n-1) + extra);\n    }\n\n    cout << temp << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\nconst ll MAX_N=500,INF=1e18;\nll N,A[MAX_N][MAX_N],psm[MAX_N+1][MAX_N+1],trism[MAX_N+1][MAX_N+1],dp[MAX_N+1][MAX_N+1];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N;\n\tREP(i,N){\n\t\tREP(j,N-1){\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\tll inx=j;\n\t\t\tif(j>=i){\n\t\t\t\tinx++;\n\t\t\t}\n\t\t\tA[i][inx]=a;\n\t\t}\n\t}\n\tREP(i,N){\n\t\tREP(j,N){\n\t\t\tpsm[i+1][j+1]=A[i][j]+psm[i+1][j]+psm[i][j+1]-psm[i][j];\n\t\t}\n\t}\n\tREP(i,N+1){\n\t\tFOR(j,i+1,N+1){\n\t\t\ttrism[i][j]=trism[i][j-1]+psm[j-1][j]-psm[i][j]-psm[j-1][j-1]+psm[i][j-1];\n\t\t}\n\t}\n\tREP(i,N+1){\n\t\tREP(j,N+1){\n\t\t\tdp[i][j]=INF;\n\t\t}\n\t}\n\tdp[0][0]=0;\n\tREP(i,N){\n\t\tFOR(j,i,N){\n\t\t\tFOR(x,j,N+1){\n\t\t\t\tdp[j][x]=min(dp[j][x],dp[i][j]+trism[j][x]+psm[x][i]-psm[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\tREP(i,N+1){\n\t\tans=min(ans,dp[i][N]);\n\t}\n\tREP(i,N+1){\n\t\tREP(j,N+1){\n//\t\t\tprintf(\"dp[%lld][%lld]=%lld\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\t\t\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\nint N;\nint A[555][555];\nint S[555][555];\n\nint neg[555][555];\n\nint sum(int a,int b,int c,int d){\n    return S[b][d]-S[b][c]-S[a][d]+S[a][c];\n}\n\nconst int INF=1001001001001001001;\nint dp[555][555];\nsigned main(){\n    scanf(\"%lld\",&N);\n    rep(i,N){\n        rep(j,i)scanf(\"%lld\",&A[i][j]);\n        for(int j=i+1;j<N;j++)scanf(\"%lld\",&A[i][j]);\n    }\n\n    rep(i,N)rep(j,N){\n        S[i+1][j+1]=A[i][j]+S[i+1][j]+S[i][j+1]-S[i][j];\n    }\n\n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<=N;j++){\n            neg[i][j]=neg[i+1][j]+sum(i,i+1,i+1,j);\n        }\n    }\n\n    fill_n(*dp,555*555,INF);\n    for(int i=1;i<=N;i++)dp[0][i]=neg[0][i];\n    for(int i=0;i<N;i++){\n        for(int j=i+1;j<=N;j++){\n            for(int k=j+1;k<=N;k++){\n                chmin(dp[j][k],dp[i][j]+neg[j][k]+sum(j,k,0,i));\n            }\n        }\n    }\n\n    int ans=INF;\n    for(int i=0;i<N;i++)chmin(ans,dp[i][N]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nlong long f[510][510],a[510][510];\nlong long sc(re int x1,re int y1,re int x,re int y)\n{\n\tif(!x1||!y1)return 0;\n\tif(!x)x=1;if(!y)y=1;\n\treturn a[x1][y1]-a[x-1][y1]-a[x1][y-1]+a[x-1][y-1];\n}\nint main()\n{\n\tre int n;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)\n\t\tfor(re int j=1;j<=n;j++)if(i!=j)scanf(\"%lld\",&a[i][j]);\n\tfor(re int i=1;i<=n;i++)\n\t\tfor(re int j=1;j<=n;j++)a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\tf[0][0]=0;\n\tfor(re int i=0;i<=n;i++)\n\t{\n\t\tfor(re int j=i;j<=n;j++)if(i!=0||j==0)\n\t\t{\n\t\t\tre long long x1=0;\n\t\t\tfor(re int i1=j+1;i1<=n;i1++)\n\t\t\t{\n\t\t\t\tx1+=sc(j,i1,1,i1)+sc(i1,i1-1,i1,i);\n\t\t\t\tf[j+1][i1]=std::max(f[j+1][i1],f[i][j]+x1);\n\t\t\t\t//printf(\"**%d %d %lld %lld %lld %lld\\n\",j+1,i1,x1,f[j+1][i1],a[2][1],a[1][1]);\n\t\t\t}\n\t\t}\n\t}\n\tre long long ans=0;\n\tfor(re int i=1;i<=n;i++)ans=std::max(ans,f[i][n]);\n\tprintf(\"%lld\\n\",a[n][n]-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=510;\nll a[N][N],qz[N][N],f[N][N],qz2[N][N];\nll mymin(ll x,ll y) {return x<y?x:y;}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tqz[i][j]=qz[i-1][j]+qz[i][j-1]-qz[i-1][j-1]+a[i][j];\n\t\t\tqz2[i][j]=qz2[i-1][j]+qz2[i][j-1]-qz2[i-1][j-1]+(i<j?a[i][j]:0);\n\t\t}\n\tmemset(f,60,sizeof(f));\n\tf[0][1]=0;\n\tfor(int i=0;i<=n-1;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tfor(int k=j+1;k<=n+1;k++){\n\t\t\t\tll t1=qz[n][j-1]-qz[k-1][j-1]-qz[n][(i>0?i-1:0)]+qz[k-1][(i>0?i-1:0)];\n\t\t\t\tll t2=qz2[k-1][k-1]-qz2[j-1][k-1]-qz2[k-1][j-1]+qz2[j-1][j-1];\n\t\t\t\tf[j][k]=mymin(f[j][k],f[i][j]+t1+t2);\n\t\t\t}\n\tll Ans=1e18;\n\tfor(int i=0;i<=n;i++) Ans=mymin(Ans,f[i][n+1]);\n\tprintf(\"%lld\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst long long inf=0x3f3f3f3f3f3f3f3f;\nint n;\nlong long s1[510][510],s2[510][510],dp[510][510],ans=inf;\nlong long get1(int x,int y){return s1[y][y]-s1[x][y]-s1[y][x]+s1[x][x];}\nlong long get2(int w,int x,int y){return s2[y][w]-s2[x][w];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(i!=j)scanf(\"%d\",i<j?&s1[i][j]:&s2[i][j]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)s1[i][j]+=s1[i][j-1],s2[i][j]+=s2[i][j-1];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)s1[i][j]+=s1[i-1][j],s2[i][j]+=s2[i-1][j];\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0]=0;\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<i+(!i);++j)\n\t\t\tfor(int k=i+1;k<=n;++k)\n\t\t\t\tdp[k][i]=min(dp[k][i],dp[i][j]+get1(i,k)+get2(j,i,k));\n//\tfor(int i=1;i<=n;++i)\n//\t{\n//\t\tfor(int j=0;j<i;++j)printf(\"%lld \",dp[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=0;i<n;++i)ans=min(ans,dp[n][i]);\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9')ch=getchar();\n\twhile (ch>='0'&&ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\nconst ll inf=1e15;\nint n,a[505][505];\nll f[505][505],p[505][505],q[505][505];\nll min(ll a,ll b){return a<b?a:b;}\nint main()\n{\n\tn=read();\n\tfor (int i=0;i<n;++i)\n\tfor (int j=0;j<n;++j)\n\tif (i!=j)\n\t{\n\t\ta[i][j]=read();\n\t\tif (i<j)\n\t\tf[i][j]=inf;\n\t}\n\tfor (int i=n-1;i>=0;--i)\n\t{\n\t\tfor (int j=i+1;j<=n;++j)\n\t\tp[i][j]=p[i][j-1]+a[i][j];\n\t\tfor (int j=i+1;j<=n;++j)\n\t\tp[i][j]+=p[i+1][j];\n\t}\n\tfor (int i=0;i<n;++i)\n\t{\n\t\tfor (int j=n-1;j>i;--j)\n\t\tq[i][j]=q[i][j+1]+a[j][i];\n\t\tif (i)\n\t\tfor (int j=n-1;j>i;--j)\n\t\tq[i][j]+=q[i-1][j];\n\t}\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=i+1;j<=n+1;++j)\n\t\tf[i][j]=p[0][i-1]+p[i][j-1]+q[i-1][j];\n\tfor (int i=1;i<n;++i)\n\tfor (int j=i+1;j<=n;++j)\n\tfor (int k=j+1;k<=n+1;++k)\n\tf[j][k]=min(f[j][k],f[i][j]+\n\tp[j][k-1]+q[j-1][k]-q[i-1][k]);\n\tprintf(\"%lld\\n\",f[n][n+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nint main() {\n    setIO();\n\n    int N; re(N); vvi a(N, vi(N));\n    F0R (i, N) F0R (j, N) if (i != j) re(a[i][j]);\n\n    map<pii, ll> dp; dp[{ 0, 1 }] = 0;\n\n    FOR (i, 1, N) {\n        decltype(dp) DP;\n        trav (p, dp) {\n            auto [pc, cc] = p.f; ll cost = p.s;\n            {\n                ll stay = cost;\n                FOR (v, i - cc, i) stay += a[v][i];\n                F0R (v, i - cc - pc) stay += a[i][v];\n                pii key{pc, cc+1};\n                DP[key] = min(stay, DP.count(key) ? DP[key] : LLONG_MAX);\n            }\n            {\n                ll go = cost;\n                F0R (v, i - cc) go += a[i][v];\n                pii key{cc, 1};\n                DP[key] = min(go, DP.count(key) ? DP[key] : LLONG_MAX);\n            }\n        }\n\n        dp = move(DP);\n    }\n\n    ll ans = LLONG_MAX;\n    trav (p, dp) ckmin(ans, p.s);\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 505\n#define ll long long\n#define inf 0x3f3f3f3f3f3f3f3fll\nint n, A[N][N];\nll sum1[N][N], sum2[N][N], f[N][N];\nll Getsum1(int La, int Ra, int Lb, int Rb)\n{\n\tif (La > Ra || Lb > Rb)return 0;\n\treturn sum1[Ra][Rb] - sum1[Ra][Lb - 1] - sum1[La - 1][Rb] + sum1[La - 1][Lb - 1];\n}\nll Getsum2(int La,int Ra,int Lb,int Rb)\n{\n\tif (La > Ra || Lb > Rb)return 0;\n\treturn sum2[Ra][Rb] - sum2[Ra][Lb - 1] - sum2[La - 1][Rb] + sum2[La - 1][Lb - 1];\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (i != j)\n\t\t\t\tscanf(\"%d\", &A[i][j]);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\tsum1[i][j] = sum1[i - 1][j] + sum1[i][j - 1] - sum1[i - 1][j - 1] + (i > j ? A[i][j] : 0);\n\t\t\tsum2[i][j] = sum2[i - 1][j] + sum2[i][j - 1] - sum2[i - 1][j - 1] + (i < j ? A[i][j] : 0);\n\t\t}\n\tn++;\n\tmemset(f, 0x3f, sizeof(f));\n\tll ans = inf;\n\tf[0][0] = 0;\n\tfor (int i = 1; i < n; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tfor (int k = 0; k <= j; k++)\n\t\t\t\tf[i][j] = min(f[i][j], f[j][k] + Getsum1(i + 1, n - 1, k + 1, j) + Getsum2(j + 1, i, j + 1, i));\n\t\t\tif (i == n - 1)\n\t\t\t\tans = min(ans, f[i][j]);\n\t\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n#define inf    0x7f7f7f7f\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x7f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < inf)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = inf;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=500;\nconst LL INF=(1LL<<50)-1;\n\nint n,a[N+9][N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tfor (int j=1;j<=n;++j)\n\t  if (i^j) scanf(\"%d\",&a[i][j]);\n}\n\nLL sum[2][N+9][N+9];\n\nvoid Get_sum(){\n  for (int i=1;i<=n;++i){\n\tfor (int j=1;j<=n;++j){\n\t  if (i^j) sum[i>j][i][j]=a[i][j];\n\t  for (int k=0;k<2;++k) sum[k][i][j]+=sum[k][i][j-1];\n\t}\n\tfor (int j=1;j<=n;++j)\n\t  for (int k=0;k<2;++k) sum[k][i][j]+=sum[k][i-1][j];\n  }\n}\n\nLL Get_sum(int id,int x0,int y0,int x1,int y1){\n  return sum[id][x1][y1]-sum[id][x0-1][y1]-sum[id][x1][y0-1]+sum[id][x0-1][y0-1];\n}\n\nLL dp[N+9][N+9],ans;\n\nvoid Get_dp(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=n;++j) dp[i][j]=INF;\n  dp[0][0]=0;\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<i||j<1;++j)\n\t  for (int k=i+1;k<=n;++k)\n\t\tdp[k][i]=min(dp[k][i],dp[i][j]+Get_sum(1,k+1,j+1,n,i)+Get_sum(0,i+1,i+1,k,k));\n  ans=INF;\n  for (int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n}\n\nvoid work(){\n  Get_sum();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=505;\nint n,a[Maxn][Maxn];\nLL dp[Maxn][Maxn];\nLL S1[Maxn][Maxn],S2[Maxn][Maxn];\nLL Q1(int x1,int x2,int y1,int y2){\n\tif (x1>x2 ||y1>y2) return 0;\n\treturn S1[x2][y2]-S1[x1-1][y2]-S1[x2][y1-1]+S1[x1-1][y1-1];\n}\nLL Q2(int x1,int x2,int y1,int y2){\n\tif (x1>x2 || y1>y2) return 0;\n\treturn S2[x2][y2]-S2[x1-1][y2]-S2[x2][y1-1]+S2[x1-1][y1-1];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tif (i==j) continue;\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif (i<j){\n\t\t\t\tS1[i][j]=a[i][j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS2[i][j]=a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tS1[i][j]+=S1[i-1][j]+S1[i][j-1]-S1[i-1][j-1]; \n\t\t\tS2[i][j]+=S2[i-1][j]+S2[i][j-1]-S2[i-1][j-1]; \n\t\t}\n\t}\n\tfor (int i=0;i<Maxn;i++){\n\t\tfor (int j=0;j<Maxn;j++){\n\t\t\tdp[i][j]=1e18;\n\t\t}\n\t}\n\tLL ans=1e18;\n\tfor (int i=1;i<=n;i++){\n\t\tdp[i][0]=Q1(1,i,1,i);\n\t}\n\t//cout<<S1[3][3]<<' '<<S2[3][3]<<endl;\n\t//cout<<Q1(1,3,1,3)<<\" \"<<Q2(1,3,1,3)<<endl;\n\tfor (int i=2;i<=n;i++){\n\t\tfor (int j=1;j<i;j++){\n\t\t\tfor (int k=0;k<j;k++){\n\t\t\t\tif (dp[j][k]==1e18) continue;\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+Q1(j+1,i,j+1,i)+Q2(j+1,i,1,k));\n\t\t\t}\n\t\t//\tcout<<i<<' '<<j<<' '<<dp[i][j]<<endl;\n\t\t}\n\t}\n\tans=Q1(1,n,1,n);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<i;j++){\n\t\t\tans=min(ans,dp[i][j]+Q1(i+1,n,i+1,n)+Q2(i+1,n,1,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n\nconst int maxN=505;\n\nint n;\nLL f[maxN+1][maxN+1],A[maxN+1][maxN+1],s1[maxN+1][maxN+1],s2[maxN+1][maxN+1];\n\ninline LL read()\n{\n\tLL num=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch))num=(num<<3)+(num<<1)+(ch^48),ch=getchar();\n\treturn num*f;\n}\n\ninline LL query(int xu,int yu,int xd,int yd,LL sum[maxN+1][maxN+1])\n{\n\treturn sum[xd][yd]-sum[xu-1][yd]-sum[xd][yu-1]+sum[xu-1][yu-1];\n}\n\nint main()\n{\n\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i!=j)A[i][j]=read();\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j)s1[i][j]+=A[i][j];\n\t\t\tif(i>j)s2[i][j]+=A[i][j];\n\t\t}\n\t\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tf[i][0]=query(1,1,i+1,i,s2);\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tf[i][i]=max(f[i][i],f[i-1][j]+query(i+1,j+1,i+1,i,s2)+query(1,i+1,i,i+1,s1));\n\t\t\tfor(int k=0;k<j;k++)\n\t\t\t\tf[i][j]=max(f[i][j],f[j-1][k]+query(j+1,k+1,i+1,i,s2)+query(1,j+1,j,i+1,s1));\n\t\t}\n\t}\n\n\tLL ans=0;\n\tfor(int i=0;i<=n-1;i++)ans=max(ans,f[n-1][i]);\n\tprintf(\"%lld\",s1[n][n]+s2[n][n]-ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nint main(){\n  int n;\n  cin >> n;\n  vector<vector<int>> a(n, vector<int>(n, 0));\n  for(int i=0; i<n; i++){\n    for(int j=0; j<n-1; j++){\n      int k = j>=i ? j+1 : j;\n      cin >> a[i][k];\n    }\n  }\n\n  long long inf = 1ll<<58;\n\n  vector<vector<long long>> b(n+2, vector<long long>(n+2, 0));\n  for(int i=0; i<n; i++){\n    for(int j=0; j<n; j++){\n      b[i+2][j+2] = a[i][j];\n    }\n  }\n  n += 2;\n\n  vector<vector<long long>> bsum_row = b;\n  for(int i=0; i<n; i++){\n    for(int j=1; j<n; j++){\n      bsum_row[i][j] += bsum_row[i][j-1];\n    }\n  }\n  vector<vector<long long>> bsum_col = b;\n  for(int i=1; i<n; i++){\n    for(int j=0; j<n; j++){\n      bsum_col[i][j] += bsum_col[i-1][j];\n    }\n  }\n\n  // dp[ p ][ p- ] := min cost\n  vector<vector<long long>> dp(n, vector<long long>(n, inf));\n  dp[1][0] = 0;\n  for(int i=2; i<n; i++){\n    for(int p0=i-1; p0>0; p0--){\n      for(int p1=p0-1; p1>=0; p1--){\n        // use -1 (i-j)\n        {\n          long long cost = 0;\n          // for(int k=0; k<p0; k++){\n          //   cost += b[i][k];\n          // }\n          if(p0-1>=0) cost += bsum_row[i][p0-1];\n          dp[i][p0] = min(dp[i][p0], dp[p0][p1] + cost);\n        }\n\n        {\n          // dont use\n          long long cost = 0;\n          // for(int k=0; k<p1; k++){\n          //   cost += b[i][k];\n          // }\n          if(p1-1>=0) cost += bsum_row[i][p1-1];\n          // for(int k=p0; k<i; k++){\n          //   cost += b[k][i];\n          // }\n          cost += bsum_col[i-1][i];\n          if(p0-1 >= 0) cost -= bsum_col[p0-1][i];\n          dp[p0][p1] += cost;\n        }\n      }\n    }\n  }\n\n  long long ans = inf;\n  for(int i=0; i<n; i++){\n    for(int j=0; j<i; j++){\n      ans = min(ans, dp[i][j]);\n    }\n  }\n  println(ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 505;\nll a[maxN][maxN];\nll dp[maxN][maxN];\nll in_minus[maxN][maxN];\nll in_ones[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == i) continue;\n            cin >> a[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = 1e18;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (j > i) {\n                in_ones[i][j] = in_ones[i][j - 1];\n                in_minus[i][j] = in_minus[i][j - 1];\n            }\n            // delete all minus ones\n            for (int k = i; k < j; k++) {\n                in_minus[i][j] += a[k][j];\n                in_ones[i][j] += a[j][k];\n            }\n        }\n    }\n    for (int last = 0; last < n; last++) {\n        dp[0][last] = in_minus[0][last];\n    }\n    for (int i = 0; i < n; i++) {\n        for (int last = 0; last <= i; last++) {\n            for (int j = i + 1; j < n; j++) {\n                // [last, i], [i + 1, j]\n                ll total = in_minus[i + 1][j];\n                ll minus_last = in_minus[last][j] - in_minus[last][i] - in_minus[i + 1][j];\n                ll one_last = in_ones[last][j] - in_ones[last][i] - in_ones[i + 1][j];\n                ll one_all = in_ones[0][j];\n                one_all -= in_ones[0][i];\n                one_all -= in_ones[i + 1][j];\n                one_all -= one_last;\n                total += one_all;\n                dp[i + 1][j] = min(dp[i + 1][j], dp[last][i] + total);\n            }\n        }\n    }\n    ll best = 1e18;\n    for (int i = 0; i < n; i++) best = min(best, dp[i][n - 1]);\n    cout << best;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#define N 505\n#define ll long long\nusing namespace std;\nint n;\nint s[N][N];\nll sum[N][N][2],f[N][N];\nll get(int x,int y,int z){return sum[y][z+1][0]-sum[x][z+1][0]+sum[y+1][z][1];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tscanf(\"%d\",&s[i][j]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tsum[i][j][0]=s[j][i],sum[i][j][1]=s[i][j];\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t\tsum[i][j][1]+=sum[i][j-1][1];\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t\tsum[i][j][0]+=sum[i-1][j][0];\n\tfor(int i=n+1;i>=0;i--)\n\t\tfor(int j=n+1;j>=0;j--)\n\t\t\tsum[i][j][0]+=sum[i][j+1][0];\n\tfor(int i=n+1;i>=0;i--)\n\t\tfor(int j=n+1;j>=0;j--)\n\t\t\tsum[i][j][1]+=sum[i+1][j][1];\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tf[i][j]=1e17;\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=max(0,i-1);j++)\n\t\t\tfor(int k=i+1;k<=n;k++)\n\t\t\t\tf[k][i]=min(f[k][i],f[i][j]+get(j,i,k));\n\tll mi=get(0,0,n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tmi=min(mi,f[j][i]+get(i,j,n));\n\tprintf(\"%lld\\n\",mi);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=505;\nconst long long INF=4557430888798830399;\nint n;\nlong long a[N][N];\nlong long s1[N][N],s2[N][N];\nlong long f[N][N];\nlong long calc1(int l1,int r1,int l2,int r2)\n{\n\tswap(l1,l2);\n\tswap(r1,r2);\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n//\tcerr<<\"Calc1\"<<l1<<\" \"<<r1<<\" \"<<l2<<\" \"<<r2<<\" res:\"<<s1[r1][r2]<<\"\\n\";\n\treturn s1[r1][r2]-s1[l1-1][r2]-s1[r1][l2-1]+s1[l1-1][l2-1];\n}\nlong long calc2(int l1,int r1,int l2,int r2)\n{\n\tif(l1>r1) return 0;\n\tif(l2>r2) return 0;\n//\tcerr<<\"Calc-1\"<<l1<<\" \"<<r1<<\" \"<<l2<<\" \"<<r2<<\" res:\"<<s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1]<<\"\\n\";\n\treturn s2[r1][r2]-s2[l1-1][r2]-s2[r1][l2-1]+s2[l1-1][l2-1];\n}\nint main()\n{\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j) scanf(\"%lld\",&a[i][j]);\n//\tfor(int i=1;i<=n;i++)\n//\t{\n//\t\tfor(int j=1;j<=n;j++)\n//\t\t\tprintf(\"%lld \",a[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tfor(int j=1;j<=n+1;j++)\n\t\t{\n\t\t\ts1[i][j]=s1[i-1][j]+s1[i][j-1]-s1[i-1][j-1];\n\t\t\tif(i>j) s1[i][j]+=a[i][j];\n\t\t\ts2[i][j]=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1];\n\t\t\tif(i<j) s2[i][j]+=a[i][j];\n\t\t}\n//\tfor(int i=1;i<=n+1;i++)\n//\t{\n//\t\tfor(int j=1;j<=n+1;j++)\n//\t\t\tprintf(\"%lld \",s1[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tmemset(f,63,sizeof(f));\n\tf[0][0]=0;\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tif(f[i][j]<INF)\n\t\t\t\tfor(int k=j+1;k<=n+1;k++)\n\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long t=calc1(i+1,j,k+1,n+1)+calc2(j+1,k,j+1,k);\n\t\t\t\t\t\tf[j][k]=min(f[j][k],f[i][j]+t);\n//\t\t\t\t\t\tcerr<<\"f\"<<i<<\" \"<<j<<\" \"<<f[i][j]<<\" ccc\"<<\" \"<<t<<\" \"<<\"to \"<<j<<\" \"<<k<<\" \"<<f[j][k]<<\"\\n\";\n\t\t\t\t\t}\n\tlong long res=INF;\n\tfor(int i=0;i<=n;i++)\n\t\tres=min(res,f[i][n+1]);\n\tprintf(\"%lld\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N    510\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x3f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 0x3f3f3f3f)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 0x3f3f3f3f;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%d\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nconst int N=505;\nint n,x,i,j,k;\nll s[2][N][N],f[N][N],ans=1ll<<60;\ninline ll ask(int o,int x1,int x2,int y1,int y2){return s[o][x2][y2]-s[o][x1-1][y2]-s[o][x2][y1-1]+s[o][x1-1][y1-1];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tfor(j=1;j<i;++j)scanf(\"%d\",&x),s[0][j][i]=x;\n\t\tfor(j=i+1;j<=n;++j)scanf(\"%d\",&x),s[1][i][j]=x;\n\t}\n\tfor(i=1;i<=n;++i)for(j=2;j<=n;++j)s[0][i][j]+=s[0][i][j-1],s[1][i][j]+=s[1][i][j-1];\n\tfor(i=2;i<=n;++i)for(j=1;j<=n;++j)s[0][i][j]+=s[0][i-1][j],s[1][i][j]+=s[1][i-1][j];\n\tfor(i=2;i<=n+1;++i)for(j=i-1,f[i][1]=ask(1,1,i-1,1,i-1)-ask(0,1,i-1,1,i-1);j>1;--j){\n\t\tfor(f[i][j]=1ll<<60,k=j-1;k>=1;--k)\n\t\t\tf[i][j]=std::min(f[i][j],f[j][k]+ask(1,j,i-1,j,i-1)\n\t\t\t\t-ask(0,j,i-1,j,i-1)-ask(0,k,j-1,j,i-1));\n\t}\n\tfor(i=n;i;--i)ans=std::min(ans,f[n+1][i]);ans+=s[0][n][n];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"2,Ofast,inline\")\n#include <bits/stdc++.h>\n#define LL long long\n#define P pair<int, int>\nconst LL N = 6e4 + 10;\nconst LL inf = 0x3f3f3f3f;\nconst LL mod = 998244353;\nusing namespace std;\ntemplate <typename tp>\ninline void read(tp &x)\n{\n    x = 0; char c = getchar(); bool f = 0;\n    for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar()) ;\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar()) ;\n    if (f) x = -x;\n}\nLL n,cost[510][510];\n// sum_along i j -> SUM(1->i) cost[i][j];\n// along i j -> i到j之间所有顺序cost\nLL along[510][510],sum_along[510][510];\nLL inverse[510][510],sum_inverse[510][510];\nLL dp[510][510];\nsigned main()\n{\n    read(n);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n        {\n            if(i==j) continue;\n            read(cost[i][j]);\n        }\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            sum_along[j][i]=sum_along[j-1][i]+cost[j][i];\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n+1;j++)\n            along[i][j]=along[i][j-1]+sum_along[j-1][j]-sum_along[i-1][j];\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            sum_inverse[j][i]=sum_inverse[j-1][i]+cost[i][j];\n    for(int i=1;i<=n+1;i++)\n        for(int j=n+1;j>i;j--)\n            inverse[i][j]=inverse[i][j+1]+sum_inverse[i][j];\n    // for(int i=0;i<=n;i++)\n    //     for(int j=0;j<=n;j++)\n    //         printf(\"along[%d][%d]=%d\\n\",i,j,along[i][j]);\n    // for(int i=0;i<=n;i++)\n    //     for(int j=0;j<=n;j++)\n    //         printf(\"inverse[%d][%d]=%d\\n\",i,j,inverse[i][j]);\n    memset(dp,0x3f,sizeof(dp));\n    dp[0][0]=0;\n    for(int i=0;i<=n;i++)\n        for(int j=i;j<=n;j++)\n            if(dp[i][j]<1e18)\n                for(int k=j+1;k<=n+1;k++)\n                {\n                    dp[j][k]=min(dp[j][k],dp[i][j]+along[j+1][k]+inverse[j][k+1]-inverse[i][k+1]);\n                    // cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[j][k]<<\" \"<<\n                    // along[j+1][k]<<\" \"<<inverse[j][k+1]-inverse[i][k+1]<<endl;\n                }\n    LL ans=1e18;\n    for(int i=0;i<=n;i++)\n        ans=min(ans,dp[i][n+1]);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cassert>\n#include<cstdlib>\nusing namespace std;\n#define N 505\n#define ll long long\n#define INF 0x3f3f3f3f\nint n,a[N];\nll sum=0;\nint main() \n{\n\t\n    //freopen(\"cycle.in\",\"r\",stdin);\n    //freopen(\"cycle.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tsum+=a[i];\n\t}\n\tprintf(\"%lld\\n\",1ll*sum/n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/02/11] 10:15:26\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\nint main()\n{\n    const auto N = in<int>();\n    auto fass    = make_v({N, N}, 0LL);\n    auto bass    = make_v({N, N}, 0LL);\n    ll btotal    = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) { continue; }\n            if (i < j) {\n                fass[i][j] = in<ll>();\n            } else {\n                bass[i][j] = -in<ll>();\n                btotal -= bass[i][j];\n            }\n        }\n    }\n    auto fsss = fass, bsss = bass;\n    for (int i = 0; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            fsss[i][j] += fsss[i][j - 1];\n            bsss[i][j] += bsss[i][j - 1];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            fsss[i][j] += fsss[i - 1][j];\n            bsss[i][j] += bsss[i - 1][j];\n        }\n    }\n    auto sum = [&](const auto sss, const int il, const int iu, const int jl, const int ju) {\n        ll ans = sss[iu - 1][ju - 1];\n        if (il > 0) { ans -= sss[il - 1][ju - 1]; }\n        if (jl > 0) { ans -= sss[iu - 1][jl - 1]; }\n        if (il > 0 and jl > 0) { ans += sss[il - 1][jl - 1]; }\n        return ans;\n    };\n    auto fsum = [&](const int, const int p, const int np) { return sum(fsss, p, np, p, np); };\n    auto bsum = [&](const int pp, const int p, const int np) { return sum(bsss, p, np, pp, np); };\n    auto memo = make_v({N + 1, N + 1}, -1LL);\n    auto dp   = mfp([&](auto&& self, const int pp, const int p) -> ll {\n        if (p == N) { return 0; }\n        if (memo[pp][p] != -1LL) { return memo[pp][p]; }\n        ll ans = inf_v<ll>;\n        for (int np = p + 1; np <= N; np++) {\n            const ll fore = fsum(pp, p, np);\n            const ll back = bsum(pp, p, np);\n            SHOW(pp, p, np, fore);\n            SHOW(pp, p, np, back);\n            chmin(ans, fore + back + self(self, p, np));\n        }\n        SHOW(pp, p, ans);\n        return memo[pp][p] = ans;\n    });\n    SHOW(btotal);\n    outln(dp(0, 0) + btotal);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\n#define show(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nstruct P {\n    ll x, y;\n    char ty;\n};\nostream& operator<<(ostream& os, const P& p) {\n    return os << p.ty << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\nconst int MN = 502;\nint n;\nll cost[MN][MN];\nll rcost[MN][MN];\nll cost_sm[MN][MN];\nll rcost_sm[MN][MN];\n\nll memo[MN][MN][MN];\nll calc(int a, int b, int c) {\n    /*\n    [0, a) : 2\n    [a, b) : 1\n    [b, c) : 0\n     */\n    if (c == n) return 0;\n    if (memo[a][b][c] != -1) return memo[a][b][c];\n    ll ans = TEN(18);\n    /*\n      c = 0\n      prohibit\n      2 <- 0\n      0 -> 0\n     */\n    ans = min(ans, cost_sm[c][a] + (rcost_sm[c][c] - rcost_sm[c][b]) + calc(a, b, c + 1));\n    /*\n      c = -1\n      prohibit\n      1 <- -1      \n     */\n    ans = min(ans, (cost_sm[c][b]) + calc(b, c, c + 1));\n\n    return memo[a][b][c] = ans;\n}\n\n\nint main() {\n    memset(memo, -1, sizeof(memo));\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            cin >> cost[i][j];\n            rcost[j][i] = cost[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cost_sm[i][j + 1] = cost_sm[i][j] + cost[i][j];\n            rcost_sm[i][j + 1] = rcost_sm[i][j] + rcost[i][j];\n        }\n    }\n\n\n    cout << calc(0, 0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::cerr;\nusing std::endl;\n\nconst int N = 505;\n\nint n;\nlong long A[N][N];\nlong long B[N][N];\nlong long f[N][N];\nlong long ans;\n\ninline long long get_val(int k, int j, int i) {\n  long long ret1 = B[j + 1][i];\n  long long ret2 = A[n][j] - A[n][k] - A[i][j] + A[i][k];\n  return ret1 + ret2;\n}\n\nint main() {\n//   freopen(\"data\", \"r\", stdin);\n  std::ios::sync_with_stdio(0);\n  std::cin.tie(0);\n  std::cin >> n;\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j)\n      if (i != j)\n        std::cin >> A[i][j];\n  for (int j = 1; j <= n; ++j)\n    for (int i = j; i; --i)\n      B[i][j] = B[i + 1][j] + B[i][j - 1] - B[i + 1][j - 1] + A[i][j];\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j)\n      A[i][j] += A[i - 1][j] + A[i][j - 1] - A[i - 1][j - 1];\n  ans = 1e18;\n  for (int i = 1; i < n; ++i) {\n    f[i][0] = get_val(0, 0, i);\n    ans = std::min(ans, f[i][0] + get_val(0, i, n));\n    for (int j = 1; j < i; ++j) {\n      f[i][j] = 1e18;\n      for (int k = 0; k < j; ++k) {\n        f[i][j] = std::min(f[i][j], f[j][k] + get_val(k, j, i));\n      }\n      ans = std::min(ans, f[i][j] + get_val(j, i, n));\n    }\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint a[510][510];\nlong long f[510][510],sum[510][510],cnt[510][510];\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read();\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)if(i!=j)a[i][j]=read();\n    }\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)sum[i][j]=sum[i][j-1]+a[i][j];\n    }\n    for(int i=1;i<=n;i++)\n    {\n    \tfor(int j=1;j<=n;j++)cnt[i][j]=cnt[i][j-1]+sum[j][i]-sum[j][j-1];\n    }\n    for(int i=n-1;i>=1;i--)\n    {\n    \tfor(int j=i+1;j<=n;j++)\n    \t{\n    \t\tf[i][j]=cnt[j-1][j-1]-cnt[j-1][i-1];\n    \t\tlong long tot=0,mn=0;\n    \t\tfor(int k=n;k>j;k--)\n    \t\t{\n    \t\t\ttot+=sum[k][j-1]-sum[k][i-1];\n    \t\t\tif(k==n)mn=f[j][k]+tot;\n    \t\t\telse mn=min(mn,f[j][k]+tot);\n    \t\t}f[i][j]+=mn;\n    \t}\n    }long long ans=f[1][2];\n    for(int i=3;i<=n;i++)ans=min(ans,f[1][i]);\n    printf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// D - Negative Cycle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tINF\t1e16\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tvector<vector<long long> > a(n, vector<long long>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tif (i != j) cin >> a[i][j];\n\n\tvector<vector<long long> > dp(n + 1, vector<long long>(n + 1, INF));\n\tdp[0][0] = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 0; k <= j; k++) {\n\t\t\t\tlong long r = dp[j][k];\n\t\t\t\tfor (int jj = k; jj < j; jj++)\n\t\t\t\t\tfor (int ii = i; ii < n; ii++)\n\t\t\t\t\t\tr += a[ii][jj];\n\t\t\t\tfor (int jj = j; jj < i; jj++)\n\t\t\t\t\tfor (int ii = jj + 1; ii < i; ii++)\n\t\t\t\t\t\tr += a[jj][ii];\n\t\t\t\tdp[i][j] = min(dp[i][j], r);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << *min_element(dp[n].begin(),dp[n].end()) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n#include <chrono>\n#include <climits>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n// default_random_engine generator;\n// mt19937 rnd(1);\n\nconst int MAXN = 555;\n\nll a[MAXN][MAXN];\nll dp[MAXN][MAXN];\n\nll u[MAXN][MAXN];\nll v[MAXN][MAXN];\n\nll f[MAXN][MAXN];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    int n;\n    cin >> n;\n\n    ll sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) {\n                continue;\n            }\n            cin >> a[i][j];\n            sum += a[i][j];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i; j < n - 1; ++j) {\n            u[j][i] = u[j][i + 1];\n        }\n\n        for (int j = i + 1; j < n; ++j) { \n            for (int k = i; k < j; ++k) {\n                u[k][i] += a[i][j];\n            }\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i + 1; j < n; ++j) {\n            v[i][j] = v[i + 1][j];\n        }\n        ll x = 0;\n        for (int j = i + 1; j < n; ++j) {\n            x += a[j][i];\n            v[i][j] += x;\n        }\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = n - 1; j >= i; --j)  {\n            dp[i][j] = max(dp[i][j], dp[i][j + 1] + v[i][j + 1] - v[i][j]);\n            for (int k = j + 1; k < n; ++k) {\n                dp[i][j] = max(dp[i][j], dp[j + 1][k] + v[i][k] - v[i][j] + u[j][i]);\n            }\n        }\n    }\n\n    cout << sum - dp[0][0] << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#define int long long\nusing namespace std;\nconst int N=502;\nconst int inf=1e15+2;\nint ar[N][N],dp[N][N],sum[N][N],f[N][N],damn[N][N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,ans=inf,xd=0;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(i==j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcin>>ar[i][j];\n\t\t\tsum[i][j]=sum[i][j-1]+ar[i][j];\n\t\t\txd+=ar[i][j];\n\t\t}\n\t}\n//\tcout<<\"cac\"<<endl;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j]=inf;\n\t\t}\n\t\tdp[0][i]=inf;\n\t\tfor(j=i;j<=n;j++){\n\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\tdamn[i][j]+=sum[k][j]-sum[k][i-1];\t\n\t\t\t}\n\t\t\tf[i][j]=f[i][j-1];\n\t\t\tfor(k=i;k<j;k++){\n\t\t\t\tf[i][j]+=ar[k][j];\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<\"cac\"<<endl;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(k=j;k<=n;k++){\n\t\t\t\tdamn[j][k]-=sum[i][k]-sum[i][j-1];\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<i;j++){\n\t\t\tfor(k=0;k<=j;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[j][k]+damn[k+1][j]+f[j+1][i]);\n\t\t\t}\n\t\t\tif(i==n){\n\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nll dp[2][505][505],a[505][505];\nll sum_up[505][505],sum_down[505][505];\nint n;\n\nint main(){\n\tcin >> n;\n\trepn(i,n) repn(j,n) if(i != j) scanf(\"%lld\",&a[i][j]);\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tsum_up[i][j] = sum_up[i][j-1]+sum_up[i+1][j]-sum_up[i+1][j-1]+a[i][j];\n\t\t}\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tsum_down[i][j] = sum_down[i][j-1]+sum_down[i+1][j]-sum_down[i+1][j-1]+a[j][i];\n\t\t}\n\t}\n\trep(a,2)rep(b,505)rep(c,505)dp[a][b][c] = -1e18;\n\tint cur = 0, nxt = 1;\n\tfor(int i=1;i<=n;i++){\n\t\trep(b,505)rep(c,505) dp[nxt][b][c] = -1e18;\n\t\trepn(j,i-1) for(int k=j;k<i;k++){\n\t\t\tif(dp[cur][j][k] < -8e17) continue;\n\t\t\tdp[nxt][j][k] = max(dp[nxt][j][k],dp[cur][j][k]);\n\t\t\t//[k+1][i]\n\t\t\tdp[nxt][k+1][i] = max(dp[nxt][k+1][i],dp[cur][j][k]-sum_up[k+1][i]+sum_down[j][i]-sum_down[j][k]);\n\t\t}\n\t\tdp[nxt][1][i] = max(dp[nxt][1][i],-sum_up[1][i]+sum_down[1][i]);\n\t\tswap(cur,nxt);\n\t}\n\tll ans = -1e18;\n\trepn(i,n) ans = max(ans,dp[cur][i][n]+sum_up[1][n]);\n\tcout << sum_up[1][n]+sum_down[1][n]-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 512;\n\nll rgt_cost[MaxN][MaxN], lft_cost[MaxN][MaxN];\nll rgt_pref[MaxN][MaxN], lft_pref[MaxN][MaxN];\nint n;\n\nvoid MakePref(ll src[MaxN][MaxN], ll dest[MaxN][MaxN]) {\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      dest[i][j] = dest[i-1][j] + dest[i][j-1] - dest[i-1][j-1] + src[i-1][j-1];\n      debug(i, j, dest[i][j]);\n    }\n  }\n}\n\nll GetRect(ll pref[MaxN][MaxN], int x1, int x2, int y1, int y2) {\n  ll ans = pref[x2][y2] - pref[x1][y2] - pref[x2][y1] + pref[x1][y1];\n  debug(x1, x2, y1, y2, pref[x2][y2], pref[x1][y2], pref[x2][y1], ans);\n  return ans;\n}\n\nll dp[MaxN][MaxN];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) { continue; }\n      if (i < j) {\n        cin >> rgt_cost[i][j];\n      } else {\n        cin >> lft_cost[i][j];\n      }\n    }\n  }\n\n  MakePref(rgt_cost, rgt_pref);\n  MakePref(lft_cost, lft_pref);\n\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      dp[i][j] = 1e18;\n    }\n  }\n\n  for (int r = 0; r < n; ++r) {\n    dp[0][r] = GetRect(rgt_pref, 0, r, 0, r);\n    debug(r, dp[0][r]);\n  }\n\n  ll ans = 1e18;\n\n  for (int L = 0; L < n; ++L) {\n    mini(ans, dp[L][n]);\n    for (int R = L + 1; R < n; ++R) {\n      for (int nxt = R + 1; nxt <= n; ++nxt) {\n        ll cand = dp[L][R];\n        cand += GetRect(rgt_pref, R, nxt, R, nxt);\n        cand += GetRect(lft_pref, R, nxt, 0, L);\n        mini(dp[R][nxt], cand);\n      }\n    }\n  }\n\n  cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<vector<ll>> A(n,vector<ll>(n,0));\n    ll all=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i==j){continue;}\n            cin>>A[i][j];\n            all+=A[i][j];\n        }\n    }\n    vector<vector<ll>> upper(n,vector<ll>(n,0));\n    vector<vector<ll>> lower(n,vector<ll>(n,0));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(i<j){upper[i][j]=A[i][j];}\n            else{lower[i][j]=A[i][j];}\n        }\n    }\n    for(int i=1;i<n;i++){\n        for(int j=0;j<n;j++){\n            upper[i][j]+=upper[i-1][j];\n            lower[i][j]+=lower[i-1][j];\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=1;j<n;j++){\n            upper[i][j]+=upper[i][j-1];\n            lower[i][j]+=lower[i][j-1];\n        }\n    }\n    \n    auto sum2=[](const vector<vector<ll>> &Ab,ll x,ll y)->ll{return (x<0 || y<0)?0LL:Ab[x][y];};\n    \n    auto sum=[&](const vector<vector<ll>> &Ab,ll xs,ll xl,ll ys,ll yl)->ll{\n        if(xs>xl || ys>yl){return 0LL;}\n        return sum2(Ab,xl,yl)-sum2(Ab,xl,ys-1)-sum2(Ab,xs-1,yl)+sum2(Ab,xs-1,ys-1);\n    };\n    \n    vector<vector<ll>> dp(n,vector<ll>(n,0));\n    for(ll i=0;i<n;i++){\n        for(ll j=i;j<n;j++){\n            for(ll m=i;m<=j;m++){\n                dp[i][j]=max(dp[i][j],sum(upper,i,m-1,m,j));\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n            dp[i][j]+=sum(lower,i,j,i,j);\n            dp[i][j]=max(dp[i][j],sum(upper,i,j,i,j));\n            //cout<<dp[i][j]<<endl;\n        }\n    }\n    for(ll w=0;w<n;w++){\n        for(ll lf=0;lf+w<n;lf++){\n            ll i=lf,j=lf+w;\n            if(i+1<n){dp[i][j]=max(dp[i][j],dp[i+1][j]);}\n            if(j-1>=0){dp[i][j]=max(dp[i][j],dp[i][j-1]);}\n            for(ll m=i+1;m<=j;m++){\n                dp[i][j]=max(dp[i][j],dp[i][m-1]+dp[m][j]);\n            }\n        }\n    }\n    ll mx=0;\n    for(auto &I:dp){for(auto &J:I){mx=max(mx,J);}}\n    cout<<all-mx<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n#define lint long long\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nauto make_vector(size_t sz, T t) {\n  return std::vector<T>(sz, t);\n}\ntemplate <size_t N, typename T, typename U, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz, U u) {\n  return make_vector(sz, T(u));\n}\ntemplate <size_t N, typename T, std::enable_if_t<\n  N == 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t sz) {\n  return std::vector<T>(sz);\n}\ntemplate <size_t N, typename T, typename... Args, std::enable_if_t<\n  N != 1, std::nullptr_t> = nullptr>\nauto make_higher_vector(size_t a, Args... args) {\n  return make_vector(a, make_higher_vector<N - 1, T>(args...));\n}\ntemplate <typename T, typename Size_t>\nauto& at(T& t, Size_t i) {\n  return t.at(i);\n}\ntemplate <typename T, typename Size_t, typename... Args>\nauto& at(T& t, Size_t i, Args... args) {\n  return at(t.at(i), args...);\n}\n\ntemplate<typename T, typename U>\ninline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}\ntemplate<typename T, typename U>\ninline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n; std::cin >> n;\n  auto a = make_higher_vector<2, lint>(n, n);\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (i == j) continue;\n      std::cin >> at(a, i, j);\n    }\n  }\n  auto b = make_higher_vector<2, lint>(n + 1, n, -1);\n  auto c = make_higher_vector<2, lint>(n, n + 1, -1);\n  auto d = make_higher_vector<3, lint>(n, n + 1, n + 1);\n  for (int j = 0; j < n; j++)\n  {\n    at(b, 0, j) = 0;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      auto crr = at(b, i, j);\n      at(b, i + 1, j) = crr + at(a, i, j);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    at(c, j, j + 1) = 0;\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j + 1; k < n; k++)\n    {\n      auto crr = at(c, j, k);\n      at(c, j, k + 1) = crr - at(b, j, k) + at(b, k, k);\n    }\n  }\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = j; k <= n; k++)\n    {\n      at(d, j, k, 0) = 0;\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      for (int k = j; k <= n; k++)\n      {\n        // auto crr = at(d, j, k, i);\n        // at(d, j, k, i + 1) = crr - at(b, j, i) + at(b, k, i);\n        d[j][k][i + 1] = d[j][k][i] - b[j][i] + b[k][i];\n      }\n    }\n  }\n  constexpr long long inf = 1LL << 60;\n  auto dp = make_higher_vector<2, lint>(n, n + 1, inf);\n  for (int k = 1; k <= n; k++)\n  {\n    at(dp, 0, k) = at(c, 0, k);\n  }\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++)\n    {\n      for (int k = j + 1; k <= n; k++)\n      {\n        // auto crr = at(dp, i, j);\n        // if (crr == inf) continue;\n        // auto val_1 = at(c, j, k);\n        // auto val_2 = at(d, j, k, i);\n        // cmn(at(dp, j, k), crr + val_1 + val_2);\n        auto crr = dp[i][j];\n        if (crr == inf) continue;\n        cmn(dp[j][k], crr + c[j][k] + d[j][k][i]);\n      }\n    }\n  }\n  auto ret = inf;\n  for (int i = 0; i < n; i++)\n  {\n    cmn(ret, at(dp, i, n));\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 577;\nconst ll INF = LLONG_MAX / 2;\n\nint N;\nll A[MAX_N][MAX_N], cost1[MAX_N][MAX_N], cost2[MAX_N][MAX_N];\nll dp[MAX_N][MAX_N];\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i == j) continue;\n            scanf(\"%lld\", &A[i][j]);\n            if (i < j) cost1[i][j] = A[i][j];\n            else cost2[j][i] = A[i][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i][j - 1];\n        }\n    }\n    for (int i = N; i; i--) {\n        for (int j = 1; j <= N; j++) {\n            cost1[i][j] += cost1[i + 1][j];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = N; j; j--) {\n            cost2[i][j] += cost2[i][j + 1];\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost2[i][j] += cost2[i - 1][j];\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        dp[0][i] = cost1[1][i];\n        for (int j = 1; j < i; j++) {\n            dp[j][i] = INF;\n            for (int k = 0; k < j; k++) {\n                dp[j][i] = min(dp[j][i], dp[k][j] + cost1[j + 1][i] + cost2[j][i + 1] - cost2[k][i + 1]);\n            }\n        }\n    }\n    ll ans = INF;\n    for (int i = 1; i < N; i++) {\n        for (int j = 0; j < i; j++) {\n            ans = min(ans, dp[j][i] + cost1[i + 1][N]);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<t;i++)\ntypedef long long ll;\nconst ll inf=1e18;\nll dp[555][555],sum[2][555][555];\nll cal(int t,int l1,int r1,int l2,int r2)\n{\n    if(!r1||!r2)return 0;\n    return sum[t][r1][r2]-sum[t][l1-1][r2]-sum[t][r1][l2-1]+sum[t][l1-1][l2-1];\n}\n\nint main()\n{\n    int n;scanf(\"%d\",&n);\n    rep(i,1,n+1)rep(j,1,n+1)\n    if(i!=j)\n    {\n        scanf(\"%lld\",&sum[0][i][j]);\n        if(i<j)sum[1][i][j]=sum[0][i][j];\n    }\n    rep(k,0,2)rep(i,1,n+1)rep(j,1,n+1)\n        sum[k][i][j]+=sum[k][i-1][j]+sum[k][i][j-1]-sum[k][i-1][j-1];\n    rep(i,0,n+1)rep(j,0,n+1)dp[i][j]=inf;\n    dp[0][0]=0;\n    rep(i,0,n+1)\n    rep(j,0,n+1)if(dp[i][j]!=inf)\n    {\n        rep(k,j+1,n+1)\n        dp[j][k]=min(dp[j][k],dp[i][j]+cal(0,j+1,k,1,i)+cal(1,j+1,k,j+1,k));\n    }\n    ll res=inf;\n    for(int i=n-1;i>=0;i--)res=min(res,dp[i][n]);\n    printf(\"%lld\\n\",res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N      510\n// #define inf    0x7f7f7f7f\n#define int    long long\nusing namespace std;\nint a[N][N] = {};\nint read()\n{\n    int  s = 0, w = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-')\n        c = getchar();\n    if (c == '-')\n        c = getchar(), w = -1;\n    while (c <= '9' && c >= '0')\n        s = (s << 3) + (s << 1) + c - '0', c = getchar();\n    return s * w;\n}\nint n;\nint b[N][N] = {}, c[N][N] = {};\nint f[N][N] = {};\nsigned main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j)\n            if (i != j)\n                a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = n; j >= i + 1; --j)\n        {\n            b[i][j] = b[i][j + 1];\n            for (int k = 1; k <= i; ++k)\n                b[i][j] += a[j][k];\n        }\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n + 1; ++j)\n        {\n            c[i][j] = c[i][j - 1];\n            for (int k = i; k <= j - 1; ++k)\n                c[i][j] += a[k][j];\n        }\n    memset(f, 0x7f, sizeof(f));\n    f[0][0] = 0;\n    for (int i = 0; i <= n; ++i)\n        for (int j = i; j <= n; ++j)\n            if (f[i][j] < 1e18)\n                for (int k = j + 1; k <= n + 1; ++k)\n                    f[j][k] = min(f[j][k], f[i][j] + c[j + 1][k] + b[j][k + 1] - b[i][k + 1]);\n    int minn = 1e18;\n    for (int i = 0; i <= n; ++i)\n        minn = min(minn, f[i][n + 1]);\n    printf(\"%lld\\n\", minn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 505;\nint n;\nll inf, v1[N][N], v2[N][N], f[N][N];\nll get(ll v[N][N], int x1, int x2, int y1, int y2) {\n  return v[x2][y2] - v[x1][y2] - v[x2][y1] + v[x1][y1];\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j < i; j++) {\n      scanf(\"%lld\", &v1[j][i]);\n    }\n    for (int j = i + 1; j <= n; j++) {\n      scanf(\"%lld\", &v2[i][j]);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      v1[i][j] = v1[i][j] + v1[i - 1][j] + v1[i][j - 1] - v1[i - 1][j - 1];\n      v2[i][j] = v2[i][j] + v2[i - 1][j] + v2[i][j - 1] - v2[i - 1][j - 1];\n    }\n  }\n  memset(f, 0x3f, sizeof f);\n  inf = f[0][0];\n  f[0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i + !i; j++) if (f[i][j] != inf) {\n      for (int k = i + 1; k <= n; k++) {\n        f[k][i] = min(f[k][i], f[i][j] + get(v1, j, i, k, n) + get(v2, i, k, i, k));\n      }\n    }\n  }\n  ll ans = inf;\n  for (int j = 0; j < n; j++) {\n    ans = min(ans, f[n][j]);\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "Text",
    "code": "2"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        private static final long INF = (long) 1e18;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[][] cost = new int[n + 1][n + 1];\n            for (int i = 1; i <= n; ++i) {\n                for (int j = 1; j <= n; ++j) {\n                    if (i != j) cost[i][j] = in.nextInt();\n                }\n            }\n            long[][] best = new long[n + 1][n + 1];\n            long[] suffix = new long[n + 1];\n            for (int i = 1; i <= n; ++i) {\n                for (int j = 1; j < i; ++j) {\n                    suffix[j] += cost[i][j];\n                }\n            }\n            for (long[] x : best) Arrays.fill(x, INF);\n            best[0][0] = 0;\n            for (int a = 1; a <= n; ++a) {\n                long inside = 0;\n                for (int j = 1; j < a; ++j) {\n                    suffix[j] -= cost[a][j];\n                }\n                for (int b = a - 1; b >= 0; --b) {\n                    long outside = 0;\n                    for (int c = b; c >= 0; --c) {\n                        if (best[b][c] < INF) {\n                            best[a][b] = Math.min(best[a][b], best[b][c] + outside + inside);\n                        }\n                        outside += suffix[c];\n                    }\n                    for (int c = a; c > b; --c) {\n                        inside += cost[b][c];\n                    }\n                }\n            }\n            long res = INF;\n            for (int a = 1; a <= n; ++a) {\n                res = Math.min(res, best[n][a]);\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n\n        long[][] dp;\n        long[][] l2rMat;\n        long[][] r2lMat;\n\n        public void solve() {\n            int n = io.readInt();\n            List<Constraint> l2r = new ArrayList<>(n * (n - 1) / 2);\n            List<Constraint> r2l = new ArrayList<>(n * (n - 1) / 2);\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j < i; j++) {\n                    r2l.add(new Constraint(j, i - 1, io.readInt()));\n                }\n                for (int j = i + 1; j <= n; j++) {\n                    l2r.add(new Constraint(i, j - 1, io.readInt()));\n                }\n            }\n            l2rMat = new long[n + 1][n + 1];\n            r2lMat = new long[n + 1][n + 1];\n            for (Constraint c : l2r) {\n                l2rMat[c.l][c.r] += c.cost;\n            }\n            for (Constraint c : r2l) {\n                r2lMat[c.l][c.r] += c.cost;\n            }\n\n            debug.debug(\"l2r\", l2rMat);\n            debug.debug(\"r2l\", r2lMat);\n\n            preSum(l2rMat);\n            preSum(r2lMat);\n\n            debug.debug(\"l2r\", l2rMat);\n            debug.debug(\"r2l\", r2lMat);\n\n            dp = new long[n + 1][n + 1];\n            for (long[] r : dp) {\n                Arrays.fill(r, -1L);\n            }\n            dp[0][0] = 0;\n\n            long ans = lInf;\n            for (int i = 0; i < n; i++) {\n                ans = Math.min(ans, dp(n, i));\n            }\n            debug.debug(\"dp\", dp);\n            io.cache.append(ans);\n        }\n\n        public long valueOf(long[][] mat, int i, int j) {\n            if (i < 0 || i >= mat.length || j < 0 || j >= mat[0].length) {\n                return 0;\n            }\n            return mat[i][j];\n        }\n\n        public long subarea(long[][] mat, int x1, int y1, int x2, int y2) {\n            if (x1 > x2 || y1 > y2) {\n                return 0;\n            }\n            return valueOf(mat, x2, y2) - valueOf(mat, x1 - 1, y2) - valueOf(mat, x2, y1 - 1) + valueOf(mat, x1 - 1, y1 - 1);\n        }\n\n        public long dp(int x, int i) {\n            if (dp[x][i] == -1) {\n                if (x <= i) {\n                    dp[x][i] = lInf;\n                    return lInf;\n                }\n                dp[x][i] = lInf;\n                for (int j = 0; j <= i; j++) {\n                    dp[x][i] = Math.min(dp[x][i],\n                            dp(i, j) + subarea(l2rMat, i + 1, i + 1, x - 1, x - 1)\n                                    + subarea(r2lMat, 1, i, j, x - 1));\n                }\n            }\n            return dp[x][i];\n        }\n\n        public void preSum(long[][] g) {\n            int n = g.length;\n            int m = g[0].length;\n\n            for (int i = 1; i < n; i++) {\n                g[i][0] += g[i - 1][0];\n            }\n            for (int i = 1; i < m; i++) {\n                g[0][i] += g[0][i - 1];\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 1; j < m; j++) {\n                    g[i][j] += g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1];\n                }\n            }\n        }\n\n\n    }\n\n    public static class Constraint {\n        int l;\n        int r;\n        int cost;\n\n        public Constraint(int l, int r, int cost) {\n            this.l = l;\n            this.r = r;\n            this.cost = cost;\n        }\n\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(1 << 13);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() throws IOException {\n            os.write(cache.toString().getBytes(charset));\n            os.flush();\n            cache.setLength(0);\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\n\nusing Number = System.Int64;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar a = Enumerate(n, x => new long[n]);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (i != j) a[i][j] = rl;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tDebug.WriteLine(a[i].AsJoinedString(\"\\t\"));\n\t\t\tvar b = Enumerate(n, x => new long[n]);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < i; j++) b[i][j] = a[i][j];\n\t\t\tvar A = new RectangleSum(a);\n\t\t\tvar B = new RectangleSum(b);\n\t\t\tvar dp = Enumerate(n, n, (x, y) => -INF);\n\t\t\tfor (int r = 0; r < n; r++) {\n\t\t\t\tdp[0][r] = B.Sum(0, 0, r + 1, r + 1);\n\t\t\t}\n\t\t\tfor (int nl = 1; nl < n; nl++) {\n\t\t\t\tvar r = nl - 1;\n\t\t\t\tfor (int l = 0; l <= r; l++)\n\t\t\t\t\tfor (int nr = nl; nr < n; nr++) {\n\t\t\t\t\t\tvar u = dp[l][r] + A.Sum(0, nl, r + 1, nr + 1) + A.Sum(nl, l, nr + 1, r + 1) + B.Sum(nl, nl, nr + 1, nr + 1);\n\t\t\t\t\t\tdp[nl][nr] = Max(dp[nl][nr], u);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tvar sum = 0L;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) sum += a[i][j];\n\t\t\tvar ans = INF;\n\t\t\tfor (int l = 0; l < n; l++) ans = Min(ans, sum - dp[l][n - 1]);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\npublic class RectangleSum {\n\tint n, m;\n\tlong[][] s;\n\tpublic RectangleSum(long[][] a) {\n\t\tn = a.Length;\n\t\tm = a.Length;\n\t\ts = new long[n + 1][];\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t\ts[i] = new long[m + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ts[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + a[i][j];\n\t}\n\tpublic RectangleSum(int[][] a) {\n\t\tvar n = a.Length;\n\t\tvar m = a.Length;\n\t\ts = new long[n + 1][];\n\t\tfor (int i = 0; i < n + 1; i++)\n\t\t\ts[i] = new long[m + 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\ts[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + a[i][j];\n\t}\n\t/// <summary>\n\t/// [t,b),[l,r) で作られる矩形領域の和を求める\n\t/// </summary>\n\tpublic long Sum(int top, int left, int bottom, int right) {\n\t\tif (top < 0 || left < 0 || bottom > n || right > m || top >= bottom || left >= right) return 0;\n\t\treturn s[bottom][right] - s[top][right] - s[bottom][left] + s[top][left];\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n\n(N - 1).times do |b|\n  i = N - b - 1\n\n  a = []\n  max_loop = 2\n  now_loop = 0\n  i.times do |j|\n    if j % 2 == 0\n      a.push(1)\n    else\n      now_loop += 1\n      a.push(now_loop + 1)\n      if max_loop == now_loop\n        max_loop += 1\n        now_loop = 0\n      end\n    end\n  end\n  puts a.join(' ')\nend"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10L^^18;\n\nint N;\nlong[][] A;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      A = new long[][](N, N);\n      foreach (u; 0 .. N) foreach (v; 0 .. N) {\n        if (u != v) {\n          A[u][v] = readLong();\n        }\n      }\n      \n      auto sumL = new long[][N];\n      auto sumR = new long[][N];\n      foreach (u; 0 .. N) {\n        sumL[u] = new long[u + 1];\n        sumR[u] = new long[u + 1];\n        foreach (v; 0 .. u) {\n          sumL[u][v + 1] = sumL[u][v] + A[u][v];\n          sumR[u][v + 1] = sumR[u][v] + A[v][u];\n        }\n      }\n      \n      auto dp = new long[][](1, 1);\n      dp[0][0] = 0;\n      foreach (u; 1 .. N) {\n        auto dpNext = new long[][](u + 1, u + 1);\n        foreach (a; 0 .. u + 1) foreach (b; a .. u + 1) {\n          dpNext[a][b] = INF;\n        }\n        foreach (a; 0 .. u) foreach (b; a .. u) {\n          // -0\n          chmin(dpNext[a][b], dp[a][b] + sumL[u][a] + (sumR[u][u] - sumR[u][b]));\n          // -1\n          chmin(dpNext[b][u], dp[a][b] + sumL[u][b]);\n        }\n        dp = dpNext;\n      }\n      long ans = INF;\n      foreach (a; 0 .. N) foreach (b; a .. N) {\n        chmin(ans, dp[a][b]);\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=500;\nconst LL INF=(1LL<<50)-1;\n\nint n,a[N+9][N+9];\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=1;i<=n;++i)\n\tfor (int j=1;j<=n;++j)\n\t  if (i^j) scanf(\"%d\",&a[i][j]);\n}\n\nLL sum[N+9][N+9][2];\n\nvoid Get_sum(){\n  for (int i=1;i<=n;++i){\n\tfor (int j=1;j<=n;++j){\n\t  if (i^j) i<j?sum[i][j][0]=a[i][j]:sum[i][j][1]=a[i][j];\n\t  for (int k=0;k<2;++k) sum[i][j][k]+=sum[i][j-1][k];\n\t}\n    for (int j=1;j<=n;++j)\n\t  for (int k=0;k<2;++k) sum[i][j][k]+=sum[i-1][j][k];\n  }\n}\n\nLL Get_sum(int id,int x0,int y0,int x1,int y1){return sum[x1][y1][id]-sum[x1][y0-1][id]-sum[x0-1][y1][id]+sum[x0-1][y0-1][id];}\n\nLL dp[N+9][N+9],ans;\n\nvoid Get_dp(){\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<=n;++j) dp[i][j]=INF;\n  dp[0][0]=0;\n  for (int i=0;i<=n;++i)\n\tfor (int j=0;j<max(i,1);++j)\n\t  for (int k=i+1;k<=n;++k){\n\t\tLL t=dp[i][j]+Get_sum(1,k+1,j+1,n,i)+Get_sum(0,i+1,i+1,k,k);\n\t\tdp[k][i]=min(dp[k][i],t);\n\t  }\n  ans=INF;\n  for (int i=1;i<=n;++i) ans=min(ans,dp[n][i]);\n}\n\nvoid work(){\n  Get_sum();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "Python",
    "code": "N = int(input())    \n\nA = [[0] * N for _ in range(N)]\nAl = [[0] * (N+1) for _ in range(N+1)]\nAr = [[0] * (N+1) for _ in range(N+1)]\n\nfor i in range(N) :\n    a = [int(i) for i in input().split()]\n    for j in range(N) :\n        if i < j :\n            A[i][j] = a[j-1]\n        elif i > j :\n            A[i][j] = a[j]\n\nfor i in range(N) :\n    for j in range(i+1, N) :\n        Al[j][i+1] = Al[j][i] + A[j][i]\n        Ar[i][j] = Ar[i-1][j] + A[i][j]\n\ndp = [[float('inf')] * (N+1) for _ in range(N+1)]\ndp[0][0] = 0\n        \nfor i in range(N+1) :\n    for j in range(i, N+1) :\n        if dp[i][j] == float('inf') :\n            continue\n        l, r = 0, 0\n        for k in range(j+1, N+1) :\n            l += Al[k-1][i]\n            r += Ar[k-2][k-1] - Ar[j-1][k-1]\n            dp[j][k] = min(dp[j][k], dp[i][j] + l + r)\nprint(min(dp[i][N] for i in range(N+1)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())    \n\nA = [[0] * N for _ in range(N)]\nAl = [[0] * (N+1) for _ in range(N+1)]\nAr = [[0] * (N+1) for _ in range(N+1)]\n\nfor i in range(N) :\n    a = [int(i) for i in input().split()]\n    for j in range(N) :\n        if i < j :\n            A[i][j] = a[j-1]\n        elif i > j :\n            A[i][j] = a[j]\n\nfor i in range(N) :\n    for j in range(i+1, N) :\n        Al[j][i+1] = Al[j][i] + A[j][i]\n        Ar[i][j] = Ar[i-1][j] + A[i][j]\n\n# for al in Al :\n    # print(al)\n# print()\n# for ar in Ar :\n    # print(ar)\n\ndp = [[float('inf')] * (N+1) for _ in range(N+1)]\ndp[0][0] = 0\n        \nfor i in range(N+1) :\n    for j in range(i, N+1) :        \n        l, r = 0, 0\n        for k in range(j+1, N+1) :\n            l += Al[k-1][i]\n            r += Ar[k-2][k-1] - Ar[j-1][k-1]\n            dp[j][k] = min(dp[j][k], dp[i][j] + l + r)\n            # print('i', i, 'j', j, 'k', k, l, r)\n# print(dp)\nprint(min(dp[i][N] for i in range(N+1)))"
  }
]