[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define INF 0x3f3f3f3f\n\nint N;\nint cost[MAX_N][MAX_N];\nint dist[MAX_N];\n\nbool bellman_ford() {\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (dist[i] != INF && dist[j] > dist[i] + cost[i][j]) {\n                    dist[j] = dist[i] + cost[i][j];\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dist[i] != INF && dist[j] > dist[i] + cost[i][j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint solve() {\n    int total_cost = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (i < j) cost[i][j] = -1;\n            else cost[i][j] = 1;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j || i + 1 == j) continue;\n            \n            // Try removing this edge\n            int original_cost = cost[i][j];\n            cost[i][j] = INF;\n            \n            for (int k = 0; k < N; k++) {\n                dist[k] = (k == 0) ? 0 : INF;\n            }\n            \n            if (!bellman_ford()) {\n                total_cost += original_cost;\n            } else {\n                cost[i][j] = original_cost;\n            }\n        }\n    }\n    \n    return total_cost;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &cost[i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    long long **A = (long long **)malloc(N * sizeof(long long *));\n    for (int i = 0; i < N; i++) {\n        A[i] = (long long *)malloc(N * sizeof(long long));\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            scanf(\"%lld\", &A[i][j]);\n        }\n    }\n\n    long long res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            long long mn = A[i][j];\n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                mn = min(mn, A[i][k] + A[k][j]);\n            }\n            if (mn < A[i][j]) {\n                res += A[i][j] - mn;\n                A[i][j] = mn;\n            }\n        }\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j || i == k || j == k) continue;\n                if (A[i][j] > A[i][k] + A[k][j]) {\n                    printf(\"-1\\n\");\n                    return 0;\n                }\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int needed = 1;\n            for (int k = 0; k < N; k++) {\n                if (k == i || k == j) continue;\n                if (A[i][j] == A[i][k] + A[k][j]) {\n                    needed = 0;\n                    break;\n                }\n            }\n            if (needed) {\n                total += A[i][j];\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", total);\n\n    for (int i = 0; i < N; i++) {\n        free(A[i]);\n    }\n    free(A);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<long long>> A(N, vector<long long>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i != j) cin >> A[i][j];\n        }\n    }\n\n    long long total = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            bool needed = true;\n            for (int k = 0; k < N; ++k) {\n                if (k != i && k != j && A[i][j] > A[i][k] + A[k][j]) {\n                    needed = false;\n                    break;\n                }\n            }\n            if (needed) {\n                total += A[i][j];\n            }\n        }\n    }\n\n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        long[][] A = new long[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = sc.nextLong();\n            }\n        }\n\n        long res = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                boolean needed = true;\n                for (int k = 0; k < N; k++) {\n                    if (k != i && k != j && A[i][j] > A[i][k] + A[k][j]) {\n                        needed = false;\n                        break;\n                    }\n                }\n                if (needed) {\n                    res += A[i][j];\n                }\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 22:47:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int INF = Integer.MAX_VALUE / 2;\n\n    public static int minimumCycleRemoval(int N, int[][] costMatrix) {\n        int[][] dist = new int[N][N];\n        \n        // Initialize initial graph with 0-weight edges between consecutive vertices\n        for (int i = 0; i < N - 1; i++) {\n            dist[i][i + 1] = 0;\n        }\n        \n        // Add new edges from Snuke\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                dist[i][j] = (i < j) ? -1 : 1;\n            }\n        }\n        \n        // Floyd-Warshall to find shortest paths\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        \n        // Check for negative cycles\n        boolean[] negativeCycle = new boolean[N];\n        for (int i = 0; i < N; i++) {\n            if (dist[i][i] < 0) {\n                negativeCycle[i] = true;\n            }\n        }\n        \n        // Greedy edge deletion\n        int totalCost = 0;\n        boolean[] deleted = new boolean[N * N];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                if (dist[i][j] < 0) {\n                    int minCost = INF;\n                    int bestK = -1;\n                    \n                    for (int k = 0; k < N; k++) {\n                        if (k == i || k == j) continue;\n                        \n                        if (!deleted[i * N + k] && costMatrix[i][k] < minCost) {\n                            minCost = costMatrix[i][k];\n                            bestK = k;\n                        }\n                        \n                        if (!deleted[k * N + j] && costMatrix[k][j] < minCost) {\n                            minCost = costMatrix[k][j];\n                            bestK = k;\n                        }\n                    }\n                    \n                    if (bestK != -1) {\n                        if (dist[i][bestK] + dist[bestK][j] > 0) {\n                            if (dist[i][bestK] < 0) {\n                                deleted[i * N + bestK] = true;\n                                totalCost += costMatrix[i][bestK];\n                            } else {\n                                deleted[bestK * N + j] = true;\n                                totalCost += costMatrix[bestK][j];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 22:47:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAXN = 405;\nconst ll INF = 1e18;\n\nll cost[MAXN][MAXN];\nll dist[MAXN][MAXN];\n\nint main() {\n    int N;\n    cin >> N;\n    \n    // Read cost matrix\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> cost[i][j];\n        }\n    }\n    \n    // Initialize distances with initial graph\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) dist[i][j] = 0;\n            else if (abs(i - j) == 1) dist[i][j] = 0;\n            else if (i < j) dist[i][j] = -1;\n            else dist[i][j] = 1;\n        }\n    }\n    \n    // Floyd-Warshall algorithm\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    \n    // Find minimum cost to remove negative cycles\n    ll total_cost = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i != j && abs(i - j) != 1 && dist[i][j] < 0) {\n                total_cost += cost[i][j];\n            }\n        }\n    }\n    \n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cost_to_remove_negative_cycles(N, A):\n    # Set up the distances with the given graph's edges that have 0 weight\n    inf = float('inf')\n    min_cost = 0\n\n    # We'll use a modified version of the Floyd-Warshall algorithm to detect cycles\n    dp = [[inf] * N for _ in range(N)]\n \n    # Initialize weights of the original zero-weight linear path\n    for i in range(N - 1):\n        dp[i][i+1] = 0\n  \n    # Snuke's added edges\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                dp[i][j] = -1 if i < j else 1\n\n    # Floyd-Warshall algorithm to check for negative cycles\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dp[i][k] != inf and dp[k][j] != inf:\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\n    # Track the cost of not having a negative cycle\n    for i in range(N):\n        if dp[i][i] < 0:\n            for j in range(N):\n                if i != j:\n                    weight = -1 if i < j else 1\n                    if dp[i][j] + weight + dp[j][i] < 0:\n                        min_cost += A[i][j]\n\n    return min_cost\n\n# Example usage of the function (uncomment to test):\n# N = 3\n# A = [\n#     [0, 2, 3],\n#     [4, 0, 1],\n#     [5, 6, 0]\n# ]\n# print(min_cost_to_remove_negative_cycles(N, A))  # Example test case",
    "timestamp": "2025-08-13 12:30:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class NegativeCycleRemoval {\n\n    private static int solve(int N, int[][] A) {\n        int[][] dp = new int[N][N];\n        \n        for (int i = 0; i < N; i++) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\n        }\n        \n        for (int i = 0; i < N; i++) {\n            dp[i][i] = 0;\n        }\n        \n        for (int length = 2; length <= N; length++) {\n            for (int i = 0; i <= N - length; i++) {\n                int j = i + length - 1;\n                for (int k = i; k < j; k++) {\n                    if (dp[i][k] != Integer.MAX_VALUE && dp[k+1][j] != Integer.MAX_VALUE) {\n                        int weight = i < j ? -1 : 1;\n                        if ((dp[i][k] + dp[k+1][j] + weight < dp[i][j])) {\n                            dp[i][j] = dp[i][k] + dp[k+1][j] + weight;\n                        }\n                    }\n                }\n                if (i < j)\n                    dp[i][j] = Math.min(dp[i][j], A[i][j]);\n                else\n                    dp[i][j] = Math.min(dp[i][j], A[j][i]);\n            }\n        }\n        \n        int cost = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (dp[i][j] < 0) {\n                    cost += A[i][j];\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        \n        return cost;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] A = new int[N][N];\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int result = solve(N, A);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 12:30:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAXN 100\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int A[MAXN][MAXN];\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    int minCost = 0;\n    for (int k = 1; k < N; ++k) {\n        int totalCost = 0;\n        for (int i = 0; i < k; ++i) {\n            for (int j = k; j < N; ++j) {\n                totalCost += A[i][j];\n            }\n        }\n        minCost = (k == 1) ? totalCost : min(minCost, totalCost);\n    }\n\n    printf(\"%d\\n\", minCost);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:30:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minCostToAvoidNegativeCycle(N, A) {\n    const inf = Infinity;\n    const cost = new Array(N).fill(0).map(() => new Array(N).fill(inf));\n    \n    // Initialize cost for deleting edges to themselves as 0\n    for (let i = 0; i < N; i++) {\n        cost[i][i] = 0;\n    }\n  \n    // Initialize cost for edges that initially have weight 0\n    for (let i = 0; i < N - 1; i++) {\n        cost[i][i + 1] = 0;\n    }\n  \n    // Bellman-Ford algorithm to detect and remove negative cycles\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                if (i != j) {\n                    let weight = (i < j) ? -1 : 1;\n                    if (cost[i][j] > cost[i][k] + cost[k][j] + A[k][j] * (weight < 0 ? 1 : 0)) {\n                        cost[i][j] = cost[i][k] + cost[k][j] + A[k][j] * (weight < 0 ? 1 : 0);\n                    }\n                }\n            }\n        }\n    }\n  \n    let result = 0;\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i != j && cost[i][j] < inf && cost[i][j] < 0) {\n                result += A[i][j];\n            }\n        }\n    }\n  \n    return result;\n}",
    "timestamp": "2025-08-13 12:30:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A):\n    INF = float('inf')\n    dist = [[INF] * N for _ in range(N)]\n    \n    # Initialize original graph edges\n    for i in range(N-1):\n        dist[i][i+1] = 0\n    \n    # Add new edges\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                dist[i][j] = 0\n            elif i < j:\n                dist[i][j] = -1\n            else:\n                dist[i][j] = 1\n    \n    # Floyd-Warshall algorithm\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # Check for negative cycles\n    min_cost = INF\n    for mask in range(1 << (N * N)):\n        temp_dist = [row.copy() for row in dist]\n        total_cost = 0\n        \n        # Try removing added edges\n        for i in range(N):\n            for j in range(N):\n                if i == j or i < j:\n                    continue\n                \n                # Check if this edge should be removed\n                if mask & (1 << (i * N + j)):\n                    temp_dist[i][j] = INF\n                    total_cost += A[i][j]\n        \n        # Check for negative cycles after edge removal\n        for k in range(N):\n            for i in range(N):\n                for j in range(N):\n                    temp_dist[i][j] = min(temp_dist[i][j], temp_dist[i][k] + temp_dist[k][j])\n        \n        # Check if no negative cycle exists\n        negative_cycle = False\n        for i in range(N):\n            if temp_dist[i][i] < 0:\n                negative_cycle = True\n                break\n        \n        # Update minimum cost if no negative cycle\n        if not negative_cycle:\n            min_cost = min(min_cost, total_cost)\n    \n    return min_cost\n\n# Input handling\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\nprint(solve(N, A))",
    "timestamp": "2025-08-13 12:31:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A) {\n    const INF = 1e9;\n    const dist = Array.from({ length: N }, () => Array(N).fill(INF));\n\n    // Initialize original edges\n    for (let i = 0; i < N - 1; i++) {\n        dist[i][i + 1] = 0;\n    }\n\n    // Add new edges\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i === j) continue;\n            dist[i][j] = i < j ? -1 : 1;\n        }\n    }\n\n    // Floyd-Warshall algorithm to find and eliminate negative cycles\n    for (let k = 0; k < N; k++) {\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n\n    // Find minimum cost to remove negative cycles\n    let totalCost = 0;\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i === j) continue;\n            if (dist[i][j] < 0) {\n                totalCost += A[i][j];\n            }\n        }\n    }\n\n    return totalCost;\n}",
    "timestamp": "2025-08-13 12:31:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    A = []\n    for _ in range(N):\n        row = list(map(int, data[idx:idx+N]))\n        idx += N\n        A.append(row)\n    \n    INF = 1 << 60\n    dist = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n    for i in range(N-1):\n        dist[i][i+1] = 0\n    \n    total_cost = 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if i + 1 == j:\n                continue\n            if dist[i][j] <= (-1 if i < j else 1):\n                continue\n            total_cost += A[i][j]\n            if i < j:\n                dist[i][j] = -1\n            else:\n                dist[i][j] = 1\n    \n    for k in range(N):\n        for i in range(N):\n            if dist[i][k] == INF:\n                continue\n            for j in range(N):\n                if dist[k][j] == INF:\n                    continue\n                if dist[i][j] > dist[i][k] + dist[k][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    \n    for i in range(N):\n        if dist[i][i] < 0:\n            print(-1)\n            return\n    \n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 12:31:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const A = [];\n    for (let i = 1; i <= N; i++) {\n        const row = input[i].split(' ').map(Number);\n        A.push(row);\n    }\n\n    // Initialize the DP table\n    const dp = new Array(N).fill().map(() => new Array(N).fill(Infinity));\n    for (let i = 0; i < N; i++) {\n        dp[i][i] = 0;\n    }\n\n    // Fill the DP table\n    for (let len = 1; len <= N; len++) {\n        for (let i = 0; i + len <= N; i++) {\n            const j = i + len - 1;\n            if (i > 0) {\n                let cost = dp[i][j];\n                for (let k = i; k <= j; k++) {\n                    cost += A[i - 1][k];\n                }\n                dp[i - 1][j] = Math.min(dp[i - 1][j], cost);\n            }\n            if (j < N - 1) {\n                let cost = dp[i][j];\n                for (let k = i; k <= j; k++) {\n                    cost += A[k][j + 1];\n                }\n                dp[i][j + 1] = Math.min(dp[i][j + 1], cost);\n            }\n        }\n    }\n\n    console.log(dp[0][N - 1]);\n};\n\nsolve();",
    "timestamp": "2025-08-13 12:31:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> A(N, vector<int>(N));\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> A[i][j];\n        }\n    }\n\n    vector<vector<int>> dp(N+1, vector<int>(N, INF));\n\n    dp[0][0] = 0;\n\n    for (int k = 1; k <= N; ++k) {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (dp[k-1][j] != INF && ((i < j && dp[k-1][j] - 1 < dp[k][i]) || (i > j && dp[k-1][j] + 1 < dp[k][i]))) {\n                    dp[k][i] = (i < j) ? dp[k-1][j] - 1 : dp[k-1][j] + 1;\n                }\n            }\n        }\n\n        for (int j = 0; j < N; ++j) {\n            if (dp[k][j] < 0) {  // Negative cycle detected\n                int min_cost = INF;\n                for (int i = 0; i < j; ++i) {\n                    min_cost = min(min_cost, A[i][j]);\n                }\n                for (int i = j+1; i < N; ++i) {\n                    min_cost = min(min_cost, A[i][j]);\n                }\n                cout << min_cost << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << 0 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:01"
  }
]