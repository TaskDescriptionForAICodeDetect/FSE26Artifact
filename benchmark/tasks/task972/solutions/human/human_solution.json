[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nint A[222][222];\n\nint dp[444][222][222];\n\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)rep(j,W)cin>>A[i][j];\n\n    for(int i=0;i<H+W-2;i++){\n        for(int j=0;j<=i&&j<W;j++){\n            for(int k=0;k<=i&&k<W;k++){\n                int x1=j,y1=i-j;\n                int x2=k,y2=i-k;\n\n                rep(b,4){\n                    int nx1=x1,ny1=y1;\n                    int nx2=x2,ny2=y2;\n\n                    if(b&1)nx1++;\n                    else ny1++;\n\n                    if(b>>1&1)nx2++;\n                    else ny2++;\n\n                    if(nx1>=W||ny1>=H||nx2>=W||ny2>=H)continue;\n                    if(nx1!=nx2||ny1!=ny2)chmax(dp[i+1][nx1][nx2],dp[i][j][k]+A[ny1][nx1]+A[ny2][nx2]);\n                    else chmax(dp[i+1][nx1][nx2],dp[i][j][k]+A[ny1][nx1]);\n                }\n            }\n        }\n    }\n\n    cout<<dp[H+W-2][W-1][W-1]+A[0][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nint dp[401][201][201];\nint A[201][201];\n\nbool same(int ay, int ax, int by, int bx) {\n    return ay == by&&ax == bx;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while(cin >> H >> W) {\n        rep(y, H)rep(x, W)cin >> A[y][x];\n\n        MEM(dp, -1);\n        dp[0][0][0] = A[0][0];\n\n        rep(s, H + W - 2) {\n            rep(ay, H) {\n                int ax = s - ay;\n                if(ax < 0 || ax >= W)continue;\n\n                rep(by, H) {\n                    int bx = s - by;\n                    if(bx < 0 || bx >= W)continue;\n\n                    int z = dp[s][ay][by];\n                    if(z == -1)continue;\n\n                    // 下,下\n                    if(ay < H - 1 && by < H - 1) {\n                        int nay = ay + 1;\n                        int nby = by + 1;\n                        int w = z + A[nay][ax] + A[nby][bx];\n                        if(same(nay, ax, nby, bx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][nby], w);\n                    }\n\n                    // 下,右\n                    if(ay < H - 1 && bx < W - 1) {\n                        int nay = ay + 1;\n                        int nbx = bx + 1;\n                        int w = z + A[nay][ax] + A[by][nbx];\n                        if(same(nay, ax, by, nbx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][by], w);\n                    }\n\n                    // 右,下\n                    if(ax < W - 1 && by < H - 1) {\n                        int nax = ax + 1;\n                        int nby = by + 1;\n                        int w = z + A[ay][nax] + A[nby][bx];\n                        if(same(ay, nax, nby, bx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][nby], w);\n                    }\n\n                    // 右,右\n                    if(ax < W - 1 && bx < W - 1) {\n                        int nax = ax + 1;\n                        int nbx = bx + 1;\n                        int w = z + A[ay][nax] + A[by][nbx];\n                        if(same(ay, nax, by, nbx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][by], w);\n                    }\n                }\n            }\n        }\n\n        cout << dp[H+W-2][H - 1][W - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n\n// 最小費用流 O( F |E| log |V| )\nclass MinimumCostFlow\n{\nprivate:\n\tstruct Edge\n\t{\n\t\tint to, cap, cost, rev;\n\t\tEdge( int t, int c, int d, int r ) : to( t ), cap( c ), cost( d ), rev( r ) {}\n\t};\n\n\tconst int V;\n\tvector< vector<Edge> > G;\n\npublic:\n\tMinimumCostFlow( int v ) : V( v ), G( V ) {};\n\n\tvoid connect( int from, int to, int cap, int cost )\n\t{\n\t\tG[ from ].push_back( Edge( to, cap, cost, G[ to ].size() ) );\n\t\tG[ to ].push_back( Edge( from, 0, -cost, G[ from ].size() - 1 ) );\n\t\treturn;\n\t}\n\n\tint solve( int s, int t, int f )\n\t{\n\t\tint res = 0;\n\t\tvector<int> h( V, 0 ), prevv( V ), preve( V );\n\n\t\twhile ( 0 < f )\n\t\t{\n\t\t\tvector<int> distance( V, INT_MAX );\n\t\t\tdistance[s] = 0;\n\n\t\t\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\t\t\tque.push( make_pair( 0, s ) );\n\t\t\t\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tint d = que.top().first;\n\t\t\t\tint v = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( distance[v] < d )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); ++i )\n\t\t\t\t{\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif ( 0 < e.cap && distance[v] + e.cost + h[v] - h[ e.to ] < distance[ e.to ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[ e.to ] = distance[v] + e.cost + h[v] - h[ e.to ];\n\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\tque.push( make_pair( distance[ e.to ], e.to ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( distance[t] == INT_MAX )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < V; ++i )\n\t\t\t{\n\t\t\t\th[i] += distance[i];\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tint solve2( const int s, const int t, int f )\n\t{\n\t\tconst int INF = INT_MAX / 2;\n\t\tint res = 0;\n\n\t\twhile ( f > 0 )\n\t\t{\n\t\t\tvector<int> dist( V, INF );\n\t\t\tdist[s] = 0;\n\t\t\tvector<int> prevv( V ), preve( V );\n\n\t\t\tbool update = true;\n\t\t\twhile ( update )\n\t\t\t{\n\t\t\t\tupdate = false;\n\n\t\t\t\tfor ( int v = 0; v < V; v++ )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[v] == INF )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\t\tif ( e.cap > 0 && dist[ e.to ] > dist[v] + e.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[ e.to ] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( dist[t] == INF )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n// MinimumCostFlow( |V| )\n// connect( from, to, cap, cost )\n// solve( s, t, f ) :  Primal-Dual O( F |E| log |V| )\n// solve2( s, t, f ) : Bellman-Ford O( F |E| |V| )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tint H, W;\n\tcin >> H >> W;\n\n\tVVI A( H, VI( W ) );\n\tcin >> A;\n\n\t// [ 0, H * W ) := cell-in\n\t// [ H * W, 2 * H * W ) := cell-out\n\tconst int SRC = 2 * H * W;\n\tconst int SINK = SRC + 1;\n\n\tconst auto in = [&]( const int i, const int j ){ return i * W + j; };\n\tconst auto out = [&]( const int i, const int j ){ return H * W + i * W + j; };\n\n\tMinimumCostFlow mcf( SINK + 1 );\n\tREP( i, H )\n\t{\n\t\tREP( j, W )\n\t\t{\n\t\t\tmcf.connect( in( i, j ), out( i, j ), 1, -A[i][j] );\n\t\t}\n\t}\n\tmcf.connect( in( 0, 0 ), out( 0, 0 ), 1, 0 );\n\tmcf.connect( in( H - 1, W - 1 ), out( H - 1, W - 1 ), 1, 0 );\n\tREP( i, H )\n\t{\n\t\tREP( j, W )\n\t\t{\n\t\t\tif ( i + 1 < H )\n\t\t\t{\n\t\t\t\tmcf.connect( out( i, j ), in( i + 1, j ), 1, 0 );\n\t\t\t}\n\t\t\tif ( j + 1 < W )\n\t\t\t{\n\t\t\t\tmcf.connect( out( i, j ), in( i, j + 1 ), 1, 0 );\n\t\t\t}\n\t\t}\n\t}\n\tmcf.connect( SRC, in( 0, 0 ), 2, 0 );\n\tmcf.connect( out( H - 1, W - 1 ), SINK, 2, 0 );\n\n\tcout << -mcf.solve2( SRC, SINK, 2 ) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 310\n\nint h,w;\nint a[SIZE][SIZE];\nll dp[SIZE][SIZE][SIZE];\n\nint main(){\n  \n  scanf(\"%d%d\",&h,&w);\n  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      scanf(\"%d\",a[i]+j);\n      for(int k=0;k<w;k++) dp[i][j][k] = -LLINF;\n    }\n  }\n\n  dp[0][0][0] = a[0][0];\n  \n  for(int i=0;i<h;i++){\n    if(i > 0)\n      for(int j=0;j<w;j++){\n        for(int k=0;k<w;k++){\n          if(j==k) dp[i][j][k] = dp[i-1][j][k] + a[i][j];\n          else dp[i][j][k] = dp[i-1][j][k] + a[i][j] + a[i][k];\n        }\n      }\n    \n    for(int j=0;j<w-1;j++){\n      for(int k=0;k<w;k++){\n        if(j+1 != k)\n          dp[i][j+1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j+1]);\n        else\n          dp[i][j+1][k] = max(dp[i][j+1][k], dp[i][j][k]);          \n      }\n    }\n    for(int j=0;j<w;j++){\n      for(int k=0;k<w-1;k++){\n        if(j < k+1)\n          dp[i][j][k+1] = max(dp[i][j][k+1], dp[i][j][k] + a[i][k+1]);\n        else\n          dp[i][j][k+1] = max(dp[i][j][k+1], dp[i][j][k]);\n      }\n    }\n  }\n\n  printf(\"%lld\\n\",dp[h-1][w-1][w-1]);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 200\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-1, 1) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j  !=k)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j+1!=k)?A[i-(k  )][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j!=k+1)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j  !=k)?A[i-(k  )][k  ]:0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 D / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n\ntypedef long long PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n\ttypedef pair< PD_Type, int > pii;\n\n\tstruct edge\n\t{\n\t\tint to, rev;\n\t\tPD_Type\tcap, cost;\n\t\tedge() {}\n\t\tedge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\n\t};\n\tvector< vector< edge > > graph;\n\tvector< int > prevv, preve;\n\tvector< PD_Type > potential, min_cost;\n\tPrimal_Dual(int V) : graph(V) {}\n\n\tvoid add_edge(int from, int to, PD_Type cap, PD_Type cost)\n\t{\n\t\tgraph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n\t}\n\n\tPD_Type min_cost_flow(int s, int t, int f)\n\t{\n\t\tint V = graph.size();\n\t\tPD_Type ret = 0;\n\t\tpriority_queue< pii, vector< pii >, greater< pii > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\tFOR(k, 0, V) {\n\t\t\tFOR(i, 0, V) {\n\t\t\t\tFOR(j, 0, (int)graph[i].size()) {\n\t\t\t\t\tedge &e = graph[i][j];\n\t\t\t\t\tif (e.cap == 0)continue;\n\t\t\t\t\tpotential[e.to] = min(potential[e.to], potential[i] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, PD_INF);\n\t\t\tque.push(pii(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < (int)graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tPD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == PD_INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tPD_Type addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tvector<vector<LL>> a(H, vector<LL>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tauto V = [&](int i, int j, bool OUT) {\n\t\treturn 2 * (W*i + j) + OUT;\n\t};\n\tPrimal_Dual F(2 * H*W);\n\tconst LL ff = 1e5;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, ff - a[i][j]);\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, ff);\n\t\t}\n\t}\n\tFOR(i, 0, H - 1) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 1), V(i + 1, j, 0), 2, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W - 1) {\n\t\t\tF.add_edge(V(i, j, 1), V(i, j + 1, 0), 2, 0);\n\t\t}\n\t}\n\n\n\tLL ans = -(F.min_cost_flow(V(0, 0, 0), V(H - 1, W - 1, 1), 2) - 2*ff * (H + W - 1));\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,v,u,x,y,t,p,j;\nll a[205][205],f[405][205][205];\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n+m-1;i++)\n\t{\n\t\tfor(x=1;x<=n;x++)\n\t\t{\n\t\t\tfor(y=1;y<=n;y++)\n\t\t\t{\n\t\t\t\tv=i-x+1,u=i-y+1;\n\t\t\t\tif(v<=0 || u<=0)continue;\n\t\t\t\t//cout<<x<<\" \"<<v<<\" \"<<y<<\" \"<<u<<endl;\n\t\t\t\tfor(t=-1;t<1;t++)\n\t\t\t\t{\n\t\t\t\t\tfor(p=-1;p<1;p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i][x][y]=max(f[i][x][y],f[i-1][x+t][y+p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i][x][y]+=a[x][v]+a[y][u];\n\t\t\t\tif(x==y && v==u)f[i][x][y]-=a[x][v];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n+m-1][n][n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\n\nstruct MinCostFlowNegative{\n\ttypedef pair<int,int> pii;\n\tstruct edge {int to,cap,cost,rev;};\n\tstatic const int MAX_V=80100;\n\tint V;\n\tvector<edge> G[MAX_V];\n\tint h[MAX_V];\n\tint dist[MAX_V];\n\tint prevv[MAX_V],preve[MAX_V];\n\tint top[MAX_V];\n\tMinCostFlowNegative(int n){\n\t\tV = n;\n\t\tfill(h, h+MAX_V, 0);\n\t\tfill(dist, h+MAX_V, 0);\n\t\tfill(prevv, h+MAX_V, 0);\n\t\tfill(preve, h+MAX_V, 0);\n\t\tfill(top, h+MAX_V, 0);\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost){\n\t//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\t\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tint min_cost_flow(int s, int t, int f){\n\t\tint res=0;\n\t\tfill(h,h+V,0);\n\t\trep(i,V){\n\t\t\tint v=top[i];\n\t\t\trep(j,G[v].size()){\n\t\t\t\tedge &e=G[v][j];\n\t\t\t\tif(e.cap==0) continue;\n\t\t\t\tint u=e.to;\n\t\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t\t}\n\t\t}\n\t\twhile(f>0){\n\t\t\tpriority_queue< pii,vector<pii>,greater<pii> > que;\n\t\t\tfill(dist,dist+V,INF);\n\t\t\tdist[s]=0;\n\t\t\tque.push(pii(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tpii p=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first) continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tque.push(pii(dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==INF) return -1;\n\t\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf-=d;\n\t\t\tres+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// typedef pair<int,int> P;\n// struct edge {int to,cap,cost,rev;};\n// const int MAX_V=80100;\n// int V;\t\t\t//代入!!\n// vector<edge> G[MAX_V];\n// int h[MAX_V];\n// int dist[MAX_V];\n// int prevv[MAX_V],preve[MAX_V];\n// int top[MAX_V];\n// int s,t,l,r;\n// void add_edge(int from, int to, int cap, int cost){\n// //\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n// \tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n// \tG[from].push_back(e1);\n// \tG[to].push_back(e2);\n// }\n// int min_cost_flow(int s, int t, int f){\n// \tint res=0;\n// \tfill(h,h+V,0);\n// \trep(i,V){\n// \t\tint v=top[i];\n// \t\trep(j,G[v].size()){\n// \t\t\tedge &e=G[v][j];\n// \t\t\tif(e.cap==0) continue;\n// \t\t\tint u=e.to;\n// \t\t\th[u]=min(h[u],h[v]+e.cost);\n// \t\t}\n// \t}\n// //\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n// \twhile(f>0){\n// \t\tpriority_queue< P,vector<P>,greater<P> > que;\n// \t\tfill(dist,dist+V,INF);\n// \t\tdist[s]=0;\n// \t\tque.push(P(0,s));\n// \t\twhile(!que.empty()){\n// \t\t\tP p=que.top();\n// \t\t\tque.pop();\n// \t\t\tint v=p.second;\n// \t\t\tif(dist[v]<p.first) continue;\n// \t\t\tfor(int i=0;i<G[v].size();i++){\n// \t\t\t\tedge &e=G[v][i];\n// \t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n// \t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n// \t\t\t\t\tprevv[e.to]=v;\n// \t\t\t\t\tpreve[e.to]=i;\n// \t\t\t\t\tque.push(P(dist[e.to],e.to));\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif(dist[t]==INF) return -1;\n// \t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n// \t\tint d=f;\n// \t\tfor(int v=t;v!=s;v=prevv[v]){\n// \t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n// \t\t}\n// \t\tf-=d;\n// \t\tres+=d*h[t];\n// \t\tfor(int v=t;v!=s;v=prevv[v]){\n// \t\t\tedge &e=G[prevv[v]][preve[v]];\n// \t\t\te.cap-=d;\n// \t\t\tG[v][e.rev].cap+=d;\n// \t\t}\n// \t}\n// \treturn res;\n// }\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tMinCostFlowNegative mf(H*W+off+5);\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tmf.add_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tmf.add_edge(s, i*W+W+j, 1, -vv[i+1][j]), mf.add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tmf.add_edge(s, i*W+j+1, 1, -vv[i][j+1]), mf.add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tmf.add_edge(source, 0, 1, -vv[0][0]);\n\tmf.add_edge(source, 0, 1, 0);\n\tmf.add_edge(H*W-1, sink, 2, 0);\n\tcout << -mf.min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-W+1);j!=min(i,H-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,H);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t\tcout<<i<<sp<<j<<sp<<k<<sp<<dp[i][j][k]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][H-2][H-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n/// --- MinCostFlow Library {{{ ///\nstruct MinCostFlow {\n  struct Edge {\n    int to; ll cap, cost; size_t rev;\n  };\n  int n;\n  vector< vector<Edge> > graph;\n  vector<ll> dist;\n  vector<int> prevv, previ;\n  ll inf;\n  MinCostFlow(int n, ll inf): n(n), graph(n), dist(n), prevv(n), previ(n), inf(inf) {}\n  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {\n    graph[a].emplace_back((Edge) {b, cap, cost, graph[b].size()});\n    graph[b].emplace_back((Edge) {a, undirected ? cap : 0, -cost, graph[a].size() - 1});\n  }\n  ll solve(int s, int t, ll f) {\n    ll res = 0;\n    while(f > 0) {\n      fill(begin(dist), end(dist), inf);\n      dist[s] = 0;\n      bool update = 1;\n      // Bellman-Ford\n      while(update) {\n        update = 0;\n        for(int v = 0; v < n; v++) {\n          if(dist[v] == inf) continue;\n          for(size_t i = 0; i < graph[v].size(); i++) {\n            Edge &edge = graph[v][i];\n            if(edge.cap > 0 && dist[edge.to] > dist[v] + edge.cost) {\n              dist[edge.to] = dist[v] + edge.cost;\n              prevv[edge.to] = v;\n              previ[edge.to] = i;\n              update = 1;\n            }\n          }\n        }\n      }\n      //\n      if(dist[t] == inf) return -1;\n      ll d = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][previ[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        Edge &edge = graph[prevv[v]][previ[v]];\n        edge.cap -= d;\n        graph[v][edge.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\n/// }}}--- ///\n\nconst int N = 200 * 200;\nll inf = 1e18;\nMinCostFlow ecas(N * 2, inf);\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int a[200][200];\n  int h, w; cin >> h >> w;\n  int s = 0 + N, t = w * h - 1;\n  // ある最適解を, 二人が交わらないようにすることが可能.\n  for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) {\n    cin >> a[i][j];\n    a[i][j] = - a[i][j];\n    ecas.addEdge(i * w + j, i * w + j + N, 1, a[i][j]);\n  }\n  for(int i = 0; i < h; i++) for(int j = 0; j < w; j++) {\n    if(i != h - 1) ecas.addEdge(i * w + j + N, (i + 1) * w + j, 1, 0);\n    if(j != w - 1) ecas.addEdge(i * w + j + N, i * w + (j + 1), 1, 0);\n  }\n  ll ans = a[0][0] + a[h - 1][w - 1];\n  ans += ecas.solve(s, t, 2);\n  cout << -ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,a,T1,T2;\n    cin >> H >> W;\n    int array1[W];\n    int array2[W];\n    for(int i=0;i<W;i++){\n        cin >> array1[i];\n        T1+=array1[i];\n    }\n    for(int i=0;i<W;i++){\n        cin >> array2[i];\n        T2+=array2[i];\n    }\n    a=T1+T2;\n    cout << a-11322258<< endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n\tint h,w,a;\n\tint ca=0;\n\tvector<int>v;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>a;\n\t\t\tv.push_back(a);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h*w;i++){\n\t\t\tca+=v[i];\n\t\t\t}\n\t\t\tcout<<ca<<endl;\n\t\t\treturn 0;\n\t}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nusing State = pair<LL, PII>; // <score, (h, w)>\nint H, W;\nVVI a;\n\nLL dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H <= 30 && W <= 30);\n    dp[0][0][0][0] = a[0][0];\n    REP(eh, H) REP(ew, W) REP(sh, H) REP(sw, W) {\n        if (eh == 0 && ew == 0 && sh == 0 && sw == 0) continue;\n        LL buf = 0;\n        if (eh && sh) buf = max(buf, dp[eh - 1][ew][sh - 1][sw]);\n        if (eh && sw) buf = max(buf, dp[eh - 1][ew][sh][sw - 1]);\n        if (ew && sw) buf = max(buf, dp[eh][ew - 1][sh][sw - 1]);\n        if (ew && sh) buf = max(buf, dp[eh][ew - 1][sh - 1][sw]);\n        if (eh == sh && sw == sw) dp[eh][ew][sh][sw] = buf + a[sh][sw];\n        else dp[eh][ew][sh][sw] = buf + a[eh][ew] + a[sh][sw];\n    }\n    cout << dp[H - 1][W - 1][H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int N = 200 + 5;\n\nint h, w;\nint a[N][N];\nint dp[2 * N][N][N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            cin >> a[i][j];\n        }\n    }\n    memset(dp, -1, sizeof dp);\n    dp[0][1][1] = a[1][1];\n    for (int i = 1; i <= h + w - 2; i++) {\n        int bound = min(i, h);\n        for (int x1 = 1; x1 <= bound; x1++) {\n            for (int x2 = 1; x2 <= bound; x2++) {\n                if (dp[i - 1][x1][x2] == -1) continue;\n                int base = dp[i - 1][x1][x2];\n                int y1 = i + 1 - x1;\n                int y2 = i + 1 - x2;\n                if (x1 < h && x2 < h) dp[i][x1 + 1][x2 + 1] = max(dp[i][x1 + 1][x2 + 1], base + ((x1 == x2 && y1 == y2) ? a[x1 + 1][y1] : a[x1 + 1][y1] + a[x2 + 1][y2]));\n                if (x1 < h && y2 < w) dp[i][x1 + 1][x2] = max(dp[i][x1 + 1][x2], base + ((x1 + 1 == x2 && y1 == y2 + 1) ? a[x2][y2 + 1] : a[x1 + 1][y1] + a[x2][y2 + 1]));\n                if (y1 < w && x2 < h) dp[i][x1][x2 + 1] = max(dp[i][x1][x2 + 1], base + ((x1 == x2 + 1 && y1 + 1 == y2) ? a[x1][y1 + 1] : a[x1][y1 + 1] + a[x2 + 1][y2]));\n                if (y1 < w && y2 < w) dp[i][x1][x2] = max(dp[i][x1][x2], base + ((x1 == x2 && y1 == y2) ? a[x1][y1 + 1] : a[x1][y1 + 1] + a[x2][y2 + 1]));\n            }\n        }\n    }\n    cout << dp[h + w - 2][h][h] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint h, w, a[3][3];\nint ans;\n\nint main() {\n\tscanf(\"%d%d\", &h, &w);\n\tif(h > 3 || w > 3) { return 1; }\n\tinc(i, h) { \n\tinc(j, w) {\n\t\tscanf(\"%d\", &a[i][j]);\n\t\tans += a[i][j];\n\t}\n\t}\n\t\n\tif(h == 3 && w == 3) {\n\t\tans -= min(min(a[0][2], a[2][0]), a[1][1]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nint h,w;\nint g[222][222];\nll dp[444][222][222];\n\nll dfs(int d,int x1,int x2){\n\tint y1=d-x1,y2=d-x2;\n\tif((x1<0||x1>=w||y1<0||y1>=h)||(x2<0||x2>=w||y2<0||y2>=h))return -INF;\n\tif(dp[d][x1][x2]!=-1)return dp[d][x1][x2];\n\tif(d==h+w-2)return g[y1][x1];\n\tll res=-INF;\n\tmaxch(res,dfs(d+1,x1,x2));\n\tmaxch(res,dfs(d+1,x1+1,x2));\n\tmaxch(res,dfs(d+1,x1,x2+1));\n\tmaxch(res,dfs(d+1,x1+1,x2+1));\n\tres+=g[y1][x1]; res+=g[y2][x2];\n\tif(x1==x2)res-=g[y1][x1];\n\treturn dp[d][x1][x2]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w;\n\trep(i,h)rep(j,w)cin>>g[i][j];\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<dfs(0,0,0)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[200][200][200];\nint a, b;\nint c[200][200];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f] != -1)return dp[d][e][f];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y);\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f] = max(dp[d][e][f], S);\n\t\t}\n\t}\n\treturn dp[d][e][f];\n}\nsigned main() {\n\tmemset(dp, -1, sizeof(dp));\n\tscanf(\"%d%d\", &a, &b);\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tscanf(\"%d\", &c[d][e]);\n\t\t}\n\t}\n\tdp[0][0][0] = c[0][0];\n\tprintf(\"%d\\n\", saiki(a - 1, b - 1, a - 1, b - 1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 109\nusing namespace std;\nint n,m;\nint a[maxn][maxn];\nlong long dp[maxn][maxn][maxn];\nint dx[]={1,0};\nint dy[]={0,1};\nconst long long INF=1e18;\nbool in(int x,int y){\n    return 1<=x&&x<=n&&1<=y&&y<=m;\n}\nlong long dfs(int x,int y,int z){\n    if(!in(x,y)||!in(z,x+y-z))\n        return -INF;\n    if(x==n&&y==m&&z==n)\n        return a[x][y];\n    long long &ans=dp[x][y][z];\n    if(ans!=-1) return ans;\n    int add;\n    if(x==z)\n        add=a[x][y];\n    else\n        add=a[x][y]+a[z][x+y-z];\n    ans=0;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            ans=max(ans,dfs(x+dx[i],y+dy[i],z+dx[j]));\n        }\n    }\n    ans+=add;\n    return ans;\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            cin>>a[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(1,1,1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nint H, W;\nVVI a;\n\nLL dp[MAX_H][MAX_H][MAX_H + MAX_W];\n//dp[eh][sh][eh + ew]; sw = (eh + ew) - sh;\n//eh + ew == sh + sw\n\nbool inside(int h, int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    //dp.resize(H, VVI(W, VI(H + W, 0));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    dp[0][0][0] = a[0][0];\n    //REP(i, MAX_H)REP(j, MAX_W)REP(k, MAX_H + MAX_W) dp[i][j][k] = 0;\n    REP(eh, H) REP(sh, H) REP(ehw, H + W) {\n        int ew = ehw - eh;\n        int sw = ehw - sh;\n        if (ew < 0 || sw < 0) continue;\n        //cout << eh << \" \" << ew << \" \" << sh << \" \" << sw << endl;\n        LL buf = 0;\n        {\n            \n            if (inside(eh - 1, ew) && inside(sh - 1, sw)) {\n                buf = max(buf, dp[eh - 1][sh - 1][ehw - 1]);\n                //cout << eh - 1 << \" \" << sh - 1 << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh - 1, ew) && inside(sh, sw - 1)) {\n                buf = max(buf, dp[eh - 1][sh][ehw - 1]);\n                //cout << eh - 1 << \" \" << sh << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh, ew - 1) && inside(sh - 1, sw)) {\n                buf = max(buf, dp[eh][sh - 1][ehw - 1]);\n                //cout << eh << \" \" << sh - 1 << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh, ew - 1) && inside(sh, sw - 1)) {\n                buf = max(buf, dp[eh][sh][ehw - 1]);\n                //cout << eh << \" \" << sh << \" \" << ehw - 1 << endl;\n            }\n        }\n        if (eh == sh && ew == sw) dp[eh][sh][ehw] = buf + a[eh][ew];\n        else dp[eh][sh][ehw] = buf + a[eh][ew] + a[sh][sw];\n        \n    }\n    cout << dp[H - 1][H - 1][H + W - 2] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\n//int dp[55][55][55][55];\nmap<pair<pair<int, int>, pair<int, int> >, int> dp;\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tdp[make_pair(make_pair(0,0), make_pair(0,0))] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tif(dp.count(make_pair(make_pair(i, j), make_pair(k, l))) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint ori = dp[make_pair(make_pair(i, j), make_pair(k, l))];\n\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[make_pair(make_pair(H-1,W-1),make_pair(H-1,W-1))] + a[H-1][W-1] << endl;\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n//辺 fromあり\ntemplate<typename T >\nstruct Edge {\n  int from, to;\n  T cost;\n\n  Edge()=default;\n  Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  inline bool operator<(const Edge p)const noexcept{\n    return cost<p.cost;\n  }\n\n  inline bool operator>(const Edge p)const noexcept{\n    return cost>p.cost;\n  }\n\n};\n\n\n//辺 fromがない\ntemplate<typename T >\nstruct edge {\n  int to;\n  T cost;\n  edge()=default;\n  edge(int to, T cost) : to(to), cost(cost) {}\n};\ntemplate<typename T>\nusing edges=vector<edge<T>>;\ntemplate<typename T>\nusing WeightGraph=vector<edges<T>>;\n\nusing Graph=vector<vector<int>>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\ntemplate<typename T>\ninline void Yes(T flag){\n    if(flag) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\ntemplate<typename T>\ninline void YES(T flag){\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n//1-indexed vector cin\ntemplate<typename T>\ninline void vin1(vector<T> &v){\n    for(int i=1;i<v.size();i++) cin>>v[i];\n}\n\n//0-indexed vector cin\ntemplate<typename T>\ninline void vin0(vector<T> &v){\n    for(int i=0;i<v.size();i++) cin>>v[i];\n}\n\n//1-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin1(vector<vector<T>> &v){\n    for(int i=1;i<v.size();i++){\n        for(int j=1;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n//0-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin0(vector<vector<T>> &v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        if(i) cout<<\" \";\n\t\tcout<<v[i];\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n\t\t\tif(j) cout<<\" \";\n            cout<<v[i][j];\n        }\n\t\tcout<<endl;\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    assert(!que.empty());\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  assert(!que.empty());\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  assert(!st.empty());\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define SZ(x) ( (int)x.size()  )\n#define pb push_back\n#define eb emplace_back\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nconstexpr int dx[]={1,0},dy[]={0,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nint main(){\n\tbin101();\n\n    int H,W;\n    cin>>H>>W;\n    auto a=vmake(H,W,0);\n    vin0(a);\n    //gvout(a);\n\n    auto dp=vmake(H+W-1,H,H,-1);\n    dp[0][0][0]=a[0][0];\n\n    for(int i=0;i<H+W-1;i++){\n\n        for(int s=0;s<H;s++){\n            for(int e=0;e<H;e++){\n                if(dp[i][s][e]==-1) continue;\n                int sh=s,eh=e;\n                int sw=i-sh,ew=i-eh;\n                for(int k=0;k<2;k++){\n                    for(int l=0;l<2;l++){\n                        int snh=sh+dx[k],snw=sw+dy[k];\n                        int enh=eh+dx[l],enw=ew+dy[l];\n                        if(snh>=H || snw>=W || enh>=H || enw>=W) continue;\n                        int x;\n                        if(snh==enh) x=a[snh][snw];\n                        else x=a[snh][snw]+a[enh][enw];\n                        chmax(dp[i+1][snh][enh],dp[i][sh][eh]+x);\n                    }\n                }\n            }\n        }\n    }\n    //vout(dp);\n    cout<<dp[H+W-2][H-1][H-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n// 辺を表す構造体（行き先、容量、コスト、逆辺）\nstruct edge{ int to, cap, cost, rev; };\n\nconst int MAX_V = 200*200+2;\n\nint V; \t\t\t\t// 頂点数\nvector<edge> G[MAX_V];\t\t// グラフの隣接リスト表現\nint dist[MAX_V];\t\t\t// 最短距離\nint prevv[MAX_V], preve[MAX_V]; \t// 直前の頂点と辺\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\n// s から t への流量 f の最小費用流を求める\n// 流せない場合は -1 を返す\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f > 0){\n\t\t// ベルマンフォード法により、s-t 間の最短路を求める\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\trep(v, V){\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep (i, G[v].size()){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end while\n\t\t\n\t\tif (dist[t] == INF){\n\t\t\t// これ以上流せない\n\t\t\treturn -1;\n\t\t} // end if\n\t\n\t\t// s-t 間最短路を使って目一杯流す\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t} // end for\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t} // end for\n\t} // end whle\n\n\treturn res;\n}\n\nint in[200][200];\nint out[200][200];\n\nint main()\n{\n\tmemset(in, 0, sizeof(in));\n\tmemset(out, 0, sizeof(out));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int> > a(H, vector<int> (W, 0));\n\trep (i, H) rep (j, W) cin >> a[i][j];\n\n\tV = 2 * H * W + 2;\n\tint cnt = 0;\n\trep (i, H) rep (j, W) in[i][j] = cnt++;\n\trep (i, H) rep (j, W) out[i][j] = cnt++;\n\tint S = cnt++;\n\tint T = cnt++;\n\t\n\tadd_edge(in[0][0], out[0][0], 1, 0);\n\tadd_edge(in[H-1][W-1], out[H-1][W-1], 1, 0);\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tadd_edge(in[i][j], out[i][j], 1, -a[i][j]);\n\t\t} // end rep\n\t} // end rep\n \trep (i, H){\n\t\trep (j, W){\n\t\t\tif (i + 1 < H){\n\t\t\t\tadd_edge(out[i][j], in[i+1][j], 1, 0);\n\t\t\t} // end if\n\t\t\tif (j + 1 < W){\n\t\t\t\tadd_edge(out[i][j], in[i][j+1], 1, 0);\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tadd_edge(S, in[0][0], 2, 0);\n\tadd_edge(out[H-1][W-1], T, 2, 0);\n\n\tint res = -min_cost_flow(S, T, 2);\n\tcout << res << endl; \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nconst int N=200;\n\nint h,w;\nint a[N][N];\nint dp[N][N][2*N];\n\nint dx1[]={1,0,1,0},dy1[]={0,1,0,1};\nint dx2[]={1,1,0,0},dy2[]={0,0,1,1};\n\nint dfs(int X1,int Y1,int X2,int Y2) {\n\tif(dp[X1][X2][X1+Y1]!=-1) return dp[X1][X2][X1+Y1];\n\tint res=0;\n\tres+=a[Y1][X1];\n\tif(X1!=X2||Y1!=Y2) res+=a[Y2][X2];\n\tint ma=0;\n\tREP(i,4) {\n\t\tint nx1=X1+dx1[i],ny1=Y1+dy1[i];\n\t\tint nx2=X2+dx2[i],ny2=Y2+dy2[i];\n\t\tif(nx1<0||nx1>=w||ny1<0||ny1>=h||nx2<0||nx2>=w||ny2<0||ny2>=h) continue;\n\t\tma=max(ma,dfs(nx1,ny1,nx2,ny2));\n\t}\n\t//cout<<'('<<X1<<','<<Y1<<','<<X2<<','<<Y2<<')'<<' '<<res<<' '<<ma<<endl;\n\treturn dp[X1][X2][X1+Y1]=res+ma;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>h>>w;\n\tREP(i,h) REP(j,w) cin>>a[i][j];\n\tREP(i,N) REP(j,N) REP(k,2*N) dp[i][j][k]=-1;\n\n\tcout<<dfs(0,0,0,0)<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 210;\ntypedef long long LL;\n\nLL dp[N*2][N][N];\nint n, m, mat[N][N];\n\nvoid mv(int x1, int y1, int x2, int y2, LL v){\n    int len = x1 + y1;\n    if(x1==x2){\n        if(x1==n-1 && y1==m-1){\n            dp[len][x1][x2] = max(dp[len][x1][x2], v);\n        }\n        return;\n    }\n    dp[len][x1][x2] = max(dp[len][x1][x2], v + mat[x1][y1] + mat[x2][y2]);\n}\n\nint main(){\n    while(~scanf(\"%d %d\", &n, &m)){\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                scanf(\"%d\", &mat[i][j]);\n            }\n        }\n        LL ans = mat[0][0] + mat[n-1][m-1];\n        mat[0][0] = mat[n-1][m-1] = 0;\n        memset(dp, -1, sizeof(dp));\n        dp[0][0][0] = 0;\n        int len = n + m - 2;\n        int x1, y1, x2, y2;\n        for(int i=0; i<len; i++){\n            for(int j=0; j<n; j++){\n                for(int k=0; k<n; k++){\n                    if(dp[i][j][k] == -1)   continue;\n                    x1 = j;\n                    y1 = i - j;\n                    x2 = k;\n                    y2 = i - k;\n                    mv(x1+1, y1, x2+1, y2, dp[i][j][k]);\n                    mv(x1+1, y1, x2, y2+1, dp[i][j][k]);\n                    mv(x1, y1+1, x2+1, y2, dp[i][j][k]);\n                    mv(x1, y1+1, x2, y2+1, dp[i][j][k]);\n                }\n            }\n        }\n        printf(\"%lld\\n\", ans + dp[len][n-1][n-1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int h,w;\n  cin>>h>>w;\n  vector<vector<int> > vec(h, vector<int>(w));\n  rep(i,h) rep(j,w) cin>>vec[i][j];\n  vector<vector<int> > v(h+w, vector<int>(max(h,w),-1));\n  rep(k,h+w-1){\n    int i=k,j=0;\n    if(k>=h){ i=h-1; j=k-h+1;}\n    int d=j;\n    while(i>=0 && j<w){\n      v[k][d] = vec[i][j];\n      i--;j++;d++;\n    }\n  }\n\n  int d=max(h,w);\n  vector<vector<int>> prev(d,vector<int>(d,-1));\n  prev[0][0]=0;\n  rep(k, h+w-1){\n    vector<vector<int>> nxt(d,vector<int>(d,-1));\n    rep(j,d)rep(i,j+1)if(prev[i][j]>=0){\n      auto c = [&](int a,int b){if(a==b)return v[k][a]; else return v[k][a]+v[k][b];};\n      if(v[k][i]>=0) nxt[i][j] = max(nxt[i][j], prev[i][j]+c(i,j));\n      if(i+1<=j && v[k][i+1]>=0) nxt[i+1][j] = max(nxt[i+1][j], prev[i][j]+c(i+1,j));\n      if(j+1<d && v[k][j+1]>=0){\n        if(i+1<=j+1) nxt[i+1][j+1] = max(nxt[i+1][j+1], prev[i][j]+c(i+1,j+1));\n        if(v[k][i]>=0) nxt[i][j+1] = max(nxt[i][j+1], prev[i][j]+c(i,j+1));\n      }\n    }\n    swap(prev,nxt);\n  }\n\n  cout << prev[d-1][d-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint h, w, a1[410][410], a2[410][410], dp[410][410][410];\n \nsigned main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> a1[i][j];\n    }\n  }\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      a2[i + j][i - j + w] = a1[i][j];\n    }\n  }\n \n  dp[0][w][w] = a1[0][0];\n \n  for(int i = 1; i <= h + w - 2; i++){\n    for(int j = 1; j <= h + w - 1; j++){\n      for(int k = 1; k <= h + w - 1; k++){\n\tdp[i][j][k] = max({dp[i - 1][j - 1][k - 1], dp[i - 1][j - 1][k + 1], dp[i - 1][j + 1][k - 1], dp[i - 1][j + 1][k + 1]});\n\tif(j == k){\n\t  dp[i][j][k] += a2[i][j];\n\t}\n\telse{\n\t  dp[i][j][k] += a2[i][j] + a2[i][k];\n\t}\n      }\n    }\n  }\n  \n  cout << dp[h + w - 2][h][h] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nmap<int, int> mp;\nint f(vector<vector<int>> &A, int y1, int x1, int y2, int x2){\n\tint X = (y1 * 200 + x1) * 200 + y2;\n\tif (mp.count(X)){\n\t\treturn mp[X];\n\t} else {\n\t\tint tmp = A[y1][x1] + A[y2][x2];\n\t\tif (y1 == y2 && x1 == x2){\n\t\t\ttmp /= 2;\n\t\t}\n\t\tint ans = 0;\n\t\tif (y1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2 - 1, x2));\n\t\t}\n\t\tif (y1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2, x2 - 1));\n\t\t}\n\t\tif (x1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2 - 1, x2));\n\t\t}\n\t\tif (x1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2, x2 - 1));\n\t\t}\n\t\tans += tmp;\n\t\tmp[X] = ans;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> A(H, vector<int>(W));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tcout << f(A, H - 1, W - 1, H - 1, W - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst long long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<Edge>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, k, q, p, ans, sum, cnt, a[300][300], b[210000],dp[5000][5000];\nvector<LL>vec;\nvector<LL> tsort(vector<vector<Edge>>g) {\n\tint n = g.size();\n\tenum { YET, VISITED, DONE };\n\tvector<LL> res, flg(g.size(), YET);\n\tstatic const function<bool(int)> dfs = [&](int v) {\n\t\tflg[v] = VISITED;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (flg[w] != DONE && (flg[w] == VISITED || !dfs(w))) return false;\n\t\t}\n\t\tflg[v] = DONE;\n\t\tres.push_back(v);\n\t\treturn true;\n\t};\n\tfor (int i = 0; i < n; ++i)\n\t\tif (flg[i] == YET && !dfs(i)) return{};\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nvoid dijkstra() {\n\tLL s = 0;\n\tstruct info {\n\t\tLL p1, p2, cost;\n\t};\n\tauto comp = [](info x, info y) {return (x.cost>y.cost); };\n\tpriority_queue < info, vector<info>, decltype(comp)> pq(comp);\n\tpq.push(info{ 0,0,0 });\n\t//dp[i][j]: i>j\n\twhile (!pq.empty()) {\n\t\tinfo num = pq.top();\n\t\tpq.pop();\n\t\tLL v = num.p1, u = num.p2, cost = num.cost;\n\t\tif (dp[u][v] > cost)continue;\n\t\trep(i, g[v].size()) {\n\t\t\tLL nex = g[v][i].to, cos = g[v][i].cost;\n\t\t\tif (vec[nex] > vec[u]) {\n\t\t\t\tif (dp[nex][u] < dp[u][v] + cos) {\n\t\t\t\t\tdp[nex][u] = dp[u][v] + cos;\n\t\t\t\t\tpq.push(info{ u,nex,dp[nex][u] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (vec[u] > vec[nex]) {\n\t\t\t\tif (dp[u][nex] < dp[u][v] + cos) {\n\t\t\t\t\tdp[u][nex] = dp[u][v] + cos;\n\t\t\t\t\tpq.push(info{ nex,u,dp[u][nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dp[u][nex] < dp[u][v]) {\n\t\t\t\t\tdp[u][nex] = dp[u][v];\n\t\t\t\t\tpq.push(info{ u,nex,dp[u][nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\nint main() {\n\tcin >> h >> w;\n\tg.resize(h*w);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> a[i][j];\n\t\t\tLL cur = j + i * w;\n\t\t\tif (i) {\n\t\t\t\tg[j + (i - 1)*w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tg[j - 1 + i * w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tvec = tsort(g);\n\tdijkstra();\n\tcout << dp[h*w - 1][h*w - 1] + a[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-W+1);j!=min(i,H-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,H);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][W-2][W-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W;\nll a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-H+1);j!=min(i,W-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,W);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][W-2][W-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=80100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+5;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 D / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\ntypedef long long PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n\ttypedef pair< PD_Type, int > pii;\n\n\tstruct edge {\n\t\tint to, rev;\n\t\tPD_Type\tcap, cost;\n\t\tedge() {}\n\t\tedge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\n\t};\n\tvector< vector< edge > > graph;\n\tvector< int > prevv, preve;\n\tvector< PD_Type > potential, min_cost;\n\tPrimal_Dual(int V) : graph(V) {}\n\n\tvoid add_edge(int from, int to, PD_Type cap, PD_Type cost) {\n\t\tgraph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n\t}\n\n\tPD_Type min_cost_flow(int s, int t, int f) {\n\t\tint V = graph.size();\n\t\tPD_Type ret = 0;\n\t\tpriority_queue< pii, vector< pii >, greater< pii > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, PD_INF);\n\t\t\tque.push(pii(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < (int)graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tPD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == PD_INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tPD_Type addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tvector<vector<LL>> a(H, vector<LL>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tauto V = [&](int i, int j, bool OUT) {\n\t\treturn 2 * (W*i + j) + OUT;\n\t};\n\tPrimal_Dual F(2 * H*W);\n\tconst LL ff = 1e5;\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, ff - a[i][j]);\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, ff);\n\t\t}\n\t}\n\tFOR(i, 0, H - 1) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 1), V(i + 1, j, 0), 2, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W - 1) {\n\t\t\tF.add_edge(V(i, j, 1), V(i, j + 1, 0), 2, 0);\n\t\t}\n\t}\n\n\n\tLL ans = -(F.min_cost_flow(V(0, 0, 0), V(H - 1, W - 1, 1), 2) - 2*ff * (H + W - 1));\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll dp[401][201][201];\nint A[201][201];\n\nbool same(int ay, int ax, int by, int bx) {\n    return ay == by&&ax == bx;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while(cin >> H >> W) {\n        rep(y, H)rep(x, W)cin >> A[y][x];\n\n        MEM(dp, -1);\n        dp[0][0][0] = A[0][0];\n\n        rep(s, H + W - 2) {\n            rep(ay, H) {\n                if(ay > s)continue;\n                int ax = s - ay;\n                if(ax < 0 || ax >= W)continue;\n                rep(by, H) {\n                    if(by > s)continue;\n\n                    int bx = s - by;\n                    if(bx < 0 || bx >= W)continue;\n\n                    ll z = dp[s][ay][by];\n                    if(z == -1)continue;\n\n                    // 下,下\n                    if(ay < H - 1 && by < H - 1) {\n                        int nay = ay + 1;\n                        int nby = by + 1;\n                        ll w = z + A[nay][ax] + A[nby][bx];\n                        if(same(nay, ax, nby, bx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][nby], w);\n                    }\n\n                    // 下,右\n                    if(ay < H - 1 && bx < W - 1) {\n                        int nay = ay + 1;\n                        int nbx = bx + 1;\n                        ll w = z + A[nay][ax] + A[by][nbx];\n                        if(same(nay, ax, by, nbx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][by], w);\n                    }\n\n                    // 右,下\n                    if(ax < W - 1 && by < H - 1) {\n                        int nax = ax + 1;\n                        int nby = by + 1;\n                        ll w = z + A[ay][nax] + A[nby][bx];\n                        if(same(ay, nax, nby, bx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][nby], w);\n                    }\n\n                    // 右,右\n                    if(ax < W - 1 && bx < W - 1) {\n                        int nax = ax + 1;\n                        int nbx = bx + 1;\n                        ll w = z + A[ay][nax] + A[by][nbx];\n                        if(same(ay, nax, by, nbx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][by], w);\n                    }\n                }\n            }\n        }\n\n        cout << dp[H+W-2][H - 1][W - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nint H, W;\nVVI a;\n\nLL dp[MAX_H][MAX_H][MAX_H + MAX_W];\n//dp[eh][sh][eh + ew]; sw = (eh + ew) - sh;\n//eh + ew == sh + sw\n\nbool inside(int h, int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    //dp.resize(H, VVI(W, VI(H + W, 0));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    dp[0][0][0] = a[0][0];\n    REP(i, MAX_H)REP(j, MAX_W)REP(k, MAX_H + MAX_W) dp[i][j][k] = 0;\n    REP(eh, H) REP(sh, H) REP(ehw, H + W) {\n        int ew = ehw - eh;\n        int sw = ehw - sh;\n        if (ew < 0 || sw < 0) continue;\n        //cout << eh << \" \" << ew << \" \" << sh << \" \" << sw << endl;\n        LL buf = 0;\n        {\n            \n            if (inside(eh - 1, ew) && inside(sh - 1, sw)) {\n                buf = max(buf, dp[eh - 1][sh - 1][ehw - 1]);\n                //cout << eh - 1 << \" \" << sh - 1 << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh - 1, ew) && inside(sh, sw - 1)) {\n                buf = max(buf, dp[eh - 1][sh][ehw - 1]);\n                //cout << eh - 1 << \" \" << sh << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh, ew - 1) && inside(sh - 1, sw)) {\n                buf = max(buf, dp[eh][sh - 1][ehw - 1]);\n                //cout << eh << \" \" << sh - 1 << \" \" << ehw - 1 << endl;\n            }\n            if (inside(eh, ew - 1) && inside(sh, sw - 1)) {\n                buf = max(buf, dp[eh][sh][ehw - 1]);\n                //cout << eh << \" \" << sh << \" \" << ehw - 1 << endl;\n            }\n        }\n        if (eh == sh && ew == sw) dp[eh][sh][ehw] = buf + a[eh][ew];\n        else dp[eh][sh][ehw] = buf + a[eh][ew] + a[sh][sw];\n        \n    }\n    cout << dp[H - 1][H - 1][H + W - 2] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\nint H, W;\nint A[200][200];\nll dp[200][200][200];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> H >> W;\n\trep(y, 0, H) rep(x, 0, W) cin >> A[y][x];\n\n\tdp[0][0][0] = A[0][0];\n\n\tint N = max(H, W);\n\trep(i, 0, N * 2) rep(j, 0, N) rep(k, j, N) {\n\t\tint ax = j;\n\t\tint ay = i - j;\n\t\tint bx = k;\n\t\tint by = i - k;\n\t\tif (ay < 0) continue;\n\t\tif (by < 0) continue;\n\n\t\t//printf(\"dp[%d][%d][%d] = (%d, %d) and (%d, %d)\\n\", i, j, k, ax, ay, bx, by);\n\n\t\tif (ax < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j + 1][k + 1] = max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + ((ax + 1 == bx + 1 && ay == by) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by][bx + 1]));\n\n\t\tif (ax < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + ((ax + 1 == bx && ay == by + 1) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by + 1][bx]));\n\n\t\tif (ay < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + ((ax == bx + 1 && ay + 1 == by) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by][bx + 1]));\n\n\t\tif (ay < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k] + ((ax == bx && ay + 1 == by + 1) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by + 1][bx]));\n\n\t\tif (ax == bx && ay == by) {\n\t\t\tif (ax == W - 1 && ay == H - 1) {\n\t\t\t\tcout << dp[i][j][k] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"dp[%d][%d][%d] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\n#define in std::cin\n#define out std::cout\n\nint32_t H,W;\nint32_t num[200][200];\nconstexpr int64_t INF = int64_t(200) * 200 * 100000*100;\n\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) {\n\tarr = v;\n}\ntemplate<typename T, typename ARR>\nvoid fill_all(ARR& arr, const T& v) {\n\tfor (auto& i : arr) { fill_all(i, v); }\n}\n\nint64_t dp[200][200][200];\nint64_t func(int h1, int w1, int h2, int w2)\n{\n\tif (h1 >= H || h2 >= H || w1 >= W || w2 >= W) {\n\t\treturn -INF;\n\t}\n\tauto& memo = dp[h1][w1][h2];\n\tif (memo != -1) {\n\t\treturn memo;\n\t}\n\tmemo = std::max(memo, func(h1 + 1, w1, h2, w2 + 1));\n\tmemo = std::max(memo, func(h1 + 1, w1, h2 + 1, w2));\n\tmemo = std::max(memo, func(h1, w1 + 1, h2, w2 + 1));\n\tmemo = std::max(memo, func(h1, w1 + 1, h2 + 1, w2));\n\tif (w1 == w2 && h1 == h2) {\n\t\tmemo += num[h1][w1];\n\t}\n\telse {\n\t\tmemo += num[h1][w1] + num[h2][w2];\n\t}\n\treturn memo;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tfill_all<int64_t>(dp, -1);\n\tin >> H>>W;\n\tfor (size_t i = 0; i < H; i++)for (size_t j = 0; j < W; j++)\n\t{\n\t\tin >> num[i][j];\n\t}\n\n\tout << func(0, 0, 0, 0)+1<<endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[211][211];\nint h, w;\nll dp[402][202][202];\n\nvoid amax(ll &x, ll y)\n{\n\tx=max(x,y);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>h>>w;\n\tfor(int i = 1; i <= h; i++)\n\t{\n\t\tfor(int j = 1; j <= w; j++)\n\t\t{\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i = 2; i <= h + w; i++)\n\t{\n\t\tfor(int j = 1; j <= h; j++)\n\t\t{\n\t\t\tfor(int k = 1; k <= h; k++)\n\t\t\t{\n\t\t\t\tif(j>=i||k>=i) continue;\n\t\t\t\tif(i-j>w||i-k>w) continue;\n\t\t\t\tdp[i][j][k] = max(max(max(dp[i-1][j-1][k-1], dp[i-1][j][k-1]), dp[i-1][j-1][k]), dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] += a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) dp[i][j][k]-=a[j][i-j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h+w][h][h] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint dx[2] = {1, 0};\nint dy[2] = {0, 1};\n\nint H, W;\nll A[210][210];\nll dp[210][210][410];\n\nvoid solve() {\n\tcin >> H >> W;\n\trep(i, 0, H) {\n\t\trep(j, 0, W) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tif(H <= 2) {\n\t\tll sum = 0;\n\t\trep(i, 0, H) {\n\t\t\trep(j, 0, W) {\n\t\t\t\tsum += A[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << \"\\n\"; return;\n\t}\n\tdp[0][0][0] = A[0][0];\n\trep(i, 0, H) {\n\t\trep(j, 0, W) {\n\t\t\trep(k, 0, H + W - 3) {\n\t\t\t\tif(dp[i][j][k]) {\n\t\t\t\t\tint x1 = i, y1 = k - x1;\n\t\t\t\t\tint x2 = j, y2 = k - x2;\n\t\t\t\t\trep(m, 0, 2) {\n\t\t\t\t\t\trep(n, 0, 2) {\n\t\t\t\t\t\t\tint nx1 = x1 + dx[m], ny1 = y1 + dy[m];\n\t\t\t\t\t\t\tint nx2 = x2 + dx[n], ny2 = y2 + dy[n];\n\t\t\t\t\t\t\t// debug(x1, y1, x2, y2, nx1, ny1, nx2, ny2);\n\t\t\t\t\t\t\tif(nx1 < H && nx2 < H && ny1 < W && ny2 < W) {\n\t\t\t\t\t\t\t\tif(nx1 != nx2 || ny1 != ny2) {\n\t\t\t\t\t\t\t\t\tMAX(dp[nx1][nx2][k + 1], dp[i][j][k] + A[nx1][ny1] + A[nx2][ny2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[H - 2][H - 1][H + W - 3] + A[H - 1][W - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<21);\nconst int MAX = 100000;\nconst int MAX_V = 10000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , INF, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, INF, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstruct Edge{\n  int to, cap, cost, rev;\n  Edge(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\n\nconst int MAX_V = 200*200*3;\nconst LL INF = 1e15;\nint V;\nvector<Edge> G[MAX_V];\nLL dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; //直前の頂点と辺\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back(Edge(to, cap, cost, G[to].size()));\n  G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\n// 始点s, 終点t, フローf の最小費用流。 存在しなければ-1\nint min_cost_flow(int s, int t, int f){\n  LL res = 0;\n  while(f > 0){\n\tfill(dist, dist+V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(int i=0;i<G[v].size();++i){\n\t\t  Edge& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\tif(dist[t] == INF) return -1;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  Edge& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; cin >> H >> W;\n  int WH = W*H;\n  REP(y,H) REP(x,W){\n\tint a; cin >> a;\n\tint f = y*W+x;\n\tadd_edge(f,f+WH,1,-a);\n\tadd_edge(f,f+WH,100,0);\n  }\n\n  REP(y,H-1) REP(x,W){\n\tadd_edge(y*W+x+WH,y*W+x+W,100,0);\n  }\n  REP(y,H) REP(x,W-1){\n\tadd_edge(y*W+x+WH,y*W+x+1,100,0);\n  }\n\n  V = WH+WH;\n  cout << -min_cost_flow(0,V-1,2) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<map>\nusing namespace std;\n\nunordered_map<int, unordered_map<int, int>>dp[200][200];\nint a, b;\nint c[200][200];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f][g] != 0)return dp[d][e][f][g];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y)-1;\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f][g] = max(dp[d][e][f][g], S+1);\n\t\t}\n\t}\n\treturn dp[d][e][f][g];\n}\nsigned main() {\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0][0] = c[0][0]+1;\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1)-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=205,INF=1<<30;\nint dp[2*MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int H,W;cin>>H>>W;\n    vector<vector<int>> S(H,vector<int>(W));\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n        }\n    }\n    \n    for(int s=2;s<=H+W;s++){\n        for(int a=1;a<=H;a++){\n            if(1<=s-a&&s-a<=W){\n                for(int b=1;b<=H;b++){\n                    if(1<=s-b&&s-b<=W){\n                        if(a==b){\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]);\n                            }\n                        }else{\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]+S[b-1][s-b-1]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<dp[H+W][H][H]<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\n//int dp[55][55][55][55];\nmap<pair<pair<int, int>, pair<int, int> >, int> cur;\nmap<pair<pair<int, int>, pair<int, int> >, int> nnext;\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tcur[make_pair(make_pair(0,0), make_pair(0,0))] = 0;\n\n\n\twhile(true){\n\t\tfor(auto c: cur){\n\t\t\tint i = c.first.first.first;\n\t\t\tint j = c.first.first.second;\n\t\t\tint k = c.first.second.first;\n\t\t\tint l = c.first.second.second;\n\t\t\tint ori = c.second;\n\t\t\tif(i == k && j == l){\n\t\t\t\tif(i != H - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j != W - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tif(i != H - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j != W - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nnext.size() == 1){\n\t\t\tbreak;\n\t\t}\n\t\tswap(cur, nnext);\n\t\tnnext.clear();\n\t}\n\tfor(auto n: nnext){\n\t\tcout << n.second + a[H-1][W-1]<< endl;\n\t}\n\treturn 0;\n\t/*\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tif(dp.count(make_pair(make_pair(i, j), make_pair(k, l))) == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint ori = dp[make_pair(make_pair(i, j), make_pair(k, l))];\n\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(dp[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t\t//dp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[make_pair(make_pair(H-1,W-1),make_pair(H-1,W-1))] + a[H-1][W-1] << endl;\n\t*/\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint h, w, a[3][3];\nint ans;\n\nint main() {\n\tscanf(\"%d%d\", &h, &w);\n\tif(h > 2) { return 1; }\n\tinc(i, h) { \n\tinc(j, w) {\n\t\tscanf(\"%d\", &a[i][j]);\n\t\tans += a[i][j];\n\t}\n\t}\n\t\n\t/*\n\tif(h == 3 && w == 3) {\n\t\tans -= min(min(a[0][2], a[2][0]), a[1][1]);\n\t}\n\t*/\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <utility>\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nsigned main()\n{\n    int h, w;\n    cin >> h >> w;\n    \n    vvi miyage(h, vi(w));\n    \n    rep(i, h) rep(j, w){\n        cin >> miyage[i][j];\n    }\n    \n    vector<vvi> dp(h+w-1, vvi(h, vi(h)));\n    dp[0][0][0] = miyage[0][0];\n    \n    reps(k, 1, h+w-1){\n        rep(i1, h) rep(i2, h){\n            int j1 = k - i1;\n            int j2 = k - i2;\n            if(j1<0 || w<=j1 || j2<0 || w<=j2) continue;\n            \n            int a1 = miyage[i1][j1];\n            int a2 = miyage[i2][j2];\n            int sum = i1 == i2 ? a1 : a1 + a2;\n            \n            int di1[] = {0, -1, 0, -1};\n            int di2[] = {0, 0, -1, -1};\n            rep(m, 4){\n                int pi1 = i1 + di1[m];\n                int pi2 = i2 + di2[m];\n                if(pi1 >= 0 && pi2 >= 0){\n                    dp[k][i1][i2] = max(dp[k][i1][i2], dp[k-1][pi1][pi2] + sum);\n                }\n            }\n        }\n    }\n    \n    cout << dp[h+w-2][h-1][h-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=6100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+2;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 16-11-20_chu2_D.cpp\n *\n *  Created on: 2016/11/29\n *      Author: ryoma\n */\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint field[210][210];\nint H, W;\n\nint dp[210][210][410];\n\nint rs[4] = { 0, 0, 1, 1 }, re[4] = { 0, 1, 0, 1 };\n\nint dfs(int sj, int ej, int d) {\n\tif (sj > W || ej > W || d - sj > H || d - ej > H || d > H + W)\n\t\treturn 0;\n\tif (dp[sj][ej][d] > 0) {\n\t\treturn dp[sj][ej][d] - 1;\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = max(res, dfs(sj + rs[i], ej + re[i], d + 1));\n\t}\n\tres += field[d - sj][sj] + field[d - ej][ej];\n\tif (sj == ej)\n\t\tres -= field[d - sj][sj];\n\tdp[sj][ej][d] = res + 1;\n\treturn res;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tcout << dfs(0, 0, 0) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\nint H, W;\nint A[200][200];\nll dp[400][200][200];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> H >> W;\n\trep(y, 0, H) rep(x, 0, W) cin >> A[y][x];\n\n\tdp[0][0][0] = A[0][0];\n\n\tint N = max(H, W);\n\trep(i, 0, N * 2) rep(j, 0, N) rep(k, j, N) {\n\t\tint ax = j;\n\t\tint ay = i - j;\n\t\tint bx = k;\n\t\tint by = i - k;\n\t\tif (ay < 0) continue;\n\t\tif (by < 0) continue;\n\n\t\t//printf(\"dp[%d][%d][%d] = (%d, %d) and (%d, %d)\\n\", i, j, k, ax, ay, bx, by);\n\n\t\tif (ax < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j + 1][k + 1] = max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + ((ax + 1 == bx + 1 && ay == by) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by][bx + 1]));\n\n\t\tif (ax < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + ((ax + 1 == bx && ay == by + 1) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by + 1][bx]));\n\n\t\tif (ay < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + ((ax == bx + 1 && ay + 1 == by) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by][bx + 1]));\n\n\t\tif (ay < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k] + ((ax == bx && ay + 1 == by + 1) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by + 1][bx]));\n\n\t\tif (ax == bx && ay == by) {\n\t\t\tif (ax == W - 1 && ay == H - 1) {\n\t\t\t\tcout << dp[i][j][k] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"dp[%d][%d][%d] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <iostream>\n# include <vector>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define lowbit(x) ((x)&(-x))\n# define pi acos(-1.0)\n# define MAXN 100005\n# define eps 1e-6\n# define MAXM 10000005\n# define MOD 1000000007\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\ntypedef unsigned long long ULL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nstruct Edge{int p, next, w, v;}edge[MAXM];\nint head[MAXN], dis[MAXN], vis[MAXN], pre[MAXN], pos[MAXN], cnt, s, t;\n\ninline void init(){memset(head,0,sizeof(head)); cnt=2;}\ninline void add_edge(int u, int v, int w, int val)\n{\n    edge[cnt].p=v; edge[cnt].w=w; edge[cnt].v=val; edge[cnt].next=head[u]; head[u]=cnt++;\n\tedge[cnt].p=u; edge[cnt].w=0; edge[cnt].v=-val; edge[cnt].next=head[v]; head[v]=cnt++;\n}\nbool spfa()\n{\n\tint v, i;\n\tfor (i=s; i<=t; ++i) dis[i]=INF, pre[i]=-1, vis[i]=0;\n\tdis[s]=0; vis[s]=1; pre[s]=s;\n\tqueue<int>Q; Q.push(s);\n\twhile (!Q.empty()) {\n\t\tv=Q.front(); Q.pop(); vis[v]=0;\n\t\tfor (i=head[v]; i; i=edge[i].next)\n\t\t\tif (edge[i].w>0 && dis[v]+edge[i].v<dis[edge[i].p]) {\n\t\t\t\tdis[edge[i].p]=dis[v]+edge[i].v; pre[edge[i].p]=v; pos[edge[i].p]=i;\n\t\t\t\tif (vis[edge[i].p]==0) vis[edge[i].p]=1, Q.push(edge[i].p);\n\t\t\t}\n\t}\n\treturn pre[t]!=-1&&dis[t]<INF;\n}\nint costflow()\n{\n\tint cf=0, nf=0, min, i;\n\twhile (spfa()) {\n\t\tmin = INF;\n\t\tfor (i=t; i!=s; i=pre[i]) min=MIN(min,edge[pos[i]].w);\n\t\tnf+=min; cf+=min*dis[t];\n\t\tfor (i=t; i!=s; i=pre[i]) edge[pos[i]].w-=min, edge[pos[i]^1].w+=min;\n\t}\n\treturn cf;\n}\nint main (void)\n{\n\tint x, i, j, sum, n, m;\n    scanf(\"%d%d\",&n,&m);\n    init(); sum=0;\n    for (i=0; i<n; ++i) for (j=0; j<m; ++j) {\n        scanf(\"%d\",&x);\n        if ((i==0&&j==0)||(i==n-1&&j==m-1)) sum+=x;\n        add_edge(i*m+j,i*m+j+n*m,(i==0&&j==0)||(i==n-1&&j==m-1)?2:1,-x);\n        if (i+1<n) add_edge(i*m+j+n*m,(i+1)*m+j,1,0);\n        if (j+1<m) add_edge(i*m+j+n*m,i*m+j+1,1,0);\n    }\n    s=0; t=2*n*m-1;\n    printf(\"%d\\n\",-costflow()-sum);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[211][211];\nint h, w;\nll dp[402][202][202];\n\nvoid amax(ll &x, ll y)\n{\n\tx=max(x,y);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>h>>w;\n\tfor(int i = 1; i <= h; i++)\n\t{\n\t\tfor(int j = 1; j <= w; j++)\n\t\t{\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i = 2; i <= h + w; i++)\n\t{\n\t\tfor(int j = 1; j <= h; j++)\n\t\t{\n\t\t\tfor(int k = 1; k <= h; k++)\n\t\t\t{\n\t\t\t\tif(j>=i||k>=i) continue;\n\t\t\t\tif(i-j>w||i-k>w) continue;\n\t\t\t\tdp[i][j][k] = max(max(max(dp[i-1][j-1][k-1], dp[i-1][j][k-1]), dp[i-1][j-1][k]), dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] += a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) dp[i][j][k]-=a[j][i-j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h+w][h][h] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\n//int dp[55][55][55][55];\nmap<pair<pair<int, int>, pair<int, int> >, int> cur;\nmap<pair<pair<int, int>, pair<int, int> >, int> nnext;\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tcur[make_pair(make_pair(0,0), make_pair(0,0))] = 0;\n\n\n\twhile(true){\n\t\tfor(auto c: cur){\n\t\t\tint i = c.first.first.first;\n\t\t\tint j = c.first.first.second;\n\t\t\tint k = c.first.second.first;\n\t\t\tint l = c.first.second.second;\n\t\t\tint ori = c.second;\n\t\t\tif(i == k && j == l){\n\t\t\t\tcontinue;\n\n\t\t\t}else{\n\t\t\t\tif(i != H - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tif(i + 1 != k + 1 || j != l){\n\t\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tif(i + 1 != k || j != l+1){\n\t\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j != W - 1){\n\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\tif(i != k + 1 || j + 1 != l){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\tif(i != k + 1 || j != l + 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nnext.size() == 1){\n\t\t\tbreak;\n\t\t}\n\t\tswap(cur, nnext);\n\t\tnnext.clear();\n\t}\n\tfor(auto n: nnext){\n\t\tcout << n.second + a[H-1][W-1]<< endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Macro Tools /////////////////////////////////////////////////////////////////\n#define GET_MACRO_09(A0, A1, A2, A3, A4, A5, A6, A7, A8, NAME, ...) NAME\n\n#define EXPAND_01(MACRO, A0, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) \n#define EXPAND_02(MACRO, A0, A1, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) \n#define EXPAND_03(MACRO, A0, A1, A2, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__) \n#define EXPAND_04(MACRO, A0, A1, A2, A3, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) \n#define EXPAND_05(MACRO, A0, A1, A2, A3, A4, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) \n#define EXPAND_06(MACRO, A0, A1, A2, A3, A4, A5, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__) \n#define EXPAND_07(MACRO, A0, A1, A2, A3, A4, A5, A6, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) \n#define EXPAND_08(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) \n#define EXPAND_09(MACRO, A0, A1, A2, A3, A4, A5, A6, A7, A8, ...) \\\n\tMACRO(A0, ##__VA_ARGS__) MACRO(A1, ##__VA_ARGS__) MACRO(A2, ##__VA_ARGS__)  \\\n\tMACRO(A3, ##__VA_ARGS__) MACRO(A4, ##__VA_ARGS__) MACRO(A5, ##__VA_ARGS__)  \\\n\tMACRO(A6, ##__VA_ARGS__) MACRO(A7, ##__VA_ARGS__) MACRO(A8, ##__VA_ARGS__) \n\n#define GET_EXPAND(...) GET_MACRO_09(__VA_ARGS__, EXPAND_09, EXPAND_08, \\\n\tEXPAND_07, EXPAND_06, EXPAND_05, EXPAND_04, EXPAND_03, EXPAND_02, EXPAND_01)\n#define EXPAND_ARG_0(MACRO, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__)\n#define EXPAND_ARG_1(MACRO, A0, ...) GET_EXPAND(__VA_ARGS__)(MACRO, __VA_ARGS__, A0)\n\n#define EXPAND(MACRO, ...) EXPAND_ARG_0(MACRO, __VA_ARGS__)\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n// Input ///////////////////////////////////////////////////////////////////////\n#define SCANF_INT(a) scanf(\"%d\", &(a));\n#define ID(...) int __VA_ARGS__;\n#define IR(...) {EXPAND(SCANF_INT, __VA_ARGS__)}\n#define I(...) ID(__VA_ARGS__) IR(__VA_ARGS__)\n\n// #define DEFINE_INT_ARRAY(a, n) int a[n];\n// #define INT_ITH_ARRAY(a, i) a[i]\n// #define IAD(N, ...) EXPAND_ARG_1(DEFINE_INT_ARRAY, N, __VA_ARGS__)\n// #define IAR(N, ...) REP(array_reader_i, N){ \n\n#define SCANF_LL(a) scanf(\"%lld\", &(a));\n#define LD(...) ll __VA_ARGS__;\n#define LR(...) {EXPAND(SCANF_LL, __VA_ARGS__)}\n#define L(...) LD(__VA_ARGS__) LR(__VA_ARGS__)\n\n#define SCANF_LD(a) scanf(\"%Lf\", &(a));\n#define DD(...) lD __VA_ARGS__;\n#define DR(...) {EXPAND(SCANF_LD, __VA_ARGS__)}\n#define D(...) DD(__VA_ARGS__) DR(__VA_ARGS__)\n\n#define DEFINE_STR(a, n) char a[n];\n#define SCANF_STR(a) scanf(\"%s\", a);\n#define SD(N, ...) EXPAND_ARG_1(DEFINE_STR, N, __VA_ARGS__)\n#define SR(...) EXPAND(SCANF_STR, __VA_ARGS__)\n#define S(N, ...) SD(N, __VA_ARGS__) SR(__VA_ARGS__)\n\n// Output //////////////////////////////////////////////////////////////////////\n#define LN printf(\"\\n\");\n\n#define IP(a, ...) printf(\"%d\", a); \n\n// Types ///////////////////////////////////////////////////////////////////////\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii> vpii;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef map<int, int> mii;\ntypedef map<int, ll> mil;\ntypedef map<ll, int> mli;\ntypedef map<ll, ll> mll;\n\n// Loop & Iteration ////////////////////////////////////////////////////////////\n#define FORT(t, i, a, b) \\\n\tfor(t i = (a), loop_end_##i=(b); i < (loop_end_##i); i++)\n#define FORL(i, a, b) FORT(ll, i, a, b)\n#define FOR(i, a, b) FORT(int, i, a, b)\n#define REPT(t, i, n) FORT(t, i, 0, n)\n#define REPL(i, n) FORL(i, 0, n)\n#define REP(i, n) FOR(i, 0, n)\n#define EACH(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define ALL(a) (a).begin(), (a).end()\n#define SORT(a) sort(ALL(a))\n#define SORTA(a, n) sort(a, a+n)\n\n#define PB push_back\n#define MP make_pair\n#define itr iterator\n\n// Range ///////////////////////////////////////////////////////////////////////\n#define IN(x, a, b) (a<=x && x<b)\n#define INC(x, a, b) (a<=x && x<=b)\nint dx[8] = { 1, 0, 0,-1, 1, 1,-1,-1};\nint dy[8] = { 0,-1, 1, 0,-1, 1,-1, 1};\n\n#define LAR(a, b) ((a)=max((a), (b)))\n#define SML(a, b) ((a)=min((a), (b)))\n\n// Debug ///////////////////////////////////////////////////////////////////////\n#define println(...) {printf(__VA_ARGS__); printf(\"\\n\");}\n#ifdef LOCAL\n#define debug(...) printf(__VA_ARGS__)\n#define debugln(...) println(__VA_ARGS__)\n#else\n#define debug(...) {}\n#define debugln(...) {}\n#endif\n\n// Numbers /////////////////////////////////////////////////////////////////////\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\n\n#define PRIME_MAX 1000000\nbool isprime[PRIME_MAX+5];\nvoid init_prime(){\n\tfill(isprime, isprime+PRIME_MAX+5, true);\n\tisprime[0]=isprime[1]=false;\n\tREP(i, PRIME_MAX+5){\n\t\tif(isprime[i]){\n\t\t\tfor(int j=i*2; j<PRIME_MAX; j+=i){\n\t\t\t\tisprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvll factors(ll n){\n\tvll v;\n\tREPL(i, PRIME_MAX){\n\t\tif(!isprime[i]) continue;\n\t\twhile(n%i==0){\n\t\t\tv.PB(i);\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n>1){\n\t\tv.PB(n);\n\t}\n\treturn v;\n}\n\n// BIT /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int\n>\nclass bit{\npublic:\n\tT *bit_arr;\n\tint size;\n\n\tbit(int n){\n\t\tsize = n;\n\t\tbit_arr = new T[n];\n\t\tfill(bit_arr, bit_arr+n, 0);\n\t}\n\n\t~bit(){\n\t\tdelete bit_arr;\n\t}\n\n\tT sum(int a){\n\t\tT ret = 0;\n\t\twhile(a){\n\t\t\tret+=bit_arr[a];\n\t\t\ta-=a&-a;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tT sum(int a, int b){\n\t\treturn sum(b)-sum(a);\n\t}\n\n\tT get(int a){\n\t\treturn sum(a, a+1);\n\t}\n\n\tvoid add(int a, T x){\n\t\ta++;\n\t\twhile(a<size){\n\t\t\tbit_arr[a]+=x;\n\t\t\ta+=a&-a;\n\t\t}\n\t}\n\n\tvoid set(int a, T x){\n\t\tadd(a, x-get(a));\n\t}\n};\ntypedef bit<ll> bll;\n\n// RMQ /////////////////////////////////////////////////////////////////////////\ntemplate<\n\ttypename T = int,\n\tclass Compare=less<T>\n>\nclass rmq{\npublic:\n\tint size;\n\tCompare comp;\n\tT *dat;\n\tT init;\n\t\n\trmq(int n, T init_=INT_MAX){\n\t\tinit=init_;\n\t\tsize = 1;\n\t\twhile(size<n) size*=2;\n\t\tdat = new T[2*size-1];\n\t\tfill(dat, dat+(2*size-1), init);\n\t}\n\n\t~rmq(){\n\t\tdelete dat;\n\t}\n\n\tvoid set(int k, T a){\n\t\tk+=size-1;\n\t\tdat[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdat[k]=min(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\n\tT get(int a, int b, int k, int l, int r){\n\t\tif(r<=a || b<=l) return init;\n\t\tif(a<=l && r<=b) return dat[k];\n\t\telse{\n\t\t\tT vl = get(a, b, k*2+1, l, (l+r)/2);\n\t\t\tT vr = get(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn min(vl, vr, comp);\n\t\t}\n\t}\n\n\tT get(int a, int b){\n\t\treturn get(a, b, 0, 0, size);\n\t}\n};\n\n// Others //////////////////////////////////////////////////////////////////////\n#define MOD 1000000007\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n\n////////////////////////////////////////////////////////////////////////////////\n\nint h, w;\nint memo[250][250][250];\nint x[250][250];\n\ninline int sm(int a, int b, int c){\n\treturn x[a][c+1]-x[a][b];\n}\n\nint DP(int, int, int);\ninline int dp(int a, int b, int c){\n\tif(~memo[a][b][c]) return memo[a][b][c];\n\telse return memo[a][b][c]=DP(a, b, c);\n}\nint DP(int a, int b, int c){\n\tint ret=0;\n\tif(a==h-1){\n\t\tret=sm(a, min(b, c), w-1);\n\t}else{\n\t\tFOR(d, b, w){\n\t\t\tFOR(e, max(c, d), w){\n\t\t\t\tint s = sm(a, b, d)+sm(a, c, e);\n\t\t\t\tif(c<=d) s-=sm(a, c, d);\n\t\t\t\tLAR(ret, s+dp(a+1, d, e));\n\t\t\t}\n\t\t}\n\t}\n\t// printf(\"(%d, %d, %d)=%d\\n\", a, b, c, ret);\n\treturn ret;\n}\n\nint main(){\n\tIR(h, w);\n\tREP(i, 250) REP(j, 250) REP(k, 250) memo[i][j][k]=-1;\n\tREP(i, h){\n\t\tx[i][0]=0;\n\t\tREP(j, w){\n\t\t\tI(a);\n\t\t\tx[i][j+1]=x[i][j]+a;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp(0, 0, 0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long h, w, max_cost = -1, max_cost2 = -1;\nint k[205][205];\n\nbool is_search_a[205][205], is_search_b[205][205];\n\nvoid cpy() {\n/*  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      cout << is_search_a[i][j] << \" \";\n    }\n    cout << endl;\n  }*/\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      is_search_b[i][j] = is_search_a[i][j];\n    }\n  }\n}\n\nvoid dfs(int x, int y, int cost) {\n  if(x == h-1 && y == w-1) {\n    if(max_cost < cost+k[x][y]) {\n      max_cost = cost+k[x][y];\n      cpy();\n    }\n    return;\n  }\n  if(x+1 < h) {\n    is_search_a[x+1][y] = true;\n    dfs(x+1,y, cost+k[x][y]);\n    is_search_a[x+1][y] = false;\n  }\n  if(y+1 < w) {\n    is_search_a[x][y+1] = true;\n    dfs(x, y+1, cost+k[x][y]);\n    is_search_a[x][y+1] = false;\n  }\n\n  return;\n}\n\nvoid dfs2(int x, int y, int cost) {\n\n  if(x == h-1 && y == w-1) {\n    if(max_cost2 < cost) max_cost2 = cost;\n    return;\n  }\n  if(x < h-1) {\n    dfs2(x+1,y, cost+k[x][y]);\n  }\n  if(y < w-1) {\n    dfs2(x,y+1, cost+k[x][y]);\n  }\n  return;\n}\n\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> h >> w;\n\n  for(int i = 0; i < h; i++) {\n    fill(is_search_a[i], is_search_a[i]+w, false);\n    fill(is_search_b[i], is_search_b[i]+w, false);\n  }\n\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      cin >> k[i][j];\n    }\n  }\n  is_search_a[0][0] = true;\n  dfs(0, 0, 0);\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      if(is_search_b[i][j]) k[i][j] = 0;\n    }\n  }\n  dfs2(0, 0, 0);\n  cout << (max_cost + max_cost2) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n//辺 fromあり\ntemplate<typename T >\nstruct Edge {\n  int from, to;\n  T cost;\n\n  Edge()=default;\n  Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  inline bool operator<(const Edge p)const noexcept{\n    return cost<p.cost;\n  }\n\n  inline bool operator>(const Edge p)const noexcept{\n    return cost>p.cost;\n  }\n\n};\n\n\n//辺 fromがない\ntemplate<typename T >\nstruct edge {\n  int to;\n  T cost;\n  edge()=default;\n  edge(int to, T cost) : to(to), cost(cost) {}\n};\ntemplate<typename T>\nusing edges=vector<edge<T>>;\ntemplate<typename T>\nusing WeightGraph=vector<edges<T>>;\n\nusing Graph=vector<vector<int>>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\ntemplate<typename T>\ninline void Yes(T flag){\n    if(flag) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\ntemplate<typename T>\ninline void YES(T flag){\n    if(flag) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\n//1-indexed vector cin\ntemplate<typename T>\ninline void vin1(vector<T> &v){\n    for(int i=1;i<v.size();i++) cin>>v[i];\n}\n\n//0-indexed vector cin\ntemplate<typename T>\ninline void vin0(vector<T> &v){\n    for(int i=0;i<v.size();i++) cin>>v[i];\n}\n\n//1-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin1(vector<vector<T>> &v){\n    for(int i=1;i<v.size();i++){\n        for(int j=1;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n//0-indexed vector<vector> cin\ntemplate<typename T>\ninline void vin0(vector<vector<T>> &v){\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++) cin>>v[i][j];\n    }\n}\n\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        if(i) cout<<\" \";\n\t\tcout<<v[i];\n    }\n    cout<<\"\\nend\\n\"<<endl;\n}\n//デバッグ(グリッド)\ntemplate<typename T>\ninline void gvout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n\t\t\tif(j) cout<<\" \";\n            cout<<v[i][j];\n        }\n\t\tcout<<endl;\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    assert(!que.empty());\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  assert(!que.empty());\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  assert(!st.empty());\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define SZ(x) ( (int)x.size()  )\n#define pb push_back\n#define eb emplace_back\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nconstexpr int dx[]={1,0},dy[]={0,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nint main(){\n\tbin101();\n\n    int H,W;\n    cin>>H>>W;\n    auto a=vmake(H,W,0);\n    vin0(a);\n    gvout(a);\n\n    auto dp=vmake(H+W-1,H,H,-1);\n    dp[0][0][0]=a[0][0];\n\n    for(int i=0;i<H+W-1;i++){\n\n        for(int s=0;s<H;s++){\n            for(int e=0;e<H;e++){\n                if(dp[i][s][e]==-1) continue;\n                int sh=s,eh=e;\n                int sw=i-sh,ew=i-eh;\n                for(int k=0;k<2;k++){\n                    for(int l=0;l<2;l++){\n                        int snh=sh+dx[k],snw=sw+dy[k];\n                        int enh=eh+dx[l],enw=ew+dy[l];\n                        if(snh>=H || snw>=W || enh>=H || enw>=W) continue;\n                        int x;\n                        if(snh==enh) x=a[snh][snw];\n                        else x=a[snh][snw]+a[enh][enw];\n                        chmax(dp[i+1][snh][enh],dp[i][sh][eh]+x);\n                    }\n                }\n            }\n        }\n    }\n    //vout(dp);\n    cout<<dp[H+W-2][H-1][H-1]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,T1,w;\n    cin >> H >> W;\n    w=2*W;\n    T1=0;\n    int array[w];\n    for(int i=0;i<w;i++){\n        cin >> array[i];\n        T1=T1+array[i];\n    }\n    cout << T1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 205\nint a[maxn][maxn];\nint dp[maxn][maxn][maxn];\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][1] = a[1][1];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tfor (int k = 1; k <= i+j-1 && k<=w;k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t\tdp[i][j + 1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k], dp[i][j][k] + a[i + 1][j] + a[i + j - k + 1][k]);\n\t\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j+1][k+1] ,dp[i][j][k] +a[i][j + 1] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j == k + 1)\n\t\t\t\t{\t\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i+1][j][k+1], dp[i][j][k] + a[i + 1][j] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j + 1 == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j + 1] + a[i + j - k + 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[h][w][w] << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nint H, W, a[212][212];\nLL ans;\n\nint main()\n{\n\tin >> H >> W;\n\trep(i, H) { rep(j, W) { in >> a[i][j]; } }\n\n\trep(i, H)\n\t{\n\t\trep(j, W)\n\t\t{\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\tif (H == 3)\n\t{\n\t\trep(k, W - 2)\n\t\t{\n\t\t\tans -= std::min(a[k][2], std::min(a[k + 1][1], a[k + 2][0]));\n\t\t}\n\t}\n\tout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,a,T1,T2;\n    cin >> H >> W;\n    int array1[W];\n    int array2[W];\n    for(int i=0;i<W;i++){\n        cin >> array1[i];\n        T1=T1+array1[i];\n    }\n    for(int i=0;i<W;i++){\n        cin >> array2[i];\n        T2=T2+array2[i];\n    }\n    a=T1+T2;\n    cout << a-11322322 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=405,INF=1<<30;\nint dp[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int H,W;cin>>H>>W;\n    vector<vector<int>> S(H,vector<int>(W));\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n        }\n    }\n    \n    for(int s=2;s<=H+W;s++){\n        for(int a=1;a<=H;a++){\n            if(1<=s-a&&s-a<=W){\n                for(int b=1;b<=H;b++){\n                    if(1<=s-b&&s-b<=W){\n                        if(a==b){\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]);\n                            }\n                        }else{\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]+S[b-1][s-b-1]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<dp[H+W][H][H]<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {1, 0, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {0, 1, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.9lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 2000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\nint H, W;\nint A[210][210];\nint dp[410][210][210];\n\nbool out(int r, int c){\n  if(r < 0 || r >= H || c < 0 || c >= W) return 1;\n  return 0;\n}\n\nvoid solve(){\n  cin >> H >> W;\n  rep(i, H)rep(j, W) cin >> A[i][j];\n  rep(i, 410)rep(j, 210)rep(k, 210) dp[i][j][k] = -INF;\n  dp[0][0][0] = A[0][0];\n  rep(i, H + W - 2)rep(j, 210)rep(k, 210){\n    int jy = j, jx = i - jy;\n    int ky = k, kx = i - ky;\n    if(out(jy, jx)) continue;\n    if(out(ky, kx)) continue;\n    rep(dj, 2)rep(dk, 2){\n      int njy = jy + dy[dj], njx = jx + dx[dj];\n      int nky = ky + dy[dk], nkx = kx + dx[dk];\n      if(out(njy, njx)) continue;\n      if(out(nky, nkx)) continue;\n      int add = A[njy][njx] + A[nky][nkx];\n      if(njy == nky) add = A[njy][njx];\n      dp[i+1][njy][nky] = max(dp[i+1][njy][nky], dp[i][j][k] + add);\n    }\n  }\n  int ans = 0;\n  rep(i, 210)rep(j, 210) ans = max(ans, dp[H+W-2][i][j]);\n  cout << ans << endl;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tvector<vector<int>>a(H, vector<int>(W, 0));\n\trep(i, H)rep(j, W)cin >> a[i][j];\n\n\tassert(H <= 2);\n\tint ans = 0;\n\trep(i, H)rep(j, W)ans += a[i][j];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<30);\nconst int MAX = 100000;\nconst int MAX_V = 50000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , 2, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, 2, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint h, w, a1[400][400], a2[400][400], dp[400][400][400];\n \nsigned main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> a1[i][j];\n    }\n  }\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      a2[i + j][i - j + w] = a1[i][j];\n    }\n  }\n \n  dp[0][w][w] = a1[0][0];\n \n  for(int i = 1; i <= h + w - 2; i++){\n    for(int j = 1; j <= h + w - 1; j++){\n      for(int k = 1; k <= h + w - 1; k++){\n\tdp[i][j][k] = max({dp[i - 1][j - 1][k - 1], dp[i - 1][j - 1][k + 1], dp[i - 1][j + 1][k - 1], dp[i - 1][j + 1][k + 1]});\n\tif(j == k){\n\t  dp[i][j][k] += a2[i][j];\n\t}\n\telse{\n\t  dp[i][j][k] += a2[i][j] + a2[i][k];\n\t}\n      }\n    }\n  }\n  \n  cout << dp[h + w - 2][h][h] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define int long long\ntypedef long long int64;\n \n \nstruct Primal_Dual\n{\n  const int64 INF = 1LL << 59;\n  typedef pair< int64, int > Pi;\n \n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int64 > potential, min_cost, prevv, preve;\n \n  Primal_Dual(int V) : graph(V) {}\n \n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n \n  int64 min_cost_flow(int s, int t, int f)\n  {\n    int64 V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n \n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n \n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int64 nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return (114514);\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n \nsigned main()\n{\n  int H, W, A[200][200];\n \n  cin >> H >> W;\n  Primal_Dual flow(H * W * 2);\n \n  auto cell = [&](int i, int j, bool in)\n  {\n    if(in) return (H * W + i * W + j);\n    return (i * W + j);\n  };\n \n  const int mx = 1e6;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      cin >> A[i][j];\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, mx - A[i][j]);\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, mx);\n      if(i > 0) flow.add_edge(cell(i - 1, j, true), cell(i, j, false), 2, 0);\n      if(j > 0) flow.add_edge(cell(i, j - 1, true), cell(i, j, false), 2, 0);\n    }\n  }\n  cout << -(flow.min_cost_flow(cell(0, 0, false), cell(H - 1, W - 1, true), 2) - mx * (H + W - 1) * 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 201\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tmemset(A, 0, sizeof(A));\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-1, 1) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tREP(x, j+2, j) {\n\t\t\t\t\tREP(y, k+2, k) {\n\t\t\t\t\t\tint s = i - x, t = i - y;\n\t\t\t\t\t\tif (s<0||s>=H||t<0||t>=H||x>=W||y>=W) continue;\n\t\t\t\t\t\tdp[pos][x][y] = max(dp[pos][x][y], dp[pos^1][j][k] + A[s][x] + (s==t?0:A[t][y]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\nusing namespace std;\nmap<tuple<int, int, int, int>, int> mp;\nint f(vector<vector<int>> &A, int y1, int x1, int y2, int x2){\n\ttuple<int, int, int, int> T = make_tuple(y1, x1, y2, x2);\n\tif (mp.count(T)){\n\t\treturn mp[T];\n\t} else {\n\t\tint tmp = A[y1][x1] + A[y2][x2];\n\t\tif (y1 == y2 && x1 == x2){\n\t\t\ttmp /= 2;\n\t\t}\n\t\tint ans = 0;\n\t\tif (y1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2 - 1, x2));\n\t\t}\n\t\tif (y1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2, x2 - 1));\n\t\t}\n\t\tif (x1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2 - 1, x2));\n\t\t}\n\t\tif (x1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2, x2 - 1));\n\t\t}\n\t\tans += tmp;\n\t\tmp[T] = ans;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> A(H, vector<int>(W));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tcout << f(A, H - 1, W - 1, H - 1, W - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dp[200][200][200];//sx,sy,ex\nint x[]{ 1,1,0,0 }, y[]{ 0,1,0,1 };\nint dx[]{ 1,0 }, dy[]{ 0,1 };\nint a[200][200];\nint main() {\n\tint h, w; scanf(\"%d%d\", &h, &w);\n\trep(i, h)rep(j, w)scanf(\"%d\", &a[i][j]);\n\tdp[0][0][0] = a[0][0];\n\trep(i, h)rep(j, w)rep(k, h) {\n\t\tif (i + j - k < 0 || i + j - k >= w)continue;\n\t\tif ((i || j) && i == k&&j == i + j - k)continue;\n\t\trep(t, 4) {\n\t\t\tint sx = i + dx[x[t]], sy = j + dy[x[t]], ex = k + dx[y[t]], ey = i + j - k + dy[y[t]];\n\t\t\tif (0 <= sx&&sx < h && 0 <= sy&&sy < w && 0 <= ex&&ex < h && 0 <= ey&&ey < w)\n\t\t\t\tdp[sx][sy][ex] = max(dp[sx][sy][ex], dp[i][j][k] + a[sx][sy] + a[ex][ey]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[h - 1][w - 1][h - 1] - a[h - 1][w - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define len(x)  (int((x).size()))\n#define append push_back\n#define pp make_pair\n#define ff(a, b)    for (int a = 0; a < int(b); ++a)\n#define kk(n)    ff(k, n)\n#define xx(n)    ff(x, n)\n#define yy(n)    ff(y, n)\n#define ii(n)    ff(i, n)\n#define fff(a, b, c) for (int a = int(b); a < int(c); ++a)\n#define kkk(a, b) fff(k, a, b)\n#define xxx(a, b) fff(x, a, b)\n#define yyy(a, b) fff(y, a, b)\n#define iii(a, b) fff(i, a, b)\n#define bb begin()\n#define ee end()\n#define uu first\n#define vv second\n#define all(x)  (x).bb, (x).ee\n#define ite(v)   decltype((v).bb)\n#define fe(i, v) for(ite(v) i = (v).bb; i != (v).ee; ++i)\n#define err(...)    { fprintf(stderr, __VA_ARGS__); fflush(stderr); }\n#define zz(array, byte)   memset(array, byte, sizeof(array));\n\nusing LL = long long;\nusing DD = long double;\nusing pii = pair<int, int>;\n\n\n\nconst LL  INFLL  = 0x7f7f7f7f7f7f7f7fLL;\nconst int INFint = 0x7f7f7f7f;  //Works with memset(..).\n \n     \n\n\n\n\nint main() {\n    //ios_base::sync_with_stdio(false);     cin.tie(NULL);\n    //cout << '\\n';\n    cout.precision(16);\n    \n\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int> > grid(h, vector<int>(w, 0));\n    yy (h)\n    xx (w)\n        cin >> grid[y][x];\n\n    map<pii, int> best;\n    best[pp(0, 0)] = grid[0][0];\n    ii (h + w - 2) {\n        map<pii, int> next;\n        fe (it, best) {\n            int x1 = it->uu.uu;\n            int x2 = it->uu.vv;\n            int y1 = i - x1;\n            int y2 = i - x2;\n            xx (2) {\n                int x1n = x1 + x;\n                int y1n = y1 + (1-x);\n                if (! (x1n < w && y1n < h))\n                    continue;\n                yy (2) {\n                    int x2n = x2 + y;\n                    int y2n = y2 + (1-y);\n                    if (! (x2n < w && y2n < h))\n                        continue;\n\n                    int here = grid[y1n][x1n];\n                    if (x1n != x2n)\n                        here += grid[y2n][x2n];\n                    pii key = pp(min(x1n, x2n), max(x1n, x2n));\n                    next[key] = max(next[key], it->vv + here);\n                    //printf(\"put %d %d %d\\n\", x1n, x2n, it->vv + here);\n                }\n            }\n        }\n        //printf(\"\\n\");\n        swap(best, next);\n    }\n    int rr = 0;\n    fe (it, best) {\n        rr = it->vv;\n    }\n\n    cout << rr << '\\n';\n    \n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 16-11-20_chu2_D.cpp\n *\n *  Created on: 2016/11/29\n *      Author: ryoma\n */\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint field[210][210];\nint H,W;\n\nint dp[210][210][410];\n\nint rs[4]={0,0,1,1},re[4] = {0,1,0,1};\n\nint dfs(int sj,int ej,int d){\n\tif(sj>W||ej>W||d>H+W)\n\t\treturn 0;\n\tif(dp[sj][ej][d]>0){\n\t\treturn dp[sj][ej][d]-1;\n\t}\n\tint res=0;\n\tfor(int i=0;i<4;i++){\n\tres = max(res,dfs(sj+rs[i],ej+re[i],d+1));\n\t}\n\tres += field[d-sj][sj] + field[d-ej][ej];\n\tif(sj == ej)\n\t\tres -= field[d-sj][sj];\n\tdp[sj][ej][d] = res+1;\n\treturn res;\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tcout << dfs(0,0,0) << endl;\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\ntypedef long long int64;\n\n\nstruct Primal_Dual\n{\n  const int INF = 1 << 30;\n  typedef pair< int64, int > Pi;\n\n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int64 > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int64 min_cost_flow(int s, int t, int f)\n  {\n    int64 V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int64 nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return (114514);\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nsigned main()\n{\n  int H, W, A[200][200];\n\n  cin >> H >> W;\n  Primal_Dual flow(H * W * 2);\n\n  auto cell = [&](int i, int j, bool in)\n  {\n    if(in) return (H * W + i * W + j);\n    return (i * W + j);\n  };\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      cin >> A[i][j];\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, -A[i][j]);\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, 0);\n      if(i > 0) flow.add_edge(cell(i - 1, j, true), cell(i, j, false), 2, 0);\n      if(j > 0) flow.add_edge(cell(i, j - 1, true), cell(i, j, false), 2, 0);\n    }\n  }\n  cout << -flow.min_cost_flow(cell(0, 0, false), cell(H - 1, W - 1, true), 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=307;\nusing pii=pair<int,int>;\n\nint n, m;\n\nint tab[nax][nax];\n\nint dp[nax*2][nax][nax];\n\nint &daj(pii a, pii b)\n{\n\treturn dp[a.first+a.second][a.first][b.first];\n}\n\nvector <pii> mog(pii v)\n{\n\tvector <pii> ret;\n\tif (v.first<n)\n\t\tret.push_back({v.first+1, v.second});\n\tif (v.second<m)\n\t\tret.push_back({v.first, v.second+1});\n\treturn ret;\n}\n\nint licz(pii a, pii b)\n{\n\tif (a==make_pair(n, m))\n\t\treturn tab[n][m];\n\t\n\tif (daj(a, b)!=-1)\n\t\treturn daj(a, b);\n\t\n\tint ret=0;\n\tfor (pii i : mog(a))\n\t\tfor (pii j : mog(b))\n\t\t\tret=max(ret, licz(i, j));\n\t\n\tret+=tab[a.first][a.second];\n\tif (a!=b)\n\t\tret+=tab[b.first][b.second];\n\treturn daj(a, b)=ret;\n}\n\nint main()\n{\n\tmemset(dp, -1, sizeof(dp));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tscanf(\"%d\", &tab[i][j]);\n\tprintf(\"%d\\n\", licz({1, 1}, {1, 1}));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-H+1);j!=min(i,W-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,W);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][W-2][W-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int H,W; cin >> H >> W ;\n  vvl a(H,vl(W));\n  rep(i,H) rep(j,W) cin >> a[i][j] ;\n  int N = H + W;\n  vector<vvl> dp(N-1,vvl(H,vl(H,-1)));\n  dp[0][0][0] = a[0][0];\n  rep(i,N-2) rep(x1,H) rep(x2,H){\n    if(dp[i][x1][x2]==-1) continue;\n    rep(s,2) rep(t,2){\n      int nx1,ny1,nx2,ny2;\n      nx1 = x1+s;\n      ny1 = i+1-nx1;\n      nx2 = x2+t;\n      ny2 = i+1-nx2;\n      if(!(nx1<H && ny1<W && nx2<H && ny2<W)) continue;\n      if(nx1==nx2 && ny1==ny2) chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][ny2]);\n      else chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][ny1]+a[nx2][ny2]);\n    }\n  }\n  dump(dp);\n  cout << dp[N-2][H-1][H-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <fstream>\n#include <unistd.h>\n#include <string.h>\n#include <string>\n#include <numeric>\n#include <queue>\n#include <deque>\n#include <sstream>\n#include <iomanip>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <functional>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<vvvl> vvvvl;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef long double LD;\ntypedef vector<LD> vld;\ntypedef vector<pair<LD, LD>> vpld;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> vpl;\ntypedef vector<vector<PL>> vvpl;\ntypedef vector<vvpl> vvvpl;\ntypedef pair<ll, PL> TL;\ntypedef vector<TL> vtl;\ntypedef vector<vtl> vvtl;\ntypedef long double ld;\ntypedef vector<ld> vld;\nconst ll LINF = 1e17;\nconst double pi = 3.1415926535897932;\nconst string endstr = \"\\n\";\n#define FOR(i, a, b) for(ll i = (a); i < b; i++)\n#define RFOR(i, a, b) for(ll i = (a); i > b; i--)\n#define rep(i, n) for(ll i = 0; i < n; i++)\n#define rrep(i, n) for(ll i = n-1; i > -1; i--)\n#define FORMAP(it, m) for(auto it = m.begin(); it != m.end(); it++)\n#define ff first\n#define ss second\n#define pb push_back\n#define epb emplace_back\n#define ALL(X) (X).begin(),(X).end()\n\ntemplate <typename T> T gcd(T a, T b) {return (a == 0) ? b : gcd(b%a, a);}\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b;}\n\nbool p_comp_fs(const PL p1, const PL p2){ return p1.first < p2.first;};\nbool p_comp_fg(const PL p1, const PL p2){ return p1.first > p2.first;};\nbool p_comp_ss(const PL p1, const PL p2){ return p1.second < p2.second;};\nbool p_comp_sg(const PL p1, const PL p2){ return p1.second > p2.second;};\ntemplate <typename T>\nvector<T> uniquen(vector<T> vec /* copy */){\n    sort(ALL(vec)); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec;\n}\n\ninline ll popcnt(ll x){return __builtin_popcountll((unsigned long long)x);};\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\n//friend bool operator<(const tpl& lhs, const tpl& rhs){\n//    return std::tie(lhs.l, lhs.r) < std::tie(rhs.l, rhs.r);\n//}\n\nbool bit(ll st, ll b){return ((st>>b)&1) == 1;}\n\nll H, W;\nll dp[210][210][420];\nvvl A;\n\nvl dh = {1, 0};\n\nbool ok(ll h, ll w){\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nvoid dfs(ll eh, ll sh, ll sum, ll now){\n    if(dp[eh][sh][sum] > now) return;\n    rep(i, 2) rep(j, 2){\n        ll nhe = eh+dh[i], nwe = sum+1-nhe;\n        ll nhs = sh+dh[j], nws = sum+1-nhs;\n        if(!ok(nhe, nwe)  || !ok(nhs, nws)) continue;\n        if(nhe == nhs && nwe == nws){\n            if(chmax(dp[nhe][nhs][sum+1], now + A[nhe][nwe])){\n                dfs(nhe, nhs, sum+1,  now + A[nhe][nwe]);\n            }\n        }\n        else{\n            if(chmax(dp[nhe][nhs][sum+1], now + A[nhe][nwe] + A[nhs][nws])){\n                dfs(nhe, nhs, sum+1,  now + A[nhe][nwe] + A[nhs][nws]);\n            }\n        }\n    }\n}\n\n\nint main(){\n#ifdef __DEBUG_LOCAL__\n    ifstream file(\"../../../../../in.txt\"); if(file.is_open()) cin.rdbuf(file.rdbuf());\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n    \n    memset(dp, -1, sizeof(dp));\n    cin >> H >> W;  A = vvl(H, vl(W, 0));\n    rep(i, H) rep(j, W) cin >> A[i][j];\n    dp[0][0][0] = 0;\n    dfs(0, 0, 0, A[0][0]);\n    cout << dp[H-1][H-1][H-1+W-1] << endstr;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n\nconst int H = 200;\nint a[H][H];\n\nint main(void){\n  int h, w;\n  cin >> h >> w;\n  assert (h <= 3 && w <= 3);\n  REP(i, 0, h) {\n    REP(j, 0, w) {\n      cin >> a[i][j];\n    }\n  }\n  ll tot = 0;\n  REP(i, 0, h) {\n    REP(j, 0, w) {\n      tot += a[i][j];\n    }\n  }\n  \n  if (h <= 2 || w <= 2) {\n    cout << tot << endl;\n    return 0;\n  }\n  int mi = 1e9;\n  REP(i, 0, 3) {\n    mi = min(mi, a[2 - i][i]);\n  }\n  cout << tot - mi << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ary[210][210];\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ary[i][j];\n\t\t}\n\t}\n\n\t//部分\n\tint res=0;\n\tif(H<=3&&W<=3){\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tres+=ary[i][j];\n\t\t\t}\n\t\t}\n\t\tif(H==3&&W==3){\n\t\t\tres-=min(ary[1][3],min(ary[2][2],ary[3][1]));\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint mf(const int& a, const int& b, const int& c, const int& d) {\n  return max(a, max(b, max(c, d)));\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int mp[n][m];\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      cin >> mp[i][j];\n  int dp[n][m][n] = {};\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      for (int k = max(0, i + j - m + 1); k < min(i + j + 1, n); ++k) {\n        dp[i][j][k] = mf(i ? dp[i-1][j][k] : 0,\n                         j ? dp[i][j-1][k] : 0,\n                         i && k ? dp[i-1][j][k-1] : 0,\n                         j && k ? dp[i][j-1][k-1] : 0)\n                        + mp[i][j] + (i == k ? 0 : mp[k][i+j-k]);\n      }\n    }\n  }\n  cout << dp[n-1][m-1][n-1] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nll dp[401][201][201];\nint A[201][201];\n\nbool same(int ay, int ax, int by, int bx) {\n    return ay == by&&ax == bx;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int H, W;\n    while(cin >> H >> W) {\n        rep(y, H)rep(x, W)cin >> A[y][x];\n\n        MEM(dp, -1);\n        dp[0][0][0] = A[0][0];\n\n        rep(s, H + W - 2) {\n            rep(ay, H) {\n                if(ay > s)continue;\n                int ax = s - ay;\n                if(ax < 0 || ax >= W)continue;\n                rep(by, H) {\n                    if(by > s)continue;\n\n                    int bx = s - by;\n                    if(bx < 0 || bx >= W)continue;\n\n                    ll z = dp[s][ay][by];\n                    if(z == -1)continue;\n\n                    // 下,下\n                    if(ay < H - 1 && by < H - 1) {\n                        int nay = ay + 1;\n                        int nby = by + 1;\n                        ll w = z + A[nay][ax] + A[nby][bx];\n                        if(same(nay, ax, nby, bx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][nby], w);\n                    }\n\n                    // 下,右\n                    if(ay < H - 1 && bx < W - 1) {\n                        int nay = ay + 1;\n                        int nbx = bx + 1;\n                        ll w = z + A[nay][ax] + A[by][nbx];\n                        if(same(nay, ax, by, nbx)) {\n                            w -= A[nay][ax];\n                        }\n                        smax(dp[s + 1][nay][by], w);\n                    }\n\n                    // 右,下\n                    if(ax < W - 1 && by < H - 1) {\n                        int nax = ax + 1;\n                        int nby = by + 1;\n                        ll w = z + A[ay][nax] + A[nby][bx];\n                        if(same(ay, nax, nby, bx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][nby], w);\n                    }\n\n                    // 右,右\n                    if(ax < W - 1 && bx < W - 1) {\n                        int nax = ax + 1;\n                        int nbx = bx + 1;\n                        ll w = z + A[ay][nax] + A[by][nbx];\n                        if(same(ay, nax, by, nbx)) {\n                            w -= A[ay][nax];\n                        }\n                        smax(dp[s + 1][ay][by], w);\n                    }\n                }\n            }\n        }\n\n        cout << dp[H+W-2][H - 1][H - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dp[205][205][420];\n//int dp[55][55][55][55];\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < H; k++){\n\t\t\tfor(int m = 0; m < H + W; m++){\n\t\t\t\tdp[i][k][m] = -INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < H; k++){\n\t\t\tfor(int m = 0; m < H + W - 1; m++){\n\t\t\t\tint j = m - i;\n\t\t\t\tint l = m - k;\n\t\t\t\tif(i == k && j == l){\n\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i+1][k+1][i+1+j] = max(dp[i+1][k+1][i+1+j] , dp[i][k][m] + a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i+1][k][i+1+j] = max(dp[i+1][k][i+1+j], dp[i][k][m] + a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i][k+1][i+j+1] = max(dp[i][k+1][i+j+1], dp[i][k][m]+ a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i][k][i+j+1] = max(dp[i][k][i+j+1], dp[i][k][m]+ a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i+1][k+1][m+1] = max(dp[i+1][k+1][m+1], dp[i][k][m]+ a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i+1][k][m+1] = max(dp[i+1][k][m+1], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i][k+1][m+1] = max(dp[i][k+1][m+1], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i][k][m+1] = max(dp[i][k][m+1], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[H-1][H-1][H-1+W-1] + a[H-1][W-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int N = 50;\n\nint n, m;\nint arr[N][N];\nint dp[N][N][N][N];\n\nint dx[] = {0, 1};\nint dy[] = {1, 0};\n\ninline bool isValid(int x, int y) {\n    return (0 <= x && x < n && 0 <= y && y < m);\n}\n\ninline int solve(int a1, int b1, int a2, int b2) {\n    if (dp[a1][b1][a2][b2] != -1) {\n        return dp[a1][b1][a2][b2];\n    }\n    if ((a1 == a2) && (b1 == b2)) {\n        if ((a1 + b1 > 0) && (a1 + b1 < n + m - 2)) {\n            return 0;\n        }\n    }\n    if (a1 == n - 1 && b1 == m - 1) {\n        return dp[a1][b1][a2][b2] = arr[a1][b1];\n    }\n    int score = arr[a1][b1];\n    if (a1 != a2 || b1 != b2) {\n        score += arr[a2][b2];\n    }\n    int result = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            int na1 = a1 + dx[i];\n            int nb1 = b1 + dy[i];\n            int na2 = a2 + dx[j];\n            int nb2 = b2 + dy[j];\n            if (isValid(na1, nb1) && isValid(na2, nb2)) {\n                result = max(result, solve(na1, nb1, na2, nb2));\n            }\n        }\n    }\n    return dp[a1][b1][a2][b2] = result + score;\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> arr[i][j];\n        }\n    }\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nint dp[401][401][401],dx[2]={0,1},dy[2]={1,0};\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n][m];\n  for(int i=0; i<n; i++)for(int j=0; j<m; j++) cin >> a[i][j];\n  for(int i=0;i<401;i++)for(int j=0;j<401;j++)for(int k=0;k<401;k++)dp[i][j][k]=-(1<<29);\n  dp[0][0][0]=a[0][0];\n  for(int i=0; i<n+m-2; i++) {\n    for(int j=0; j<n+m; j++) {\n      int x1,y1,x2,y2;\n      if(i<m) x1=0,y1=i;\n      else x1=i-m+1,y1=m-1;\n      x1+=j,y1-=j;\n      if(!check(n,m,x1,y1)) break;\n      for(int k=j; k<n+m; k++) {\n        if(i<m) x2=0,y2=i;\n        else x2=i-m+1,y2=m-1;\n        x2+=k,y2-=k;\n        if(!check(n,m,x2,y2)) break;\n        if(dp[i][j][k]==-(1<<29)) continue;\n        for(int l=0; l<2; l++) {\n          int xx1=x1+dx[l],yy1=y1+dy[l];\n          if(!check(n,m,xx1,yy1)) continue;\n          for(int l2=0; l2<2; l2++) {\n            int xx2=x2+dx[l2],yy2=y2+dy[l2];\n            if(!check(n,m,xx2,yy2)) continue;\n            int c=a[xx1][yy1]+a[xx2][yy2];\n            if(xx1==xx2&&yy1==yy2) c/=2;\n            int x=xx1,y=xx2;\n            if(i+1>=m) x-=i-m+2,y-=i-m+2;\n            dp[i+1][x][y]=max(dp[i+1][x][y],dp[i][j][k]+c);\n          }\n        }\n      }\n    } \n  }\n  cout << dp[n+m-2][0][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define pb push_back\n#define sor(vec) sort(vec.begin(),vec.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define fr first\n#define sc second\n\nconst ll M = 1000000007;\n\nint main(){\n\tint h,w;\n\tint a[202][202];\n\tscanf(\"%d%d\",&h,&w);\n\trep1(i,h)rep1(j,w){\n\t\tscanf(\"%d\",&a[i][j]);\n\t}\n\t\n\tstatic int dp[202][202][202] = {};\n\tdp[1][1][1] = a[1][1];\n\tfor(int i = 2 ; i <= w ; i ++)dp[1][1][i] = dp[1][1][i-1] + a[1][i];\n\tfor(int i = 2 ; i <= h ; i ++){\n\t\tfor(int k = w ; k >= 2 ; k --){\n\t\t\tfor(int j = 1 ; j < k ; j ++){\n\t\t\t\tdp[i][j][k] = max ( dp[i][j][k] , dp[i-1][j][k]+a[i][j]+a[i][k] );\n\t\t\t\tdp[i][j][k] = max ( dp[i][j][k] , dp[i][j-1][k]+a[i][j] );\n\t\t\t\tfor(int K = k+1 ; K <= w ; K ++){\n\t\t\t\t\tdp[i][j][K] = max ( dp[i][j][K] , dp[i][j][K-1]+a[i][K] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1 ; i <= w ; i ++){\n\t\tret = max ( ret , dp[h][i][w] );\n\t}\n\tcout << ret << endl;\n}\n\t\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\n#define int long long\nint dp[201][201][500];\nint grid[201][201];\n#undef int\nint main() {\n#define int long long\n\tint h, w;\n\tcin >> h >> w;\n\tint hoge = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tcin >> grid[i][q];\n\t\t\thoge += grid[i][q];\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < h + w-2; ++i) {\n\t\tfor (int q = 0; q <= i; ++q) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tint first_x = q;\n\t\t\t\tint first_y = i - q;\n\t\t\t\tint second_x = j;\n\t\t\t\tint second_y = i - j;\n\t\t\t\tREP(t, 2) {\n\t\t\t\t\tREP(p, 2) {\n\t\t\t\t\t\tint next_fx = first_x + t;\n\t\t\t\t\t\tint next_fy = first_y + 1 - t;\n\t\t\t\t\t\tint next_sx = second_x + p;\n\t\t\t\t\t\tint next_sy = second_y + 1 - p;\n\t\t\t\t\t\tif (next_fx >= h || next_sx >= h | next_fy >= w | next_sy >= w) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint winning = dp[q][j][i] + grid[next_fx][next_fy];\n\t\t\t\t\t\tif (next_fx != next_sx || next_fy != next_sy) {\n\t\t\t\t\t\t\twinning += grid[next_sx][next_sy];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next_fx][next_sx][next_fx + next_fy] = max(dp[next_fx][next_sx][next_fx + next_fy], winning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(hoge >= dp[i - 1][q - 1][h + w - 2]);\n\tcout << dp[h - 1][h - 1][h + w - 2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\n#define ll long long\nconst ll MOD = 1000000007;\n\nll sc[203][203];\nll dp[400][200][200];\nmap<pair<ll, ll>, ll> bef, aft;\n\nvoid chmax(ll& x, ll y) {\n\tx = max(x, y);\n}\n\nint main() {\n\tfor (ll i = 0;i < 203;i++)for (ll j = 0;j < 203;j++)sc[i][j] = INT64_MIN / 5;\n\tll H, W;\n\tcin >> H >> W;\n\tfor (ll i = 0;i < H;i++) {\n\t\tfor (ll j = 0;j < W;j++) {\n\t\t\tcin >> sc[i][j];\n\t\t}\n\t}\n\n\tdp[0][0][0] = sc[0][0];\n\n\tfor (int t = 0;t < H + W;t++) {\n\t\tfor (int e8 = 0;e8 <= t;e8++) {\n\t\t\tif (e8 >= H)continue;\n\t\t\tif (t - e8 >= W)continue;\n\t\t\tfor (int sq = 0;sq <= t;sq++) {\n\t\t\tif (sq >= H)continue;\n\t\t\tif (t - sq >= W)continue;\n\t\t\t\tif (e8 != sq) {\n\t\t\t\t\tchmax(dp[t + 1][e8][sq], dp[t][e8][sq] + sc[e8][t - e8 + 1] + sc[sq][t - sq + 1]);\n\t\t\t\t\tchmax(dp[t + 1][e8 + 1][sq + 1], dp[t][e8][sq] + sc[e8 + 1][t - e8] + sc[sq + 1][t - sq]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchmax(dp[t + 1][e8][sq], dp[t][e8][sq] + sc[e8][t - e8 + 1]);\n\t\t\t\t\tchmax(dp[t + 1][e8 + 1][sq + 1], dp[t][e8][sq] + sc[e8 + 1][t - e8]);\n\t\t\t\t}\n\n\t\t\t\tif (e8 + 1 != sq) {\n\t\t\t\t\tchmax(dp[t + 1][e8 + 1][sq], dp[t][e8][sq] + sc[e8 + 1][t - e8] + sc[sq][t - sq + 1]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchmax(dp[t + 1][e8 + 1][sq], dp[t][e8][sq] + sc[e8 + 1][t - e8]);\n\t\t\t\t}\n\n\t\t\t\tif (sq + 1 != e8) {\n\t\t\t\t\tchmax(dp[t + 1][e8][sq + 1], dp[t][e8][sq] + sc[e8][t - e8 + 1] + sc[sq + 1][t - sq]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchmax(dp[t + 1][e8][sq + 1], dp[t][e8][sq] + sc[e8][t - e8 + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[H + W - 2][H - 1][H - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 205\nint a[maxn][maxn];\nint dp[maxn][maxn][maxn];\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][1] = a[1][1];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tfor (int k = 1; k<=w && k<=i+j-1;k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t\tdp[i][j + 1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k], dp[i][j][k] + a[i + 1][j] + a[i + j - k + 1][k]);\n\t\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j+1][k+1] ,dp[i][j][k] +a[i][j + 1] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j == k + 1)\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\telse\n\t\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i+1][j][k+1], dp[i][j][k] + a[i + 1][j] + a[i + j - k][k + 1]);\n\t\t\t\tif (j + 1 == k)\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\telse\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j + 1] + a[i + j - k + 1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[h][w][w] << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconst int N = 205;\n\nint n, m;\nint arr[N][N];\nint dp[N][N][N];\n\nint dx[] = {0, 1};\nint dy[] = {1, 0};\n\ninline bool isValid(int x, int y) {\n    return (0 <= x && x < n && 0 <= y && y < m);\n}\n\ninline int solve(int a1, int b1, int a2) {\n    int b2 = (a1 + b1) - (a2);\n    if (dp[a1][b1][a2] != -1) {\n        return dp[a1][b1][a2];\n    }\n    if ((a1 == a2) && (b1 == b2)) {\n        if ((a1 + b1 > 0) && (a1 + b1 < n + m - 2)) {\n            return 0;\n        }\n    }\n    if (a1 == n - 1 && b1 == m - 1) {\n        return dp[a1][b1][a2] = arr[a1][b1];\n    }\n    int score = arr[a1][b1];\n    if (a1 != a2 || b1 != b2) {\n        score += arr[a2][b2];\n    }\n    int result = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            int na1 = a1 + dx[i];\n            int nb1 = b1 + dy[i];\n            int na2 = a2 + dx[j];\n            int nb2 = b2 + dy[j];\n            if (isValid(na1, nb1) && isValid(na2, nb2)) {\n                result = max(result, solve(na1, nb1, na2));\n            }\n        }\n    }\n    return dp[a1][b1][a2] = result + score;\n}\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> arr[i][j];\n        }\n    }\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nint dp[401][401][401],dx[2]={0,1},dy[2]={1,0};\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n][m];\n  for(int i=0; i<n; i++)for(int j=0; j<m; j++) cin >> a[i][j];\n  for(int i=0;i<401;i++)for(int j=0;j<401;j++)for(int k=0;k<401;k++)dp[i][j][k]=-(1<<29);\n  dp[0][0][0]=a[0][0];\n  for(int i=0; i<n+m-2; i++) {\n    for(int j=0; j<n+m; j++) {\n      int x1,y1,x2,y2;\n      if(i<m) x1=0,y1=i;\n      else x1=i-m+1,y1=m-1;\n      x1+=j,y1-=j;\n      if(!check(n,m,x1,y1)) break;\n      for(int k=j; k<n+m; k++) {\n        if(i<m) x2=0,y2=i;\n        else x2=i-m+1,y2=m-1;\n        x2+=k,y2-=k;\n        if(!check(n,m,x2,y2)) break;\n        if(dp[i][j][k]==-(1<<29)) continue;\n        for(int l=0; l<2; l++) {\n          int xx1=x1+dx[l],yy1=y1+dy[l];\n          if(!check(n,m,xx1,yy1)) continue;\n          for(int l2=0; l2<2; l2++) {\n            int xx2=x2+dx[l2],yy2=y2+dy[l2];\n            if(!check(n,m,xx2,yy2)) continue;\n            int c=a[xx1][yy1]+a[xx2][yy2];\n            if(xx1==xx2&&yy1==yy2) c/=2;\n            int x=xx1,y=xx2;\n            if(i+1>=m) x-=i-m+2,y-=i-m+2;\n            dp[i+1][x][y]=max(dp[i+1][x][y],dp[i][j][k]+c);\n          }\n        }\n      }\n    } \n  }\n  cout << dp[n+m-2][0][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,j,d[105][105];\nll a[105][105],f[105][105],ans;\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tif(j-1>=1 && f[i][j-1]>f[i-1][j])\n\t\t\t{\n\t\t\t\tf[i][j]=f[i][j-1];\n\t\t\t\td[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\td[i][j]=1;\n\t\t\t}\n\t\t\tf[i][j]+=a[i][j];\n\t\t}\n\t}\n\tans=f[n][m];\n\ti=n,j=m;\n\twhile(1)\n\t{\n\t\ta[i][j]=0;\n\t\tif(i==1 && j==1)break;\n\t\tif(d[i][j])i--;\n\t\telse j--;\n\t}\n\tmemset(f,0,sizeof(f));\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];\n\tcout<<f[n][m]+ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 210\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tmemset(A, 0, sizeof(A));\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-1, 1) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j  !=k)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j+1!=k)?A[i-(k  )][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j!=k+1)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j  !=k)?A[i-(k  )][k  ]:0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ary[210][210];\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ary[i][j];\n\t\t}\n\t}\n\n\t//部分\n\tint res=0;\n\tif(H<=3&&W<=3){\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tres+=ary[i][j];\n\t\t\t}\n\t\t}\n\t\tif(H==3&&W==3){\n\t\t\tres-=min(ary[1][3],min(ary[2][2],ary[3][1]));\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=405,INF=1<<30;\nint dp[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int H,W;cin>>H>>W;\n    vector<vector<ll>> S(H,vector<ll>(W));\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n        }\n    }\n    \n    for(int s=2;s<=H+W;s++){\n        for(int a=1;a<=H;a++){\n            if(1<=s-a&&s-a<=W){\n                for(int b=1;b<=H;b++){\n                    if(1<=s-b&&s-b<=W){\n                        if(a==b){\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]);\n                            }\n                        }else{\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]+S[b-1][s-b-1]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<dp[H+W][H][H]<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#include <climits>\n\n// 最小費用流 O( F |E| log |V| )\nclass MinimumCostFlow\n{\nprivate:\n\tstruct Edge\n\t{\n\t\tint to, cap, cost, rev;\n\t\tEdge( int t, int c, int d, int r ) : to( t ), cap( c ), cost( d ), rev( r ) {}\n\t};\n\n\tconst int V;\n\tvector< vector<Edge> > G;\n\npublic:\n\tMinimumCostFlow( int v ) : V( v ), G( V ) {};\n\n\tvoid connect( int from, int to, int cap, int cost )\n\t{\n\t\tG[ from ].push_back( Edge( to, cap, cost, G[ to ].size() ) );\n\t\tG[ to ].push_back( Edge( from, 0, -cost, G[ from ].size() - 1 ) );\n\t\treturn;\n\t}\n\n\tint solve( int s, int t, int f )\n\t{\n\t\tint res = 0;\n\t\tvector<int> h( V, 0 ), prevv( V ), preve( V );\n\n\t\twhile ( 0 < f )\n\t\t{\n\t\t\tvector<int> distance( V, INT_MAX );\n\t\t\tdistance[s] = 0;\n\n\t\t\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\t\t\tque.push( make_pair( 0, s ) );\n\t\t\t\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tint d = que.top().first;\n\t\t\t\tint v = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( distance[v] < d )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); ++i )\n\t\t\t\t{\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif ( 0 < e.cap && distance[v] + e.cost + h[v] - h[ e.to ] < distance[ e.to ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[ e.to ] = distance[v] + e.cost + h[v] - h[ e.to ];\n\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\tque.push( make_pair( distance[ e.to ], e.to ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( distance[t] == INT_MAX )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < V; ++i )\n\t\t\t{\n\t\t\t\th[i] += distance[i];\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tint solve2( const int s, const int t, int f )\n\t{\n\t\tconst int INF = INT_MAX / 2;\n\t\tint res = 0;\n\n\t\twhile ( f > 0 )\n\t\t{\n\t\t\tvector<int> dist( V, INF );\n\t\t\tdist[s] = 0;\n\t\t\tvector<int> prevv( V ), preve( V );\n\n\t\t\tbool update = true;\n\t\t\twhile ( update )\n\t\t\t{\n\t\t\t\tupdate = false;\n\n\t\t\t\tfor ( int v = 0; v < V; v++ )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[v] == INF )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\t\tif ( e.cap > 0 && dist[ e.to ] > dist[v] + e.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[ e.to ] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( dist[t] == INF )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n// MinimumCostFlow( |V| )\n// connect( from, to, cap, cost )\n// solve( s, t, f ) :  Primal-Dual O( F |E| log |V| )\n// solve2( s, t, f ) : Bellman-Ford O( F |E| |V| )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tint H, W;\n\tcin >> H >> W;\n\n\tVVI A( H, VI( W ) );\n\tcin >> A;\n\n\t// [ 0, H * W ) := cell-in\n\t// [ H * W, 2 * H * W ) := cell-out\n\tconst int SRC = 2 * H * W;\n\tconst int SINK = SRC + 1;\n\n\tconst auto in = [&]( const int i, const int j ){ return i * W + j; };\n\tconst auto out = [&]( const int i, const int j ){ return H * W + i * W + j; };\n\n\tMinimumCostFlow mcf( SINK + 1 );\n\tREP( i, H )\n\t{\n\t\tREP( j, W )\n\t\t{\n\t\t\tmcf.connect( in( i, j ), out( i, j ), 1, -A[i][j] );\n\t\t}\n\t}\n\tmcf.connect( in( 0, 0 ), out( 0, 0 ), 1, 0 );\n\tmcf.connect( in( H - 1, W - 1 ), out( H - 1, W - 1 ), 1, 0 );\n\tREP( i, H )\n\t{\n\t\tREP( j, W )\n\t\t{\n\t\t\tif ( i + 1 < H )\n\t\t\t{\n\t\t\t\tmcf.connect( out( i, j ), in( i + 1, j ), 1, 0 );\n\t\t\t}\n\t\t\tif ( j + 1 < W )\n\t\t\t{\n\t\t\t\tmcf.connect( out( i, j ), in( i, j + 1 ), 1, 0 );\n\t\t\t}\n\t\t}\n\t}\n\tmcf.connect( SRC, in( 0, 0 ), 2, 0 );\n\tmcf.connect( out( H - 1, W - 1 ), SINK, 2, 0 );\n\n\tcout << -mcf.solve2( SRC, SINK, 2 ) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nint A[202][202];\nll ma[402][202][202];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W;\n\tFOR(y,H) FOR(x,W) cin>>A[y][x];\n\tma[0][0][0]=A[0][0];\n\t\n\tFOR(i,H+W-2) {\n\t\tint y1,y2,x1,x2;\n\t\tFOR(y1,H) FOR(y2,H) {\n\t\t\tx1=i-y1;\n\t\t\tx2=i-y2;\n\t\t\tif(x1<0 || x1>=W || x2<0 || x2>=W) continue;\n\t\t\tll v=ma[i][y1][y2];\n\t\t\tif(x1<W-1 && x2<W-1) { //RR\n\t\t\t\tif(y1==y2) ma[i+1][y1][y2] = max(ma[i+1][y1][y2],v+A[y1][x1+1]);\n\t\t\t\telse ma[i+1][y1][y2] = max(ma[i+1][y1][y2],v+A[y1][x1+1]+A[y2][x2+1]);\n\t\t\t}\n\t\t\tif(x1<W-1 && y2<H-1) { // RD\n\t\t\t\tif(x1+1==x2) ma[i+1][y1][y2+1] = max(ma[i+1][y1][y2+1],v+A[y1][x1+1]);\n\t\t\t\telse ma[i+1][y1][y2+1] = max(ma[i+1][y1][y2+1],v+A[y1][x1+1]+A[y2+1][x2]);\n\t\t\t}\n\t\t\tif(y1<H-1 && x2<W-1) { // DR\n\t\t\t\tif(y1+1==y2) ma[i+1][y1+1][y2] = max(ma[i+1][y1+1][y2],v+A[y1+1][x1]);\n\t\t\t\telse ma[i+1][y1+1][y2] = max(ma[i+1][y1+1][y2],v+A[y1+1][x1]+A[y2][x2+1]);\n\t\t\t}\n\t\t\tif(y1<H-1 && y2<H-1) { //DD\n\t\t\t\tif(y1==y2) ma[i+1][y1+1][y2+1] = max(ma[i+1][y1+1][y2+1],v+A[y1+1][x1]);\n\t\t\t\telse ma[i+1][y1+1][y2+1] = max(ma[i+1][y1+1][y2+1],v+A[y1+1][x1]+A[y2+1][x2]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout<<ma[H+W-2][H-1][H-1]<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 50000\ntypedef pair<ll,int> P;\nll INF=100000000000LL;\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V];\nll dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,int f){\n  ll res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=(ll)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint H,W;\nint t[200][200];\n\nint main(){\n  cin>>H>>W;\n  int si=H*W*2;\n  int ti=si+1;\n  V=ti+1;\n\n  int N=H*W;\n  ll mx=1e6;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      add_edge(i*W+j,i*W+j+N,1,mx);\n      add_edge(i*W+j,i*W+j+N,1,mx-t[i][j]);\n      //      add_edge(i*W+j,i*W+j+N,1,mx);\n      if(i+1<H){\n        int id=(i+1)*W+j;\n        add_edge(i*W+j+N,id,2,0);\n      }\n      if(j+1<W){\n        int id=i*W+(j+1);\n        add_edge(i*W+j+N,id,2,0);\n      }\n      \n    }\n  }\n  add_edge(si, 0, 2, 0);\n  add_edge( (H-1)*W+(W-1)+N , ti, 2,0);\n\n  ll ans= min_cost_flow(si,ti,2);\n  \n  ans-=mx*(H+W-1)*2;\n  cout<<-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\ntypedef long long int64;\n\n\nstruct Primal_Dual\n{\n  const int64 INF = 1LL << 59;\n  typedef pair< int64, int > Pi;\n\n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int64 > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int64 min_cost_flow(int s, int t, int f)\n  {\n    int64 V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int64 nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return (114514);\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nsigned main()\n{\n  int H, W, A[200][200];\n\n  cin >> H >> W;\n  Primal_Dual flow(H * W * 2);\n\n  auto cell = [&](int i, int j, bool in)\n  {\n    if(in) return (H * W + i * W + j);\n    return (i * W + j);\n  };\n\n  const int mx = 1e6;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      cin >> A[i][j];\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, mx - A[i][j]);\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, mx);\n      if(i > 0) flow.add_edge(cell(i - 1, j, true), cell(i, j, false), 2, 0);\n      if(j > 0) flow.add_edge(cell(i, j - 1, true), cell(i, j, false), 2, 0);\n    }\n  }\n  cout << -flow.min_cost_flow(cell(0, 0, false), cell(H - 1, W - 1, true), 2) - mx * (H + W - 1) * 2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dp[205][205][205][205];\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tdp[i][j][k][l] = - INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tdp[0][0][0][0] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[H-1][W-1][H-1][W-1] + a[H-1][W-1] << endl;\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nint main() {\n\tint h = ri();\n\tint w = ri();\n\tint a[h][w];\n\tfor (auto &i : a) for (auto &j : i) j = ri();\n\tint dp[w][w];\n\tfor (auto &i : dp) for (auto &j : i) j = -1000000000;\n\tdp[0][1] = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint sum[w + 1];\n\t\tsum[0] = 0;\n\t\tfor (int j = 0; j < w; j++) sum[j + 1] = sum[j] + a[i][j];\n\t\tstd::vector<int> insert[w][w];\n\t\tstd::vector<int> erase[w][w];\n\t\tfor (int j = 0; j < w; j++) for (int k = j; k < w; k++) {\n\t\t\tinsert[j][k].push_back(dp[j][k] - sum[j]);\n\t\t\terase[k][k].push_back(dp[j][k] - sum[j]);\n\t\t}\n\t\tint max[w][w];\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tstd::multiset<int> all{-1000000000};\n\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\tfor (auto l : insert[k][j]) all.insert(l);\n\t\t\t\tfor (auto l : erase[k][j]) all.erase(all.find(l));\n\t\t\t\tmax[k][j] = *std::prev(all.end()) + sum[k + 1] + a[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < w; j++) for (int k = 0; k + 1 < w; k++)\n\t\t\tmax[j][k + 1] = std::max(max[j][k + 1], max[j][k] + a[i][k + 1]);\n\t\tmemcpy(dp, max, sizeof(max));\n\t}\n\tint res = 0;\n\tfor (auto &i : dp) for (auto &j : i) res = std::max(res, j);\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst ll INF=1e13;\nll a[222][222];\nll dp[422][222][222];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m;\n  cin>>n>>m;\n  rep(i,n)rep(j,m) cin>>a[i][j];\n  fill(dp[0][0],dp[0][0]+222*222*222,-INF);\n  dp[0][0][0]=0;\n  rep(i,n+m)rep(j,m)rep(k,j+1){\n    if(i-j>=0){\n      dp[i][j][k]+=a[i-j][j];\n      if(j!=k) dp[i][j][k]+=a[i-k][k];\n    }\n    rep(a,2)rep(b,2) MX(dp[i+1][j+a][k+b],dp[i][j][k]);\n  }\n  cout<<dp[n+m-2][m-1][m-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tvector<vector<int>>field(H, vector<int>(W));\n\tfor (auto &i : field)for (auto &j : i)cin >> j;\n\tvector<vector<vector<int>>>dp(W, vector<vector<int>>(W, vector<int>(H + W - 2)));\n\tdp[1][0][1] = field[0][0] + field[0][1] + field[1][0];\n\tfor (int i = 1; i < H + W - 3; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\tint ax = j, bx = k, ay = i - ax, by = i - bx;\n\t\t\t\tif (ax < 0 || bx < 0 || by < 0 || ay < 0)continue;\n\t\t\t\tif (ax >= W || ay >= H || bx >= W || by >= H)continue;\n\t\t\t\tif (ay + by != 1) {\n\t\t\t\t\tdp[ax][bx + 1][i + 1] = max(dp[ax][bx + 1][i + 1], dp[j][k][i] + field[ay + 1][ax] + field[by][bx + 1]);\n\t\t\t\t}\n\t\t\t\tif (ax + 1 < W) {\n\t\t\t\t\tdp[ax + 1][bx + 1][i + 1] = max(dp[ax + 1][bx + 1][i + 1], dp[j][k][i] + field[ay][ax + 1] + field[by][bx + 1]);\n\t\t\t\t}\n\t\t\t\tif (by + 1 < H) {\n\t\t\t\t\tdp[ax][bx][i + 1] = max(dp[ax][bx][i + 1], dp[j][k][i] + field[ay + 1][ax] + field[by + 1][bx]);\n\t\t\t\t}\n\t\t\t\tif (ax + 1 < W&&by + 1 < H) {\n\t\t\t\t\tdp[ax + 1][bx][i + 1] = max(dp[ax + 1][bx][i + 1], dp[j][k][i] + field[ay][ax + 1] + field[by + 1][bx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[W - 1][W - 2].back() + field.back().back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n,m;\nint i,j,k;\nint Map[205][205];\nint F[410][205][205];\nint Max(int a,int b,int c,int d)\n{\n    if(a>=b&&a>=c&&a>=d)\n        return a;\n    if(b>=a&&b>=c&&b>=d)\n        return b;\n    if(c>=a&&c>=b&&c>=d)\n        return c;\n    if(d>=a&&d>=b&&d>=c)\n        return d;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++)\n        for(j=1;j<=m;j++)\n            scanf(\"%d\",&Map[i][j]);\n    int res = Map[1][1] + Map[n][m];\n    Map[1][1] = Map[n][m] = 0;\n    for(k=1;k<=n+m-2;k++)\n        for(i=1;i<=n;i++)\n            for(j=1;j<=n;j++)\n                if(i==n&&j==n&&k==n+m-2)\n                    F[k][i][j]=Max(F[k-1][i-1][j],F[k-1][i][j-1],F[k-1][i][j],F[k-1][i-1][j-1])+Map[i][k+2-i]+Map[j][k+2-j];\n                else  if(i!=j&&k+2-i>=1&&k+2-j>=1)\n                    F[k][i][j]=Max(F[k-1][i-1][j],F[k-1][i][j-1],F[k-1][i][j],F[k-1][i-1][j-1])+Map[i][k+2-i]+Map[j][k+2-j];\n    printf(\"%d\\n\",F[n+m-2][n][n] + res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\n#define int long long\nint dp[201][201][500];\nint grid[201][201];\n#undef int\nint main() {\n#define int long long\n\tint h, w;\n\tcin >> h >> w;\n\tint hoge = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tcin >> grid[i][q];\n\t\t\thoge += grid[i][q];\n\t\t}\n\t}\n\tdp[0][0][0] = grid[0][0];\n\tfor (int i = 0; i < h + w-2; ++i) {\n\t\tfor (int q = 0; q <= i; ++q) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tint first_x = q;\n\t\t\t\tint first_y = i - q;\n\t\t\t\tint second_x = j;\n\t\t\t\tint second_y = i - j;\n\t\t\t\tREP(t, 2) {\n\t\t\t\t\tREP(p, 2) {\n\t\t\t\t\t\tint next_fx = first_x + t;\n\t\t\t\t\t\tint next_fy = first_y + 1 - t;\n\t\t\t\t\t\tint next_sx = second_x + p;\n\t\t\t\t\t\tint next_sy = second_y + 1 - p;\n\t\t\t\t\t\tif (next_fx >= h || next_sx >= h | next_fy >= w | next_sy >= w) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint winning = dp[q][j][i] + grid[next_fx][next_fy];\n\t\t\t\t\t\tif (next_fx != next_sx || next_fy != next_sy) {\n\t\t\t\t\t\t\twinning += grid[next_sx][next_sy];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next_fx][next_sx][i+1] = max(dp[next_fx][next_sx][i+1], winning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h - 1][h - 1][h + w - 2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\n//int dp[55][55][55][55];\nmap<pair<pair<int, int>, pair<int, int> >, int> cur;\nmap<pair<pair<int, int>, pair<int, int> >, int> nnext;\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tcur[make_pair(make_pair(0,0), make_pair(0,0))] = 0;\n\n\n\twhile(true){\n\t\tfor(auto c: cur){\n\t\t\tint i = c.first.first.first;\n\t\t\tint j = c.first.first.second;\n\t\t\tint k = c.first.second.first;\n\t\t\tint l = c.first.second.second;\n\t\t\tint ori = c.second;\n\t\t\tif(i != H - 1){\n\t\t\t\tif(k != H - 1){\n\t\t\t\t\tif(i + 1 != k + 1 || j != l){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == H - 1 && k + 1 == W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(l != W - 1){\n\t\t\t\t\tif(i + 1 != k || j != l+1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == H-1 && j == W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j != W - 1){\n\t\t\t\tif(k != H - 1){\n\t\t\t\t\tif(i != k + 1 || j + 1 != l){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i == H-1 && j + 1 == W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(l != W - 1){\n\t\t\t\t\tif(i != k + 1 || j != l + 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i == H-1 && j == W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nnext.size() == 1){\n\t\t\tbreak;\n\t\t}\n\t\tswap(cur, nnext);\n\t\tnnext.clear();\n\t}\n\tfor(auto n: nnext){\n\t\tcout << n.second + a[H-1][W-1] - a[0][0] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint H, W;\nint A[400][400];\nint dp[401][400][400];\nint D[2] = {0, 1};\n\nint main() {\n  cin >> H >> W;\n  long long sum = 0;\n  for (int y=0; y<H; y++) {\n    for (int x=0; x<W; x++) {\n      cin >> A[x][y];\n      sum += A[x][y];\n    }\n  }\n  if (W == 1 || H == 1) {\n    cout << sum << \"\\n\";\n    return 0;\n  }\n\n  dp[1][0][1] = A[0][0] + A[0][1] + A[1][0];\n  for (int i=1; i<W+H-3; i++) {\n    int r = 1+i;\n    int nr = 2+i;\n    for (int a=0; a<r; a++) {\n      for (int b=a+1; b<r; b++) {\n        for (int ka=0; ka<2; ka++) {\n          for (int kb=0; kb<2; kb++) {\n            int na = a+D[ka], nb = b+D[kb];\n            if (na < 0 || na >= nr || nb < 0 || nb >= nr) continue;\n            if (na >= nb) continue;\n            if (r-na<0 || r-nb<0) continue;\n            dp[i+1][na][nb] = max(dp[i+1][na][nb], dp[i][a][b] + A[na][r-na] + A[nb][r-nb]);\n          }\n        }\n      }\n    }\n  }\n  cout << 0LL + A[W-1][H-1] + dp[W+H-3][W-2][W-1] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint mf(const int& a, const int& b, const int& c, const int& d) {\n  return max(a, max(b, max(c, d)));\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int mp[n][m];\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      cin >> mp[i][j];\n  int dp[n][m][n] = {};\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      for (int k = 0; k < min(i + j + 1, n); ++k) {\n        dp[i][j][k] = mf(i ? dp[i-1][j][k] : 0,\n                         j ? dp[i][j-1][k] : 0,\n                         i && k ? dp[i-1][j][k-1] : 0,\n                         j && k ? dp[i][j-1][k-1] : 0)\n                        + mp[i][j] + (i == k ? 0 : mp[k][i+j-k]);\n      }\n    }\n  }\n  cout << dp[n-1][m-1][n-1] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ary[210][210];\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ary[i][j];\n\t\t}\n\t}\n\n\t//部分\n\tint res=0;\n\tif(H<=3&&W<=3){\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tres+=ary[i][j];\n\t\t\t}\n\t\t}\n\t\tif(H==3&&W==3){\n\t\t\tres-=min(ary[1][3],min(ary[2][2],ary[3][1]));\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 210\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tmemset(A, 0, sizeof(A));\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-2, 0) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-j  ][j+1] + ((j  !=k)?A[i-k  ][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-j  ][j+1] + ((j+1!=k)?A[i-k+1][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-j+1][j  ] + ((j!=k+1)?A[i-k  ][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-j+1][j  ] + ((j  !=k)?A[i-k+1][k  ]:0));\n\t\t\t\t/*\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j  !=k)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j+1!=k)?A[i-(k  )][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j!=k+1)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j  !=k)?A[i-(k  )][k  ]:0));\n*/\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nlong dp[200][200][200];\n\nint main(){\n    int H, W;\n    long a[200][200];\n    cin >> H >> W;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            cin >> a[i][j];\n        }\n    }\n    dp[0][0][0] = a[0][0];\n    for(int i = 1; i <= H+W-2; i++){\n        for(int j = 0; j < W; j++){\n            if(i-j < 0 || i-j >= H) continue;\n            for(int k = 0; k < W; k++){\n                if(i-k < 0 || i-k >= H) continue;\n                if(j > 0 && k > 0) dp[i][j][k] = dp[i-1][j-1][k-1];\n                if(i-j-1 >= 0 && k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]);\n                if(i-k-1 >= 0 && j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]);\n                if(i-j-1 >= 0 && i-k-1 >= 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n                               \n                if(j == k) dp[i][j][k] += a[i-j][j];\n                else dp[i][j][k] += (a[i-j][j]+a[i-k][k]);\n                //cout << i <<  ' ' << j <<  ' ' << k << ' ' << dp[i][j][k] << endl;\n            }\n        }\n    }\n    cout << dp[H+W-2][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\nusing namespace std;\nmap<tuple<int, int, int, int>, int> mp;\nint f(vector<vector<int>> &A, int y1, int x1, int y2, int x2){\n\ttuple<int, int, int, int> T = make_tuple(y1, x1, y2, x2);\n\tif (mp.count(T)){\n\t\treturn mp[T];\n\t} else {\n\t\tint tmp = A[y1][x1] + A[y2][x2];\n\t\tif (y1 == y2 && x1 == x2){\n\t\t\ttmp /= 2;\n\t\t}\n\t\tint ans = tmp;\n\t\tif (y1 > 0 && y2 > 0){\n\t\t\tans = max(ans, tmp + f(A, y1 - 1, x1, y2 - 1, x2));\n\t\t}\n\t\tif (y1 > 0 && x2 > 0){\n\t\t\tans = max(ans, tmp + f(A, y1 - 1, x1, y2, x2 - 1));\n\t\t}\n\t\tif (x1 > 0 && y2 > 0){\n\t\t\tans = max(ans, tmp + f(A, y1, x1 - 1, y2 - 1, x2));\n\t\t}\n\t\tif (x1 > 0 && x2 > 0){\n\t\t\tans = max(ans, tmp + f(A, y1, x1 - 1, y2, x2 - 1));\n\t\t}\n\t\tmp[T] = ans;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> A(H, vector<int>(W));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tcout << f(A, H - 1, W - 1, H - 1, W - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\n/*\nthx\nhttp://kmjp.hatenablog.jp/entry/2016/11/25/0930\n2点を同時に動かす\n動き方は{RR,RD,DR,DD}の4通り\n同じ地点に到達するのはスタート地点と\n移動後に同じ場所になるかだけ、\n以前の位置には到達できない(RかDの移動だけなので)\n*マンハッタン距離として増加方向だけ許されている\n*/\nvoid solve(){\n\tint H,W;\n\tcin>>H>>W;\n\tvector<vector<int> > A(H,vector<int>(W));\n\tfor(int h=0;h<H;++h){\n\t\tfor(int w=0;w<W;++w){\n\t\t\tcin>>A[h][w];\n\t\t}\n\t}\n\n\tvector<vector<vector<LL> > > dp(H+W,\n\t\tvector<vector<LL> >(H,\n\t\t\tvector<LL>(W,0)\n\t\t\t)\n\t\t\t);\n\tdp[0][0][0] = A[0][0];\n\tfor(int i=0;i<H+W-2;++i){//\n\t\tint x1,x2,y1,y2;\n\t\t//位置を順番に総当り\n\t\tfor(y1=0;y1<H;++y1){\n\t\tfor(y2=0;y2<H;++y2){\n\t\t\tx1 = i-y1;\n\t\t\tx2 = i-y2;\n\t\t\t//範囲外,y1は範囲内ループさせてる\n\t\t\tif(x1<0 || x1>=W || x2<0 || x2>=W)continue;\n\t\t\tLL v = dp[i][y1][y2];\n\t\t\t//RR\n\t\t\tif(x1+1<W && x2+1<W ){\n\t\t\t\tif(y1==y2){//同じ位置なので増えるの移動先はひとつ\n\t\t\t\t\tdp[i+1][y1][y2] = max(dp[i+1][y1][y2],v+A[y1][x1+1]);\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][y1][y2] = max(dp[i+1][y1][y2],v+A[y1][x1+1]+A[y2][x2+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//RD\n\t\t\tif(x1+1<W && y2+1<H){\n\t\t\t\tif(x1+1==x2){\n\t\t\t\t\tdp[i+1][y1][y2+1]=max(dp[i+1][y1][y2+1],v+A[y1][x1+1]);\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][y1][y2+1]=max(dp[i+1][y1][y2+1],v+A[y1][x1+1]+A[y2+1][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//DR\n\t\t\tif(y1+1<H && x2+1<W){\n\t\t\t\tif(y1+1==y2){\n\t\t\t\t\tdp[i+1][y1+1][y2]=max(dp[i+1][y1+1][y2],v+A[y1+1][x1]);\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][y1+1][y2]=max(dp[i+1][y1+1][y2],v+A[y1+1][x1]+A[y2][x2+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//DD\n\t\t\tif(y1+1<H && y2+1<H){\n\t\t\t\tif(y1==y2){//y1+1==y2+1\n\t\t\t\t\tdp[i+1][y1+1][y2+1]=max(dp[i+1][y1+1][y2+1],v+A[y1+1][x1]);\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][y1+1][y2+1]=max(dp[i+1][y1+1][y2+1],v+A[y1+1][x1]+A[y2+1][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}}\n\t}\n\tLL ans = dp[H+W-1-1][H-1][H-1];\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 200\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE];\nint cache[SIZE][SIZE][SIZE];\n\nLL calc(int x1, int y1, int x2, int y2) {\n\tif (cache[x1][y1][x2] > -1) return cache[x1][y1][x2];\n\tif (x1 == H || y1 == W || x2 == H || y2 == W) {\n\t\treturn 0;\n\t}\n\tif (x1 == H-1 && y1 == W-1 && x2 == H-1 && y2 == W-1) {\n\t\treturn A[H-1][W-1];\n\t}\n\tLL res = 0;\n\tif (x1 == x2) {\n\t\tres += A[x1][y1];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), calc (x1, y1+1, x2, y2+1));\n\t} else {\n\t\tres += A[x1][y1] + A[x2][y2];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), max(\n\t\t\t\tcalc(x1, y1+1, x2+1, y2),\n\t\t\t\tcalc(x1, y1+1, x2, y2+1)));\n\t}\n\tcache[x1][y1][x2] = res;\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tmemset(cache, -1, sizeof(cache));\n\tcout << calc(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\n\nstruct MinCostFlowNegative{\n\ttypedef pair<int,int> pii;\n\tstruct edge {int to,cap,cost,rev;};\n\tstatic const int MAX_V=80100;\n\tint V;\n\tvector<edge> G[MAX_V];\n\tint h[MAX_V];\n\tint dist[MAX_V];\n\tint prevv[MAX_V],preve[MAX_V];\n\tint top[MAX_V];\n\tMinCostFlowNegative(int n){\n\t\tV = n;\n\t\tfill(h, h+MAX_V, 0);\n\t\tfill(dist,  dist+MAX_V, 0);\n\t\tfill(prevv, prevv+MAX_V, 0);\n\t\tfill(preve, preve+MAX_V, 0);\n\t\tfill(top,   top+MAX_V, 0);\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost){\n\t//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\t\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tint min_cost_flow(int s, int t, int f){\n\t\tint res=0;\n\t\tfill(h,h+V,0);\n\t\trep(i,V){\n\t\t\tint v=top[i];\n\t\t\trep(j,G[v].size()){\n\t\t\t\tedge &e=G[v][j];\n\t\t\t\tif(e.cap==0) continue;\n\t\t\t\tint u=e.to;\n\t\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t\t}\n\t\t}\n\t\twhile(f>0){\n\t\t\tpriority_queue< pii,vector<pii>,greater<pii> > que;\n\t\t\tfill(dist,dist+V,INF);\n\t\t\tdist[s]=0;\n\t\t\tque.push(pii(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tpii p=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first) continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tque.push(pii(dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==INF) return -1;\n\t\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf-=d;\n\t\t\tres+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// typedef pair<int,int> P;\n// struct edge {int to,cap,cost,rev;};\n// const int MAX_V=80100;\n// int V;\t\t\t//代入!!\n// vector<edge> G[MAX_V];\n// int h[MAX_V];\n// int dist[MAX_V];\n// int prevv[MAX_V],preve[MAX_V];\n// int top[MAX_V];\n// int s,t,l,r;\n// void add_edge(int from, int to, int cap, int cost){\n// //\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n// \tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n// \tG[from].push_back(e1);\n// \tG[to].push_back(e2);\n// }\n// int min_cost_flow(int s, int t, int f){\n// \tint res=0;\n// \tfill(h,h+V,0);\n// \trep(i,V){\n// \t\tint v=top[i];\n// \t\trep(j,G[v].size()){\n// \t\t\tedge &e=G[v][j];\n// \t\t\tif(e.cap==0) continue;\n// \t\t\tint u=e.to;\n// \t\t\th[u]=min(h[u],h[v]+e.cost);\n// \t\t}\n// \t}\n// //\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n// \twhile(f>0){\n// \t\tpriority_queue< P,vector<P>,greater<P> > que;\n// \t\tfill(dist,dist+V,INF);\n// \t\tdist[s]=0;\n// \t\tque.push(P(0,s));\n// \t\twhile(!que.empty()){\n// \t\t\tP p=que.top();\n// \t\t\tque.pop();\n// \t\t\tint v=p.second;\n// \t\t\tif(dist[v]<p.first) continue;\n// \t\t\tfor(int i=0;i<G[v].size();i++){\n// \t\t\t\tedge &e=G[v][i];\n// \t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n// \t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n// \t\t\t\t\tprevv[e.to]=v;\n// \t\t\t\t\tpreve[e.to]=i;\n// \t\t\t\t\tque.push(P(dist[e.to],e.to));\n// \t\t\t\t}\n// \t\t\t}\n// \t\t}\n// \t\tif(dist[t]==INF) return -1;\n// \t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n// \t\tint d=f;\n// \t\tfor(int v=t;v!=s;v=prevv[v]){\n// \t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n// \t\t}\n// \t\tf-=d;\n// \t\tres+=d*h[t];\n// \t\tfor(int v=t;v!=s;v=prevv[v]){\n// \t\t\tedge &e=G[prevv[v]][preve[v]];\n// \t\t\te.cap-=d;\n// \t\t\tG[v][e.rev].cap+=d;\n// \t\t}\n// \t}\n// \treturn res;\n// }\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tMinCostFlowNegative mf(H*W+off+5);\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tmf.add_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tmf.add_edge(s, i*W+W+j, 1, -vv[i+1][j]), mf.add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tmf.add_edge(s, i*W+j+1, 1, -vv[i][j+1]), mf.add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tmf.add_edge(source, 0, 1, -vv[0][0]);\n\tmf.add_edge(source, 0, 1, 0);\n\tmf.add_edge(H*W-1, sink, 2, 0);\n\tcout << -mf.min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint H, W, a[212][212];\nint ans = 0;\n\nint main(void) {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) { for (int j = 0; j < W; ++j) { scanf(\"%d\", &a[i][j]); } }\n\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n#include <complex>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 220;\nint h, w;\nll g[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nll dp[2*MN][MN][MN];\nbool used[2*MN][MN][MN] = {};\n\nll solve(int d, int ax, int bx) {\n    int ay = d-ax, by = d-bx;\n    if (!bc(ax, ay) || !bc(bx, by)) return -TEN(15);\n    if (d == h+w-2) return g[ay][ax];\n    if (used[d][ax][bx]) return dp[d][ax][bx];\n    used[d][ax][bx] = true;\n    ll &ans = dp[d][ax][bx];\n    ans = -TEN(15);\n    ans = max(ans, solve(d+1, ax, bx));\n    ans = max(ans, solve(d+1, ax+1, bx));\n    ans = max(ans, solve(d+1, ax, bx+1));\n    ans = max(ans, solve(d+1, ax+1, bx+1));\n    ans += g[ay][ax] + g[by][bx];\n    if (ax == bx) {\n        ans -= g[ay][ax];\n    }\n    return ans;\n}\n\nint main() {\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> g[i][j];\n        }\n    }\n    cout << solve(0, 0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int h,w;\n  cin>>h>>w;\n  vector<vector<int> > vec(h, vector<int>(w));\n  rep(i,h) rep(j,w) cin>>vec[i][j];\n  vector<vector<int> > v(h+w, vector<int>(max(h,w),-1));\n  rep(k,h+w-1){\n    int i=k,j=0;\n    if(k>=h){ i=h-1; j=k-h+1;}\n    int d=j;\n    while(i>=0 && j<w){\n      v[k][d] = vec[i][j];\n      i--;j++;d++;\n    }\n  }\n\n  int d=max(h,w);\n  vector<vector<int>> prev(d,vector<int>(d,-1));\n  prev[0][0]=0;\n  rep(k, h+w-1){\n    vector<vector<int>> nxt(d,vector<int>(d,-1));\n    rep(j,d)rep(i,j+1)if(prev[i][j]>=0){\n      auto c = [&](int a,int b){\n        if(v[k][a]<0 || v[k][b]<0) return -INF;\n        else if(a==b) return v[k][a];\n        else return v[k][a]+v[k][b];\n      };\n      nxt[i][j] = max(nxt[i][j], prev[i][j]+c(i,j));\n      if(i+1<=j) nxt[i+1][j] = max(nxt[i+1][j], prev[i][j]+c(i+1,j));\n      if(j+1<d){\n        nxt[i+1][j+1] = max(nxt[i+1][j+1], prev[i][j]+c(i+1,j+1));\n        nxt[i][j+1] = max(nxt[i][j+1], prev[i][j]+c(i,j+1));\n      }\n    }\n    swap(prev,nxt);\n  }\n\n  cout << prev[d-1][d-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint h, w, a[200][600];\nint dp[400][200][200];\n\nint main() {\n\tscanf(\"%d%d\", &h, &w);\n\tinc(i, h) { \n\tinc(j, w) {\n\t\tscanf(\"%d\", &a[i][j + 200]);\n\t}\n\t}\n\t\n\tdp[0][0][0] = a[0][0 + 200];\n\tinc(i, h + w - 1 - 1) {\n\t\tinc(j, h) {\n\t\tinc(k, h) {\n\t\t\tint jj[4] = { 0, 0, 1, 1 };\n\t\t\tint kk[4] = { 0, 1, 0, 1 };\n\t\t\tinc(l, 4) {\n\t\t\t\tint jjj = j + jj[l];\n\t\t\t\tint kkk = k + kk[l];\n\t\t\t\tif(0 <= jjj && jjj < h && 0 <= kkk && kkk < h) {\n\t\t\t\t\tsetmax(dp[i + 1][jjj][kkk], dp[i][j][k] + a[jjj][i+1 - jjj + 200] + (jjj == kkk ? 0 : a[kkk][i+1 - kkk + 200]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[h + w - 2][h - 1][h - 1]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\nusing namespace std;\nmap<int, int> mp;\nint f(vector<vector<int>> &A, int y1, int x1, int y2, int x2){\n\tint X = (y1 * 200 + x1) * 200 + y2;\n\tif (mp.count(X)){\n\t\treturn mp[T];\n\t} else {\n\t\tint tmp = A[y1][x1] + A[y2][x2];\n\t\tif (y1 == y2 && x1 == x2){\n\t\t\ttmp /= 2;\n\t\t}\n\t\tint ans = 0;\n\t\tif (y1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2 - 1, x2));\n\t\t}\n\t\tif (y1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2, x2 - 1));\n\t\t}\n\t\tif (x1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2 - 1, x2));\n\t\t}\n\t\tif (x1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2, x2 - 1));\n\t\t}\n\t\tans += tmp;\n\t\tmp[X] = ans;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> A(H, vector<int>(W));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tcout << f(A, H - 1, W - 1, H - 1, W - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n#include <ctype.h>\nusing namespace std;\nint h,k=0;\nint main() {\n\twhile (cin>>h)\n\t{\n\t\tk += h;\n\t}\n\tcout << k;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst ll INF=1e13;\nll a[2222][2222];\nll dp[422][222][222];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m;\n  cin>>n>>m;\n  rep(i,n)rep(j,m) cin>>a[i][j];\n  fill(dp[0][0],dp[0][0]+422*222*222,-INF);\n  dp[0][0][0]=0;\n  rep(i,n+m-1)rep(j,m)rep(k,j+1){\n    if(i-j>=0){\n      dp[i][j][k]+=a[i-j][j];\n      if(j!=k) dp[i][j][k]+=a[i-k][k];\n    }\n    rep(a,2)rep(b,2) MX(dp[i+1][j+a][k+b],dp[i][j][k]);\n  }\n  cout<<dp[n+m-2][m-1][m-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint h,w;\nint a[252][252];\nvector<pii> g[52525];\nint bef[52525];\nint dist[52525];\nint used[52525];\n\n#define ID(i,j) ((i)*w+j)\n#define REV(i,j,v) int i=v/w, j=v%w\n\nconst int NICO = 125252;\nconst int INF = 830252521;\n\nint main(){\n  scanf(\"%d%d\",&h,&w);\n  REP(i,h)REP(j,w)scanf(\"%d\",&a[i][j]);\n  // start : (0,0)\n  // goal : (h,w)\n\n  // first flow\n  REP(i,h)REP(j,w){\n    if(i<h-1){\n      g[ID(i,j)].push_back(pii(ID(i+1,j),NICO-a[i+1][j]));\n    }\n    if(j<w-1){\n      g[ID(i,j)].push_back(pii(ID(i,j+1),NICO-a[i][j+1]));\n    }\n  }\n  REP(i,w*h)dist[i] = INF;\n  priority_queue<pii> Q;\n  dist[0] = 0;\n  Q.push(pii(-0,0));\n  while(!Q.empty()){\n    pii P = Q.top(); Q.pop();\n    int d = -P.first;\n    int id = P.second;\n    for(pii X:g[id]){\n      int to = X.first;\n      int cost = X.second;\n      if(d+cost < dist[to]){\n        dist[to] = d+cost;\n        bef[to] = id;\n        Q.push(pii(-dist[to],to));\n      }\n    }\n  }\n  ll first_attempt = (ll)(w+h-2)*NICO-dist[w*h-1];\n  // second construct\n  int cur = w*h-1;\n  REP(i,w*h)used[i] = -1;\n  REP(i,w*h)g[i].clear();\n  while(cur!=0){\n    // DEBUG(cur);\n    int par = bef[cur];\n    used[par] = cur;\n    REV(i,j,cur);\n    g[cur].push_back(pii(par,a[i][j]-NICO));\n    if(i>0 && par == ID(i-1,j)){\n      if(j>0){\n        g[ID(i,j-1)].push_back(pii(par,0));\n      }\n    }else{\n      if(i>0){\n        g[ID(i-1,j)].push_back(pii(par,0));\n      }\n    }\n    a[i][j] = 0;\n    cur = par;\n  }\n  REP(i,h)REP(j,w){\n    if(i<h-1 && used[ID(i,j)]!=ID(i+1,j)){\n      g[ID(i,j)].push_back(pii(ID(i+1,j),NICO-a[i+1][j]));\n    }\n    if(j<w-1 && used[ID(i,j)]!=ID(i,j+1)){\n      g[ID(i,j)].push_back(pii(ID(i,j+1),NICO-a[i][j+1]));\n    }\n  }\n  REP(i,w*h)dist[i] = INF;\n  dist[0] = 0;\n  Q.push(pii(-0,0));\n  while(!Q.empty()){\n    pii P = Q.top(); Q.pop();\n    int d = -P.first;\n    int id = P.second;\n    for(pii X:g[id]){\n      int to = X.first;\n      int cost = X.second;\n      if(d+cost < dist[to]){\n        dist[to] = d+cost;\n        bef[to] = id;\n        Q.push(pii(-dist[to],to));\n      }\n    }\n  }\n  // cur = w*h-1;\n  // while(cur!=0){\n  //   DEBUG(cur);\n  //   cur = bef[cur];\n  // }\n  ll second_attempt = (ll)(w+h-2)*NICO-dist[w*h-1];\n  // DEBUG(first_attempt);\n  // DEBUG(second_attempt);\n  printf(\"%lld\\n\",first_attempt+second_attempt - a[h-1][w-1]+a[0][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,j,x,y,t,p,dx[]={-1,0},dy[]={0,-1};\nll a[35][35],f[35][35][35][35];\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tf[1][1][1][1]=a[1][1];\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tfor(x=1;x<=n;x++)\n\t\t\t{\n\t\t\t\tfor(y=1;y<=m;y++)\n\t\t\t\t{\n\t\t\t\t\tif(x+y!=i+j)continue;\n\t\t\t\t\tfor(t=0;t<2;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(p=0;p<2;p++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[i][j][x][y]=max(f[i][j][x][y],f[i+dx[t]][j+dy[t]][x+dx[p]][y+dy[p]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j][x][y]+=a[i][j]+a[x][y];\n\t\t\t\t\tif(i==x && j==y)f[i][j][x][y]-=a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][m][n][m]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\nll inf=1e18+9;\n\n/*\nWA\n１人目を探索させてから２人目を探索させる貪欲\n*/\n\nll h,w,a[210][210],dp[210][210],dx[2]={0,1},dy[2]={1,0},ans=0;\n\n//普通にdp\nll f(ll x,ll y){\n\tll ans=0;\n\trep(i,2){\n\t\tif(x+dx[i]>w-1 || y+dy[i]>h-1)continue;\n\t\tans=max(ans,f(x+dx[i],y+dy[i]));\n\t}\n\treturn dp[y][x]=ans+a[y][x];\n}\n//fで通った場所を消す\nvoid g(ll x,ll y){\n\twhile(1){\n\t\ta[y][x]=0;\n\t\tif(x==w-1 && y==h-1)break;\n\t\tll b=0,to=0;\n\t\trep(i,2){\n\t\t\tif(x+dx[i]>w-1 || y+dy[i]>h-1)continue;\n\t\t\tif(dp[y+dy[i]][x+dx[i]]>b){\n\t\t\t\tto=i;\n\t\t\t\tb=dp[y+dy[i]][x+dx[i]];\n\t\t\t}\n\t\t}\n\t\tx=x+dx[to];\n\t\ty=y+dy[to];\n\t}\n}\n\nvoid dp_reset(){\n\trep(i,210)rep(j,210)dp[i][j]=-1;//初期化\n}\n\nint main(void){\n\tcin>>h>>w;\n\trep(i,h)rep(j,w)cin>>a[i][j];\n\tdp_reset();\n\tans+=f(0,0);\n\t// rep(i,h){\n\t// \trep(j,w)cout<<dp[i][j]<<\" \";\n\t// \tcout<<endl;\n\t// }\n\tg(0,0);\n\t// rep(i,h){\n\t// \trep(j,w)cout<<a[i][j]<<\" \";\n\t// \tcout<<endl;\n\t// }\n\tdp_reset();\n\tans+=f(0,0);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nusing State = pair<LL, PII>; // <score, (h, w)>\nint H, W;\nVVI a;\n\n//int dp[MAX_H][MAX_W][MAX_H][MAX_W];\nVT<VT<VVI>> dp;\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    dp.resize(H, VT<VVI>(W, VVI(H, VI(W, 0))));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H <= 30 && W <= 30);\n    dp[0][0][0][0] = a[0][0];\n    REP(eh, H) REP(ew, W) REP(sh, H) REP(sw, W) {\n        if (eh == 0 && ew == 0 && sh == 0 && sw == 0) continue;\n        int buf = 0;\n        if (eh && sh) buf = max(buf, dp[eh - 1][ew][sh - 1][sw]);\n        if (eh && sw) buf = max(buf, dp[eh - 1][ew][sh][sw - 1]);\n        if (ew && sw) buf = max(buf, dp[eh][ew - 1][sh][sw - 1]);\n        if (ew && sh) buf = max(buf, dp[eh][ew - 1][sh - 1][sw]);\n        if (eh == sh && ew == sw) dp[eh][ew][sh][sw] = buf + a[sh][sw];\n        else dp[eh][ew][sh][sw] = buf + a[eh][ew] + a[sh][sw];\n    }\n    cout << dp[H - 1][W - 1][H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tif(n<=2||m<=2){\n\t\tint out=0;\n\t\trep(i,n)rep(j,m)out+=in[i][j];\n\t\tcout<<out<<endl;\n\t\treturn 0;\n\t}\n\tvi dp(40010);\n\tdp[200]=in[0][0]+in[1][0]+in[0][1]+in[n-1][m-1];\n\tloop(i,2,n+m-2){\n\t\tvi tmp(40010);\n\t\trep(j,40010)if(dp[j]){\n\t\t\tint l=j%200,r=j/200;\n\t\t\t//l=0 r=1\n\t\t\trep(q1,2)rep(q2,2){\n\t\t\t\tint L=l+q1,R=r+q2;\n\t\t\t\tif(i-L==n||L==R||R==m)continue;\n\t\t\t\ttmp[L+200*R]=max(tmp[L+200*R],dp[j]+in[i-L][L]+in[i-R][R]);\n\t\t\t}\n\t\t}\n\t\tdp=tmp;\n\t}\n\tcout<<dp[(m-2)+(m-1)*200]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ary[210][210];\nint main(){\n\tint H,W;\n\tcin>>H>>W;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tcin>>ary[i][j];\n\t\t}\n\t}\n\n\t//部分\n\tint res=0;\n\tif(H<=2){\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tres+=ary[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(ll i=0;i<n;i++)\n#define MOD 1000000007\n#define EPS (1e-10)\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint a[300][300];\nint main() {\n\tint h, w; scanf(\"%d%d\", &h, &w);\n\trep(i, h)rep(j, w) {\n\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tprintf(\"%d\\n\", accumulate(a[0], a[300], 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n#include <ctype.h>\nusing namespace std;\nint a,b,h,k=0;\nint main() {\n\tcin >> a >> b;\n\twhile (cin>>h)\n\t{\n\t\tk += h;\n\t}\n\tcout << k;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\nll inf=1e18+9;\n\n/*\nac\n２人を同時に探索させる（２人のx+yは同じ）．\n始点・終点以外同じ場所を通らなくても最適な経路にできる．\n何故１人目を探索させてから２人目を探索させるではいけないのかまだ分からない．\n*/\n\nll h,w,a[210][210],dp[210][210][410],b=0,dx[2]={0,1},dy[2]={1,0};\n\nll f(ll x1,ll x2,ll sum){//最初の経路\n\tif(dp[x1][x2][sum]!=-1)return dp[x1][x2][sum];\n\tll y1=sum-x1,y2=sum-x2,ans=0;\n\trep(i,2){\n\t\trep(j,2){\n\t\t\tif(x1+dx[i]>w-1 || x2+dx[j]>w-1 || y1+dy[i]>h-1 || y2+dy[j]>h-1)continue;\n\t\t\t//行き先が一致しないようにする\n\t\t\t//この方法の都合上，最初と最後だけ場合分けが必要\n\t\t\tif(x1+dx[i]==x2+dx[j] && y1+dy[i]==y2+dy[j])continue;\n\t\t\tans=max(ans,f(x1+dx[i],x2+dx[j],sum+1));\n\t\t}\n\t}\n\treturn dp[x1][x2][sum]=ans+a[sum-x1][x1]+a[sum-x2][x2];\n}\n\nint main(void){\n\tcin>>h>>w;\n\trep(i,h)rep(j,w)cin>>a[i][j];\n\trep(i,210)rep(j,210)rep(k,410)dp[i][j][k]=-1;\n\tcout<<f(1,0,1)+a[0][0]+a[h-1][w-1]<<endl;//最初と最後だけどうしても同じ場所にいなくちゃいけないので，個別に足す\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nint mf(const int& a, const int& b, const int& c, const int& d) {\n  return max(a, max(b, max(c, d)));\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int mp[n][m];\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n      cin >> mp[i][j];\n  int dp[n][m][n] = {};\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      for (int k = max(0, i + j - n + 1); k < min(i + j + 1, n); ++k) {\n        dp[i][j][k] = mf(i ? dp[i-1][j][k] : 0,\n                         j ? dp[i][j-1][k] : 0,\n                         i && k ? dp[i-1][j][k-1] : 0,\n                         j && k ? dp[i][j-1][k-1] : 0)\n                        + mp[i][j] + (i == k ? 0 : mp[k][i+j-k]);\n      }\n    }\n  }\n  cout << dp[n-1][m-1][n-1] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n)   for(int i=0;i<(n);++i)\n#define ALL(v)     (v).begin(),(v).end()\n#define debug(x)   cerr<<#x<<\": \"<<(x)<<endl\nusing namespace std;\nusing llong = long long;\nusing vi    = vector<int>;\nusing vvi   = vector<vi >;\nusing vvvi  = vector<vvi >;\nusing pii   = pair<int,int>;\nconstexpr int    INF=1e9;\nconstexpr double EPS=1e-9;\nconstexpr int    MOD=1e9+7;\ntemplate<class Type>\nvoid line(const Type &a){int cnt=0;for(const auto &elem:a){cerr<<(cnt++?' ':'>');cerr<<elem;}cerr<<endl;}\n\nusing vl    = vector<long long>;\nusing vvl   = vector<vl >;\nusing vvvl  = vector<vvl >;\n\nconst int dy[]={0,1};\nconst int dx[]={1,0};\n\n/*最小費用流*/\ntemplate<typename T,typename U>\nstruct PrimalDual{\n\tusing P = pair<U,int>;\n\tstruct Edge{//Edge:=(辺の情報を表す構造体).\n\t\tint to;\t\t//to:=(行き先).\n\t\tT cap;\t\t//cap:=(容量).\n\t\tU cost;\t\t//cost:=(コスト).\n\t\tint rev;\t//rev:=(逆辺).\n\t};\n\t\n\tint vn;\t\t\t\t\t//ノード数.\n\tvector<vector<Edge> > g;//g[i]:=(ノードiの隣接リスト).\n\tvector<U> h;\t\t\t//h[i]:=(ノードiのポテンシャル).\n\tvector<U> dist;\t\t\t//dist[i]:=(ノートiまでの最短距離).\n\tvi prevv,preve;\t\t\t//prevv:=(直前のノード), preve:=(直前の辺).\n\tU inf;\n\t\n\tPrimalDual(unsigned int vn_):vn(vn_),g(vn_),h(vn_),dist(vn_),prevv(vn_),preve(vn_){\n\t\tif(typeid(U)==typeid(int)) inf=1e9;\n\t\telse if(typeid(U)==typeid(long long)) inf=1e18;\n\t}\n\t\n\tvoid add_egde(int from,int to,T cap,U cost){//fromからtoへ向かう容量cap,コストcastの辺をグラフに追加する.\n\t\tg[from].push_back((Edge){to,cap,cost,(int)g[to].size()});\n\t\tg[to].push_back((Edge){from,0,-cost,(int)g[from].size()-1});\n\t}\n\tU min_cost_flow(int s,int t,T f){//sからtへの流量fの最小費用流を求める. 流せない場合は-1を返す. O(F*|E|*log|V|).\n\t\tU res=0;\n\t\tfill(ALL(h),0);\n\t\twhile(f>0){\n\t\t\tfill(ALL(dist),inf);//ダイクストラ法でhを更新する.\n\t\t\tdist[s]=0;\n\t\t\tpriority_queue<P,vector<P>,greater<P> > pque;\n\t\t\tpque.push(P(0,s));\n\t\t\twhile(!pque.empty()){\n\t\t\t\tP p=pque.top();\n\t\t\t\tpque.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first) continue;\n\t\t\t\tREP(i,g[v].size()){\n\t\t\t\t\tEdge &e=g[v][i];\n\t\t\t\t\tif(e.cap>0 and dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tpque.push(P(dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf) return -1;//これ以上流せない.\n\t\t\tREP(v,vn) h[v]+=dist[v];\n\t\t\tint d=f;//s-t間最短路に沿って目一杯流す.\n\t\t\tfor(int v=t;v!=s;v=prevv[v]) d=min(d,g[prevv[v]][preve[v]].cap);\n\t\t\tf-=d;\n\t\t\tres+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\t\tEdge &e=g[prevv[v]][preve[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tg[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\n\tvvl a(h,vl(w));\n\tREP(i,h)REP(j,w) cin>>a[i][j];\n\t\n\tPrimalDual<int,llong> ob(2*h*w+2);//(s,t):=(2*h*w,2*h*w+1).\n\tob.add_egde(2*h*w,0,1,-a[0][0]);//マイナスにする!\n\tob.add_egde(2*h*w,0,1,0);\n\tob.add_egde(h*w-1,2*h*w+1,1,0);\n\tob.add_egde(2*h*w-1,2*h*w+1,1,0);\n\tauto jud=[&](const int y,const int x)->bool{\n\t\treturn (0<=y and y<h and 0<=x and x<w);\n\t};\n\tREP(i,h)REP(j,w){\n\t\tREP(k,2){\n\t\t\tint ny=i+dy[k], nx=j+dx[k];\n\t\t\tif(jud(ny,nx)){\n\t\t\t\tREP(ii,2)REP(jj,2){\n\t\t\t\t\tif(jj==0) ob.add_egde(i*w+j+ii*h*w,ny*w+nx+jj*h*w,1,-a[ny][nx]);//マイナスにする!\n\t\t\t\t\telse ob.add_egde(i*w+j+ii*h*w,ny*w+nx+jj*h*w,1,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<-ob.min_cost_flow(2*h*w,2*h*w+1,2)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> dp(8000000, -1);\nint f(vector<vector<int>> &A, int y1, int x1, int y2, int x2){\n\tint X = (y1 * 200 + x1) * 200 + y2;\n\tif (dp[X] != -1){\n\t\treturn dp[X];\n\t} else {\n\t\tint tmp = A[y1][x1] + A[y2][x2];\n\t\tif (y1 == y2 && x1 == x2){\n\t\t\ttmp /= 2;\n\t\t}\n\t\tint ans = 0;\n\t\tif (y1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2 - 1, x2));\n\t\t}\n\t\tif (y1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1 - 1, x1, y2, x2 - 1));\n\t\t}\n\t\tif (x1 > 0 && y2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2 - 1, x2));\n\t\t}\n\t\tif (x1 > 0 && x2 > 0){\n\t\t\tans = max(ans, f(A, y1, x1 - 1, y2, x2 - 1));\n\t\t}\n\t\tans += tmp;\n\t\tdp[X] = ans;\n\t\treturn ans;\n\t}\n}\nint main(){\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> A(H, vector<int>(W));\n\tfor (int i = 0; i < H; i++){\n\t\tfor (int j = 0; j < W; j++){\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tcout << f(A, H - 1, W - 1, H - 1, W - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <functional>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 405;\nint dp[N][N][N];\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    VVI a(h, VI(w));\n    REP(i,h) REP(j,w){\n        a[i][j] = in();\n    }\n    dp[1][1][0] = a[0][0] + a[1][0] + a[0][1];\n    FOR(i,1,h+w-3) REP(xi,h) REP(yi,xi){\n        int xj = i - xi;\n        int yj = i - yi;\n        if (xj < 0 || xj >= w) continue;\n        if (yj < 0 || yj >= w) continue;\n        if (xi < h - 1 && yi < h - 1){\n            chmax(dp[i + 1][xi + 1][yi + 1], dp[i][xi][yi] + a[xi + 1][xj] + a[yi + 1][yj]);\n        }\n        if (xi < h - 1 && yj < w - 1){\n            chmax(dp[i + 1][xi + 1][yi], dp[i][xi][yi] + a[xi + 1][xj] + a[yi][yj + 1]);\n        }\n        if (xj < w - 1 && yi < h - 1 && xi > yi + 1){\n            chmax(dp[i + 1][xi][yi + 1], dp[i][xi][yi] + a[xi][xj + 1] + a[yi + 1][yj]);\n        }\n        if (xj < w - 1 && yj < w - 1){\n            chmax(dp[i + 1][xi][yi], dp[i][xi][yi] + a[xi][xj + 1] + a[yi][yj + 1]);\n        }\n    }\n    int ans = dp[h + w - 3][h - 1][h - 2] + a[h - 1][w - 1];\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint dp[30][30][30][30];\nint a, b;\nint c[30][30];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f][g] != -1)return dp[d][e][f][g];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y);\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f][g] = max(dp[d][e][f][g], S);\n\t\t}\n\t}\n\treturn dp[d][e][f][g];\n}\nsigned main() {\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0][0] = c[0][0];\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=24100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+2;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 201\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-1, 1) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j  !=k)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j+1!=k)?A[i-(k  )][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j!=k+1)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j  !=k)?A[i-(k  )][k  ]:0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\ntypedef long long ll;\nint H,W,v[200][200];\nll dp[201][200][200];\nint main(){\n\tcin>>H>>W;\n\trep(i,H) rep(j,W) cin>>v[i][j];\n\tif(W==1){\n\t\tll ans=0;\n\t\trep(i,H) ans+=v[i][0];\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\trep(i,H+1) rep(j,W) rep(k,W) dp[i][j][k]=-1;\n\tdp[0][0][0]=v[0][0];\n\trep(i,H){\n\t\trep(a,W) for(int b=a;b<W;b++) if(dp[i][a][b]){\n\t\t\tif(a+1<b) chmax(dp[i][a+1][b],dp[i][a][b]+v[i][a+1]);\n\t\t}\n\t\trep(a,W) for(int b=a;b<W-1;b++) if(dp[i][a][b]){\n\t\t\tchmax(dp[i][a][b+1],dp[i][a][b]+v[i][b+1]);\n\t\t}\n\t\tif(i==H-1){\n\t\t\tll ans=0;\n\t\t\trep(a,W) rep(b,W) chmax(ans,dp[i][a][b]);\n\t\t\tcout<<ans<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\trep(a,W) for(int b=a+1;b<W;b++) if(dp[i][a][b]){\n\t\t\tdp[i+1][a][b]=dp[i][a][b]+v[i+1][a]+v[i+1][b];\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[200][200][200];\nint a, b;\nint c[30][30];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f] != -1)return dp[d][e][f];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y);\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f] = max(dp[d][e][f], S);\n\t\t}\n\t}\n\treturn dp[d][e][f];\n}\nsigned main() {\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0] = c[0][0];\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 405\nint a[maxn][maxn];\nint dp[maxn][maxn][maxn];\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][1] = a[1][1];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tfor (int k = 1; k<=w&&k<=i+j-1;k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t\tdp[i][j + 1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k], dp[i][j][k] + a[i + 1][j] + a[i + j - k + 1][k]);\n\t\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j+1][k+1] ,dp[i][j][k] +a[i][j + 1] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j == k + 1)\n\t\t\t\t{\t\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i+1][j][k+1], dp[i][j][k] + a[i + 1][j] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j + 1 == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j + 1] + a[i + j - k + 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[h][w][w] << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint H,W;\nint A[200];\nint dp[200][200];\nmain()\n{\n\tcin>>H>>W;\n\tfor(int i=0;i<W;i++)for(int j=0;j<W;j++)dp[i][j]=-1e9;\n\tdp[0][1]=0;\n\tfor(int _=0;_<H;_++)\n\t{\n\t\tfor(int i=0;i<W;i++)cin>>A[i];\n\t\tfor(int i=0;i<W;i++)for(int j=i+1;j<W;j++)\n\t\t{\n\t\t\tdp[i][j]+=A[i];\n\t\t\tif(i+1<j)dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t}\n\t\tfor(int i=0;i<W;i++)for(int j=i+1;j<W;j++)\n\t\t{\n\t\t\tdp[i][j]+=A[j];\n\t\t\tif(j+1<W)dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i+1<W;i++)ans=max(ans,dp[i][W-1]);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 D / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n\ntypedef long long PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n\ttypedef pair< PD_Type, int > pii;\n\n\tstruct edge\n\t{\n\t\tint to, rev;\n\t\tPD_Type\tcap, cost;\n\t\tedge() {}\n\t\tedge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\n\t};\n\tvector< vector< edge > > graph;\n\tvector< int > prevv, preve;\n\tvector< PD_Type > potential, min_cost;\n\tPrimal_Dual(int V) : graph(V) {}\n\n\tvoid add_edge(int from, int to, PD_Type cap, PD_Type cost)\n\t{\n\t\tgraph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n\t}\n\n\tPD_Type min_cost_flow(int s, int t, int f)\n\t{\n\t\tint V = graph.size();\n\t\tPD_Type ret = 0;\n\t\tpriority_queue< pii, vector< pii >, greater< pii > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\tFOR(k, 0, V) {\n\t\t\tFOR(i, 0, V) {\n\t\t\t\tFOR(j, 0, (int)graph[i].size()) {\n\t\t\t\t\tedge &e = graph[i][j];\n\t\t\t\t\tif (e.cap == 0)continue;\n\t\t\t\t\tpotential[e.to] = min(potential[e.to], potential[i] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, PD_INF);\n\t\t\tque.push(pii(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < (int)graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tPD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == PD_INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tPD_Type addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tvector<vector<LL>> a(H, vector<LL>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tauto V = [&](int i, int j, bool OUT) {\n\t\treturn 2 * (W*i + j) + OUT;\n\t};\n\tPrimal_Dual F(2 * H*W);\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, -a[i][j]);\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H - 1) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 1), V(i + 1, j, 0), 2, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W - 1) {\n\t\t\tF.add_edge(V(i, j, 1), V(i, j + 1, 0), 2, 0);\n\t\t}\n\t}\n\n\n\tLL ans = -F.min_cost_flow(V(0, 0, 0), V(H - 1, W - 1, 1), 2);\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int inf = 1e9;\n\nint main()\n{\n\n    //freopen(\"input.txt\", \"r\", stdin);\n\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int> > v(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> v[i][j];\n        }\n    }\n\n    vector<vector<vector<int> > > dp(n, vector<vector<int> >(n, vector<int>(n + m - 1, -inf)));\n    dp[0][0][0] = v[0][0];\n    int dx[2] = {1, 0};\n    int dy[2] = {0, 1};\n    for (int k = 0; k < n + m - 2; ++k) {\n        for (int a = 0; a < n; ++a) {\n            for (int b = 0; b < n; ++b) {\n                if (dp[a][b][k] != -inf) {\n                    int c = k - a, d = k - b;\n                    for (int i = 0; i < 2; ++i) {\n                        for (int j = 0; j < 2; ++j) {\n                            if (a + dx[i] < n && c + dy[i] < m && b + dx[j] < n && d + dy[j] < m) {\n                                int sum = v[a + dx[i]][c + dy[i]];\n                                if (a + dx[i] != b + dx[j] || c + dy[i] != d + dy[j]) {\n                                    sum += v[b + dx[j]][d + dy[j]];\n                                }\n                                dp[a + dx[i]][b + dx[j]][k + 1] = max(dp[a + dx[i]][b + dx[j]][k + 1], dp[a][b][k] + sum);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[n - 1][n - 1][n + m - 2] << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<30);\nconst int MAX = 100000;\nconst int MAX_V = 190000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , INF, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, INF, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint H,W;\nint dp [400] [200] [200];\nconst int INF = 1e9;\n\nbool in_range(int x,int y){\n\treturn x >= 0 && x < W && y >= 0 && y < H;\n}\n\nint main()\n{\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> H >> W;\n\tvector< vector<int> > A(H,vector<int>(W));\n\tFOR(i,0,H) FOR(j,0,W){\n\t\tcin >> A [i] [j];\n\t}\n\n\tfill(dp [0] [0],dp [H + W] [0],-INF);\n\tdp [0] [0] [0] = A [0] [0];\n\tFOR(i,0,H + W - 1) FOR(j,0,W) FOR(k,0,W) if(dp [i] [j] [k] >= 0){\n\t\tFOR(l,0,4){\n\t\t\tint x1 = j + l / 2,y1 = i - x1 + 1,x2 = k + l % 2,y2 = i - x2 + 1;\n\t\t\tif(in_range(x1,y1) == false || in_range(x2,y2) == false) continue;\n\t\t\tint add;\n\t\t\tif(x1 == x2 && y1 == y2){\n\t\t\t\tadd = A [y1] [x1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadd = A [y1] [x1] + A [y2] [x2];\n\t\t\t}\n\t\t\tchmax(dp [i + 1] [x1] [x2],dp [i] [j] [k] + add);\n\t\t}\n\t}\n\n\tcout << dp [H + W - 2] [W - 1] [W - 1] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T1, class T2>\nvoid chmax(T1 &a, T2 b) {\n    if (a < b) a = b;\n}\n\nint h, w, a[200][200];\nint dp[200][200][200];\n\nconst int dy[] = { 0, 1 };\nconst int dx[] = { 1, 0 };\n\nint main() {\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) cin >> a[i][j];\n    fill_n(**dp, 200 * 200 * 200, -1e9);\n\n    dp[0][0][0] = a[0][0];\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            for (int ii = 0; ii < h; ii++) {\n                int jj = (i + j) - ii;\n                for (int k = 0; k < 2; k++) {\n                    for (int kk = 0; kk < 2; kk++) {\n                        int ni = i + dy[k];\n                        int nj = j + dx[k];\n                        int nii = ii + dy[kk];\n                        int njj = jj + dx[kk];\n                        if (ni >= h || nii >= h || nj >= w || njj >= w) continue;\n                        int gain = 0;\n                        if (ni == nii && nj == njj) {\n                            gain = a[ni][nj];\n                        } else {\n                            gain = a[ni][nj] + a[nii][njj];\n                        }\n                        chmax(dp[ni][nj][nii], dp[i][j][ii] + gain);\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[h - 1][w - 1][h - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=10100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+5;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define pb push_back\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\n#define lb(a, b) lower_bound((a).begin(), (a).end(), (b))\n#define ub(a, b) upper_bound((a).begin(), (a).end(), (b))\n#define bitcnt(a) (ll) __builtin_popcount((a))\nusing namespace std;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> TP;\ntemplate <typename T> void fill_all(T &arr, const T &v) { arr = v; }\ntemplate <typename T, typename ARR> void fill_all(ARR &arr, const T &v) {\n  for (auto &i : arr) {\n    fill_all(i, v);\n  }\n}\n//------------------変数-----------------------//\n\n//-------------------関数----------------------//\nll h, w, grid[200][200], dp[500][200][200];\nll p[] = {1, 0, 0, 1, 1, 1, 0, 0};\nint main() {\n  cin >> h >> w;\n  REP(i, h) {\n    REP(j, w) { cin >> grid[i][j]; }\n  }\n  REP(i, h + w - 2) {\n    REP(X, min(w, i + 1)) {\n      REP(x, min(w, i + 1)) {\n        if (h <= i - X || h <= i - x)\n          continue;\n        ll y = i - x, Y = i - X, cost = grid[Y][X] + grid[y][x];\n        // cost -= (X == x && grid[y][x]);\n        cost -= (X == x ? grid[y][x] : 0);\n        REP(k, 4) {\n          dp[i + 1][X + p[k * 2]][x + p[k * 2 + 1]] = max(\n              dp[i + 1][X + p[k * 2]][x + p[k * 2 + 1]], cost + dp[i][X][x]);\n        }\n      }\n    }\n  }\n  cout << dp[h + w - 2][w - 1][w - 1] + grid[h - 1][w - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst long long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<Edge>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, k, q, p, ans, sum, cnt, a[300][300], b[21], dp[200][200][400];\nint main() {\n\tcin >> h >> w;\n\tg.resize(h*w);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tdp[0][0][0] = a[0][0];\n\trep(st, h + w-1) {\n\t\trep(sx, h) {\n\t\t\trep(tx, h) {\n\t\t\t\tLL sy = st - sx, ty = st - tx;\n\t\t\t\tif (dp[st + 1][sx][tx] < dp[st][sx][tx] + (sx == tx ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx][st - tx + 1])) {\n\t\t\t\t\tdp[st + 1][sx][tx] = dp[st][sx][tx] + (sx == tx ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx][st - tx + 1]);\n\t\t\t\t}\n\t\t\t\tif (sx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx + 1][tx] < dp[st][sx][tx] + (sx + 1 == tx ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx][st - tx + 1])) {\n\t\t\t\t\t\tdp[st + 1][sx + 1][tx] = dp[st][sx][tx] + (sx + 1 == tx ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx][st - tx + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx][tx + 1] < dp[st][sx][tx] + (sx == tx + 1 ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx + 1][st - tx])) {\n\t\t\t\t\t\tdp[st + 1][sx][tx + 1] = dp[st][sx][tx] + (sx == tx + 1 ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx + 1][st - tx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tx + 1 < h&&sx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx + 1][tx + 1] < dp[st][sx][tx] + (sx + 1 == tx + 1 ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx + 1][st - tx])) {\n\t\t\t\t\t\tdp[st + 1][sx + 1][tx + 1] = dp[st][sx][tx] + (sx + 1 == tx + 1 ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx + 1][st - tx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h + w - 2][h - 1][h - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <deque>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define It iterator\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\n\n#define maxn 55\nint m,n,a[maxn][maxn];\nint f[maxn*2][maxn][maxn];\nint main() {\n    //freopen(\"test.in\",\"r\",stdin);\n    cin>>m>>n;\n    for(int i=1; i<=m; i++) {\n        for(int j=1; j<=n; j++) cin>>a[i][j];\n    }\n    for(int k=1; k<=m+n; k++) {\n        for(int i=1; i<=k-1; i++) {\n            for(int j=1; j<=k-1; j++) {\n                int s1=0,s2=0;\n                    if(i!=j) {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i]+a[j][k-j];\n                    } else {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i];\n                    }\n            }\n        }\n    }\n    cout<<f[m+n][m][m]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w;\nvvi a,b;\n\nint main(){\n\tcin>>h>>w;\n\ta=b=vvi(h,vi(w));\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) cin>>a[i][j];\n\tif(w==1){\n\t\tint res=0;\n\t\tfor(int i=0;i<h;i++) res+=a[i][0];\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tint t=0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tt+=a[i][j];\n\t\t\tif(j&&i+1<h) t-=a[i+1][j-1];\n\t\t\tb[i][j]=t;\n\t\t}\n\t}\n\tvvi dp(w,vi(w,-inf));\n\tfor(int i=1;i<w;i++) dp[0][i]=b[0][i];\n\tfor(int i=1;i<h;i++){\n\t\tvvi DP(w,vi(w));\n\t\tfor(int j=0;j<w;j++) for(int k=0;k<w;k++){\n\t\t\tif(j) dp[j][k]=max(dp[j-1][k],dp[j][k]);\n\t\t}\n\t\tfor(int j=0;j<w;j++){\n\t\t\tint mx=-inf;\n\t\t\tfor(int k=j+1;k<w;k++){\n\t\t\t\tmx=max(mx,dp[j][k]);\n\t\t\t\tDP[j][k]=mx+b[i][j]+b[i][k];\n\t\t\t}\n\t\t}\n\t\tdp=DP;\n\t}\n\tint res=0;\n\tfor(int i=0;i<w;i++) for(int j=0;j<w;j++) res=max(res,dp[i][j]);\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<unordered_set>\n#include<vector>\n#include<array>\n#include<string>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<functional>\n#include<random>\n#include<complex>\n#include<bitset>\n#include<chrono>\n//#include<boost/multiprecision/cpp_int.hpp>\n#define int int64_t\n#define uint uint64_t\n#define REP(i, a, b) for (int64_t i = (int64_t)(a); i < (int64_t)(b); i++)\n#define rep(i, a) REP(i, 0, a)\n#define EACH(i, a) for (auto i: a)\n#define ITR(x, a) for (auto x = a.begin(); x != a.end(); x++)\n#define ALL(a) (a.begin()), (a.end())\n#define HAS(a, x) (a.find(x) != a.end())\n#define Min(x) *min_element(ALL(x))\n#define Max(x) *max_element(ALL(x))\n#define Unique(L) (L.erase(unique(ALL(L)), L.end()))\n#define veccat(v1, v2) std::copy((v2).begin(),(v2).end(),std::back_inserter(v1)/*v1の後ろにv2を入れる*/)\n#define intmax (std::numeric_limits<int64_t>::max() / 4)\nusing namespace std;\n//typedef boost::multiprecision::cpp_int bigint;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>>a(H, vector<int>(W, 0));\n\trep(i, H)rep(j, W)cin >> a[i][j];\n\n\tassert(H <= 2);\n\tint ans = 0;\n\trep(i, H)rep(j, W)ans += a[i][j];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//列ごとに移動を決めると, [列][sの行][eの行]で{ その後できる移動 }が決まることが分かる。\n//また, sの行 <= eの行としてもよい。\n//これでmax化DPすればよさそう。愚直にやると状態数O(HW^2), 遷移O(H^2)でTLE.\n\n#include <iostream>\n#define int long long\nusing namespace std;\n\nint h, w;\nint a[200][200];\nint dp[201][200][200];\t//dp[col][row_1][row_2] (回収作業の直前）\nint ra[200][201];\t\t//ra[col][n] = a[0][col] + a[1][col] + … + a[n - 1][col]\n\nsigned main() {\n\tint i, j, k, l, m;\n\t\n\tcin >> h >> w;\n\tif (h > 30 || w > 30) { return 0; }\n\t\n\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) cin >> a[i][j];\n\tfor (i = 0; i < w; i++) for (j = 0; j < h; j++) ra[i][j + 1] += ra[i][j] + a[j][i];\n\t\n\tfor (i = 0; i <= w; i++) {\n\t\tfor (j = 0; j < h; j++) {\n\t\t\tfor (k = 0; k < h; k++) {\n\t\t\t\tdp[i][j][k] = -1145141919893810;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdp[0][0][0] = 0;\n\tfor (i = 0; i < w; i++) {\n\t\tfor (j = 0; j < h; j++) {\n\t\t\tfor (k = j; k < h; k++) {\n\t\t\t\tfor (l = j; l < h; l++) {\n\t\t\t\t\tfor (m = max(l, k); m < h; m++) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cst = ra[i][l + 1] - ra[i][j] + ra[i][m + 1] - ra[i][max(l + 1, k)];\n\t\t\t\t\t\t\n\t\t\t\t\t\t//for (int y = j; y <= l; y++) cst += a[y][i];\n\t\t\t\t\t\t//for (int y = max(l + 1, k); y <= m; y++) cst += a[y][i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i + 1][l][m] = max(dp[i + 1][l][m], dp[i][j][k] + cst);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[w][h - 1][h - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tif(n<=2||m<=2){\n\t\tint out=0;\n\t\trep(i,n)rep(j,m)out+=in[i][j];\n\t\tcout<<out<<endl;\n\t\treturn 0;\n\t}\n\tvi dp(20010);\n\tdp[200]=in[0][0]+in[1][0]+in[0][1]+in[n-1][m-1];\n\tloop(i,2,n+m-2){\n\t\tvi tmp(20010);\n\t\trep(j,20010)if(dp[j]){\n\t\t\tint l=j%200,r=j/200;\n\t\t\t//l=0 r=1\n\t\t\trep(q1,2)rep(q2,2){\n\t\t\t\tint L=l+q1,R=r+q2;\n\t\t\t\tif(i-L==n||L==R||R==m)continue;\n\t\t\t\ttmp[L+200*R]=max(tmp[L+200*R],dp[j]+in[i-L][L]+in[i-R][R]);\n\t\t\t}\n\t\t}\n\t\tdp=tmp;\n\t}\n\tcout<<dp[(m-2)+(m-1)*200]<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\nint H, W;\nint A[405][405];\nll dp[405][405][405];\n//-----------------------------------------------------------------\nint main() {\n\tcin >> H >> W;\n\trep(y, 0, H) rep(x, 0, W) cin >> A[y][x];\n\n\tdp[0][0][0] = A[0][0];\n\n\tint N = max(H, W);\n\trep(i, 0, N * 2) rep(j, 0, N) rep(k, j, N) {\n\t\tint ax = j;\n\t\tint ay = i - j;\n\t\tint bx = k;\n\t\tint by = i - k;\n\t\tif (ay < 0) continue;\n\t\tif (by < 0) continue;\n\n\t\t//printf(\"dp[%d][%d][%d] = (%d, %d) and (%d, %d)\\n\", i, j, k, ax, ay, bx, by);\n\n\t\tif (ax < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j + 1][k + 1] = max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + ((ax + 1 == bx + 1 && ay == by) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by][bx + 1]));\n\n\t\tif (ax < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + ((ax + 1 == bx && ay == by + 1) ? A[ay][ax + 1] : A[ay][ax + 1] + A[by + 1][bx]));\n\n\t\tif (ay < N - 1 && bx < N - 1)\n\t\t\tdp[i + 1][j][k + 1] = max(dp[i + 1][j][k + 1], dp[i][j][k] + ((ax == bx + 1 && ay + 1 == by) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by][bx + 1]));\n\n\t\tif (ay < N - 1 && by < N - 1)\n\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k] + ((ax == bx && ay + 1 == by + 1) ? A[ay + 1][ax] : A[ay + 1][ax] + A[by + 1][bx]));\n\n\t\tif (ax == bx && ay == by) {\n\t\t\tif (ax == W - 1 && ay == H - 1) {\n\t\t\t\tcout << dp[i][j][k] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"dp[%d][%d][%d] = %lld\\n\", i, j, k, dp[i][j][k]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\nusing namespace std;\n#define rep(i,n) for (int i=0;i<(n);i++)\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\nint main() {\n\tint n, k,cnt=0,st=0;\n\tbool memo[10];\n\trep(i, 10)\n\t\tmemo[i] = false;\n\tcin >> n >> k;\n\trep(i, n) {\n\t\tst = (7 * i * 9 + 81) % 11;\n\t\tif (memo[st] == false)\n\t\t\tif (st == k || (st + 9) % 11 == k || (st + 7) % 11 == k || (st + 5) % 11 == k || (st + 3) % 11 == k) {\n\t\t\t\tcnt++;\n\t\t\t\tmemo[st] = true;\n\t\t\t}\n\t\t\telse;\n\t\telse cnt++;\n\t}\n\t\n\tcout << cnt << endl;\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate <class T> void chmax(T &x, T y) { if (x < y) x = y; }\nint A[200][200], B[200][200];\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int H, W; cin >> H >> W;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> A[i][j];\n        }\n    }\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            for (int k = j + 1; k < W; k++) {\n                B[j][k] = B[j][k] + A[i][j] + A[i][k];\n            }\n        }\n        for (int k = 0; k < W; k++) {\n            for (int j = 0; j + 1 < k; j++) {\n                chmax(B[j + 1][k], B[j][k] + A[i][j + 1]);\n            }\n        }\n        for (int j = 0; j < W; j++) {\n            for (int k = j + 1; k + 1 < W; k++) {\n                chmax(B[j][k + 1], B[j][k] + A[i][k + 1]);\n            }\n        }\n        for (int k = 0; k < W; k++) {\n            for (int j = 0; j + 1 < k; j++) {\n                chmax(B[j + 1][k], B[j][k]);\n            }\n        }\n    }\n    cout << B[W - 2][W - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst long long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<Edge>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, k, q, p, ans, sum, cnt, a[300][300], b[21],dp[40000][210];\nvector<LL>vec;\nvector<LL> tsort(vector<vector<Edge>>g) {\n\tint n = g.size();\n\tenum { YET, VISITED, DONE };\n\tvector<LL> res, flg(g.size(), YET);\n\tstatic const function<bool(int)> dfs = [&](int v) {\n\t\tflg[v] = VISITED;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (flg[w] != DONE && (flg[w] == VISITED || !dfs(w))) return false;\n\t\t}\n\t\tflg[v] = DONE;\n\t\tres.push_back(v);\n\t\treturn true;\n\t};\n\tfor (int i = 0; i < n; ++i)\n\t\tif (flg[i] == YET && !dfs(i)) return{};\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nvoid dijkstra() {\n\tLL s = 0;\n\tstruct info {\n\t\tLL p1, p2, cost;\n\t};\n\tauto comp = [](info x, info y) {return (x.cost > y.cost); };\n\tpriority_queue < info, vector<info>, decltype(comp)> pq(comp);\n\tpq.push(info{ 0,0,0 });\n\t//dp[i][j]: i>j\n\twhile (!pq.empty()) {\n\t\tinfo num = pq.top();\n\t\tpq.pop();\n\t\tLL v = num.p1, u = num.p1 + num.p2, cost = num.cost;\n\t\tif (dp[u][v] > cost)continue;\n\t\trep(i, g[v].size()) {\n\t\t\tLL nex = g[v][i].to, cos = g[v][i].cost;\n\t\t\tif (vec[nex] > vec[u]) {\n\t\t\t\tif (dp[nex][nex - u] < dp[u][u - v] + cos) {\n\t\t\t\t\tdp[nex][nex - u] = dp[u][u - v] + cos;\n\t\t\t\t\tpq.push(info{ u,nex - u,dp[nex][nex - u] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (vec[u] > vec[nex]) {\n\t\t\t\tif (dp[u][u - nex] < dp[u][u - v] + cos) {\n\t\t\t\t\tdp[u][u - nex] = dp[u][u - v] + cos;\n\t\t\t\t\tpq.push(info{ nex,u - nex,dp[u][u - nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dp[u][u - nex] < dp[u][u - v]) {\n\t\t\t\t\tdp[u][u - nex] = dp[u][u - v];\n\t\t\t\t\tpq.push(info{ u,u - nex,dp[u][u - nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\nint main() {\n\tcin >> h >> w;\n\tg.resize(h*w);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> a[i][j];\n\t\t\tLL cur = j + i * w;\n\t\t\tif (i) {\n\t\t\t\tg[j + (i - 1)*w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tg[j - 1 + i * w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tvec = tsort(g);\n\tdijkstra();\n\tcout << dp[h*w - 1][0] + a[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\n\n/* -----  2019/07/09  Problem: SQUARE869120CONTEST_03 D / Link: https://atcoder.jp/contests/s8pc-3/  ----- */\n\n// これおもしろい　フローであってるかな\n\ntypedef long long PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n\ttypedef pair< PD_Type, int > pii;\n\n\tstruct edge {\n\t\tint to, rev;\n\t\tPD_Type\tcap, cost;\n\t\tedge() {}\n\t\tedge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\n\t};\n\tvector< vector< edge > > graph;\n\tvector< int > prevv, preve;\n\tvector< PD_Type > potential, min_cost;\n\tPrimal_Dual(int V) : graph(V) {}\n\n\tvoid add_edge(int from, int to, PD_Type cap, PD_Type cost) {\n\t\tgraph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n\t}\n\n\tPD_Type min_cost_flow(int s, int t, int f) {\n\t\tint V = graph.size();\n\t\tPD_Type ret = 0;\n\t\tpriority_queue< pii, vector< pii >, greater< pii > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, PD_INF);\n\t\t\tque.push(pii(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < (int)graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tPD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == PD_INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tPD_Type addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint H, W; cin >> H >> W;\n\tvector<vector<LL>> a(H, vector<LL>(W));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tauto V = [&](int i, int j, bool OUT) {\n\t\treturn 2 * (W*i + j) + OUT;\n\t};\n\tPrimal_Dual F(2 * H*W);\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, -a[i][j]);\n\t\t\tF.add_edge(V(i, j, 0), V(i, j, 1), 1, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H - 1) {\n\t\tFOR(j, 0, W) {\n\t\t\tF.add_edge(V(i, j, 1), V(i + 1, j, 0), 2, 0);\n\t\t}\n\t}\n\tFOR(i, 0, H) {\n\t\tFOR(j, 0, W - 1) {\n\t\t\tF.add_edge(V(i, j, 1), V(i, j + 1, 0), 2, 0);\n\t\t}\n\t}\n\n\n\tLL ans = -F.min_cost_flow(V(0, 0, 0), V(H - 1, W - 1, 1), 2);\n\n\n\tcout << (ans) << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 210\nint h,w,a[N][N];\nll dp[2*N][N][N];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t    cin>>a[i][j];\n\t}\n    }\n    if(h>w){\n\tll cop[N][N];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t    cop[j][i]=a[i][j];\n\t}\n\tswap(h,w);\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t    a[i][j]=cop[i][j];\n\t}\n    }\n    if(h<=2){\n\tll ans=0;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)ans+=a[i][j];\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)for(int k=0;k<N;k++)dp[i][j][k]=0;\n    dp[1][0][1]=a[0][1]+a[1][0]+a[0][0]+a[h-1][w-1];\n    for(int i=1;i<h+w;i++){\n\tfor(int x=0;x<h;x++)for(int y=x+1;y<h;y++){\n\t    if(i-x<0||w<=i-x)continue;\n\t    if(i-y<0||w<=i-y)continue;\n\t    //cout<<i<<\" \"<<x<<\" \"<<y<<\" \"<<dp[i][x][y]<<endl;\n\t    for(int xx=x;xx<=x+1;xx++)for(int yy=y;yy<=y+1;yy++){\n\t\tif(xx==yy)continue;\n\t\tif(i+1-xx<0||w<=i+1-xx)continue;\n\t\tif(i+1-yy<0||w<=i+1-yy)continue;\n\t\tchmax(dp[i+1][xx][yy],dp[i][x][y]+a[xx][i+1-xx]+a[yy][i+1-yy]);\n\t    }\n\t}\n    }\n    cout<<dp[h+w-3][h-2][h-1]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=12100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+2;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n\nconst int H = 200;\nint a[H][H];\nll b[H][H + 1];\n\nint main(void){\n  int h, w;\n  cin >> h >> w;\n  assert (h <= 3);\n  REP(i, 0, h) {\n    REP(j, 0, w) {\n      cin >> a[i][j];\n    }\n  }\n  ll tot = 0;\n  REP(i, 0, h) {\n    b[i][0] = 0;\n    REP(j, 0, w) {\n      tot += a[i][j];\n      b[i][j + 1] = b[i][j] + a[i][j];\n    }\n  }\n  \n  if (h <= 2) {\n    cout << tot << endl;\n    return 0;\n  }\n  assert (h == 3);\n  ll ma = 0;\n  REP(i, 0, w) {\n    REP(j, i + 1, w) {\n      ll tmp = b[0][w] - b[0][j + 1];\n      tmp += b[1][j] - b[1][i + 1];\n      tmp += b[2][i] - b[2][0];\n      ma = max(ma, tot - tmp);\n    }\n  }\n  cout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 201\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE], dp[2][SIZE][SIZE];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tmemset(A, 0, sizeof(A));\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint pos = 0;\n\tmemset(dp, -1, sizeof(dp));\n\tdp[pos][0][0] = A[0][0];\n\tREP(i, H+W-1, 1) {\n\t\tpos ^= 1;\n\t\tmemset(dp[pos], -1, sizeof(dp[pos]));\n\t\tREP(j, W, 0) {\n\t\t\tREP(k, W, 0) {\n\t\t\t\tif (dp[pos^1][j][k] == -1) continue;\n\t\t\t\tdp[pos][j+1][k+1] = max(dp[pos][j+1][k+1], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j  !=k)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j+1][k  ] = max(dp[pos][j+1][k  ], dp[pos^1][j][k] + A[i-(j+1)][j+1] + ((j+1!=k)?A[i-(k  )][k  ]:0));\n\t\t\t\tdp[pos][j  ][k+1] = max(dp[pos][j  ][k+1], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j!=k+1)?A[i-(k+1)][k+1]:0));\n\t\t\t\tdp[pos][j  ][k  ] = max(dp[pos][j  ][k  ], dp[pos^1][j][k] + A[i-(j  )][j  ] + ((j  !=k)?A[i-(k  )][k  ]:0));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[pos][W-1][W-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nint h,w;\nint g[222][222];\nll dp[444][222][222];\n\nll dfs(int d,int x1,int x2){\n\tint y1=d-x1,y2=d-x2;\n\tif((x1<0||x1>=w||y1<0||y1>=h)||(x2<0||x2>=w||y2<0||y2>=h))return -INF;\n\tif(dp[d][x1][x2]!=-1)return dp[d][x1][x2];\n\tif(d==h+w-2)return g[x1][x2];\n\tll res=-INF;\n\tmaxch(res,dfs(d+1,x1,x2));\n\tmaxch(res,dfs(d+1,x1+1,x2));\n\tmaxch(res,dfs(d+1,x1,x2+1));\n\tmaxch(res,dfs(d+1,x1+1,x2+1));\n\tres+=g[y1][x1]; res+=g[y2][x2];\n\tif(x1==x2)res-=g[y1][x1];\n\treturn dp[d][x1][x2]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>h>>w;\n\trep(i,h)rep(j,w)cin>>g[i][j];\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<dfs(0,0,0)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nLL dp[201][201][402];\nLL a[201][201];\n\nint h,w;\n\n\nLL dfs(int x1,int x2,int k){\n    if(~dp[x1][x2][k]) return dp[x1][x2][k];\n    LL ret = (x1==x2?a[x1][k-x1]:a[x1][k-x1]+a[x2][k-x2]);\n    LL t = 0;\n    if(k==h+w) return ret;\n    if(x1+1<w&&x2+1<w) chmax(t, dfs(x1+1,x2+1,k+1));\n    if(x2+1<w) chmax(t, dfs(x1,x2+1,k+1));\n    if(x1+1<w) chmax(t, dfs(x1+1,x2,k+1));\n    chmax(t, dfs(x1,x2,k+1));\n    ret += t;\n    return dp[x1][x2][k] = ret;\n}\n\n\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> a[i][j];\n        }\n    }\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nusing State = pair<LL, PII>; // <score, (h, w)>\nint H, W;\nVVI a;\n\nLL dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H <= 30 && W <= 30);\n    dp[0][0][0][0] = a[0][0];\n    REP(eh, H) REP(ew, W) REP(sh, H) REP(sw, W) {\n        if (eh == 0 && ew == 0 && sh == 0 && sw == 0) continue;\n        LL buf = 0;\n        if (eh && sh) buf = max(buf, dp[eh - 1][ew][sh - 1][sw]);\n        if (eh && sw) buf = max(buf, dp[eh - 1][ew][sh][sw - 1]);\n        if (ew && sw) buf = max(buf, dp[eh][ew - 1][sh][sw - 1]);\n        if (ew && sh) buf = max(buf, dp[eh][ew - 1][sh - 1][sw]);\n        if (eh == sh && ew == sw) dp[eh][ew][sh][sw] = buf + a[sh][sw];\n        else dp[eh][ew][sh][sw] = buf + a[eh][ew] + a[sh][sw];\n    }\n    cout << dp[H - 1][W - 1][H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n)   for(int i=0;i<(n);++i)\n#define ALL(v)     (v).begin(),(v).end()\n#define debug(x)   cerr<<#x<<\": \"<<(x)<<endl\nusing namespace std;\nusing llong = long long;\nusing vi    = vector<int>;\nusing vvi   = vector<vi >;\nusing vvvi  = vector<vvi >;\nusing pii   = pair<int,int>;\nconstexpr int    INF=1e9;\nconstexpr double EPS=1e-9;\nconstexpr int    MOD=1e9+7;\ntemplate<class Type>\nvoid line(const Type &a){int cnt=0;for(const auto &elem:a){cerr<<(cnt++?' ':'>');cerr<<elem;}cerr<<endl;}\n\nusing vl    = vector<long long>;\nusing vvl   = vector<vl >;\nusing vvvl  = vector<vvl >;\n\nconst int dy[]={-1,0};\nconst int dx[]={0,-1};\n\ntemplate<class T,class U> inline bool chmax(T &a,const U &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T,class U> inline bool chmin(T &a,const U &b){if(a>b){a=b;return true;}return false;}\n\nint main(){//Refering other editorials.\n\tint h,w;\n\tcin>>h>>w;\n\t\n\tvvl a(h,vl(w));\n\tREP(i,h)REP(j,w) cin>>a[i][j];\n\t\n\tvvvl dp(h,vvl(h,vl(h+w-1,0LL)));//dp[ey][sy][ey+ex]:=(Eがeyに,Sがsyに,EとSの移動量がey+exのときのお土産個数).\n\tdp[0][0][0]=a[0][0];\n\tauto jud=[=](const int y,const int x)->bool{\n\t\treturn (0<=y and y<h and 0<=x and x<w);\n\t};\n\tREP(i,h)REP(j,h)REP(k,h+w-1){\n\t\tint ey=i, ex=k-i, sy=j, sx=k-j;\n\t\tif(jud(ey,ex) and jud(sy,sx)){\n\t\t\tREP(ii,2)REP(jj,2){\n\t\t\t\tint ney=ey+dy[ii], nex=ex+dx[ii], nsy=sy+dy[jj], nsx=sx+dx[jj];\n\t\t\t\tif(jud(ney,nex) and jud(nsy,nsx)){\n\t\t\t\t\tif(ey==sy and ex==sx) chmax(dp[i][j][k],dp[ney][nsy][k-1]+a[ey][ex]);\n\t\t\t\t\telse chmax(dp[i][j][k],dp[ney][nsy][k-1]+a[ey][ex]+a[sy][sx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<dp[h-1][h-1][h+w-2]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1e6\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MAX_V = 2*200*200 + 2;\n\nstruct edge{ int to, cap, cost, rev; };\n\nint V; \t\t\t\t// 頂点数\nvector<edge> G[MAX_V];\t\t// グラフの隣接リスト表現\nint dist[MAX_V];\t\t\t// 最短距離\nint prevv[MAX_V], preve[MAX_V]; \t// 直前の頂点と辺\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\n// s から t への流量 f の最小費用流を求める\n// 流せない場合は -1 を返す\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f > 0){\n\t\t// ベルマンフォード法により、s-t 間の最短路を求める\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\trep(v, V){\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep (i, G[v].size()){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end while\n\t\t\n\t\tif (dist[t] == INF){\n\t\t\t// これ以上流せない\n\t\t\treturn -1;\n\t\t} // end if\n\t\n\t\t// s-t 間最短路を使って目一杯流す\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t} // end for\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t} // end for\n\t} // end whle\n\n\treturn res;\n}\n\nint a[202][202];\nint in[202][202];\nint out[202][202];\n\nint main(){\n\tmemset(a, 0, sizeof(a));\n\tmemset(in, 0, sizeof(in));\n\tmemset(out, 0, sizeof(out));\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W; cin >> H >> W;\n\trep (i, H) rep (j, W) cin >> a[i][j];\n\tV = 2 * H * W + 2;\n\n\tint cnt = 0;\t\n\tfor (int i = 0; i < H; ++i){\n\t\tfor (int j = 0; j < W; ++j){\n\t\t\tin[i][j] = cnt++;\n\t\t} // end for\n\t} // end for\n\tfor (int i = 0; i < H; ++i){\n\t\tfor (int j = 0; j < W; ++j){\n\t\t\tout[i][j] = cnt++;\n\t\t} // end for\n\t} // end for\n\tint s = cnt++;\n\tint t = cnt++;\n\n\tfor (int i = 0; i < H; ++i){\n\t\tfor (int j = 0; j < W; ++j){\n\t\t\tadd_edge(in[i][j], out[i][j], 1, -a[i][j]);\n\t\t} // end for\n\t} // end for\n\n\tadd_edge(in[0][0], out[0][0], 1, 0);\n\tadd_edge(in[H-1][W-1], out[H-1][W-1], 1, 0);\n\n\tfor(int i = 0; i < H; ++i){\n\t\tfor (int j = 0; j < W; ++j){\n\t\t\tif (i + 1 < H){\n\t\t\t\tadd_edge(out[i][j], in[i+1][j], 1, 0);\n\t\t\t} // end if\n\t\t\tif (j + 1 < W){\n\t\t\t\tadd_edge(out[i][j], in[i][j+1], 1, 0);\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\tadd_edge(s, in[0][0], 2, 0);\n\tadd_edge(out[H-1][W-1], t, 2, 0);\n\n\tint res = -min_cost_flow(s, t, 2);\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint a[410][210], dp[410][210][210];\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\n\tif(H==1 || W==1){\n\t\tint sum=0;\n\t\tfor(int i=0; i<max(H, W); ++i){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tsum += b;\n\t\t}\n\t\tcout << sum << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<H; ++i){\n\t\tfor(int j=0; j<W; ++j){\n\t\t\tcin >> a[i+j][j];\n\t\t}\n\t}\n\tint ans=a[0][0]+a[H+W-2][W-1];\n\tdp[1][0][1]=a[1][0]+a[1][1];\n\tfor(int i=1; i<H+W-3; ++i){\n\t\tfor(int p=0; p<W; ++p){\n\t\t\tfor(int q=p+1; q<W; ++q){\n\t\t\t\tdp[i+1][p][q]=max(dp[i+1][p][q], dp[i][p][q]+a[i+1][p]+a[i+1][q]);\n\t\t\t\tdp[i+1][p][q+1]=max(dp[i+1][p][q+1], dp[i][p][q]+a[i+1][p]+a[i+1][q+1]);\n\t\t\t\tdp[i+1][p+1][q+1]=max(dp[i+1][p+1][q+1], dp[i][p][q]+a[i+1][p+1]+a[i+1][q+1]);\n\t\t\t\tif(p+1<q){\n\t\t\t\t\tdp[i+1][p+1][q]=max(dp[i+1][p+1][q], dp[i][p][q]+a[i+1][p+1]+a[i+1][q]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans+dp[H+W-3][W-2][W-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nint A[222][222];\n\nint dp[222][222][222];\n\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)rep(j,W)cin>>A[i][j];\n\n    for(int i=0;i<H+W-2;i++){\n        for(int j=0;j<=i&&j<W;j++){\n            for(int k=0;k<=i&&k<W;k++){\n                int x1=j,y1=i-j;\n                int x2=k,y2=i-k;\n\n                rep(b,4){\n                    int nx1=x1,ny1=y1;\n                    int nx2=x2,ny2=y2;\n\n                    if(b&1)nx1++;\n                    else ny1++;\n\n                    if(b>>1&1)nx2++;\n                    else ny2++;\n\n                    if(nx1>=W||ny1>=H||nx2>=W||ny2>=H)continue;\n                    if(nx1!=nx2||ny1!=ny2)chmax(dp[i+1][nx1][nx2],dp[i][j][k]+A[ny1][nx1]+A[ny2][nx2]);\n                    else chmax(dp[i+1][nx1][nx2],dp[i][j][k]+A[ny1][nx1]);\n                }\n            }\n        }\n    }\n\n    cout<<dp[H+W-2][W-1][W-1]+A[0][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t dp[500][210][210] = {};\nint dj[4] = {1, 1, 0, 0};\nint dk[4] = {0, 1, 0, 1};\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> a(H, vector<int>(W));\n    for(auto& c : a) for(auto & i : c){\n        cin >> i;\n    }\n\n    dp[0][0][0] = a[0][0];\n    for(int i = 0; i < H + W; ++i){\n        for(int j = 0; j <= min(i, W-1); ++j){\n            for(int k = 0; k <= min(i, W-1); ++k){\n                for(int l = 0; l < 4; ++l){\n                    int nj = j + dj[l];\n                    int nk = k + dk[l];\n                    if(nj >= W || nk >= W || (i+1-nj) >= H || (i+1-nk) >= H) continue;\n                    if(nk == nj){\n                        dp[i+1][nj][nk] = max(dp[i+1][nj][nk], dp[i][j][k] + a[nj][i-nj+1]);\n                    } else {\n                        dp[i+1][nj][nk] = max(dp[i+1][nj][nk], dp[i][j][k] + a[nj][i-nj+1] + a[nk][i-nk+1]);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[H+W-2][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n// 辺を表す構造体（行き先、容量、コスト、逆辺）\nstruct edge{ int to, cap, cost, rev; };\n\nconst int MAX_V = 2*200*200+2;\n\nint V; \t\t\t\t// 頂点数\nvector<edge> G[MAX_V];\t\t// グラフの隣接リスト表現\nint dist[MAX_V];\t\t\t// 最短距離\nint prevv[MAX_V], preve[MAX_V]; \t// 直前の頂点と辺\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\n// s から t への流量 f の最小費用流を求める\n// 流せない場合は -1 を返す\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f > 0){\n\t\t// ベルマンフォード法により、s-t 間の最短路を求める\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\trep(v, V){\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep (i, G[v].size()){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end while\n\t\t\n\t\tif (dist[t] == INF){\n\t\t\t// これ以上流せない\n\t\t\treturn -1;\n\t\t} // end if\n\t\n\t\t// s-t 間最短路を使って目一杯流す\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t} // end for\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t} // end for\n\t} // end whle\n\n\treturn res;\n}\n\nint in[200][200];\nint out[200][200];\n\nint main()\n{\n\tmemset(in, 0, sizeof(in));\n\tmemset(out, 0, sizeof(out));\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int> > a(H, vector<int> (W, 0));\n\trep (i, H) rep (j, W) cin >> a[i][j];\n\n\tV = 2 * H * W + 2;\n\tint cnt = 0;\n\trep (i, H) rep (j, W) in[i][j] = cnt++;\n\trep (i, H) rep (j, W) out[i][j] = cnt++;\n\tint S = cnt++;\n\tint T = cnt++;\n\t\n\tadd_edge(in[0][0], out[0][0], 1, 0);\n\tadd_edge(in[H-1][W-1], out[H-1][W-1], 1, 0);\n\trep (i, H){\n\t\trep (j, W){\n\t\t\tadd_edge(in[i][j], out[i][j], 1, -a[i][j]);\n\t\t} // end rep\n\t} // end rep\n \trep (i, H){\n\t\trep (j, W){\n\t\t\tif (i + 1 < H){\n\t\t\t\tadd_edge(out[i][j], in[i+1][j], 1, 0);\n\t\t\t} // end if\n\t\t\tif (j + 1 < W){\n\t\t\t\tadd_edge(out[i][j], in[i][j+1], 1, 0);\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\tadd_edge(S, in[0][0], 2, 0);\n\tadd_edge(out[H-1][W-1], T, 2, 0);\n\n\tint res = -min_cost_flow(S, T, 2);\n\tcout << res << endl; \n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nll H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-H+1);j!=min(i,W-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,W);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][W-2][W-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint p[210][210];\nint dp[410][210][210];\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tscanf(\"%d\",&p[i][j]);\n\t}\n\tdp[0][0][0]=p[0][0];\n\tfor(int i=0;i<a+b;i++){\n\t\tfor(int j=0;j<max(a,b);j++){\n\t\t\tint X1=j;\n\t\t\tint Y1=i-j;\n\t\t\tif(X1>=a||Y1<0||Y1>=b)continue;\n\t\t\tfor(int k=0;k<max(a,b);k++){\n\t\t\t\tint X2=k;\n\t\t\t\tint Y2=i-k;\n\t\t\t\tif(X2>=a||Y2<0||Y2>=b)continue;\n\n\t\t\t\tif(X1+1<a&&X2+1<a){\n\t\t\t\t\tint to=dp[i][j][k]+p[X1+1][Y1];\n\t\t\t\t\tif(X1!=X2)to+=p[X2+1][Y2];\n\t\t\t\t\tdp[i+1][X1+1][X2+1]=max(dp[i+1][X1+1][X2+1],to);\n\t\t\t\t}\n\t\t\t\tif(X1+1<a&&Y2+1<b){\n\t\t\t\t\tint to=dp[i][j][k]+p[X1+1][Y1];\n\t\t\t\t\tif(X1+1!=X2)to+=p[X2][Y2+1];\n\t\t\t\t\tdp[i+1][X1+1][X2]=max(dp[i+1][X1+1][X2],to);\n\t\t\t\t}\n\t\t\t\tif(Y1+1<b&&X2+1<a){\n\t\t\t\t\tint to=dp[i][j][k]+p[X1][Y1+1];\n\t\t\t\t\tif(X1!=X2+1)to+=p[X2+1][Y2];\n\t\t\t\t\tdp[i+1][X1][X2+1]=max(dp[i+1][X1][X2+1],to);\n\t\t\t\t}\n\t\t\t\tif(Y1+1<b&&Y2+1<b){\n\t\t\t\t\tint to=dp[i][j][k]+p[X1][Y1+1];\n\t\t\t\t\tif(X1!=X2)to+=p[X2][Y2+1];\n\t\t\t\t\tdp[i+1][X1][X2]=max(dp[i+1][X1][X2],to);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[a+b-2][a-1][a-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\nint dp[55][55][55][55];\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tdp[i][j][k][l] = - INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tdp[0][0][0][0] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[H-1][W-1][H-1][W-1] + a[H-1][W-1] << endl;\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define rep(n) for (int i = 0; i < n; ++i)\n#define REP(n,i) for (int i = 0; i < n; ++i)\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint h, w, a[200][200], dp[200][200][400] = {};\nint main() {\n\tcin >> h >> w;\n\trep(h)\n\t\tREP(w, j)\n\t\t\tcin >> a[i][j];\n\tfor (int i = 1; i != w + h - 2; ++i) {\n\t\tfor (int j = max(0, i - h + 1); j != min(w, i + 1); ++j) {\n\t\t\tfor (int k = j + 1; k != min(w, i + 1); ++k) {\n\t\t\t\tdp[j][k][i] = a[i - j][j] + a[i - k][k];\n\t\t\t\tif (j)\n\t\t\t\t\tdp[j][k][i] += max({ dp[j - 1][k - 1][i - 1],dp[j - 1][k][i - 1],dp[j][k - 1][i - 1],dp[j][k][i - 1] });\n\t\t\t\telse\n\t\t\t\t\tdp[j][k][i] += max(dp[j][k - 1][i - 1], dp[j][k][i - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << a[0][0] + a[h - 1][w - 1] + dp[w - 2][w - 1][w + h - 3] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <fstream>\n#include <string>\n#include <math.h>\n#include <set>\n#include <string>\n#include <bitset>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n//typedef pair<ll, P> T;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define revrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define f first\n#define s second\n#define pb push_back\n\nll mod = 1000000007;\nconst ll INF = 100000000000010000;\n//const ull B = 998244353;\n\n//ll bit[200010];\n//ll kai[3010];\n//ll Cnt[10010];\n\n//void pres(double A, ll x = 20) { printf(\"%.20f\\n\", x); }\n\nvector<ll> dx = { 0, 1, 0, -1, 1, -1, 1, -1, 0};\nvector<ll> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0};\n\nvoid chmin(ll& x, ll y) {\n\tx = min(x, y);\n}\n\nvoid chmax(ll& x, ll y) {\n\tx = max(x, y);\n}\n\n\n/*ll sum(ll i)\n{\n\ti += 1;\n\tll t = 0;\n\twhile (i > 0)\n\t{\n\t\tt += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn t;\n}\n\nvoid add(ll i, ll x)\n{\n\ti += 1;\n\twhile (i <= 200005)\n\t{\n\t\tbit[i] += x;\n\t\ti += i & -i;\n\t}\n}*/\n\n/*`ll SAIKI(ll S) {\n\tfor (ll T = S; ; T = (T - 1) & S) {\n\n\t}\n}*/\n\n\n\nvoid test() {\n\tcout << \"888888888888888888888888\" << endl;\n}\n\nll gcd(ll x, ll y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\n\nll pow_mod(ll x, ll k) {\n\tx %= mod;\n\tll res = 1;\n\twhile (k > 0) {\n\t\tif (k % 2) {\n\t\t\tres *= x; res %= mod;\n\t\t}\n\t\tx *= x; x %= mod;\n\t\tk /= 2;\n\t}\n\treturn res;\n}\n\nll div_mod(ll x) {\n\treturn pow_mod(x, mod - 2);\n}\n\n\nvector <ll> par; // 各元の親を表す配列\nvector <ll> siz; // 素集合のサイズを表す配列(1 で初期化)\n\nvoid init_u(ll sz_) {\n\tpar.resize(sz_);\n\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n}\n\n// Member Function\n// Find\nll root(ll x) { // 根の検索\n\twhile (par[x] != x) {\n\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t}\n\treturn x;\n}\n\n// Union(Unite, Merge)\nbool merge(ll x, ll y) {\n\tx = root(x);\n\ty = root(y);\n\tif (x == y) return false;\n\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\tif (siz[x] < siz[y]) swap(x, y);\n\tsiz[x] += siz[y];\n\tpar[y] = x;\n\treturn true;\n}\n\nbool issame(ll x, ll y) { // 連結判定\n\treturn root(x) == root(y);\n}\n\nll size(ll x) { // 素集合のサイズ\n\treturn siz[root(x)];\n}\n\n\n//コンビネーション\nconst int MAXcomb = 1000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAXcomb; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[k] % mod * finv[n - k] % mod;\n}\n\n\n/*map<ll, ll> pres;\nll ct;\n\nvoid makePrimeList(ll x) {\n\tll X = x;\n\tfor (ll j = 2; j * j <= x; j++) {\n\t\tll cnt = 0;\n\t\twhile (X % j == 0) {\n\t\t\tcnt++;\n\t\t\tX /= j;\n\t\t}\n\t\tif (cnt) {\n\t\t\tif (pres[j] == 0) {\n\t\t\t\tct++;\n\t\t\t\tpres[j] = ct;\n\t\t\t}\n\t\t\tCnt[pres[j]] += cnt;\n\t\t}\n\t}\n\tif (X != 1) {\n\t\tif (pres[X] == 0) {\n\t\t\tct++;\n\t\t\tpres[X] = ct;\n\t\t}\n\t\tCnt[pres[X]] += 1;\n\t}\n}*/\n\nll H, W;\nll a[201][201];\nll dp[401][201][201];\n\nbool out(ll x, ll y) {\n\treturn (x < 0 || x >= H || y < 0 || y >= W);\n}\n\nvoid solve() {\n\tcin >> H >> W;\n\trep(i, H) rep(j, W) cin >> a[i][j];\n\tdp[0][0][0] = a[0][0];\n\trep(i, H + W - 1) rep(sx, H) rep(tx, H) {\n\t\tll sy = i - sx, ty = i - tx;\n\t\tif (out(sx, sy)) continue;\n\t\tif (out(tx, ty)) continue;\n\t\trep(j, 2) rep(k, 2) {\n\t\t\tll nsx = sx + dx[j], nsy = sy + dy[j], ntx = tx + dx[k], nty = ty + dy[k];\n\t\t\tif (out(nsx, nsy)) continue;\n\t\t\tif (out(ntx, nty)) continue;\n\t\t\tll add = a[nsx][nsy] + a[ntx][nty];\n\t\t\tif (nsx == ntx) add = a[nsx][nsy];\n\t\t\tchmax(dp[i + 1][nsx][ntx], dp[i][sx][tx] + add);\n\t\t\t//dp[i + 1][nsx][ntx] = max(dp[i + 1][nsx][ntx], dp[i][sx][tx] + add);\n\t\t}\n\t}\n\tcout << dp[H + W - 2][H - 1][H - 1] << endl;\n}\n\nint main() {\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll T = 1;\n\t//cin >> T;\n\trep(i, T) solve();\n\tll N;\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int H,W; cin >> H >> W ;\n  vvl a(H,vl(W));\n  rep(i,H) rep(j,W) cin >> a[i][j] ;\n  int N = H + W;\n  vector<vvl> dp(N-1,vvl(H,vl(H,-1)));\n  dp[0][0][0] = a[0][0];\n  rep(i,N-1) rep(x1,H) rep(x2,H){\n    if(dp[i][x1][x2]==-1) continue;\n    rep(s,2) rep(t,2){\n      int nx1,ny1,nx2,ny2;\n      nx1 = x1+s;\n      ny1 = i+1-nx1;\n      nx2 = x2+t;\n      ny2 = i+1-nx2;\n      if(!(nx1<H && ny1<W && nx2<H && ny2<W)) continue;\n      if(nx1==nx2 && ny1==ny2) chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][nx2]);\n      else chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][ny1]+a[nx2][ny2]);\n    }\n  }\n  cout << dp[N-2][H-1][H-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <deque>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define It iterator\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n \n \n#define maxn 222\nint m,n,a[maxn][maxn];\nint f[maxn*2][maxn][maxn];\nint main() {\n    //freopen(\"test.in\",\"r\",stdin);\n    cin>>m>>n;\n    for(int i=1; i<=m; i++) {\n        for(int j=1; j<=n; j++) cin>>a[i][j];\n    }\n    for(int k=1; k<=m+n; k++) {\n        for(int i=1; i<=k-1; i++) {\n            for(int j=1; j<=k-1; j++) {\n                int s1=0,s2=0;\n                    if(i!=j) {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i]+a[j][k-j];\n                    } else {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i];\n                    }\n            }\n        }\n    }\n    cout<<f[m+n][m][m]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint H, W, a[212][212];\nint ans = 0;\n\nint main(void) {\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; ++i) { for (int j = 0; j < W; ++j) { scanf(\"%d\", &a[i][j]); } }\n\n\t// 小課題２\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\tif (3 == H) {\n\t\tfor (int i = 0; i <= W - 3; ++i) {\n\t\t\tans -= std::min(a[i][2], std::min(a[i + 1][1], a[i + 2][0]));\n\t\t}\n\t}\n\n\t// 小課題１\n\t/*for (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tans += a[i][j];\n\t\t}\n\t}*/\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nint A[222][222];\nint dp[222][222][444];\nint solve(int x1,int x2,int t){\n    int y1=t-x1;\n    int y2=t-x2;\n    int &ret=dp[x1][x2][t];\n    if(ret!=-1)return ret;\n    ret=0;\n    if(t==H+W-2)return A[H-1][W-1];\n    rep(i,2)rep(j,2){\n        x1+=i;y1+=1-i;x2+=j;y2+=1-j;\n        if(x1==W||x1==W||y1==H||y2==H||(x1==x2&&y1==y2));\n        else{\n            chmax(ret,solve(x1,x2,t+1));\n        }\n        x1-=i;y1-=1-i;x2-=j;y2-=1-j;\n    }\n    if(t==0)ret+=A[0][0];\n    else ret+=A[y1][x1]+A[y2][x2];\n    return ret;\n}\n\nsigned main(){\n    cin>>H>>W;\n    rep(i,H)rep(j,W)cin>>A[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout<<solve(0,0,0)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\ntypedef long long LL;\n\nint H , W;\nint a[222][222];\nLL dp[444][222][222];\n\nint main(){\n\tscanf(\"%d%d\" , &H , &W);\n\trepp(i,1,H+1){\n\t\trepp(j,1,W+1){\n\t\t\tscanf(\"%d\" , &a[i][j]);\n\t\t}\n\t}\n\tint n = H + W + 1;\n\tdp[2][1][1] = a[1][1];\n\trepp(i,3,n){\n\t\tint x = max(1,i-W);\n\t\tint y = min(i,H+1);\n\t\trepp(j,x,y){\n\t\t\trepp(k,x,y){\n\t\t\t\tdp[i][j][k] = max(max(dp[i-1][j-1][k] , dp[i-1][j][k]) , max(dp[i-1][j-1][k-1] , dp[i-1][j][k-1])) + a[j][i-j] + (j != k ? a[k][i-k] : 0);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[H+W][H][H]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-W+1);j!=min(i,H-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,H);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[j][i-j]+a[k][i-k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][H-2][H-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,v,u,x,y,t,p,j;\nll a[205][205],f[405][205][205];\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n+m-1;i++)\n\t{\n\t\tfor(x=1;x<=n;x++)\n\t\t{\n\t\t\tfor(y=1;y<=n;y++)\n\t\t\t{\n\t\t\t\tv=i-x+1,u=i-y+1;\n\t\t\t\tif(v<=0 || u<=0)continue;\n\t\t\t\t//cout<<x<<\" \"<<v<<\" \"<<y<<\" \"<<u<<endl;\n\t\t\t\tfor(t=-1;t<1;t++)\n\t\t\t\t{\n\t\t\t\t\tfor(p=-1;p<1;p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i][x][y]=max(f[i][x][y],f[i-1][x+t][y+p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i][x][y]+=a[x][v]+a[y][u];\n\t\t\t\tif(x==y && v==u)f[i][x][y]-=a[x][v];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n+m-1][n][n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <string.h>\n# include <stdlib.h>\n# include <iostream>\n# include <vector>\n# include <queue>\n# include <stack>\n# include <map>\n# include <math.h>\n# include <algorithm>\nusing namespace std;\n# define lowbit(x) ((x)&(-x))\n# define pi acos(-1.0)\n# define MAXN 50005\n# define eps 1e-6\n# define MAXM 5000005\n# define MOD 1000000007\n# define INF 1000000000\n# define MIN(a,b) (a)>(b)?(b):(a)\n# define MAX(a,b) (a)<(b)?(b):(a)\n# define mem(a,b) memset(a,b,sizeof(a))\n# define FOR(i,a,n) for(int i=a; i<=n; ++i)\n# define FO(i,a,n) for(int i=a; i<n; ++i)\n# define bug puts(\"H\");\ntypedef long long LL;\ntypedef unsigned long long ULL;\nint _MAX(int a, int b){return a>b?a:b;}\nint _MIN(int a, int b){return a>b?b:a;}\n\nstruct Edge{int p, next, w, v;}edge[MAXM];\nint head[MAXN], dis[MAXN], vis[MAXN], pre[MAXN], pos[MAXN], cnt, s, t;\n\ninline void init(){memset(head,0,sizeof(head)); cnt=2;}\ninline void add_edge(int u, int v, int w, int val)\n{\n    edge[cnt].p=v; edge[cnt].w=w; edge[cnt].v=val; edge[cnt].next=head[u]; head[u]=cnt++;\n\tedge[cnt].p=u; edge[cnt].w=0; edge[cnt].v=-val; edge[cnt].next=head[v]; head[v]=cnt++;\n}\nbool spfa()\n{\n\tint v, i;\n\tfor (i=s; i<=t; ++i) dis[i]=INF, pre[i]=-1, vis[i]=0;\n\tdis[s]=0; vis[s]=1; pre[s]=s;\n\tqueue<int>Q; Q.push(s);\n\twhile (!Q.empty()) {\n\t\tv=Q.front(); Q.pop(); vis[v]=0;\n\t\tfor (i=head[v]; i; i=edge[i].next)\n\t\t\tif (edge[i].w>0 && dis[v]+edge[i].v<dis[edge[i].p]) {\n\t\t\t\tdis[edge[i].p]=dis[v]+edge[i].v; pre[edge[i].p]=v; pos[edge[i].p]=i;\n\t\t\t\tif (vis[edge[i].p]==0) vis[edge[i].p]=1, Q.push(edge[i].p);\n\t\t\t}\n\t}\n\treturn pre[t]!=-1&&dis[t]<INF;\n}\nint costflow()\n{\n\tint cf=0, nf=0, min, i;\n\twhile (spfa()) {\n\t\tmin = INF;\n\t\tfor (i=t; i!=s; i=pre[i]) min=MIN(min,edge[pos[i]].w);\n\t\tnf+=min; cf+=min*dis[t];\n\t\tfor (i=t; i!=s; i=pre[i]) edge[pos[i]].w-=min, edge[pos[i]^1].w+=min;\n\t}\n\treturn cf;\n}\nint main (void)\n{\n\tint x, i, j, sum, n, m;\n    scanf(\"%d%d\",&n,&m);\n    init(); sum=0;\n    for (i=0; i<n; ++i) for (j=0; j<m; ++j) {\n        scanf(\"%d\",&x);\n        if ((i==0&&j==0)||(i==n-1&&j==m-1)) sum+=x;\n        add_edge(i*m+j,i*m+j+n*m,(i==0&&j==0)||(i==n-1&&j==m-1)?2:1,-x);\n        if (i+1<n) add_edge(i*m+j+n*m,(i+1)*m+j,1,0);\n        if (j+1<m) add_edge(i*m+j+n*m,i*m+j+1,1,0);\n    }\n    s=0; t=2*n*m-1;\n    printf(\"%d\\n\",-costflow()-sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint H, W;\nVVI a;\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H == 2 || H == 3);\n    if (H == 2) {\n        LL ans = 0;\n        REP(i, H)REP(j, W) ans += a[i][j];\n        cout << ans << endl;\n    } else {\n        LL ans = 0;\n        LL fst = accumulate(ALL(a[0]), 0), snd = accumulate(ALL(a[1]), 0), thd = accumulate(ALL(a[2]), 0);\n        ans = fst + snd + thd;\n        fst -= a[0].front();\n        snd = snd - a[1].front() - a[1].back();\n        thd -= a[2].back();\n        //cout << fst << \" \" << snd << \" \" << thd << endl;\n        cout << ans - min({fst, snd, thd}) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\nll h, w, grid[200][200], dp[500][200][200];\nll p[] = {1, 0, 0, 1, 1, 1, 0, 0};\nint main() {\n  cin >> h >> w;\n  REP(i, h) {\n    REP(j, w) { cin >> grid[i][j]; }\n  }\n  REP(i, h + w - 2) {\n    REP(X, min(w, i + 1)) {\n      REP(x, min(w, i + 1)) {\n        if (h <= i - X || h <= i - x)\n          continue;\n        ll y = i - x, Y = i - X, cost = grid[Y][X] + grid[y][x];\n        // cost -= (X == x && grid[y][x]);\n        cost -= (X == x ? grid[y][x] : 0);\n        REP(k, 4) {\n          dp[i + 1][X + p[k * 2]][x + p[k * 2 + 1]] = max(\n              dp[i + 1][X + p[k * 2]][x + p[k * 2 + 1]], cost + dp[i][X][x]);\n        }\n      }\n    }\n  }\n  cout << dp[h + w - 2][w - 1][w - 1] + grid[h - 1][w - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nll h, w; \nbool can(pair<ll, ll> po){return (0 <= po.first && po.first < h && 0 <= po.second && po.second < w ? true : false);}\nint main(){\n\tcin >> h >> w;\n\tll a[h][w], dp[h][h];\n\tfor(ll i = 0; i < h; i++)for(ll j = 0; j < w; j++)cin >> a[i][j];\n\tfor(ll i = 0; i < h; i++)for(ll j = 0; j < h; j++)dp[i][j] = 0;\n\tdp[0][0] = a[0][0];\n\tfor(ll count = 0; count < h + w - 2; count++){\n\t\tll nextdp[h][h];\n\t\tfor(ll i = 0; i < h; i++)for(ll j = 0; j < h; j++)nextdp[i][j] = 0;\n\t\tfor(ll i = 0; i < h; i++){\n\t\t\tfor(ll j = 0; j < h; j++){\n\t\t\t\tauto po = pair<ll, ll>(i, count - i), yo = pair<ll, ll>(j, count - j);\n\t\t\t\tif(!can(po) || !can(yo)) continue;\n\t\t\t\tll dh[] = {1, 0}, dw[] = {0, 1};\n\t\t\t\tfor(ll p = 0; p < 2; p++){\n\t\t\t\t\tfor(ll y = 0; y < 2; y++){\n\t\t\t\t\t\tauto nextpo = po, nextyo = yo;\n\t\t\t\t\t\tnextpo.first += dh[p];\n\t\t\t\t\t\tnextpo.second += dw[p];\n\t\t\t\t\t\tnextyo.first += dh[y];\n\t\t\t\t\t\tnextyo.second += dw[y];\n\t\t\t\t\t\tif(!can(nextpo) || !can(nextyo)) continue;\n\t\t\t\t\t\tnextdp[nextpo.first][nextyo.first] = max(nextdp[nextpo.first][nextyo.first], dp[po.first][yo.first] + a[nextpo.first][nextpo.second] + a[nextyo.first][nextyo.second] - (nextpo == nextyo ? a[nextpo.first][nextpo.second] : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(ll i = 0; i < h; i++)for(ll j = 0; j < h; j++)dp[i][j] = nextdp[i][j];\n\t}\n\tcout << dp[h - 1][h - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst long long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<Edge>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, k, q, p, ans, sum, cnt, a[300][300], b[210000],dp[300][300];\nvector<LL>vec;\nvector<LL> tsort(vector<vector<Edge>>g) {\n\tint n = g.size();\n\tenum { YET, VISITED, DONE };\n\tvector<LL> res, flg(g.size(), YET);\n\tstatic const function<bool(int)> dfs = [&](int v) {\n\t\tflg[v] = VISITED;\n\t\tfor (auto &e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (flg[w] != DONE && (flg[w] == VISITED || !dfs(w))) return false;\n\t\t}\n\t\tflg[v] = DONE;\n\t\tres.push_back(v);\n\t\treturn true;\n\t};\n\tfor (int i = 0; i < n; ++i)\n\t\tif (flg[i] == YET && !dfs(i)) return{};\n\treverse(res.begin(), res.end());\n\treturn res;\n}\nvoid dijkstra() {\n\tLL s = 0;\n\tstruct info {\n\t\tLL p1, p2, cost;\n\t};\n\tauto comp = [](info x, info y) {return (x.cost>y.cost); };\n\tpriority_queue < info, vector<info>, decltype(comp)> pq(comp);\n\tpq.push(info{ 0,0,0 });\n\t//dp[i][j]: i>j\n\twhile (!pq.empty()) {\n\t\tinfo num = pq.top();\n\t\tpq.pop();\n\t\tLL v = num.p1, u = num.p2, cost = num.cost;\n\t\tif (dp[u][v] > cost)continue;\n\t\trep(i, g[v].size()) {\n\t\t\tLL nex = g[v][i].to, cos = g[v][i].cost;\n\t\t\tif (vec[nex] > vec[u]) {\n\t\t\t\tif (dp[nex][u] < dp[u][v] + cos) {\n\t\t\t\t\tdp[nex][u] = dp[u][v] + cos;\n\t\t\t\t\tpq.push(info{ u,nex,dp[nex][u] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (vec[u] > vec[nex]) {\n\t\t\t\tif (dp[u][nex] < dp[u][v] + cos) {\n\t\t\t\t\tdp[u][nex] = dp[u][v] + cos;\n\t\t\t\t\tpq.push(info{ nex,u,dp[u][nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dp[u][nex] < dp[u][v]) {\n\t\t\t\t\tdp[u][nex] = dp[u][v];\n\t\t\t\t\tpq.push(info{ u,nex,dp[u][nex] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\nint main() {\n\tcin >> h >> w;\n\tg.resize(h*w);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> a[i][j];\n\t\t\tLL cur = j + i * w;\n\t\t\tif (i) {\n\t\t\t\tg[j + (i - 1)*w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tg[j - 1 + i * w].push_back(Edge{ cur,a[i][j] });\n\t\t\t}\n\t\t}\n\t}\n\tvec = tsort(g);\n\tdijkstra();\n\tcout << dp[h*w - 1][h*w - 1] + a[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,j,x,y,t,p,dx[]={-1,0},dy[]={0,-1};\nll a[35][35],f[35][35][35][35];\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tfor(x=1;x<=n;x++)\n\t\t\t{\n\t\t\t\tfor(y=1;y<=m;y++)\n\t\t\t\t{\n\t\t\t\t\tif(x+y!=i+j)continue;\n\t\t\t\t\tfor(t=0;t<2;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(p=0;p<2;p++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[i][j][x][y]=max(f[i][j][x][y],f[i+dx[t]][j+dy[t]][x+dx[p]][y+dy[p]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j][x][y]+=a[i][j]+a[x][y];\n\t\t\t\t\tif(i==x && j==y)f[i][j][x][y]-=a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][m][n][m]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long dp[205][205][205][205];\nlong long H, W;\nlong long a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tdp[i][j][k][l] = - INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tdp[0][0][0][0] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\tif(i == k && j == l){\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k+1][l] = max(dp[i+1][j][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i+1][j][k][l+1] = max(dp[i+1][j][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k+1][l] = max(dp[i][j+1][k+1][l], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\t\tdp[i][j+1][k][l+1] = max(dp[i][j+1][k][l+1], dp[i][j][k][l] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tcout << dp[H-1][W-1][H-1][W-1] + a[H-1][W-1] << endl;\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst ll INF=1e13;\nll a[222][222];\nll dp[222][222][222];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m;\n  cin>>n>>m;\n  rep(i,n)rep(j,m) cin>>a[i][j];\n  fill(dp[0][0],dp[0][0]+222*222*222,-INF);\n  dp[0][0][0]=0;\n  rep(i,n+m)rep(j,m)rep(k,j+1){\n    if(i-j>=0){\n      dp[i][j][k]+=a[i-j][j];\n      if(j!=k) dp[i][j][k]+=a[i-k][k];\n    }\n    rep(a,2)rep(b,2) MX(dp[i+1][j+a][k+b],dp[i][j][k]);\n  }\n  cout<<dp[n+m-2][m-1][m-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tint h,w,a[200][200]; scanf(\"%d%d\",&h,&w);\n\trep(i,h) rep(j,w) scanf(\"%d\",&a[i][j]);\n\n\tstatic int dp[201][200][200];\n\trep(i,h+1) rep(j1,w) rep(j2,w) dp[i][j1][j2]=-INF;\n\tdp[0][0][0]=0;\n\trep(i,h){\n\t\t// 1 行下に降りる\n\t\trep(j1,w) for(int j2=j1;j2<w;j2++) if(dp[i][j1][j2]!=-INF) {\n\t\t\tint val;\n\t\t\tif(j1<j2) val=a[i][j1]+a[i][j2];\n\t\t\telse      val=a[i][j1];\n\t\t\tdp[i+1][j1][j2]=dp[i][j1][j2]+val;\n\t\t}\n\n\t\t// 左の人を動かす\n\t\trep(j2,w){\n\t\t\trep(j1,j2-1) if(dp[i+1][j1][j2]!=-INF) {\n\t\t\t\tdp[i+1][j1+1][j2]=max(dp[i+1][j1+1][j2],dp[i+1][j1][j2]+a[i][j1+1]);\n\t\t\t}\n\t\t}\n\n\t\t// 右の人を動かす\n\t\trep(j1,w){\n\t\t\tfor(int j2=j1;j2<w-1;j2++) if(dp[i+1][j1][j2]!=-INF) {\n\t\t\t\tdp[i+1][j1][j2+1]=max(dp[i+1][j1][j2+1],dp[i+1][j1][j2]+a[i][j2+1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=-INF;\n\trep(j1,w) ans=max(ans,dp[h][j1][w-1]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nint H, W, a[212][212];\nLL ans;\n\nint main()\n{\n\tin >> H >> W;\n\trep(i, H) { rep(j, W) { in >> a[i][j]; } }\n\n\trep(i, H)\n\t{\n\t\trep(j, W)\n\t\t{\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\tif (H == 3)\n\t{\n\t\tfor (int k = 1; k < W - 1; ++k)\n\t\t{\n\t\t\tans -= std::min(a[k][0], std::min(a[k][1], a[k][2]));\n\t\t}\n\t}\n\tout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i, x, n) for(int i = x; i >= n; i--)\n#define rrep(i, n) RREP(i,n,0)\n#define pb push_back\n#pragma GCC optimize (\"-O3\")\n\nusing namespace std;\n\n// #define DEBUG_IS_VALID\n\n#ifdef DEBUG_IS_VALID\n#define DEB 1 \n#else\n#define DEB 0\n#endif\n#define DUMPOUT cout\n#define dump(...) if(DEB) DUMPOUT<<\"  \"<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl<<\"    \"; if(DEB) dump_func(__VA_ARGS__)\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, pair<T1,T2> p){cout << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate<typename T>ostream& operator << (ostream& os, vector<T>& vec) { os << \"{\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"}\"; return os; }\ntemplate<typename T>ostream& operator << (ostream& os, set<T>& st){for(auto itr = st.begin(); itr != st.end(); itr++) cout << *itr << (next(itr)!=st.end() ? \", \" : \"\"); cout << \"}\"; return os;}\ntemplate<typename T1,typename T2>ostream& operator << (ostream& os, map<T1,T2> mp){cout << \"{\"; for(auto itr = mp.begin(); itr != mp.end(); itr++) cout << \"(\" << (itr->first) << \", \" << (itr->second) << \")\" << (next(itr)!=mp.end() ? \",\" : \"\"); cout << \"}\"; return os; }\n\nvoid dump_func(){DUMPOUT << endl;}\ntemplate <class Head, class... Tail>void dump_func(Head&& head, Tail&&... tail){ DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...);}\ntemplate<class T> inline bool chmax(T& a,T const& b){if(a>=b) return false; a=b; return true;}\ntemplate<class T> inline bool chmin(T& a,T const& b){if(a<=b) return false; a=b; return true;}\n\nusing ll = long long;\nusing P = pair<int,int>;\nusing Pl = pair<ll,ll>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nconst int mod=1e9+7,INF=1<<29;\nconst double EPS=1e-12,PI=3.1415926535897932384626;\nconst ll lmod = 1e9+7,LINF=1LL<<59; \n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int H,W; cin >> H >> W ;\n  vvl a(H,vl(W));\n  rep(i,H) rep(j,W) cin >> a[i][j] ;\n  int N = H + W;\n  vector<vvl> dp(N-1,vvl(H,vl(H,-1)));\n  dp[0][0][0] = a[0][0];\n  rep(i,N-2) rep(x1,H) rep(x2,H){\n    if(dp[i][x1][x2]==-1) continue;\n    rep(s,2) rep(t,2){\n      int nx1,ny1,nx2,ny2;\n      nx1 = x1+s;\n      ny1 = i+1-nx1;\n      nx2 = x2+t;\n      ny2 = i+1-nx2;\n      if(!(nx1<H && ny1<W && nx2<H && ny2<W)) continue;\n      if(nx1==nx2 && ny1==ny2) chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][nx2]);\n      else chmax(dp[i+1][nx1][nx2],dp[i][x1][x2]+a[nx1][ny1]+a[nx2][ny2]);\n    }\n  }\n  cout << dp[N-2][H-1][H-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 205\nusing namespace std;\n\nint main(){\n\n  int h,w;\n  int a[N][N];\n  \n  cin>>h>>w;\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)      \n      cin>>a[i][j];\n\n  assert(h<=2);\n\n  long long sum=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      sum+=a[i][j];\n\n  cout<<sum<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\n\nstruct Primal_Dual\n{\n  const int INF = 1 << 30;\n  typedef pair< int64, int > Pi;\n\n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int64 > potential, min_cost, prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  int64 min_cost_flow(int s, int t, int f)\n  {\n    int64 V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int64 nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return (114514);\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nint main()\n{\n  int H, W, A[200][200];\n\n  cin >> H >> W;\n  Primal_Dual flow(H * W * 2);\n\n  auto cell = [&](int i, int j, bool in)\n  {\n    if(in) return (H * W + i * W + j);\n    return (i * W + j);\n  };\n\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      cin >> A[i][j];\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, -A[i][j]);\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, 0);\n      if(i > 0) flow.add_edge(cell(i - 1, j, true), cell(i, j, false), 2, 0);\n      if(j > 0) flow.add_edge(cell(i, j - 1, true), cell(i, j, false), 2, 0);\n    }\n  }\n  cout << -flow.min_cost_flow(cell(0, 0, false), cell(H - 1, W - 1, true), 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <memory.h>\nusing namespace std;\n#define MAX 210\nint h, w, t, ans1, ans2;\nint omap[MAX][MAX];\nint flag[MAX][MAX];\nint tflag[MAX][MAX];\n\nvoid tdfs(int x, int y, int tt, int tans){\n    if(x>h||y>w)return;\n    if(tt>t)return;\n    if(x==h&&y==w){\n        if(tans>ans2){\n            ans2=tans;\n//            for(int i=1;i<=h;i++){\n//                for(int j=1;j<=w;j++){\n//                    cout<<tflag[i][j]<<\" \";\n//                }\n//                cout<<endl;\n//            }\n//            for(int i=1;i<=h;i++){\n//                for(int j=1;j<=w;j++){\n//                    cout<<flag[i][j]<<\" \";\n//                }\n//                cout<<endl;\n//            }\n//            cout<<endl;\n        }\n    }\n    int add;\n    tflag[x+1][y]=1;\n    if(flag[x+1][y])add=0;\n    else add=omap[x+1][y];\n    tdfs(x+1,y, tt+1, tans+add);\n    tflag[x+1][y]=0;\n    tflag[x][y+1]=1;\n    if(flag[x][y+1])add=0;\n    else add=omap[x][y+1];\n    tdfs(x,y+1, tt+1, tans+add);\n    tflag[x][y+1]=0;\n}\n\nvoid dfs(int x, int y, int tt, int tans){\n    if(x>h||y>w)return;\n    if(tt>t)return;\n    if(x==h&&y==w){\n        if(tans>ans1){\n            ans1=tans;\n            memset(tflag, 0, sizeof(tflag));\n            tflag[1][1]=1;\n            tdfs(1, 1, 0, 0);\n        }\n    }\n    flag[x+1][y]=1;\n    dfs(x+1,y, tt+1, tans+omap[x+1][y]);\n    flag[x+1][y]=0;\n    flag[x][y+1]=1;\n    dfs(x,y+1, tt+1, tans+omap[x][y+1]);\n    flag[x][y+1]=0;\n}\n\nint main()\n{\n    while(~scanf(\"%d %d\", &h, &w)){\n        ans1=0;\n        ans2=0;\n        memset(flag, 0, sizeof(flag));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                scanf(\"%d\", &omap[i][j]);\n            }\n        }\n        t=h+w-2;\n        flag[1][1]=1;\n        dfs(1, 1, 0, omap[1][1]);\n        printf(\"%d\\n\", ans1+ans2);\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<map>\nusing namespace std;\n\nunordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, int>>>>dp;\nint a, b;\nint c[200][200];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f][g] != 0)return dp[d][e][f][g];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y)-1;\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f][g] = max(dp[d][e][f][g], S+1);\n\t\t}\n\t}\n\treturn dp[d][e][f][g];\n}\nsigned main() {\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0][0] = c[0][0]+1;\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1)-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\nconst int N=30;\n\nint h,w;\nint a[N][N];\nint dp[N][N][N][N];\n\nint dx1[]={1,0,1,0},dy1[]={0,1,0,1};\nint dx2[]={1,1,0,0},dy2[]={0,0,1,1};\n\nint dfs(int X1,int Y1,int X2,int Y2) {\n\tif(dp[X1][Y1][X2][Y2]!=-1) return dp[X1][Y1][X2][Y2];\n\tint res=0;\n\tres+=a[Y1][X1];\n\tif(X1!=X2||Y1!=Y2) res+=a[Y2][X2];\n\tint ma=0;\n\tREP(i,4) {\n\t\tint nx1=X1+dx1[i],ny1=Y1+dy1[i];\n\t\tint nx2=X2+dx2[i],ny2=Y2+dy2[i];\n\t\tif(nx1<0||nx1>=w||ny1<0||ny1>=h||nx2<0||nx2>=w||ny2<0||ny2>=h) continue;\n\t\tma=max(ma,dfs(nx1,ny1,nx2,ny2));\n\t}\n\t//cout<<'('<<X1<<','<<Y1<<','<<X2<<','<<Y2<<')'<<' '<<res<<' '<<ma<<endl;\n\treturn dp[X1][Y1][X2][Y2]=res+ma;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>h>>w;\n\tREP(i,h) REP(j,w) cin>>a[i][j];\n\tREP(i,N) REP(j,N) REP(k,N) REP(l,N) dp[i][j][k][l]=-1;\n\n\tcout<<dfs(0,0,0,0)<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 205, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint a[MX][MX*2];\n\nint main() {\n  int h, w;\n  scanf(\"%d%d\",&h,&w);\n  rep(i,h)rep(j,w) scanf(\"%d\",&a[i][j]);\n  vvi dp(h+1,vi(h+1,a[0][0]));\n\n  rrep(s,h+w-2) {\n    vvi p(h+1,vi(h+1));\n    swap(dp,p);\n    int mh = min(h,s);\n    rep(i,mh)rep(j,mh) {\n      for (int ni = i; ni <= i+1; ++ni) {\n        for (int nj = j; nj <= j+1; ++nj) {\n          int c = a[ni][s-ni];\n          if (ni != nj) c += a[nj][s-nj];\n          maxs(dp[ni][nj],p[i][j]+c);\n        }\n      }\n    }\n  }\n  cout<<dp[h-1][h-1]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint H,W,a[210][210],f[210][210][210];\nbool vis[210][210][210];\nint F(int x1,int y1,int x2,int y2){\n\tif(x1>=H||y1>=W||x2>=H||y2>=W)return 0;\n\tif(x1==H-1&&y1==W-1&&x2==H-1)return a[x1][y1];\n\tif(vis[x1][y1][x2])return f[x1][y1][x2];\n\tvis[x1][y1][x2]=1;\n\tint&g=f[x1][y1][x2];\n\tg=0;\n\tfor(int d1=0;d1<2;d1++){\n\t\tfor(int d2=0;d2<2;d2++){\n\t\t\tint tmp=F(x1+d1,y1+1-d1,x2+d2,y2+1-d2);\n\t\t\tif(tmp>g)g=tmp;\n\t\t}\n\t}\n\tg+=x1==x2&&y1==y2?a[x1][y1]:a[x1][y1]+a[x2][y2];\n\treturn g;\n}\nint main(){\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++)for(int j=0;j<W;j++)scanf(\"%d\",a[i]+j);\n\tprintf(\"%d\\n\",F(0,0,0,0));\n}"
  },
  {
    "language": "C++",
    "code": "//四則演算 #pragma GCC target(\"avx\")\n//並列計算 #pragma GCC optimize(\"O3\")\n//条件分岐を減らす #pragma GCC optimize(\"unroll-loops\")\n//浮動小数点演算 #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(int i=(a);i<(n);++i)\n#define eFOR(i,a,n) for(int i=(a);i<=(n);++i)\n#define rFOR(i,a,n) for(int i=(n)-1;i>=(a);--i)\n#define erFOR(i,a,n) for(int i=(n);i>=(a);--i)\n#define each(i, a) for(auto &i : a)\n#define SORT(a) sort(a.begin(),a.end())\n#define rSORT(a) sort(a.rbegin(),a.rend())\n#define fSORT(a,f) sort(a.begin(),a.end(),f)\n#define all(a) a.begin(),a.end()\n#define out(y,x) ((y)<0||h<=(y)||(x)<0||w<=(x))\n#define tp(a,i) get<i>(a)\n#define line cout << \"-----------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n#define stop system(\"pause\")\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T>inline istream& operator>>(istream& is, deque<T>& v) { for (auto& a : v)is >> a; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\ntemplate<class T>inline void print(const T& a) { cout << a << \"\\n\"; }\ntemplate<class T, class... Ts>inline void print(const T& a, const Ts&... ts) { cout << a << \" \"; print(ts...); }\ntemplate<class T>inline void print(const vector<T>& v) { for (int i = 0; i < v.size(); ++i)cout << v[i] << (i == v.size() - 1 ? \"\\n\" : \" \"); }\ntemplate<class T>inline void print(const vector<vector<T>>& v) { for (auto& a : v)print(a); }\ninline string reversed(const string& s) { string t = s; reverse(all(t)); return t; }\n\nint main() {\n    init();\n\n    int h, w; cin >> h >> w;\n    auto a = vec<int>(h + w - 1, 0);\n    FOR(i, 0, h + w - 1)a[i].reserve(min(i + 1, h + w - i));\n    FOR(y, 0, h)FOR(x, 0, w) {\n        int ipt_a; cin >> ipt_a;\n        a[x + y].push_back(ipt_a);\n    }\n\n    auto dp = vec<int>(h + w - 1, 0, 0);\n    dp[0] = defvec<int>(a[0][0], 1, 1);\n    FOR(i, 0, h + w - 2) {\n        reverse(all(a[i]));\n        dp[i + 1] = vec<int>(a[i + 1].size(), a[i + 1].size());\n        FOR(e, 0, a[i].size())FOR(s, 0, a[i].size()) {\n            if (i < h - 1)eFOR(ne, e, e + 1)eFOR(ns, s, s + 1) {\n                chmax(dp[i + 1][ne][ns], dp[i][e][s] + a[i + 1][ne] + a[i + 1][ns] * (ne != ns));\n            }\n            else FOR(ne, max(e - 1, 0), min(e + 1, (int)a[i + 1].size()))FOR(ns, max(s - 1, 0), min(s + 1, (int)a[i + 1].size())) {\n                chmax(dp[i + 1][ne][ns], dp[i][e][s] + a[i + 1][ne] + a[i + 1][ns] * (ne != ns));\n            }\n        }\n    }\n    print(dp[h + w - 2][0]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<map>\nusing namespace std;\n\nunordered_map<int, unordered_map<int, int[200][200]>>dp;\nint a, b;\nint c[200][200];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f][g] != 0)return dp[d][e][f][g];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y)-1;\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f][g] = max(dp[d][e][f][g], S+1);\n\t\t}\n\t}\n\treturn dp[d][e][f][g];\n}\nsigned main() {\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0][0] = c[0][0]+1;\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1)-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define N 210\nint h,w,a[N][N];\nll dp[N][N][N];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t    cin>>a[i][j];\n\t}\n    }\n    if(h>w){\n\tll cop[N][N];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t    cop[j][i]=a[i][j];\n\t}\n\tswap(h,w);\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t    a[i][j]=cop[i][j];\n\t}\n    }\n    if(h<=2){\n\tll ans=0;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)ans+=a[i][j];\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    for(int i=0;i<N;i++)for(int j=0;j<N;j++)for(int k=0;k<N;k++)dp[i][j][k]=0;\n    dp[1][0][1]=a[0][1]+a[1][0]+a[0][0]+a[h-1][w-1];\n    for(int i=1;i<h+w;i++){\n\tfor(int x=0;x<h;x++)for(int y=x+1;y<h;y++){\n\t    if(i-x<0||w<=i-x)continue;\n\t    if(i-y<0||w<=i-y)continue;\n\t    //cout<<i<<\" \"<<x<<\" \"<<y<<\" \"<<dp[i][x][y]<<endl;\n\t    for(int xx=x;xx<=x+1;xx++)for(int yy=y;yy<=y+1;yy++){\n\t\tif(xx==yy)continue;\n\t\tif(i+1-xx<0||w<=i+1-xx)continue;\n\t\tif(i+1-yy<0||w<=i+1-yy)continue;\n\t\tchmax(dp[i+1][xx][yy],dp[i][x][y]+a[xx][i+1-xx]+a[yy][i+1-yy]);\n\t    }\n\t}\n    }\n    cout<<dp[h+w-3][h-2][h-1]<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 100000\ntypedef pair<ll,int> P;\nll INF=100000000000LL;\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V];\nll dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,int f){\n  ll res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n\n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=(ll)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint H,W;\nint t[200][200];\n\nint main(){\n  cin>>H>>W;\n  int si=H*W*2;\n  int ti=si+1;\n  V=ti+1;\n\n  int N=H*W;\n  ll mx=1e6;\n  \n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      add_edge(i*W+j,i*W+j+N,1,mx);\n      add_edge(i*W+j,i*W+j+N,1,mx-t[i][j]);\n      //      add_edge(i*W+j,i*W+j+N,1,mx);\n      if(i+1<H){\n        int id=(i+1)*W+j;\n        add_edge(i*W+j+N,id,2,0);\n      }\n      if(j+1<W){\n        int id=i*W+(j+1);\n        add_edge(i*W+j+N,id,2,0);\n      }\n      \n    }\n  }\n  add_edge(si, 0, 2, 0);\n  add_edge( (H-1)*W+(W-1)+N , ti, 2,0);\n\n  ll ans= min_cost_flow(si,ti,2);\n  \n  ans-=mx*(H+W-1)*2;\n  cout<<-ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;} cout << endl;\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int H, W;\n    cin >> H >> W;\n    int N = max(H, W);\n    vvi a(N + 1, vi(N + 1));\n    rep(i, N) rep(j, N) cin >> a[i + 1][j + 1];\n\n    vvi b(2 * N + 1, vi(N + 1));\n    rep(i, N + 1) {\n        rep(j, N + 1) {\n            b[i + j][j] = a[i][j];\n        }\n    }\n\n    vvvi dp(2 * N + 1, vvi(N + 1, vi(N + 1)));\n    rep2(i, 1, 2 * N + 1) {\n        rep2(j, 1, N + 1) {\n            rep2(k, 1, N + 1) {\n                dp[i][j][k] = max({dp[i-1][j][k],\n                                    dp[i-1][j][k-1],\n                                    dp[i-1][j-1][k],\n                                    dp[i-1][j-1][k-1]});\n                dp[i][j][k] += (j != k ? b[i][j] + b[i][k] : b[i][j]);\n            }\n        }\n    }\n    cout << dp.back().back().back() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,t,T1,m;\n    cin >> H >> W;\n    int array1[W];\n    int array2[W];\n    int array3[W];\n    T1=0;\n    m=0;\n    for(int i=0;i<W;i++){\n        cin>>array1[i];\n        T1=T1+array1[i];\n    }\n    for(int i=0;i<W;i++){\n        cin>>array2[i];\n    }\n    for(int y=0;y<W;y++){\n            if(y==0){\n                array3[y]=T1+array2[W-1];\n            }else{\n                array3[y]=T1+array2[W-1]+(array2[W-y-1]+array2[W-2])*y/2-(array1[W-y]+array1[W-1])*y/2;\n            }\n    }\n    for(int i=0;i<W;i++){\n        if(array3[i]>m){\n            m=array3[i];\n        }\n    }\n    cout << m << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint H, W;\nVVI a;\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H == 2 || H == 3);\n    if (H == 2) {\n        LL ans = 0;\n        REP(i, H)REP(j, W) ans += a[i][j];\n        cout << ans << endl;\n    } else {\n        LL ans = 0;\n        LL fst = accumulate(ALL(a[0]), 0), snd = accumulate(ALL(a[1]), 0), thd = accumulate(ALL(a[2]), 0);\n        ans = fst + snd + thd;\n        fst -= a[0].front();\n        snd = snd - a[1].front() - a[1].back();\n        thd -= a[2].back();\n        cout << fst << \" \" << snd << \" \" << thd << endl;\n        cout << ans - min({fst, snd, thd}) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nusing ll = long long;\n\nll chart[234][234];\nll INF = 1234567890123456;\nll memo[456][234][234];\nll h, w;\nll dp(int d, int i, int j)\n{\n\tif (i < 0 || i > d || j < 0 || j > d || d - i >= w || d - j >= w || i >= h || j >= h)return -INF;\n\tif (memo[d][i][j] != -1)return memo[d][i][j];\n\tll score = chart[i][d - i];\n\tif (i != j)\n\t{\n\t\tscore += chart[j][d - j];\n\t}\n\tll ans = 0;\n\tfor (int bit = 0; bit < 4; ++bit)\n\t{\n\t\tans = max(ans, dp(d - 1, i - (bit % 2), j - (bit / 2)));\n\t}\n\treturn memo[d][i][j] = ans + score;\n}\n\nint main(void)\n{\n\tmemset(memo, 0xff, sizeof(memo));\n\tscanf(\"%lld %lld\", &h, &w);\n\tfor (int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0; j < w; ++j)\n\t\t{\n\t\t\tscanf(\"%lld\", &chart[i][j]);\n\t\t}\n\t}\n\tmemo[0][0][0] = chart[0][0];\n\tprintf(\"%lld\\n\", dp(h + w - 2, h - 1, h - 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nconst int INF=1001001001001001001ll;\n\nint H,W;\nint A[222][222];\n\nint dp[222][222][222];\nsigned main(){\n    cin>>H>>W;\n    rep(i,H){\n        rep(j,W)cin>>A[i][j+1],A[i][j+1]+=A[i][j];\n    }\n    fill_n(**dp,222*222*222,-INF);\n    dp[0][0][0]=0;\n\n    for(int i=0;i<H;i++){\n        int max1=-INF;\n        int max2[222]={};fill_n(max2,222,-INF);\n        for(int j=0;j<W;j++){\n            for(int k=0;k<=j;k++)chmax(max1,dp[i][k][j]-A[i][k]);\n            for(int k=j+1;k<W;k++)chmax(max2[k],dp[i][j][k]-A[i][j]-A[i][k]);\n            int max3=-INF;\n            for(int k=j;k<W;k++){\n                if(k!=j)chmax(max3,max2[k]);\n                chmax(dp[i+1][j][k],max1+A[i][k+1]);\n                chmax(dp[i+1][j][k],max3+A[i][k+1]+A[i][j+1]);\n            }\n        }\n    }\n    cout<<dp[H][W-1][W-1]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define int long long\ntypedef long long int64;\n \n \nstruct Primal_Dual\n{\n  const int64 INF = 1LL << 59;\n  typedef pair< int64, int > Pi;\n \n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int64 > potential, min_cost, prevv, preve;\n \n  Primal_Dual(int V) : graph(V) {}\n \n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n \n  int64 min_cost_flow(int s, int t, int f)\n  {\n    int64 V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n \n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n \n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int64 nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return (114514);\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n \nsigned main()\n{\n  int H, W, A[200][200];\n \n  cin >> H >> W;\n  Primal_Dual flow(H * W * 2);\n \n  auto cell = [&](int i, int j, bool in)\n  {\n    if(in) return (H * W + i * W + j);\n    return (i * W + j);\n  };\n \n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      cin >> A[i][j];\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, -A[i][j]);\n      flow.add_edge(cell(i, j, false), cell(i, j, true), 1, 0);\n      if(i > 0) flow.add_edge(cell(i - 1, j, true), cell(i, j, false), 2, 0);\n      if(j > 0) flow.add_edge(cell(i, j - 1, true), cell(i, j, false), 2, 0);\n    }\n  }\n  cout << -flow.min_cost_flow(cell(0, 0, false), cell(H - 1, W - 1, true), 2) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int> > a(H, vector<int>(W));\n\trep(y, H) rep(x, W) cin >> a[y][x];\n\tvector<vector<int> > dp(H + 1, vector<int>(H + 1, INT_MIN));\n\tdp[0][0] = 0;\n\trep(z, H + W - 2) {\n\t\tvector<vector<int> > _dp(H + 1, vector<int>(H + 1, INT_MIN));\n\t\trep(y1, H) rep(y2, H) {\n\t\t\tint x1 = z - y1, x2 = z - y2;\n\t\t\tif (!(0<=x1 && x1<W && 0<=x2 && x2<W)) continue;\n\t\t\tint unko = dp[y1][y2] + a[y1][x1];\n\t\t\tif (y1 != y2) unko += a[y2][x2];\n\t\t\t_dp[y1][y2] = max(_dp[y1][y2], unko);\n\t\t\t_dp[y1 + 1][y2] = max(_dp[y1 + 1][y2], unko);\n\t\t\t_dp[y1][y2 + 1] = max(_dp[y1][y2 + 1], unko);\n\t\t\t_dp[y1 + 1][y2 + 1] = max(_dp[y1 + 1][y2 + 1], unko);\n\t\t}\n\t\tdp = _dp;\n\t}\n\tcout << dp[H - 1][H - 1] + a[H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[211][211];\nint h, w;\n\nstruct Edge{\n    int u, v;\n    long long cap, cost;\n\n    Edge(int _u, int _v, long long _cap, long long _cost){\n        u = _u; v = _v; cap = _cap; cost = _cost;\n    }\n};\n\nstruct MinCostFlow{\n    int n, s, t;\n    long long flow, cost;\n    vector<vector<int> > graph;\n    vector<Edge> e;\n    vector<long long> dist;\n    vector<int> parent;\n\n    MinCostFlow(int _n){\n        // 0-based indexing\n        n = _n;\n        graph.assign(n, vector<int> ());\n    }\n\n    void addedge(int u, int v, long long cap, long long cost, bool directed = true){\n        graph[u].push_back(e.size());\n        e.push_back(Edge(u, v, cap, cost));\n\n        graph[v].push_back(e.size());\n        e.push_back(Edge(v, u, 0, -cost));\n\n        if(!directed)\n            addedge(v, u, cap, cost, true);\n    }\n\n    pair<long long, long long> getMinCostFlow(int _s, int _t){\n        s = _s; t = _t;\n        flow = 0, cost = 0;\n\n        while(SPFA()){\n            flow += sendFlow(t, 1LL<<62);\n        }\n\n        return make_pair(flow, cost);\n    }\n\n    // not sure about negative cycle\n    bool SPFA(){\n        parent.assign(n, -1);\n        dist.assign(n, 1LL<<62);        dist[s] = 0;\n        vector<int> queuetime(n, 0);    queuetime[s] = 1;\n        vector<bool> inqueue(n, 0);     inqueue[s] = true;\n        queue<int> q;                   q.push(s);\n        bool negativecycle = false;\n\n\n        while(!q.empty() && !negativecycle){\n            int u = q.front(); q.pop(); inqueue[u] = false;\n\n            for(int i = 0; i < graph[u].size(); i++){\n                int eIdx = graph[u][i];\n                int v = e[eIdx].v, w = e[eIdx].cost, cap = e[eIdx].cap;\n\n                if(dist[u] + w < dist[v] && cap > 0){\n                    dist[v] = dist[u] + w;\n                    parent[v] = eIdx;\n\n                    if(!inqueue[v]){\n                        q.push(v);\n                        queuetime[v]++;\n                        inqueue[v] = true;\n\n                        if(queuetime[v] == n+2){\n                            negativecycle = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dist[t] != (1LL<<62);\n    }\n\n    long long sendFlow(int v, long long curFlow){\n        if(parent[v] == -1)\n            return curFlow;\n        int eIdx = parent[v];\n        int u = e[eIdx].u, w = e[eIdx].cost;\n\n        long long f = sendFlow(u, min(curFlow, e[eIdx].cap));\n\n        cost += f*w;\n        e[eIdx].cap -= f;\n        e[eIdx^1].cap += f;\n\n        return f;\n    }\n};\n\nint getid(int x, int y, int type)\n{\n\treturn (x*w+y)*2+type;\n}\n\nconst int T = 2;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>h>>w;\n\tfor(int i = 0; i < h; i++)\n\t{\n\t\tfor(int j = 0; j < w; j++)\n\t\t{\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tMinCostFlow mcmf(h*w*2+10);\n\tint s=h*w*2+9; int e=h*w*2+8;\n\tmcmf.addedge(s,getid(0,0,0),T,0);\n\tmcmf.addedge(getid(h-1,w-1,1),e,T,0);\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(i+1<h)\n\t\t\t{\n\t\t\t\tmcmf.addedge(getid(i,j,1),getid(i+1,j,0),T,0);\n\t\t\t}\n\t\t\tif(j+1<w)\n\t\t\t{\n\t\t\t\tmcmf.addedge(getid(i,j,1),getid(i,j+1,0),T,0);\n\t\t\t}\n\t\t\tmcmf.addedge(getid(i,j,0),getid(i,j,1),1,-a[i][j]);\n\t\t\tmcmf.addedge(getid(i,j,0),getid(i,j,1),T-1,0);\n\t\t}\n\t}\n\tii tmp = mcmf.getMinCostFlow(s,e);\n\tcout<<-tmp.se<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,j,d[205][205];\nll a[205][205],f[205][205],ans;\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tif(j-1>=1 && f[i][j-1]>f[i-1][j])\n\t\t\t{\n\t\t\t\tf[i][j]=f[i][j-1];\n\t\t\t\td[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\td[i][j]=1;\n\t\t\t}\n\t\t\tf[i][j]+=a[i][j];\n\t\t}\n\t}\n\tans=f[n][m];\n\ti=n,j=m;\n\twhile(1)\n\t{\n\t\ta[i][j]=0;\n\t\tif(i==1 && j==1)break;\n\t\tif(d[i][j])i--;\n\t\telse j--;\n\t}\n\tmemset(f,0,sizeof(f));\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j];\n\tcout<<f[n][m]+ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\n//int dp[205][205][205][205];\n//int dp[55][55][55][55];\nmap<pair<pair<int, int>, pair<int, int> >, int> cur;\nmap<pair<pair<int, int>, pair<int, int> >, int> nnext;\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tcur[make_pair(make_pair(0,0), make_pair(0,0))] = 0;\n\n\n\twhile(true){\n\t\tfor(auto c: cur){\n\t\t\tint i = c.first.first.first;\n\t\t\tint j = c.first.first.second;\n\t\t\tint k = c.first.second.first;\n\t\t\tint l = c.first.second.second;\n\t\t\tint ori = c.second;\n\t\t\tif(i != H - 1){\n\t\t\t\tif(k != H - 1){\n\t\t\t\t\tif(i + 1 != k + 1 || j != l){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == H - 1 && k + 1 == W - 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(l != W - 1){\n\t\t\t\t\tif(i + 1 != k || j != l+1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 != H-1 || j != W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i+1, j), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j != W - 1){\n\t\t\t\tif(k != H - 1){\n\t\t\t\t\tif(i != k + 1 || j + 1 != l){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i != H-1 || j + 1 != W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k+1, l))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(l != W - 1){\n\t\t\t\t\tif(i != k + 1 || j != l + 1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i != H-1 || j != W-1){\n\t\t\t\t\t\tnnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))] = max(nnext[make_pair(make_pair(i, j+1), make_pair(k, l+1))], ori + a[i][j] + a[k][l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(nnext.size() == 1){\n\t\t\tbreak;\n\t\t}\n\t\tswap(cur, nnext);\n\t\tnnext.clear();\n\t}\n\tfor(auto n: nnext){\n\t\tcout << n.second + a[H-1][W-1] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <fstream>\n#include <unistd.h>\n#include <string.h>\n#include <string>\n#include <numeric>\n#include <queue>\n#include <deque>\n#include <sstream>\n#include <iomanip>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <functional>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<vvvl> vvvvl;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef long double LD;\ntypedef vector<LD> vld;\ntypedef vector<pair<LD, LD>> vpld;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> vpl;\ntypedef vector<vector<PL>> vvpl;\ntypedef vector<vvpl> vvvpl;\ntypedef pair<ll, PL> TL;\ntypedef vector<TL> vtl;\ntypedef vector<vtl> vvtl;\ntypedef long double ld;\ntypedef vector<ld> vld;\nconst ll LINF = 1e17;\nconst double pi = 3.1415926535897932;\nconst string endstr = \"\\n\";\n#define FOR(i, a, b) for(ll i = (a); i < b; i++)\n#define RFOR(i, a, b) for(ll i = (a); i > b; i--)\n#define rep(i, n) for(ll i = 0; i < n; i++)\n#define rrep(i, n) for(ll i = n-1; i > -1; i--)\n#define FORMAP(it, m) for(auto it = m.begin(); it != m.end(); it++)\n#define ff first\n#define ss second\n#define pb push_back\n#define epb emplace_back\n#define ALL(X) (X).begin(),(X).end()\n\ntemplate <typename T> T gcd(T a, T b) {return (a == 0) ? b : gcd(b%a, a);}\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b;}\n\nbool p_comp_fs(const PL p1, const PL p2){ return p1.first < p2.first;};\nbool p_comp_fg(const PL p1, const PL p2){ return p1.first > p2.first;};\nbool p_comp_ss(const PL p1, const PL p2){ return p1.second < p2.second;};\nbool p_comp_sg(const PL p1, const PL p2){ return p1.second > p2.second;};\ntemplate <typename T>\nvector<T> uniquen(vector<T> vec /* copy */){\n    sort(ALL(vec)); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec;\n}\n\ninline ll popcnt(ll x){return __builtin_popcountll((unsigned long long)x);};\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\n//friend bool operator<(const tpl& lhs, const tpl& rhs){\n//    return std::tie(lhs.l, lhs.r) < std::tie(rhs.l, rhs.r);\n//}\n\nbool bit(ll st, ll b){return ((st>>b)&1) == 1;}\n\nll H, W;\nll dp[210][210][420];\nvvl A;\n\nvl dh = {1, 0};\n\nbool ok(ll h, ll w){\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nvoid dfs(ll eh, ll sh, ll sum, ll now){\n    if(dp[eh][sh][sum] > now) return;\n    if(sum == H-1+W-1) return;\n    rep(i, 2) rep(j, 2){\n        ll nhe = eh+dh[i], nwe = sum+1-nhe;\n        ll nhs = sh+dh[j], nws = sum+1-nhs;\n        if(!ok(nhe, nwe)  || !ok(nhs, nws)) continue;\n        if(nhe == nhs && nwe == nws){\n            if(chmax(dp[nhe][nhs][sum+1], now + A[nhe][nwe])){\n                dfs(nhe, nhs, sum+1,  now + A[nhe][nwe]);\n            }\n        }\n        else{\n            if(chmax(dp[nhe][nhs][sum+1], now + A[nhe][nwe] + A[nhs][nws])){\n                dfs(nhe, nhs, sum+1,  now + A[nhe][nwe] + A[nhs][nws]);\n            }\n        }\n    }\n}\n\n\nint main(){\n#ifdef __DEBUG_LOCAL__\n    ifstream file(\"../../../../../in.txt\"); if(file.is_open()) cin.rdbuf(file.rdbuf());\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n    \n    memset(dp, -1, sizeof(dp));\n    cin >> H >> W;  A = vvl(H, vl(W, 0));\n    rep(i, H) rep(j, W) cin >> A[i][j];\n    dp[0][0][0] = 0;\n    dfs(0, 0, 0, A[0][0]);\n    cout << dp[H-1][H-1][H-1+W-1] << endstr;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nint dp[205][205][420];\n//int dp[55][55][55][55];\nint H, W;\nint a[205][205];\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < H; k++){\n\t\t\tfor(int m = 0; m < H + W; m++){\n\t\t\t\tdp[i][k][m] = -INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < H; k++){\n\t\t\tfor(int m = 0; m < H + W - 1; m++){\n\t\t\t\tint j = m - i;\n\t\t\t\tint l = m - k;\n\t\t\t\tif(i == k && j == l){\n\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i+1][k+1][j+l] = max(dp[i+1][k+1][j+l] , dp[i][k][m] + a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i+1][k][j+l+1] = max(dp[i+1][k][j+l+1], dp[i][k][m] + a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i][k+1][j+1+l] = max(dp[i][k+1][j+1+l], dp[i][k][m]+ a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i][k][j+1+l+1] = max(dp[i][k][j+1+l+1], dp[i][k][m]+ a[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\t\t\t\t\tif(i != H - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i+1][k+1][j+l] = max(dp[i+1][k+1][j+l], dp[i][k][m]+ a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i+1][k][j+l+1] = max(dp[i+1][k][j+l+1], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j != W - 1){\n\t\t\t\t\t\tif(k != H - 1){\n\t\t\t\t\t\t\tdp[i][k+1][j+1+l] = max(dp[i][k+1][j+1+l], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(l != W - 1){\n\t\t\t\t\t\t\tdp[i][k][j+1+l+1] = max(dp[i][k][j+1+l+1], dp[i][k][m] + a[i][j] + a[k][l]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[H-1][H-1][H-1+W-1] + a[H-1][W-1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    if(h == 1 || w == 1){\n        int ans = 0;\n        for(int i=0; i<h*w; ++i){\n            int a;\n            cin >> a;\n            ans += a;\n        }\n        cout << ans << endl;\n        return 0;\n    }\n\n    vector<vector<int> > a(h, vector<int>(w));\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            cin >> a[y][x];\n        }\n    }\n\n    vector<vector<int> > dp(w, vector<int>(w, 0));\n    for(int y=0; y<h; ++y){\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1+1; x2<w; ++x2){\n                dp[x1][x2] += a[y][x1] + a[y][x2];\n            }\n        }\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1+1; x2<w; ++x2){\n                dp[x1+1][x2] = max(dp[x1+1][x2], dp[x1][x2] + a[y][x1+1]);\n            }\n        }\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1+1; x2<w-1; ++x2){\n                dp[x1][x2+1] = max(dp[x1][x2+1], dp[x1][x2] + a[y][x2+1]);\n            }\n        }\n    }\n    cout << dp[w-2][w-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\nInt a[222][222];\nInt dp[2][222][222][222];\nsigned main(){\n  memset(a,0,sizeof(a));\n  Int h,w;\n  cin>>h>>w;\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cin>>a[i][j];\n  \n  memset(dp,-1,sizeof(dp));\n  dp[0][0][0][0]=a[0][0];\n  for(Int i=0;i<h;i++){\n    for(Int l=0;l<w;l++){\n      for(Int r=l;r<w;r++){\n\tfor(Int k=0;k<2;k++){\n\t  if(dp[k][i][l][r]<0) continue;\n\t  if(l+1<=r)\n\t    chmax(dp[k][i][l+1][r],dp[k][i][l][r]+(!k)*(l+1<r)*a[i][l+1]);\n\t  if(r+1<w)\n\t    chmax(dp[1][i][l][r+1],dp[k][i][l][r]+a[i][r+1]);\n\t  \n\t  chmax(dp[0][i+1][l][r],dp[k][i][l][r]+a[i+1][l]+(l!=r)*a[i+1][r]);\n\t}\n      }\n    }\n  }\n  cout<<max(dp[0][h][w-1][w-1],dp[1][h][w-1][w-1])<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[30][30][30][30];\nint a, b;\nint c[30][30];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f][g] != -1)return dp[d][e][f][g];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y);\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f][g] = max(dp[d][e][f][g], S);\n\t\t}\n\t}\n\treturn dp[d][e][f][g];\n}\nsigned main() {\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0][0] = c[0][0];\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nll h, w; \nll dp[402][200][200];\nbool can(pair<ll, ll> po){return (0 <= po.first && po.first < h && 0 <= po.second && po.second < w ? true : false);}\nint main(){\n\tcin >> h >> w;\n\tll a[h][w];\n\tfor(ll i = 0; i < h; i++)for(ll j = 0; j < w; j++)cin >> a[i][j];\n\tdp[0][0][0] = a[0][0];\n\tfor(ll count = 0; count < h + w - 2; count++){\n\t\tfor(ll i = 0; i < h; i++){\n\t\t\tfor(ll j = 0; j < h; j++){\n\t\t\t\tauto po = pair<ll, ll>(i, count - i), yo = pair<ll, ll>(j, count - j);\n\t\t\t\tif(!can(po) || !can(yo)) continue;\n\t\t\t\tll dh[] = {1, 0}, dw[] = {0, 1};\n\t\t\t\tfor(ll p = 0; p < 2; p++){\n\t\t\t\t\tfor(ll y = 0; y < 2; y++){\n\t\t\t\t\t\tauto nextpo = po, nextyo = yo;\n\t\t\t\t\t\tnextpo.first += dh[p];\n\t\t\t\t\t\tnextpo.second += dw[p];\n\t\t\t\t\t\tnextyo.first += dh[y];\n\t\t\t\t\t\tnextyo.second += dw[y];\n\t\t\t\t\t\tif(!can(nextpo) || !can(nextyo)) continue;\n\t\t\t\t\t\tdp[count + 1][nextpo.first][nextyo.first] = max(dp[count + 1][nextpo.first][nextyo.first], dp[count][po.first][yo.first] + a[nextpo.first][nextpo.second] + a[nextyo.first][nextyo.second] - (nextpo == nextyo ? a[nextpo.first][nextpo.second] : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h + w - 2][h - 1][h - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nusing State = pair<LL, PII>; // <score, (h, w)>\nint H, W;\nVVI a;\n\nLL dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool inside(int h, int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H <= 30 && W <= 30);\n    dp[0][0][0][0] = a[0][0];\n    REP(eh, H) REP(ew, W) REP(sh, H) REP(sw, W) {\n        if (eh == 0 && ew == 0 && sh == 0 && sw == 0) continue;\n        LL buf = 0;\n        if (eh && sh) buf = max(buf, dp[eh - 1][ew][sh - 1][sw]);\n        if (eh && sw) buf = max(buf, dp[eh - 1][ew][sh][sw - 1]);\n        if (ew && sw) buf = max(buf, dp[eh][ew - 1][sh][sw - 1]);\n        if (ew && sh) buf = max(buf, dp[eh][ew - 1][sh - 1][sw]);\n        if (eh == sh && sw == sw) dp[eh][ew][sh][sw] = buf + a[sh][sw];\n        else dp[eh][ew][sh][sw] = buf + a[eh][ew] + a[sh][sw];\n    }\n    cout << dp[H - 1][W - 1][H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\n#include <bitset>\n#include <time.h>\n#include <set>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nll A[222][222];\nll dp[222][222][222];\n\n\nll Solve(int x1,int y1,int x2,int y2,int H,int W) {\n    if (x1==H && y1==W)\n        return A[H][W];\n    \n    \n    if (dp[x1][y1][x2]!=-1)\n        return dp[x1][y1][x2];\n    \n    ll curr = A[x1][y1];\n    if (x1 != x2)\n        curr += A[x2][y2];\n\n    ll retval = 0;\n    \n    for(int b1=0;b1<=1;b1++)\n        for(int b2=0;b2<=1;b2++) {\n            int nx1=x1;\n            int ny1=y1;\n            int nx2=x2;\n            int ny2=y2;\n            \n            if (b1==0) {\n                nx1++;\n            } else {\n                ny1++;\n            }\n            \n            if (b2==0) {\n                nx2++;\n            } else {\n                ny2++;\n            }\n            \n            if (nx1 > H | ny1 > W || nx2 > H || ny2 > W)\n                continue;\n            retval = max(retval, curr+Solve(nx1,ny1,nx2,ny2,H,W));\n        }\n    return dp[x1][y1][x2]=retval;\n    \n    \n}\n\nint main() {\n    int H,W;\n    cin>>H>>W;\n    for(int i=1;i<=H;i++)\n        for(int j=1;j<=W;j++)\n            cin>>A[i][j];\n    \n    for(int i=0;i<=H;i++)\n        for(int j=0;j<=W;j++)\n            for(int k=0;k<=H;k++)\n                dp[i][j][k]=-1;\n    cout << Solve(1,1,1,1,H,W) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 201\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE];\nint cache[SIZE][SIZE][SIZE];\n\nLL calc(int x1, int y1, int x2, int y2) {\n\tif (cache[x1][y1][x2] > -1) return cache[x1][y1][x2];\n\tif (x1 == H || y1 == W || x2 == H || y2 == W) {\n\t\treturn 0;\n\t}\n\tif (x1 == H-1 && y1 == W-1 && x2 == H-1 && y2 == W-1) {\n\t\treturn A[H-1][W-1];\n\t}\n\tLL res = 0;\n\tif (x1 == x2) {\n\t\tres += A[x1][y1];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), calc (x1, y1+1, x2, y2+1));\n\t} else {\n\t\tres += A[x1][y1] + A[x2][y2];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), max(\n\t\t\t\tcalc(x1, y1+1, x2+1, y2),\n\t\t\t\tcalc(x1, y1+1, x2, y2+1)));\n\t}\n\tcache[x1][y1][x2] = res;\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tmemset(cache, -1, sizeof(cache));\n\tcout << calc(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\nll inf=1e18+9;\n\n/*\nWA\n１人目を探索させてから２人目を探索させる貪欲\nこれが何故WAになるのか分からないのでどなたか教えてください・・・\n（一応解説の方法でACになることは確認していますが・・・）\n*/\n\nll h,w,a[210][210],dp[210][210],dx[2]={0,1},dy[2]={1,0},ans=0;\n\n//普通にdp\nll f(ll x,ll y){\n\tif(dp[y][x]!=-1)return dp[y][x];\n\tll ans=0;\n\trep(i,2){\n\t\tif(x+dx[i]>w-1 || y+dy[i]>h-1)continue;\n\t\tans=max(ans,f(x+dx[i],y+dy[i]));\n\t}\n\treturn dp[y][x]=ans+a[y][x];\n}\n//fで通った場所を消す\nvoid g(ll x,ll y){\n\twhile(1){\n\t\ta[y][x]=0;\n\t\tif(x==w-1 && y==h-1)break;\n\t\tll b=0,to=0;\n\t\trep(i,2){\n\t\t\tif(x+dx[i]>w-1 || y+dy[i]>h-1)continue;\n\t\t\tif(dp[y+dy[i]][x+dx[i]]>b){\n\t\t\t\tto=i;\n\t\t\t\tb=dp[y+dy[i]][x+dx[i]];\n\t\t\t}\n\t\t}\n\t\tx=x+dx[to];\n\t\ty=y+dy[to];\n\t}\n}\n\nvoid dp_reset(){\n\trep(i,210)rep(j,210)dp[i][j]=-1;//初期化\n}\n\nint main(void){\n\tcin>>h>>w;\n\trep(i,h)rep(j,w)cin>>a[i][j];\n\tdp_reset();\n\tans+=f(0,0);\n\t// rep(i,h){\n\t// \trep(j,w)cout<<dp[i][j]<<\" \";\n\t// \tcout<<endl;\n\t// }\n\tg(0,0);\n\t// rep(i,h){\n\t// \trep(j,w)cout<<a[i][j]<<\" \";\n\t// \tcout<<endl;\n\t// }\n\tdp_reset();\n\tans+=f(0,0);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst long long MOD = 1000000000 + 7;//1000000000 + 7 998244353 924844033 1000000000 + 9;\nconstexpr long long INF = 1LL << 60;//numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<double, double> Dll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge {\n\tLL from, to, cost;\n};\nvector<vector<Edge>>g;\nvector<edge>ed;\nvector<Pll>pv;\nset<LL>st;\nmap<Pll, LL>ma;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstring str, ss;\nbool f;\nLL n, m, s, t, h, w, k, q, p, ans, sum, cnt, a[300][300], b[21], dp[400][200][200];\nint main() {\n\tcin >> h >> w;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tdp[0][0][0] = a[0][0];\n\trep(st, h + w-1) {\n\t\trep(sx, h) {\n\t\t\trep(tx, h) {\n\t\t\t\tLL sy = st - sx, ty = st - tx;\n\t\t\t\tif (dp[st + 1][sx][tx] < dp[st][sx][tx] + (sx == tx ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx][st - tx + 1])) {\n\t\t\t\t\tdp[st + 1][sx][tx] = dp[st][sx][tx] + (sx == tx ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx][st - tx + 1]);\n\t\t\t\t}\n\t\t\t\tif (sx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx + 1][tx] < dp[st][sx][tx] + (sx + 1 == tx ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx][st - tx + 1])) {\n\t\t\t\t\t\tdp[st + 1][sx + 1][tx] = dp[st][sx][tx] + (sx + 1 == tx ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx][st - tx + 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx][tx + 1] < dp[st][sx][tx] + (sx == tx + 1 ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx + 1][st - tx])) {\n\t\t\t\t\t\tdp[st + 1][sx][tx + 1] = dp[st][sx][tx] + (sx == tx + 1 ? a[sx][st - sx + 1] : a[sx][st - sx + 1] + a[tx + 1][st - tx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (tx + 1 < h&&sx + 1 < h) {\n\t\t\t\t\tif (dp[st + 1][sx + 1][tx + 1] < dp[st][sx][tx] + (sx + 1 == tx + 1 ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx + 1][st - tx])) {\n\t\t\t\t\t\tdp[st + 1][sx + 1][tx + 1] = dp[st][sx][tx] + (sx + 1 == tx + 1 ? a[sx + 1][st - sx] : a[sx + 1][st - sx] + a[tx + 1][st - tx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h + w - 2][h - 1][h - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); i++)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); i++)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); i--)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); i--)\n#define inc( i, n) incID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec( i, n) decID(i, 0, n)\n#define dec1(i, n) decII(i, 1, n)\n\ntypedef long long   signed int LL;\ntypedef long long unsigned int LU;\n\ntemplate<typename T> void swap(T &x, T &y) { T t = x; x = y; y = t; return; }\ntemplate<typename T> T abs(T x) { return (0 <= x ? x : -x); }\ntemplate<typename T> T max(T a, T b) { return (b <= a ? a : b); }\ntemplate<typename T> T min(T a, T b) { return (a <= b ? a : b); }\ntemplate<typename T> bool setmin(T &a, T b) { if(a <= b) { return false; } else { a = b; return true; } }\ntemplate<typename T> bool setmax(T &a, T b) { if(b <= a) { return false; } else { a = b; return true; } }\ntemplate<typename T> T gcd(T a, T b) { return (b == 0 ? a : gcd(b, a % b)); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\n\n// ---- ----\n\nint h, w, a[200][200];\nint ans;\n\nint main() {\n\tscanf(\"%d%d\", &h, &w);\n\tif(h > 2) { return 1; }\n\tinc(i, h) { \n\tinc(j, w) {\n\t\tscanf(\"%d\", &a[i][j]);\n\t\tans += a[i][j];\n\t}\n\t}\n\t\n\t/*\n\tif(h == 3 && w == 3) {\n\t\tans -= min(min(a[0][2], a[2][0]), a[1][1]);\n\t}\n\t*/\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint H, W;\nvector<vector<int>> space;\n\nint dp[300][300][599];\n\nint move(int E869120_y, int square1001_y, int progress){\n    if(dp[E869120_y][square1001_y][progress] != -1){\n        return dp[E869120_y][square1001_y][progress];\n    }else{\n        vector<int> E869120_can_move_y;\n        if(E869120_y != H - 1){\n            E869120_can_move_y.push_back(E869120_y + 1);\n        }\n        if(progress - E869120_y != W - 1){\n            E869120_can_move_y.push_back(E869120_y);\n        }\n        vector<int> square1001_can_move_y;\n        if(square1001_y != H - 1){\n            square1001_can_move_y.push_back(square1001_y + 1);\n        }\n        if(progress - square1001_y != W - 1){\n            square1001_can_move_y.push_back(square1001_y);\n        }\n        int ans = 0;\n        for(int i = 0; i < E869120_can_move_y.size(); i++){\n            for(int j = 0; j < square1001_can_move_y.size(); j++){\n                ans = max(ans, move(E869120_can_move_y[i], square1001_can_move_y[j], progress + 1));\n            }\n        }\n        if(E869120_y == square1001_y){\n            return dp[E869120_y][square1001_y][progress] = space[E869120_y][progress - E869120_y] + ans;\n        }else{\n            return dp[E869120_y][square1001_y][progress] = space[E869120_y][progress - E869120_y] + space[square1001_y][progress -  square1001_y] + ans;\n        }\n    }\n}\n\nint main(){\n    cin >> H >> W;\n    space.resize(H);\n    for(int i = 0; i < H; i++){\n        space[i].resize(W);\n        for(int j = 0; j < W; j++){\n            cin >> space[i][j];\n        }\n    }\n    for(int i = 0; i < 300; i++){\n        for(int j = 0; j < 300; j++){\n            for(int k = 0; k < 599; k++){\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n    cout << move(0, 0, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nlong dp[400][200][200];\n\nint main(){\n    int H, W;\n    long a[200][200];\n    cin >> H >> W;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            cin >> a[i][j];\n        }\n    }\n    dp[0][0][0] = a[0][0];\n    for(int i = 1; i <= H+W-2; i++){\n        for(int j = 0; j < W; j++){\n            if(i-j < 0 || i-j >= H) continue;\n            for(int k = 0; k < W; k++){\n                if(i-k < 0 || i-k >= H) continue;\n                if(j > 0 && k > 0) dp[i][j][k] = dp[i-1][j-1][k-1];\n                if(i-j-1 >= 0 && k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]);\n                if(i-k-1 >= 0 && j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]);\n                if(i-j-1 >= 0 && i-k-1 >= 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n                               \n                if(j == k) dp[i][j][k] += a[i-j][j];\n                else dp[i][j][k] += (a[i-j][j]+a[i-k][k]);\n                //cout << i <<  ' ' << j <<  ' ' << k << ' ' << dp[i][j][k] << endl;\n            }\n        }\n    }\n    cout << dp[H+W-2][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n#include <ctype.h>\nusing namespace std;\nint a,b,h,k=0;\nint main() {\n\tcin >> a >> b;\n\twhile (cin>>h)\n\t{\n\t\tk += h;\n\t}\n\tcout << k<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint dp[201][201][402];\nint a[201][201];\n\nint h,w;\n\n\nint dfs(int x1,int x2,int k){\n    if(~dp[x1][x2][k]) return dp[x1][x2][k];\n    int ret = (x1==x2?a[k-x1][x1]:a[k-x1][x1]+a[k-x2][x2]);\n    int t = 0;\n    if(k==h+w) return ret;\n    if(x1+1<w&&x2+1<w) chmax(t, dfs(x1+1,x2+1,k+1));\n    if(k+1-x1<h&&x2+1<w) chmax(t, dfs(x1,x2+1,k+1));\n    if(x1+1<w&&k+1-x2<h) chmax(t, dfs(x1+1,x2,k+1));\n    if(k+1-x1<h&&k+1-x2<h) chmax(t, dfs(x1,x2,k+1));\n    ret += t;\n    return dp[x1][x2][k] = ret;\n}\n\n\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> a[i][j];\n        }\n    }\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n#define int long long\n\ntypedef pair<int,int> P;\nstruct edge {int to,cap,cost,rev;};\nconst int MAX_V=10100;\nint V;\t\t\t//代入!!\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nint top[MAX_V];\nint s,t,l,r;\nvoid add_edge(int from, int to, int cap, int cost){\n//\tprintf(\"%d->%d  cap=%d,cost=%d\\n\",from,to,cap,cost);\n\tedge e1={to,cap,cost,(int)G[to].size()},e2={from,0,-cost,(int)G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nint min_cost_flow(int s, int t, int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\trep(i,V){\n\t\tint v=top[i];\n\t\trep(j,G[v].size()){\n\t\t\tedge &e=G[v][j];\n\t\t\tif(e.cap==0) continue;\n\t\t\tint u=e.to;\n\t\t\th[u]=min(h[u],h[v]+e.cost);\n\t\t}\n\t}\n//\trep(i,V) printf(\"h[%d]=%d\\n\",i,h[i]);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nvoid mainmain(){\n\tint H,W;\n\tcin>>H>>W;\n\tvvint vv;\n\tint off = H*W;\n\tV = H*W+off+2;\n\tinitvv(vv,H,W);\n\tint source = H*W+off;\n\tint sink = H*W+off+1;\n\tif(H==W && H == 1){\n\t\tint t;\n\t\tcin>>t;\n\t\tcout<<t<<endl;\n\t\treturn;\n\t}\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>vv[i][j];\n\t\t}\n\t}\n\tint ans = vv[0][0] + vv[H-1][W-1];\n\tvv[0][0] = 0;\n\tvv[H-1][W-1] = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tint s = i*W+j;\n\t\t\tif(i||j){\n\t\t\t\tadd_edge(i*W+j, i*W+j+off, 1, 0);\n\t\t\t\ts += off;\n\t\t\t}\n\t\t\tif(i+1<H){\n\t\t\t\tadd_edge(s, i*W+W+j, 1, -vv[i+1][j]), add_edge(s, i*W+W+j, 1, 0);\n\t\t\t}\n\t\t\tif(j+1<W){\n\t\t\t\tadd_edge(s, i*W+j+1, 1, -vv[i][j+1]), add_edge(s, i*W+j+1, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\tadd_edge(source, 0, 1, -vv[0][0]);\n\tadd_edge(source, 0, 1, 0);\n\tadd_edge(H*W-1, sink, 2, 0);\n\tcout << -min_cost_flow(source, sink, 2) + ans << endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\n#define ll long long\nconst ll MOD = 1000000007;\n\nll sc[203][203];\nll dp[400][200][200];\nmap<pair<ll, ll>, ll> bef, aft;\n\nint main() {\n\tfor (ll i = 0;i < 203;i++)for (ll j = 0;j < 203;j++)sc[i][j] = INT64_MIN / 5;\n\tll H, W;\n\tcin >> H >> W;\n\tfor (ll i = 0;i < H;i++) {\n\t\tfor (ll j = 0;j < W;j++) {\n\t\t\tcin >> sc[i][j];\n\t\t}\n\t}\n\n\tpriority_queue<pair<ll,pair<ll, ll>>> Q;\n\tqueue<pair<ll, pair<ll, ll>>> NQ;\n\tQ.push({ sc[0][0],{0,0} });\n\tll e8, sq, h, w, t = 0;\n\n\twhile (!Q.empty()) {\n\t\twhile (!Q.empty()) {\n\t\t\tauto x = Q.top().second;\n\t\t\tll y = Q.top().first;\n\t\t\tQ.pop();\n\t\t\tif (y < 0)continue;\n\t\t\ttie(e8, sq) = x;\n\t\t\tif (dp[t][e8][sq] >= y)continue;\n\t\t\tdp[t][e8][sq] = y;\n\t\t\t\n\t\t\tif (e8 == sq) {\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8],{e8 + 1,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq][t - sq + 1],{e8 + 1,sq} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq + 1][t - sq],{e8,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1],{e8,sq} });\n\t\t\t}\n\t\t\telse if (e8 + 1 == sq) {\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq + 1][t - sq],{e8 + 1,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8],{e8 + 1,sq} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq + 1][t - sq],{e8,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq][t - sq + 1],{e8,sq} });\n\t\t\t}\n\t\t\telse if (sq + 1 == e8) {\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq + 1][t - sq],{e8 + 1,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq][t - sq + 1],{e8 + 1,sq} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1],{e8,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq][t - sq + 1],{e8,sq} });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq + 1][t - sq],{e8 + 1,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8 + 1][t - e8] + sc[sq][t - sq + 1],{e8 + 1,sq} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq + 1][t - sq],{e8,sq + 1} });\n\t\t\t\tNQ.push({ y + sc[e8][t - e8 + 1] + sc[sq][t - sq + 1],{e8,sq} });\n\t\t\t}\n\t\t}\n\t\twhile (!NQ.empty()) {\n\t\t\tauto x = NQ.front();\n\t\t\tNQ.pop();\n\t\t\tQ.push(x);\n\t\t}\n\t\tt++;\n\t}\n\tcout << dp[H + W - 2][H - 1][H - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <fstream>\n#include <unistd.h>\n#include <string.h>\n#include <string>\n#include <numeric>\n#include <queue>\n#include <deque>\n#include <sstream>\n#include <iomanip>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <functional>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<vvvl> vvvvl;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef long double LD;\ntypedef vector<LD> vld;\ntypedef vector<pair<LD, LD>> vpld;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> vpl;\ntypedef vector<vector<PL>> vvpl;\ntypedef vector<vvpl> vvvpl;\ntypedef pair<ll, PL> TL;\ntypedef vector<TL> vtl;\ntypedef vector<vtl> vvtl;\ntypedef long double ld;\ntypedef vector<ld> vld;\nconst ll LINF = 1e17;\nconst double pi = 3.1415926535897932;\nconst string endstr = \"\\n\";\n#define FOR(i, a, b) for(ll i = (a); i < b; i++)\n#define RFOR(i, a, b) for(ll i = (a); i > b; i--)\n#define rep(i, n) for(ll i = 0; i < n; i++)\n#define rrep(i, n) for(ll i = n-1; i > -1; i--)\n#define FORMAP(it, m) for(auto it = m.begin(); it != m.end(); it++)\n#define ff first\n#define ss second\n#define pb push_back\n#define epb emplace_back\n#define ALL(X) (X).begin(),(X).end()\n\ntemplate <typename T> T gcd(T a, T b) {return (a == 0) ? b : gcd(b%a, a);}\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b;}\n\nbool p_comp_fs(const PL p1, const PL p2){ return p1.first < p2.first;};\nbool p_comp_fg(const PL p1, const PL p2){ return p1.first > p2.first;};\nbool p_comp_ss(const PL p1, const PL p2){ return p1.second < p2.second;};\nbool p_comp_sg(const PL p1, const PL p2){ return p1.second > p2.second;};\ntemplate <typename T>\nvector<T> uniquen(vector<T> vec /* copy */){\n    sort(ALL(vec)); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec;\n}\n\ninline ll popcnt(ll x){return __builtin_popcountll((unsigned long long)x);};\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\n//friend bool operator<(const tpl& lhs, const tpl& rhs){\n//    return std::tie(lhs.l, lhs.r) < std::tie(rhs.l, rhs.r);\n//}\n\nbool bit(ll st, ll b){return ((st>>b)&1) == 1;}\n\nll H, W;\nll dp[210][210][420];\nvvl A;\n\nvl dh = {1, 0};\n\nbool ok(ll h, ll w){\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\n\nll dfs(ll eh, ll sh, ll sum){\n    if(dp[eh][sh][sum] > -1) return dp[eh][sh][sum];\n    if(eh >= H || sh >= H || sum-eh >= W || sum-sh >= W || sum > H-1+W-1) return 0;\n    rep(i, 2) rep(j, 2){\n        ll nhe = eh+dh[i], nwe = sum+1-nhe;\n        ll nhs = sh+dh[j], nws = sum+1-nhs;\n//        if(!ok(nhe, nwe)  || !ok(nhs, nws)) continue;\n        if(eh == sh){\n            chmax(dp[eh][sh][sum], dfs(nhe, nhs, sum+1) + A[eh][sum-eh]);\n        }\n        else{\n            chmax(dp[eh][sh][sum], dfs(nhe, nhs, sum+1) + A[eh][sum-eh] + A[sh][sum-sh]);\n        }\n    }\n    return dp[eh][sh][sum];\n}\n\n\nint main(){\n#ifdef __DEBUG_LOCAL__\n    ifstream file(\"../../../../../in.txt\"); if(file.is_open()) cin.rdbuf(file.rdbuf());\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n    \n    memset(dp, -1, sizeof(dp));\n    cin >> H >> W;  A = vvl(H, vl(W, 0));\n    rep(i, H) rep(j, W) cin >> A[i][j];\n    cout << dfs(0, 0, 0) << endstr;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int h,w;\n  cin>>h>>w;\n  vector<vector<int> > vec(h, vector<int>(w));\n  rep(i,h) rep(j,w) cin>>vec[i][j];\n  vector<vector<int> > v(h+w, vector<int>(max(h,w),-1));\n  rep(k,h+w-1){\n    int i=k,j=0;\n    if(k>=h){ i=h-1; j=k-h+1;}\n    int d=j;\n    while(i>=0 && j<w){\n      v[k][d] = vec[i][j];\n      i--;j++;d++;\n    }\n  }\n\n  int d=w;\n  vector<vector<int>> prev(d,vector<int>(d,-1));\n  prev[0][0]=0;\n  rep(k, h+w-1){\n    vector<vector<int>> nxt(d,vector<int>(d,-1));\n    rep(j,d)rep(i,j+1)if(prev[i][j]>=0){\n      auto c = [&](int a,int b){\n        if(v[k][a]<0 || v[k][b]<0) return -INF;\n        else if(a==b) return v[k][a];\n        else return v[k][a]+v[k][b];\n      };\n      nxt[i][j] = max(nxt[i][j], prev[i][j]+c(i,j));\n      if(i+1<=j) nxt[i+1][j] = max(nxt[i+1][j], prev[i][j]+c(i+1,j));\n      if(j+1<d){\n        nxt[i+1][j+1] = max(nxt[i+1][j+1], prev[i][j]+c(i+1,j+1));\n        nxt[i][j+1] = max(nxt[i][j+1], prev[i][j]+c(i,j+1));\n      }\n    }\n    swap(prev,nxt);\n  }\n\n  cout << prev[d-1][d-1] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint dp[200][200][200];\nint a, b;\nint c[30][30];\nint dx[2] = { -1,0 }, dy[2] = { 0,-1 };\nint saiki(int d, int e, int f, int g) {\n\tif (dp[d][e][f] != -1)return dp[d][e][f];\n\tfor (int h = 0; h < 2; h++) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tint n = d + dx[h], m = e + dy[h];\n\t\t\tif (n < 0 || m < 0)continue;\n\t\t\tint x = f + dx[i], y = g + dy[i];\n\t\t\tif (x < 0 || y < 0)continue;\n\t\t\tint S = saiki(n, m, x, y);\n\t\t\tS += c[d][e]; S += c[f][g];\n\t\t\tif (d == f&&e == g)S -= c[d][e];\n\t\t\tdp[d][e][f] = max(dp[d][e][f], S);\n\t\t}\n\t}\n\treturn dp[d][e][f];\n}\nsigned main() {\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> a >> b;\n\tfor (int d = 0; d < a; d++) {\n\t\tfor (int e = 0; e < b; e++) {\n\t\t\tcin >> c[d][e];\n\t\t}\n\t}\n\tdp[0][0][0] = c[0][0];\n\tcout << saiki(a - 1, b - 1, a - 1, b - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint a[200][200];\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    REP(i,h) REP(j,w) cin >> a[i][j];\n\n    int ans = 0;\n    REP(i,2) REP(j,w) ans += a[i][j];\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <map>\n#include <set>\n#include <array>\n#include <queue>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#define MOD 1000000007\n#define INF 11234567890\n#define in std::cin\n#define out std::cout\n#define rep(i,N) for(LL i=0;i<N;++i)\ntypedef long long int LL;\ntypedef std::pair<int, int> P;\n\nint H, W, a[212][212];\nLL ans;\n\nint main()\n{\n\tin >> H >> W;\n\trep(i, H) { rep(j, W) { in >> a[i][j]; } }\n\n\trep(i, H)\n\t{\n\t\trep(j, W)\n\t\t{\n\t\t\tans += a[i][j];\n\t\t}\n\t}\n\n\tout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint H,W;\nint A[200];\nint dp[200][200];\nmain()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<W;i++)for(int j=0;j<W;j++)dp[i][j]=-1e9;\n\tdp[0][1]=0;\n\tfor(int _=0;_<H;_++)\n\t{\n\t\tfor(int i=0;i<W;i++)scanf(\"%d\",&A[i]);\n\t\tfor(int i=0;i<W;i++)for(int j=i+1;j<W;j++)\n\t\t{\n\t\t\tdp[i][j]+=A[i];\n\t\t\tif(i+1<j)dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t}\n\t\tfor(int i=0;i<W;i++)for(int j=i+1;j<W;j++)\n\t\t{\n\t\t\tdp[i][j]+=A[j];\n\t\t\tif(j+1<W)dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i+1<W;i++)ans=max(ans,dp[i][W-1]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nll a[222][222],b[222][222],dp[222][222];\n\nvoid Main() {\n  ll n,m;\n  cin >> n >> m;\n  if(n>7) return;\n  rep(i,n)rep(j,m) R a[i][j];\n  vector<ll> c(n+m);\n  rep(i,n+m)c[i]=i>=n;\n  ll ans=0;\n  do {\n    rep(i,n)rep(j,m)b[i][j]=a[i][j];\n    ll x=0,y=0,sum=0;\n    sum+=b[0][0];\n    b[0][0]=0;\n    rep(i,n+m) {\n      if(!c[i]) x++;\n      else y++;\n      sum+=b[x][y];\n      b[x][y]=0;\n    }\n    mem(dp);\n    REP(i,1,n+1) {\n      REP(j,1,m+1) {\n        dp[i][j]=max(dp[i][j],max(dp[i-1][j],dp[i][j-1])+b[i-1][j-1]);\n      }\n    }\n    ans=max(ans,sum+dp[n][m]);\n  } while(next_permutation(all(c)));\n  pr(ans);\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nint dp[401][401][401],dx[2]={0,1},dy[2]={1,0};\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n][m];\n  for(int i=0; i<n; i++)for(int j=0; j<m; j++) cin >> a[i][j];\n  for(int i=0;i<555;i++)for(int j=0;j<555;j++)for(int k=0;k<555;k++)dp[i][j][k]=-(1<<29);\n  dp[0][0][0]=a[0][0];\n  for(int i=0; i<n+m-2; i++) {\n    for(int j=0; j<n+m; j++) {\n      int x1,y1,x2,y2;\n      if(i<m) x1=0,y1=i;\n      else x1=i-m+1,y1=m-1;\n      x1+=j,y1-=j;\n      if(!check(n,m,x1,y1)) break;\n      for(int k=j; k<n+m; k++) {\n        if(i<m) x2=0,y2=i;\n        else x2=i-m+1,y2=m-1;\n        x2+=k,y2-=k;\n        if(!check(n,m,x2,y2)) break;\n        if(dp[i][j][k]==-(1<<29)) continue;\n        for(int l=0; l<2; l++) {\n          int xx1=x1+dx[l],yy1=y1+dy[l];\n          if(!check(n,m,xx1,yy1)) continue;\n          for(int l2=0; l2<2; l2++) {\n            int xx2=x2+dx[l2],yy2=y2+dy[l2];\n            if(!check(n,m,xx2,yy2)) continue;\n            int c=a[xx1][yy1]+a[xx2][yy2];\n            if(xx1==xx2&&yy1==yy2) c/=2;\n            int x=xx1,y=xx2;\n            if(i+1>=m) x-=i-m+2,y-=i-m+2;\n            dp[i+1][x][y]=max(dp[i+1][x][y],dp[i][j][k]+c);\n          }\n        }\n      }\n    } \n  }\n  cout << dp[n+m-2][0][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\n#define int long long\nint dp[201][201][500];\nint grid[201][201];\n#undef int\nint main() {\n#define int long long\n\tint h, w;\n\tcin >> h >> w;\n\tint hoge = 0;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tcin >> grid[i][q];\n\t\t\thoge += grid[i][q];\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < h + w-2; ++i) {\n\t\tfor (int q = 0; q <= i; ++q) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tint first_x = q;\n\t\t\t\tint first_y = i - q;\n\t\t\t\tint second_x = j;\n\t\t\t\tint second_y = i - j;\n\t\t\t\tREP(t, 2) {\n\t\t\t\t\tREP(p, 2) {\n\t\t\t\t\t\tint next_fx = first_x + t;\n\t\t\t\t\t\tint next_fy = first_y + 1 - t;\n\t\t\t\t\t\tint next_sx = second_x + p;\n\t\t\t\t\t\tint next_sy = second_y + 1 - p;\n\t\t\t\t\t\tif (next_fx >= h || next_sx >= h | next_fy >= w | next_sy >= w) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint winning = dp[q][j][i] + grid[next_fx][next_fy];\n\t\t\t\t\t\tif (next_fx != next_sx || next_fy != next_sy) {\n\t\t\t\t\t\t\twinning += grid[next_sx][next_sy];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next_fx][next_sx][next_fx + next_fy] = max(dp[next_fx][next_sx][next_fx + next_fy], winning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(hoge >= dp[h - 1][h - 1][h + w - 2]);\n\tcout << dp[h - 1][h - 1][h + w - 2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <cassert>\n#define SIZE 205\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint dp[2][SIZE][SIZE];\nint A[SIZE][SIZE];\n\nint main()\n{\n\tint h,w;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&A[i][j]);\n\t\t}\n\t}\n\tint pos=0;\n\tmemset(dp,-1,sizeof(dp));\n\tdp[pos][0][0]=A[0][0];\n\tfor(int i=1;i<=h+w-2;i++)\n\t{\n\t\tpos^=1;\n\t\tmemset(dp[pos],-1,sizeof(dp[pos]));\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tfor(int k=0;k<w;k++)\n\t\t\t{\n\t\t\t\tif(dp[pos^1][j][k]==-1) continue;\n\t\t\t\tfor(int x=j;x<=j+1;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=k;y<=k+1;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint s=i-x,t=i-y;\n\t\t\t\t\t\tif(s<0||s>=h||t<0||t>=h||x>=w||y>=w) continue;\n\t\t\t\t\t\tdp[pos][x][y]=max(dp[pos][x][y],dp[pos^1][j][k]+A[s][x]+(s==t?0:A[t][y]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[pos][w-1][w-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nint dp[555][555][555],dx[2]={0,1},dy[2]={1,0};\nint main() {\n  int n,m;\n  cin >> n >> m;\n  int a[n][m];\n  for(int i=0; i<n; i++)for(int j=0; j<m; j++) cin >> a[i][j];\n  for(int i=0;i<555;i++)for(int j=0;j<555;j++)for(int k=0;k<555;k++)dp[i][j][k]=-(1<<29);\n  dp[0][0][0]=a[0][0];\n  for(int i=0; i<n+m-2; i++) {\n    for(int j=0; j<n+m; j++) {\n      int x1,y1,x2,y2;\n      if(i<m) x1=0,y1=i;\n      else x1=i-m+1,y1=m-1;\n      x1+=j,y1-=j;\n      if(!check(n,m,x1,y1)) break;\n      for(int k=j; k<n+m; k++) {\n        if(i<m) x2=0,y2=i;\n        else x2=i-m+1,y2=m-1;\n        x2+=k,y2-=k;\n        if(!check(n,m,x2,y2)) break;\n        if(dp[i][j][k]==-(1<<29)) continue;\n        for(int l=0; l<2; l++) {\n          int xx1=x1+dx[l],yy1=y1+dy[l];\n          if(!check(n,m,xx1,yy1)) continue;\n          for(int l2=0; l2<2; l2++) {\n            int xx2=x2+dx[l2],yy2=y2+dy[l2];\n            if(!check(n,m,xx2,yy2)) continue;\n            int c=a[xx1][yy1]+a[xx2][yy2];\n            if(xx1==xx2&&yy1==yy2) c/=2;\n            int x=xx1,y=xx2;\n            if(i+1>=m) x-=i-m+2,y-=i-m+2;\n            dp[i+1][x][y]=max(dp[i+1][x][y],dp[i][j][k]+c);\n          }\n        }\n      }\n    } \n  }\n  cout << dp[n+m-2][0][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\n#define rc(x) return cout<<x<<endl,0\n#define pb push_back\n#define in insert\n#define er erase\n#define fd find\n#define fr first\n#define sc second\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nconst ll llinf=(1LL<<62);\nconst int inf=(1<<30);\nconst int nmax=1e5+50;\nconst int mod=1e9+7;\nusing namespace std;\nint n,m,i,v,u,x,y,t,p,j,b;\nll a[205][205],f[2][205][205];\nint main()\n{\n\t//freopen(\"sol.in\",\"r\",stdin);\n\t//freopen(\"sol.out\",\"w\",stdout);\n\t//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tios_base::sync_with_stdio(false);cin.tie(0);cerr.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(i=1;i<=n;i++)for(j=1;j<=m;j++)cin>>a[i][j];\n\tfor(i=1;i<=n+m-1;i++)\n\t{\n\t\tmemset(f[i&1],0,sizeof(f[i&1]));\n\t\tfor(x=1;x<=n;x++)\n\t\t{\n\t\t\tfor(y=1;y<=n;y++)\n\t\t\t{\n\t\t\t\tv=i-x+1,u=i-y+1;\n\t\t\t\tif(v<=0 || u<=0)continue;\n\t\t\t\tfor(t=-1;t<1;t++)\n\t\t\t\t{\n\t\t\t\t\tfor(p=-1;p<1;p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[i&1][x][y]=max(f[i&1][x][y],f[i&1^1][x+t][y+p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i&1][x][y]+=a[x][v]+a[y][u];\n\t\t\t\tif(x==y && v==u)f[i&1][x][y]-=a[x][v];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[(n+m-1)&1][n][n]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 16-11-20_chu2_D.cpp\n *\n *  Created on: 2016/11/29\n *      Author: ryoma\n */\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint field[201][201];\nint H,W;\n\nint dp[201][201][410];\n\nint rs[4]={0,0,1,1},re[4] = {0,1,0,1};\n\nint dfs(int sj,int ej,int d){\n\tif(sj>W||ej>W||d>H+W)\n\t\treturn 0;\n\tif(dp[sj][ej][d]>0){\n\t\treturn dp[sj][ej][d]-1;\n\t}\n\tint res=0;\n\tfor(int i=0;i<4;i++){\n\tres = max(res,dfs(sj+rs[i],ej+re[i],d+1));\n\t}\n\tres += field[d-sj][sj] + field[d-ej][ej];\n\tif(sj == ej)\n\t\tres -= field[d-sj][sj];\n\tdp[sj][ej][d] = res+1;\n\treturn res;\n}\n\nint main(){\n\tcin >> H >> W;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin >> field[i][j];\n\t\t}\n\t}\n\tcout << dfs(0,0,0) << endl;\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n#include <chrono>\n#include <random>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nconst int MAX_H = 210;\nconst int MAX_W = 210;\nusing State = pair<LL, PII>; // <score, (h, w)>\nint H, W;\nVVI a;\n\nint dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nint main(void) {\n    scanf(\"%d%d\", &H, &W);\n    a.resize(H, VI(W));\n    for_each(ALL(a), [](auto &v) {\n        for_each(ALL(v), [](int &e){scanf(\"%d\", &e);});\n    });\n    assert(H <= 30 && W <= 30);\n    dp[0][0][0][0] = a[0][0];\n    REP(eh, H) REP(ew, W) REP(sh, H) REP(sw, W) {\n        if (eh == 0 && ew == 0 && sh == 0 && sw == 0) continue;\n        LL buf = 0;\n        if (eh && sh) buf = max(buf, dp[eh - 1][ew][sh - 1][sw]);\n        if (eh && sw) buf = max(buf, dp[eh - 1][ew][sh][sw - 1]);\n        if (ew && sw) buf = max(buf, dp[eh][ew - 1][sh][sw - 1]);\n        if (ew && sh) buf = max(buf, dp[eh][ew - 1][sh - 1][sw]);\n        if (eh == sh && ew == sw) dp[eh][ew][sh][sw] = buf + a[sh][sw];\n        else dp[eh][ew][sh][sw] = buf + a[eh][ew] + a[sh][sw];\n    }\n    cout << dp[H - 1][W - 1][H - 1][W - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\n#include <complex>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\nconst int MN = 220;\nint h, w;\nll g[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nll dp[MN][MN][MN];\nbool used[MN][MN][MN] = {};\n\nll solve(int d, int ax, int bx) {\n    int ay = d-ax, by = d-bx;\n    if (!bc(ax, ay) || !bc(bx, by)) return -TEN(15);\n    if (d == h+w-2) return g[ay][ax];\n    if (used[d][ax][bx]) return dp[d][ax][bx];\n    used[d][ax][bx] = true;\n    ll &ans = dp[d][ax][bx];\n    ans = -TEN(15);\n    ans = max(ans, solve(d+1, ax, bx));\n    ans = max(ans, solve(d+1, ax+1, bx));\n    ans = max(ans, solve(d+1, ax, bx+1));\n    ans = max(ans, solve(d+1, ax+1, bx+1));\n    ans += g[ay][ax] + g[by][bx];\n    if (ax == bx) {\n        ans -= g[ay][ax];\n    }\n    return ans;\n}\n\nint main() {\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> g[i][j];\n        }\n    }\n    cout << solve(0, 0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\nconst ll INF=1e13;\nll a[222][222];\nll dp[422][222][222];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m;\n  cin>>n>>m;\n  rep(i,n)rep(j,m) cin>>a[i][j];\n  fill(dp[0][0],dp[0][0]+422*222*222,-INF);\n  dp[0][0][0]=0;\n  rep(i,n+m-1)rep(j,m)rep(k,j+1){\n    if(i-j>=0){\n      dp[i][j][k]+=a[i-j][j];\n      if(j!=k) dp[i][j][k]+=a[i-k][k];\n    }\n    rep(a,2)rep(b,2) MX(dp[i+1][j+a][k+b],dp[i][j][k]);\n  }\n  cout<<dp[n+m-2][m-1][m-1]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<30);\nconst int MAX = 100000;\nconst int MAX_V = 50000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , INF, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, INF, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 209\nusing namespace std;\nint n,m;\nint a[maxn][maxn];\nlong long dp[maxn][maxn][maxn];\nint dx[]={1,0};\nint dy[]={0,1};\nconst long long INF=1e18;\nbool in(int x,int y){\n    return 1<=x&&x<=n&&1<=y&&y<=m;\n}\nlong long dfs(int x,int y,int z){\n    if(!in(x,y)||!in(z,x+y-z))\n        return -INF;\n    if(x==n&&y==m&&z==n)\n        return a[x][y];\n    long long &ans=dp[x][y][z];\n    if(ans!=-1) return ans;\n    int add;\n    if(x==z)\n        add=a[x][y];\n    else\n        add=a[x][y]+a[z][x+y-z];\n    ans=0;\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            ans=max(ans,dfs(x+dx[i],y+dy[i],z+dx[j]));\n        }\n    }\n    ans+=add;\n    return ans;\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            cin>>a[i][j];\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(1,1,1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t dp[500][210][210] = {};\nint dj[4] = {1, 1, 0, 0};\nint dk[4] = {0, 1, 0, 1};\n\nint main(){\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> a(H, vector<int>(W));\n    for(auto& c : a) for(auto & i : c){\n        cin >> i;\n    }\n\n    dp[0][0][0] = a[0][0];\n    for(int i = 0; i < H + W; ++i){\n        for(int j = 0; j <= min(i, W-1); ++j){\n            for(int k = 0; k <= min(i, W-1); ++k){\n                for(int l = 0; l < 4; ++l){\n                    int nj = j + dj[l];\n                    int nk = k + dk[l];\n                    if(nj >= W || nk >= W || (i+1-nj) >= H || (i+1-nk) >= H) continue;\n                    if(nk == nj){\n                        dp[i+1][nj][nk] = max(dp[i+1][nj][nk], dp[i][j][k] + a[i-nj+1][nj]);\n                    } else {\n                        dp[i+1][nj][nk] = max(dp[i+1][nj][nk], dp[i][j][k] + a[i-nj+1][nj] + a[i-nk+1][nk]);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[H+W-2][W-1][W-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint board[222][222];\nint dp[222][222][222][2];\nint H, W;\n\nint dfs(int row, int col1, int col2, int flag) {\n\tint& ret = dp[row][col1][col2][flag];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tif (row == H+1) return ret;\n\tif (flag == 0) {\n\t\t// 左の人が右に移動\n\t\tif (col1+1 < col2) {\n\t\t\tret = max(ret, board[row][col1+1] + dfs(row, col1+1, col2, 0));\n\t\t}\n\t\tret = max(ret, dfs(row, col1, col2, 1));\n\t} else {\n\t\t// 右の人が右に移動\n\t\tif (col2 < W+1) {\n\t\t\tret = max(ret, board[row][col2+1] + dfs(row, col1, col2+1, 1));\n\t\t}\n\t}\n\t// 一段下に移動\n\tret = max(ret, board[row+1][col1] + board[row+1][col2] + dfs(row+1, col1, col2, 0));\n\treturn ret;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 1; i <= H; i++) for (int j = 1; j <= W; j++)\n\t\tcin >> board[i][j];\n\tmemset(dp, -1, sizeof(dp));\n\tcout << dfs(0, 0, 1, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int> > a(h, vector<int>(w));\n    for(int y=0; y<h; ++y){\n        for(int x=0; x<w; ++x){\n            cin >> a[y][x];\n        }\n    }\n\n    vector<vector<int> > dp(w, vector<int>(w, 0));\n    for(int y=0; y<h; ++y){\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1; x2<w; ++x2){\n                dp[x1][x2] += a[y][x1];\n                if(x1 != x2)\n                    dp[x1][x2] += a[y][x2];\n            }\n        }\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1; x2<w; ++x2){\n                if(x1 < x2 - 1)\n                    dp[x1+1][x2] = max(dp[x1+1][x2], dp[x1][x2] + a[y][x1+1]);\n            }\n        }\n        for(int x1=0; x1<w; ++x1){\n            for(int x2=x1; x2<w; ++x2){\n                if(x2 < w - 1)\n                    dp[x1][x2+1] = max(dp[x1][x2+1], dp[x1][x2] + a[y][x2+1]);\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int x1=0; x1<w; ++x1){\n        for(int x2=x1; x2<w; ++x2){\n            ans = max(ans, dp[x1][x2]);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int tx[] = {0, 1}, ty[] = {1, 0};\nint n, m, mat[205][205];\nint dp[205][205][205];\ninline int dfs(int x1, int y1, int x2, int y2) {\n\tif (~dp[x1][y1][x2]) return dp[x1][y1][x2];\n\tint ret = 0, X1, Y1, X2, Y2;\n\trep (i, 0, 1) {\n\t\tX1 = x1 + tx[i];\n\t\tY1 = y1 + ty[i];\n\t\trep (j, 0, 1) {\n\t\t\tX2 = x2 + tx[j];\n\t\t\tY2 = y2 + ty[j];\n\t\t\tif (X1 == X2) continue;\n\t\t\tif (~mat[X1][Y1] && ~mat[X2][Y2])\n\t\t\tret = max(ret, dfs(X1, Y1, X2, Y2));\n\t\t}\n\t}\n\treturn dp[x1][y1][x2] = ret + mat[x1][y1] + mat[x2][y2];\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tcin >> n >> m;\n\tmemset(mat, -1, sizeof(mat));\n\trep (i, 1, n) {\n\t\trep (j, 1, m) {\n\t\t\tcin >> mat[i][j];\n\t\t}\n\t}\n\tif (n < 3 || m < 3) {\n\t\tint ans = 0;\n\t\trep (i, 1, n) {\n\t\t\trep (j, 1, m) {\n\t\t\t\tans += mat[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tmemset(dp, -1, sizeof(dp));\n\tcout << dfs(1, 2, 2, 1) + mat[1][1] + mat[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[201][201];\nint h, w;\nll dp[402][202][202];\n\nvoid amax(ll &x, ll y)\n{\n\tx=max(x,y);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>h>>w;\n\tfor(int i = 1; i <= h; i++)\n\t{\n\t\tfor(int j = 1; j <= w; j++)\n\t\t{\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i = 1; i <= h + w; i++)\n\t{\n\t\tfor(int j = 1; j <= h; j++)\n\t\t{\n\t\t\tfor(int k = 1; k <= h; k++)\n\t\t\t{\n\t\t\t\tll v1 = dp[i-1][j-1][k-1]+a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) v1-=a[j][i-j];\n\t\t\t\tll v2 = dp[i-1][j][k-1]+a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) v2-=a[j][i-j];\n\t\t\t\tll v3 = dp[i-1][j-1][k]+a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) v3-=a[j][i-j];\n\t\t\t\tll v4 = dp[i-1][j][k]+a[j][i-j] + a[k][i-k];\n\t\t\t\tif(j==k) v4-=a[j][i-j];\n\t\t\t\tamax(dp[i][j][k], v1);\n\t\t\t\tamax(dp[i][j][k],v2);\n\t\t\t\tamax(dp[i][j][k],v3);\n\t\t\t\tamax(dp[i][j][k],v4);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h+w][h][h] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long int\nusing namespace std;\n\nint h, w, a1[410][410], a2[410][410], dp[410][410][410];\n\nsigned main()\n{\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> a1[i][j];\n    }\n  }\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      a2[i + j][i - j + w] = a1[i][j];\n    }\n  }\n\n  dp[0][w][w] = a1[0][0];\n\n  for(int i = 1; i <= h + w - 2; i++){\n    for(int j = 1; j <= h + w - 1; j++){\n      for(int k = 1; k <= h + w - 1; k++){\n\tdp[i][j][k] = max({dp[i - 1][j - 1][k - 1], dp[i - 1][j - 1][k + 1], dp[i - 1][j + 1][k - 1], dp[i - 1][j + 1][k + 1]});\n\tif(j == k){\n\t  dp[i][j][k] += a2[i][j];\n\t}\n\telse{\n\t  dp[i][j][k] += a2[i][j] + a2[i][k];\n\t}\n      }\n    }\n  }\n  \n  cout << dp[h + w - 2][h][h] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint dp[201][201][402];\nint a[201][201];\n\nint h,w;\n\n\nint dfs(int x1,int x2,int k){\n    if(~dp[x1][x2][k]) return dp[x1][x2][k];\n    int ret = (x1==x2?a[k-x1][x1]:a[k-x1][x1]+a[k-x2][x2]);\n    int t = 0;\n    if(k==h+w) return ret;\n    if(x1+1<w&&x2+1<w) chmax(t, dfs(x1+1,x2+1,k+1));\n    if(x2+1<w) chmax(t, dfs(x1,x2+1,k+1));\n    if(x1+1<w) chmax(t, dfs(x1+1,x2,k+1));\n    chmax(t, dfs(x1,x2,k+1));\n    ret += t;\n    return dp[x1][x2][k] = ret;\n}\n\n\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> a[i][j];\n        }\n    }\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"algorithm\"\n#include \"string\"\n#include \"vector\"\n#include \"cmath\"\n#include \"bitset\"\n#include \"queue\"\n#include \"functional\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"set\"\n#include \"stack\"\n#include \"tuple\"\n\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 92233720368547758070\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define P pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint H,W,a[200][200],dp[400][200][200]={};\n\nint main(){\n\tcin>>H>>W;\n\tif(H==1||W==1){\n\t\tint ans=0;\n\t\tfor(int i=0;i!=H;++i)\n\t\t\tfor(int j=0;j!=W;++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tans+=a[i][j];\n\t\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i!=H;++i)\n\t\tfor(int j=0;j!=W;++j)\n\t\t\tcin>>a[i][j];\n\tfor(int i=1;i!=H+W-2;++i){\n\t\tfor(int j=max(0,i-H+1);j!=min(i,W-1);++j){\n\t\t\tfor(int k=j+1;k!=min(i+1,W);++k){\n\t\t\t\tif(j)\n\t\t\t\t\tdp[i][j][k]=max({dp[i-1][j][k],dp[i-1][j-1][k],dp[i-1][j][k-1],dp[i-1][j-1][k-1]})+a[i-j][j]+a[i-k][k];\n\t\t\t\telse\n\t\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j][k-1])+a[j][i-j]+a[k][i-k];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<a[0][0]+a[H-1][W-1]+dp[H+W-3][W-2][W-1]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<30);\nconst int MAX = 100000;\nconst int MAX_V = 10000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , INF, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, INF, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 500\nint a[maxn][maxn];\nint dp[maxn][maxn][maxn];\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][1] = a[1][1];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tfor (int k = 1; k <= i+j-1 && k<=w;k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t\tdp[i][j + 1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k], dp[i][j][k] + a[i + 1][j] + a[i + j - k + 1][k]);\n\t\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j+1][k+1] ,dp[i][j][k] +a[i][j + 1] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j == k + 1)\n\t\t\t\t{\t\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i+1][j][k+1], dp[i][j][k] + a[i + 1][j] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j + 1 == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j + 1] + a[i + j - k + 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[h][w][w] << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint a[205][205], dp[205][205][205];\nint h, w;\n\nint func(int sx, int sy, int ex, int ey) {\n  if(sx >= w || ex >= w || sy >= h || ey >= h) return -INF;\n  if(dp[sx][sy][ex] != -1) return dp[sx][sy][ex];\n  int res = 0;\n  res = max(res, func(sx, sy+1, ex+1, ey));\n  res = max(res, func(sx, sy+1, ex, ey+1));\n  res = max(res, func(sx+1, sy, ex+1, ey));\n  res = max(res, func(sx+1, sy, ex, ey+1));\n  if(sx == ex && sy == ey) res += a[sy][sx];\n  else res += a[sy][sx] + a[ey][ex];\n\n  // cout << sx << \" \" << sy << \" \" << ex << \" \" << ey << endl;\n  // cout << res << endl;\n  return dp[sx][sy][ex] = res;\n}\n\nsigned main(void)\n{\n  cin >> h >> w;\n  REP(i, h) REP(j, w) cin >> a[i][j];\n  REP(i, 205) REP(j, 205) REP(k, 205) dp[i][j][k] = -1;\n\n  cout << func(0, 0, 0, 0) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define pb push_back\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\n#define lb(a, b) lower_bound((a).begin(), (a).end(), (b))\n#define ub(a, b) upper_bound((a).begin(), (a).end(), (b))\n#define bitcnt(a) (ll) __builtin_popcount((a))\nusing namespace std;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> TP;\ntemplate <typename T> void fill_all(T &arr, const T &v) { arr = v; }\ntemplate <typename T, typename ARR> void fill_all(ARR &arr, const T &v) {\n  for (auto &i : arr) {\n    fill_all(i, v);\n  }\n}\n//------------------変数-----------------------//\n\n//-------------------関数----------------------//\nll h, w, grid[200][200], dp[500][200][200];\nint main() {\n  cin >> h >> w;\n  REP(i, h) {\n    REP(j, w) { cin >> grid[i][j]; }\n  }\n  REP(i, h + w) {\n    REP(X, w) {\n      for (ll x = i - X; x >= 0 && x < w;) {\n        if (X == x) {\n          dp[i + 1][X + 1][x] =\n              max(dp[i + 1][X + 1][x], grid[i - X][X] + dp[i + 1][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1], grid[i - X][X] + dp[i + 1][X][x]);\n          dp[i + 1][X + 1][x + 1] =\n              max(dp[i + 1][X + 1][x + 1], grid[i - X][X] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x], grid[i - X][X] + dp[i][X][x]);\n        } else {\n          dp[i + 1][X + 1][x] =\n              max(dp[i + 1][X + 1][x],\n                  grid[i - X][X] + grid[i - x][x] + dp[i + 1][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1],\n                  grid[i - X][X] + grid[i - x][x] + dp[i + 1][X][x]);\n          dp[i + 1][X + 1][x + 1] =\n              max(dp[i + 1][X + 1][x + 1],\n                  grid[i - X][X] + grid[i - x][x] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x],\n                                grid[i - X][X] + grid[i - x][x] + dp[i][X][x]);\n        }\n      }\n    }\n  }\n  cout << dp[h + w][w][w] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,T1,w;\n    cin >> H >> W;\n    w=H*W;\n    T1=0;\n    int array[w];\n    for(int i=0;i<w;i++){\n        cin >> array[i];\n        T1=T1+array[i];\n    }\n    cout << T1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto&youso_: (x) )cout<<youso_<<\" \";cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\ncin>>head;\nCINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define L list<int>\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\n/*\nll h,w,k;\nll Solve(vector<V> vec,int dan,int count,int point){\n    if(dan<0)return point;\n    bool wareware=true;\n    int ttttt=vec[dan][0];\n    REP(i,w)if(ttttt!=vec[dan][i])wareware=false;\n    if(!wareware)return point;\n\n    point+=(pow(2,count) * ttttt * w);\n    REPR(i,dan)REP(j,w)vec[i][j]=vec[i+1][j];\n    h--;\n    vec.erase(vec.begin()+(int)vec.size()-1);\n    return Solve(vec,dan-1,count+1,point);\n\n\n}\n\n*/\nint main(){\n\n    CIN(h,w);\n    vector<V> a(h,V(w));\n    FOREACH(aa,a)VECCIN(aa);\n    \n    COUT(accumulate(ALL(a[0]),0)+accumulate(ALL(a[1]),0));\n    /*\n    cin>>h>>w>>k;\n    vector<V> c(h,V(w));\n    REP(i,h){\n        SCIN(str);\n        REP(j,w){\n            c[i][j]=(int)str[j]-48;\n        }\n    }\n\n    ll ans=0;\n    REP(i,h){\n        ans = max(ans,Solve(c,i,0,0));\n    }\n    COUT(ans);\n    */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=405,INF=1<<30;\nll dp[MAX][MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int H,W;cin>>H>>W;\n    vector<vector<ll>> S(H,vector<ll>(W));\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n        }\n    }\n    \n    for(int s=2;s<=H+W;s++){\n        for(int a=1;a<=H;a++){\n            if(1<=s-a&&s-a<=W){\n                for(int b=1;b<=H;b++){\n                    if(1<=s-b&&s-b<=W){\n                        if(a==b){\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]);\n                            }\n                        }else{\n                            for(int bit=0;bit<4;bit++){\n                                dp[s][a][b]=max(dp[s][a][b],dp[s-1][a-bit/2][b-bit%2]+S[a-1][s-a-1]+S[b-1][s-b-1]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    cout<<dp[H+W][H][H]<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint h,w,a=0;\n\tcin>>h>>w;\n\tfor(int i=0;i<w*2;i++){cin>>h;a+=h;}\n\tcout<<a<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <utility>\nusing namespace std;\nint a[210][210];\nstruct E {\n\tint to, cap, co, rev;\n};\nvector<E> e[80010];\nconst int C = 40010;\nvoid add_edge(int f, int t, int c, int ca) {\n\te[f].push_back((E){t, ca, c, (int)e[t].size()});\n\te[t].push_back((E){f, 0, -c, (int)e[f].size()-1});\n}\nlong long h[80010],  d[80010];\nlong long prevv[80010], preve[80010];\nconst long long inf = 1ll << 50;\nint go(int f, int t) {\n\tint res = 0;\n\tint fl = 2;\n\twhile (fl) {\n\t\tfor (int i = 0; i < t + C; i++) {\n\t\t\td[i] = inf;\n\t\t}\n\t\td[f] = 0;\n\t\tpriority_queue<pair<int, int> > q;\n\t\tq.push(make_pair(0, f));\n\t\twhile (q.size()) {\n\t\t\tint x = q.top().second, z = -q.top().first;\n\t\t\tq.pop();\n\t\t\tif (d[x] < z) continue;\n\t\t\tfor (int i = 0; i < e[x].size(); i++) {\n\t\t\t\tE &ed = e[x][i];\n\t\t\t\tint y = ed.to;\n\t\t\t\tif (ed.cap > 0 && d[x] + ed.co + h[x] < d[y] + h[y]) {\n\t\t\t\t\td[y] = d[x] + ed.co + h[x] - h[y];\n\t\t\t\t\tprevv[y] = x;\n\t\t\t\t\tpreve[y] = i;\n\t\t\t\t\tq.push(make_pair(-d[y], y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < t + C; i++) {\n\t\t\th[i] += d[i];\n\t\t}\n\t\tint v = t;\n\t\twhile (v != f) {\n\t\t\tE &ed = e[prevv[v]][preve[v]];\n\t\t\ted.cap -= 1;\n\t\t\te[v][ed.rev].cap += 1;\n\t\t\tv = prevv[v];\n\t\t}\n\t\tres += h[t];\n\t\t--fl;\n\t}\n\treturn res;\n}\nint main() {\n\tint h, w;\n\tscanf(\"%d%d\", &h, &w);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\ta[i][j] = 100000 - a[i][j];\n\t\t\tif (i < h - 1) {\n\t\t\t\tadd_edge(i * w + j + C, i * w + w + j, 0, 1);\n\t\t\t}\n\t\t\tif (j < w - 1) {\n\t\t\t\tadd_edge(i * w + j + C, i * w + j + 1, 0, 1);\n\t\t\t}\n\t\t\tadd_edge(i * w + j, i * w + j + C, a[i][j], 1);\n\t\t}\n\t}\n\tlong long ans = 200000 - a[0][0] - a[h-1][w-1] + 200000ll * (h + w - 3) - go(C, (h - 1) * w + w - 1);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <deque>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define It iterator\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n\n\n#define maxn 55\nint m,n,a[maxn][maxn];\nint f[maxn*2][maxn][maxn];\nint main() {\n    //freopen(\"test.in\",\"r\",stdin);\n    cin>>m>>n;\n    for(int i=1; i<=m; i++) {\n        for(int j=1; j<=n; j++) cin>>a[i][j];\n    }\n    for(int k=1; k<=m+n; k++) {\n        for(int i=1; i<=k-1; i++) {\n            for(int j=1; j<=k-1; j++) {\n                int s1=0,s2=0;\n                    if(i!=j) {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i]+a[j][k-j];\n                    } else {\n                        s1=max(f[k-1][i-1][j],f[k-1][i][j-1]);\n                        s2=max(f[k-1][i][j],f[k-1][i-1][j-1]);\n                        f[k][i][j]=max(s1,s2)+a[i][k-i];\n                    }\n            }\n        }\n    }\n    cout<<f[m+n][m][m]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\n#define H 31\n#define W 31\n\nvoid print(int a[H][W], int h, int w){\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      std::cout << \" \" << a[i][j];\n    }\n    std::cout << std::endl;\n  }\n}\n\nint main(void){\n  int dp[H][W][H][W];\n  \n  int a[H][W];\n  int h,w;\n  std::cin >> h >> w;\n\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      std::cin >> a[i][j];\n    }\n  }\n\n  std::cout << a[0][0]+a[0][1]+a[1][0]+a[1][1] << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\n#define FOR(i, a, b) for (ll i = (signed)(a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define EREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define MOD 1000000007\n#define pb push_back\n#define INF 93193111451418101\n#define MIN -93193111451418101\n#define EPS 1e-11\n#define lb(a, b) lower_bound((a).begin(), (a).end(), (b))\n#define ub(a, b) upper_bound((a).begin(), (a).end(), (b))\n#define bitcnt(a) (ll) __builtin_popcount((a))\nusing namespace std;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> TP;\ntemplate <typename T> void fill_all(T &arr, const T &v) { arr = v; }\ntemplate <typename T, typename ARR> void fill_all(ARR &arr, const T &v) {\n  for (auto &i : arr) {\n    fill_all(i, v);\n  }\n}\n//------------------変数-----------------------//\n\n//-------------------関数----------------------//\nll h, w, grid[200][200], dp[500][200][200];\nint main() {\n  cin >> h >> w;\n  REP(i, h) {\n    REP(j, w) { cin >> grid[i][j]; }\n  }\n  REP(i, h + w - 1) {\n    REP(X, min(w, i)) {\n      REP(x, min(w, i)) {\n        if (h <= i - X || h <= i - x)\n          continue;\n        ll y = i - X, Y = i - x;\n        if (X == x) {\n          dp[i + 1][X + 1][x] =\n              max(dp[i + 1][X + 1][x], grid[Y][X] + dp[i][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1], grid[Y][X] + dp[i][X][x]);\n          dp[i + 1][X + 1][x + 1] =\n              max(dp[i + 1][X + 1][x + 1], grid[Y][X] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x], grid[Y][X] + dp[i][X][x]);\n        } else {\n          dp[i + 1][X + 1][x] = max(dp[i + 1][X + 1][x],\n                                    grid[i - X][X] + grid[y][x] + dp[i][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1], grid[Y][X] + grid[y][x] + dp[i][X][x]);\n          dp[i + 1][X + 1][x + 1] = max(dp[i + 1][X + 1][x + 1],\n                                        grid[Y][X] + grid[y][x] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x],\n                                grid[i - X][X] + grid[i - x][x] + dp[i][X][x]);\n        }\n      }\n    }\n  }\n  /*REP(i, h + w) {\n    REP(X, w) {\n      for (ll x = i - X; x >= 0 && x < w;) {\n        if (X == x) {\n          dp[i + 1][X + 1][x] =\n              max(dp[i + 1][X + 1][x], grid[i - X][X] + dp[i + 1][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1], grid[i - X][X] + dp[i + 1][X][x]);\n          dp[i + 1][X + 1][x + 1] =\n              max(dp[i + 1][X + 1][x + 1], grid[i - X][X] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x], grid[i - X][X] + dp[i][X][x]);\n        } else {\n          dp[i + 1][X + 1][x] =\n              max(dp[i + 1][X + 1][x],\n                  grid[i - X][X] + grid[i - x][x] + dp[i + 1][X][x]);\n          dp[i + 1][X][x + 1] =\n              max(dp[i + 1][X][x + 1],\n                  grid[i - X][X] + grid[i - x][x] + dp[i + 1][X][x]);\n          dp[i + 1][X + 1][x + 1] =\n              max(dp[i + 1][X + 1][x + 1],\n                  grid[i - X][X] + grid[i - x][x] + dp[i][X][x]);\n          dp[i + 1][X][x] = max(dp[i + 1][X][x],\n                                grid[i - X][X] + grid[i - x][x] + dp[i][X][x]);\n        }\n      }\n    }\n  }*/\n  cout << dp[h + w - 2][w - 1][w - 1] + grid[h - 1][w - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// failed to generate code\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint a[210][210];\nint H,W;\nint dp[210][210][210];\n\nint dfs(int x,int y,int x2){\n\t//cout << x << \" \" << y << \" \" << x2 << endl;\n\tif( x >= W ) return 0;\n\tif( y >= H ) return 0;\n\tint y2 = (x + y) -x2;\n\tif( y2 >= H ) return 0;\n\tif( x2 >= W ) return 0;\n\tif( y2 < 0 ) return 0;\n\tif( dp[x][y][x2] != -1 ) return dp[x][y][x2];\n\t//cout << x2 << \" \" << y2 << endl;\n\tint ans = a[y][x];\n\tif( x != x2 or y != y2 )\n\t\tans += a[y2][x2];\n\tint ans2 = 0;\n\tans2 = max(dfs(x+1,y,x2+1),dfs(x,y+1,x2+1));\n\tans2 = max(ans2,max(dfs(x+1,y,x2),dfs(x,y+1,x2)));\n\t\n\treturn dp[x][y][x2] = ans + ans2;\n}\n\nint main(){\t\n\tmemset(dp,-1,sizeof(dp));\n\tios::sync_with_stdio(false);\n\t\n\tcin >> H >> W;\n\tfor(int i = 0 ; i < H ; i++)\n\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\tcin >> a[i][j];\n\tcout << dfs(0,0,0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\ntypedef long long int LL;\nusing namespace std;\n\nint H, W, A[200][200];\n\nint calc(int res, int x1, int y1, int x2, int y2) {\n\tif (x1 == H || y1 == W || x2 == H || y2 == W) {\n\t\treturn res;\n\t}\n\tif (x1 == H-1 && y1 == W-1 && x2 == H-1 && y2 == W-1) {\n\t\treturn res + A[H-1][W-1];\n\t}\n\tint tmp = 0;\n\tif (x1 == x2) {\n\t\tres += A[x1][y1];\n\t\treturn max(\n\t\t\tmax(\n\t\t\t\tcalc(res, x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(res, x1+1, y1, x2, y2+1)\n\t\t\t), calc (res, x1, y1+1, x2, y2+1));\n\t} else {\n\t\tres += A[x1][y1] + A[x2][y2];\n\t\treturn max(\n\t\t\tmax(\n\t\t\t\tcalc(res, x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(res, x1+1, y1, x2, y2+1)\n\t\t\t), max(\n\t\t\t\tcalc (res, x1, y1+1, x2+1, y2),\n\t\t\t\tcalc (res, x1, y1+1, x2, y2+1)));\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\n\tint res = calc(0, 0, 0, 0, 0);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int H,W,a,T1,T2;\n    cin >> H >> W;\n    int array1[W];\n    int array2[W];\n    for(int i=0;i<W;i++){\n        cin >> array1[i];\n        T1=T1+array1[i]; \n    }\n    for(int i=0;i<W;i++){\n        cin >> array2[i];\n        T2=T2+array2[i];\n    }\n    a=T1+T2-array1[i]-array2[W];\n    cout << a << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// /usr/local/bin/g++ Main.cpp -std=c++14\n#include <bits/stdc++.h>\n#define REP(i,n,s) for (int i = (s); i < (n); i++)\n#define SIZE 200\nusing namespace std;\ntypedef long long int LL;\n\nint H, W, A[SIZE][SIZE];\nint cache[SIZE][SIZE][SIZE];\n\nint calc(int x1, int y1, int x2, int y2) {\n\tif (cache[x1][y1][x2] > -1) return cache[x1][y1][x2];\n\tif (x1 == H || y1 == W || x2 == H || y2 == W) {\n\t\treturn 0;\n\t}\n\tif (x1 == H-1 && y1 == W-1 && x2 == H-1 && y2 == W-1) {\n\t\treturn A[H-1][W-1];\n\t}\n\tint res = 0;\n\tif (x1 == x2) {\n\t\tres += A[x1][y1];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), calc (x1, y1+1, x2, y2+1));\n\t} else {\n\t\tres += A[x1][y1] + A[x2][y2];\n\t\tres += max(\n\t\t\tmax(\n\t\t\t\tcalc(x1+1, y1, x2+1, y2),\n\t\t\t\tcalc(x1+1, y1, x2, y2+1)\n\t\t\t), max(\n\t\t\t\tcalc(x1, y1+1, x2+1, y2),\n\t\t\t\tcalc(x1, y1+1, x2, y2+1)));\n\t}\n\tcache[x1][y1][x2] = res;\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\t// Dummy input\n//\tifstream in(\"input.txt\");\n//\tcin.rdbuf(in.rdbuf());\n\n\tcin >> H >> W;\n\tREP(i, H, 0) {\n\t\tREP(j, W, 0) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tmemset(cache, -1, sizeof(cache));\n\tcout << calc(0, 0, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<30);\nconst int MAX = 100000;\nconst int MAX_V = 200000;\n//最小費用流 O(F|E|log|V|) または O(F|V|^2)\nstruct edge{int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n \n    if(dist[t] == INF){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n       \n    int d = f;\n \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n    //cout << res << endl;\n  }\n  return res;\n}\n\nint H,W;\nint A[222][222];\nint getId(int x,int y){\n  return y * W + x;\n}\nint dx[]={0,1};\nint dy[]={1,0};\nint main(){\n  cin >> H >> W;\n\n  V = H * W * 2;\n  int T = H * W;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> A[j][i];\n      for(int k=0;k<2;k++){\n        int nx = j+dx[k], ny = i+dy[k];\n        if( nx >= W || ny >= H ) continue;\n        add_edge( getId(j,i) + T, getId(nx,ny) , 2, 0 );\n      }\n      add_edge( getId(j,i), getId(j,i)+T, 1, -A[j][i] );\n      add_edge( getId(j,i), getId(j,i)+T, 2, 0 );\n    }\n  }\n  /*\n  for(int i=0;i<V;i++){\n    cout << i << \" : \" << endl;\n    for(edge e : G[i] )\n      cout << e.to << \" \" << e.cap << \" \" << e.cost << endl;\n  }\n  */\n  //  cout << getId(0,0) << \" -> \" << getId(W-1,H-1) + T << \" = \" << V-1 << endl;\n  int res = -min_cost_flow( 0, V-1, 2 );\n  cout << res << endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <math.h>\nusing namespace std;\n#define maxn 300\nint a[maxn][maxn];\nint dp[maxn][maxn][maxn];\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tmemset(a, 0, sizeof(a));\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t}\n\tmemset(dp, 0, sizeof(dp));\n\tdp[1][1][1] = a[1][1];\n\tfor (int i = 1; i <= h; i++)\n\t{\n\t\tfor (int j = 1; j <= w; j++)\n\t\t{\n\t\t\tfor (int k = 1; k<=w&&k<=i+j-1;k++)\n\t\t\t{\n\t\t\t\tif (j == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t\tdp[i][j + 1][k+1] = max(dp[i][j+1][k+1],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k], dp[i][j][k] + a[i + 1][j] + a[i + j - k + 1][k]);\n\t\t\t\t\tdp[i][j + 1][k + 1] = max(dp[i][j+1][k+1] ,dp[i][j][k] +a[i][j + 1] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j == k + 1)\n\t\t\t\t{\t\n\t\t\t\t\tdp[i + 1][j][k] = max(dp[i+1][j][k],dp[i][j][k] + a[i + 1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i + 1][j][k + 1] = max(dp[i+1][j][k+1], dp[i][j][k] + a[i + 1][j] + a[i + j - k][k + 1]);\n\t\t\t\t}\n\t\t\t\tif (j + 1 == k)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k],dp[i][j][k] + a[i][j + 1]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j+1][k], dp[i][j][k] + a[i][j + 1] + a[i + j - k + 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[h][w][w] << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint dp[201][201][402];\nint a[201][201];\n\nint h,w;\n\n\nint dfs(int x1,int x2,int k){\n    if(~dp[x1][x2][k]) return dp[x1][x2][k];\n    int ret = (x1==x2?a[x1][k-x1]:a[x1][k-x1]+a[x2][k-x2]);\n    int t = 0;\n    if(k==h+w) return ret;\n    if(x1+1<w&&x2+1<w) chmax(t, dfs(x1+1,x2+1,k+1));\n    if(x2+1<w) chmax(t, dfs(x1,x2+1,k+1));\n    if(x1+1<w) chmax(t, dfs(x1+1,x2,k+1));\n    chmax(t, dfs(x1,x2,k+1));\n    ret += t;\n    return dp[x1][x2][k] = ret;\n}\n\n\n\nint main(){\n    cin >> h >> w;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> a[i][j];\n        }\n    }\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n#include <ctype.h>\nusing namespace std;\nint h,k=0;\nint main() {\n\twhile (cin>>h)\n\t{\n\t\tk += h;\n\t}\n\tcout << k<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\nint dp[201][201][500];\nint grid[201][201];\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tcin >> grid[i][q];\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < h + w-2; ++i) {\n\t\tfor (int q = 0; q <= i; ++q) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tint first_x = q;\n\t\t\t\tint first_y = i - q;\n\t\t\t\tint second_x = j;\n\t\t\t\tint second_y = i - j;\n\t\t\t\tREP(t, 2) {\n\t\t\t\t\tREP(p, 2) {\n\t\t\t\t\t\tint next_fx = first_x + t;\n\t\t\t\t\t\tint next_fy = first_y + 1 - t;\n\t\t\t\t\t\tint next_sx = second_x + p;\n\t\t\t\t\t\tint next_sy = second_y + 1 - p;\n\t\t\t\t\t\tif (next_fx >= h || next_sx >= h | next_fy >= w | next_sy >= w) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint winning = dp[q][j][i] + grid[next_fx][next_fy];\n\t\t\t\t\t\tif (next_fx != next_sx || next_fy != next_sy) {\n\t\t\t\t\t\t\twinning += grid[next_sx][next_sy];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next_fx][next_sx][next_fx + next_fy] = max(dp[next_fx][next_sx][next_fx + next_fy], winning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h - 1][h - 1][h + w - 2] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//カタラン数を語らん!w\n\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define REP(a,b) for(long long a = 0;a < b;++a)\n#define int long long\nint dp[201][201][500];\nint grid[201][201];\n#undef int\nint main() {\n#define int long long\n\tint h, w;\n\tcin >> h >> w;\n\tREP(i, h) {\n\t\tREP(q, w) {\n\t\t\tcin >> grid[i][q];\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < h + w-2; ++i) {\n\t\tfor (int q = 0; q <= i; ++q) {\n\t\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\t\tint first_x = q;\n\t\t\t\tint first_y = i - q;\n\t\t\t\tint second_x = j;\n\t\t\t\tint second_y = i - j;\n\t\t\t\tREP(t, 2) {\n\t\t\t\t\tREP(p, 2) {\n\t\t\t\t\t\tint next_fx = first_x + t;\n\t\t\t\t\t\tint next_fy = first_y + 1 - t;\n\t\t\t\t\t\tint next_sx = second_x + p;\n\t\t\t\t\t\tint next_sy = second_y + 1 - p;\n\t\t\t\t\t\tif (next_fx >= h || next_sx >= h | next_fy >= w | next_sy >= w) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint winning = dp[q][j][i] + grid[next_fx][next_fy];\n\t\t\t\t\t\tif (next_fx != next_sx || next_fy != next_sy) {\n\t\t\t\t\t\t\twinning += grid[next_sx][next_sy];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[next_fx][next_sx][next_fx + next_fy] = max(dp[next_fx][next_sx][next_fx + next_fy], winning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[h - 1][h - 1][h + w - 2] << endl;\n}"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MinCostFlow = {}\n\nMinCostFlow.initialize = function(self, n, spos, tpos, inf)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  self.inf = inf\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cost[src][i] := cost from src to edge_dst[src][i]\n  self.edge_cost = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- initial capacity. corresponding to edge_cap\n  self.edge_initialcap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- len[v] := length from spos. len[spos] := 0\n  self.len = {}\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph. from tpos to spos.\n  self.sub_graph_v = {}\n  -- sub_graph_edgeidx[i] := edge index from sub_graph_v[i + 1] to sub_graph_v[i]\n  self.sub_graph_edgeidx = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cost[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_initialcap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.len[i] = 0\n    self.sub_graph_flag[i] = false\n  end\nend\n\nMinCostFlow.addEdge = function(self, src, dst, cost, cap)\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cost[src], cost)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_initialcap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cost[dst], -cost)\n  table.insert(self.edge_cap[dst], 0)--invcap\n  table.insert(self.edge_initialcap[dst], 0)--invcap\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMinCostFlow.invwalk_recursive = function(self, invsrc)\n  if invsrc == self.spos then return true end\n  local edge_dst, edge_cap, edge_cost = self.edge_dst, self.edge_cap, self.edge_cost\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local len = self.len\n  local sub_graph_flag = self.sub_graph_flag\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  for i = 1, #edge_dst[invsrc] do\n    local invdst = edge_dst[invsrc][i]\n    local j = edge_dst_invedge_idx[invsrc][i]\n    if 0 < edge_cap[invdst][j]\n    and len[invdst] + edge_cost[invdst][j] == len[invsrc]\n    and not sub_graph_flag[invdst] then\n      self.sub_graph_size = self.sub_graph_size + 1\n      sub_graph_v[self.sub_graph_size] = invdst\n      sub_graph_edgeidx[self.sub_graph_size - 1] = j\n      sub_graph_flag[invdst] = true\n      if self:invwalk_recursive(invdst) then\n        return true\n      else\n        self.sub_graph_flag[invdst] = false\n        self.sub_graph_size = self.sub_graph_size - 1\n      end\n    end\n  end\n  return false\nend\n\nMinCostFlow.makeSubGraph = function(self)\n  local inf = self.inf\n  local len = self.len\n  local n = self.n\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local edge_cost = self.edge_cost\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  local sub_graph_flag = self.sub_graph_flag\n  for i = 1, self.n do\n    len[i] = inf\n    sub_graph_flag[i] = false\n  end\n  -- Bellman-Ford\n  local updated1, updated2 = {}, {}\n  for i = 1, n do\n    updated1[i] = true\n  end\n  len[self.spos] = 0\n  for irp = 1, n do\n    local updsrc = irp % 2 == 1 and updated1 or updated2\n    local upddst = irp % 2 == 1 and updated2 or updated1\n    for i = 1, n do\n      upddst[i] = false\n    end\n    for src = 1, n do\n      if updsrc[src] then\n        local eddst, edcap, edcost = edge_dst[src], edge_cap[src], edge_cost[src]\n        for i = 1, #eddst do\n          if 0 < edcap[i] then\n            local dst = eddst[i]\n            local cost = edcost[i]\n            if len[src] + cost < len[dst] then\n              len[dst] = len[src] + cost\n              upddst[dst] = true\n            end\n          end\n        end\n      end\n    end\n  end\n  self.sub_graph_size = 0\n  if inf <= len[self.tpos] then\n    return 0\n  end\n  -- restore route (from tpos to spos)\n  self.sub_graph_size = 1\n  sub_graph_v[1] = self.tpos\n  self:invwalk_recursive(self.tpos)\n  local min_capacity = inf\n  for i = self.sub_graph_size, 2, -1 do\n    local src = sub_graph_v[i]\n    local j = sub_graph_edgeidx[i - 1]\n    min_capacity = mmi(min_capacity, edge_cap[src][j])\n  end\n  return min_capacity\nend\n\nMinCostFlow.flow = function(self, capacity)\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  for i = self.sub_graph_size, 2, -1 do\n    local src = sub_graph_v[i]\n    local dst = sub_graph_v[i - 1]\n    local j = sub_graph_edgeidx[i - 1]\n    edge_cap[src][j] = edge_cap[src][j] - capacity\n    local k = edge_dst_invedge_idx[src][j]\n    edge_cap[dst][k] = edge_cap[dst][k] + capacity\n  end\nend\n\nMinCostFlow.getMinCostFlow = function(self, amount, invalid)\n  local ret = 0\n  local cap = self:makeSubGraph()\n  while 0 < cap do\n    cap = mmi(amount, cap)\n    ret = ret + self.len[self.tpos] * cap\n    self:flow(cap)\n    amount = amount - cap\n    if 0 < amount then\n      cap = self:makeSubGraph()\n    else\n      break\n    end\n  end\n  if 0 < amount then return invalid end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\")\nlocal s = 2 * h * w + 1\nlocal t = 2 * h * w + 2\nMinCostFlow:initialize(t, s, t, 1000000007 * 100)\nMinCostFlow:addEdge(s, 1, 0, 2)\nMinCostFlow:addEdge(2 * h * w, t, 0, 2)\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx = (i - 1) * w + j\n    MinCostFlow:addEdge(idx + h * w, idx + 1, 0, 2)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    MinCostFlow:addEdge(idx + h * w, idx + w, 0, 2)\n  end\nend\nfor i = 1, h do\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    local a = io.read(\"*n\")\n    MinCostFlow:addEdge(idx, idx + h * w, 0, 1)\n    MinCostFlow:addEdge(idx, idx + h * w, -a, 1)\n  end\nend\nprint(math.abs(MinCostFlow:getMinCostFlow(2)))\n"
  },
  {
    "language": "Lua",
    "code": "local mmi, mma = math.min, math.max\nlocal MinCostFlow = {}\n\nMinCostFlow.initialize = function(self, n, spos, tpos, inf)\n  self.n = n\n  self.spos, self.tpos = spos, tpos\n  self.inf = inf\n  -- edge_dst[src][i] := dst\n  self.edge_dst = {}\n  -- edge_cost[src][i] := cost from src to edge_dst[src][i]\n  self.edge_cost = {}\n  -- edge_cap[src][i] := capacity from src to edge_dst[src][i]\n  self.edge_cap = {}\n  -- initial capacity. corresponding to edge_cap\n  self.edge_initialcap = {}\n  -- edge_dst_invedge_idx[src][i] := \"j\" where edge_dst[dst][j] == src\n  -- in this case, edge_dst_invedge_idx[dst][j] should be \"i\".\n  self.edge_dst_invedge_idx = {}\n  -- len[v] := length from spos. len[spos] := 0\n  self.len = {}\n  -- sub_graph_flag[v] := whether to contains the vertex v in the sub-graph or not\n  self.sub_graph_flag = {}\n  -- sub_graph_v[i] := list of vertexes that are contained in the sub-graph. from tpos to spos.\n  self.sub_graph_v = {}\n  -- sub_graph_edgeidx[i] := edge index from sub_graph_v[i + 1] to sub_graph_v[i]\n  self.sub_graph_edgeidx = {}\n  -- sub_graph_size := the size of sub_graph_v.\n  -- may not equal to #sub_graph_v (because not cleared).\n  self.sub_graph_size = 0\n  for i = 1, n do\n    self.edge_dst[i] = {}\n    self.edge_cost[i] = {}\n    self.edge_cap[i] = {}\n    self.edge_initialcap[i] = {}\n    self.edge_dst_invedge_idx[i] = {}\n    self.len[i] = 0\n    self.sub_graph_flag[i] = false\n  end\nend\n\nMinCostFlow.addEdge = function(self, src, dst, cost, cap)\n  table.insert(self.edge_dst[src], dst)\n  table.insert(self.edge_cost[src], cost)\n  table.insert(self.edge_cap[src], cap)\n  table.insert(self.edge_initialcap[src], cap)\n  table.insert(self.edge_dst_invedge_idx[src], 1 + #self.edge_dst[dst])\n  table.insert(self.edge_dst[dst], src)\n  table.insert(self.edge_cost[dst], -cost)\n  table.insert(self.edge_cap[dst], 0)--invcap\n  table.insert(self.edge_initialcap[dst], 0)--invcap\n  table.insert(self.edge_dst_invedge_idx[dst], #self.edge_dst[src])\nend\nMinCostFlow.invwalk_recursive = function(self, invsrc)\n  if invsrc == self.spos then return true end\n  local edge_dst, edge_cap, edge_cost = self.edge_dst, self.edge_cap, self.edge_cost\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local len = self.len\n  local sub_graph_flag = self.sub_graph_flag\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  for i = 1, #edge_dst[invsrc] do\n    local invdst = edge_dst[invsrc][i]\n    local j = edge_dst_invedge_idx[invsrc][i]\n    if 0 < edge_cap[invdst][j]\n    and len[invdst] + edge_cost[invdst][j] == len[invsrc]\n    and not sub_graph_flag[invdst] then\n      self.sub_graph_size = self.sub_graph_size + 1\n      sub_graph_v[self.sub_graph_size] = invdst\n      sub_graph_edgeidx[self.sub_graph_size - 1] = j\n      sub_graph_flag[invdst] = true\n      if self:invwalk_recursive(invdst) then\n        return true\n      else\n        self.sub_graph_flag[invdst] = false\n        self.sub_graph_size = self.sub_graph_size - 1\n      end\n    end\n  end\n  return false\nend\n\nMinCostFlow.makeSubGraph = function(self)\n  local inf = self.inf\n  local len = self.len\n  local n = self.n\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local edge_cost = self.edge_cost\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  local sub_graph_flag = self.sub_graph_flag\n  for i = 1, n do\n    len[i] = inf\n    sub_graph_flag[i] = false\n  end\n  len[self.spos] = 0\n  -- Dijkstra-like\n  do\n    local taskstate = {}\n    for i = 1, n do taskstate[i] = false end\n    local tasks = {}\n    local tasknum = 0\n    local done = 0\n    local tasklim = n\n\n    local function addtask(idx)\n      if not taskstate[idx] then\n        taskstate[idx] = true\n        tasknum = tasknum + 1\n        local taskidx = tasknum % tasklim\n        if taskidx == 0 then taskidx = tasklim end\n        tasks[taskidx] = idx\n      end\n    end\n\n    local function walk(src, dst, cost)\n      if len[src] + cost < len[dst] then\n        len[dst] = len[src] + cost\n        addtask(dst)\n      end\n    end\n\n    addtask(self.spos)\n\n    while done < tasknum do\n      done = done + 1\n      local taskidx = done % tasklim\n      if taskidx == 0 then taskidx = tasklim end\n      local idx = tasks[taskidx]\n      taskstate[idx] = false\n      local eddst, edcap, edcost = edge_dst[idx], edge_cap[idx], edge_cost[idx]\n      for i = 1, #eddst do\n        if 0 < edcap[i] then\n          walk(idx, eddst[i], edcost[i])\n        end\n      end\n    end\n  end\n  self.sub_graph_size = 0\n  if inf <= len[self.tpos] then\n    return 0\n  end\n  -- restore route (from tpos to spos)\n  self.sub_graph_size = 1\n  sub_graph_v[1] = self.tpos\n  self:invwalk_recursive(self.tpos)\n  return 1\nend\n\nMinCostFlow.flow = function(self, capacity)\n  local edge_dst, edge_cap = self.edge_dst, self.edge_cap\n  local edge_dst_invedge_idx = self.edge_dst_invedge_idx\n  local sub_graph_v = self.sub_graph_v\n  local sub_graph_edgeidx = self.sub_graph_edgeidx\n  for i = self.sub_graph_size, 2, -1 do\n    local src = sub_graph_v[i]\n    local dst = sub_graph_v[i - 1]\n    local j = sub_graph_edgeidx[i - 1]\n    edge_cap[src][j] = edge_cap[src][j] - capacity\n    local k = edge_dst_invedge_idx[src][j]\n    edge_cap[dst][k] = edge_cap[dst][k] + capacity\n  end\nend\n\nMinCostFlow.getMinCostFlow = function(self, amount, invalid)\n  local ret = 0\n  local cap = self:makeSubGraph()\n  while 0 < cap do\n    cap = mmi(amount, cap)\n    ret = ret + self.len[self.tpos] * cap\n    self:flow(cap)\n    amount = amount - cap\n    if 0 < amount then\n      cap = self:makeSubGraph()\n    else\n      break\n    end\n  end\n  if 0 < amount then return invalid end\n  return ret\nend\n\nlocal h, w = io.read(\"*n\", \"*n\")\nlocal s = 2 * h * w + 1\nlocal t = 2 * h * w + 2\nlocal inf = 100000 * 200 * 2 + 100\nMinCostFlow:initialize(t, s, t, 1000000007 * 100)\nMinCostFlow:addEdge(s, 1, 0, 2)\nMinCostFlow:addEdge(2 * h * w, t, 0, 2)\nfor i = 1, h do\n  for j = 1, w - 1 do\n    local idx = (i - 1) * w + j\n    MinCostFlow:addEdge(idx + h * w, idx + 1, 0, 2)\n  end\nend\nfor i = 1, h - 1 do\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    MinCostFlow:addEdge(idx + h * w, idx + w, 0, 2)\n  end\nend\nfor i = 1, h do\n  for j = 1, w do\n    local idx = (i - 1) * w + j\n    local a = io.read(\"*n\")\n    MinCostFlow:addEdge(idx, idx + h * w, inf, 1)\n    MinCostFlow:addEdge(idx, idx + h * w, inf - a, 1)\n  end\nend\nlocal ret = MinCostFlow:getMinCostFlow(2)\nif h == 1 or w == 1 then\n  ret = ret - inf * math.max(h, w)\nelse\n  ret = ret - inf * 2 * (h + w - 1)\nend\nprint(math.abs(ret))\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][400];\nint h,w;\n\nint search(int ax,int ay,int bx,int by){\n  int i,c,max=0;\n  if(ax==0 && ay==0){\n    return map[0][0]+search(ax+1,ay,bx,by+1);\n  }else if(ax==h-1 && ay==w-1){\n    return map[h-1][w-1];\n  }else{\n    if(dp[ax][bx][ax+ay]==0){\n    for(i=0;i<4;i++){\n      if(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n        if((ax+(i%2)!=bx+(i/2)) || ax+ay==w+h-3){\n        c=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n        if(c>max) max=c;\n        }\n      }\n    }\n    return dp[ax][bx][ax+ay]=max;\n    }else{\n      return dp[ax][bx][ax+ay];\n    }\n  }\n}\n\nint main(){\n  int i,j,k;\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%d\",&map[i][j]);\n      for (k = 0; k < h+w; k++) {\n        dp[i][j][k]=0;\n        }\n    }\n  }\n  printf(\"%d\\n\",search(0,0,0,0));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(int argc, char const *argv[]) {\n    int h,w,map[200][200],i,j,sum;\n    \n    scanf(\"%d %d\",&h,&w);\n    sum=0;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            scanf(\"%d\",%map[i][j]);\n            sum+=map[i][j];\n        }\n    }\n    printf(\"%d\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(int argc, char const *argv[]) {\n    int h,w,map[200][200],i,j,sum;\n    \n    scanf(\"%d %d\",&h,&w);\n    sum=0;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            scanf(\"%d\",&map[i][j]);\n            sum+=map[i][j];\n        }\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint h,w,r=0,i,n;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(i = 1;i <= h*w;i++){\n\t\tscanf(\"%d\",&n);\n\t\tr+=n;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint map[200][200],dp[200][200][400];\nint h,w;\n \nint search(int ax,int ay,int bx,int by){\n\tint i,c,max=0;\n\tif(ax==0 && ay==0){\n\t\treturn map[0][0]+search(ax+1,ay,bx,by+1);\n\t}else if(ax==h-1 && ay==w-1){\n\t\treturn map[h-1][w-1];\n\t}else{\n\t\tif(dp[ax][ay][ax+ay]==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n\t\t\t\tif((ax+(i%2)!=bx+(i/2)) || ax+ay==w+h-3){\n\t\t\t\tc=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n\t\t\t\tif(c>max) max=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[ax][ay][ax+ay]=max;\n\t\t}else{\n\t\t\treturn dp[ax][ay][ax+ay];\n\t\t}\n\t}\n}\n \nint main(){\n\tint i,j;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\tdp[i][j][i+j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",search(0,0,0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <regex.h>\n\n#define lli long long int\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define abs(a) ((a)<0?-(a):(a))\n#define alloc(type,size) calloc(sizeof(type),size)\n\n\n\nint main(void){\n\tint h,w;\n\tint **a;\n\n\tint i;\n\tint j;\n\tint **map;\n\tchar **way;\n\tint res = 0;\n\n\tscanf(\"%d%d\",&h,&w);\n\ta = alloc(int*,h+2);\n\tmap = alloc(int*,h+2);\n\tway = alloc(char*,h+2);\n\tfor(i=0;i<h+2;i++){\n\t\ta[i] = alloc(int,w+2);\n\t\ta[i]++;\n\t\tmap[i] = alloc(int,w+2);\n\t\tmap[i]++;\n\t\tway[i] = alloc(char,w+2);\n\t\tway[i]++;\n\t}\n\ta++;\n\tmap++;\n\tway++;\n\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tmap[i][j] = max(map[i-1][j],map[i][j-1]) + a[i][j];\n\t\t\tif(i>j) way[i][j] = map[i-1][j] > map[i][j-1] ? 'u' : 'l';\n\t\t\telse way[i][j] = map[i-1][j] >= map[i][j-1] ? 'u' : 'l';\n\t\t}\n\t}\n\ti = h-1;j = w-1;\n\tres = map[i][j];\n\twhile(i || j){\n\t\ta[i][j] = 0;\n\t\tif(way[i][j] == 'u') i--;\n\t\telse j--;\n\t}\n\ta[i][j] = 0;\n\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tmap[i][j] = max(map[i-1][j],map[i][j-1]) + a[i][j];\n\t\t\tif(i>j) way[i][j] = map[i-1][j] > map[i][j-1] ? 'u' : 'l';\n\t\t\telse way[i][j] = map[i-1][j] >= map[i][j-1] ? 'u' : 'l';\n\t\t}\n\t}\n\ti = h-1;j = w-1;\n\tres += map[i][j];\n\n\tprintf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][400];\nint h,w;\n\nint search(int ax,int ay,int bx,int by){\n  int i,c,max=0;\n  if(ax==0 && ay==0){\n    return map[0][0]+search(ax+1,ay,bx,by+1);\n  }else if(ax==h-1 && ay==w-1){\n    return map[h-1][w-1];\n  }else{\n    if(dp[ax][ay][ax+ay]==0){\n    for(i=0;i<4;i++){\n      if(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n        if((ax+(i%2)!=bx+(i/2)) || ax+ay==w+h-3){\n        c=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n        if(c>max) max=c;\n        }\n      }\n    }\n    return dp[ax][ay][ax+ay]=max;\n    }else{\n      return dp[ax][ay][ax+ay];\n    }\n  }\n}\n\nint main(){\n  int i,j;\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%d\",&map[i][j]);\n      for (int k = 0; k < h+w; k++) {\n        dp[i][j][]=0;\n            }\n    }\n  }\n  printf(\"%d\\n\",search(0,0,0,0));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][200][200];\nint h,w,num;\n\nint search(int ax,int ay,int bx,int by){\n\tint i;\n\tif(ax==0 && ay==0){\n\t\treturn search(ax+1,ay,bx,by+1);\n\t}else if(ax==h && ay==w){\n\t\treturn 0;\n\t}else{\n\t\tif(dp[ax][ay][bx][by]==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n\t\t\t\tif((ax+(i%2)!=bx+(i/2))) return dp[ax][ay][bx][by]=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n\t\t\t}\n\t\t}\n\t\t}else{\n\t\t\treturn dp[ax][ay][bx][by];\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",search(0,0,0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][200][200];\nint h,w,num;\n\nint search(int ax,int ay,int bx,int by){\n\tint i;\n\tif(ax==0 && ay==0){\n\t\treturn search(ax+1,ay,bx,by+1);\n\t}else if(ax==h && ay==w){\n\t\treturn 0;\n\t}else{\n\t\tif(dp[ax][ay][bx][by]==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n\t\t\t\tif((ax+(i%2)!=bx+(i/2))) return dp[ax][ay][bx][by]=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n\t\t\t}\n\t\t}\n\t\t}else{\n\t\t\treturn dp[ax][ay][bx][by]\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",search(0,0,0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define mod 1000000007\n#define are(h,i,j) (dp[(h)-1][i][j]+a[i][h-(i)]+a[j][h-(j)])\nint max(int a,int b){\n\tif(a>b){ return a; } else{return b;}\n}\nint main(void){\n\t//定数倍ひどいことになってるなこれ\n\tint H,W,h,i,j,b;\n\tstatic int a[401][401]={0};\n\tstatic int dp[401][401][401]={0};\n\tscanf(\"%d %d\",&H,&W);\n\tfor(i=0;i<H;i++){\n\t\tfor(j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&b);\n\t\t\ta[i][j]=b;\n\t\t}\n\t}\n\tdp[0][1][1]=a[0][0];\n\tfor(h=1;h<=H+W;h++){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=i+1;j<=h+1;j++){//i<j\n\t\t\t\tdp[h][i][j]=max(max(dp[h-1][i][j],dp[h-1][i-1][j]),max(dp[h-1][i][j-1],dp[h-1][i-1][j-1]));\n\t\t\t\tdp[h][i][j]+=a[i-1][h-(i-1)]+a[j-1][h-(j-1)];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dp[H+W][H][H+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define mod 1000000007\n#define are(h,i,j) (dp[(h)-1][i][j]+a[i][h-(i)]+a[j][h-(j)])\nint max(int a,int b){\n\tif(a>b){ return a; } else{return b;}\n}\nint main(void){\n\t//定数倍ひどいことになってるなこれ\n\tint H,W,h,i,j,b;\n\tstatic int a[401][401]={0};\n\tstatic int dp[401][401][401]={0};\n\tscanf(\"%d %d\",&H,&W);\n\tfor(i=0;i<H;i++){\n\t\tfor(j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&b);\n\t\t\ta[i][j]=b;\n\t\t}\n\t}\n\tdp[0][1][1]=a[0][0];\n\tfor(h=1;h<=H+W;h++){\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=i+1;j<=h+1;j++){//i<j\n\t\t\t\tdp[h][i][j]=max(max(dp[h-1][i][j],dp[h-1][i-1][j]),max(dp[h-1][i][j-1],dp[h-1][i-1][j-1]));\n\t\t\t\tdp[h][i][j]+=a[i-1][h-(i-1)]+a[j-1][h-(j-1)];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[H+W][H][H+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(int argc, char const *argv[]) {\n    int h,w,map[200][200],i,j,sum;\n    \n    scanf(\"%d %d\",&h,&w);\n    sum=0;\n    for (i = 0; i < h; i++) {\n        for (j = 0; j < w; j++) {\n            scanf(\"%d\",&map[i][j]);\n            sum+=map[i][j];\n        }\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][400];\nint h,w;\n\nint search(int ax,int ay,int bx,int by){\n  int i,c,max=0;\n  if(ax==0 && ay==0){\n    return map[0][0]+search(ax+1,ay,bx,by+1);\n  }else if(ax==h-1 && ay==w-1){\n    return map[h-1][w-1];\n  }else{\n    if(dp[ax][ay][ax+ay]==0){\n    for(i=0;i<4;i++){\n      if(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n        if((ax+(i%2)!=bx+(i/2)) || ax+ay==w+h-3){\n        c=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n        if(c>max) max=c;\n        }\n      }\n    }\n    return dp[ax][ay][ax+ay]=max;\n    }else{\n      return dp[ax][ay][ax+ay];\n    }\n  }\n}\n\nint main(){\n  int i,j;\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%d\",&map[i][j]);\n      for (int k = 0; k < h+w; k++) {\n        dp[i][j][k]=0;\n            }\n    }\n  }\n  printf(\"%d\\n\",search(0,0,0,0));\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// 内部定数\n#define D_SIZE_MAX\t\t205\t\t\t\t\t\t\t\t\t\t// 最大サイズ\n\n// 内部変数\nstatic FILE *szpFpI;\t\t\t\t\t\t\t\t\t\t\t// 入力\nstatic int siW, siH;\t\t\t\t\t\t\t\t\t\t\t// 幅・高さ\nstatic int si2Mass[D_SIZE_MAX][D_SIZE_MAX];\t\t\t\t\t\t// マス\nstatic int si3Cnt[D_SIZE_MAX][D_SIZE_MAX][D_SIZE_MAX * 2];\t\t// 個数[行][列][距離]\n\n// 内部変数 - テスト用\n#ifdef D_TEST\n\tstatic int siRes;\n\tstatic FILE *szpFpA;\n\tstatic int siTNo;\n#endif\n\n// １行出力\nint\nfOutLine(\n\tchar *pcpLine\t\t\t\t// <I> １行\n)\n{\n\tchar lc1Buf[1024];\n\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, pcpLine)) {\n\t\tsiRes = -1;\n\t}\n#else\n\tprintf(\"%s\", pcpLine);\n#endif\n\n\treturn 0;\n}\n\n// 最大値 - 取得\nint\nfGetMax(\n\tint piVal1\t\t\t\t\t// <I> 値１\n\t, int piVal2\t\t\t\t// <I> 値２\n)\n{\n\tif (piVal1 > piVal2) {\n\t\treturn piVal1;\n\t}\n\telse {\n\t\treturn piVal2;\n\t}\n}\n\n// 右下移動\nint\nfMove(\n\tint *pipRow\t\t\t\t\t// <IO> 行\n\t, int *pipCol\t\t\t\t// <IO> 列\n)\n{\n\t// 右上移動\n\t(*pipRow)--;\n\t(*pipCol)++;\n\n\t// マス外\n\tif (*pipRow < 0) {\n\t\treturn -1;\n\t}\n\tif (*pipCol >= siW) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n// 加算個数 - 取得\nint\nfGetAdd(\n\tint piRow\t\t\t\t\t// <I> 行\n\t, int piCol\t\t\t\t\t// <I> 列\n\t, int piRow2\t\t\t\t// <I> 行２\n\t, int piCol2\t\t\t\t// <I> 列２\n)\n{\n\tint liAdd = si2Mass[piRow][piCol];\n\tif (piRow == piRow2) {\n\t\tif (piCol == piCol2) {\n\t\t\treturn liAdd;\n\t\t}\n\t}\n\tliAdd += si2Mass[piRow2][piCol2];\n\n\treturn liAdd;\n}\n\n// 実行メイン\nint\nfMain(\n)\n{\n\tint i, j, liRet;\n\tchar lc1Buf[1024];\n\n\t// データ - 初期化\n\tmemset(si3Cnt, 0, sizeof(si3Cnt));\n\n\t// 幅・高さ - 取得\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\tsscanf(lc1Buf, \"%d%d\", &siH, &siW);\n\n\t// マス - 取得\n\tfor (i = 0; i < siH; i++) {\n\t\tfor (j = 0; j < siW; j++) {\n\t\t\tfscanf(szpFpI, \"%d\", &si2Mass[i][j]);\n\t\t}\n\t\tfgets(lc1Buf, sizeof(lc1Buf), szpFpI);\n\t}\n\n\t// 個数 - 初期値\n\tsi3Cnt[0][0][0] = si2Mass[0][0];\n\n\t// 移動回数でループ\n\tfor (i = 0; i < siW + siH - 2; i++) {\n\n\t\t// １人目の位置でループ\n\t\tint liRow, liCol;\n\t\tif (i < siH) {\n\t\t\tliRow = i;\n\t\t\tliCol = 0;\n\t\t}\n\t\telse {\n\t\t\tliRow = siH - 1;\n\t\t\tliCol = i - liRow;\n\t\t}\n\t\twhile (1) {\n\n\t\t\t// ２人目の位置でループ\n\t\t\tint liRow2 = liRow;\n\t\t\tint liCol2 = liCol;\n\t\t\tfor (j = 0; ; j++) {\n\n\t\t\t\t// 下・下\n\t\t\t\tint liAdd = fGetAdd(liRow + 1, liCol, liRow2 + 1, liCol2);\n\t\t\t\tsi3Cnt[liRow + 1][liCol][j] = fGetMax(si3Cnt[liRow + 1][liCol][j], si3Cnt[liRow][liCol][j] + liAdd);\n\n\t\t\t\t// 下・右\n\t\t\t\tliAdd = fGetAdd(liRow + 1, liCol, liRow2, liCol2 + 1);\n\t\t\t\tsi3Cnt[liRow + 1][liCol][j + 1] = fGetMax(si3Cnt[liRow + 1][liCol][j + 1], si3Cnt[liRow][liCol][j] + liAdd);\n\n\t\t\t\t// 右・下\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tliAdd = fGetAdd(liRow, liCol + 1, liRow2 + 1, liCol2);\n\t\t\t\t\tsi3Cnt[liRow][liCol + 1][j - 1] = fGetMax(si3Cnt[liRow][liCol + 1][j - 1], si3Cnt[liRow][liCol][j] + liAdd);\n\t\t\t\t}\n\n\t\t\t\t// 右・右\n\t\t\t\tliAdd = fGetAdd(liRow, liCol + 1, liRow2, liCol2 + 1);\n\t\t\t\tsi3Cnt[liRow][liCol + 1][j] = fGetMax(si3Cnt[liRow][liCol + 1][j], si3Cnt[liRow][liCol][j] + liAdd);\n\n\t\t\t\t// 次の位置\n\t\t\t\tliRet = fMove(&liRow2, &liCol2);\n\t\t\t\tif (liRet != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 次の位置\n\t\t\tliRet = fMove(&liRow, &liCol);\n\t\t\tif (liRet != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn si3Cnt[siH - 1][siW - 1][0];\n}\n\n// １回実行\nint\nfOne(\n)\n{\n\tint liRet;\n\tchar lc1Buf[1024];\n\n\t// 入力 - セット\n#ifdef D_TEST\n\tsprintf(lc1Buf, \".\\\\Test\\\\T%d.txt\", siTNo);\n\tszpFpI = fopen(lc1Buf, \"r\");\n\tsprintf(lc1Buf, \".\\\\Test\\\\A%d.txt\", siTNo);\n\tszpFpA = fopen(lc1Buf, \"r\");\n\tsiRes = 0;\n#else\n\tszpFpI = stdin;\n#endif\n\n\t// 実行メイン\n\tliRet = fMain();\n\n\t// 出力\n\tsprintf(lc1Buf, \"%d\\n\", liRet);\n\tfOutLine(lc1Buf);\n\n\t// 残データ有無\n#ifdef D_TEST\n\tlc1Buf[0] = '\\0';\n\tfgets(lc1Buf, sizeof(lc1Buf), szpFpA);\n\tif (strcmp(lc1Buf, \"\")) {\n\t\tsiRes = -1;\n\t}\n#endif\n\n\t// テストファイルクローズ\n#ifdef D_TEST\n\tfclose(szpFpI);\n\tfclose(szpFpA);\n#endif\n\n\t// テスト結果\n#ifdef D_TEST\n\tif (siRes == 0) {\n\t\tprintf(\"OK %d\\n\", siTNo);\n\t}\n\telse {\n\t\tprintf(\"NG %d\\n\", siTNo);\n\t}\n#endif\n\n\treturn 0;\n}\n\n// プログラム開始\nint\nmain()\n{\n\n#ifdef D_TEST\n\tint i;\n\tfor (i = D_TEST_SNO; i <= D_TEST_ENO; i++) {\n\t\tsiTNo = i;\n\t\tfOne();\n\t}\n#else\n\tfOne();\n#endif\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nint map[200][200],dp[200][200][400];\nint h,w;\n \nint search(int ax,int ay,int bx,int by){\n  int i,c,max=0;\n  if(ax==0 && ay==0){\n    return map[0][0]+search(ax+1,ay,bx,by+1);\n  }else if(ax==h-1 && ay==w-1){\n    return map[h-1][w-1];\n  }else{\n    if(dp[ax][ay][ax+ay]==0){\n    for(i=0;i<4;i++){\n      if(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n        if((ax+(i%2)!=bx+(i/2)) || ax+ay==w+h-3){\n        c=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n        if(c>max) max=c;\n        }\n      }\n    }\n    return dp[ax][ay][ax+ay]=max;\n    }else{\n      return dp[ax][ay][ax+ay];\n    }\n  }\n}\n \nint main(){\n  int i,j;\n  scanf(\"%d %d\",&h,&w);\n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      scanf(\"%d\",&map[i][j]);\n      dp[i][j][i+j]=0;\n    }\n  }\n  if(h==1){\n    j=0;\n    for(i=0;i<w;i++){\n      j+=map[0][i];\n    }\n    printf(\"%d\\n\",j);\n  }else if(w==1){\n    j=0;\n    for(i=0;i<h;i++){\n      j+=map[i][0];\n    }\n    printf(\"%d\\n\",j);\n  }else{\n    printf(\"%d\\n\",search(0,0,0,0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint map[200][200],dp[200][200][400];\nint h,w,num;\n\nint search(int ax,int ay,int bx,int by){\n\tint i;\n\tif(ax==0 && ay==0){\n\t\treturn search(ax+1,ay,bx,by+1);\n\t}else if(ax==h && ay==w){\n\t\treturn 0;\n\t}else{\n\t\tif(dp[ax][ay][ax+ay]==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(ax+(i%2)<h && ay+(1-i%2)<w && bx+i/2<h && by+(1-i/2)<w){\n\t\t\t\tif((ax+(i%2)!=bx+(i/2))) return dp[ax][ay][ax+ay]=map[ax][ay]+map[bx][by]+search(ax+(i%2),ay+(1-i%2),bx+i/2,by+(1-i/2));\n\t\t\t}\n\t\t}\n\t\t}else{\n\t\t\treturn dp[ax][ay][ax+ay];\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",search(0,0,0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t prevcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l > r) {\n\t\treturn -1;\n\t}\n\tif (l < r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptripleREVcomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\nhwllc tup[N_MAX];\nsll table[3000][3000];\n// here we go\n\null dp[410][210][210];\n\nvoid mp (char s[], sll border[]) {\n\tborder[0] = -1;\n\tsll j = -1;\n\n\tfor (sll i = 0; i < n; i++) {\n\t\twhile (j >= 0 && s[i] != s[j]) j = border[j];\n\t\tj++;\n\t\tborder[i + 1] = j;\n\t}\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tdp[0][0][0] = table[0][0];\n\tfor (i = 1; i <= h + w - 2; i++) {\n\n\t\tfor (sll ah = 0; ah < h; ah++) {\n\t\t\tsll aw = i - ah;\n\t\t\tif (aw < 0 || aw >= w) continue;\n\t\t\tfor (sll bh = 0; bh < h; bh++) {\n\t\t\t\tsll bw = i - bh;\n\t\t\t\tif (bw < 0 || bw >= w) continue;\n\n\t\t\t\tull add = (table[ah][aw] + table[bh][bw]) / ((ah == bh) ? 2 : 1);\n\t\t\t\tull prev = 0;\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\tsll pah = ah, pbh = bh;\n\t\t\t\t\tif (j & 1) {\n\t\t\t\t\t\tif (!pah) continue;\n\t\t\t\t\t\tpah--;\n\t\t\t\t\t}\n\t\t\t\t\tif (j & 2) {\n\t\t\t\t\t\tif (!pbh) continue;\n\t\t\t\t\t\tpbh--;\n\t\t\t\t\t}\n\t\t\t\t\tull maybe = dp[i - 1][pah][pbh];\n\t\t\t\t\tif (maybe > prev) {\n\t\t\t\t\t\tprev = maybe;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdp[i][ah][bh] = prev + add;\n\t\t\t}\n\n\t\t}\n\t}\n\tresult = dp[h + w - 2][h - 1][h - 1];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\tscanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n - 1; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// c[i]--;\n\t// \t// tup[i].a--;\n\t// \t// tup[i].b--;\n\t// }\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tscanf(\"%llu\", &table[i][j]);\n\t\t}\n\t}\n\t// // for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int[][][][] dp;\n    static int h;\n    static int w;\n    static int[][] field;\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        h = sc.nextInt();\n        w = sc.nextInt();\n        field = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                field[i][j] = sc.nextInt();\n            }\n        }\n        dp = new int[h][w][h][w];\n        System.out.println(dfw(h - 1, w - 1, h - 1, w - 1));\n    }\n    \n    static int dfw(int h1, int w1, int h2, int w2) {\n        if (h1 == 0 && w1 == 0 && h2 == 0 && w2 == 0) {\n            return field[0][0];\n        }\n        if (h1 < 0 || w1 < 0 || h2 < 0 || w2 < 0) {\n            return -1;\n        }\n        if (dp[h1][w1][h2][w2] != 0) {\n            return dp[h1][w1][h2][w2];\n        }\n        if (dp[h2][w2][h1][w1] != 0) {\n            return dp[h2][w2][h1][w1];\n        }\n        int max = 0;\n        int now;\n        if (h1 == h - 1 && w1 == w - 1 && h2 == h - 1 && w2 == w - 1) {\n            now = field[h - 1][w - 1];\n        } else if (h1 == h2 && w1 == w2) {\n            return -1;\n        } else {\n            now = field[h1][w1] + field[h2][w2];\n        }\n        max = Math.max(max, dfw(h1 - 1, w1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1 - 1, w1, h2, w2 - 1));\n        max = Math.max(max, dfw(h1, w1 - 1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1, w1 - 1, h2, w2 - 1));\n        dp[h1][w1][h2][w2] = max + now;\n        return max + now;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.concurrent.SynchronousQueue;\n\npublic class Main {\n    MyScanner sc    = new MyScanner();\n    Scanner   sc2   = new Scanner(System.in);\n    long      start = System.currentTimeMillis();\n    long      fin   = System.currentTimeMillis();\n    final int MOD   = 1000000007;\n    int[]     dx    = { 1, 0, 0, -1 };\n    int[]     dy    = { 0, 1, -1, 0 };\n\n    int       H, W;\n    int[][]   a;\n    long      cost;\n\n    void run() {\n        H = sc.nextInt();\n        W = sc.nextInt();\n        a = sc.nextInt2dArray(H, W);\n        if(H> 7 && W > 7) return;\n\n        cost = 0;\n        dfs(0, 0, 0, 0);\n        System.out.println(cost);\n    }\n\n    void dfs(int h, int w, int sum, int f) {\n        if (h == H - 1 && w == W - 1) {\n            int tmp = a[h][w];\n            a[h][w] = 0;\n\n            if (f == 0) dfs(0, 0, sum + tmp, 1);\n            else {\n                cost = Math.max(cost, sum);\n            }\n\n            a[h][w] = tmp;\n            return;\n        }\n\n        if (h + 1 < H) {\n            int tmp = a[h][w];\n            a[h][w] = 0;\n            dfs(h + 1, w, sum + tmp, f);\n            a[h][w] = tmp;\n        }\n        if (w + 1 < W) {\n            int tmp = a[h][w];\n            a[h][w] = 0;\n            dfs(h, w + 1, sum + tmp, f);\n            a[h][w] = tmp;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    void debug2(int[][] array) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                System.out.print(array[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    boolean inner(int h, int w, int limH, int limW) {\n        return 0 <= h && h < limH && 0 <= w && w < limW;\n    }\n\n    void swap(int[] x, int a, int b) {\n        int tmp = x[a];\n        x[a] = x[b];\n        x[b] = tmp;\n    }\n\n    // find minimum i (k <= a[i])\n    int lower_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k <= a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    // find minimum i (k < a[i])\n    int upper_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k < a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    long gcd(long a, long b) {\n        return a % b == 0 ? b : gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    boolean palindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    class MyScanner {\n        int nextInt() {\n            try {\n                int c = System.in.read();\n                while (c != '-' && (c < '0' || '9' < c))\n                    c = System.in.read();\n                if (c == '-')\n                    return -nextInt();\n                int res = 0;\n                do {\n                    res *= 10;\n                    res += c - '0';\n                    c = System.in.read();\n                } while ('0' <= c && c <= '9');\n                return res;\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String next() {\n            try {\n                StringBuilder res = new StringBuilder(\"\");\n                int c = System.in.read();\n                while (Character.isWhitespace(c))\n                    c = System.in.read();\n                do {\n                    res.append((char) c);\n                } while (!Character.isWhitespace(c = System.in.read()));\n                return res.toString();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        int[] nextIntArray(int n) {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextInt();\n            }\n            return in;\n        }\n\n        int[][] nextInt2dArray(int n, int m) {\n            int[][] in = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextIntArray(m);\n            }\n            return in;\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] in = new double[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextDouble();\n            }\n            return in;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextLong();\n            }\n            return in;\n        }\n\n        char[][] nextCharField(int n, int m) {\n            char[][] in = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                String s = sc.next();\n                for (int j = 0; j < m; j++) {\n                    in[i][j] = s.charAt(j);\n                }\n            }\n            return in;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.function.LongBinaryOperator;\nclass Main{\n\tstatic Scanner s = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tlong[][] ina = new long[Integer.parseInt(s.next())][Integer.parseInt(s.next())],\n\t\t         inb = new long[ina.length][ina[0].length];\n\t\tlong result = 0;\n\t\tfor(int i=0;i<ina.length;i++)\n\t\t\tfor(int j=0;j<ina[0].length;j++) {\n\t\t\t\tina[i][j]=Integer.parseInt(s.next());\n\t\t\t\tinb[i][j]=ina[i][j];\n\t\t\t}\n\t\t//out(ina);\n\t\tif(ina.length==1) {\n\t\t\tArrays.parallelPrefix(ina[0], (LongBinaryOperator) (left, right) -> left+right);\n\t\t\treturn;\n\t\t}\n\t\tif(ina[0].length==1) {\n\t\t\tint i=0;\n\t\t\tfor(long j:ina[0]) {\n\t\t\t\ti+=j;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsearch(ina);\n\n\t\t//out(ina);\n\n\t\tresult+=ina[ina.length-1][ina[0].length-1];\n\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ina[y-1][x]>ina[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t\tsearch(inb);\n\t\t//out(inb);\n\n\t\tresult+=inb[inb.length-1][inb[0].length-1];\n\n\t\tSystem.out.println(result);\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inb[y-1][x]>inb[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t}\n\tstatic void search(long[][] in) {\n\t\tfor(int i=0;i<in.length-1;i++) {\n\t\t\tin[i+1][0]+=in[i][0];\n\t\t}\n\t\tfor(int i=0;i<in[0].length-1;i++) {\n\t\t\tin[0][i+1]+=in[0][i];\n\t\t}\n\t\tfor(int i=1;i<in.length;i++) {\n\t\t\tfor(int j=1;j<in[0].length;j++) {\n\t\t\t\tin[i][j]+=Math.max(in[i-1][j], in[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void out(long[][] in) {\n\t\tfor(long[] i:in)\n\t\t\tSystem.out.println(Arrays.toString(i));\n\t\tSystem.out.println();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n\npublic class Main {\n\tfinal int _intMax = Integer.MAX_VALUE; //=2147483647>10^9\n\tfinal long _longMax = Long.MAX_VALUE; //=9223372036854775807L>10^18\n\tstatic boolean bElapsed = false;\n\tStringBuilder sb = new StringBuilder();\n\tList<Point> list = new ArrayList<>();\n\tSet<String> set = new HashSet<>();\n\tQueue<String> queue = new ArrayDeque<>();\n\tDeque<String> stack = new ArrayDeque<>();\n\tint h;\n\tint w;\n\tint[][] map;\n\tint maxCnt;\n\tList<Point> maxList = new ArrayList<>();\n\n\tvoid solve() {\n\t\tint[] ia = readNums();\n\t\th = ia[0];\n\t\tw = ia[1];\n\t\tmap = new int[h+1][w+1];\n\t\tfor (int y=1; y<=h; y++) {\n\t\t\tia = readNums();\n\t\t\tfor (int x=1; x<=w; x++) {\n\t\t\t\tmap[y][x] = ia[x-1];\n\t\t\t}\n\t\t}\n\t\tlong sum = 0;\n\t\tdfs(1, 1, 0);\n\t\t//pln(maxList.toString());\n\t\tsum += maxCnt;\n\t\tfor (Point pt : maxList) {\n\t\t\tmap[pt.y][pt.x] = 0;\n\t\t}\n\t\tmaxCnt = 0;\n\t\tmaxList = null;\n\t\tdfs(1, 1, 0);\n\t\t//pln(maxList.toString());\n\t\tsum += maxCnt;\n\t\tpln(sum);\n\t}\n\t\n\tvoid dfs(int x, int y, int cnt) {\n\t\tcnt += map[y][x];\n\t\tlist.add(new Point(x, y));\n\t\tif (x == w && y == h) {\n\t\t\tif (maxCnt < cnt) {\n\t\t\t\tmaxCnt = cnt;\n\t\t\t\tmaxList = new ArrayList<>(list);\n\t\t\t}\n\t\t}\n\t\tif (x+1<=w) dfs(x+1, y, cnt);\n\t\tif (y+1<=h) dfs(x, y+1, cnt);\n\t\tlist.remove(list.size()-1);\t\t\n\t}\n\n\tclass Point {\n\t\tint x;\n\t\tint y;\n\t\tpublic Point(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic Point(Point pt) {\n\t\t\tthis.x = pt.x;\n\t\t\tthis.y = pt.y;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Point) {\n\t\t\t\tPoint that = (Point)o;\n\t\t\t\treturn (x == that.x) && (y == that.y);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn x + (y << 16);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \", \" + y + \")\";\n\t\t}\n\t}\n\tclass Info implements Comparable<Info> {\n\t\tint idx;\n\t\tint val;\n\t\tpublic Info(int idx, int val) {\n\t\t\tthis.idx = idx;\n\t\t\tthis.val = val;\n\t\t}\n\t\tpublic int compareTo(Info o) {\n\t\t\treturn idx - o.idx;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Info) {\n\t\t\t\tInfo that = (Info)o;\n\t\t\t\treturn 0 == compareTo(that);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn idx + (val << 16);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + idx + \", \" + val + \")\";\n\t\t}\n\t}\n\tclass InfoComp implements Comparator<Info> {\n\t\tpublic int compare(Info o1, Info o2) {\n\t\t\treturn o1.val - o2.val;\n\t\t}\n\t}\n\tint pint(String s) {\n\t\treturn Integer.parseInt(s);\n\t}\n\tString readLine() {\n\t\ttry {\n\t\t\t_line = _in.readLine();\n\t\t\treturn _line;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\tint readNum() {\n\t\treadLine();\n\t\treturn pint(_line);\n\t}\n\tString[] readFields() {\n\t\treadLine();\n\t\t_flds = _line.split(\" \");\n\t\treturn _flds;\n\t}\n\tint[] readNums() {\n\t\treadFields();\n\t\t_nums = new int[_flds.length];\n\t\tfor (int i=0; i<_flds.length; i++) {\n\t\t\t_nums[i] = pint(_flds[i]);\n\t\t}\n\t\treturn _nums;\n\t}\n\tvoid p(char c) {\n\t\t_out.print(c);\n\t}\n\tvoid pln(char c) {\n\t\t_out.println(c);\n\t}\n\tvoid p(double d) {\n\t\t_out.print(d);\n\t}\n\tvoid pln(double d) {\n\t\t_out.println(d);\n\t}\n\tvoid p(long l) {\n\t\t_out.print(l);\n\t}\n\tvoid pln(long l) {\n\t\t_out.println(l);\n\t}\n\tvoid p(String s) {\n\t\t_out.print(s);\n\t}\n\tvoid pln(String s) {\n\t\t_out.println(s);\n\t}\n\tString _line;\n\tString[] _flds;\n\tint[] _nums;\n\tstatic BufferedReader _in;\n\tstatic PrintWriter _out;\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\t\t_in = new BufferedReader(new InputStreamReader(System.in));\n\t\t_out = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\t_out.flush();\n\t\tlong end = System.currentTimeMillis();\n\t\tif (bElapsed) {\n\t\t\tSystem.err.println((end-start) + \"ms\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int H = sc.nextInt();\n    int W = sc.nextInt();\n    int[][] A = new int[400][400];\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        A[i][j] = sc.nextInt();\n      }\n    }\n    if (H <= 2 || W <= 2) {\n      int ans = 0;\n      for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n          ans += A[i][j];\n        }\n      }\n      System.out.println(ans);\n      return;\n    }\n    int[][][] dp = new int[2][H + W][H + W];\n    dp[0][0][1] = A[0][0] + A[1][0] + A[0][1];\n    int t = 1;\n    for (int i = 1; i < H + W - 3; i++) {\n      int len = i + 1;\n      for (int j = 0; j < dp[0].length; j++) {\n        Arrays.fill(dp[t][j], 0);\n      }\n      for (int j = 0; j < len; j++) {\n        for (int k = j + 1; k < len; k++) {\n          dp[t][j][k] = Math.max(dp[t][j][k], dp[1 - t][j][k] + A[i + 1 - j][j] + A[i + 1 - k][k]);\n          dp[t][j][k + 1] = Math.max(dp[t][j][k + 1], dp[1 - t][j][k] + A[i + 1 - j][j] + A[i - k][k + 1]);\n          if (k > j + 1) {\n            dp[t][j + 1][k] = Math.max(dp[t][j + 1][k], dp[1 - t][j][k] + A[i - j][j + 1] + A[i + 1 - k][k]);\n          }\n          dp[t][j + 1][k + 1] = Math.max(dp[t][j + 1][k + 1], dp[1 - t][j][k] + A[i - j][j + 1] + A[i - k][k + 1]);\n        }\n      }\n      t = 1 - t;\n    }\n    System.out.println(dp[1 - t][W - 2][W - 1] + A[H - 1][W - 1]);\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "package src;\nimport java.util.*;\nimport java.util.function.LongBinaryOperator;\nclass Main{\n\tstatic Scanner s = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tlong[][] ina = new long[Integer.parseInt(s.next())][Integer.parseInt(s.next())],\n\t\t         inb = new long[ina.length][ina[0].length];\n\t\tlong result = 0;\n\t\tfor(int i=0;i<ina.length;i++)\n\t\t\tfor(int j=0;j<ina[0].length;j++) {\n\t\t\t\tina[i][j]=Integer.parseInt(s.next());\n\t\t\t\tinb[i][j]=ina[i][j];\n\t\t\t}\n\t\t//out(ina);\n\t\tif(ina.length==1) {\n\t\t\tArrays.parallelPrefix(ina[0], (LongBinaryOperator) (left, right) -> left+right);\n\t\t\treturn;\n\t\t}\n\t\tif(ina[0].length==1) {\n\t\t\tint i=0;\n\t\t\tfor(long j:ina[0]) {\n\t\t\t\ti+=j;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsearch(ina);\n\n\t\t//out(ina);\n\n\t\tresult+=ina[ina.length-1][ina[0].length-1];\n\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ina[y-1][x]>ina[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t\tsearch(inb);\n\t\t//out(inb);\n\n\t\tresult+=inb[inb.length-1][inb[0].length-1];\n\n\t\tSystem.out.println(result);\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inb[y-1][x]>inb[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t}\n\tstatic void search(long[][] in) {\n\t\tfor(int i=0;i<in.length-1;i++) {\n\t\t\tin[i+1][0]+=in[i][0];\n\t\t}\n\t\tfor(int i=0;i<in[0].length-1;i++) {\n\t\t\tin[0][i+1]+=in[0][i];\n\t\t}\n\t\tfor(int i=1;i<in.length;i++) {\n\t\t\tfor(int j=1;j<in[0].length;j++) {\n\t\t\t\tin[i][j]+=Math.max(in[i-1][j], in[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void out(long[][] in) {\n\t\tfor(long[] i:in)\n\t\t\tSystem.out.println(Arrays.toString(i));\n\t\tSystem.out.println();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  private static int H;\n  private static int W;\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    H = sc.nextInt();\n    W = sc.nextInt();\n    \n    int[][] map = new int[H][W];\n    for (int i = 0; i < H; i ++) {\n      for (int j = 0; j < W;j ++) {\n        map[i][j] = sc.nextInt();\n      }\n    }\n    \n\n    System.out.println(solve2(map));\n  }\n  \n  \n  private static long solve2(int[][] map) {\n    long[][] from = new long[W][W];\n    long[][] to = new long[W][W];\n    \n    from[0][0] = map[0][0];\n    for (int i = 1; i < H + W - 1; i ++) {\n      int xMin = Math.max(0, i - (W - 1));\n      int xMax = Math.min(W - 1, i);\n\n      for (int x1 = xMin; x1 <= xMax; x1 ++) {\n        int y1 = i - x1;\n        if (y1 >= H) continue;\n        \n        for (int x2 = xMin; x2 <= xMax; x2 ++) {\n          int y2 = i - x2;\n          if (y2 >= H) continue;\n          \n          \n          long now = x1 == x2 ? map[y1][x1] : (map[y1][x1] + map[y2][x2]);\n          to[x1][x2] = from[x1][x2];\n          if (x2 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1][x2 - 1]);\n          }\n          if (x1 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1 - 1][x2]);\n          }\n          if (x1 > 0 && x2 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1 - 1][x2 - 1]);\n          }\n          to[x1][x2] += now;\n        }\n      }\n      long[][] tmp = from;\n      from = to;\n      to = tmp;\n    }\n    return from[W - 1][W - 1];\n  }\n\n}\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int H, W;\n    static int[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        C = new int[H][];\n        for (int h = 0; h < H; h++) {\n            C[h] = sc.nextIntArray(W);\n        }\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        // turn, Aのいる場所(w), Bのいる場所(w)\n        int[][][] dp = new int[H+W-1][W][W];\n        dp[0][0][0] = C[0][0];\n\n        for (int turn = 1; turn < H+W-1; turn++) {\n            for (int aw = 0; aw < W; aw++) {\n                // w + h = turn\n                int ah = turn - aw;\n                if( ah < 0 || H <= ah ) continue;\n\n                for (int bw = 0; bw < W; bw++) {\n                    int bh = turn - bw;\n                    if( bh < 0 || H <= bh ) continue;\n\n                    int v = max(value(dp, turn-1, aw, bw), value(dp, turn-1, aw-1, bw), value(dp, turn-1, aw, bw-1), value(dp, turn-1, aw-1, bw-1));\n                    if( aw != bw ) {\n                        v += C[ah][aw] + C[bh][bw];\n                    } else {\n                        v += C[ah][aw];\n                    }\n                    dp[turn][aw][bw] = v;\n                    // debug(turn, ah, aw, bh, bw, v);\n                }\n            }\n        }\n        return dp[H+W-2][W-1][W-1];\n    }\n\n    static int value(int[][][] dp, int turn, int aw, int bw) {\n        if( 0 <= aw && aw < W && 0 <= bw && bw < W ) {\n            return dp[turn][aw][bw];\n        } else {\n            return 0;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n\npublic class Main {\n  private static int H;\n  private static int W;\n  public static void main(String[] args) {\n    FastScanner sc = new FastScanner();\n    H = sc.nextInt();\n    W = sc.nextInt();\n    \n    int[][] map = new int[H][W];\n    for (int i = 0; i < H; i ++) {\n      for (int j = 0; j < W;j ++) {\n        map[i][j] = sc.nextInt();\n      }\n    }\n    \n\n    System.out.println(solve2(map));\n  }\n  \n  \n  private static long solve2(int[][] map) {\n    long[][] from = new long[W][W];\n    long[][] to = new long[W][W];\n    \n    from[0][0] = map[0][0];\n    for (int i = 1; i < H + W - 1; i ++) {\n      int xMin = Math.max(0, i - (W - 1));\n      int xMax = Math.min(W - 1, i);\n\n      for (int x1 = xMin; x1 <= xMax; x1 ++) {\n        int y1 = i - x1;\n        \n        \n        for (int x2 = xMin; x2 <= xMax; x2 ++) {\n          int y2 = i - x2;\n          \n          \n          long now = x1 == x2 ? map[y1][x1] : (map[y1][x1] + map[y2][x2]);\n          to[x1][x2] = from[x1][x2];\n          if (x2 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1][x2 - 1]);\n          }\n          if (x1 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1 - 1][x2]);\n          }\n          if (x1 > 0 && x2 > 0) {\n            to[x1][x2] = Math.max(to[x1][x2], from[x1 - 1][x2 - 1]);\n          }\n          to[x1][x2] += now;\n        }\n      }\n      long[][] tmp = from;\n      from = to;\n      to = tmp;\n    }\n    return from[W - 1][W - 1];\n  }\n\n}\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static HashMap<Integer, Integer> dp = new HashMap<>();\n    static int h;\n    static int w;\n    static int[][] field;\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        h = sc.nextInt();\n        w = sc.nextInt();\n        field = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                field[i][j] = sc.nextInt();\n            }\n        }\n        System.out.println(dfw(h - 1, w - 1, h - 1, w - 1));\n    }\n    \n    static int dfw(int h1, int w1, int h2, int w2) {\n        if (h1 == 0 && w1 == 0 && h2 == 0 && w2 == 0) {\n            return field[0][0];\n        }\n        if (h1 < 0 || w1 < 0 || h2 < 0 || w2 < 0) {\n            return -1;\n        }\n        int first = h1 * w + w1;\n        int second = h2 * w + w2;\n        int key = Math.min(first, second) * h * w + Math.max(first, second);\n        if (dp.containsKey(key)) {\n            return dp.get(key);\n        }\n        int max = 0;\n        int now;\n        if (h1 == h - 1 && w1 == w - 1 && h2 == h - 1 && w2 == w - 1) {\n            now = field[h - 1][w - 1];\n        } else if (h1 == h2 && w1 == w2) {\n            return -1;\n        } else {\n            now = field[h1][w1] + field[h2][w2];\n        }\n        max = Math.max(max, dfw(h1 - 1, w1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1 - 1, w1, h2, w2 - 1));\n        max = Math.max(max, dfw(h1, w1 - 1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1, w1 - 1, h2, w2 - 1));\n        dp.put(key, max + now);\n        return max + now;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tlong[][] a = new long[H][W];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\ta[i][j] = sc.nextLong();\n\t\t\t}\n\t\t}\n\n\t\tlong[][][] dp = new long[2][200][200];\n\t\tdp[0][0][0] = a[0][0];\n\t\tfor (int t = 0; t < H + W - 2; ++t) {\n\t\t\tint next = (t + 1) % 2;\n\t\t\tint pre = t % 2;\n\t\t\tfor (int i = 0; i < 200; ++i) {\n\t\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\t\tif (!(0 <= i && i < H && 0 <= j && j < H && 0 <= t - i && t - i < W && 0 <= t - j && t - j < W))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int to1 = 0; to1 <= 1; ++to1) {\n\t\t\t\t\t\tfor (int to2 = 0; to2 <= 1; ++to2) {\n\n\t\t\t\t\t\t\tif (!(0 <= i + to1 && i + to1 < H && 0 <= j + to2 && j + to2 < H && 0 <= t - i + (to1 ^ 1)\n\t\t\t\t\t\t\t\t\t&& t - i + (to1 ^ 1) < W && 0 <= t - j + (to2 ^ 1) && t - j + (to2 ^ 1) < W))\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tlong get = a[i + to1][t - i + (to1 ^ 1)] + a[j + to2][t - j + (to2 ^ 1)];\n\t\t\t\t\t\t\tif (i + to1 == j + to2 && t - i + (to1 ^ 1) == t - j + (to2 ^ 1))\n\t\t\t\t\t\t\t\tget /= 2;\n\t\t\t\t\t\t\tdp[next][i + to1][j + to2] = Math.max(dp[next][i + to1][j + to2], dp[pre][i][j] + get);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[(H + W - 2) % 2][H - 1][H - 1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tboolean[] isPrime = new boolean[100001];\n\tint[] tmp = new int[100001];\n\tint[] mu = new int[100001];\n\t{\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (!isPrime[i])\n\t\t\t\tcontinue;\n\t\t\tfor (int j = 2 * i; j < isPrime.length; j += i) {\n\t\t\t\tisPrime[j] = false;\n\t\t\t}\n\t\t}\n\t\tArrays.fill(tmp, 1);\n\t\tArrays.fill(mu, 1);\n\t\tmu[0] = mu[1] = 0;\n\t\tfor (int i = 2; i < isPrime.length; ++i) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i; j < isPrime.length; j += i) {\n\t\t\t\t\ttmp[j] *= i;\n\t\t\t\t\tmu[j] *= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 2; i < mu.length; ++i) {\n\t\t\tif (tmp[i] != i) {\n\t\t\t\tmu[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint H = sc.nextInt();\n\t\tint W = sc.nextInt();\n\t\tlong[][] a = new long[H][W];\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\ta[i][j] = sc.nextLong();\n\t\t\t}\n\t\t}\n\n\t\tlong[][][] dp = new long[2][200][200];\n\t\tdp[0][0][0] = a[0][0];\n\t\tfor (int t = 0; t < H + W - 2; ++t) {\n\t\t\tint next = (t + 1) % 2;\n\t\t\tint pre = t % 2;\n\t\t\tfor (int i = 0; i < 200; ++i) {\n\t\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\t\tif (!(0 <= i && i < H && 0 <= j && j < H && 0 <= t - i && t - i < W && 0 <= t - j && t - j < W))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int to1 = 0; to1 <= 1; ++to1) {\n\t\t\t\t\t\tfor (int to2 = 0; to2 <= 1; ++to2) {\n\n\t\t\t\t\t\t\tif (!(0 <= i + to1 && i + to1 < H && 0 <= j + to2 && j + to2 < H && 0 <= t - i + (to1 ^ 1)\n\t\t\t\t\t\t\t\t\t&& t - i + (to1 ^ 1) < W && 0 <= t - j + (to2 ^ 1) && t - j + (to2 ^ 1) < W))\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tlong get = a[i + to1][t - i + (to1 ^ 1)] + a[j + to2][t - j + (to2 ^ 1)];\n\t\t\t\t\t\t\tif (i + to1 == j + to2 && t - i + (to1 ^ 1) == t - j + (to2 ^ 1))\n\t\t\t\t\t\t\t\tget /= 2;\n\t\t\t\t\t\t\tdp[next][i + to1][j + to2] = Math.max(dp[next][i + to1][j + to2], dp[pre][i][j] + get);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[(H + W - 2) % 2][H - 1][H - 1]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static HashMap<Integer, Integer> dp = new HashMap<>();\n    static int h;\n    static int w;\n    static int[][] field;\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] first = br.readLine().split(\" \", 2);\n        h = Integer.parseInt(first[0]);\n        w = Integer.parseInt(first[1]);\n        field = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            String[] line = br.readLine().split(\" \", w);\n            for (int j = 0; j < w; j++) {\n                field[i][j] = Integer.parseInt(line[j]);\n            }\n        }\n        System.out.println(dfw(h - 1, w - 1, h - 1, w - 1));\n    }\n    \n    static int dfw(int h1, int w1, int h2, int w2) {\n        if (h1 == 0 && w1 == 0 && h2 == 0 && w2 == 0) {\n            return field[0][0];\n        }\n        if (h1 < 0 || w1 < 0 || h2 < 0 || w2 < 0) {\n            return -1;\n        }\n        int first = h1 * w + w1;\n        int second = h2 * w + w2;\n        int key = Math.min(first, second) * h * w + Math.max(first, second);\n        if (dp.containsKey(key)) {\n            return dp.get(key);\n        }\n        int max = 0;\n        int now;\n        if (h1 == h - 1 && w1 == w - 1 && h2 == h - 1 && w2 == w - 1) {\n            now = field[h - 1][w - 1];\n        } else if (h1 == h2 && w1 == w2) {\n            return -1;\n        } else {\n            now = field[h1][w1] + field[h2][w2];\n        }\n        max = Math.max(max, dfw(h1 - 1, w1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1 - 1, w1, h2, w2 - 1));\n        max = Math.max(max, dfw(h1, w1 - 1, h2 - 1, w2));\n        max = Math.max(max, dfw(h1, w1 - 1, h2, w2 - 1));\n        dp.put(key, max + now);\n        return max + now;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] a = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = na(m);\n\t\t}\n\t\t\n\t\tint[][] pre = new int[n+m][n+m];\n\t\tint[][] cur = new int[n+m][n+m];\n\t\tfor(int i = 0;i < n+m;i++){\n\t\t\tArrays.fill(pre[i], Integer.MIN_VALUE / 2);\n\t\t\tArrays.fill(cur[i], Integer.MIN_VALUE / 2);\n\t\t}\n\t\tpre[m-1][m-1] = a[0][0];\n\t\tfor(int i = 1;i < n+m-1;i++){\n\t\t\tfor(int k = 0;k < n+m;k++){\n\t\t\t\tint rk = (i+k-(m-1));\n\t\t\t\tint ck = (i-(k-(m-1)));\n\t\t\t\tif(!((rk&1) == 0 && (ck&1) == 0))continue;\n\t\t\t\trk /= 2; ck /= 2;\n\t\t\t\tfor(int l = 0;l < n+m;l++){\n\t\t\t\t\tint rl = (i+l-(m-1));\n\t\t\t\t\tint cl = (i-(l-(m-1)));\n\t\t\t\t\tif(!((rl&1) == 0 && (cl&1) == 0))continue;\n\t\t\t\t\trl /= 2; cl /= 2;\n\t\t\t\t\tint z = 0;\n\t\t\t\t\tfor(int u = k-1;u <= k+1;u++){\n\t\t\t\t\t\tfor(int v = l-1;v <= l+1;v++){\n\t\t\t\t\t\t\tif(u >= 0 && u < n+m && v >= 0 && v < n+m){\n\t\t\t\t\t\t\t\tz = Math.max(z, pre[u][v]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(z < 0){\n\t\t\t\t\t\tcur[k][l] = Integer.MIN_VALUE / 2;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// r+c = i\n\t\t\t\t\t// r-c+m-1 = k\n\t\t\t\t\tif(rk >= 0 && rk < n && ck >= 0 && ck < m){\n\t\t\t\t\t\tz += a[rk][ck];\n\t\t\t\t\t}\n\t\t\t\t\tif(rl >= 0 && rl < n && cl >= 0 && cl < m && k != l){\n\t\t\t\t\t\tz += a[rl][cl];\n\t\t\t\t\t}\n\t\t\t\t\tcur[k][l] = z;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dum = pre; pre = cur; cur = dum;\n\t\t}\n\t\tout.println(pre[n-1][n-1]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n//\t\tint n = 200, m = 99999;\n//\t\tRandom gen = new Random();\n//\t\tStringBuilder sb = new StringBuilder();\n//\t\tsb.append(n + \" \");\n//\t\tsb.append(n + \" \");\n//\t\tfor (int i = 0; i < n*n; i++) {\n//\t\t\tsb.append(gen.nextInt(100000) + \" \");\n//\t\t}\n//\t\tINPUT = sb.toString();\n\n\t\t\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    MyScanner sc    = new MyScanner();\n    Scanner   sc2   = new Scanner(System.in);\n    long      start = System.currentTimeMillis();\n    long      fin   = System.currentTimeMillis();\n    final int MOD   = 1000000007;\n    int[]     dx    = { 1, 0, 0, -1 };\n    int[]     dy    = { 0, 1, -1, 0 };\n\n    void run() {\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] a = sc.nextInt2dArray(H, W);\n        if(H > 2) return;\n        int res = 0;\n        for (int i = 1; i < W; i++) {\n            int score = 0;\n            for (int j = 0; j <= i; j++) score += a[0][j];\n            for (int j = i; j < W; j++)  score += a[1][j];\n            for (int j = 0; j <= i - 1; j++) score += a[1][j];\n            res = Math.max(res, score);\n        }\n        System.out.println(res);\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n\n    void debug2(int[][] array) {\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                System.out.print(array[i][j]);\n            }\n            System.out.println();\n        }\n    }\n\n    boolean inner(int h, int w, int limH, int limW) {\n        return 0 <= h && h < limH && 0 <= w && w < limW;\n    }\n\n    void swap(int[] x, int a, int b) {\n        int tmp = x[a];\n        x[a] = x[b];\n        x[b] = tmp;\n    }\n\n    // find minimum i (k <= a[i])\n    int lower_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k <= a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    // find minimum i (k < a[i])\n    int upper_bound(int a[], int k) {\n        int l = -1;\n        int r = a.length;\n        while (r - l > 1) {\n            int mid = (l + r) / 2;\n            if (k < a[mid])\n                r = mid;\n            else\n                l = mid;\n        }\n        // r = l + 1\n        return r;\n    }\n\n    long gcd(long a, long b) {\n        return a % b == 0 ? b : gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    boolean palindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    class MyScanner {\n        int nextInt() {\n            try {\n                int c = System.in.read();\n                while (c != '-' && (c < '0' || '9' < c))\n                    c = System.in.read();\n                if (c == '-')\n                    return -nextInt();\n                int res = 0;\n                do {\n                    res *= 10;\n                    res += c - '0';\n                    c = System.in.read();\n                } while ('0' <= c && c <= '9');\n                return res;\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String next() {\n            try {\n                StringBuilder res = new StringBuilder(\"\");\n                int c = System.in.read();\n                while (Character.isWhitespace(c))\n                    c = System.in.read();\n                do {\n                    res.append((char) c);\n                } while (!Character.isWhitespace(c = System.in.read()));\n                return res.toString();\n            } catch (Exception e) {\n                return null;\n            }\n        }\n\n        int[] nextIntArray(int n) {\n            int[] in = new int[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextInt();\n            }\n            return in;\n        }\n\n        int[][] nextInt2dArray(int n, int m) {\n            int[][] in = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextIntArray(m);\n            }\n            return in;\n        }\n\n        double[] nextDoubleArray(int n) {\n            double[] in = new double[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextDouble();\n            }\n            return in;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] in = new long[n];\n            for (int i = 0; i < n; i++) {\n                in[i] = nextLong();\n            }\n            return in;\n        }\n\n        char[][] nextCharField(int n, int m) {\n            char[][] in = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                String s = sc.next();\n                for (int j = 0; j < m; j++) {\n                    in[i][j] = s.charAt(j);\n                }\n            }\n            return in;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package src;\nimport java.util.*;\nimport java.util.function.LongBinaryOperator;\nclass Main{\n\tstatic Scanner s = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tlong[][] ina = new long[Integer.parseInt(s.next())][Integer.parseInt(s.next())],\n\t\t         inb = new long[ina.length][ina[0].length];\n\t\tlong result = 0;\n\t\tfor(int i=0;i<ina.length;i++)\n\t\t\tfor(int j=0;j<ina[0].length;j++) {\n\t\t\t\tina[i][j]=Integer.parseInt(s.next());\n\t\t\t\tinb[i][j]=ina[i][j];\n\t\t\t}\n\t\t//out(ina);\n\t\tif(ina.length==1) {\n\t\t\tArrays.parallelPrefix(ina[0], (LongBinaryOperator) (left, right) -> left+right);\n\t\t\treturn;\n\t\t}\n\t\tif(ina[0].length==1) {\n\t\t\tint i=0;\n\t\t\tfor(long j:ina[0]) {\n\t\t\t\ti+=j;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tsearch(ina);\n\n\t\t//out(ina);\n\n\t\tresult+=ina[ina.length-1][ina[0].length-1];\n\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ina[y-1][x]>ina[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t\tsearch(inb);\n\t\t//out(inb);\n\n\t\tresult+=inb[inb.length-1][inb[0].length-1];\n\n\t\tSystem.out.println(result);\n\t\t{\n\t\t\tint x=inb[0].length-1,y=inb.length-1;\n\t\t\twhile(true) {\n\t\t\t\tinb[y][x]=0;\n\t\t\t\tif(x==0) {\n\t\t\t\t\tfor(int i=0;i<y;i++) {\n\t\t\t\t\t\tinb[i][0]=0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(y==0) {\n\t\t\t\t\tArrays.fill(inb[0],0,x, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(inb[y-1][x]>inb[y][x-1]) {\n\t\t\t\t\ty--;\n\t\t\t\t}else {\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//out(inb);\n\t}\n\tstatic void search(long[][] in) {\n\t\tfor(int i=0;i<in.length-1;i++) {\n\t\t\tin[i+1][0]+=in[i][0];\n\t\t}\n\t\tfor(int i=0;i<in[0].length-1;i++) {\n\t\t\tin[0][i+1]+=in[0][i];\n\t\t}\n\t\tfor(int i=1;i<in.length;i++) {\n\t\t\tfor(int j=1;j<in[0].length;j++) {\n\t\t\t\tin[i][j]+=Math.max(in[i-1][j], in[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void out(long[][] in) {\n\t\tfor(long[] i:in)\n\t\t\tSystem.out.println(Arrays.toString(i));\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int H,W;\n    int[,] a; \n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[,,,] dp = new long[H,W,H,W];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<H;k++){\n                    for(int l=0;l<W;l++){\n                        if(i == 0 && j == 0 && k == 0 && l == 0){\n                            dp[i,j,k,l] = a[i,j];\n                        }\n                        else if(i == H-1 && j == W-1 && k == H-1 && l == W-1){\n                            long max = dp[i-1,j,k-1,l];\n                            if(max < dp[i-1,j,k,l-1]){\n                                max = dp[i-1,j,k,l-1];\n                            }\n                            if(max < dp[i,j-1,k-1,l]){\n                                max = dp[i,j-1,k-1,l];\n                            }\n                            if(max < dp[i,j-1,k,l-1]){\n                                max = dp[i,j-1,k,l-1];\n                            }\n                            dp[i,j,k,l] = max + a[H-1,W-1];\n                        }\n                        else if((i == k && j == l) || (i+j != k+l)){\n                            dp[i,j,k,l] = 0;\n                        }\n                        else{\n                            long max = 0;\n                            if(i != 0 && k != 0){\n                                max = dp[i-1,j,k-1,l];\n                            }\n                            if(i != 0 && l != 0 && max < dp[i-1,j,k,l-1]){\n                                max = dp[i-1,j,k,l-1];\n                            }\n                            if(j != 0 && k != 0 && max < dp[i,j-1,k-1,l]){\n                                max = dp[i,j-1,k-1,l];\n                            }\n                            if(j != 0 && l != 0 && max < dp[i,j-1,k,l-1]){\n                                max = dp[i,j-1,k,l-1];\n                            }\n                            dp[i,j,k,l] = max + a[i,j] + a[k,l];\n                        }\n                    }\n                }\n            }\n        }\n        sb.Append(dp[H-1,W-1,H-1,W-1]+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        H = int.Parse(str[0]);\n        W = int.Parse(str[1]);\n        a = new int[H,W];\n        for(int i=0;i<H;i++){\n            str = Console.ReadLine().Split(' ');\n            for(int j=0;j<W;j++){\n                a[i,j] = int.Parse(str[j]);\n            }\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int H,W;\n    int[,] a; \n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[,,] dp = new long[H,W,H];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<H;k++){\n                    if(i == 0 && j == 0 && k == 0){\n                        dp[i,j,k] = a[i,j];\n                    }\n                    else if(i == H-1 && j == W-1 && k == H-1){\n                        long max = dp[i-1,j,k-1];\n                        if(max < dp[i-1,j,k]){\n                            max = dp[i-1,j,k];\n                        }\n                        if(max < dp[i,j-1,k-1]){\n                            max = dp[i,j-1,k-1];\n                        }\n                        if(max < dp[i,j-1,k]){\n                            max = dp[i,j-1,k];\n                        }\n                        dp[i,j,k] = max + a[H-1,W-1];\n                    }\n                    else if(i == k){\n                        dp[i,j,k] = 0;\n                    }\n                    else if(i+j >= k && i+j-k < W){\n                        long max = 0;\n                        if(i != 0 && k != 0){\n                            max = dp[i-1,j,k-1];\n                        }\n                        if(i != 0 && k != (i+j) && max < dp[i-1,j,k]){\n                            max = dp[i-1,j,k];\n                        }\n                        if(j != 0 && k != 0 && max < dp[i,j-1,k-1]){\n                            max = dp[i,j-1,k-1];\n                        }\n                        if(j != 0 && k != (i+j) && max < dp[i,j-1,k]){\n                            max = dp[i,j-1,k];\n                        }\n                        dp[i,j,k] = max + a[i,j] + a[k,i+j-k];\n                    }\n                    else{\n                        dp[i,j,k] = 0;\n                    }\n                }\n            }\n        }\n        sb.Append(dp[H-1,W-1,H-1]+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        H = int.Parse(str[0]);\n        W = int.Parse(str[1]);\n        a = new int[H,W];\n        for(int i=0;i<H;i++){\n            str = Console.ReadLine().Split(' ');\n            for(int j=0;j<W;j++){\n                a[i,j] = int.Parse(str[j]);\n            }\n        }\n    }    \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nusing C = System.Int32;\nusing V = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var h = sc.Integer();\n            var w = sc.Integer();\n            var a = Enumerate(h, x => sc.Integer(w));\n            var dp = new int[w, w];\n            for (int i = 0; i < w; i++)\n                for (int j = 0; j < w; j++)\n                    dp[i, j] = -1000000000;\n            dp[0, 0] = a[0][0];\n            var dx = new int[] { 0, 1 };\n            var dy = new int[] { 1, 0 };\n            for (int d = 0; d < h + w - 2; d++)\n            {\n                var next = new int[w, w];\n                for (int i = 0; i < w; i++)\n                    for (int j = 0; j < w; j++)\n                        next[i, j] = -1000000000;\n                for (int i = 0; i < w; i++)\n                    for (int j = 0; j < w; j++)\n                    {\n                        if (dp[i, j] < 0) continue;\n                        var px = d - i;\n                        var py = i;\n                        var qx = d - j;\n                        var qy = j;\n                        for (int u = 0; u < 2; u++)\n                            for (int v = 0; v < 2; v++)\n                            {\n                                var npx = px + dx[u];\n                                var npy = py + dy[u];\n                                var nqx = qx + dx[v];\n                                var nqy = qy + dy[v];\n                                if (npx >= h || npy >= w) continue;\n                                if (nqx >= h || nqy >= w) continue;\n                                if (npy == nqy) next[npy, nqy] = Math.Max(next[npy, nqy], dp[i, j] + a[npx][npy]);\n                                else next[npy, nqy] = Math.Max(next[npy, nqy], dp[i, j] + a[npx][npy] + a[nqx][nqy]);\n\n                            }\n\n                    }\n                dp = next;\n\n            }\n            IO.Printer.Out.WriteLine(dp[w - 1, w - 1]);\n\n\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    int H,W;\n    int[,] a; \n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Read();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        long[,,] dp = new long[H,W,H];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<H;k++){\n                    if(i == 0 && j == 0 && k == 0 &&){\n                        dp[i,j,k] = a[i,j];\n                    }\n                    else if(i == H-1 && j == W-1 && k == H-1){\n                        long max = dp[i-1,j,k-1];\n                        if(max < dp[i-1,j,k]){\n                            max = dp[i-1,j,k];\n                        }\n                        if(max < dp[i,j-1,k-1]){\n                            max = dp[i,j-1,k-1];\n                        }\n                        if(max < dp[i,j-1,k]){\n                            max = dp[i,j-1,k];\n                        }\n                        dp[i,j,k] = max + a[H-1,W-1];\n                    }\n                    else if(i == k){\n                        dp[i,j,k] = 0;\n                    }\n                    else{\n                        long max = 0;\n                        if(i != 0 && k != 0){\n                            max = dp[i-1,j,k-1];\n                        }\n                        if(i != 0 && k != (i+j) && max < dp[i-1,j,k]){\n                            max = dp[i-1,j,k];\n                        }\n                        if(j != 0 && k != 0 && max < dp[i,j-1,k-1]){\n                            max = dp[i,j-1,k-1];\n                        }\n                        if(j != 0 && k != (i+j) && max < dp[i,j-1,k]){\n                            max = dp[i,j-1,k];\n                        }\n                        dp[i,j,k,l] = max + a[i,j] + a[k,i+j-k];\n                    }\n                }\n            }\n        }\n        sb.Append(dp[H-1,W-1,H-1]+\"\\n\");\n    }\n    void Read(){\n        string[] str = Console.ReadLine().Split(' ');\n        H = int.Parse(str[0]);\n        W = int.Parse(str[1]);\n        a = new int[H,W];\n        for(int i=0;i<H;i++){\n            str = Console.ReadLine().Split(' ');\n            for(int j=0;j<W;j++){\n                a[i,j] = int.Parse(str[j]);\n            }\n        }\n    }    \n}"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (declare #.OPT)\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;;;\n;;; Minimum cost flow (Primal-Dual, O(FElogV))\n;;;\n\n(setf *print-circle* t)\n\n;; COST-TYPE and +INF-COST+ may be changed. (A supposed use case is to adopt\n;; bignum).\n(deftype cost-type () '(signed-byte 32))\n(defconstant +inf-cost+ #x7fffffff)\n(assert (and (typep +inf-cost+ 'cost-type)\n             (subtypep 'cost-type 'integer)))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (cost 0 :type cost-type)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity cost graph)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare ((simple-array list (*)) graph)\n           (cost-type cost))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity :cost cost))\n         (ret (%make-edge :to from-idx :capacity 0 :cost (- cost) :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n;; binary heap for Dijkstra's algorithm\n(defstruct (fheap (:constructor make-fheap\n                          (size\n                           &aux (costs (make-array (1+ size) :element-type 'cost-type))\n                                (vertices (make-array (1+ size) :element-type 'fixnum)))))\n  (costs nil :type (simple-array cost-type (*)))\n  (vertices nil :type (simple-array fixnum (*)))\n  (position 1 :type (integer 1 #.most-positive-fixnum)))\n\n(defun fheap-push (cost vertex fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (when (>= position (length (fheap-costs fheap)))\n      (setf (fheap-costs fheap)\n            (adjust-array (fheap-costs fheap) (* position 2))\n            (fheap-vertices fheap)\n            (adjust-array (fheap-vertices fheap) (* position 2))))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0)))\n                 (unless (= pos 1)\n                   (let ((parent-pos (ash pos -1)))\n                     (when (< (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref vertices pos) (aref vertices parent-pos))\n                       (update parent-pos))))))\n        (setf (aref costs position) cost\n              (aref vertices position) vertex)\n        (update position)\n        (incf position)\n        fheap))))\n\n(defun fheap-pop (fheap)\n  (declare #.OPT)\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0))\n                          ((integer 1 #.most-positive-fixnum) pos))\n                 (let* ((child-pos1 (+ pos pos))\n                        (child-pos2 (1+ child-pos1)))\n                   (when (<= child-pos1 position)\n                     (if (<= child-pos2 position)\n                         (if (< (aref costs child-pos1) (aref costs child-pos2))\n                             (unless (< (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref vertices pos) (aref vertices child-pos1))\n                               (update child-pos1))\n                             (unless (< (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref vertices pos) (aref vertices child-pos2))\n                               (update child-pos2)))\n                         (unless (< (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))\n        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))\n          (decf position)\n          (setf (aref costs 1) (aref costs position)\n                (aref vertices 1) (aref vertices position))\n          (update 1))))))\n\n(declaim (inline fheap-empty-p))\n(defun fheap-empty-p (fheap)\n  (= (fheap-position fheap) 1))\n\n(declaim (inline fheap-reinitialize))\n(defun fheap-reinitialize (heap)\n  (setf (fheap-position heap) 1)\n  heap)\n\n(define-condition not-enough-capacity-error (error)\n  ((graph :initarg :graph :reader not-enough-capacity-error-graph)\n   (flow :initarg :flow :reader not-enough-capacity-error-flow))\n  (:report\n   (lambda (c s)\n     (format s \"Cannot send ~A units of flow on graph ~A due to not enough capacity.\"\n             (not-enough-capacity-error-flow c)\n             (not-enough-capacity-error-graph c)))))\n\n(defun min-cost-flow! (src-idx dest-idx flow graph &key density)\n  \"Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in\nGRAPH. Destructively modifies GRAPH.\n\nDENSITY := nil | the number of edges (assumed to be (size of GRAPH)*2 if NIL)\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) flow)\n           ((simple-array list (*)) graph))\n  (macrolet ((the-cost-type (form)\n               (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))\n\t\t       (cdr form))))\n    (let* ((size (length graph))\n           (density (or density (* size 2)))\n           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))\n           (prev-edges (make-array size :element-type 'edge))\n           (potential (make-array size :element-type 'cost-type :initial-element 0))\n           (dist (make-array size :element-type 'cost-type))\n           (pqueue (make-fheap density))\n           (res 0))\n      (declare (fixnum density)\n               (cost-type res))\n      (loop while (> flow 0)\n            do (fill dist +inf-cost+)\n               (setf (aref dist src-idx) 0)\n               (fheap-reinitialize pqueue)\n               (fheap-push 0 src-idx pqueue)\n               (loop until (fheap-empty-p pqueue)\n                     do (multiple-value-bind (cost v) (fheap-pop pqueue)\n                          (declare (cost-type cost)\n                                   (fixnum v))\n                          (when (<= cost (aref dist v))\n                            (dolist (edge (aref graph v))\n                              (let* ((next-v (edge-to edge))\n                                     (next-cost (the-cost-type\n                                                 (+ (aref dist v)\n                                                    (edge-cost edge)\n                                                    (aref potential v)\n                                                    (- (aref potential next-v))))))\n                                (when (and (> (edge-capacity edge) 0)\n                                           (> (aref dist next-v) next-cost))\n                                  (setf (aref dist next-v) next-cost\n                                        (aref prev-vertices next-v) v\n                                        (aref prev-edges next-v) edge)\n                                  (fheap-push next-cost next-v pqueue)))))))\n               (when (= (aref dist dest-idx) +inf-cost+)\n                 (error 'not-enough-capacity-error :flow flow :graph graph))\n               (let ((max-flow flow))\n                 (declare (fixnum max-flow))\n                 (dotimes (v size)\n                   (setf (aref potential v)\n                         (min +inf-cost+\n                              (+ (aref potential v) (aref dist v)))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (setf max-flow (min max-flow (edge-capacity (aref prev-edges v)))))\n                 (decf flow max-flow)\n                 (incf res (the cost-type (* max-flow (aref potential dest-idx))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (decf (edge-capacity (aref prev-edges v)) max-flow)\n                   (incf (edge-capacity (edge-reversed (aref prev-edges v))) max-flow))))\n      res)))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (as (make-array (list h w) :element-type 'uint31))\n         (graph (make-array (* h w 2) :element-type 'list :initial-element nil)))\n    (declare (uint16 h w))\n    (labels ((encode (y x dir)\n               (let ((res (if (eql dir :in)\n                              (* 2 (+ (* w y) x))\n                              (+ (* 2 (+ (* w y) x)) 1))))\n                 res)))\n      (dotimes (i h)\n        (dotimes (j w)\n          (let ((a (read-fixnum)))\n            (setf (aref as i j) a)\n            (push-edge (encode i j :in)\n                       (encode i j :out)\n                       1\n                       (- a)\n                       graph))))\n      (labels ((connect (i1 j1 i2 j2)\n                 (when (and (< i2 h) (< j2 w))\n                   (push-edge (encode i1 j1 :out) (encode i2 j2 :in) 1 0 graph))))\n        (dotimes (i h)\n          (dotimes (j w)\n            (connect i j i (+ j 1))\n            (connect i j (+ i 1) j))))\n      (println (+ (aref as 0 0)\n                  (aref as (- h 1) (- w 1))\n                  (- (min-cost-flow! (encode 0 0 :out)\n                                     (encode (- h 1) (- w 1) :in)\n                                     2 graph)))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    ;; (run-program \"C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\" '(\"get-clipboard\") :output out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Minimum cost flow (SSP)\n;;;\n\n(setf *print-circle* t)\n\n;; COST-TYPE and +INF-COST+ may be changed. (A supposed use case is to adopt\n;; bignum).\n(deftype cost-type () 'fixnum)\n(defconstant +inf-cost+ most-positive-fixnum)\n(assert (and (typep +inf-cost+ 'cost-type)\n             (subtypep 'cost-type 'integer)))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (cost 0 :type cost-type)\n  (reversed nil :type (or null edge)))\n\n(defun add-edge! (from-idx to-idx capacity cost graph)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare ((simple-array list (*)) graph)\n           (cost-type cost))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity :cost cost))\n         (ret (%make-edge :to from-idx :capacity 0 :cost (- cost) :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n;; binary heap for Dijkstra's algorithm\n(defstruct (fheap (:constructor make-fheap\n                          (size\n                           &aux (costs (make-array (1+ size) :element-type 'cost-type))\n                                (vertices (make-array (1+ size) :element-type 'fixnum)))))\n  (costs nil :type (simple-array cost-type (*)))\n  (vertices nil :type (simple-array fixnum (*)))\n  (position 1 :type (integer 1 #.most-positive-fixnum)))\n\n(defun fheap-push (cost vertex fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (when (>= position (length (fheap-costs fheap)))\n      (setf (fheap-costs fheap)\n            (adjust-array (fheap-costs fheap) (* position 2))\n            (fheap-vertices fheap)\n            (adjust-array (fheap-vertices fheap) (* position 2))))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0)))\n                 (unless (= pos 1)\n                   (let ((parent-pos (ash pos -1)))\n                     (when (< (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref vertices pos) (aref vertices parent-pos))\n                       (update parent-pos))))))\n        (setf (aref costs position) cost\n              (aref vertices position) vertex)\n        (update position)\n        (incf position)\n        fheap))))\n\n(defun fheap-pop (fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0))\n                          ((integer 1 #.most-positive-fixnum) pos))\n                 (let* ((child-pos1 (+ pos pos))\n                        (child-pos2 (1+ child-pos1)))\n                   (when (<= child-pos1 position)\n                     (if (<= child-pos2 position)\n                         (if (< (aref costs child-pos1) (aref costs child-pos2))\n                             (unless (< (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref vertices pos) (aref vertices child-pos1))\n                               (update child-pos1))\n                             (unless (< (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref vertices pos) (aref vertices child-pos2))\n                               (update child-pos2)))\n                         (unless (< (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))\n        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))\n          (decf position)\n          (setf (aref costs 1) (aref costs position)\n                (aref vertices 1) (aref vertices position))\n          (update 1))))))\n\n(declaim (inline fheap-empty-p))\n(defun fheap-empty-p (fheap)\n  (= (fheap-position fheap) 1))\n\n(declaim (inline fheap-reinitialize))\n(defun fheap-reinitialize (heap)\n  (setf (fheap-position heap) 1)\n  heap)\n\n(define-condition not-enough-capacity-error (error)\n  ((graph :initarg :graph :reader not-enough-capacity-error-graph)\n   (flow :initarg :flow :reader not-enough-capacity-error-flow)\n   (score :initarg :score :reader not-enough-capacity-error-score))\n  (:report\n   (lambda (c s)\n     (format s \"Cannot send ~A units of flow on graph ~A due to not enough capacity.\"\n             (not-enough-capacity-error-flow c)\n             (not-enough-capacity-error-graph c)))))\n\n(defun min-cost-flow! (src-idx dest-idx flow graph &key density)\n  \"Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in\nGRAPH. Destructively modifies GRAPH.\n\nDENSITY := nil | the number of edges (assumed to be (size of GRAPH)*2 if NIL)\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) flow)\n           ((simple-array list (*)) graph))\n  (macrolet ((the-cost-type (form)\n               (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))\n\t\t       (cdr form))))\n    (let* ((size (length graph))\n           (density (or density (* size 2)))\n           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))\n           (prev-edges (make-array size :element-type 'edge))\n           (potential (make-array size :element-type 'cost-type :initial-element 0))\n           (dist (make-array size :element-type 'cost-type))\n           (pqueue (make-fheap density))\n           (res 0))\n      (declare (fixnum density)\n               (cost-type res))\n      ;; FIXME: Actually we must do Bellman-Ford here to handle negative edges\n      ;; properly. Currently this function returns a correct result also for a\n      ;; graph containing negative edges, if no negative **cycles** are\n      ;; contained. In this case, however, the worst-case time complexity is\n      ;; exponential. If the input network is for a weighted bipartite matching\n      ;; containing negative weights, this function completely works without any\n      ;; problems.\n      (loop while (> flow 0)\n            do (fill dist +inf-cost+)\n               (setf (aref dist src-idx) 0)\n               (fheap-reinitialize pqueue)\n               (fheap-push 0 src-idx pqueue)\n               (loop until (fheap-empty-p pqueue)\n                     do (multiple-value-bind (cost v) (fheap-pop pqueue)\n                          (declare (cost-type cost)\n                                   (fixnum v))\n                          (when (<= cost (aref dist v))\n                            (dolist (edge (aref graph v))\n                              (let* ((next-v (edge-to edge))\n                                     (next-cost (the-cost-type\n                                                 (+ (aref dist v)\n                                                    (edge-cost edge)\n                                                    (aref potential v)\n                                                    (- (aref potential next-v))))))\n                                (when (and (> (edge-capacity edge) 0)\n                                           (> (aref dist next-v) next-cost))\n                                  (setf (aref dist next-v) next-cost\n                                        (aref prev-vertices next-v) v\n                                        (aref prev-edges next-v) edge)\n                                  (fheap-push next-cost next-v pqueue)))))))\n               (when (= (aref dist dest-idx) +inf-cost+)\n                 (error 'not-enough-capacity-error :flow flow :graph graph :score res))\n               (let ((max-flow flow))\n                 (declare (fixnum max-flow))\n                 (dotimes (v size)\n                   (setf (aref potential v)\n                         (min +inf-cost+\n                              (+ (aref potential v) (aref dist v)))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (setf max-flow (min max-flow (edge-capacity (aref prev-edges v)))))\n                 (decf flow max-flow)\n                 (incf res (the cost-type (* max-flow (aref potential dest-idx))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (decf (edge-capacity (aref prev-edges v)) max-flow)\n                   (incf (edge-capacity (edge-reversed (aref prev-edges v))) max-flow))))\n      res)))\n\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (as (make-array (list h w) :element-type 'uint31))\n         (graph (make-array (+ 2 (* h w 2)) :element-type 'list :initial-element nil))\n         (src (* h w 2))\n         (dest (+ 1 (* h w 2))))\n    (declare (uint8 h w))\n    (declare (uint31 h w))\n    (labels ((encode (y x dir)\n               (declare (uint8 y x))\n               (+ (if (eq dir :in) 0 1)\n                  (* 2 (+ x (* y w))))))\n      (dotimes (i h)\n        (dotimes (j w)\n          (setf (aref as i j) (read-fixnum))))\n      (add-edge! src (encode 0 0 :in) 2 0 graph)\n      (add-edge! (encode (- h 1) (- w 1) :out) dest 2 0 graph)\n      (dotimes (i h)\n        (dotimes (j w)\n          (when (< j (- w 1))\n            (add-edge! (encode i j :out) (encode i (+ j 1) :in)\n                       2 0 graph))\n          (when (< i (- h 1))\n            (add-edge! (encode i j :out) (encode (+ i 1) j :in)\n                       2 0 graph))\n          (add-edge! (encode i j :in) (encode i j :out)\n                     (if (or (and (= i 0) (= j 0))\n                             (and (= i (- h 1)) (= j (- w 1))))\n                         2\n                         1)\n                     (- 100000 (aref as i j)) graph)))\n      (let ((score (min-cost-flow! src dest 2 graph)))\n        (println\n         (- (- (* 100000 2 (+ h w -1)) score)\n            (aref as 0 0)\n            (aref as (- h 1) (- w 1))))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (declare #.OPT)\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;;;\n;;; Minimum cost flow (Primal-Dual, O(FElogV))\n;;;\n\n(setf *print-circle* t)\n\n;; COST-TYPE and +INF-COST+ may be changed. (A supposed use case is to adopt\n;; bignum).\n(deftype cost-type () '(signed-byte 32))\n(defconstant +inf-cost+ #x7fffffff)\n(assert (and (typep +inf-cost+ 'cost-type)\n             (subtypep 'cost-type 'integer)))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (cost 0 :type cost-type)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity cost graph)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare ((simple-array list (*)) graph)\n           (cost-type cost))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity :cost cost))\n         (ret (%make-edge :to from-idx :capacity 0 :cost (- cost) :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n;; binary heap for Dijkstra's algorithm\n(defstruct (fheap (:constructor make-fheap\n                          (size\n                           &aux (costs (make-array (1+ size) :element-type 'cost-type))\n                                (vertices (make-array (1+ size) :element-type 'fixnum)))))\n  (costs nil :type (simple-array cost-type (*)))\n  (vertices nil :type (simple-array fixnum (*)))\n  (position 1 :type (integer 1 #.most-positive-fixnum)))\n\n(defun fheap-push (cost vertex fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (when (>= position (length (fheap-costs fheap)))\n      (setf (fheap-costs fheap)\n            (adjust-array (fheap-costs fheap) (* position 2))\n            (fheap-vertices fheap)\n            (adjust-array (fheap-vertices fheap) (* position 2))))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0)))\n                 (unless (= pos 1)\n                   (let ((parent-pos (ash pos -1)))\n                     (when (< (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref vertices pos) (aref vertices parent-pos))\n                       (update parent-pos))))))\n        (setf (aref costs position) cost\n              (aref vertices position) vertex)\n        (update position)\n        (incf position)\n        fheap))))\n\n(defun fheap-pop (fheap)\n  (declare #.OPT)\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0))\n                          ((integer 1 #.most-positive-fixnum) pos))\n                 (let* ((child-pos1 (+ pos pos))\n                        (child-pos2 (1+ child-pos1)))\n                   (when (<= child-pos1 position)\n                     (if (<= child-pos2 position)\n                         (if (< (aref costs child-pos1) (aref costs child-pos2))\n                             (unless (< (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref vertices pos) (aref vertices child-pos1))\n                               (update child-pos1))\n                             (unless (< (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref vertices pos) (aref vertices child-pos2))\n                               (update child-pos2)))\n                         (unless (< (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))\n        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))\n          (decf position)\n          (setf (aref costs 1) (aref costs position)\n                (aref vertices 1) (aref vertices position))\n          (update 1))))))\n\n(declaim (inline fheap-empty-p))\n(defun fheap-empty-p (fheap)\n  (= (fheap-position fheap) 1))\n\n(declaim (inline fheap-reinitialize))\n(defun fheap-reinitialize (heap)\n  (setf (fheap-position heap) 1)\n  heap)\n\n(define-condition not-enough-capacity-error (error)\n  ((graph :initarg :graph :reader not-enough-capacity-error-graph)\n   (flow :initarg :flow :reader not-enough-capacity-error-flow))\n  (:report\n   (lambda (c s)\n     (format s \"Cannot send ~A units of flow on graph ~A due to not enough capacity.\"\n             (not-enough-capacity-error-flow c)\n             (not-enough-capacity-error-graph c)))))\n\n(defun min-cost-flow! (src-idx dest-idx flow graph &key density)\n  \"Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in\nGRAPH. Destructively modifies GRAPH.\n\nDENSITY := nil | the number of edges (assumed to be (size of GRAPH)*2 if NIL)\"\n  (declare #.OPT\n           ((integer 0 #.most-positive-fixnum) flow)\n           ((simple-array list (*)) graph))\n  (macrolet ((the-cost-type (form)\n               (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))\n\t\t       (cdr form))))\n    (let* ((size (length graph))\n           (density (or density (* size 2)))\n           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))\n           (prev-edges (make-array size :element-type 'edge))\n           (potential (make-array size :element-type 'cost-type :initial-element 0))\n           (dist (make-array size :element-type 'cost-type))\n           (pqueue (make-fheap density))\n           (res 0))\n      (declare (fixnum density)\n               (cost-type res))\n      (loop while (> flow 0)\n            do (fill dist +inf-cost+)\n               (setf (aref dist src-idx) 0)\n               (fheap-reinitialize pqueue)\n               (fheap-push 0 src-idx pqueue)\n               (loop until (fheap-empty-p pqueue)\n                     do (multiple-value-bind (cost v) (fheap-pop pqueue)\n                          (declare (cost-type cost)\n                                   (fixnum v))\n                          (when (<= cost (aref dist v))\n                            (dolist (edge (aref graph v))\n                              (let* ((next-v (edge-to edge))\n                                     (next-cost (the-cost-type\n                                                 (+ (aref dist v)\n                                                    (edge-cost edge)\n                                                    (aref potential v)\n                                                    (- (aref potential next-v))))))\n                                (when (and (> (edge-capacity edge) 0)\n                                           (> (aref dist next-v) next-cost))\n                                  (setf (aref dist next-v) next-cost\n                                        (aref prev-vertices next-v) v\n                                        (aref prev-edges next-v) edge)\n                                  (fheap-push next-cost next-v pqueue)))))))\n               (when (= (aref dist dest-idx) +inf-cost+)\n                 (error 'not-enough-capacity-error :flow flow :graph graph))\n               (let ((max-flow flow))\n                 (declare (fixnum max-flow))\n                 (dotimes (v size)\n                   (setf (aref potential v)\n                         (min +inf-cost+\n                              (+ (aref potential v) (aref dist v)))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (setf max-flow (min max-flow (edge-capacity (aref prev-edges v)))))\n                 (decf flow max-flow)\n                 (incf res (the cost-type (* max-flow (aref potential dest-idx))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (decf (edge-capacity (aref prev-edges v)) max-flow)\n                   (incf (edge-capacity (edge-reversed (aref prev-edges v))) max-flow))))\n      res)))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((h (read))\n         (w (read))\n         (as (make-array (list h w) :element-type 'uint31))\n         (graph (make-array (* h w 2) :element-type 'list :initial-element nil)))\n    (declare (uint16 h w))\n    (labels ((encode (y x dir)\n               (let ((res (if (eql dir :in)\n                              (* 2 (+ (* w y) x))\n                              (+ (* 2 (+ (* w y) x)) 1))))\n                 res)))\n      (dotimes (i h)\n        (dotimes (j w)\n          (let ((a (read-fixnum)))\n            (setf (aref as i j) a)\n            (push-edge (encode i j :in)\n                       (encode i j :out)\n                       1\n                       (- 100000 a)\n                       graph))))\n      (labels ((connect (i1 j1 i2 j2)\n                 (when (and (< i2 h) (< j2 w))\n                   (push-edge (encode i1 j1 :out) (encode i2 j2 :in) 1 0 graph))))\n        (dotimes (i h)\n          (dotimes (j w)\n            (connect i j i (+ j 1))\n            (connect i j (+ i 1) j))))\n      (println (+ (aref as 0 0)\n                  (aref as (- h 1) (- w 1))\n                  (- (* 100000 (* 2 (+ h w -3)))\n                     (min-cost-flow! (encode 0 0 :out)\n                                     (encode (- h 1) (- w 1) :in)\n                                     2 graph)))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    ;; (run-program \"C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\" '(\"get-clipboard\") :output out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"200 200~%\")\n    (dotimes (i 200)\n      (dotimes (j 200)\n        (println (random 100001) out)))))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": ";; -*- coding: utf-8 -*-\n(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx OPT\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           ;; enclose the form with VALUES to avoid being captured by LOOP macro\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(declaim (ftype (function * (values fixnum &optional)) read-fixnum))\n(defun read-fixnum (&optional (in *standard-input*))\n  \"NOTE: cannot read -2^62\"\n  (macrolet ((%read-byte ()\n               `(the (unsigned-byte 8)\n                     #+swank (char-code (read-char in nil #\\Nul))\n                     #-swank (sb-impl::ansi-stream-read-byte in nil #.(char-code #\\Nul) nil))))\n    (let* ((minus nil)\n           (result (loop (let ((byte (%read-byte)))\n                           (cond ((<= 48 byte 57)\n                                  (return (- byte 48)))\n                                 ((zerop byte) ; #\\Nul\n                                  (error \"Read EOF or #\\Nul.\"))\n                                 ((= byte #.(char-code #\\-))\n                                  (setf minus t)))))))\n      (declare ((integer 0 #.most-positive-fixnum) result))\n      (loop\n        (let* ((byte (%read-byte)))\n          (if (<= 48 byte 57)\n              (setq result (+ (- byte 48)\n                              (* 10 (the (integer 0 #.(floor most-positive-fixnum 10))\n                                         result))))\n              (return (if minus (- result) result))))))))\n\n;;;\n;;; Minimum cost flow (Primal-Dual, O(FElogV))\n;;;\n\n(setf *print-circle* t)\n\n;; COST-TYPE and +INF-COST+ may be changed. (A supposed use case is to adopt\n;; bignum).\n(deftype cost-type () 'fixnum)\n(defconstant +inf-cost+ most-positive-fixnum)\n(assert (and (typep +inf-cost+ 'cost-type)\n             (subtypep 'cost-type 'integer)))\n\n(defstruct (edge (:constructor %make-edge))\n  (to nil :type (integer 0 #.most-positive-fixnum))\n  (capacity 0 :type (integer 0 #.most-positive-fixnum))\n  (cost 0 :type cost-type)\n  (reversed nil :type (or null edge)))\n\n(defun push-edge (from-idx to-idx capacity cost graph)\n  \"FROM-IDX, TO-IDX := index of vertex\nGRAPH := vector of list of all the edges that goes from the vertex\"\n  (declare ((simple-array list (*)) graph)\n           (cost-type cost))\n  (let* ((dep (%make-edge :to to-idx :capacity capacity :cost cost))\n         (ret (%make-edge :to from-idx :capacity 0 :cost (- cost) :reversed dep)))\n    (setf (edge-reversed dep) ret)\n    (push dep (aref graph from-idx))\n    (push ret (aref graph to-idx))))\n\n;; binary heap for Dijkstra's algorithm\n(defstruct (fheap (:constructor make-fheap\n                          (size\n                           &aux (costs (make-array (1+ size) :element-type 'cost-type))\n                                (vertices (make-array (1+ size) :element-type 'fixnum)))))\n  (costs nil :type (simple-array cost-type (*)))\n  (vertices nil :type (simple-array fixnum (*)))\n  (position 1 :type (integer 1 #.most-positive-fixnum)))\n\n(defun fheap-push (cost vertex fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (when (>= position (length (fheap-costs fheap)))\n      (setf (fheap-costs fheap)\n            (adjust-array (fheap-costs fheap) (* position 2))\n            (fheap-vertices fheap)\n            (adjust-array (fheap-vertices fheap) (* position 2))))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0)))\n                 (unless (= pos 1)\n                   (let ((parent-pos (ash pos -1)))\n                     (when (< (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref costs pos) (aref costs parent-pos))\n                       (rotatef (aref vertices pos) (aref vertices parent-pos))\n                       (update parent-pos))))))\n        (setf (aref costs position) cost\n              (aref vertices position) vertex)\n        (update position)\n        (incf position)\n        fheap))))\n\n(defun fheap-pop (fheap)\n  (declare (optimize (speed 3)))\n  (symbol-macrolet ((position (fheap-position fheap)))\n    (let ((costs (fheap-costs fheap))\n          (vertices (fheap-vertices fheap)))\n      (labels ((update (pos)\n                 (declare (optimize (safety 0))\n                          ((integer 1 #.most-positive-fixnum) pos))\n                 (let* ((child-pos1 (+ pos pos))\n                        (child-pos2 (1+ child-pos1)))\n                   (when (<= child-pos1 position)\n                     (if (<= child-pos2 position)\n                         (if (< (aref costs child-pos1) (aref costs child-pos2))\n                             (unless (< (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref costs pos) (aref costs child-pos1))\n                               (rotatef (aref vertices pos) (aref vertices child-pos1))\n                               (update child-pos1))\n                             (unless (< (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref costs pos) (aref costs child-pos2))\n                               (rotatef (aref vertices pos) (aref vertices child-pos2))\n                               (update child-pos2)))\n                         (unless (< (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref costs pos) (aref costs child-pos1))\n                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))\n        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))\n          (decf position)\n          (setf (aref costs 1) (aref costs position)\n                (aref vertices 1) (aref vertices position))\n          (update 1))))))\n\n(declaim (inline fheap-empty-p))\n(defun fheap-empty-p (fheap)\n  (= (fheap-position fheap) 1))\n\n(declaim (inline fheap-reinitialize))\n(defun fheap-reinitialize (heap)\n  (setf (fheap-position heap) 1)\n  heap)\n\n(define-condition not-enough-capacity-error (error)\n  ((graph :initarg :graph :reader not-enough-capacity-error-graph)\n   (flow :initarg :flow :reader not-enough-capacity-error-flow))\n  (:report\n   (lambda (c s)\n     (format s \"Cannot send ~A units of flow on graph ~A due to not enough capacity.\"\n             (not-enough-capacity-error-flow c)\n             (not-enough-capacity-error-graph c)))))\n\n(defun min-cost-flow! (src-idx dest-idx flow graph &key density)\n  \"Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in\nGRAPH. Destructively modifies GRAPH.\n\nDENSITY := nil | the number of edges (assumed to be (size of GRAPH)*2 if NIL)\"\n  (declare (optimize (speed 3))\n           ((integer 0 #.most-positive-fixnum) flow)\n           ((simple-array list (*)) graph))\n  (macrolet ((the-cost-type (form)\n               (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))\n\t\t       (cdr form))))\n    (let* ((size (length graph))\n           (density (or density (* size 2)))\n           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))\n           (prev-edges (make-array size :element-type 'edge))\n           (potential (make-array size :element-type 'cost-type :initial-element 0))\n           (dist (make-array size :element-type 'cost-type))\n           (pqueue (make-fheap density))\n           (res 0))\n      (declare (fixnum density)\n               (cost-type res))\n      (loop while (> flow 0)\n            do (fill dist +inf-cost+)\n               (setf (aref dist src-idx) 0)\n               (fheap-reinitialize pqueue)\n               (fheap-push 0 src-idx pqueue)\n               (loop until (fheap-empty-p pqueue)\n                     do (multiple-value-bind (cost v) (fheap-pop pqueue)\n                          (declare (cost-type cost)\n                                   (fixnum v))\n                          (when (<= cost (aref dist v))\n                            (dolist (edge (aref graph v))\n                              (let* ((next-v (edge-to edge))\n                                     (next-cost (the-cost-type\n                                                 (+ (aref dist v)\n                                                    (edge-cost edge)\n                                                    (aref potential v)\n                                                    (- (aref potential next-v))))))\n                                (when (and (> (edge-capacity edge) 0)\n                                           (> (aref dist next-v) next-cost))\n                                  (setf (aref dist next-v) next-cost\n                                        (aref prev-vertices next-v) v\n                                        (aref prev-edges next-v) edge)\n                                  (fheap-push next-cost next-v pqueue)))))))\n               (when (= (aref dist dest-idx) +inf-cost+)\n                 (error 'not-enough-capacity-error :flow flow :graph graph))\n               (let ((max-flow flow))\n                 (declare (fixnum max-flow))\n                 (dotimes (v size)\n                   (setf (aref potential v)\n                         (min +inf-cost+\n                              (+ (aref potential v) (aref dist v)))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (setf max-flow (min max-flow (edge-capacity (aref prev-edges v)))))\n                 (decf flow max-flow)\n                 (incf res (the cost-type (* max-flow (aref potential dest-idx))))\n                 (do ((v dest-idx (aref prev-vertices v)))\n                     ((= v src-idx))\n                   (decf (edge-capacity (aref prev-edges v)) max-flow)\n                   (incf (edge-capacity (edge-reversed (aref prev-edges v))) max-flow))))\n      res)))\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((h (read))\n         (w (read))\n         (as (make-array (list h w) :element-type 'uint31))\n         (graph (make-array (* h w 2) :element-type 'list :initial-element nil)))\n    (declare (uint16 h w))\n    (labels ((encode (y x dir)\n               (let ((res (if (eql dir :in)\n                              (* 2 (+ (* w y) x))\n                              (+ (* 2 (+ (* w y) x)) 1))))\n                 res)))\n      (dotimes (i h)\n        (dotimes (j w)\n          (let ((a (read-fixnum)))\n            (setf (aref as i j) a)\n            (push-edge (encode i j :in)\n                       (encode i j :out)\n                       1\n                       (- a)\n                       graph))))\n      (labels ((connect (i1 j1 i2 j2)\n                 (when (and (< i2 h) (< j2 w))\n                   (push-edge (encode i1 j1 :out) (encode i2 j2 :in) 1 0 graph))))\n        (dotimes (i h)\n          (dotimes (j w)\n            (connect i j i (+ j 1))\n            (connect i j (+ i 1) j))))\n      (println (+ (aref as 0 0)\n                  (aref as (- h 1) (- w 1))\n                  (- (min-cost-flow! (encode 0 0 :out)\n                                     (encode (- h 1) (- w 1) :in)\n                                     2 graph)))))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    ;; (run-program \"C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe\" '(\"get-clipboard\") :output out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 3\n1 0 5\n2 2 3\n4 2 4\n\"\n    \"21\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"6 6\n1 2 3 4 5 6\n8 6 9 1 2 0\n3 1 4 1 5 9\n2 6 5 3 5 8\n1 4 1 4 2 1\n2 7 1 8 2 8\n\"\n    \"97\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.split.map(&:to_i)\nend\n\ndp = Array.new(H+W-1){Array.new(H+1){Array.new(H+1, 0)}}\ndp[0][0][0] = as[0][0]\n\n(1...(H+W-2)).each do |k|\n    mini = [1, k-W+1].max\n    minj = [0, k-W+1].max\n    max = [k, H-1].min\n    (mini..max).each do |i|\n        (minj...i).each do |j|\n            dp[k][i][j] = [dp[k-1][i][j], dp[k-1][i-1][j], dp[k-1][i][j-1], dp[k-1][i-1][j-1]].max + as[i][k-i] + as[j][k-j]\n        end\n    end\nend\n\nputs dp[H+W-3][H-1][H-2] + as[H-1][W-1]"
  },
  {
    "language": "Ruby",
    "code": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.split.map(&:to_i)\nend\n\ndp = Array.new(H+1){Array.new(H+1, 0)}\ndp[0][0] = as[0][0]\n\n(1...(H+W-2)).each do |k|\n    mini = [1, k-W+1].max\n    minj = [0, k-W+1].max\n    maxi = [k, H-1].min\n    maxi.downto(mini) do |i|\n        (i-1).downto(minj) do |j|\n            dp[i][j] = [dp[i][j], dp[i-1][j], dp[i][j-1], dp[i-1][j-1]].max + as[i][k-i] + as[j][k-j]\n        end\n    end\nend\n\nputs dp[H-1][H-2] + as[H-1][W-1]"
  },
  {
    "language": "Ruby",
    "code": "H, W = gets.split.map(&:to_i)\nas = []\nH.times do |i|\n    as[i] = gets.split.map(&:to_i)\nend\n\ndp = Array.new(H+1){Array.new(H+1, 0)}\ndp[0][0] = as[0][0]\n\n(1...(H+W-2)).each do |k|\n    mini = [1, k-W+1].max\n    minj = [0, k-W+1].max\n    maxi = [k, H-1].min\n    maxi.downto(mini) do |i|\n        (i-1).downto(minj) do |j|\n            dp[i][j] = dp[i-1][j] if dp[i][j] < dp[i-1][j]\n            dp[i][j] = dp[i][j-1] if dp[i][j] < dp[i][j-1]\n            dp[i][j] = dp[i-1][j-1] if dp[i][j] < dp[i-1][j-1]\n            dp[i][j] += as[i][k-i] + as[j][k-j]\n        end\n    end\nend\n\nputs dp[H-1][H-2] + as[H-1][W-1]"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto H = s[0];\n    auto W = s[1];\n    auto A = H.iota.map!(_ => readln.split.to!(long[])).array;\n\n    auto dp = new long[][][](H+W-1, H, H);\n    dp[0][0][0] = A[0][0];\n\n    foreach (i; 0..H+W-2) {\n        foreach (r1; 0..H) {\n            foreach (r2; 0..H) {\n                int c1 = i - r1;\n                int c2 = i - r2;\n                if (c1 < 0 || c2 < 0 || c1 >= W || c2 >= W) continue;\n                foreach (j; 0..2) {\n                    foreach (k; 0..2) {\n                        int nr1 = r1 + j;\n                        int nc1 = c1 + 1 - j;\n                        int nr2 = r2 + k;\n                        int nc2 = c2 + 1 - k;\n                        if (nr1 >= H || nc1 >= W || nr2 >= H || nc2 >= W) continue;\n                        if (nr1 == nr2 && nc1 == nc2) {\n                            dp[i+1][nr1][nr2] = max(dp[i+1][nr1][nr2], dp[i][r1][r2] + A[nr1][nc1]);\n                        } else {\n                            dp[i+1][nr1][nr2] = max(dp[i+1][nr1][nr2], dp[i][r1][r2] + A[nr1][nc1] + A[nr2][nc2]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    dp[H+W-2].map!(d => d.reduce!max).reduce!max.writeln;\n}\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H <= 2 or W <= 2:\n    print(sum(map(sum, A)))\n    exit(0)\n\ndef solve(A, W, H):\n    S = {(0, 1): 0}\n    for c in range(1, H-1):\n        T = {}\n        for p, q in S:\n            v = S[p, q] + A[c-p][p] + A[c-q][q]\n            T[p, q] = max(T.get((p, q), 0), v)\n            if p+1 < q:\n                T[p+1, q] = max(T.get((p+1, q), 0), v)\n            if q+1 < W:\n                T[p, q+1] = max(T.get((p, q+1), 0), v)\n                T[p+1, q+1] = max(T.get((p+1, q+1), 0), v)\n        S = T\n        print(c, S)\n    return S\nB = [e[::-1] for e in A[::-1]]\nS0 = solve(A, W, H)\nS1 = solve(B, H, W)\nprint(A[0][0] + A[-1][-1] + max(S0[p, q] + S1[H-1-q, H-1-p] + A[H-1-p][p] + A[H-1-q][q] for p, q in S0))\n"
  },
  {
    "language": "Python",
    "code": "#tle -solution\nimport copy\ndef main():\n    H,W = map(int,input().split())\n    data = [[0]+list(map(int,input().split())) for i in range(H)]\n    a = copy.deepcopy(data)\n    for i in range(H):\n        for j in range(1,W+1):\n            data[i][j] += data[i][j-1]\n            \n    #dp[height][left][right] assert 1<=height<=H, 1<=left<right<=W\n    \n    dp = [[[0]*(W+1) for j in range(W+1)] for i in range(H+1)]   \n\n\n\n    #initializaton : height is 1.\n\n    for i in range(1,W+1):            \n            for j in range(i,W+1):\n                dp[1][i][j] =data[0][j]\n\n    for height in range(2,H+1):\n        for i in range(1,W+1):\n            for j in range(i+1,W+1):              \n                dp[height][i][j] = max(max(dp[height-1][i][k] +data[height-1][j]-data[height-1][k-1] for k in range(i+1,j+1))+a[height-1][i],dp[height][i][j])\n                dp[height][i][j] = max(max(dp[height-1][l][j]+data[height-1][i]-data[height-1][l-1] for l in range(1,i+1))+a[height-1][j],dp[height][i][j])\n                if i > 1:\n                    dp[height][i][j] = max(dp[height][i-1][j],dp[height][i][j-1],dp[height][i][j])\n    \n\n    ans = max(dp[H][i][i+1]+data[-1][W] -data[-1][i+1] for i in range(1,W))\n    \n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = {(W+H-2, H-2, H-1): 0}\ndef dfs(c, p, q):\n    if (c, p, q) in memo:\n        return memo[c, p, q]\n    res = 0\n    if c+1-H < p < q < W:\n        res = max(res, dfs(c+1, p, q))\n    if c+1-H < p+1 < q < W:\n        res = max(res, dfs(c+1, p+1, q))\n    if c+1-H < p < q+1 < W:\n        res = max(res, dfs(c+1, p, q+1))\n    if c+1-H < p+1 < q+1 < W:\n        res = max(res, dfs(c+1, p+1, q+1))\n    memo[c, p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])"
  },
  {
    "language": "Python",
    "code": "#atcoder problem solving\n\n\n#problem name --> お土産購入計画2\n\n#tle -solution 10**8 order\ndef main():\n    H,W = map(int,input().split())\n    data = [[0]+list(map(int,input().split())) for i in range(H)]\n    for i in range(H):\n        for j in range(1,W+1):\n            data[i][j] += data[i][j-1]\n            \n    #dp[height][left][right] assert 1<=height<=H, 1<=left<right<=W\n    \n    dp = [[[0]*(W+1) for j in range(W+1)]for i in range(H+1)]   \n    H_dp = [[[0]*(W+1) for j in range(W+1)] for i in range(H+1)]\n    W_dp = [[[0]*(W+1) for j in range(W+1)] for   i in range(H+1)]\n\n\n    #initializaton : height is 1.\n\n    for i in range(1,W+1):\n            for j in range(i+1,W+1):\n                dp[1][i][j] =data[0][j]\n\n    for height in range(2,H+1):\n        for i in range(1,W+1):\n            for j in range(i+1,W+1):\n                dp[height][i][j] = max(max(dp[height-1][i][k] +data[height-1][j]-data[height-1][k-1] for k in range(i+1,j+1))+data[height-1][i]-data[height-1][i-1],dp[height][i][j])\n                dp[height][i][j] = max(max(dp[height-1][l][j]+data[height-1][i]-data[height-1][l-1] for l in range(1,i+1))+data[height-1][j]-data[height-1][j-1],dp[height][i][j])\n    \n\n    ans = dp[H][W-1][W]\n    \n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom heapq import heappop, heappush\nimport itertools\n\n\"\"\"\n・最小費用流。流量2を流せばよい。\n・頂点xをx_in,x_outに拡張。x_inからx_outにcapacity1で、価値 a と 0 の辺を貼る\n・このままだと最大化問題になっているので、辺のコストをX - a_{ij}とする感じで\n\"\"\"\n\nclass MinCostFlow:\n    \"\"\"\n    最小費用流。負辺がないと仮定して、BellmanFordを省略している。\n    \"\"\"\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n        \n    def add_edge(self, fr, to, cap, cost):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, cost, n2])\n        self.G[to].append([fr, 0, -cost, n1])\n\n    def MinCost(self, flow, negative_edge = False):\n        if negative_edge:\n            raise ValueError\n        N = self.N; G = self.G; source = self.source; sink = self.sink\n        INF = 10 ** 18\n        prev_v = [0] * N; prev_e = [0] * N # 経路復元用\n        H = [0] * N # potential\n        mincost=0\n        while flow:\n            dist=[INF] * N\n            dist[source]=0\n            q = [source]\n            mask = (1 << 20) - 1\n            while q:\n                x = heappop(q)\n                dv = (x >> 20); v = x & mask\n                if dist[v] < dv:\n                    continue\n                if v == sink:\n                    break\n                for i,(w,cap,cost,rev) in enumerate(G[v]):\n                    dw = dist[v] + cost + H[v] - H[w]\n                    if (not cap) or (dist[w] <= dw):\n                        continue\n                    dist[w] = dw\n                    prev_v[w] = v; prev_e[w] = i\n                    heappush(q, (dw << 20) + w)\n            if dist[sink] == INF:\n                raise Exception('No Flow Exists')\n            # ポテンシャルの更新\n            for v,d in enumerate(dist):\n                H[v] += d\n            # 流せる量を取得する\n            d = flow; v = sink\n            while v != source:\n                pv = prev_v[v]; pe = prev_e[v]\n                cap = G[pv][pe][1]\n                if d > cap:\n                    d = cap\n                v = pv\n            # 流す\n            mincost += d * H[sink]\n            flow -= d\n            v = sink\n            while v != source:\n                pv = prev_v[v]; pe = prev_e[v]\n                G[pv][pe][1] -= d\n                rev = G[pv][pe][3]\n                G[v][rev][1] += d\n                v = pv\n        return mincost\n\nH,W = map(int,readline().split())\nA = list(map(int,read().split()))\n\nN = 2 * H * W + 2\nsource = N-2; sink = N-1\n\nG = MinCostFlow(N,source,sink)\nadd = G.add_edge\nX = 10 ** 6\n\n# スタート地点\nadd(fr=source, to=0, cap=2, cost=0)\n# ゴール\nadd(2*H*W-1, sink, 2, 0)\n\n# x_in to x_out\nfor x,a in enumerate(A):\n    add(x+x,x+x+1,1,X) # とらない\n    add(x+x,x+x+1,1,X - a) # とる\n\n# 左から右への辺\nfor i,j in itertools.product(range(H),range(W-1)):\n    x = W * i + j; y = x + 1\n    add(x+x+1,y+y,1,0)\n# 上から下への辺\nfor i,j in itertools.product(range(H-1),range(W)):\n    x = W * i + j; y = x + W\n    add(x+x+1,y+y,1,0)\n\ncost = G.MinCost(2)\n\n# 1点通るごとに、X - costになっている。2人合わせて、(H+W-1) * 2個のXが足されている\n\nanswer = 2 * (H+W-1) * X -cost\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = [{} for i in range(W+H)]\ndef dfs(c, p, q):\n    mc = memo[c]\n    if (p, q) in mc:\n        return mc[p, q]\n    res = 0\n    if c+1-H < p:\n        res = max(res, dfs(c+1, p, q))\n        if q+1 < W:\n            res = max(res, dfs(c+1, p, q+1))\n    if p+1 < q:\n        res = max(res, dfs(c+1, p+1, q))\n    if q+1 < W:\n        res = max(res, dfs(c+1, p+1, q+1))\n    mc[p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\n\nmemo = {(W+H-2, H-2, H-1): 0}\ndef dfs(c, p, q):\n    if (c, p, q) in memo:\n        return memo[c, p, q]\n    res = 0\n    if c+1-W < p < q < H:\n        res = max(res, dfs(c+1, p, q))\n    if c+1-W < p+1 < q < H:\n        res = max(res, dfs(c+1, p+1, q))\n    if c+1-W < p < q+1 < H:\n        res = max(res, dfs(c+1, p, q+1))\n    if c+1-W < p+1 < q+1 < H:\n        res = max(res, dfs(c+1, p+1, q+1))\n    memo[c, p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = {(W+H-2, H-2, H-1): 0}\ndef dfs(c, p, q):\n    if (c, p, q) in memo:\n        return memo[c, p, q]\n    res = 0\n    if c+1-H < p:\n        res = max(res, dfs(c+1, p, q))\n        if q+1 < W:\n            res = max(res, dfs(c+1, p, q+1))\n    if p+1 < q:\n        res = max(res, dfs(c+1, p+1, q))\n    if q+1 < W:\n        res = max(res, dfs(c+1, p+1, q+1))\n    memo[c, p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H <= 2 or W <= 2:\n    print(sum(map(sum, A)))\n    exit(0)\n\ndef solve(A, W, H):\n    S = {(0, 1): 0}\n    for c in range(1, H-1):\n        T = {}\n        for p, q in S:\n            v = S[p, q] + A[c-p][p] + A[c-q][q]\n            T[p, q] = max(T.get((p, q), 0), v)\n            if p+1 < q:\n                T[p+1, q] = max(T.get((p+1, q), 0), v)\n            if q+1 < W:\n                T[p, q+1] = max(T.get((p, q+1), 0), v)\n                T[p+1, q+1] = max(T.get((p+1, q+1), 0), v)\n        S = T\n    return S\nB = [e[::-1] for e in A[::-1]]\nS0 = solve(A, W, H)\nS1 = solve(B, H, W)\nprint(A[0][0] + A[-1][-1] + max(S0[p, q] + S1[H-1-q, H-1-p] + A[H-1-p][p] + A[H-1-q][q] for p, q in S0))\n"
  },
  {
    "language": "Python",
    "code": "h,w=map(int,raw_input().split())\na=[map(int,raw_input().split()) for _ in xrange(h)]\ndp=[[[0]*(h+1) for _ in xrange(w+1)] for _ in xrange(h+1)]\n\nfor i in xrange(h):\n    for j in xrange(w):\n        for k in xrange(h):\n            if i+j-k<=-1 or i+j-k>=w:\n                continue\n            if i==k:\n                dp[i+1][j+1][k+1]=max(dp[i][j+1][k+1],dp[i+1][j][k+1],dp[i][j+1][k],dp[i+1][j][k])+a[i][j]\n            else:\n                dp[i+1][j+1][k+1]=max(dp[i][j+1][k+1],dp[i+1][j][k+1],dp[i][j+1][k],dp[i+1][j][k])+a[i][j]+a[k][i+j-k]\n\nprint(dp[h][w][h])"
  },
  {
    "language": "Python",
    "code": "#tle -solution\ndef main():\n    H,W = map(int,input().split())\n    data = [[0]+list(map(int,input().split())) for i in range(H)]\n    for i in range(H):\n        for j in range(1,W+1):\n            data[i][j] += data[i][j-1]\n            \n    #dp[height][left][right] assert 1<=height<=H, 1<=left<right<=W\n    \n    dp = [[[0]*(W+1) for j in range(W+1)] for i in range(H+1)]   \n\n\n\n    #initializaton : height is 1.\n\n    for i in range(1,W+1):            \n            for j in range(i,W+1):\n                dp[1][i][j] =data[0][j]\n\n    for height in range(2,H+1):\n        for i in range(1,W+1):\n            for j in range(i+1,W+1):              \n                dp[height][i][j] = max(max(dp[height-1][i][k] +data[height-1][j]-data[height-1][k-1] for k in range(i+1,j+1))+data[height-1][i]-data[height-1][i-1],dp[height][i][j])\n                dp[height][i][j] = max(max(dp[height-1][l][j]+data[height-1][i]-data[height-1][l-1] for l in range(1,i+1))+data[height-1][j]-data[height-1][j-1],dp[height][i][j])\n                if i > 1:\n                    dp[height][i][j] = max(max(dp[height-1][u][v] + data[height-1][i]-data[height-1][u-1] + data[height-1][j]-data[height-1][v-1] for u in range(1,i+1) for v in range(i+1,j+1)),dp[height][i][j])\n    \n\n    ans = max(dp[H][i][i+1]+data[-1][W] -data[-1][i+1] for i in range(1,W))\n    \n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nfrom heapq import heappop, heappush\nimport itertools\n\n\"\"\"\n・最小費用流。流量2を流せばよい。\n・頂点xをx_in,x_outに拡張。x_inからx_outにcapacity1で、価値 a と 0 の辺を貼る\n・このままだと最大化問題になっているので、辺のコストをX - a_{ij}とする感じで\n\"\"\"\n\nclass MinCostFlow:\n    \"\"\"\n    最小費用流。負辺がないと仮定して、BellmanFordを省略している。\n    \"\"\"\n    def __init__(self, N, source, sink):\n        self.N = N\n        self.G = [[] for _ in range(N)]\n        self.source = source\n        self.sink = sink\n        \n    def add_edge(self, fr, to, cap, cost):\n        n1 = len(self.G[fr])\n        n2 = len(self.G[to])\n        self.G[fr].append([to, cap, cost, n2])\n        self.G[to].append([fr, 0, -cost, n1])\n\n    def MinCost(self, flow, negative_edge = False):\n        if negative_edge:\n            raise ValueError\n        N = self.N; G = self.G; source = self.source; sink = self.sink\n        INF = 10 ** 18\n        prev_v = [0] * N; prev_e = [0] * N # 経路復元用\n        H = [0] * N # potential\n        mincost=0\n        while flow:\n            dist=[INF] * N\n            dist[source]=0\n            q = [source]\n            mask = (1 << 20) - 1\n            while q:\n                x = heappop(q)\n                dv = (x >> 20); v = x & mask\n                if dist[v] < dv:\n                    continue\n                if v == sink:\n                    break\n                for i,(w,cap,cost,rev) in enumerate(G[v]):\n                    dw = dist[v] + cost + H[v] - H[w]\n                    if (not cap) or (dist[w] <= dw):\n                        continue\n                    dist[w] = dw\n                    prev_v[w] = v; prev_e[w] = i\n                    heappush(q, (dw << 20) + w)\n            if dist[sink] == INF:\n                raise Exception('No Flow Exists')\n            # ポテンシャルの更新\n            for v,d in enumerate(dist):\n                H[v] += d\n            # 流せる量を取得する\n            d = flow; v = sink\n            while v != source:\n                pv = prev_v[v]; pe = prev_e[v]\n                cap = G[pv][pe][1]\n                if d > cap:\n                    d = cap\n                v = pv\n            # 流す\n            mincost += d * H[sink]\n            flow -= d\n            v = sink\n            while v != source:\n                pv = prev_v[v]; pe = prev_e[v]\n                G[pv][pe][1] -= d\n                rev = G[pv][pe][3]\n                G[v][rev][1] += d\n                v = pv\n        return mincost\n\nH,W = map(int,readline().split())\nA = list(map(int,read().split()))\n\nN = 2 * H * W + 2\nsource = N-2; sink = N-1\n\nG = MinCostFlow(N,source,sink)\nadd = G.add_edge\nX = 10 ** 6\n\n# スタート地点\nadd(fr=source, to=0, cap=2, cost=0)\n# ゴール\nadd(2*H*W-1, sink, 2, 0)\n\n# x_in to x_out\nfor x,a in enumerate(A):\n    add(x+x,x+x+1,1,X) # とらない\n    add(x+x,x+x+1,1,X - a) # とる\n\n# 左から右への辺\nfor i,j in itertools.product(range(H),range(W-1)):\n    x = W * i + j; y = x + 1\n    add(x+x+1,y+y,1,0)\n# 上から下への辺\nfor i,j in itertools.product(range(H-1),range(W)):\n    x = W * i + j; y = x + W\n    add(x+x+1,y+y,1,0)\n\ncost = G.MinCost(2)\n\n# 1点通るごとに、X - costになっている。2人合わせて、(H+W-1) * 2個のXが足されている\n\nanswer = 2 * (H+W-1) * X -cost\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\n\nmemo = {(W+H-2, H-2, H-1): 0}\ndef dfs(c, p, q):\n    if (c, p, q) in memo:\n        return memo[c, p, q]\n    res = 0\n    if c+1-H < p < q < H:\n        res = max(res, dfs(c+1, p, q))\n    if c+1-H < p+1 < q < H:\n        res = max(res, dfs(c+1, p+1, q))\n    if c+1-H < p < q+1 < H:\n        res = max(res, dfs(c+1, p, q+1))\n    if c+1-H < p+1 < q+1 < H:\n        res = max(res, dfs(c+1, p+1, q+1))\n    memo[c, p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])"
  },
  {
    "language": "Python",
    "code": "H,W = map(int,input().split())\nsrc = [list(map(int,input().split())) for i in range(H)]\n\ndp = [[[0 for ex in range(W)] for sx in range(W)] for xy in range(H+W-1)]\ndp[0][0][0] = src[0][0]\nfor xy in range(H+W-2):\n    n = min(xy+1,H,W,H+W-xy-1)\n    sx0 = max(0,xy-H+1)\n    for sx in range(sx0, sx0+n):\n        for ex in range(sx, sx0+n):\n            sy,ey = xy-sx, xy-ex\n            if sx < W-1 and ex < W-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex+1: gain += src[ey][ex+1]\n                if dp[xy+1][sx+1][ex+1] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx+1][ex+1] = dp[xy][sx][ex] + gain\n            if sx < W-1 and ey < H-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex: gain += src[ey+1][ex]\n                if dp[xy+1][sx+1][ex] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx+1][ex] = dp[xy][sx][ex] + gain\n            if sy < H-1 and ex < W-1:\n                gain = src[sy+1][sx]\n                if sx != ex+1: gain += src[ey][ex+1]\n                if dp[xy+1][sx][ex+1] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx][ex+1] = dp[xy][sx][ex] + gain\n            if sy < H-1 and ey < H-1:\n                gain = src[sy+1][sx]\n                if sx != ex: gain += src[ey+1][ex]\n                if dp[xy+1][sx][ex] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx][ex] = dp[xy][sx][ex] + gain\n\nprint(dp[-1][-1][-1])"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = [{} for i in range(W+H)]\ndef calc(c, p, q):\n    yield 0\n    if c+1-H < p:\n        yield dfs(c+1, p, q)\n        if q+1 < W:\n            yield dfs(c+1, p, q+1)\n    if p+1 < q:\n        yield dfs(c+1, p+1, q)\n    if q+1 < W:\n        yield dfs(c+1, p+1, q+1)\ndef dfs(c, p, q):\n    mc = memo[c]\n    if (p, q) in mc:\n        return mc[p, q]\n    mc[p, q] = r = max(calc(c, p, q)) + A[c-p][p] + A[c-q][q]\n    return r\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "H,W = map(int,input().split())\nsrc = [list(map(int,input().split())) for i in range(H)]\n\ndp = [[[0 for ex in range(W)] for sx in range(W)] for xy in range(H+W-1)]\ndp[0][0][0] = src[0][0]\nfor xy in range(H+W-2):\n    n = min(xy+1,H,W,H+W-xy-1)\n    sx0 = max(0,xy-H+1)\n    for sx in range(sx0, sx0+n):\n        for ex in range(sx, sx0+n):\n            sy,ey = xy-sx, xy-ex\n            assert 0 <= sx < W\n            assert 0 <= ex < W\n            assert 0 <= sy < H\n            assert 0 <= ey < H\n            if sx < W-1 and ex < W-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex+1: gain += src[ey][ex+1]\n                dp[xy+1][sx+1][ex+1] = max(dp[xy+1][sx+1][ex+1], dp[xy][sx][ex] + gain)\n            if sx < W-1 and ey < H-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex: gain += src[ey+1][ex]\n                dp[xy+1][sx+1][ex] = max(dp[xy+1][sx+1][ex], dp[xy][sx][ex] + gain)\n            if sy < H-1 and ex < W-1:\n                gain = src[sy+1][sx]\n                if sx != ex+1: gain += src[ey][ex+1]\n                dp[xy+1][sx][ex+1] = max(dp[xy+1][sx][ex+1], dp[xy][sx][ex] + gain)\n            if sy < H-1 and ey < H-1:\n                gain = src[sy+1][sx]\n                if sx != ex: gain += src[ey+1][ex]\n                dp[xy+1][sx][ex] = max(dp[xy+1][sx][ex], dp[xy][sx][ex] + gain)\n\nprint(dp[-1][-1][-1])"
  },
  {
    "language": "Python",
    "code": "H,W = map(int,input().split())\nsrc = [list(map(int,input().split())) for i in range(H)]\n\ndp = [[[0 for ex in range(W)] for sx in range(W)] for xy in range(H+W-1)]\ndp[0][0][0] = src[0][0]\nfor xy in range(H+W-2):\n    n = min(xy+1,H,W,H+W-xy-1)\n    sx0 = max(0,xy-H+1)\n    for sx in range(sx0, sx0+n):\n        for ex in range(sx, sx0+n):\n            sy,ey = xy-sx, xy-ex\n            if sx < W-1 and ex < W-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex+1: gain += src[ey][ex+1]\n                if dp[xy+1][sx+1][ex+1] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx+1][ex+1] = dp[xy][sx][ex] + gain\n            if sx < W-1 and ey < H-1:\n                gain = src[sy][sx+1]\n                if sx+1 != ex: gain += src[ey+1][ex]\n                if dp[xy+1][sx+1][ex] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx+1][ex] = dp[xy][sx][ex] + gain\n            if sy < H-1 and ex < W-1:\n                gain = src[sy+1][sx]\n                if sx != ex+1: gain += src[ey][ex+1]\n                if dp[xy+1][sx][ex+1] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx][ex+1] = dp[xy][sx][ex] + gain\n            if sy < H-1 and ey < H-1:\n                gain = src[sy+1][sx]\n                if sx != ex: gain += src[ey+1][ex]\n                if dp[xy+1][sx][ex] < dp[xy][sx][ex] + gain:\n                    dp[xy+1][sx][ex] = dp[xy][sx][ex] + gain\n\nprint(dp[-1][-1][-1])"
  },
  {
    "language": "Python",
    "code": "#tle -solution 10**8 order\ndef main():\n    H,W = map(int,input().split())\n    data = [[0]+list(map(int,input().split())) for i in range(H)]\n    for i in range(H):\n        for j in range(1,W+1):\n            data[i][j] += data[i][j-1]\n            \n    #dp[height][left][right] assert 1<=height<=H, 1<=left<right<=W\n    \n    dp = [[[0]*(W+1) for j in range(W+1)]for i in range(H+1)]   \n    H_dp = [[[0]*(W+1) for j in range(W+1)] for i in range(H+1)]\n    W_dp = [[[0]*(W+1) for j in range(W+1)] for   i in range(H+1)]\n\n\n    #initializaton : height is 1.\n\n    for i in range(1,2):            \n            for j in range(i+1,W+1):\n                dp[1][i][j] =data[0][j]\n\n    for height in range(2,H+1):\n        for i in range(1,W+1):\n            for j in range(i+1,W+1):\n                dp[height][i][j] = max(max(dp[height-1][i][k] +data[height-1][j]-data[height-1][k-1] for k in range(i+1,j+1))+data[height-1][i]-data[height-1][i-1],dp[height][i][j])\n                dp[height][i][j] = max(max(dp[height-1][l][j]+data[height-1][i]-data[height-1][l-1] for l in range(1,i+1))+data[height-1][j]-data[height-1][j-1],dp[height][i][j])\n    \n\n    ans = max(dp[H][i][i+1]+data[-1][W] -data[-1][i+1] for i in range(1,W))\n    \n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = {(W+H-2, H-2, H-1): 0}\ndef dfs(c, p, q):\n    if (c, p, q) in memo:\n        return memo[c, p, q]\n    res = 0\n    if c+1-H < p < q < W:\n        res = max(res, dfs(c+1, p, q))\n    if c+1-H < p+1 < q < W:\n        res = max(res, dfs(c+1, p+1, q))\n    if c+1-H < p < q+1 < W:\n        res = max(res, dfs(c+1, p, q+1))\n    if c+1-H < p+1 < q+1 < W:\n        res = max(res, dfs(c+1, p+1, q+1))\n    memo[c, p, q] = res = res + A[c-p][p] + A[c-q][q]\n    return res\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nA = [list(map(int, input().split())) for i in range(H)]\nif H == 1 or W == 1:\n    print(sum(map(sum, A)))\n    exit(0)\n\nmemo = [{} for i in range(W+H)]\ndef calc(c, p, q):\n    yield 0\n    if c+1-H < p:\n        yield dfs(c+1, p, q)\n        if q+1 < W:\n            yield dfs(c+1, p, q+1)\n    if p+1 < q:\n        yield dfs(c+1, p+1, q)\n    if q+1 < W:\n        yield dfs(c+1, p+1, q+1)\ndef dfs(c, p, q):\n    mc = memo[c]\n    if (p, q) in mc:\n        return mc[p, q]\n    mc[p, q] = r = max(calc(c, p, q)) + A[c-p][p] + A[c-q][q]\n    return r\nprint(dfs(1, 0, 1) + A[0][0] + A[-1][-1])\n"
  },
  {
    "language": "Python",
    "code": "#tle -solution 10**8 order\ndef main():\n    H,W = map(int,input().split())\n    data = [[0]+list(map(int,input().split())) for i in range(H)]\n    for i in range(H):\n        for j in range(1,W+1):\n            data[i][j] += data[i][j-1]\n            \n    #dp[height][left][right] assert 1<=height<=H, 1<=left<right<=W\n    \n    dp = [[[0]*(W+1) for j in range(W+1)]for i in range(H+1)]   \n    H_dp = [[[0]*(W+1) for j in range(W+1)] for i in range(H+1)]\n    W_dp = [[[0]*(W+1) for j in range(W+1)] for   i in range(H+1)]\n\n\n    #initializaton : height is 1.\n\n    for i in range(1,2):            \n            for j in range(i+1,W+1):\n                dp[1][i][j] =data[0][j]\n\n    for height in range(2,H+1):\n        for i in range(1,W+1):\n            for j in range(i+1,W+1):\n                dp[height][i][j] = max(max(dp[height-1][i][k] +data[height-1][j]-data[height-1][k-1] for k in range(i+1,j+1))+data[height-1][i]-data[height-1][i-1],dp[height][i][j])\n                dp[height][i][j] = max(max(dp[height-1][l][j]+data[height-1][i]-data[height-1][l-1] for l in range(1,i+1))+data[height-1][j]-data[height-1][j-1],dp[height][i][j])\n    \n\n    ans = dp[H][W-1][W]\n    \n    print(ans)\n    return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  }
]