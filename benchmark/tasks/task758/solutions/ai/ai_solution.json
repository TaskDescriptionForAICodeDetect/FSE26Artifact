[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 1000\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int x[MAX_N], y[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &x[i], &y[i]);\n    }\n    \n    int min_cost = INT_MAX;\n    \n    for (int p = -200; p <= 200; p++) {\n        for (int q = -200; q <= 200; q++) {\n            if (p == 0 && q == 0) continue;\n            \n            int cost = 0;\n            int collected[MAX_N] = {0};\n            int remaining = N;\n            \n            while (remaining > 0) {\n                int best_ball = -1;\n                for (int i = 0; i < N; i++) {\n                    if (collected[i]) continue;\n                    \n                    int is_connected = 0;\n                    for (int j = 0; j < N; j++) {\n                        if (i == j || collected[j]) continue;\n                        if (x[i] == x[j] + p && y[i] == y[j] + q) {\n                            is_connected = 1;\n                            break;\n                        }\n                    }\n                    \n                    if (best_ball == -1 || (is_connected == 0 && best_ball != -1)) {\n                        best_ball = i;\n                    }\n                }\n                \n                if (best_ball == -1) break;\n                \n                if (best_ball != -1) {\n                    collected[best_ball] = 1;\n                    remaining--;\n                    \n                    if (remaining > 0) {\n                        for (int i = 0; i < N; i++) {\n                            if (!collected[i] && x[i] == x[best_ball] - p && y[i] == y[best_ball] - q) {\n                                cost += 0;\n                                break;\n                            }\n                        }\n                        if (remaining > 0) cost += 1;\n                    }\n                }\n            }\n            \n            min_cost = min(min_cost, cost);\n        }\n    }\n    \n    printf(\"%d\\n\", min_cost);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint comparePoints(const void *a, const void *b) {\n    Point *pointA = (Point *)a;\n    Point *pointB = (Point *)b;\n    if (pointA->x != pointB->x) {\n        return pointA->x - pointB->x;\n    }\n    return pointA->y - pointB->y;\n}\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nvoid normalize(int *dx, int *dy) {\n    if (*dx == 0 && *dy == 0) {\n        return;\n    }\n    int g = gcd(abs(*dx), abs(*dy));\n    *dx /= g;\n    *dy /= g;\n    if (*dx < 0 || (*dx == 0 && *dy < 0)) {\n        *dx = -*dx;\n        *dy = -*dy;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point *points = (Point *)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    if (N == 1) {\n        printf(\"1\\n\");\n        free(points);\n        return 0;\n    }\n\n    qsort(points, N, sizeof(Point), comparePoints);\n\n    int min_cost = INT_MAX;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            int dx = points[j].x - points[i].x;\n            int dy = points[j].y - points[i].y;\n            normalize(&dx, &dy);\n\n            int cost = 1;\n            Point current = points[j];\n            Point next;\n            next.x = current.x + dx;\n            next.y = current.y + dy;\n\n            int *collected = (int *)calloc(N, sizeof(int));\n            collected[i] = 1;\n            collected[j] = 1;\n\n            while (1) {\n                int found = 0;\n                for (int k = 0; k < N; k++) {\n                    if (!collected[k] && points[k].x == next.x && points[k].y == next.y) {\n                        collected[k] = 1;\n                        current = points[k];\n                        next.x = current.x + dx;\n                        next.y = current.y + dy;\n                        found = 1;\n                        break;\n                    }\n                }\n                if (!found) {\n                    break;\n                }\n            }\n\n            for (int k = 0; k < N; k++) {\n                if (!collected[k]) {\n                    cost++;\n                    current = points[k];\n                    next.x = current.x + dx;\n                    next.y = current.y + dy;\n\n                    collected[k] = 1;\n                    while (1) {\n                        found = 0;\n                        for (int l = 0; l < N; l++) {\n                            if (!collected[l] && points[l].x == next.x && points[l].y == next.y) {\n                                collected[l] = 1;\n                                current = points[l];\n                                next.x = current.x + dx;\n                                next.y = current.y + dy;\n                                found = 1;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            free(collected);\n            if (cost < min_cost) {\n                min_cost = cost;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", min_cost);\n    free(points);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> balls(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> balls[i].first >> balls[i].second;\n    }\n\n    if (N == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    set<pair<int, int>> pq_candidates;\n    for (int i = 1; i < N; ++i) {\n        int dx = balls[i].first - balls[0].first;\n        int dy = balls[i].second - balls[0].second;\n        if (dx == 0 && dy == 0) continue;\n        int g = __gcd(abs(dx), abs(dy));\n        if (g != 0) {\n            dx /= g;\n            dy /= g;\n        }\n        pq_candidates.insert({dx, dy});\n    }\n\n    if (pq_candidates.empty()) {\n        cout << 1 << endl;\n        return 0;\n    }\n\n    int min_cost = N;\n    for (const auto& pq : pq_candidates) {\n        int p = pq.first;\n        int q = pq.second;\n        map<pair<int, int>, int> groups;\n        for (const auto& ball : balls) {\n            int x = ball.first;\n            int y = ball.second;\n            int k = x * q - y * p;\n            int g = __gcd(p, q);\n            int a = (x * q - y * p) / g;\n            int b = q;\n            groups[{a, b}]++;\n        }\n        int current_cost = groups.size();\n        if (current_cost < min_cost) {\n            min_cost = current_cost;\n        }\n    }\n\n    cout << min_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        for (int i = 0; i < N; i++) {\n            x[i] = scanner.nextInt();\n            y[i] = scanner.nextInt();\n        }\n\n        if (N == 1) {\n            System.out.println(1);\n            return;\n        }\n\n        Set<String> diffs = new HashSet<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                int dx = x[i] - x[j];\n                int dy = y[i] - y[j];\n                int gcd = gcd(Math.abs(dx), Math.abs(dy));\n                if (gcd != 0) {\n                    dx /= gcd;\n                    dy /= gcd;\n                }\n                diffs.add(dx + \",\" + dy);\n            }\n        }\n\n        int minCost = Integer.MAX_VALUE;\n        for (String diff : diffs) {\n            String[] parts = diff.split(\",\");\n            int p = Integer.parseInt(parts[0]);\n            int q = Integer.parseInt(parts[1]);\n            Map<String, Integer> groups = new HashMap<>();\n            for (int i = 0; i < N; i++) {\n                int a = x[i] * q - y[i] * p;\n                int b = q;\n                int gcd = gcd(Math.abs(a), Math.abs(b));\n                if (gcd != 0) {\n                    a /= gcd;\n                    b /= gcd;\n                }\n                String key = a + \",\" + b;\n                groups.put(key, groups.getOrDefault(key, 0) + 1);\n            }\n            int cost = groups.size();\n            if (cost < minCost) {\n                minCost = cost;\n            }\n        }\n\n        System.out.println(minCost);\n    }\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 22:49:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int minimumCost(int[][] balls) {\n        int n = balls.length;\n        if (n <= 1) return n;\n        \n        int minCost = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int p = balls[j][0] - balls[i][0];\n                int q = balls[j][1] - balls[i][1];\n                \n                minCost = Math.min(minCost, collectBalls(balls, p, q));\n                minCost = Math.min(minCost, collectBalls(balls, -p, -q));\n            }\n        }\n        \n        return minCost;\n    }\n    \n    private int collectBalls(int[][] balls, int p, int q) {\n        Set<Integer> collected = new HashSet<>();\n        int cost = 0;\n        \n        for (int i = 0; i < balls.length; i++) {\n            if (!collected.contains(i)) {\n                int currentIndex = i;\n                int currentCost = 1;\n                \n                collected.add(currentIndex);\n                \n                for (int j = 0; j < balls.length; j++) {\n                    if (j == currentIndex) continue;\n                    \n                    if (!collected.contains(j) && \n                        balls[j][0] - balls[currentIndex][0] == p && \n                        balls[j][1] - balls[currentIndex][1] == q) {\n                        currentIndex = j;\n                        currentCost = 0;\n                        collected.add(currentIndex);\n                    }\n                }\n                \n                cost += currentCost;\n            }\n        }\n        \n        return cost;\n    }\n}",
    "timestamp": "2025-08-05 22:49:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int collectBalls(vector<vector<int>>& balls) {\n        int n = balls.size();\n        if (n <= 1) return n;\n        \n        int minCost = INT_MAX;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int p = balls[j][0] - balls[i][0];\n                int q = balls[j][1] - balls[i][1];\n                \n                if (p == 0 && q == 0) continue;\n                \n                int cost = collectWithOffset(balls, p, q);\n                minCost = min(minCost, cost);\n            }\n        }\n        \n        return minCost;\n    }\n    \nprivate:\n    int collectWithOffset(vector<vector<int>>& balls, int p, int q) {\n        set<pair<int, int>> ballSet;\n        for (auto& ball : balls) {\n            ballSet.insert({ball[0], ball[1]});\n        }\n        \n        int cost = 0;\n        pair<int, int> prev = {-1, -1};\n        \n        while (!ballSet.empty()) {\n            bool found = false;\n            for (auto it = ballSet.begin(); it != ballSet.end(); ++it) {\n                if (prev.first == -1 || \n                    (it->first - prev.first == p && it->second - prev.second == q)) {\n                    prev = *it;\n                    ballSet.erase(it);\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) {\n                for (auto it = ballSet.begin(); it != ballSet.end(); ++it) {\n                    prev = *it;\n                    ballSet.erase(it);\n                    cost++;\n                    break;\n                }\n            }\n        }\n        \n        return cost;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<int>> balls = {{1,2},{3,4},{5,6}};\n    cout << sol.collectBalls(balls) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef min_cost_to_collect_balls(balls):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    if not balls:\n        return 0\n    \n    directions = defaultdict(set)\n    \n    for i in range(len(balls)):\n        x1, y1 = balls[i]\n        for j in range(i + 1, len(balls)):\n            x2, y2 = balls[j]\n            dx = x2 - x1\n            dy = y2 - y1\n            g = gcd(dx, dy)\n            dx //= g\n            dy //= g\n            directions[(dx, dy)].add((x1, y1))\n            directions[(dx, dy)].add((x2, y2))\n            directions[(-dx, -dy)].add((x1, y1))\n            directions[(-dx, -dy)].add((x2, y2))\n\n    min_cost = float('inf')\n    for points in directions.values():\n        cost = len(set(balls)) - len(points)\n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\n# Example usage\nballs = [(0, 0), (1, 2), (2, 4), (3, 6), (5, 4)]\nprint(min_cost_to_collect_balls(balls))",
    "timestamp": "2025-08-13 12:38:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class MinimumCostCollector {\n    static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof Point)) {\n                return false;\n            }\n            Point other = (Point) obj;\n            return this.x == other.x && this.y == other.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return 31 * x + y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            x[i] = scanner.nextInt();\n            y[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n        \n        Set<String> slopes = new HashSet<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int dx = x[j] - x[i];\n                int dy = y[j] - y[i];\n                int gcd = gcd(dx, dy);\n                dx /= gcd;\n                dy /= gcd;\n                if (dy < 0 || (dy == 0 && dx < 0)) {\n                    dx = -dx;\n                    dy = -dy;\n                }\n                String slope = dx + \",\" + dy;\n                slopes.add(slope);\n            }\n        }\n        \n        System.out.println(slopes.size());\n    }\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int t = b;\n            b = a % b;\n            a = t;\n        }\n        return Math.abs(a);\n    }\n}",
    "timestamp": "2025-08-13 12:38:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Ball;\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint collectBalls(Ball balls[], int n) {\n    int minCost = n;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int dx = balls[j].x - balls[i].x;\n            int dy = balls[j].y - balls[i].y;\n\n            int g = abs(gcd(dx, dy));\n            dx /= g;\n            dy /= g;\n\n            int dxAlt = -dx;\n            int dyAlt = -dy;\n\n            int countDX = 0, countDXAlt = 0;\n\n            for (int k = 0; k < n; ++k) {\n                if ((balls[k].x - balls[i].x) % dx == 0 && (balls[k].y - balls[i].y) % dy == 0 &&\n                    (balls[k].x - balls[i].x) / dx == (balls[k].y - balls[i].y) / dy) {\n                    countDX++;\n                }\n                \n                if ((balls[k].x - balls[i].x) % dxAlt == 0 && (balls[k].y - balls[i].y) % dyAlt == 0 &&\n                    (balls[k].x - balls[i].x) / dxAlt == (balls[k].y - balls[i].y) / dyAlt) {\n                    countDXAlt++;\n                }\n            }\n            \n            minCost = minCost < n - countDX ? minCost : n - countDX;\n            minCost = minCost < n - countDXAlt ? minCost : n - countDXAlt;\n        }\n    }\n\n    return minCost;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Ball balls[N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &balls[i].x, &balls[i].y);\n    }\n    \n    printf(\"%d\\n\", collectBalls(balls, N));\n    return 0;\n}",
    "timestamp": "2025-08-13 12:38:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinCost(N, balls) {\n    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);\n\n    let minCost = N;\n  \n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            if (i === j) continue;\n\n            let p = balls[j][0] - balls[i][0];\n            let q = balls[j][1] - balls[i][1];\n            const factor = gcd(Math.abs(p), Math.abs(q));\n            p /= factor;\n            q /= factor;\n\n            const visited = new Set();\n            let cost = 0;\n\n            for (let k = 0; k < N; k++) {\n                const a = balls[k][0];\n                const b = balls[k][1];\n                const hashKey = `${a * q - b * p}`;\n                \n                if (!visited.has(hashKey)) {\n                    visited.add(hashKey);\n                    cost++;\n                }\n            }\n            \n            minCost = Math.min(minCost, cost);\n        }\n    }\n  \n    return minCost;\n}\n\n// Sample usage\nconst N = 3;\nconst balls = [[1, 1], [2, 3], [3, 2]];\nconsole.log(findMinCost(N, balls)); // Output the minimum cost",
    "timestamp": "2025-08-13 12:38:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import product\nimport math\n\ndef solve(N, coordinates):\n    min_cost = float('inf')\n    \n    for p, q in product(range(-100, 101), repeat=2):\n        if p == 0 and q == 0:\n            continue\n        \n        cost = collect_balls(N, coordinates, p, q)\n        min_cost = min(min_cost, cost)\n    \n    return min_cost\n\ndef collect_balls(N, coordinates, p, q):\n    balls = set(coordinates)\n    cost = 0\n    last_ball = None\n    \n    while balls:\n        if last_ball is None:\n            current_ball = min(balls)\n            balls.remove(current_ball)\n            last_ball = current_ball\n            cost += 1\n        else:\n            found_ball = False\n            for ball in balls:\n                if ball[0] == last_ball[0] - p and ball[1] == last_ball[1] - q:\n                    current_ball = ball\n                    balls.remove(current_ball)\n                    last_ball = current_ball\n                    found_ball = True\n                    break\n            \n            if not found_ball:\n                current_ball = min(balls)\n                balls.remove(current_ball)\n                last_ball = current_ball\n                cost += 1\n    \n    return cost\n\ndef main():\n    N = int(input())\n    coordinates = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        coordinates.append((x, y))\n    \n    result = solve(N, coordinates)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:39:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumCost(coordinates) {\n    const n = coordinates.length;\n    let minCost = Infinity;\n\n    for (let p = -100; p <= 100; p++) {\n        for (let q = -100; q <= 100; q++) {\n            if (p === 0 && q === 0) continue;\n\n            const sortedBalls = coordinates.slice().sort((a, b) => {\n                const distA = Math.abs(a[0] - p) + Math.abs(a[1] - q);\n                const distB = Math.abs(b[0] - p) + Math.abs(b[1] - q);\n                return distA - distB;\n            });\n\n            let currentCost = 0;\n            const visited = new Set();\n\n            for (const ball of sortedBalls) {\n                const key = ball[0] + ',' + ball[1];\n                if (visited.has(key)) continue;\n\n                let cost = 1;\n                for (const prev of visited) {\n                    const [prevX, prevY] = prev.split(',').map(Number);\n                    if (ball[0] - p === prevX && ball[1] - q === prevY) {\n                        cost = 0;\n                        break;\n                    }\n                }\n\n                currentCost += cost;\n                visited.add(key);\n            }\n\n            minCost = Math.min(minCost, currentCost);\n        }\n    }\n\n    return minCost;\n}",
    "timestamp": "2025-08-13 12:39:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    \n    if N == 1:\n        print(1)\n        return\n    \n    unique_pq = set()\n    \n    for i in range(N):\n        xi, yi = points[i]\n        for j in range(N):\n            if i == j:\n                continue\n            xj, yj = points[j]\n            dx = xi - xj\n            dy = yi - yj\n            g = math.gcd(dx, dy)\n            if g != 0:\n                dx //= g\n                dy //= g\n            unique_pq.add((dx, dy))\n    \n    min_cost = float('inf')\n    \n    for (p, q) in unique_pq:\n        cost = 0\n        used = set()\n        for (x, y) in points:\n            if (x - p, y - q) not in used:\n                cost += 1\n            used.add((x, y))\n        if cost < min_cost:\n            min_cost = cost\n    \n    print(min_cost)\n\nsolve()",
    "timestamp": "2025-08-13 12:39:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N = 0;\n    let points = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            N = parseInt(line);\n            lineCount++;\n        } else {\n            const [x, y] = line.split(' ').map(Number);\n            points.push({ x, y });\n            lineCount++;\n            if (lineCount > N) {\n                rl.close();\n                main();\n            }\n        }\n    });\n\n    function main() {\n        if (N === 1) {\n            console.log(1);\n            return;\n        }\n\n        const diffs = new Map();\n        for (let i = 0; i < N; i++) {\n            for (let j = 0; j < N; j++) {\n                if (i === j) continue;\n                const dx = points[i].x - points[j].x;\n                const dy = points[i].y - points[j].y;\n                const key = `${dx},${dy}`;\n                diffs.set(key, (diffs.get(key) || 0) + 1);\n            }\n        }\n\n        let maxCount = 0;\n        for (const [key, count] of diffs) {\n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n\n        console.log(N - maxCount);\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:39:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n// Hash pair for unordered_set\nstruct hash_pair {\n    template <class T1, class T2>\n    size_t operator()(const pair<T1, T2>& p) const {\n        auto hash1 = hash<T1>{}(p.first);\n        auto hash2 = hash<T2>{}(p.second);\n        return hash1 ^ hash2;\n    }\n};\n\nint minTotalCost(vector<pair<int, int>>& balls) {\n    int n = balls.size();\n    if (n == 1) return 1;  // Only one ball\n    \n    unordered_set<pair<int, int>, hash_pair> ball_set(balls.begin(), balls.end());\n    int min_cost = n;\n\n    for (int i = 0; i < n; ++i) {\n        int x1 = balls[i].first, y1 = balls[i].second;\n\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n\n            int x2 = balls[j].first, y2 = balls[j].second;\n            int p = x2 - x1;\n            int q = y2 - y1;\n\n            int current_cost = 0;\n\n            for (int k = 0; k < n; ++k) {\n                int x = balls[k].first, y = balls[k].second;\n                \n                if (ball_set.count({x - p, y - q}) == 0) {\n                    current_cost++;\n                    ball_set.insert({x, y});\n                }\n            }\n\n            min_cost = min(min_cost, current_cost);\n            ball_set.clear();\n            ball_set.insert(balls.begin(), balls.end());\n        }\n    }\n\n    return min_cost;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> balls(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> balls[i].first >> balls[i].second;\n    }\n    \n    cout << minTotalCost(balls) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:41"
  }
]